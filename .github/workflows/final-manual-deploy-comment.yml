name: Final Netlify build manual deploy comment

on:
  issue_comment:
    types: [created]
  # This is the new trigger that allows testing from a PR branch
  pull_request:
    types: [opened, synchronize]

jobs:
  deploy-preview:
    # This 'if' now runs for the 'netlify build' comment OR any 'pull_request' event
    if: |
      (github.event.comment.body == 'netlify build' && github.event.issue.pull_request)
      || github.event_name == 'pull_request'
    runs-on: ubuntu-latest

    steps:
      # New step to check if the PR is from a forked repository.
      # If the PR is from a fork, doesn't run. Only runs for branches in the main repo.
      - name: Check if PR is from a fork
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_URL="${{ github.event.issue.pull_request.url }}"
          IS_FORK=$(gh api "$PR_URL" --jq '.head.repo.fork')

          if [[ "$IS_FORK" == "true" ]]; then
            echo "ðŸ›‘ Halting: This workflow only runs for branches in the main repository, not for forks."
            exit 1
          else
            echo "âœ… PR is not from a fork. Proceeding with the job."
          fi

      - name: Check for member permission
        # Only run this check for issue_comment events (manual triggers)
        # For pull_request events, the PR author is implicitly authorized

        # ##########################################################################################
        # REMOVE THIS CONDITION AFTER TESTING THIS WORKFLOW, THIS SHOULD NOT MAKE IT TO THE MERGE
        # ##########################################################################################
        if: github.event_name == 'issue_comment'
        env:
          GH_TOKEN: ${{ secrets.DOCS_ENG_TEAM_MEMBERSHIP_CHECKER }}
        id: check_permission
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.DOCS_ENG_TEAM_MEMBERSHIP_CHECKER }}
          script: |
            const commenter = context.payload.comment.user.login;
            const org = context.repo.owner;
            const team_slugs = ['doc', 'DOCS-ENG']; // <-- add your team slugs here

            console.log(`ðŸ” Checking permissions...`);
            console.log(`ðŸ“‹ Organization: ${org}`);
            console.log(`ðŸ‘¤ Commenter: ${commenter}`);

            try {
              const user = await github.rest.users.getAuthenticated();
              console.log('ðŸ”‘ Authenticated as:', user.data.login);
              
              const scopes = await github.request('GET /user');
              console.log('ðŸŽ« Token scopes:', scopes.headers['x-oauth-scopes']);
            } catch (error) {
              console.log('âŒ Auth check failed:', error.message);
            }

            // List all teams where the commenter is a member
            async function listUserTeams() {
              try {
                const teams = await github.paginate(github.rest.teams.listForAuthenticatedUser, {});
                const userTeams = teams.filter(team => team.organization.login.toLowerCase() === org.toLowerCase());
                if (userTeams.length === 0) {
                  console.log(`âš ï¸  ${commenter} is not a member of any team in org ${org}.`);
                } else {
                  console.log(`ðŸ‘¥ ${commenter} is a member of the following teams in ${org}:`);
                  userTeams.forEach(team => {
                    console.log(`   âœ“ ${team.slug} (${team.name})`);
                  });
                }
              } catch (err) {
                console.log(`âŒ Could not list teams for user ${commenter}: ${err.message}`);
              }
            }

            await listUserTeams();

            async function isMemberOfAnyTeam() {
              for (const team_slug of team_slugs) {
                console.log(`ðŸ” Checking team_slug: ${team_slug}`);
                try {
                  const response = await github.rest.teams.getMembershipForUserInOrg({
                    org,
                    team_slug,
                    username: commenter,
                  });
                  console.log(`ðŸ“Š API response for team_slug ${team_slug}:`, JSON.stringify(response.data, null, 2));
                  if (response.data.state === 'active') {
                    console.log(`âœ… ${commenter} is an active member of the ${team_slug} team.`);
                    return true;
                  }
                } catch (error) {
                  console.log(`âš ï¸  Error object for team_slug ${team_slug}:`, JSON.stringify(error, Object.getOwnPropertyNames(error)));
                  if (error.status !== 404) {
                    console.log(`âŒ Error checking team_slug ${team_slug}: ${error.message}`);
                    core.setFailed(`Could not verify team membership for ${team_slug}: ${error.message}`);
                    return false;
                  }
                  // If 404, user is not in this team, continue to next
                  console.log(`â„¹ï¸  ${commenter} is not a member of ${team_slug} (404)`);
                }
              }
              return false;
            }

            // Properly await the async function
            const isMember = await isMemberOfAnyTeam();
            if (!isMember) {
              core.setFailed(`âŒ ${commenter} is not a member of any required team (${team_slugs.join(', ')})`);
            } else {
              console.log(`âœ… ${commenter} is authorized to trigger builds`);
            }
        
      # we use `jq` to parse the GH API response
      - name: setup jq
        uses: dcarbone/install-jq-action@v2

      - name: send request to Netlify build hook
        id: netlify_build
        env: 
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh_api_url=$(echo ${{ github.event.issue.pull_request.url || github.event.pull_request.url }} | sed 's/https:\/\/api.github.com//')
          gh_api_response=$(gh api $gh_api_url)
          branch_name=$(echo $gh_api_response | jq -r .head.ref)
          sha=$(echo $gh_api_response | jq -r .head.sha)
          pr_number=$(echo $gh_api_response | jq -r .number)

          echo "branch_name=$branch_name" >> $GITHUB_OUTPUT
          echo "pr_number=$pr_number" >> $GITHUB_OUTPUT
          echo "sha=$sha" >> $GITHUB_OUTPUT
          
          # Capture the timestamp before triggering the build
          TRIGGER_TIME=$(date -u +%s)
          echo "trigger_time=$TRIGGER_TIME" >> $GITHUB_OUTPUT
          
          echo "ðŸš€ Triggering Netlify build for branch: $branch_name"
          echo "ðŸ“ PR #$pr_number | Commit: $sha"

          curl -X POST \
          "https://api.netlify.com/build_hooks/${{ secrets.NETLIFY_BUILD_HOOK_ID }}?trigger_branch=$branch_name"'&trigger_title=Manual+deploy+preview+for+PR+%23'"$pr_number"'+-+'"$sha"
          
          echo "âœ… Build hook triggered successfully"

      # This step gets the branch name and replaces any non-alpha-numeric characters with '-' to match Netlify's URL format and capital letters to small case
      - name: Sanitize branch name for Netlify URL
        id: sanitize_branch
        run: |
          # Replace all non-alphanumeric characters with '-' and convert to lowercase
          SANITIZED_BRANCH_NAME=$(echo "${{ steps.netlify_build.outputs.branch_name }}" | sed 's/[^a-zA-Z0-9]/-/g' | tr 'A-Z' 'a-z')
          echo "name=$SANITIZED_BRANCH_NAME" >> $GITHUB_OUTPUT

      # This step now posts a comment with the dynamically constructed preview URL.
      - name: Add PR comment with preview URL
        uses: thollander/actions-comment-pull-request@v2
        with:
          message: |
            ### <span aria-hidden="true">ðŸš€</span> Netlify Preview Building!

            Build triggered for PR #${{ steps.netlify_build.outputs.pr_number }} (commit: `${{ steps.netlify_build.outputs.sha }}`)
            
            â³ Monitoring deployment status... This usually takes 10-20 minutes.
          # Removed `comment_tag` to ensure a new comment is added every time
          # comment_tag: manual-build-comment

      # Poll Netlify API to check deployment status
      - name: Poll Netlify deployment status
        id: poll_netlify
        env:
          NETLIFY_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
        run: |
          BRANCH_NAME="${{ steps.netlify_build.outputs.branch_name }}"
          TRIGGER_TIME="${{ steps.netlify_build.outputs.trigger_time }}"
          SHA="${{ steps.netlify_build.outputs.sha }}"
          MAX_WAIT_TIME=1800  # 30 minutes
          POLL_INTERVAL=90     # 90 seconds for deployment status checks
          DEPLOY_ID=""
          
          echo "ðŸ” Starting deployment tracking..."
          echo "ðŸ“Œ Branch: $BRANCH_NAME"
          echo "ðŸ“Œ Commit SHA: $SHA"
          echo "â° Trigger time: $TRIGGER_TIME"
          
          # Wait 30 seconds for Netlify to create the deployment
          echo "â³ Waiting 30 seconds for Netlify to register the deployment..."
          sleep 30
          
          # First, find the specific deployment ID that was just triggered
          echo "ðŸ”Ž Looking for the deployment triggered by this workflow run..."
          echo "----------------------------------------"
          for i in {1..10}; do
            echo "ðŸ”„ Attempt $i/10 to find deployment..."
            
            DEPLOYS=$(curl -s -H "Authorization: Bearer $NETLIFY_TOKEN" \
              "https://api.netlify.com/api/v1/sites/$NETLIFY_SITE_ID/deploys")
            
            # Find deployment matching our branch and created after trigger time
            # We look for deployments with our exact commit SHA for precision
            DEPLOY=$(echo "$DEPLOYS" | jq -r --arg branch "$BRANCH_NAME" --arg sha "$SHA" \
              '[.[] | select(.branch == $branch and (.commit_ref == $sha or .head == $sha))] | 
               sort_by(.created_at) | reverse | .[0]')
            
            if [ "$DEPLOY" != "null" ] && [ -n "$DEPLOY" ]; then
              DEPLOY_ID=$(echo "$DEPLOY" | jq -r '.id')
              CREATED_AT=$(echo "$DEPLOY" | jq -r '.created_at')
              CREATED_TIMESTAMP=$(date -d "$CREATED_AT" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%S" "$CREATED_AT" +%s 2>/dev/null || echo "$TRIGGER_TIME")
              
              # Construct the Netlify Build URL
              BUILD_URL="https://app.netlify.com/sites/${{ secrets.NETLIFY_SITE_ID }}/deploys/$DEPLOY_ID"
              
              # Check if deployment was created after (or very close to) our trigger time
              TIME_DIFF=$((CREATED_TIMESTAMP - TRIGGER_TIME))
              
              if [ $TIME_DIFF -ge -5 ]; then
                echo "âœ… Found target deployment!"
                echo "ðŸ†” Deploy ID: $DEPLOY_ID"
                echo "ðŸ”— Netlify Build URL: $BUILD_URL"
                echo "ðŸ“… Created at: $CREATED_AT"
                echo "----------------------------------------"
                break
              else
                echo "âš ï¸  Found deployment but it's too old (created ${TIME_DIFF}s before trigger)"
              fi
            fi
            
            if [ $i -lt 10 ]; then
              echo "â³ Deployment not found yet, waiting 15 seconds..."
              echo "----------------------------------------"
              sleep 15
            fi
          done
          
          if [ -z "$DEPLOY_ID" ] || [ "$DEPLOY_ID" = "null" ]; then
            echo "âŒ Could not find deployment after 10 attempts"
            echo "ðŸ”„ Falling back to branch-based tracking..."
            # Fallback: track by branch name only
            USE_FALLBACK=true
          else
            echo "ðŸŽ¯ Locked onto deployment ID: $DEPLOY_ID"
            USE_FALLBACK=false
          fi
          
          # Now poll the specific deployment until completion
          echo ""
          echo "ðŸ“Š Starting status monitoring..."
          ELAPSED_TIME=0
          
          while [ $ELAPSED_TIME -lt $MAX_WAIT_TIME ]; do
            MINUTES_ELAPSED=$(awk "BEGIN {print $ELAPSED_TIME/60}")
            echo "ðŸ”„ Checking deployment status... (â±ï¸  elapsed: ${MINUTES_ELAPSED}/30 minutes)"
            echo "----------------------------------------"
            
            if [ "$USE_FALLBACK" = "true" ]; then
              # Fallback: Get latest deployment for branch
              DEPLOYS=$(curl -s -H "Authorization: Bearer $NETLIFY_TOKEN" \
                "https://api.netlify.com/api/v1/sites/$NETLIFY_SITE_ID/deploys")
              
              DEPLOY=$(echo "$DEPLOYS" | jq -r --arg branch "$BRANCH_NAME" \
                '[.[] | select(.branch == $branch)] | sort_by(.created_at) | reverse | .[0]')
            else
              # Primary: Get specific deployment by ID
              DEPLOY=$(curl -s -H "Authorization: Bearer $NETLIFY_TOKEN" \
                "https://api.netlify.com/api/v1/sites/$NETLIFY_SITE_ID/deploys/$DEPLOY_ID")
            fi
            
            if [ "$DEPLOY" != "null" ] && [ -n "$DEPLOY" ]; then
              STATE=$(echo "$DEPLOY" | jq -r '.state')
              CURRENT_DEPLOY_ID=$(echo "$DEPLOY" | jq -r '.id')
              DEPLOY_URL=$(echo "$DEPLOY" | jq -r '.deploy_ssl_url // .ssl_url // .url')
              ERROR_MESSAGE=$(echo "$DEPLOY" | jq -r '.error_message // ""')
              
              # Construct the Netlify Build URL
              BUILD_URL="https://app.netlify.com/sites/${{ secrets.NETLIFY_SITE_ID }}/deploys/$DEPLOY_ID"
              
              # Update DEPLOY_ID if we were using fallback
              if [ "$USE_FALLBACK" = "true" ] && [ -z "$DEPLOY_ID" ]; then
                DEPLOY_ID=$CURRENT_DEPLOY_ID
                echo "ðŸ†” Deployment ID: $DEPLOY_ID"
              fi
              
              echo "ðŸ“Š Current state: $STATE"
              
              if [ "$STATE" = "ready" ]; then
                echo "âœ… Deployment successful!"
                echo "ðŸ”— Netlify Build URL: $BUILD_URL"
                echo "status=success" >> $GITHUB_OUTPUT
                echo "deploy_url=$BUILD_URL" >> $GITHUB_OUTPUT
                echo "deploy_id=$DEPLOY_ID" >> $GITHUB_OUTPUT
                exit 0
              elif [ "$STATE" = "error" ]; then
                echo "âŒ Deployment failed!"
                echo "ðŸ”— Netlify Build URL: $BUILD_URL"
                echo "ðŸ’¥ Error: $ERROR_MESSAGE"
                echo "status=failure" >> $GITHUB_OUTPUT
                echo "error_message=$ERROR_MESSAGE" >> $GITHUB_OUTPUT
                echo "deploy_id=$DEPLOY_ID" >> $GITHUB_OUTPUT
                exit 0
              elif [ "$STATE" = "building" ] || [ "$STATE" = "enqueued" ] || [ "$STATE" = "processing" ]; then
                echo "â³ Deployment in progress (state: $STATE)..."
                echo "ðŸ”— Netlify Build URL: $BUILD_URL"
              else
                echo "âš ï¸  Unknown state: $STATE"
              fi
            else
              echo "â“ No deployment data returned from Netlify API"
            fi
            
            sleep $POLL_INTERVAL
            ELAPSED_TIME=$((ELAPSED_TIME + POLL_INTERVAL))
          done
          
          echo "â±ï¸  Timeout reached after ${MAX_WAIT_TIME}s"
          echo "âš ï¸  Build is still running or Netlify is experiencing delays"
          echo "ðŸ”— Netlify Build URL: $BUILD_URL"
          echo "status=timeout" >> $GITHUB_OUTPUT

      # Post success comment
      - name: Post success comment
        if: steps.poll_netlify.outputs.status == 'success'
        uses: thollander/actions-comment-pull-request@v2
        with:
          message: |
            ### âœ… Netlify Preview Deploy Successful!

            Your preview deployment has completed successfully and is now live!

            ðŸŒ **Preview URL:** [${{ steps.poll_netlify.outputs.deploy_url }}](${{ steps.poll_netlify.outputs.deploy_url }})
            ðŸ”— **Netlify Deployment:** [View Deployment](https://app.netlify.com/sites/${{ secrets.NETLIFY_SITE_ID }}/deploys/${{ steps.poll_netlify.outputs.deploy_id }})
            ðŸ”— **GitHub Actions Job:** [View Job](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

            The preview is ready for review. Please test your changes thoroughly before merging.

      # Post failure comment
      - name: Post failure comment
        if: steps.poll_netlify.outputs.status == 'failure'
        uses: thollander/actions-comment-pull-request@v2
        with:
          message: |
            # ðŸš¨ â›” NETLIFY DEPLOYMENT FAILED â›” ðŸš¨
            
            ## âŒ **DO NOT MERGE THIS PR** âŒ
            
            The Netlify preview deployment has **FAILED**. This PR contains changes that break the build process.
            
            ### ðŸ”´ Critical Issue Details:
            
            - **Status:** Build Failed
            - **Deploy ID:** `${{ steps.poll_netlify.outputs.deploy_id }}`
            - **Error Message:** 
            ```
            ${{ steps.poll_netlify.outputs.error_message }}
            ```
            
            ðŸ”— **Netlify Deployment:** [View Deployment](https://app.netlify.com/sites/${{ secrets.NETLIFY_SITE_ID }}/deploys/${{ steps.poll_netlify.outputs.deploy_id }})
            ðŸ”— **GitHub Actions Job:** [View Job](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

            ### ðŸ› ï¸ Required Actions:
            
            1. **Review the error message above carefully**
            2. **Fix the build issues in your branch**
            3. **Test locally before pushing changes**
            4. **Trigger a new build with `netlify build` comment once fixed**
            
            ### âš ï¸ WARNING TO MAINTAINERS:
            
            **This PR has a failing build and should NOT be merged until:**
            - âœ… All build errors are resolved
            - âœ… A successful deployment preview is confirmed
            - âœ… The preview site has been manually tested
            
            ---
            
            **ðŸ”´ MERGING THIS PR IN ITS CURRENT STATE WILL BREAK PRODUCTION ðŸ”´**

      # Post timeout comment
      - name: Post timeout comment
        if: steps.poll_netlify.outputs.status == 'timeout'
        uses: thollander/actions-comment-pull-request@v2
        with:
          message: |
            ### â±ï¸ Netlify Deployment Status: Timeout
            
            âš ï¸ The deployment is taking longer than expected (>30 minutes).
            
            **Possible reasons:**
            - The build is still in progress
            - Netlify is experiencing delays
            - The build queue is backed up
            
            ðŸ”— **Netlify Deployment:** [View Deployment](https://app.netlify.com/sites/${{ secrets.NETLIFY_SITE_ID }}/deploys/${{ steps.poll_netlify.outputs.deploy_id }})
            ðŸ”— **GitHub Actions Job:** [View Job](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

            **Next steps:**
            1. Check the [Netlify dashboard](https://app.netlify.com) manually for deployment status
            2. Look for branch: `${{ steps.netlify_build.outputs.branch_name }}`
            3. If the build is still running, please wait for it to complete
            4. If needed, you can re-trigger with another `netlify build` comment
            
            **Expected preview URL (once ready):**
            https://${{ steps.sanitize_branch.outputs.name }}--docs-website-netlify.netlify.app


      # Fail the workflow if deployment failed
      - name: Fail workflow on deployment failure
        if: steps.poll_netlify.outputs.status == 'failure'
        run: |
          echo "::error::Netlify deployment failed. This PR should not be merged."
          exit 1