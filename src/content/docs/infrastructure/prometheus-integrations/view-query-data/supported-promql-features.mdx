---
title: Supported PromQL Features
tags:
  - Integrations
  - Prometheus integrations
  - View and query data
translate:
  - jp
  - kr
metaDescription: Read about how support Promethus and PromQL features.
redirects:
  - /docs/integrations/prometheus-integrations/view-query-data/supported-promql-features
  - /docs/supported-promql-features
---

New Relic supports PromQL-style queries, and our query builder offers a PromQL-style query mode that translates PromQL syntax queries into the closest NRQL approximation. Although the method of approximation means that a handful of edge cases are not fully supported, it provides coverage for an overwhelming majority of queries, supporting over 99.5% of queries across the 7.8 million top Grafana dashboard downloads.

Read on to learn about how we work with PromQL queries, as well as differences between standard PromQL and our PromQL-like query language we want you to be aware of.

<Callout variant="important">
  For general information about Prometheus queries and operators, see the [Prometheus.io](https://prometheus.io/docs/prometheus/latest/querying/operators/) documentation.
</Callout>

## Supported features [#features]

We support the following aggregation, arithmetic, mathematical, and rate-like functions. As we continue to expand support for Prometheus and PromQL, this list will be updated.

<CollapserGroup>
  <Collapser
    id=""
    title="Aggregation operators and functions"
  >
    * Aggregation operators:

      * [`avg()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`count()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`min()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`max()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`quantile()`](https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`stddev()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * `stdvar()`
      * [`sum()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`topk()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)

      Aggregation functions:

      * `histogram_quantile()`
    * `<aggregation>_over_time()` functions:

      * [`avg_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`count_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`min_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`max_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`quantile_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`stdev_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`stvar_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`sum_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
  </Collapser>

  <Collapser
    id=""
    title="Arithmetic binary operators"
  >
    * [`+` (addition)](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`-` (subtraction)](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`*` (multiplication)](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`/` (division)](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`%` (percent)](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`^` (power/exponents)](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
  </Collapser>

  <Collapser title="Logical operators">
    * [`and`](https://prometheus.io/docs/prometheus/latest/querying/operators/#logical-set-binary-operators)
    * [`or`](https://prometheus.io/docs/prometheus/latest/querying/operators/#logical-set-binary-operators)
  </Collapser>

  <Collapser
    id=""
    title="Date/time functions"
  >
    * `day_of_month()`
    * `day_of_week()`
    * [`days_in_month()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#days_in_month)
    * `hour()`
    * `minute()`
    * `month()`
    * `time()`
    * `timestamp()`
    * `year()`
  </Collapser>

  <Collapser
    id=""
    title="Mathematical functions"
  >
    * [`abs()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#abs)
    * [`ceil()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#ceil)
    * [`clamp_max()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#clamp_max)
    * [`clamp_min()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#clamp_min)
    * [`exp()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#exp)
    * [`floor()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#floor)
    * [`ln()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#ln)
    * [`log10()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#log10)
    * [`log2()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#log2)
    * [`round()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#round)
    * [`sqrt()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#sqrt)
  </Collapser>

  <Collapser
    id=""
    title="Rate-like functions"
  >
    * [`delta()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#delta)
    * [`deriv()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#deriv)
    * [`idelta()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#idelta)
    * [`increase()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#increase)
    * [`irate()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#irate)
    * [`rate()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#rate)
  </Collapser>

  <Collapser title="Predictive functions">
    * `predict_linear`
  </Collapser>

  <Collapser
    id=""
    title="Time-series selectors"
  >
    We offer support for PromQL time-series selectors including the following:

    * [instant vector selectors](https://prometheus.io/docs/prometheus/latest/querying/basics/#instant-vector-selectors)
    * [range series selectors](https://prometheus.io/docs/prometheus/latest/querying/basics/#range-vector-selectors)
    * [`offset` modifier](https://prometheus.io/docs/prometheus/latest/querying/basics/#offset-modifier)

      <Callout variant="important">
        We only support `offset` queries if every vector in the query has the same offset value.
      </Callout>
  </Collapser>
</CollapserGroup>

## PromQL troubleshooting [#troubleshooting]

This section describes differences in behavior between PromQL and our PromQL-style query behavior and how to work with and around these differences. This is particularly relevant if you want to use advanced queries and our [PromQL-style mode](/docs/query-your-data/explore-query-data/chart-builder/use-advanced-promql-mode-specify-data) in the query builder.

### Metric types

Prometheus recommendations note that you should only use some functions, like delta(), on gauges, and only use others like rate() and increase() on counters, but queries in Prometheus still work most of the time even if they donâ€™t follow those instructions.

However, because NRDB converts PromQL-style accumulating counters to `delta` counters, our implementation is unforgiving when using these functions on the wrong data type and will produce different or incorrect answers.

For this reason, it's best to follow all Prometheus recommendations when working with our PromQL-style queries, even if you don't follow these recommendations in Prometheus.

### Limits

* In order to ensure the stability and performance of our system for all users, we place some limits on what queries can be run. In all cases, we enforce a limit of 366 steps in range queries. We also default to only returning 100 timeseries from queries by default.
* If you want to see more (or fewer), you need to explicitly add a `topk()` to your query. (Note that the `topk()` implementation in our PromQL-style query is different from that of Prometheus.)
* We limit the total memory a query can use. This means that requests for large numbers of time steps or large numbers of time series may be rejected, particularly if they are combined with an aggregation like unique `count` or `quantile` which require significantly more memory to compute than simple arithmetic aggregations.

### Range vector selectors (sliding windows and smoothing behavior) [#range-vector]

We provide support for sliding window timeseries aggregations. For more information, see our [NRQL reference](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions#slide-by) and [sliding windows deep dive](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows).

For information on translating between NRQL and our PromQL-style language, see [Translate PromQL queries to NRQL](/docs/integrations/prometheus-integrations/view-query-data/translate-promql-queries-nrql).

### Query range and data scraping intervals [#query-range]

* The range of your query in PromQL must be larger than the duration of the step size of the query to avoid the error "`TIMESERIES` bucket size is larger than the current time window".
* We inspect data up to one minute old when servicing instant queries. If your scrape interval is greater than 1 minute, some queries may result in **No data found**. Avoid this by sending data at least once per minute.
* If the timeseries unit for your NRQL query is less than the scrape interval for your application, some periods will lack data, and the resulting graph may be jagged or contain peaks and valleys. In general, set the step size to your scrape interval, or higher.
