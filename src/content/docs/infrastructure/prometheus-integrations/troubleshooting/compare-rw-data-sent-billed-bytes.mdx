---
title: Compare Prometheus remote write data sent and billed bytes
tags:
  - Telemetry Data Platform
  - Prometheus remote write
  - Sent bytes vs billed bytes
  - Prometheus integration
metaDescription: "Explanation for the difference in bytes sent versus bytes stored and billed for Prometheus remote write data."
---

The size of the billed bytes from Prometheus remote write can be higher than the bytes sent to New Relic. To make sure you're not surprised by the difference, we recommend you review how data compression affects billed bytes.

## Data compression [#data-compression]

When Prometheus remote write data is sent to New Relic, it is sent [compressed](https://prometheus.io/docs/prometheus/latest/storage/#remote-storage-integrations) (for faster, lossless transmission). When ingested, that data is uncompressed and decorated so that it can be properly used with New Relic features, such as [entity synthesis](/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/#entity-synthesis). Although you should expect a difference in the compressed to uncompressed byte rate, the potential difference for Prometheus Remote Write data is important because of New Relic’s [billing model](/docs/accounts/accounts-billing/new-relic-one-pricing-billing/new-relic-one-pricing-billing/#usage-calculation). 

You are billed based on the computational effort needed to ingest your data, as well as the size of the data stored within New Relic. The decompression process and data transformations can result in the final uncompressed bytes stored being around 15x the size of its compressed counterpart. 

For example, based on a sampling of timeseries data we gathered when simulating real world traffic, you might see something like this: 

```
~124 GB/day compressed data sent = ~1.86TB uncompressed data stored
```

Below is a simulation of the byte rate changes as Prometheus read-write data moves through our system. In this case, metrics were generated by ingesting a local Prometheus server’s remote write scrape of a local node-exporter.

![Byte rate estimate total comparison](./images/byte-rate-estimate-total-comparison.png "Byte rate estimate total comparison")

Note how the Prometheus sent byte rate closely matches the remote write compressed bytes count that we record on our end just before uncompressing the data point(s). We can attribute the increased variance of the remote write compressed byte rate to the nature of processing the data through our distributed systems:

![Sent vs. compressed bytes comparison](./images/sent-vs-compressed-bytes-comparison.png "Sent vs. compressed bytes comparison")

As the data points are uncompressed, the 5-10x expansion factor is reflected in the difference between the remote write compressed data byte rate and the remote write uncompressed bytes rate, which are measurements taken right before and after data decompression.

![Uncompressed vs. compressed bytes comparison](./images/uncompressed-vs-compressed-bytes-comparison.png "Uncompressed vs. compressed bytes comparison")

Finally, as the data is transformed and enrichments are performed, the difference between the remote write uncompressed bytes and the `bytescountestimate()` can be seen below. The `bytecountestimate()` listed is a measure of byte count of the final state of the data before being stored.

![Bytecountestimate() vs. uncompressed bytes comparison](./images/bytecountestimate-vs-uncompressed-bytes-comparison.png "Bytecountestimate() vs. uncompressed bytes comparison")

To give a better understanding of the possible data transformations/additions Prometheus read-write data can go through, here's comparison of the `prometheus_remote_storage_bytes_total` metric, a measure reported by the Prometheus server. 

The first is a representation as given by Prometheus, and the second is the NRQL query counterpart. 

Prometheus server representation:

```
"prometheus_remote_storage_bytes_total" {
	"instance=""localhost:9090"
	"job=""prometheus"
	"remote_name=""5dfb33"
	"url=""https://staging-metric-api.newrelic.com/prometheus/v1/write?prometheus_server=foobarbaz"
}
23051
```

NRQL query representation

```
"endTimestamp": 1631305327668,
"instance:" "localhost:9090",
"instrumentation.name": "remote-write"
"instrumentation.provider": "prometheus",
"instrumentation.source": "foobarbaz",
"instrumentation.version": "0.0.2",
"job": "prometheus",
"metricName": "prometheus_remote_storage_bytes_total",
"newrelic.source": "prometheusAPI",
"prometheus_remote_storage_bytes_total",
"newrelic.source": "prometheusAPI",
"prometheus_remote_storage_bytes_total": {
	"type": "count",
	"count": 23051
},
"prometheus_server": "foobarbaz",
"remote_name": "5dfb33",
"timestamp": 1631305312668,
"url": "https://staging-metric-api.newrelic.com/prometheus/v1/write?prometheus_server=foobarbaz"
}
```
<Callout variant="tip">
  The above example is a simplified comparison meant to illustrate the underlying concepts, so it makes lighter than average use of labeling and featured metrics. The real-world versions will look a little different because they have more complexity.
</Callout>

## NRQL queries [#nrql-queries]

Try these NRQL queries to gather byte count information:

View estimated byte count stored at New Relic:

```
FROM Metric SELECT rate(bytecountestimate(), 1 minute) AS 'bytecountestimate()' WHERE prometheus_server = <var>INSERT_PROMETHEUS_SERVER_NAME</var> SINCE 1 hour ago TIMESERIES AUTO
```

Prometheus monitoring of bytes sent to New Relic:

```
FROM Metric SELECT rate(sum(prometheus_remote_storage_samples_bytes_total), 1 minute)  AS 'Prometheus sent bytes rate' WHERE prometheus_server = <var>INSERT_PROMETHEUS_SERVER_NAME</var> SINCE 1 hour ago TIMESERIES  AUTO 
```

## External references [#references]

Here are some external links to Prometheus and GitHub docs that clarify compression and encoding. 

* [Prometheus referencing Snappy Compression being used in encoding](https://prometheus.io/docs/prometheus/latest/storage/#overview): The read and write protocols both use a snappy-compressed protocol buffer encoding over HTTP. The protocols are not considered as stable APIs yet and may change to use gRPC over HTTP/2 in the future, when all hops between Prometheus and the remote storage can safely be assumed to support HTTP/2.

* [Prometheus Protobuf Reference](https://github.com/prometheus/prometheus/blob/main/prompb/types.proto#L58-L64)

