---
title: Elasticsearch monitoring integration
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: "New Relic's Elasticsearch integration: what data it reports and how to configure it."
redirects:
  - /docs/integrations/host-integrations/host-integrations-list/elasticsearch-monitoring-integration
  - /docs/elasticsearch-monitoring-integration
  - /docs/elasticsearchonhost-integration-new-relic-infrastructure
---

Our Elasticsearch [integration](/docs/integrations/host-integrations/getting-started/introduction-host-integrations) collects and sends inventory and metrics from your [Elasticsearch](https://www.elastic.co/) cluster to our platform, where you can see the health of your Elasticsearch environment. We collect metrics at the cluster, node, and index level so you can more easily find the source of any problems.

Read on to install the integration, and to see what data we collect.

## Compatibility and requirements [#req]

Our integration is compatible with Elasticsearch 5.x through 7.x

If Elasticsearch is **not** running on Kubernetes or Amazon ECS, you must [install the infrastructure agent](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic) on a host that's running Elasticsearch. Otherwise:

* If running on Kubernetes, see [these requirements](/docs/monitor-service-running-kubernetes#requirements).
* If running on ECS, see [these requirements](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).

## Quick start [#quick]

Instrument your Elasticsearch cluster quickly and send your telemetry data with guided install. Our guided install creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent.

![A screenshot of the guided install CLI.](./images/guided-install-cli.png "The guided install CLI.")

Ready to get started? Click one of these button to try it out.

<ButtonGroup>
<ButtonLink
  role="button"
  to="https://one.newrelic.com/launcher/nr1-core.explorer?pane=eyJuZXJkbGV0SWQiOiJucjEtY29yZS5saXN0aW5nIn0=&cards[0]=eyJuZXJkbGV0SWQiOiJucjEtaW5zdGFsbC1uZXdyZWxpYy5ucjEtaW5zdGFsbC1uZXdyZWxpYyIsInBhdGgiOiJvaGkiLCJyZWNpcGVOYW1lIjoiZWxhc3RpY3NlYXJjaC1vcGVuLXNvdXJjZS1pbnRlZ3JhdGlvbiIsImFjdGl2ZUNvbXBvbmVudCI6IlZUU09Db21tYW5kIiwiYWN0aXZlRW52aXJvbm1lbnQiOiJlbGFzdGljc2VhcmNoLW9wZW4tc291cmNlLWludGVncmF0aW9uIn0="
  variant="primary"
>
  Guided install
</ButtonLink>

<ButtonLink
  role="button"
  to="https://one.eu.newrelic.com/launcher/nr1-core.explorer?pane=eyJuZXJkbGV0SWQiOiJucjEtY29yZS5saXN0aW5nIn0=&cards[0]=eyJuZXJkbGV0SWQiOiJucjEtaW5zdGFsbC1uZXdyZWxpYy5ucjEtaW5zdGFsbC1uZXdyZWxpYyIsInBhdGgiOiJvaGkiLCJyZWNpcGVOYW1lIjoiZWxhc3RpY3NlYXJjaC1vcGVuLXNvdXJjZS1pbnRlZ3JhdGlvbiIsImFjdGl2ZUNvbXBvbmVudCI6IlZUU09Db21tYW5kIiwiYWN0aXZlRW52aXJvbm1lbnQiOiJlbGFzdGljc2VhcmNoLW9wZW4tc291cmNlLWludGVncmF0aW9uIn0="
  variant="primary"
>
  EU Guided install
</ButtonLink>
</ButtonGroup>

Our guided install uses the infrastructure agent to set up the Elasticsearch integration. Not only that, it discovers other applications and log sources running in your environment and then recommends which ones you should instrument.

The guided install works with most setups. But if it doesn't suit your needs, you can find other methods below to get started monitoring your Elasticsearch cluster.

## Install and activate [#install]

To install the Elasticsearch integration, follow the instructions for your environment:

<CollapserGroup>
  <Collapser
    id="ecs-install"
    title="ECS"
  >
    See [Monitor service running on ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
  </Collapser>

  <Collapser
    id="k8s-install"
    title="Kubernetes"
  >
    See [Monitor service running on Kubernetes](/docs/monitor-service-running-kubernetes).
  </Collapser>

  <Collapser
    id="linux-install"
    title="Linux"
  >
    1. Follow the instructions for [installing an integration](/docs/install-integrations-package), using the file name `nri-elasticsearch`.
    2. Change directory to the integrations folder:

       ```
       cd /etc/newrelic-infra/integrations.d
       ```
    3. Copy the sample configuration file:

       ```
       sudo cp elasticsearch-config.yml.sample elasticsearch-config.yml
       ```
    4. Edit the `elasticsearch-config.yml` file as described in the [configuration settings](#config).
    5. [Restart the infrastructure agent](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).
  </Collapser>

  <Collapser
    id="windows-install"
    title="Windows"
  >
    1. Download the `nri-elasticsearch` .MSI installer image from:

       [http://download.newrelic.com/infrastructure_agent/windows/integrations/nri-elasticsearch/nri-elasticsearch-amd64.msi](http://download.newrelic.com/infrastructure_agent/windows/integrations/nri-elasticsearch/nri-elasticsearch-amd64.msi)
    2. To install from the Windows command prompt, run:

       ```
       msiexec.exe /qn /i <var>PATH\TO\</var>nri-elasticsearch-amd64.msi
       ```
    3. In the Integrations directory, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, create a copy of the sample configuration file by running:

       ```
       cp elasticsearch-config.yml.sample elasticsearch-config.yml
       ```
    4. Edit the `elasticsearch-config.yml`file as described in the [configuration settings](#config).
    5. [Restart the infrastructure agent](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).
  </Collapser>
</CollapserGroup>

Additional notes:

* **Advanced:** Integrations are also available in [tarball format](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball) to allow for install outside of a package manager.
* **On-host integrations do not automatically update.** For best results, regularly [update the integration package](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) and [the infrastructure agent](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

## Configuration [#configuration]

### Configure the integration [#config]

There are several ways to configure the integration, depending on how it was installed:

* If enabled via Kubernetes: see [Monitor services running on Kubernetes](/docs/monitor-service-running-kubernetes).
* If enabled via Amazon ECS: see [Monitor services running on ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
* If installed on-host: edit the config in the integration's YAML config file, `elasticsearch-config.yml`.

An integration's YAML-format configuration is where you can place required login credentials and configure how data is collected. Which options you change depend on your setup and preference.

The configuration file has common settings applicable to all integrations, such as `interval`, `timeout`, `inventory_source`. To read all about these common settings, refer to our [Configuration Format](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) document.

<Callout variant="important">
  If you are still using our legacy configuration/definition files, please refer to this [document](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/) for help.
</Callout>

Specific settings related to Elasticsearch are defined using the `env` section of the configuration file. These settings control the connection to your Elasticsearch instance as well as other security settings and features. The list of valid settings is described in the next section of this document.

### Elasticsearch Instance Settings [#instance-settings]

The Elasticsearch integration collects both metrics(**M**) and inventory(**I**) information. In the table, use the **Applies To** column for the settings available to each collection:

<table>
  <thead>
  <tr>
    <th style={{ width: "150px" }}>
      Setting
    </th>
    <th>
      Description
    </th>
    <th>
      Default
    </th>
    <th>
      <nobr>Applies to</nobr>
    </th>
  </tr>
  </thead>

  <tbody>
  <tr>
    <td>
      **HOSTNAME**
    </td>
    <td>
      Hostname or IP where Elasticsearch is running.
    </td>
    <td>
      localhost
    </td>
    <td style={{ "text-align": "center" }}>
      M/I
    </td>
  </tr>

  <tr>
    <td>
      **LOCAL_HOSTNAME**
    </td>
    <td>
      Hostname or IP of the Elasticsearch node from which to collect inventory data. Should only be set if you do not wish to collect inventory data against localhost.
    </td>
    <td>
      localhost
    </td>
    <td style={{ "text-align": "center" }}>
      M
    </td>
  </tr>

  <tr>
    <td>
      **PORT**
    </td>
    <td>
      Port on which Elasticsearch is listening.
    </td>
    <td>
       9200
    </td>
    <td style={{ "text-align": "center" }}>
      M/I
    </td>
  </tr>

  <tr>
    <td>
      **USERNAME**
    </td>
    <td>
      Username for accessing Elasticsearch Node.
    </td>
    <td>
      N/A
    </td>
    <td style={{ "text-align": "center" }}>
      M/I
    </td>
  </tr>

  <tr>
    <td>
      **PASSWORD**
    </td>
    <td>
      Password for the given user.
    </td>
    <td>
      N/A
    </td>
    <td style={{ "text-align": "center" }}>
      M/I
    </td>
  </tr>

  <tr>
    <td>
      **CLUSTER_ENVIRONMENT**
    </td>
    <td>
      A way to further specify which cluster we are gathering data for, example: 'staging'.
    </td>
    <td>
      N/A
    </td>
    <td style={{ "text-align": "center" }}>
      M/I
    </td>
  </tr>

  <tr>
    <td>
      **USE_SSL**
    </td>
    <td>
      Use SSL when communicating with the Elasticsearch node.
    </td>
    <td>
      false
    </td>
    <td style={{ "text-align": "center" }}>
      M/I
    </td>
  </tr>

  <tr>
    <td>
      **CA_BUNDLE_FILE**
    </td>
    <td>
      Location of SSL certificate on the host. Only required if `USE_SSL` is true.
    </td>
    <td>
      N/A
    </td>
    <td style={{ "text-align": "center" }}>
      M/I
    </td>
  </tr>

  <tr>
    <td>
      **CA_BUNDLE_DIR**
    </td>
    <td>
      Alternative Certificate Authority bundle directory.
    </td>
    <td>
      N/A
    </td>
    <td style={{ "text-align": "center" }}>
      M/I
    </td>
  </tr>

  <tr>
    <td>
      **SSL_ALTERNATIVE_HOSTNAME**
    </td>
    <td>
      Alternative server hostname that the integration will accept as valid for the purposes of SSL negotiation.
    </td>
    <td>
      N/A
    </td>
    <td style={{ "text-align": "center" }}>
      M/I
    </td>
  </tr>

  <tr>
    <td>
      **TLS_INSECURE_SKIP_VERIFY**
    </td>
    <td>
      Skip the verification of the server's certificate chain and hostname.
    </td>
    <td>
      false
    </td>
    <td style={{ "text-align": "center" }}>
      M/I
    </td>
  </tr>

  <tr>
    <td>
      **CONFIG_PATH**
    </td>
    <td>
      Path to the Elasticsearch configuration file.
    </td>
    <td>
      /etc/elasticsearch/<br/>elasticsearch.yml
    </td>
    <td style={{ "text-align": "center" }}>
      I
    </td>
  </tr>

  <tr>
    <td>
      **TIMEOUT**
    </td>
    <td>
      Timeout for API requests, in seconds.
    </td>
    <td>
      30
    </td>
    <td style={{ "text-align": "center" }}>
      M/I
    </td>
  </tr>

  <tr>
    <td>
      **COLLECT_INDICES**
    </td>
    <td>
      Signals whether to collect indices metrics or not.
    </td>
    <td>
      true
    </td>
    <td style={{ "text-align": "center" }}>
      M
    </td>
  </tr>

  <tr>
    <td>
      **COLLECT_PRIMARIES**
    </td>
    <td>
      Signals whether to collect primaries metrics or not.
    </td>
    <td>
      true
    </td>
    <td style={{ "text-align": "center" }}>
      M
    </td>
  </tr>

  <tr>
    <td>
      **INDICES_REGEX**
    </td>
    <td>
      Filter which indices are collected.
    </td>
    <td>
      N/A
    </td>
    <td style={{ "text-align": "center" }}>
      M
    </td>
  </tr>

  <tr>
    <td>
      **MASTER_ONLY**
    </td>
    <td>
      Collect cluster metrics on the elected master only.
    </td>
    <td>
      false
    </td>
    <td style={{ "text-align": "center" }}>
      M
    </td>
  </tr>

  <tr>
    <td>
      **METRICS**
    </td>
    <td>
      Set to `true` to enable metrics-only collection.
    </td>
    <td>
      false
    </td>
    <td style={{ "text-align": "center" }}>
    </td>
  </tr>

  <tr>
    <td>
      **INVENTORY**
    </td>
    <td>
      Set to `true` to enable inventory-only collection.
    </td>
    <td>
      false
    </td>
    <td style={{ "text-align": "center" }}>
    </td>
  </tr>

  </tbody>
</table>

The values for these settings can be defined in several ways:
* Adding the value directly in the config file. This is the most common way.
* Replacing the values from environment variables using the `{{}}` notation. This requires infrastructure agent v1.14.0+. Read more [here](/docs/infrastructure/install-infrastructure-agent/configuration/configure-infrastructure-agent/#passthrough) or see the example [below](#envvar-replacement).
* Using secrets management. Use this to protect sensitive information, such as passwords that would be exposed in plain text on the configuration file. For more information, see [Secrets management](https://docs.newrelic.com/docs/integrations/host-integrations/installation/secrets-management).


### Labels/Custom attributes [#labels]

You can further decorate your metrics using labels. Labels allow you to add key/value pair attributes to your metrics, which you can then use to query, filter, or group your metrics on.<br/>
Our default sample config file includes examples of labels; however, as they are not mandatory, you can remove, modify, or add new ones of your choice.

```
 labels:
   env: production
   role: load_balancer
```

## Example configurations [#examples]

<CollapserGroup>
  <Collapser
    id="basic-config"
    title="Basic configuration"
  >
    This is the basic configuration used to collect metrics and inventory from your localhost:

    ```
    integrations:
      - name: nri-elasticsearch
        env:
          HOSTNAME: localhost
          PORT: 9200
          USERNAME: elasticsearch_user
          PASSWORD: elasticsearch_password
          CONFIG_PATH: /etc/elasticsearch/elasticsearch.yml
        interval: 15s
        labels:
          environment: production
        inventory_source: config/elasticsearch
    ```
  </Collapser>
  <Collapser
    id="basic-intervals"
    title="Basic configuration with different metric/inventory intervals"
  >
    This configuration collects metrics every 15 seconds and inventory every 60 seconds:

    ```
    integrations:
      - name: nri-elasticsearch
        env:
          METRICS: true
          HOSTNAME: localhost
          PORT: 9200
          USERNAME: elasticsearch_user
          PASSWORD: elasticsearch_password
          REMOTE_MONITORING: true
        interval: 15s
        labels:
          environment: production

      - name: nri-elasticsearch
        env:
          INVENTORY: true
          HOSTNAME: localhost
          PORT: 9200
          USERNAME: elasticsearch_user
          PASSWORD: elasticsearch_password
          CONFIG_PATH: /etc/elasticsearch/elasticsearch.yml
        interval: 60s
        labels:
          environment: production
        inventory_source: config/elasticsearch
    ```
  </Collapser>

  <Collapser
    id="envvar-replacement"
    title="Environment variables replacement"
  >
    In this configuration we are using the environment variable `ELASTIC_HOST` to populate the HOSTNAME setting of the integration:

    ```
    integrations:
      - name: nri-elasticsearch
        env:
          METRICS: "true"
          HOSTNAME: {{ELASTIC_HOST}}
          PORT: 9200
          USERNAME: elasticsearch_user
          PASSWORD: elasticsearch_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
    ```
  </Collapser>

  <Collapser
    id="multi-instance"
    title="Multi-instance monitoring"
  >
    In this configuration we are monitoring multiple Elasticsearch servers from the same integration. For the first instance (`HOSTNAME: 1st_elasticsearch_host`) we are collecting metrics and inventory while for the second instance (`HOSTNAME: 2nd_elasticsearch_host`) we will only collect metrics.

    ```
    integrations:
      - name: nri-elasticsearch
        env:
          METRICS: "true"
          HOSTNAME: 1st_elasticsearch_host
          PORT: 9200
          USERNAME: elasticsearch_user
          PASSWORD: elasticsearch_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
      - name: nri-elasticsearch
        env:
          INVENTORY: "true"
          HOSTNAME: /1st_elasticsearch_host
          PORT: 9200
          USERNAME: elasticsearch_user
          PASSWORD: elasticsearch_password
        interval: 60s
        labels:
          env: production
          role: load_balancer
        inventory_source: config/elasticsearch

      - name: nri-elasticsearch
        env:
          METRICS: "true"
          HOSTNAME: 2nd_elasticsearch_host
          PORT: 9200
          USERNAME: elasticsearch_user
          PASSWORD: elasticsearch_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
    ```
  </Collapser>

</CollapserGroup>

## Find and use data [#find-and-use]

Data from this service is reported to an [integration dashboard](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts).

Elasticsearch data is attached to the following [event types](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic):

* [`ElasticsearchClusterSample`](#elasticsearch-cluster-metrics)
* [`ElasticsearchNodeSample`](#elasticsearch-node-metrics)
* [`ElasticsearchCommonSample`](#elasticsearch-common-metrics)
* [`ElasticsearchIndexSample`](#elasticsearch-index-metrics)

You can [query this data](/docs/using-new-relic/data/understand-data/query-new-relic-data) for troubleshooting purposes or to create custom charts and dashboards.

For more on how to find and use your data, see [Understand integration data](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Metric data [#metrics]

The Elasticsearch integration collects the following metric data attributes. Each metric name is prefixed with a category indicator and a period, such as `cluster.` or `shards.`.

### Elasticsearch cluster metrics

These attributes are attached to the `ElasticsearchClusterSample` event type:

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Metric
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cluster.dataNodes`
      </td>

      <td>
        The number of data nodes in the cluster.
      </td>
    </tr>

    <tr>
      <td>
        `cluster.nodes`
      </td>

      <td>
        The number of nodes in the cluster.
      </td>
    </tr>

    <tr>
      <td>
        `cluster.status`
      </td>

      <td>
        The Elasticsearch cluster health: `red`, `yellow`, or `green`.
      </td>
    </tr>

    <tr>
      <td>
        `shards.active`
      </td>

      <td>
        The number of active shards in the cluster.
      </td>
    </tr>

    <tr>
      <td>
        `shards.initializing`
      </td>

      <td>
        The number of shards that are currently initializing.
      </td>
    </tr>

    <tr>
      <td>
        `shards.primaryActive`
      </td>

      <td>
        The number of active primary shards in the cluster.
      </td>
    </tr>

    <tr>
      <td>
        `shards.relocating`
      </td>

      <td>
        The number of shards that are relocating from one node to another.
      </td>
    </tr>

    <tr>
      <td>
        `shards.unassigned`
      </td>

      <td>
        The number of shards that are unassigned to a node.
      </td>
    </tr>
  </tbody>
</table>

### Elasticsearch node metrics

These attributes are attached to the `ElasticsearchNodeSample` event type:

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Metric
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `activeSearches`
      </td>

      <td>
        The number of active searches.
      </td>
    </tr>

    <tr>
      <td>
        `activeSearchesInMilliseconds`
      </td>

      <td>
        The time spent on the search fetch.
      </td>
    </tr>

    <tr>
      <td>
        `breakers.estimatedSizeFieldDataCircuitBreakerInBytes`
      </td>

      <td>
        The estimated size of the field data circuit breaker, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `breakers.estimatedSizeParentCircuitBreakerInBytes`
      </td>

      <td>
        The estimated size of the parent circuit breaker, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `breakers.estimatedSizeRequestCircuitBreakerInBytes`
      </td>

      <td>
        The estimated size of the request circuit breaker, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `breakers.fieldDataCircuitBreakerTripped`
      </td>

      <td>
        The number of times the field data circuit breaker has tripped.
      </td>
    </tr>

    <tr>
      <td>
        `breakers.parentCircuitBreakerTripped`
      </td>

      <td>
        The number of times the parent circuit breaker has tripped.
      </td>
    </tr>

    <tr>
      <td>
        `breakers.requestCircuitBreakerTripped`
      </td>

      <td>
        The number of times the request circuit breaker has tripped.
      </td>
    </tr>

    <tr>
      <td>
        `cache.cacheSizeIDInBytes`
      </td>

      <td>
        The size of the id cache, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `flush.indexFlushDisk`
      </td>

      <td>
        The number of index flushes to disk since start.
      </td>
    </tr>

    <tr>
      <td>
        `flush.timeFlushIndexDiskInSeconds`
      </td>

      <td>
        The time spent flushing the index to disk.
      </td>
    </tr>

    <tr>
      <td>
        `fs.bytesAvailableJVMInBytes`
      </td>

      <td>
        Bytes available to this Java virtual machine on this file store, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `fs.bytesReadsInBytes`
      </td>

      <td>
        The total bytes read from the file store, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `fs.bytesUserIoOperationsInBytes`
      </td>

      <td>
        The total bytes used for all I/O operations on the file store, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `fs.iOOperations`
      </td>

      <td>
        The total I/O operations on the file store.
      </td>
    </tr>

    <tr>
      <td>
        `fs.reads`
      </td>

      <td>
        The total number of reads from the file store.
      </td>
    </tr>

    <tr>
      <td>
        `fs.totalSizeInBytes`
      </td>

      <td>
        The total size of the file store, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `fs.unallocatedBytesInBytes`
      </td>

      <td>
        The total number of unallocated bytes in the file store, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `fs.writes`
      </td>

      <td>
        The total number of writes to the file store.
      </td>
    </tr>

    <tr>
      <td>
        `fs.writesInBytes`
      </td>

      <td>
        The total bytes written to the file store, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `get.currentRequestsRunning`
      </td>

      <td>
        The number of get requests currently running.
      </td>
    </tr>

    <tr>
      <td>
        `get.requestsDocumentExists`
      </td>

      <td>
        The number of get requests where the document existed.
      </td>
    </tr>

    <tr>
      <td>
        `get.requestsDocumentExistsInMilliseconds`
      </td>

      <td>
        The time spent on get requests where the document existed.
      </td>
    </tr>

    <tr>
      <td>
        `get.requestsDocumentMissing`
      </td>

      <td>
        The number of get requests where the document was missing.
      </td>
    </tr>

    <tr>
      <td>
        `get.requestsDocumentMissingInMilliseconds`
      </td>

      <td>
        The time spent on get requests where the document was missing.
      </td>
    </tr>

    <tr>
      <td>
        `get.timeGetRequestsInMilliseconds`
      </td>

      <td>
        The time spent on get requests.
      </td>
    </tr>

    <tr>
      <td>
        `get.totalGetRequests`
      </td>

      <td>
        The number of get requests.
      </td>
    </tr>

    <tr>
      <td>
        `http.currentOpenConnections`
      </td>

      <td>
        The number of current open HTTP connections.
      </td>
    </tr>

    <tr>
      <td>
        `http.openedConnections`
      </td>

      <td>
        The number of opened HTTP connections.
      </td>
    </tr>

    <tr>
      <td>
        `indexing.docsCurrentlyDeleted`
      </td>

      <td>
        The number of documents currently being deleted from an index.
      </td>
    </tr>

    <tr>
      <td>
        `indexing.documentsCurrentlyIndexing`
      </td>

      <td>
        The number of documents currently being indexed to an index.
      </td>
    </tr>

    <tr>
      <td>
        `indexing.documentsIndexed`
      </td>

      <td>
        The number of documents indexed to an index.
      </td>
    </tr>

    <tr>
      <td>
        `indexing.timeDeletingDocumentsInMilliseconds`
      </td>

      <td>
        The time spent deleting documents from an index.
      </td>
    </tr>

    <tr>
      <td>
        `indexing.timeIndexingDocumentsInMilliseconds`
      </td>

      <td>
        The time spent indexing documents to an index.
      </td>
    </tr>

    <tr>
      <td>
        `indexing.totalDocumentsDeleted`
      </td>

      <td>
        The number of documents deleted from an index.
      </td>
    </tr>

    <tr>
      <td>
        `indices.indexingOperationsFailed`
      </td>

      <td>
        The number of failed indexing operations.
      </td>
    </tr>

    <tr>
      <td>
        `indices.indexingWaitedThrottlingInMilliseconds`
      </td>

      <td>
        The time indexing waited due to throttling.
      </td>
    </tr>

    <tr>
      <td>
        `indices.memoryQueryCacheInBytes`
      </td>

      <td>
        The memory used by the query cache, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `indices.numberIndices`
      </td>

      <td>
        The number of documents across all primary shards assigned to the node.
      </td>
    </tr>

    <tr>
      <td>
        `indices.queryCacheEvictions`
      </td>

      <td>
        The number of query cache evictions.
      </td>
    </tr>

    <tr>
      <td>
        `indices.queryCacheHits`
      </td>

      <td>
        The number of query cache hits.
      </td>
    </tr>

    <tr>
      <td>
        `indices.queryCacheMisses`
      </td>

      <td>
        The number of query cache misses.
      </td>
    </tr>

    <tr>
      <td>
        `indices.recoveryOngoingShardSource`
      </td>

      <td>
        The number of ongoing recoveries for which a shard serves as a source.
      </td>
    </tr>

    <tr>
      <td>
        `indices.recoveryOngoingShardTarget`
      </td>

      <td>
        The number of ongoing recoveries for which a shard serves as a target.
      </td>
    </tr>

    <tr>
      <td>
        `indices.recoveryWaitedThrottlingInMilliseconds`
      </td>

      <td>
        The total time recoveries waited due to throttling.
      </td>
    </tr>

    <tr>
      <td>
        `indices.requestCacheEvictions`
      </td>

      <td>
        The number of request cache evictions.
      </td>
    </tr>

    <tr>
      <td>
        `indices.requestCacheHits`
      </td>

      <td>
        The number of request cache hits.
      </td>
    </tr>

    <tr>
      <td>
        `indices.requestCacheMemoryInBytes`
      </td>

      <td>
        The memory used by the request cache, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `indices.requestCacheMisses`
      </td>

      <td>
        The number of request cache misses.
      </td>
    </tr>

    <tr>
      <td>
        `indices.segmentsIndexShard`
      </td>

      <td>
        The number of segments in an index shard.
      </td>
    </tr>

    <tr>
      <td>
        `indices.segmentsMaxMemoryIndexWriterInBytes`
      </td>

      <td>
        The maximum memory used by the index writer, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `indices.segmentsMemoryUsedDocValuesInBytes`
      </td>

      <td>
        The memory used by doc values, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `indices.segmentsMemoryUsedFixedBitSetInBytes`
      </td>

      <td>
        The memory used by fixed bit set, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `indices.segmentsMemoryUsedIndexSegmentsInBytes`
      </td>

      <td>
        The memory used by index segments, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `indices.segmentsMemoryUsedIndexWriterInBytes`
      </td>

      <td>
        The memory used by the index writer, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `indices.segmentsMemoryUsedNormsInBytes`
      </td>

      <td>
        The memory used by norm, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `indices.segmentsMemoryUsedSegmentVersionMapInBytes`
      </td>

      <td>
        The memory used by the segment version map, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `indices.segmentsMemoryUsedStoredFieldsInBytes`
      </td>

      <td>
        The memory used by stored fields, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `indices.segmentsMemoryUsedTermsInBytes`
      </td>

      <td>
        The memory used by terms, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `indices.segmentsMemoryUsedTermVectorsInBytes`
      </td>

      <td>
        The memory used by term vectors, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `indices.translogOperations`
      </td>

      <td>
        The number of operations in the transaction log.
      </td>
    </tr>

    <tr>
      <td>
        `indices.translogOperationsInBytes`
      </td>

      <td>
        The size of the transaction log, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.collections`
      </td>

      <td>
        The number of garbage collections run by the JVM.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.collectionsInMilliseconds`
      </td>

      <td>
        The time spent on garbage collection in the JVM.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.concurrentMarkSweep`
      </td>

      <td>
        The number of concurrent mark & sweep GCs in the JVM.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.concurrentMarkSweepInMilliseconds`
      </td>

      <td>
        The time spent on concurrent mark & sweep GCs in the JVM.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.majorCollectionsOldGenerationObjects`
      </td>

      <td>
        The number of major GCs in the JVM that collect old generation objects.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.majorCollectionsOldGenerationObjectsInMilliseconds`
      </td>

      <td>
        The time spent in major GCs in the JVM that collect old generation objects.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.minorCollectionsYoungGenerationObjects`
      </td>

      <td>
        The number of minor GCs in the JVM that collects young generation objects.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.minorCollectionsYoungGenerationObjectsInMilliseconds`
      </td>

      <td>
        The time spent in minor GCs in the JVM that collects young generation objects.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.parallelNewCollections`
      </td>

      <td>
        The number of parallel new GCs in the JVM.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.parallelNewCollectionsInMilliseconds`
      </td>

      <td>
        The time spent on parallel new GCs in the JVM.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.mem.heapCommittedInBytes`
      </td>

      <td>
        The amount of memory guaranteed to be available to the JVM heap, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.mem.heapMaxInBytes`
      </td>

      <td>
        The maximum amount of memory that can be used by the JVM heap, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.mem.heapUsed`
      </td>

      <td>
        The percentage of memory currently used by the JVM heap as a value between `0` and `1`.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.mem.heapUsedInBytes`
      </td>

      <td>
        The amount of memory currently used by the JVM heap, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.mem.maxOldGenerationHeapInBytes`
      </td>

      <td>
        The maximum amount of memory that can be used by the old generation heap, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.mem.maxSurvivorSpaceInBytes`
      </td>

      <td>
        The maximum amount of memory that can be used by the survivor space, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.mem.maxYoungGenerationHeapInBytes`
      </td>

      <td>
        The maximum amount of memory that can be used by the young generation heap, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.mem.nonHeapCommittedInBytes`
      </td>

      <td>
        The amount of memory guaranteed to be available to JVM non-heap, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.mem.nonHeapUsedInBytes`
      </td>

      <td>
        The amount of memory currently used by the JVM non-heap, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.mem.usedOldGenerationHeapInBytes`
      </td>

      <td>
        The amount of memory currently used by the old generation heap, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.mem.usedSurvivorSpaceInBytes`
      </td>

      <td>
        The amount of memory currently used by the survivor space, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.mem.usedYoungGenerationHeapInBytes`
      </td>

      <td>
        The amount of memory currently used by the young generation heap, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.ThreadsActive`
      </td>

      <td>
        The number of active threads in the JVM.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.ThreadsPeak`
      </td>

      <td>
        The peak number of threads used by the JVM.
      </td>
    </tr>

    <tr>
      <td>
        `merges.currentActive`
      </td>

      <td>
        The number of currently active segment merges.
      </td>
    </tr>

    <tr>
      <td>
        `merges.docsSegmentsMerging`
      </td>

      <td>
        The number of documents across segments currently being merged.
      </td>
    </tr>

    <tr>
      <td>
        `merges.docsSegmentMerges`
      </td>

      <td>
        The number of documents across all merged segments.
      </td>
    </tr>

    <tr>
      <td>
        `merges.mergedSegmentsInBytes`
      </td>

      <td>
        The size of all merged segments, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `merges.segmentMerges`
      </td>

      <td>
        The number of segment merges.
      </td>
    </tr>

    <tr>
      <td>
        `merges.sizeSegmentsMergingInBytes`
      </td>

      <td>
        The size of the segments currently being merged, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `merges.totalSegmentMergingInMilliseconds`
      </td>

      <td>
        The time spent on segment merging.
      </td>
    </tr>

    <tr>
      <td>
        `openFD`
      </td>

      <td>
        The number of opened file descriptors associated with the current process, or`-1` if not supported.
      </td>
    </tr>

    <tr>
      <td>
        `queriesTotal`
      </td>

      <td>
        The number of queries.
      </td>
    </tr>

    <tr>
      <td>
        `refresh.total`
      </td>

      <td>
        The number of index refreshes.
      </td>
    </tr>

    <tr>
      <td>
        `refresh.totalInMilliseconds`
      </td>

      <td>
        The time spent on index refreshes.
      </td>
    </tr>

    <tr>
      <td>
        `searchFetchCurrentlyRunning`
      </td>

      <td>
        The number of search fetches currently running.
      </td>
    </tr>

    <tr>
      <td>
        `searchFetches`
      </td>

      <td>
        The number of search fetches.
      </td>
    </tr>

    <tr>
      <td>
        `sizeStoreInBytes`
      </td>

      <td>
        The size of the store, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.bulk.Queue`
      </td>

      <td>
        The number of queued threads in the bulk pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.bulkActive`
      </td>

      <td>
        The number of active threads in the bulk pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.bulkRejected`
      </td>

      <td>
        The number of rejected threads in the bulk pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.bulkThreads`
      </td>

      <td>
        The number of threads in the bulk pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.fetchShardStartedQueue`
      </td>

      <td>
        The number of queued threads in the fetch shard started pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.fetchShardStartedRejected`
      </td>

      <td>
        The number of rejected threads in the fetch shard started pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.fetchShardStartedThreads`
      </td>

      <td>
        The number of threads in the fetch shard started pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.fetchShardStoreActive`
      </td>

      <td>
        The number of active threads in the fetch shard store pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.fetchShardStoreQueue`
      </td>

      <td>
        The number of queued threads in the fetch shard store pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.fetchShardStoreRejected`
      </td>

      <td>
        The number of rejected threads in the fetch shard store pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.fetchShardStoreThreads`
      </td>

      <td>
        The number of threads in the fetch shard store pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.flushActive`
      </td>

      <td>
        The number of active threads in the flush queue.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.flushQueue`
      </td>

      <td>
        The number of queued threads in the flush pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.flushRejected`
      </td>

      <td>
        The number of rejected threads in the flush pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.flushThreads`
      </td>

      <td>
        The number of threads in the flush pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.forceMergeActive`
      </td>

      <td>
        The number of active threads for force merge operations.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.forceMergeQueue`
      </td>

      <td>
        The number of queued threads for force merge operations.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.forceMergeRejected`
      </td>

      <td>
        The number of rejected threads for force merge operations.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.forceMergeThreads`
      </td>

      <td>
        The number of threads for force merge operations.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.genericActive`
      </td>

      <td>
        The number of active threads in the generic pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.genericQueue`
      </td>

      <td>
        The number of queued threads in the generic pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.genericRejected`
      </td>

      <td>
        The number of rejected threads in the generic pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.genericThreads`
      </td>

      <td>
        The number of threads in the generic pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.getActive`
      </td>

      <td>
        The number of active threads in the get pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.getQueue`
      </td>

      <td>
        The number of queued threads in the get pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.getRejected`
      </td>

      <td>
        The number of rejected threads in the get pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.getThreads`
      </td>

      <td>
        The number of threads in the get pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.indexActive`
      </td>

      <td>
        The number of active threads in the index pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.indexQueue`
      </td>

      <td>
        The number of queued threads in the index pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.indexRejected`
      </td>

      <td>
        The number of rejected threads in the index pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.indexThreads`
      </td>

      <td>
        The number of threads in the index pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.listenerActive`
      </td>

      <td>
        The number of active threads in the listener pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.listenerQueue`
      </td>

      <td>
        The number of queued threads in the listener pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.listenerRejected`
      </td>

      <td>
        The number of rejected threads in the listener pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.listenerThreads`
      </td>

      <td>
        The number of threads in the listener pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.managementActive`
      </td>

      <td>
        The number of active threads in the management pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.managementQueue`
      </td>

      <td>
        The number of queued threads in the management pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.managementRejected`
      </td>

      <td>
        The number of rejected threads in the management pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.managementThreads`
      </td>

      <td>
        The number of threads in the management pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.mergeActive`
      </td>

      <td>
        The number of active threads in the merge pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.mergeQueue`
      </td>

      <td>
        The number of queued threads in the merge pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.mergeRejected`
      </td>

      <td>
        The number of rejected threads in the merge pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.mergeThreads`
      </td>

      <td>
        The number of threads in the merge pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.percolateActive`
      </td>

      <td>
        The number of active threads in the percolate pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.percolateQueue`
      </td>

      <td>
        The number of queued threads in the percolate pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.percolateRejected`
      </td>

      <td>
        The number of rejected threads in the percolate pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.percolateThreads`
      </td>

      <td>
        The number of threads in the percolate pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.refreshActive`
      </td>

      <td>
        The number of active threads in the refresh pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.refreshQueue`
      </td>

      <td>
        The number of queued threads in the refresh pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.refreshRejected`
      </td>

      <td>
        The number of rejected threads in the refresh pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.refreshThreads`
      </td>

      <td>
        The number of threads in the refresh pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.searchActive`
      </td>

      <td>
        The number of active threads in the search pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.searchQueue`
      </td>

      <td>
        The number of queued threads in the search pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.searchRejected`
      </td>

      <td>
        The number of rejected threads in the search pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.searchThreads`
      </td>

      <td>
        The number of threads in the search pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.snapshotActive`
      </td>

      <td>
        The number of active threads in the snapshot pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.snapshotQueue`
      </td>

      <td>
        The number of queued threads in the snapshot pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.snapshotRejected`
      </td>

      <td>
        The number of rejected threads in the snapshot pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.snapshotThreads`
      </td>

      <td>
        The number of threads in the snapshot pool.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool.activeFetchShardStarted`
      </td>

      <td>
        The number of active threads in the fetch shard started pool.
      </td>
    </tr>

    <tr>
      <td>
        `transport.connectionsOpened`
      </td>

      <td>
        The number of connections opened for cluster communication.
      </td>
    </tr>

    <tr>
      <td>
        `transport.packetsReceived`
      </td>

      <td>
        The number of packets received in cluster communication.
      </td>
    </tr>

    <tr>
      <td>
        `transport.packetsReceivedInBytes`
      </td>

      <td>
        The size of data received in cluster communication, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `transport.packetsSent`
      </td>

      <td>
        The number of packets sent in cluster communication.
      </td>
    </tr>

    <tr>
      <td>
        `transport.packetsSentInBytes`
      </td>

      <td>
        The size of data sent in cluster communication, in bytes.
      </td>
    </tr>
  </tbody>
</table>

### Elasticsearch common metrics

These attributes are attached to the `ElasticsearchCommonSample` event type:

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Metric
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `primaries.docsDeleted`
      </td>

      <td>
        The number of documents deleted from the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.docsnumber`
      </td>

      <td>
        The number of documents in the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.flushesTotal`
      </td>

      <td>
        The number of index flushes to disk from the primary shards since start.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.flushTotalTimeInMilliseconds`
      </td>

      <td>
        The time spent flushing the index to disk from the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.get.documentsExist`
      </td>

      <td>
        The number of get requests on primary shards where the document existed.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.get.documentsExistInMilliseconds`
      </td>

      <td>
        The time spent on get requests from the primary shards where the document existed.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.get.documentsMissing`
      </td>

      <td>
        The number of get requests from the primary shards where the document was missing.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.get.documentsMissingInMilliseconds`
      </td>

      <td>
        The time spent on get requests from the primary shards where the document was missing.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.get.requests`
      </td>

      <td>
        The number of get requests from the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.get.requestsCurrent`
      </td>

      <td>
        The number of get requests currently running on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.get.requestsInMilliseconds`
      </td>

      <td>
        The time spent on get requests from the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.index.docsCurrentlyDeleted`
      </td>

      <td>
        The number of documents currently being deleted from an index on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.index.docsCurrentlyDeletedInMilliseconds`
      </td>

      <td>
        The time spent deleting documents from an index on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.index.docsCurrentlyIndexing`
      </td>

      <td>
        The number of documents currently being indexed to an index on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.index.docsCurrentlyIndexingInMilliseconds`
      </td>

      <td>
        The time spent indexing documents to an index on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.index.docsDeleted`
      </td>

      <td>
        The number of documents deleted from an index on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.index.docsTotal`
      </td>

      <td>
        The number of documents indexed to an index on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.indexRefreshesTotal`
      </td>

      <td>
        The number of index refreshes on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.indexRefreshesTotalInMilliseconds`
      </td>

      <td>
        The time spent on index refreshes on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.merges.current`
      </td>

      <td>
        The number of currently active segment merges on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.merges.docsSegmentsCurrentlyMerged`
      </td>

      <td>
        The number of documents across segments currently being merged on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.merges.docsTotal`
      </td>

      <td>
        The number of documents across all merged segments on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.merges.SegmentsCurrentlyMergedInBytes`
      </td>

      <td>
        The size of the segments currently being merged on the primary shards, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.merges.SegmentsTotal`
      </td>

      <td>
        The number of segment merges on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.merges.segmentsTotalInBytes`
      </td>

      <td>
        The size of all merged segments on the primary shards, in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.merges.segmentsTotalInMilliseconds`
      </td>

      <td>
        The time spent on segment merging on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.queriesInMilliseconds`
      </td>

      <td>
        The time spent querying on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.queriesTotal`
      </td>

      <td>
        The number of queries to the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.queryActive`
      </td>

      <td>
        The number of currently active queries on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.queryFetches`
      </td>

      <td>
        The number of query fetches currently running on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.queryFetchesInMilliseconds`
      </td>

      <td>
        The time spent on query fetches on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.queryFetchesTotal`
      </td>

      <td>
        The number of query fetches on the primary shards.
      </td>
    </tr>

    <tr>
      <td>
        `primaries.sizeInBytes`
      </td>

      <td>
        The size of all the primary shards, in bytes.
      </td>
    </tr>
  </tbody>
</table>

### Elasticsearch index metrics

These attributes are attached to the `ElasticsearchIndexSample` event type:

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Metric
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `index.docs`
      </td>

      <td>
        The number of documents in the index.
      </td>
    </tr>

    <tr>
      <td>
        `index.docsDeleted`
      </td>

      <td>
        The number of deleted documents in the index.
      </td>
    </tr>

    <tr>
      <td>
        `index.health`
      </td>

      <td>
        The status of the index: `red`, `yellow`, or `green`.
      </td>
    </tr>

    <tr>
      <td>
        `index.primaryShards`
      </td>

      <td>
        The number of primary shards in the index.
      </td>
    </tr>

    <tr>
      <td>
        `index.primaryStoreSizeInBytes`
      </td>

      <td>
        The store size of primary shards in the index.
      </td>
    </tr>

    <tr>
      <td>
        `index.replicaShards`
      </td>

      <td>
        The number of replica shards in the index.
      </td>
    </tr>

    <tr>
      <td>
        `index.storeSizeInBytes`
      </td>

      <td>
        The store size of primary and replica shards in the index, in bytes.
      </td>
    </tr>
  </tbody>
</table>

## Inventory data [#inventory]

The Elasticsearch integration captures the configuration parameters of the Elasticsearch node, as specified in the [YAML config file](#config). It also collects node configuration information from the "\_nodes/\_local" endpoint. The data is available on the [Inventory page](/docs/infrastructure/new-relic-infrastructure/infrastructure-ui-pages/infrastructure-inventory-page-search-your-entire-infrastructure), under the **config/elasticsearch** source. For more about inventory data, see [Understand integration data](/docs/infrastructure/integrations-getting-started/getting-started/understand-integration-data-data-types#inventory-data).

## Check the source code [#source-code]

This integration is open source software. That means you can [browse its source code](https://github.com/newrelic/nri-elasticsearch "Link opens in a new window.") and send improvements, or create your own fork and build it.
