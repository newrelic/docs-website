---
title: Elasticsearch OpenTelemetry Integration
description: Comprehensive guide to monitoring Elasticsearch clusters using the OpenTelemetry Collector and New Relic.
---


The New Relic Elasticsearch OpenTelemetry (OTel) integration provides a standardized, vendor-neutral observability solution. By leveraging the OpenTelemetry Collector, you gain a unified pipeline for metrics and logs that is high-performance, future-proof, and natively integrated into the New Relic platform.

<img
  title="Elasticsearch OTEL"
  alt="Elasticsearch OTEL"
  src="/images/elasticsearch-otel-solution.png"
/>

## Why Choose This Solution?

Monitoring a distributed system like Elasticsearch requires deep insights into the application, the JVM, and the underlying host. This OTel-based solution offers:

* **Zero Vendor Lock-in:** Use industry-standard OTLP protocols. Your instrumentation remains valid regardless of your backend provider.
* **Unified Signal Correlation:** By using a single collector for both metrics and logs, you can correlate performance spikes directly to specific log entries.
* **Performance Optimization:** Built-in batching and cardinality reduction ensure minimal CPU/Memory impact on your Elasticsearch nodes.
* **Full Stack Visibility:** Automatically collects Host-level metrics (CPU/Disk/Network) alongside Elasticsearch data.

---

## Metrics collected by the integration [#metrics]

The tables below show the metrics that New Relic enables by default to power the Elasticsearch OpenTelemetry dashboards.

> **Note:** For the complete catalog of metrics that the collectors can emit, see the official OpenTelemetry receiver documentation in the [`elasticsearchreceiver`](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/elasticsearchreceiver) and [`hostmetricsreceiver`](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/hostmetricsreceiver) directories.

<CollapserGroup>
  <Collapser id="cluster-core" title="Cluster health & circuit breaker metrics (elasticsearchreceiver)">
    <table>
      <thead>
        <tr>
          <th style={{ width: "260px" }}>Metric</th>
          <th>Description</th>
          <th style={{ width: "240px" }}>Attributes</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>`elasticsearch.breaker.tripped`</td>
          <td>Total breaker trips preventing OOM events.</td>
          <td><InlineCode>name</InlineCode> (breaker name)</td>
        </tr>
        <tr>
          <td>`elasticsearch.cluster.data_nodes`</td>
          <td>Count of data nodes in the cluster.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.cluster.health`</td>
          <td>Overall cluster health status.</td>
          <td><InlineCode>status</InlineCode> (green | yellow | red)</td>
        </tr>
        <tr>
          <td>`elasticsearch.cluster.in_flight_fetch`</td>
          <td>Shard fetch operations still in flight.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.cluster.nodes`</td>
          <td>Total cluster node count.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.cluster.pending_tasks`</td>
          <td>Pending cluster-level tasks awaiting execution.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.cluster.shards`</td>
          <td>Shard counts by lifecycle state.</td>
          <td><InlineCode>state</InlineCode> (active, active_primary, relocating, initializing, unassigned, unassigned_delayed)</td>
        </tr>
        <tr>
          <td>`elasticsearch.cluster.state_update.time`</td>
          <td>Cumulative time spent updating cluster state.</td>
          <td>
            <InlineCode>state</InlineCode> (any) <br />
            <InlineCode>type</InlineCode> (computation, context_construction, commit, completion, master_apply, notification)
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="index-metrics" title="Index activity metrics (elasticsearchreceiver)">
    <table>
      <thead>
        <tr>
          <th style={{ width: "260px" }}>Metric</th>
          <th>Description</th>
          <th style={{ width: "260px" }}>Attributes</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>`elasticsearch.index.documents`</td>
          <td>Documents per index, split by state.</td>
          <td>
            <InlineCode>state</InlineCode> (active | deleted)<br />
            <InlineCode>aggregation</InlineCode> (primary_shards | total)
          </td>
        </tr>
        <tr>
          <td>`elasticsearch.index.operations.merge.current`</td>
          <td>Active segment merge operations.</td>
          <td><InlineCode>aggregation</InlineCode> (primary_shards | total)</td>
        </tr>
        <tr>
          <td>`elasticsearch.index.operations.time`</td>
          <td>Time spent on index-level operations.</td>
          <td>
            <InlineCode>operation</InlineCode> (index, delete, get, query, fetch, scroll, suggest, merge, refresh, flush, warmer)<br />
            <InlineCode>aggregation</InlineCode> (primary_shards | total)
          </td>
        </tr>
        <tr>
          <td>`elasticsearch.indexing_pressure.memory.total.primary_rejections`</td>
          <td>Cumulative primary-stage indexing rejections.</td>
          <td>—</td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="node-activity" title="Node activity & workload metrics (elasticsearchreceiver)">
    <table>
      <thead>
        <tr>
          <th style={{ width: "260px" }}>Metric</th>
          <th>Description</th>
          <th style={{ width: "260px" }}>Attributes</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>`elasticsearch.node.cache.count`</td>
          <td>Query cache hits and misses across node shards.</td>
          <td><InlineCode>type</InlineCode> (hit | miss)</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.cache.evictions`</td>
          <td>Node cache evictions.</td>
          <td><InlineCode>cache_name</InlineCode> (fielddata | query)</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.cache.memory.usage`</td>
          <td>Cache memory usage in bytes.</td>
          <td><InlineCode>cache_name</InlineCode> (fielddata | query)</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.cluster.io`</td>
          <td>Internal cluster network I/O in bytes.</td>
          <td><InlineCode>direction</InlineCode> (received | sent)</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.documents`</td>
          <td>Documents hosted by the node.</td>
          <td><InlineCode>state</InlineCode> (active | deleted)</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.disk.io.read`</td>
          <td>Disk read throughput (KiB) across file stores.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.disk.io.write`</td>
          <td>Disk write throughput (KiB) across file stores.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.fs.disk.available`</td>
          <td>Disk available to the JVM.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.fs.disk.total`</td>
          <td>Total disk capacity on the node.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.http.connections`</td>
          <td>HTTP connections served by the node.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.ingest.documents.current`</td>
          <td>Documents currently being ingested.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.ingest.operations.failed`</td>
          <td>Cumulative ingest failures.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.open_files`</td>
          <td>Open file descriptors in use.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.operations.completed`</td>
          <td>Operations completed by the node.</td>
          <td><InlineCode>operation</InlineCode> (index, delete, get, query, fetch, scroll, suggest, merge, refresh, flush, warmer)</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.operations.current`</td>
          <td>Operations currently in progress.</td>
          <td><InlineCode>operation</InlineCode> (same set)</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.operations.get.completed`</td>
          <td>GET hits and misses.</td>
          <td><InlineCode>result</InlineCode> (hit | miss)</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.operations.get.time`</td>
          <td>Time spent serving GET hits/misses.</td>
          <td><InlineCode>result</InlineCode> (hit | miss)</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.operations.time`</td>
          <td>Time spent on node-level operations.</td>
          <td><InlineCode>operation</InlineCode> (index, delete, get, query, fetch, scroll, suggest, merge, refresh, flush, warmer)</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.shards.reserved.size`</td>
          <td>Predicted shard growth due to recoveries.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.node.thread_pool.tasks.finished`</td>
          <td>Tasks finished (or rejected) per thread pool.</td>
          <td>
            <InlineCode>thread_pool_name</InlineCode> (any)<br />
            <InlineCode>state</InlineCode> (rejected | completed)
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="jvm-metrics" title="JVM & OS metrics reported by Elasticsearch (elasticsearchreceiver)">
    <table>
      <thead>
        <tr>
          <th style={{ width: "260px" }}>Metric</th>
          <th>Description</th>
          <th style={{ width: "260px" }}>Attributes</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>`elasticsearch.os.cpu.load_avg.1m`</td>
          <td>One-minute OS load average.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.os.cpu.load_avg.5m`</td>
          <td>Five-minute OS load average.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.os.cpu.load_avg.15m`</td>
          <td>Fifteen-minute OS load average.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`elasticsearch.os.memory`</td>
          <td>Physical memory usage as seen by Elasticsearch.</td>
          <td><InlineCode>state</InlineCode> (free | used)</td>
        </tr>
        <tr>
          <td>`jvm.gc.collections.count`</td>
          <td>Total garbage collection runs.</td>
          <td><InlineCode>name</InlineCode> (collector name)</td>
        </tr>
        <tr>
          <td>`jvm.gc.collections.elapsed`</td>
          <td>Time spent in garbage collection.</td>
          <td><InlineCode>name</InlineCode> (collector name)</td>
        </tr>
        <tr>
          <td>`jvm.memory.heap.max`</td>
          <td>Maximum heap memory available.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`jvm.memory.heap.used`</td>
          <td>Heap memory currently in use.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`jvm.memory.heap.utilization`</td>
          <td>Heap utilization ratio.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`jvm.threads.count`</td>
          <td>Active JVM thread count.</td>
          <td>—</td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="hostmetrics" title="Host infrastructure metrics (hostmetricsreceiver)">
    <table>
      <thead>
        <tr>
          <th style={{ width: "280px" }}>Metric</th>
          <th>Description</th>
          <th style={{ width: "220px" }}>Attributes</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>`system.cpu.utilization`</td>
          <td>Normalized CPU utilization per core.</td>
          <td>
            <InlineCode>cpu</InlineCode> (logical CPU)<br />
            <InlineCode>state</InlineCode> (user, system, idle, nice, iowait, steal)
          </td>
        </tr>
        <tr>
          <td>`system.cpu.time`</td>
          <td>Cumulative CPU time split by state.</td>
          <td>
            <InlineCode>cpu</InlineCode> (logical CPU)<br />
            <InlineCode>state</InlineCode> (same set as above)
          </td>
        </tr>
        <tr>
          <td>`system.cpu.load_average.1m`</td>
          <td>One-minute system load average.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`system.cpu.load_average.5m`</td>
          <td>Five-minute system load average.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`system.cpu.load_average.15m`</td>
          <td>Fifteen-minute system load average.</td>
          <td>—</td>
        </tr>
        <tr>
          <td>`system.memory.usage`</td>
          <td>Bytes of memory in each state.</td>
          <td><InlineCode>state</InlineCode> (used, free, cached, buffers)</td>
        </tr>
        <tr>
          <td>`system.memory.utilization`</td>
          <td>Memory utilization ratio.</td>
          <td><InlineCode>state</InlineCode> (used)</td>
        </tr>
        <tr>
          <td>`system.disk.io`</td>
          <td>Disk I/O throughput per device.</td>
          <td>
            <InlineCode>device</InlineCode> (disk)<br />
            <InlineCode>direction</InlineCode> (read | write)
          </td>
        </tr>
        <tr>
          <td>`system.disk.operations`</td>
          <td>Disk operations per device.</td>
          <td>
            <InlineCode>device</InlineCode><br />
            <InlineCode>direction</InlineCode> (read | write)
          </td>
        </tr>
        <tr>
          <td>`system.filesystem.usage`</td>
          <td>Filesystem capacity by state.</td>
          <td>
            <InlineCode>device</InlineCode><br />
            <InlineCode>state</InlineCode> (used | free | reserved)
          </td>
        </tr>
        <tr>
          <td>`system.filesystem.utilization`</td>
          <td>Filesystem utilization ratio.</td>
          <td>
            <InlineCode>device</InlineCode><br />
            <InlineCode>state</InlineCode> (used)
          </td>
        </tr>
        <tr>
          <td>`system.network.io`</td>
          <td>Network bytes per interface.</td>
          <td>
            <InlineCode>interface</InlineCode><br />
            <InlineCode>direction</InlineCode> (receive | transmit)
          </td>
        </tr>
        <tr>
          <td>`system.network.packets`</td>
          <td>Network packets per interface.</td>
          <td>
            <InlineCode>interface</InlineCode><br />
            <InlineCode>direction</InlineCode> (receive | transmit)
          </td>
        </tr>
        <tr>
          <td>`process.cpu.utilization`</td>
          <td>Percentage of total CPU time used by the process since last scrape, expressed as a value between 0 and 1.</td>
          <td>
            <InlineCode>process.pid</InlineCode> (PID)<br />
            <InlineCode>process.executable.name</InlineCode> (binary name)<br />
            <InlineCode>process.owner</InlineCode> (user)<br />
            <InlineCode>state</InlineCode> (user | system | other)
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## Resource Attributes [#resource-attributes]

The following attributes are attached to all metrics to provide identity context within New Relic:

<table>
  <thead>
    <tr>
      <th style={{ width: "250px" }}>Name</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`elasticsearch.cluster.name`</td>
      <td>The name of the elasticsearch cluster.</td>
    </tr>
  </tbody>
</table>

---

## Alerts [#alerts]

To create alert conditions in New Relic:

1. Open [one.newrelic.com > Alerts > Alert Conditions](https://onenr.io/01wZ8MEgZj6).
2. Click **Create condition**.
3. Configure the alert using either **Guided mode** or the **NRQL** query builder.

The alert configurations below are recommended to achieve robust Elasticsearch monitoring.

<CollapserGroup>
  <Collapser id="recommended-alerts" title="Recommended Alert Conditions">
    <table>
      <thead>
        <tr>
          <th style={{ width: "250px" }}>Alert Name</th>
          <th>Threshold Rationale (Example Condition)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>**Unassigned Shards Alert**</td>
          <td>Metric `elasticsearch.cluster.shards` (where `state = 'unassigned'`) is above 0 for at least 5 minutes.</td>
        </tr>
        <tr>
          <td>**Healthy Data Nodes Alert**</td>
          <td>Metric `elasticsearch.cluster.data_nodes` is below your minimum required node count for at least 5 minutes.</td>
        </tr>
        <tr>
          <td>**Heap Usage Too High Alert**</td>
          <td>Heap usage percentage (Used/Max) is above 90% for at least 5 minutes.</td>
        </tr>
        <tr>
          <td>**Pending Tasks Alert**</td>
          <td>Metric `elasticsearch.cluster.pending_tasks` is above 5 for at least 5 minutes.</td>
        </tr>
        <tr>
          <td>**Query Time Slow Alert**</td>
          <td>95th percentile of `elasticsearch.node.operations.time` is above 5ms for at least 2 minutes.</td>
        </tr>
        <tr>
          <td>**Initializing Shards Too Long**</td>
          <td>Metric `elasticsearch.cluster.shards` (where `state = 'initializing'`) is above 0 for at least 5 minutes.</td>
        </tr>
        <tr>
          <td>**Relocating Shards Too Long**</td>
          <td>Metric `elasticsearch.cluster.shards` (where `state = 'relocating'`) is above 0 for at least 5 minutes.</td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>