---
title: Kafka monitoring integration
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: "New Relic's Kafka integration: how to install it and configure it, and what data it reports."
redirects:
  - /docs/integrations/host-integrations/host-integrations-list/kafka-monitoring-integration
  - /docs/kafka-integration-new-relic-infrastructure
  - /docs/infrastructure/host-integrations/host-integrations-list/kafka-monitoring-integration
dataSource: kafka
---

import osLinux from 'images/os_icon_linux.png'

import osWindows from 'images/os_icon_windows.png'

import osEcs from 'images/os_icon_ecs.png'

import osk8 from 'images/os_icon_k8.png'

The New Relic Kafka [on-host integration](/docs/integrations/host-integrations/getting-started/introduction-host-integrations) reports metrics and configuration data from your Kafka service. We instrument all the key elements of your cluster, including brokers (both ZooKeeper and Bootstrap), producers, consumers, and topics.

To install the Kafka monitoring integration, you must run through the following steps:

1. [Prepare for the installation](#prepare).
2. [Install and activate the integration](#install).
3. [Configure the integration](#config).
4. [Find and use data](#find-and-use).
5. Optionally, see [Kafka's configuration settings](/docs/infrastructure/host-integrations/host-integrations-list/kafka/kafka-config).

<Callout variant="tip">
To read about best practices when monitoring Kafka, check [this blogpost](https://newrelic.com/blog/best-practices/new-relic-kafkapocalypse).
</Callout>

## Compatibility and requirements [#req]

### Kafka versions [#kafka-versions]

Our integration is compatible with Kafka version 3 or lower.

Please note [Apache Kafka EOL Policy](https://cwiki.apache.org/confluence/display/KAFKA/Time+Based+Release+Plan#TimeBasedReleasePlan-WhatIsOurEOLPolicy) you may experience unexpected results if you use an [End of Life](https://docs.confluent.io/platform/current/installation/versions-interoperability.html#cp-and-apache-ak-compatibility) Kafka version.

### Supported operating systems [#supported-os]

* Windows <img style={{ width: '32px', height: '32px'}} class="inline" title="Windows" alt="Windows" src={osWindows}/>
* Linux <img style={{ width: '32px', height: '32px'}} class="inline" title="Linux" alt="Linux" src={osLinux}/>

For a comprehensive list of specific Windows and Linux versions, check the table of [compatible operating systems](/docs/infrastructure/install-infrastructure-agent/get-started/requirements-infrastructure-agent/#operating-systems).

### System requirements [#system-reqs]

* A New Relic account. Don't have one? [Sign up for free!](https://newrelic.com/signup) No credit card required.
* If Kafka is not running on Kubernetes or Amazon ECS, you can [install the infrastructure agent](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic) on a Linux or Windows OS host or on a host capable of remotely accessing where Kafka is installed. Otherwise:
  * If running on <img style={{ width: '32px', height: '32px'}} class="inline" title="Kubernetes" alt="Kubernetes" src={osk8}/>Kubernetes, see [these requirements](/docs/monitor-service-running-kubernetes#requirements).
  * If running on <img style={{ width: '32px', height: '32px'}} class="inline" title="ECS" alt="ECS" src={osEcs}/>Amazon ECS, see [these requirements](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
* Java version 8 or higher.
* JMX enabled on all brokers.
* Java-based consumers and producers only, and with JMX enabled.
* Total number of monitored topics must be fewer than 10000.

### Connectivity requirements [#connectivity-requirements]

The integration needs to be configured and allowed to connect to:

* Hosts listed in `zookeeper_hosts` over the Zookeeper protocol, using the Zookeeper authentication mechanism, if `autodiscover_strategy` is set to `zookeeper`.
* Hosts defined in `bootstrap_broker_host` over the Kafka protocol, using the Kafka broker's authentication/transport mechanisms, if `autodiscover_strategy` is set to `bootstrap`.
* All brokers in the cluster over the Kafka protocol and port, using the Kafka brokers' authentication/transport mechanisms.
* All brokers in the cluster over the JMX protocol and port, using the authentication/transport mechanisms specified in the JMX configuration of the brokers.
* All producers/consumers specified in producers and consumers over the JMX protocol and port, if you want producer/consumer monitoring. JMX settings for the consumer must be the same as for the brokers.

<Callout variant="important">
  By default, security groups and their equivalents in other cloud providers, in AWS don't have the required ports open by default. JMX requires two ports in order to work: the JMX port and the RMI port. These can be set to the same value when configuring the JVM to enable JMX and must be open for the integration to be able to connect to and collect metrics from brokers.
</Callout>

## Prepare for the installation [#prepare]

Kafka is a complex piece of software that is built as a distributed system. For this reason, you need to ensure that the integration can contact all the required hosts and services so the data is collected correctly.

<CollapserGroup>
  <Collapser
    id="autodiscovery"
    title="Autodiscovery"
  >
    Given the distributed nature of Kafka, the actual number and list of brokers is usually not fixed by the configuration, and it is instead quite dynamic. For this reason, the Kafka integration offers two mechanisms to perform automatic discovery of the list of brokers in the cluster: Bootstrap and Zookeeper. The mechanism you use depends on the setup of the Kafka cluster being monitored.

    ### Bootstrap


    With the [bootstrap mechanism](#bootstrap), the integration uses a bootstrap broker to perform the autodiscovery. This is a broker whose address is well known and that will be asked for any other brokers it is aware of. The integration needs to be able to contact this broker in the address provided in the bootstrap_broker_host parameter for bootstrap discovery to work.

    ### Zookeeper

    Alternatively, the Kafka integration can also talk to a [Zookeeper server](#zookeeper) in order to obtain the list of brokers. To do this, the integration needs to be provided with the following:

    * The list of Zookeeper hosts, `zookeeper_hosts`, to contact.
    * The proper authentication secrets to connect with the hosts.

      Together with the list of brokers it knows about, Zookeeper will also advertise which connection mechanisms are supported by each broker.

      You can configure the Kafka integration to try directly with one of these mechanisms with the `preferred_listener` parameter. If this parameter is not provided, the integration will try to contact the brokers with all the advertised configurations until one of them succeeds.

      <Callout variant="tip">
        The integration will use Zookeeper only for discovering brokers and will not retrieve metrics from it.
      </Callout>
  </Collapser>

  <Collapser
    id="topic-listing"
    title="Topic listing"
  >
    To correctly list the topics processed by the brokers, the integration needs to contact brokers over the Kafka protocol. Depending on how the brokers are configured, this might require setting up SSL and/or SASL to match the broker configuration. The topics must have DESCRIBE access.
  </Collapser>

  <Collapser
    id="broker-monitoring"
    title="Broker monitoring (JMX)"
  >
    The Kafka integration queries JMX, a standard Java extension for exchanging metrics in Java applications. JMX is not enabled by default in Kafka brokers, and you need to enable it for metrics collection to work properly. JMX requires RMI to be enabled, and the RMI port needs to be set to the same port as JMX.

    You can configure JMX to use username/password authentication, as well as SSL. If such features have been enabled in the broker's JMX settings, you need to configure the integration accordingly.

    If autodiscovery is set to bootstrap, the JMX settings defined for the bootstrap broker will be applied for all other discovered brokers, so the Port and other settings should be the same on all the brokers.
    <Callout variant="important">We don't recommend enabling anonymous and/or unencrypted JMX/RMI access on public or untrusted network segments because this poses a big security risk.</Callout>
  </Collapser>

  <Collapser
    id="consumer-offset"
    title="Consumer offset"
  >
    The offset of the consumer and consumer groups of the topics as well as the lag, can be retrieved as a [KafkaOffsetSample](/docs/infrastructure/host-integrations/host-integrations-list/kafka/kafka-config/#KafkaOffsetSample-collection) with the `CONSUMER_OFFSET=true` flag but should be in a separate instance because when this flag is activated the instance will not collect other Samples.
  </Collapser>

  <Collapser
    id="producer"
    title="Producer and consumer monitoring (JMX)"
  >
    Producers and consumers written in Java can also be monitored to get more specific metadata through the same mechanism (JMX). This will generate [KafkaConsumerSamples and KafkaProducerSamples](#KafkaConsumerSample-collection). JMX needs to be enabled and configured on those applications where it is not enabled by default.

    Non-Java producers and consumers do not support JMX and are therefore not supported by the Kafka integration.
  </Collapser>
</CollapserGroup>

## Install and activate the integration [#install]

To install the Kafka integration, follow the instructions for your environment:

### Linux installation [#linux-install]

1. Follow the instructions for [installing an integration](/docs/install-integrations-package), and replace the `INTEGRATION_FILE_NAME` variable with `nri-kafka`. 

2. Change the directory to the integrations configuration folder by running:
   ```shell
   cd /etc/newrelic-infra/integrations.d
   ```

3. Copy the sample configuration file by running:
   ```shell
   sudo cp kafka-config.yml.sample kafka-config.yml
   ```

4. Edit the `kafka-config.yml` configuration file with your favorite editor. Check out some [great configuration file examples.](#examples).

5. Restart the infrastructure agent. See how to [restart the infrastructure agent in different Linux environments](/docs/infrastructure/install-infrastructure-agent/manage-your-agent/start-stop-restart-infrastructure-agent/#linux).

### Other environments [#other-env]

<CollapserGroup>
  <Collapser
    id="windows-install"
    title={<><img src={osWindows} title="Windows installation" alt="Windows installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }}/> Windows installation</>}
  >
    1. [Download the .MSI installer image for New Relic's Kafka integration](http://download.newrelic.com/infrastructure_agent/windows/integrations/nri-kafka/nri-kafka-amd64.msi).

    2. Install New Relic's Kafka integration by opening command prompt and running:
       ```shell
       msiexec.exe /qn /i $PATH_TO\nri-kafka-amd64.msi
       ```

    3. In the Integrations directory, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, create a copy of the sample configuration file by running:
       ```shell
       cp kafka-config.yml.sample kafka-config.yml
       ```

    4. Edit the `kafka-config.yml` file by using one of the [`kafka-config.yml` sample files](#examples).

    5. Restart the infrastructure agent. See how to [restart the infrastructure agent in different Linux environments](/docs/infrastructure/install-infrastructure-agent/manage-your-agent/start-stop-restart-infrastructure-agent/#linux).
  </Collapser>

  <Collapser
    id="ecs-install"
    title={<>
      <img
        src={osEcs}
        title="Amazon ECS installation"
        alt="Amazon ECS installation"
        style={{ height: '32px', width: '32px', verticalAlign: 'middle' }}
      />{' '}
      Amazon ECS installation
    </>}
  >
    See [Monitor service running on ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
  </Collapser>

  <Collapser
    id="k8s-install"
    title={<><img src={osk8} title="Kubernetes installation" alt="Kubernetes installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }}/> Kubernetes installation</>}
  >
    See [Monitor service running on Kubernetes](/docs/monitor-service-running-kubernetes).
  </Collapser>
</CollapserGroup>

Additional notes:

* **Advanced:** Integrations are also available in [tarball format](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball) to allow for install outside of a package manager.
* **On-host integrations do not automatically update.** For best results, regularly [update the integration package](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) and [the infrastructure agent](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

<InstallFeedback />

## Configure the integration [#config]

There are several ways to configure the integration, depending on how it was installed:

* If enabled via <img style={{ width: '32px', height: '32px'}} class="inline" title="Kubernetes" alt="Kubernetes" src={osk8}/>Kubernetes, see [Monitor services running on Kubernetes](/docs/monitor-service-running-kubernetes).
* If enabled via <img style={{ width: '32px', height: '32px'}} class="inline" title="ECS" alt="ECS" src={osEcs}/>Amazon ECS, see [Monitor services running on ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
* If installed on-host, edit the config in the integration's YAML config file, `kafka-config.yml`. An integration's YAML-format configuration is where you can place required login credentials and configure how data is collected. Which options you change depend on your setup and preference. The configuration file has common settings applicable to all integrations like `interval`, `timeout`, `inventory_source`. To read all about these common settings refer to our [Configuration Format](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) document.

<Callout variant="important">
  If you are still using our Legacy configuration and definition files, refer to this [document](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/) for help.
</Callout>

As with other integrations, one `kafka-config.yml` configuration file can have many instances of the integration collecting different brokers, consumers and producers metrics. You can see config examples with one or multiple instances in the [`kafka-config.yml` sample files](#examples)

Specific settings related to Kafka are defined using the `env` section of each instance in the `kafka-config.yml` configuration file. These settings control the connection to your Brokers, Zookeeper, and JMX as well as other security settings and features. The list of valid settings is described in [Kafka's configuration settings](/docs/infrastructure/host-integrations/host-integrations-list/kafka/kafka-config).

The integration has two modes of operation on each instance, which are mutually exclusive, that you can set up with the `CONSUMER_OFFSET` parameter:

* Consumer offset collection: set `CONSUMER_OFFSET = true` to collect [KafkaOffsetSample](/docs/infrastructure/host-integrations/host-integrations-list/kafka/kafka-config/#KafkaOffsetSample-collection).
* Core collection mode: set `CONSUMER_OFFSET = false` to collect the rest of the samples: [KafkaBrokerSample, KafkaTopicSample](/docs/infrastructure/host-integrations/host-integrations-list/kafka/kafka-config/#broker-collection), [KafkaProducerSample, KafkaConsumerSample](/docs/infrastructure/host-integrations/host-integrations-list/kafka/kafka-config/#KafkaConsumerSample-collection).

<Callout variant="important">
  These modes are are mutually exclusive because consumer offset collection takes a long time to run and has high performance requirements, in order to collect both groups of Samples, set two instances, one with each mode.
</Callout>

The values for these settings can be defined in several ways:

- Adding the value directly in the config file. This is the most common way.
- Replacing the values from environment variables using the `{{ }}` notation. Read more about [using environment variable passthroughs with on-host integrations](/docs/infrastructure/install-infrastructure-agent/configuration/configure-infrastructure-agent/#passthrough) or see the example for [environment variables replacement](/docs/infrastructure/host-integrations/host-integrations-list/elasticsearch/elasticsearch-integration#envvar-replacement).
<Callout variant="important">
  This requires infrastructure agent v1.14.0+.
</Callout>

- Using secrets management. Use this to protect sensitive information, such as passwords that would be exposed in plain text on the configuration file. For more information, see [secrets management](/docs/integrations/host-integrations/installation/secrets-management).

### Offset monitoring

When setting `CONSUMER_OFFSET = true`, by default, only the metrics from consumer groups with active consumers (and consumer metrics) will be collected.
To also collect the metrics from consumer groups with inactive consumers you must set `INACTIVE_CONSUMER_GROUP_OFFSET` to `true`.

When a consumer group is monitoring more than one topic, it's valuable to have consumer group metrics separated by topics, specially if one of the topics have inactive consumers, because then it's possible to spot in which topic the consumer group is having lag and if there are active consumers for that consumer group and topic.

To get consumer group metrics separated by topic, you must set `CONSUMER_GROUP_OFFSET_BY_TOPIC` to `true` (it defaults to `false`)

For more on how to set up offset monitoring, see [Configure KafkaOffsetSample collection](/docs/infrastructure/host-integrations/host-integrations-list/kafka/kafka-config/#KafkaOffsetSample-collection).

## kafka-config.yml sample files [#examples]

<CollapserGroup>
  <Collapser
    id="zookeeper"
    title="Zookeper discovery"
  >
    This configuration collects Metrics and Inventory including all topics discovering the brokers from two different JMX hosts :

    ```yml
    integrations:
      - name: nri-kafka
        env:
          CLUSTER_NAME: testcluster1
          KAFKA_VERSION: "1.0.0"
          AUTODISCOVER_STRATEGY: zookeeper
          ZOOKEEPER_HOSTS: '[{"host": "localhost", "port": 2181}, {"host": "localhost2", "port": 2181}]'
          ZOOKEEPER_PATH: "/kafka-root"
          DEFAULT_JMX_USER: username
          DEFAULT_JMX_PASSWORD: password
          TOPIC_MODE: all
        interval: 15s
        labels:
          env: production
          role: kafka
        inventory_source: config/kafka
    ```
  </Collapser>

  <Collapser
    id="zookeeper-ssl"
    title="Zookeper SSL discovery"
  >
    This configuration collects Metrics and Inventory discovering the brokers from a JMX host with SSL :

    ```yml
    integrations:
      - name: nri-kafka
        env:
          CLUSTER_NAME: testcluster1
          KAFKA_VERSION: "1.0.0"
          AUTODISCOVER_STRATEGY: zookeeper
          ZOOKEEPER_HOSTS: '[{"host": "localhost", "port": 2181}]'
          ZOOKEEPER_PATH: "/kafka-root"
          DEFAULT_JMX_USER: username
          DEFAULT_JMX_PASSWORD: password

          KEY_STORE: "/path/to/your/keystore"
          KEY_STORE_PASSWORD: keystore_password
          TRUST_STORE: "/path/to/your/truststore"
          TRUST_STORE_PASSWORD: truststore_password

          TIMEOUT: 10000  #The timeout for individual JMX queries in milliseconds.
        interval: 15s
        labels:
          env: production
          role: kafka
        inventory_source: config/kafka
    ```
  </Collapser>

  <Collapser
    id="bootstrap"
    title="Bootstrap discovery"
  >
    This configuration collects Metrics and Inventory including all topics discovering the brokers from one bootstrap broker :

    ```yml
    integrations:
      - name: nri-kafka
        env:
          CLUSTER_NAME: testcluster1
          AUTODISCOVER_STRATEGY: bootstrap
          BOOTSTRAP_BROKER_HOST: localhost
          BOOTSTRAP_BROKER_KAFKA_PORT: 9092
          BOOTSTRAP_BROKER_KAFKA_PROTOCOL: PLAINTEXT
          BOOTSTRAP_BROKER_JMX_PORT: 9999  # This same port will be used to connect to all discover broker JMX
          BOOTSTRAP_BROKER_JMX_USER: admin
          BOOTSTRAP_BROKER_JMX_PASSWORD: password

          LOCAL_ONLY_COLLECTION: false

          COLLECT_BROKER_TOPIC_DATA: true
          TOPIC_MODE: "all"
          COLLECT_TOPIC_SIZE: false
        interval: 15s
        labels:
          env: production
          role: kafka
        inventory_source: config/kafka
    ```
  </Collapser>

  <Collapser
    id="bootstrap-tls"
    title="Bootstrap discovery TLS"
  >
    This configuration collects only Metrics discovering the brokers from one bootstrap broker listening with TLS protocol :

    ```yml
    integrations:
      - name: nri-kafka
        env:
          METRICS: true
          CLUSTER_NAME: testcluster1
          AUTODISCOVER_STRATEGY: bootstrap
          BOOTSTRAP_BROKER_HOST: localhost
          BOOTSTRAP_BROKER_KAFKA_PORT: 9092
          BOOTSTRAP_BROKER_KAFKA_PROTOCOL: SSL
          BOOTSTRAP_BROKER_JMX_PORT: 9999
          BOOTSTRAP_BROKER_JMX_USER: admin
          BOOTSTRAP_BROKER_JMX_PASSWORD: password

          # Kerberos authentication arguments
          TLS_CA_FILE: "/path/to/CA.pem"
          TLS_CERT_FILE: "/path/to/cert.pem"
          TLS_KEY_FILE: "/path/to/key.pem"
          TLS_INSECURE_SKIP_VERIFY: false
        interval: 15s
        labels:
          env: production
          role: kafka
        inventory_source: config/kafka
    ```
  </Collapser>

  <Collapser
    id="boostrap-kerberos"
    title="Bootstrap discovery kerberos auth"
  >
    This configuration collects only Metrics discovering the brokers from one bootstrap broker in a Kerberos Auth Cluster :

    ```yml
    integrations:
      - name: nri-kafka
        env:
          METRICS: true
          CLUSTER_NAME: testcluster1
          AUTODISCOVER_STRATEGY: bootstrap
          BOOTSTRAP_BROKER_HOST: localhost
          BOOTSTRAP_BROKER_KAFKA_PORT: 9092
          BOOTSTRAP_BROKER_KAFKA_PROTOCOL: PLAINTEXT # Currently support PLAINTEXT and SSL
          BOOTSTRAP_BROKER_JMX_PORT: 9999
          BOOTSTRAP_BROKER_JMX_USER: admin
          BOOTSTRAP_BROKER_JMX_PASSWORD: password

          # Kerberos authentication arguments
          SASL_MECHANISM: GSSAPI
          SASL_GSSAPI_REALM: SOMECORP.COM
          SASL_GSSAPI_SERVICE_NAME: Kafka
          SASL_GSSAPI_USERNAME: kafka
          SASL_GSSAPI_KEY_TAB_PATH: /etc/newrelic-infra/kafka.keytab
          SASL_GSSAPI_KERBEROS_CONFIG_PATH: /etc/krb5.conf
          SASL_GSSAPI_DISABLE_FAST_NEGOTIATION: false
        interval: 15s
        labels:
          env: production
          role: kafka
        inventory_source: config/kafka
    ```
  </Collapser>

  <Collapser
    id="zookeeper-topic-bucket"
    title="Zookeeper dicsovery topic bucket"
  >
    This configuration collects Metrics splitting topic collection between 3 different instances:

    ```yml
    integrations:
      - name: nri-kafka
        env:
          METRICS: true
          CLUSTER_NAME: testcluster1
          KAFKA_VERSION: "1.0.0"
          AUTODISCOVER_STRATEGY: zookeeper
          ZOOKEEPER_HOSTS: '[{"host": "host1", "port": 2181}]'
          ZOOKEEPER_AUTH_SECRET: "username:password"
          ZOOKEEPER_PATH: "/kafka-root"
          DEFAULT_JMX_USER: username
          DEFAULT_JMX_PASSWORD: password
          TOPIC_MODE: regex
          TOPIC_REGEX: 'topic\d+'
          TOPIC_BUCKET: '1/3'
        interval: 15s
        labels:
          env: production
          role: kafka
        inventory_source: config/kafka
      - name: nri-kafka
        env:
          METRICS: true
          CLUSTER_NAME: testcluster2
          KAFKA_VERSION: "1.0.0"
          AUTODISCOVER_STRATEGY: zookeeper
          ZOOKEEPER_HOSTS: '[{"host": "host2", "port": 2181}]'
          ZOOKEEPER_AUTH_SECRET: "username:password"
          ZOOKEEPER_PATH: "/kafka-root"
          DEFAULT_JMX_USER: username
          DEFAULT_JMX_PASSWORD: password
          TOPIC_MODE: regex
          TOPIC_REGEX: 'topic\d+'
          TOPIC_BUCKET: '2/3'
        interval: 15s
        labels:
          env: production
          role: kafka
        inventory_source: config/kafka
      - name: nri-kafka
        env:
          METRICS: true
          CLUSTER_NAME: testcluster3
          KAFKA_VERSION: "1.0.0"
          AUTODISCOVER_STRATEGY: zookeeper
          ZOOKEEPER_HOSTS: '[{"host": "host3", "port": 2181}]'
          ZOOKEEPER_AUTH_SECRET: "username:password"
          ZOOKEEPER_PATH: "/kafka-root"
          DEFAULT_JMX_USER: username
          DEFAULT_JMX_PASSWORD: password
          TOPIC_MODE: regex
          TOPIC_REGEX: 'topic\d+'
          TOPIC_BUCKET: '3/3'
        interval: 15s
        labels:
          env: production
          role: kafka
        inventory_source: config/kafka
    ```
  </Collapser>

  <Collapser
    id="java-consumer-producer"
    title="Java consumer and producer"
  >
    This gives an example for collecting JMX metrics from Java consumers and producers:

    ```yml
    integrations:
      - name: nri-kafka
        env:
          METRICS: "true"
          CLUSTER_NAME: "testcluster3"
          PRODUCERS: '[{"host": "localhost", "port": 24, "username": "me", "password": "secret"}]'
          CONSUMERS: '[{"host": "localhost", "port": 24, "username": "me", "password": "secret"}]'
          DEFAULT_JMX_HOST: "localhost"
          DEFAULT_JMX_PORT: "9999"
        interval: 15s
        labels:
          env: production
          role: kafka
        inventory_source: config/kafka
    ```
  </Collapser>

  <Collapser
    id="consumer-offset"
    title="Consumer offset"
  >
    This configuration collects consumer offset Metrics and Inventory for the cluster:

    ```yml
    integrations:
      - name: nri-kafka
        env:
          CONSUMER_OFFSET: true
          CLUSTER_NAME: testcluster3
          AUTODISCOVER_STRATEGY: bootstrap
          BOOTSTRAP_BROKER_HOST: localhost
          BOOTSTRAP_BROKER_KAFKA_PORT: 9092
          BOOTSTRAP_BROKER_KAFKA_PROTOCOL: PLAINTEXT
          # A regex pattern that matches the consumer groups to collect metrics from
          CONSUMER_GROUP_REGEX: '.*'
        interval: 15s
        labels:
          env: production
          role: kafka
        inventory_source: config/kafka
    ```
  </Collapser>
</CollapserGroup>

## Configuration options for the integration [#config-options]

For more on how to find and use your data, see [Kafka's configuration settings](/docs/infrastructure/host-integrations/host-integrations-list/kafka/kafka-config).

## Find and use data [#find-and-use]

Data from this service is reported to an [integration dashboard](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts).

Kafka data is attached to the following [event types](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic):

* [`KafkaBrokerSample`](#broker-sample)
* [`KafkaTopicSample`](#topic-sample)
* [`KafkaProducerSample`](#producer-sample)
* [`KafkaConsumerSample`](#consumer-sample)
* [`KafkaOffsetSample`](#offset-sample)

You can [query this data](/docs/using-new-relic/data/understand-data/query-new-relic-data) for troubleshooting purposes or to create charts and dashboards.

For more on how to find and use your data, see how to [understand integration data](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Metrics collected by the integration [#metrics]

The Kafka integration collects the following metrics. Each metric name is prefixed with a category indicator and a period, such as `broker.` or `consumer.`.

<CollapserGroup>
  <Collapser
    id="broker-sample"
    title="KafkaBrokerSample event"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `broker.bytesWrittenToTopicPerSecond`
          </td>

          <td>
            Number of bytes written to a topic by the broker per second.
          </td>
        </tr>

        <tr>
          <td>
            `broker.IOInPerSecond`
          </td>

          <td>
            Network IO into brokers in the cluster in bytes per second.
          </td>
        </tr>

        <tr>
          <td>
            `broker.IOOutPerSecond`
          </td>

          <td>
            Network IO out of brokers in the cluster in bytes per second.
          </td>
        </tr>

        <tr>
          <td>
            `broker.logFlushPerSecond`
          </td>

          <td>
            Log flush rate.
          </td>
        </tr>

        <tr>
          <td>
            `broker.messagesInPerSecond`
          </td>

          <td>
            Incoming messages per second.
          </td>
        </tr>

        <tr>
          <td>
            `follower.requestExpirationPerSecond`
          </td>

          <td>
            Rate of request expiration on followers in evictions per second.
          </td>
        </tr>

        <tr>
          <td>
            `net.bytesRejectedPerSecond`
          </td>

          <td>
            Rejected bytes per second.
          </td>
        </tr>

        <tr>
          <td>
            `replication.isrExpandsPerSecond`
          </td>

          <td>
            Rate of replicas joining the ISR pool.
          </td>
        </tr>

        <tr>
          <td>
            `replication.isrShrinksPerSecond`
          </td>

          <td>
            Rate of replicas leaving the ISR pool.
          </td>
        </tr>

        <tr>
          <td>
            `replication.leaderElectionPerSecond`
          </td>

          <td>
            Leader election rate.
          </td>
        </tr>

        <tr>
          <td>
            `replication.uncleanLeaderElectionPerSecond`
          </td>

          <td>
            Unclean leader election rate.
          </td>
        </tr>

        <tr>
          <td>
            `replication.unreplicatedPartitions`
          </td>

          <td>
            Number of unreplicated partitions.
          </td>
        </tr>

        <tr>
          <td>
            `request.avgTimeFetch`
          </td>

          <td>
            Average time per fetch request in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `request.avgTimeMetadata`
          </td>

          <td>
            Average time for metadata request in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `request.avgTimeMetadata99Percentile`
          </td>

          <td>
            Time for metadata requests for 99th percentile in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `request.avgTimeOffset`
          </td>

          <td>
            Average time for an offset request in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `request.avgTimeOffset99Percentile`
          </td>

          <td>
            Time for offset requests for 99th percentile in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `request.avgTimeProduceRequest`
          </td>

          <td>
            Average time for a produce request in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `request.avgTimeUpdateMetadata`
          </td>

          <td>
            Average time for a request to update metadata in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `request.avgTimeUpdateMetadata99Percentile`
          </td>

          <td>
            Time for update metadata requests for 99th percentile in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `request.clientFetchesFailedPerSecond`
          </td>

          <td>
            Client fetch request failures per second.
          </td>
        </tr>

        <tr>
          <td>
            `request.fetchTime99Percentile`
          </td>

          <td>
            Time for fetch requests for 99th percentile in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `request.handlerIdle`
          </td>

          <td>
            Average fraction of time the request handler threads are idle.
          </td>
        </tr>

        <tr>
          <td>
            `request.produceRequestsFailedPerSecond`
          </td>

          <td>
            Failed produce requests per second.
          </td>
        </tr>

        <tr>
          <td>
            `request.produceTime99Percentile`
          </td>

          <td>
            Time for produce requests for 99th percentile.
          </td>
        </tr>

        <tr>
          <td>
            `topic.diskSize`
          </td>

          <td>
            In disk Topic size. Only present if COLLECT_TOPIC_SIZE is enabled.
          </td>
        </tr>

        <tr>
          <td>
            `topic.offset`
          </td>

          <td>
            Topic offset. Only present if COLLECT_TOPIC_OFFSET is enabled.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="consumer-sample"
    title="KafkaConsumerSample event"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `consumer.avgFetchSizeInBytes`
          </td>

          <td>
            Average number of bytes fetched per request for a specific topic.
          </td>
        </tr>

        <tr>
          <td>
            `consumer.avgRecordConsumedPerTopic`
          </td>

          <td>
            Average number of records in each request for a specific topic.
          </td>
        </tr>

        <tr>
          <td>
            `consumer.avgRecordConsumedPerTopicPerSecond`
          </td>

          <td>
            Average number of records consumed per second for a specific topic in records per second.
          </td>
        </tr>

        <tr>
          <td>
            `consumer.bytesInPerSecond`
          </td>

          <td>
            Consumer bytes per second.
          </td>
        </tr>

        <tr>
          <td>
            `consumer.fetchPerSecond`
          </td>

          <td>
            The minimum rate at which the consumer sends fetch requests to a broke in requests per second.
          </td>
        </tr>

        <tr>
          <td>
            `consumer.maxFetchSizeInBytes`
          </td>

          <td>
            Maximum number of bytes fetched per request for a specific topic.
          </td>
        </tr>

        <tr>
          <td>
            `consumer.maxLag`
          </td>

          <td>
            Maximum consumer lag.
          </td>
        </tr>

        <tr>
          <td>
            `consumer.messageConsumptionPerSecond`
          </td>

          <td>
            Rate of consumer message consumption in messages per second.
          </td>
        </tr>

        <tr>
          <td>
            `consumer.offsetKafkaCommitsPerSecond`
          </td>

          <td>
            Rate of offset commits to Kafka in commits per second.
          </td>
        </tr>

        <tr>
          <td>
            `consumer.offsetZooKeeperCommitsPerSecond`
          </td>

          <td>
            Rate of offset commits to ZooKeeper in writes per second.
          </td>
        </tr>

        <tr>
          <td>
            `consumer.requestsExpiredPerSecond`
          </td>

          <td>
            Rate of delayed consumer request expiration in evictions per second.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="producer-sample"
    title="KafkaProducerSample event"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `producer.ageMetadataUsedInMilliseconds`
          </td>

          <td>
            Age in seconds of the current producer metadata being used.
          </td>
        </tr>

        <tr>
          <td>
            `producer.availableBufferInBytes`
          </td>

          <td>
            Total amount of buffer memory that is not being used in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `producer.avgBytesSentPerRequestInBytes`
          </td>

          <td>
            Average number of bytes sent per partition per-request.
          </td>
        </tr>

        <tr>
          <td>
            `producer.avgCompressionRateRecordBatches`
          </td>

          <td>
            Average compression rate of record batches.
          </td>
        </tr>

        <tr>
          <td>
            `producer.avgRecordAccumulatorsInMilliseconds`
          </td>

          <td>
            Average time in ms record batches spent in the record accumulator.
          </td>
        </tr>

        <tr>
          <td>
            `producer.avgRecordSizeInBytes`
          </td>

          <td>
            Average record size in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `producer.avgRecordsSentPerSecond`
          </td>

          <td>
            Average number of records sent per second.
          </td>
        </tr>

        <tr>
          <td>
            `producer.avgRecordsSentPerTopicPerSecond`
          </td>

          <td>
            Average number of records sent per second for a topic.
          </td>
        </tr>

        <tr>
          <td>
            `producer.AvgRequestLatencyPerSecond`
          </td>

          <td>
            Producer average request latency.
          </td>
        </tr>

        <tr>
          <td>
            `producer.avgThrottleTime`
          </td>

          <td>
            Average time that a request was throttled by a broker in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `producer.bufferMemoryAvailableInBytes`
          </td>

          <td>
            Maximum amount of buffer memory the client can use in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `producer.bufferpoolWaitTime`
          </td>

          <td>
            Faction of time an appender waits for space allocation.
          </td>
        </tr>

        <tr>
          <td>
            `producer.bytesOutPerSecond`
          </td>

          <td>
            Producer bytes per second out.
          </td>
        </tr>

        <tr>
          <td>
            `producer.compressionRateRecordBatches`
          </td>

          <td>
            Average compression rate of record batches for a topic.
          </td>
        </tr>

        <tr>
          <td>
            `producer.iOWaitTime`
          </td>

          <td>
            Producer I/O wait time in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `producer.maxBytesSentPerRequestInBytes`
          </td>

          <td>
            Max number of bytes sent per partition per-request.
          </td>
        </tr>

        <tr>
          <td>
            `producer.maxRecordSizeInBytes`
          </td>

          <td>
            Maximum record size in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `producer.maxRequestLatencyInMilliseconds`
          </td>

          <td>
            Maximum request latency in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `producer.maxThrottleTime`
          </td>

          <td>
            Maximum time a request was throttled by a broker in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `producer.messageRatePerSecond`
          </td>

          <td>
            Producer messages per second.
          </td>
        </tr>

        <tr>
          <td>
            `producer.responsePerSecond`
          </td>

          <td>
            Number of producer responses per second.
          </td>
        </tr>

        <tr>
          <td>
            `producer.requestPerSecond`
          </td>

          <td>
            Number of producer requests per second.
          </td>
        </tr>

        <tr>
          <td>
            `producer.requestsWaitingResponse`
          </td>

          <td>
            Current number of in-flight requests awaiting a response.
          </td>
        </tr>

        <tr>
          <td>
            `producer.threadsWaiting`
          </td>

          <td>
            Number of user threads blocked waiting for buffer memory to enqueue their records.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="topic-sample"
    title="KafkaTopicSample event"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `topic.diskSize`
          </td>

          <td>
            Current topic disk size per broker in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `topic.partitionsWithNonPreferredLeader`
          </td>

          <td>
            Number of partitions per topic that are not being led by their preferred replica.
          </td>
        </tr>

        <tr>
          <td>
            `topic.respondMetaData`
          </td>

          <td>
            Number of topics responding to meta data requests.
          </td>
        </tr>

        <tr>
          <td>
            `topic.retentionSizeOrTime`
          </td>

          <td>
            Whether a partition is retained by size or both size and time. A value of 0 = time and a value of 1 = both size and time.
          </td>
        </tr>

        <tr>
          <td>
            `topic.underReplicatedPartitions`
          </td>

          <td>
            Number of partitions per topic that are under-replicated.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="offset-sample"
    title="KafkaOffsetSample event"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `consumer.offset`
          </td>

          <td>
            The last consumed offset on a partition by the consumer group.
          </td>
        </tr>

        <tr>
          <td>
            `consumer.lag`
          </td>

          <td>
            The difference between a broker's high water mark and the consumer's offset (`consumer.hwm` - `consumer.offset`).
          </td>
        </tr>

        <tr>
          <td>
            `consumer.hwm`
          </td>

          <td>
            The offset of the last message written to a partition (high water mark).
          </td>
        </tr>

        <tr>
          <td>
            `consumer.totalLag`
          </td>

          <td>
            The sum of lags across partitions consumed by a consumer.
          </td>
        </tr>

        <tr>
          <td>
            `consumerGroup.totalLag`
          </td>

          <td>
            The sum of lags across all partitions consumed by a `consumerGroup`.
          </td>
        </tr>

        <tr>
          <td>
            `consumerGroup.maxLag`
          </td>

          <td>
            The maximum lag across all partitions consumed by a `consumerGroup`.
          </td>
        </tr>

        <tr>
          <td>
            `consumerGroup.activeConsumers`
          </td>

          <td>
            The number of active consumers in this `consumerGroup`.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>
