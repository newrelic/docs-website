---
title: VMware vSphere monitoring integration
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: An introduction to New Relic's open-source VMware vSphere / ESXi integration.
redirects:
  - /docs/integrations/host-integrations/host-integrations-list/vmware-vsphere-monitoring-integration
  - /docs/vmware-esxi-open-source-integration
  - /docs/integrations/host-integrations/open-source-host-integrations-list/vmware-esxi-open-source-integration
  - /docs/integrations/host-integrations/host-integrations-list/vmware-esxi-integration
  - /docs/integrations/host-integrations/host-integrations-list/vmware-esxi-monitoring-integration
  - /docs/vmwarevsphere-integration-new-relic-infrastructure
dataSource: vmware-vsphere
---

import infrastructureVmwareSphereDashboard from 'images/infrastructure_screenshot-crop_vmware-sphere-dashboard.png'

import infrastructureVmwareSphereWorkloads from 'images/infrastructure_screenshot-crop_vmware-sphere-workloads.png'

New Relic's VMware vSphere integration helps you understand the health and performance of your vSphere environment. You can:

* Query data to get insights on the performance on your hypervisors, virtual machines, and more.
* Go from high level views down to the most granular data.

<img
  title="infrastructure-ohi-vmware-vsphere.png"
  alt="Sample dashboard - VMware vSphere Integration"
  src={infrastructureVmwareSphereDashboard}
/>

<figcaption>
  vSphere data visualized in a New Relic dashboard includes operating systems, status, average CPU and memory consumption, and more.
</figcaption>

Our integration uses the [vSphere API](https://code.vmware.com/apis/704/vsphere) to collect metrics and events generated by all vSphere's components, and forwards the data to our platform via the infrastructure agent.

## Why it matters [#features]

With our vSphere integration you can:

* Instrument and monitor multiple vSphere instances using the same account.
* Collect data on snapshots, VMs, hosts, resource pools, clusters, and datastores, including tags.
* Monitor the health of your hypervisors and VMs using our charts and dashboards.
* Use the data retrieved to monitor key performance and key capacity scaling indicators.
* Set alerts based on any metrics collected from vCenter.
* Create [workloads](/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-one-workloads-isolate-resolve-incidents-faster) to group resources and focus on key data.

  <img
    title="vSphere data in New Relic Workloads"
    alt="vSphere data in New Relic Workloads"
    src={infrastructureVmwareSphereWorkloads}
  />

  <figcaption>
    You can create [workloads](/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-one-workloads-isolate-resolve-incidents-faster) using data collected via the vSphere integration.
  </figcaption>

## Compatibility and requirements [#requirements]

Our integration is compatible with VMware vSphere 6.5 or higher.

Before installing the integration, make sure that you meet the following requirements:

* [Infrastructure agent installed on a host](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic)
* vCenter service account having at least read-only global permissions with the `propagate to children` option checked

<Callout variant="important">
  **Large environments:** In environments with more than 800 virtual machines, the integration cannot report all data and may fail. We offer a workaround that will preserve all metrics and events, but it will disable entity registration. To apply the workaround, add the following environment variable to the configuration file:

  ```yaml
  integrations:
  - name: nri-vsphere
    env:
      # Integration configuration parameters.

      EVENTS: true
      METRICS: true
  
  ```
</Callout>

## Install and activate [#install]

To install the vSphere integration, choose your setup:

<CollapserGroup>
  <Collapser
    id="linux-install"
    title="Linux installation"
  >
    1. Install [the infrastructure agent](/docs/integrations/host-integrations/installation/install-infrastructure-host-integrations/#install), and replace `INTEGRATION_FILE_NAME` with `nri-vsphere` when running the installation command.
    2. Change the directory to the integrations folder:

       ```
       cd /etc/newrelic-infra/integrations.d
       ```
    3. Copy of the sample configuration file:

       ```
       sudo cp vsphere-config.yml.sample vsphere-config.yml
       ```
    4. Edit the `vsphere-config.yml` file as described in the [configuration settings](#config).
    5. [Restart the infrastructure agent](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).
  </Collapser>

  <Collapser
    id="windows-install"
    title="Windows installation"
  >
    1. Download the `nri-vsphere` MSI installer image from:

       [download.newrelic.com/infrastructure_agent/windows/integrations/nri-vsphere/nri-vsphere-amd64.msi](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-vsphere/nri-vsphere-amd64.msi)
    2. To install from the Windows command prompt, run:

       ```
       msiexec.exe /qn /i PATH\TO\nri-vsphere-amd64.msi
       ```
    3. In the Integrations directory, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, create a copy of the sample configuration file by running:

       ```
       cp vsphere-config.yml.sample vsphere-config.yml
       ```
    4. Edit the `vsphere-config.yml` file as described in the [configuration settings](#config).
    5. [Restart the infrastructure agent](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).
  </Collapser>

  <Collapser
    id="tarball"
    title="Tarball installation (advanced)"
  >
    You can also [install the integration from a tarball file](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball). This gives you full control over the installation and configuration process.
  </Collapser>
</CollapserGroup>

<InstallFeedback />

## Configure the integration [#config]

An integration's YAML-format configuration is where you can place required login credentials and configure how data is collected. Which options you change depend on your setup and preference.

To configure the vSphere integration, you must define the URL of the vSphere API endpoint, and your vSphere username and password. For configuration examples, see the [sample configuration files](#example-config). Some vSphere integration features are optional and can be enabled via configuration settings.

In addition, with [secrets management](/docs/integrations/host-integrations/installation/secrets-management), you can configure on-host integrations with New Relic's infrastructure monitoring agent to use sensitive data (such as passwords) without having to write them as plain text into the integration's configuration file.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="vsphere-events"
    title="Collect vSphere events"
  >
    To collect vSphere events, use the `ENABLE_VSPHERE_EVENTS` environment variable.

    The integration collects events between the current time and the last fetched event for each datacenter. It stores the information regarding the last fetched event in a cache that is updated after each execution. Events are only available if the integration is connected to a vCenter and not directly to an ESXi host.

    The number of events collected per request can be tuned by modifying `EVENTS_PAGE_SIZE`, which is set to `100` by default.

    Events are available in the **Events** page and can be queried via [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) as `InfrastructureEvent` under `vSphereEvent`. Here is an example of vSphere events data:

    ```
    "summary": "User dcui@127.0.0.1 logged out (login time: Tuesday, 14 July, 2020 08:32:09 AM, number of API invocations: 0, user agent: VMware-client/6.5.0)",
    "vSphereEvent.computeResource": "cluster1",
    "vSphereEvent.datacenter": "Prod Datacenter",
    "vSphereEvent.date": "Tue, 14 Jul 2020 09:03:51 UTC",
    "vSphereEvent.host": "192.168.0.230",
    "vSphereEvent.userName": "dcui"
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="snapshot-data"
    title="Collect snapshots data"
  >
    To collect snapshot data, use the `ENABLE_VSPHERE_SNAPSHOTS` environment variable.

    Snapshot data can be found in `VSphereSnapshotVmSample`. Collected data covers total and unique space occupied by disk and memory files, snapshot tree, and creation time.

    You can use this information to create [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) queries, [dashboards](/docs/dashboards/new-relic-one-dashboards/get-started/introduction-new-relic-one-dashboards), and [alerts](/docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries), since it's linked to the corresponding virtual machine entity.
  </Collapser>

  <Collapser
    className="freq-link"
    id="vsphere-tags"
    title="Collect vSphere tags"
  >
    To collect vSphere tags, use the `ENABLE_VSPHERE_TAGS` environment variable.

    Tags are available as attributes in the corresponding entity sample as `label.tagCategory:tagName`.

    If two tags of the same category are assigned to a resource, they are added to a unique attribute separated by a pipe character. For example: `label.tagCategory:tagName|tagName`2.

    Tags can be used to run [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) queries, filter entities in the [New Relic Explorer](/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-one-entity-explorer-view-performance-across-apps-services-hosts), and to create [dashboards](/docs/dashboards/new-relic-one-dashboards/get-started/introduction-new-relic-one-dashboards) and [alerts](/docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries).
  </Collapser>

  <Collapser
    className="freq-link"
    id="vsphere-filter"
    title="Filter resources by tags"
  >
    Resource filtering allows you to specify which resources you want to monitor by declaring a set of tags that resources must have in order to be monitored.

    Resources require a match on any (one or more) of the filter tags in order to be included. If none of the resource tags match any of the filter tags, no information about that resource is sent to New Relic.

    To use filtering resources by tag you need to have the `ENABLE_VSPHERE_TAGS` environment variable enabled.

    A tag filter expression is a space-separated list of pairs of strings with the format `category=name`.

    For example, to only retrieve resources with a tag category `region` and include regions `us` and `eu` use a filter expression like: `region=us region=eu`

    ```
    INCLUDE_TAGS: >
      region=us
      region=eu
    ```

    To enable resource filtering by tag, edit your integration configuration file and add the option `INCLUDE_TAGS` with the filter expression you want.

    <Callout variant="caution">
      Note that datacenter resources acting as the root of the resource tree MUST have tags attached AND match the filter expression in order for other child resources to be fetched.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="perf-metrics"
    title="Enable and configure performance metrics (preview)"
  >
    Performance metrics provide a better understanding of the current status of VMware resources and can be collected **in addition** to the metrics collected by default;and included in the samples;described at the bottom of the page.

    All metrics collected are included in the corresponding sample with the `perf.` prefix attached to the name. For example, `net.packetsRx.summation` is collected and sent as `perf.net.packetsRx.summation`.

    To collect vSphere performance metrics, use the `ENABLE_VSPHERE_PERF_METRICS` environment variable.

    Data is collected according to the settings in the [`vsphere-performance.metrics`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-performance.metrics) configuration file. You can override the location of the performance metrics config file using `PERF_METRIC_FILE` environment variable. Notice that the integration follows [VMware's data collection levels](https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.monitoring.doc/GUID-25800DE4-68E5-41CC-82D9-8811E27924BC.html) (1 to 4).

    When `ENABLE_VSPHERE_PERF_METRICS` is set, all level 1 metrics are collected. The data collection level of the performance metrics collected can be modified using `PERF_LEVEL`. Each metric in the config file can be commented out and new ones can be added if needed.

    <Callout variant="caution">
      Collection of performance data can increase the load in vCenter and the time needed by to collect data. We recommended to only include the metrics you need in the configuration file.
    </Callout>

    To fine-tune data collection, the number of entities and metrics retrieved per request can be modified using `BATCH_SIZE_PERF_ENTITIES` and `BATCH_SIZE_PERF_METRICS`.

    <Callout variant="tip">
      For more information on vSphere performance metrics, see the [VMware documentation](https://docs.vmware.com/en/VMware-vSphere/6.7/vsphere-esxi-vcenter-server-67-monitoring-performance-guide.pdf).
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="multi-instance"
    title="Multiple instances"
  >
    In this configuration we are monitoring multiple vSphere servers from the same integration. For the first instance (`FIRST_VSPHERE_API_URL`) we are collecting events and tags while for the second instance (`SECOND_VSPHERE_API_URL`) we have turned them off.

    ```yaml
    integrations:
      - name: nri-vsphere
        env:
          # vSphere API connection data (vCenter or ESXi servers)
          URL: https://<FIRST_VSPHERE_API_URL>/sdk
          USER: <FIRST_VSPHERE_USER>
          PASS: <FIRST_PASSWORD>
    
          # Collect events data
          ENABLE_VSPHERE_EVENTS: true
    
          # Collect vSphere tags
          ENABLE_VSPHERE_TAGS: true
     
        # Execution interval. Set a value higher than 20s, as real-time vSphere samples are run every 20s.
        interval: 120s
      - name: nri-vsphere
        env:
          # vSphere API connection data (vCenter or ESXi servers)
          URL: https://<SECOND_VSPHERE_API_URL>/sdk
          USER: <SECOND_VSPHERE_USER>
          PASS: <SECOND_PASSWORD>
    
          # Collect events data
          ENABLE_VSPHERE_EVENTS: false
    
          # Collect vSphere tags
          ENABLE_VSPHERE_TAGS: false
     
        # Execution interval. Set a value higher than 20s, as real-time vSphere samples are run every 20s.
        interval: 300s
    ```
  </Collapser>
</CollapserGroup>

<Callout variant="important">
  If you connect the integration directly to the ESXi host, vCenter data is not available (for example, events, tags, or datacenter metadata).
</Callout>

### Example configuration [#example-config]

Here are examples of the vSphere integration configuration, including performance metrics:

* [`vsphere-config.yml.sample`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-config.yml.sample) (Linux)
* [`vsphere-win-config.yml.sample`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-win-config.yml.sample) (Windows)
* [`vsphere-performance.metrics`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-performance.metrics) (Performance metrics)

For more information, see our documentation about the [general structure of on-host integration configurations](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview).

<Callout variant="important">
  The configuration option [inventory_source](/docs/integrations/integrations-sdk/file-specifications/host-integrations-newer-configuration-format#inventory_source) is not compatible with this integration.
</Callout>

## Update your integration [#update]

**On-host integrations do not automatically update.**

For best results, regularly [update the integration package](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) and the [infrastructure agent](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

## View and use data [#data]

Data from this service is reported to an [integration dashboard](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts). You can [query this data](/docs/using-new-relic/data/understand-data/query-new-relic-data) for troubleshooting purposes or to create charts and dashboards.

vSphere data is attached to these [event types](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#event):

* `VSphereHostSample`
* `VSphereClusterSample`
* `VSphereVmSample`
* `VSphereDatastoreSample`
* `VSphereDatacenterSample`
* `VSphereResourcePoolSample`
* `VSphereSnapshotVmSample`

Performance data is enabled and configured separately (see [Enable and configure performance metrics](#perf-metrics)).

For more on how to view and use your data, see [Understand integration data](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Metric data [#metrics]

The vSphere integration provides metric data attached to the following New Relic [events](/docs/telemetry-data-platform/ingest-manage-data/understand-data/new-relic-data-types#events-new-relic):

* `VSphereHostSample`
* `VSphereVmSample`
* `VSphereDatastoreSample`
* `VSphereDatacenterSample`
* `VSphereResourcePoolSample`
* `VSphereClusterSample`
* `VSphereSnapshotVmSample`

### VSphereHostSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cpu.totalMHz`
      </td>

      <td>
        Sum of the MHz for all the individual cores on the host
      </td>
    </tr>

    <tr>
      <td>
        `cpu.coreMHz`
      </td>

      <td>
        Speed of the CPU cores
      </td>
    </tr>

    <tr>
      <td>
        `cpu.available`
      </td>

      <td>
        Amount of free CPU MHz in the host
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        CPU usage across all cores on the host in MHz
      </td>
    </tr>

    <tr>
      <td>
        `cpu.percent`
      </td>

      <td>
        Percentage of CPU utilization in the host
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Number of physical CPU cores on the host. Physical CPU cores are the processors contained by a CPU package
      </td>
    </tr>

    <tr>
      <td>
        `cpu.threads`
      </td>

      <td>
        Number of physical CPU threads on the host
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalMiB`
      </td>

      <td>
        Total capacity of disks mounted in host, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.free`
      </td>

      <td>
        Amount of available memory in the host, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Amount of used memory in the host, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Total memory capacity of the host, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Number of virtual machines in the host
      </td>
    </tr>

    <tr>
      <td>
        `hypervisorHostname`
      </td>

      <td>
        Name of the host
      </td>
    </tr>

    <tr>
      <td>
        `uuid`
      </td>

      <td>
        The hardware BIOS identification
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Name of the datacenter related to the host
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name of the cluster related to the host
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolNameList`
      </td>

      <td>
        List of names of the resource pools related to the host
      </td>
    </tr>

    <tr>
      <td>
        `datastoreNameList`
      </td>

      <td>
        List of names of datastores related to the host
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Datacenter location
      </td>
    </tr>

    <tr>
      <td>
        `networkNameList`
      </td>

      <td>
        List of names of networks related to the host
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Status is unknown
        * `green`: Entity is OK
        * `yellow`: Entity might have a problem
        * `red`: Entity definitely has a problem
      </td>
    </tr>

    <tr>
      <td>
        `connectionState`
      </td>

      <td>
        The host connection state:

        * `connected`: Connected to the server. For ESX Server, this is the default setting.
        * `disconnected`: The user has explicitly taken the host down. VirtualCenter does not expect to receive heartbeats from the host. The next time a heartbeat is received, the host is moved to the connected state again and an event is logged.
        * `notResponding`: VirtualCenter is not receiving heartbeats from the server. The state automatically changes to connected once heartbeats are received again. This state is typically used to trigger an alarm on the host.
      </td>
    </tr>

    <tr>
      <td>
        `inMaintenanceMode`
      </td>

      <td>
        The flag to indicate whether or not the host is in maintenance mode. This flag is set when the host has entered the maintenance mode. It is not set during the entering phase of maintenance mode.
      </td>
    </tr>

    <tr>
      <td>
        `inQuarantineMode`
      </td>

      <td>
        The flag to indicate whether or not the host is in quarantine mode. `InfraUpdateHa` will recommend to set this flag based on the `HealthUpdates` received by the `HealthUpdateProviders` configured for the cluster.

        A host that is reported as degraded will be recommended to enter quarantine mode, while a host that is reported as healthy will be recommended to exit quarantine mode. Execution of these recommended actions will set this flag.

        Hosts in quarantine mode will be avoided by vSphere DRS as long as the increased consolidation in the cluster does not negatively affect VM performance.
      </td>
    </tr>

    <tr>
      <td>
        `powerState`
      </td>

      <td>
        The host power state:

        * `poweredOff`: The host was specifically powered off by the user through VirtualCenter. This state is not a cetain state, because after VirtualCenter issues the command to power off the host, the host might crash, or kill all the processes but fail to power off.
        * `poweredOn`: The host is powered on. A host that is entering standby mode entering is also in this state.
        * `standBy`: The host was specifically put in standby mode, either explicitly by the user or automatically by DPM. This state is not a certain state, because after VirtualCenter issues the command to put the host in standby state, the host might crash, or kill all the processes but fail to power off. A host that is exiting standby mode s also in this state.
        * `unknown`: If the host is disconnected or `notResponding`, we know its power state, so the host is marked as `unknown`.
      </td>
    </tr>

    <tr>
      <td>
        `standbyMode`
      </td>

      <td>
        The hostâ€™s standby mode. The property is only populated by vCenter server. If queried directly from the ESX host, the property is `unset`.

        * `entering`: The host is entering standby mode.
        * `exiting`: The host is exiting standby mode.
        * `in`: The host is in standby mode.
        * `none`: The host is not in standby mode, and it is not in the process of entering or exiting standby mode.
      </td>
    </tr>

    <tr>
      <td>
        `cryptoState`
      </td>

      <td>
        Encryption state of the host. Valid values are enumerated by the CryptoState type:

        * `incapable`: The host is not safe for receiving sensitive material.
        * `prepared`: The host is prepared for receiving sensitive material but does not have a host key set yet.
        * `safe`: The host is crypto safe and has a host key set.
      </td>
    </tr>

    <tr>
      <td>
        `bootTime`
      </td>

      <td>
        The time when the host was booted.
      </td>
    </tr>
  </tbody>
</table>

### VSphereVmSample [#vspherevirtualmachine]

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Memory size of the virtual machine, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Guest memory utilization statistics, in MiB. This is also known as active guest memory. The value can range between `0` and the configured memory size of the virtual machine. Valid while the virtual machine is running.
      </td>
    </tr>

    <tr>
      <td>
        `mem.free`
      </td>

      <td>
        Guest memory available, in MiB. The value can range between `0` and the configured memory size of the virtual machine. Valid while the virtual machine is running.
      </td>
    </tr>

    <tr>
      <td>
        `mem.ballooned`
      </td>

      <td>
        The size of the balloon driver in the virtual machine, in MiB. The host will inflate the balloon driver to reclaim physical memory from the virtual machine. This is a sign that there is memory pressure on the host.
      </td>
    </tr>

    <tr>
      <td>
        `mem.swapped`
      </td>

      <td>
        The portion of memory, in MiB, that is granted to this virtual machine from the host's swap space. This is a sign that there is memory pressure on the host.
      </td>
    </tr>

    <tr>
      <td>
        `mem.swappedSsd`
      </td>

      <td>
        The amount of memory swapped to fast disk device such as SSD, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `cpu.allocationLimit`
      </td>

      <td>
        Resource limits for CPU, in MHz. If set to `-1`, there is no fixed allocation limit.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Basic CPU performance statistics, in MHz. Valid while the virtual machine is running.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.hostUsagePercent`
      </td>

      <td>
        Percent of the host CPU used by the virtual machine. In case a limit is configured, the percentage is calculated by taking the limit as the total.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Number of processors in the virtual machine
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalMiB`
      </td>

      <td>
        Total storage space, committed to this virtual machine across all datastores, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `ipAddress`
      </td>

      <td>
        Primary guest IP address, if available
      </td>
    </tr>

    <tr>
      <td>
        `ipAddresses`
      </td>

      <td>
        List of IPs associated with the VM (except `ipAddress`). A pipe or vertical bar character (`|`) is used as a separator.
      </td>
    </tr>

    <tr>
      <td>
        `connectionState`
      </td>

      <td>
        Indicates whether or not the virtual machine is available for management:

        * `connected`: Server has access to the virtual machine.
        * `disconnected`: Server is currently disconnected from the virtual machine, since its host is disconnected.
        * `inaccessible`: One or more of the virtual machine configuration files are inaccessible.
        * `invalid`: The virtual machine configuration format is invalid.
        * `orphaned`: The virtual machine is no longer registered on its associated host.
      </td>
    </tr>

    <tr>
      <td>
        `powerState`
      </td>

      <td>
        The current power state of the virtual machine: `poweredOff`, `poweredOn`, or `suspended`.
      </td>
    </tr>

    <tr>
      <td>
        `guestHeartbeatStatus`
      </td>

      <td>
        * `gray`: Status is unknown.
        * `green`: Entity is OK.
        * `yellow`: Entity might have a problem.
        * `red`: Entity definitely has a problem.
      </td>
    </tr>

    <tr>
      <td>
        `operatingSystem`
      </td>

      <td>
        Operating system of the virtual machine
      </td>
    </tr>

    <tr>
      <td>
        `guestFullName`
      </td>

      <td>
        Guest operating system full name, if available from guest tools
      </td>
    </tr>

    <tr>
      <td>
        `hypervisorHostname`
      </td>

      <td>
        Name of the host where the virtual machine is running
      </td>
    </tr>

    <tr>
      <td>
        `instanceUuid`
      </td>

      <td>
        Unique identification of the virtual machine
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Name of the datacenter
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name of the cluster
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolNameList`
      </td>

      <td>
        List of names of the resource pools
      </td>
    </tr>

    <tr>
      <td>
        `datastoreNameList`
      </td>

      <td>
        List of names of datastores
      </td>
    </tr>

    <tr>
      <td>
        `networkNameList`
      </td>

      <td>
        List of names of networks
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Datacenter location
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Status is unknown.
        * `green`: Entity is OK.
        * `yellow`: Entity might have a problem.
        * `red`: Entity definitely has a problem.
      </td>
    </tr>

    <tr>
      <td>
        `disk.suspendMemory`
      </td>

      <td>
        Size of the snapshot file (bytes).
      </td>
    </tr>

    <tr>
      <td>
        `disk.suspendMemoryUnique`
      </td>

      <td>
        Size of the snapshot file, unique blocks (bytes).
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalUncommittedMiB`
      </td>

      <td>
        Additional storage space potentially used by this virtual machine on all datastores. Essentially an aggregate of the property uncommitted across all datastores that this virtual machine is located on (Mebibytes).
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalUnsharedMiB`
      </td>

      <td>
        Total storage space occupied by the virtual machine across all datastores, that is not shared with any other virtual machine (Mebibytes).
      </td>
    </tr>

    <tr>
      <td>
        `mem.hostUsage`
      </td>

      <td>
        Host memory usage (Mebibytes).
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolName`
      </td>

      <td>
        Resource Pool Name.
      </td>
    </tr>

    <tr>
      <td>
        `vmConfigName`
      </td>

      <td>
        Vm Config Name.
      </td>
    </tr>

    <tr>
      <td>
        `vmHostname`
      </td>

      <td>
        Vm Hostname.
      </td>
    </tr>
  </tbody>
</table>

### VSphereDatastoreSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `capacity`
      </td>

      <td>
        Maximum capacity of this datastore, in GiB, if accessible is `true`
      </td>
    </tr>

    <tr>
      <td>
        `freeSpace`
      </td>

      <td>
        Available space of this datastore, in GiB, if accessible is `true`
      </td>
    </tr>

    <tr>
      <td>
        `uncommitted`
      </td>

      <td>
        Total additional storage space, potentially used by all virtual machines on this datastore, in GiB, if accessible is `true`
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Number of virtual machines attached to the datastore
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Datacenter location
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Datacenter name
      </td>
    </tr>

    <tr>
      <td>
        `hostCount`
      </td>

      <td>
        Number of hosts attached to the datastore
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Status is unknown.
        * `green`: Entity is OK.
        * `yellow`: Entity might have a problem.
        * `red`: Entity definitely has a problem.
      </td>
    </tr>

    <tr>
      <td>
        `accessible`
      </td>

      <td>
        Connectivity status of the datastore. If this is set to `false`, the datastore is not accessible.
      </td>
    </tr>

    <tr>
      <td>
        `url`
      </td>

      <td>
        Unique locator for the datastore, if accessible is `true`
      </td>
    </tr>

    <tr>
      <td>
        `fileSystemType`
      </td>

      <td>
        Type of file system volume, such as `VMFS` or `NFS`
      </td>
    </tr>

    <tr>
      <td>
        `name`
      </td>

      <td>
        Name of the datastore
      </td>
    </tr>

    <tr>
      <td>
        `nas.remoteHost`
      </td>

      <td>
        Host that runs the NFS/CIFS server
      </td>
    </tr>

    <tr>
      <td>
        `nas.remotePath`
      </td>

      <td>
        Remote path of NFS/CIFS mount point
      </td>
    </tr>
  </tbody>
</table>

### VSphereDatacenterSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `datastore.totalUsedGiB`
      </td>

      <td>
        Total used space in the datastores, in GiB
      </td>
    </tr>

    <tr>
      <td>
        `datastore.totalFreeGiB`
      </td>

      <td>
        Total free space in the datastores, in GiB
      </td>
    </tr>

    <tr>
      <td>
        `datastore.totalGiB`
      </td>

      <td>
        Total size of the datastores, in GiB
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Total CPU count per datacenter
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsagePercentage`
      </td>

      <td>
        Total CPU usage, in percentage
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Total CPU usage, in MHz
      </td>
    </tr>

    <tr>
      <td>
        `cpu.totalMHz`
      </td>

      <td>
        Total CPU capacity, in MHz
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Total memory usage, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Total memory, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.usagePercentage`
      </td>

      <td>
        Total memory usage as percentage
      </td>
    </tr>

    <tr>
      <td>
        `clusters`
      </td>

      <td>
        Total cluster count per datacenter
      </td>
    </tr>

    <tr>
      <td>
        `resourcePools`
      </td>

      <td>
        Total resource pools per datacenter
      </td>
    </tr>

    <tr>
      <td>
        `datastores`
      </td>

      <td>
        Total datastores per datacenter
      </td>
    </tr>

    <tr>
      <td>
        `networks`
      </td>

      <td>
        Total network adapter count per datacenter
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Status is unknown
        * `green`: Entity is OK
        * `yellow`: Entity might have a problem
        * `red`: Entity definitely has a problem
      </td>
    </tr>

    <tr>
      <td>
        `hostCount`
      </td>

      <td>
        Total host system count per datacenter
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Total virtual machines count per datacenter
      </td>
    </tr>
  </tbody>
</table>

### VSphereResourcePoolSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cpu.TotalMHz`
      </td>

      <td>
        Resource pool CPU total capacity, in MHz
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Resource pool CPU usage, in MHz
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Resource pool total memory reserved, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Resource pool memory usage, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.free`
      </td>

      <td>
        Resource pool memory available, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.ballooned`
      </td>

      <td>
        Size of the balloon driver in the resource pool, in MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.swapped`
      </td>

      <td>
        Portion of memory, in MiB, that is granted to this resource pool from the host's swap space
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Number of virtual machines in the resource pool
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Status is unknown.
        * `green`: Entity is OK.
        * `yellow`: Entity might have a problem.
        * `red`: Entity definitely has a problem.
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolName`
      </td>

      <td>
        Name of the resource pool
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Datacenter location
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Name of the datacenter
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name of the cluster
      </td>
    </tr>
  </tbody>
</table>

### VSphereClusterSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cpu.totalEffectiveMHz`
      </td>

      <td>
        Effective CPU resources, in MHz, available to virtual machines. This is the aggregated effective resource level from all running hosts. Hosts that are in maintenance mode or are unresponsive are not counted. Resources used by the VMware Service Console are not included in the aggregate. This value represents the amount of resources available for the root resource pool for running virtual machines.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.totalMHz`
      </td>

      <td>
        Aggregated CPU resources of all hosts, in MHz. It does not filter out cpu used by system or related to hosts under maintenance.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Number of physical CPU cores. Physical CPU cores are the processors contained by a CPU package.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.threads`
      </td>

      <td>
        Aggregated number of CPU threads.
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Aggregated memory resources of all hosts, in MiB. It does not filter out memory used by system or related to hosts under maintenance.
      </td>
    </tr>

    <tr>
      <td>
        `mem.effectiveSize`
      </td>

      <td>
        Effective memory resources, in MiB, available to run virtual machines. This is the aggregated effective resource level from all running hosts. Hosts that are in maintenance mode or are unresponsive are not counted. Resources used by the VMware Service Console are not included in the aggregate. This value represents the amount of resources available for the root resource pool for running virtual machines.
      </td>
    </tr>

    <tr>
      <td>
        `effectiveHosts`
      </td>

      <td>
        Total number of effective hosts. This number exclude hosts under maintenance.
      </td>
    </tr>

    <tr>
      <td>
        `hosts`
      </td>

      <td>
        Total number of hosts
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Status is unknown.
        * `green`: Entity is OK.
        * `yellow`: Entity might have a problem.
        * `red`: Entity definitely has a problem.
      </td>
    </tr>

    <tr>
      <td>
        `datastoreList`
      </td>

      <td>
        List of datastore used by the cluster. A pipe or vertical bar character (`|`) is used as a separator.
      </td>
    </tr>

    <tr>
      <td>
        `hostList`
      </td>

      <td>
        List of hosts belonging to the cluster. A pipe or vertical bar character (`|`) is used as a separator.
      </td>
    </tr>

    <tr>
      <td>
        `networkList`
      </td>

      <td>
        List of networks attached to the cluster. A pipe or vertical bar character (`|`) is used as a separator.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.vmotionRate`
      </td>

      <td>
        Threshold for generated ClusterRecommendations. DRS generates only those recommendations that are above the specified vmotionRate. Ratings vary from 1 to 5. This setting applies to manual, partiallyAutomated, and fullyAutomated DRS clusters.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.restartPriorityTimeout`
      </td>

      <td>
        Maximum time the lower priority VMs should wait for the higher priority VMs to be ready (Seconds).
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Datacenter name.
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Datacenter location.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.enabled`
      </td>

      <td>
        Flag indicating whether or not the service is enabled.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.enableVmBehaviorOverrides`
      </td>

      <td>
        Flag that dictates whether DRS Behavior overrides for individual virtual machines (ClusterDrsVmConfigInfo) are enabled.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.defaultVmBehavior`
      </td>

      <td>
        Specifies the cluster-wide default DRS behavior for virtual machines. You can override the default behavior for a virtual machine by using the ClusterDrsVmConfigInfo object.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.enabled`
      </td>

      <td>
        Flag to indicate whether or not vSphere HA feature is enabled.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.admissionControlEnabled`
      </td>

      <td>
        Flag that determines whether strict admission control is enabled
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.isolationResponse`
      </td>

      <td>
        Indicates whether or not the virtual machine should be powered off if a host determines that it is isolated from the rest of the compute resource.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.restartPriority`
      </td>

      <td>
        Restart priority for a virtual machine.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.hostMonitoring`
      </td>

      <td>
        Determines whether HA restarts virtual machines after a host fails.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.vmMonitoring`
      </td>

      <td>
        Level of HA Virtual Machine Health Monitoring Service.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.vmComponentProtecting`
      </td>

      <td>
        This property indicates if vSphere HA VM Component Protection service is enabled.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.hbDatastoreCandidatePolicy`
      </td>

      <td>
        The policy on what datastores will be used by vCenter Server to choose heartbeat datastores: allFeasibleDs, allFeasibleDsWithUserPreference, userSelectedDs
      </td>
    </tr>
  </tbody>
</table>

### VSphereSnapshotVmSample [#vspheresnapshot]

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `snapshotTreeInfo`
      </td>

      <td>
        Tree info for the snapshot. Es: Cluster:Vm:Snapshot1:Snapshot2
      </td>
    </tr>

    <tr>
      <td>
        `name`
      </td>

      <td>
        Snapshot name
      </td>
    </tr>

    <tr>
      <td>
        `creationTime`
      </td>

      <td>
        Snapshot creation time
      </td>
    </tr>

    <tr>
      <td>
        `powerState`
      </td>

      <td>
        The power state of the virtual machine when this snapshot was taken
      </td>
    </tr>

    <tr>
      <td>
        `snapshotId`
      </td>

      <td>
        The unique identifier that distinguishes this snapshot from other snapshots of the virtual machine
      </td>
    </tr>

    <tr>
      <td>
        `quiesced`
      </td>

      <td>
        Flag to indicate whether or not the snapshot was created with the "quiesce" option, ensuring a consistent state of the file system
      </td>
    </tr>

    <tr>
      <td>
        `backupManifest`
      </td>

      <td>
        The relative path from the snapshotDirectory pointing to the backup manifest. Available for certain quiesced snapshots only
      </td>
    </tr>

    <tr>
      <td>
        `description`
      </td>

      <td>
        Description of the snapshot
      </td>
    </tr>

    <tr>
      <td>
        `replaySupported`
      </td>

      <td>
        Flag to indicate whether this snapshot is associated with a recording session on the virtual machine that can be replayed
      </td>
    </tr>

    <tr>
      <td>
        `totalMemoryInDisk`
      </td>

      <td>
        Total size of memory in disk.
      </td>
    </tr>

    <tr>
      <td>
        `totalUniqueMemoryInDisk`
      </td>

      <td>
        Total size of the file corresponding to the file blocks that were allocated uniquely to store memory. In other words, if the underlying storage supports sharing of file blocks across disk files, the property corresponds to the size of the file blocks that were allocated only in context of this file. It does not include shared blocks that were allocated in other files. This property will be unset if the underlying implementation is unable to compute this information.
      </td>
    </tr>

    <tr>
      <td>
        `totalDisk`
      </td>

      <td>
        Total size of snapshot files in disk
      </td>
    </tr>

    <tr>
      <td>
        `totalUniqueDisk`
      </td>

      <td>
        Total size of the file corresponding to the file blocks that were allocated uniquely to store snapshot data in disk. In other words, if the underlying storage supports sharing of file blocks across disk files, the property corresponds to the size of the file blocks that were allocated only in context of this file. It does not include shared blocks that were allocated in other files. This property will be unset if the underlying implementation is unable to compute this information.
      </td>
    </tr>

    <tr>
      <td>
        `datastorePathDisk`
      </td>

      <td>
        Disk file path in the datastore
      </td>
    </tr>

    <tr>
      <td>
        `datastorePathMemory`
      </td>

      <td>
        Memory file path in the datastore
      </td>
    </tr>
  </tbody>
</table>

## Troubleshooting [#troubleshooting]

<CollapserGroup>
  <Collapser
    id="data-gaps"
    title="Gaps on reported data"
  >
    One possible reason for data gaps could be because of the integration taking too long to collect and process data from vCenter. In case the integration exceeds the [timeout](https://docs.newrelic.com/docs/infrastructure/host-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/#timeout), which by default is `120s`, the infrastructure agent will kill the integration, and a log message like the following will be printed:
    ``` shell
    level=warn msg="HeartBeat timeout exceeded after 120000000000" integration_name=nri-vsphere
    ```
    In order to fix this, you could extend the [timeout](https://docs.newrelic.com/docs/infrastructure/host-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/#timeout) parameter in the config file.

    ``` yaml
    integrations:
    - name: nri-vsphere
      env:
        # Integration configuration parameters.

      interval: 120s

      timeout: 300s
    ```

  </Collapser>
</CollapserGroup>
