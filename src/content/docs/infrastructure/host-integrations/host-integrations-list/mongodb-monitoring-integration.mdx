---
title: MongoDB monitoring integration
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: "New Relic's MongoDB integration: how to install it and configure it, and what data it reports."
redirects:
  - /docs/integrations/host-integrations/host-integrations-list/mongodb-monitoring-integration
  - /docs/mongodb-integration-new-relic-infrastructure
---

Our MongoDB [integration](/docs/integrations/host-integrations/getting-started/introduction-host-integrations) collects and sends inventory and metrics from your MongoDB cluster to our platform, where you can aggregate and visualize key performance metrics. We collect data on mongos, mongods, and config servers, as well as on databases and collections to help pinpoint performance bottlenecks.

Read on to install the integration, and to see what data we collect.

## Compatibility and requirements [#comp-req]

Our integration is compatible with MongoDB v3.0+. MongoDB Atlas is supported for tiers M10 and above.

Before installing the integration, make sure that you meet the following requirements:

* A New Relic account. Don't have one? [Sign up for free!](https://newrelic.com/signup) No credit card required.
* MongoDB user with [`clusterMonitor` and `listCollections` roles](#users-privileges).
* If MongoDB is **not** running on Kubernetes or Amazon ECS, you must [install the infrastructure agent](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic) on a host that's running MongoDB. Otherwise:
  * If running on Kubernetes, see [these requirements](/docs/monitor-service-running-kubernetes#requirements).
  * If running on ECS, see [these requirements](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).

## Quick start [#quick]

Instrument your MongoDB cluster quickly and send your telemetry data with guided install. Our guided install creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent.

![A screenshot of the guided install CLI.](./images/guided-install-cli.png "The guided install CLI.")

Ready to get started? Click one of these button to try it out.

<ButtonGroup>
<ButtonLink
  role="button"
  to="https://one.newrelic.com/launcher/nr1-core.explorer?pane=eyJuZXJkbGV0SWQiOiJucjEtY29yZS5saXN0aW5nIn0=&cards[0]=eyJuZXJkbGV0SWQiOiJucjEtaW5zdGFsbC1uZXdyZWxpYy5ucjEtaW5zdGFsbC1uZXdyZWxpYyIsInBhdGgiOiJvaGkiLCJyZWNpcGVOYW1lIjoibW9uZ29kYi1vcGVuLXNvdXJjZS1pbnRlZ3JhdGlvbiIsImFjdGl2ZUNvbXBvbmVudCI6IlZUU09Db21tYW5kIiwiYWN0aXZlRW52aXJvbm1lbnQiOiJtb25nb2RiLW9wZW4tc291cmNlLWludGVncmF0aW9uIn0="
  variant="primary"
>
  Guided install
</ButtonLink>

<ButtonLink
  role="button"
  to="https://one.eu.newrelic.com/launcher/nr1-core.explorer?pane=eyJuZXJkbGV0SWQiOiJucjEtY29yZS5saXN0aW5nIn0=&cards[0]=eyJuZXJkbGV0SWQiOiJucjEtaW5zdGFsbC1uZXdyZWxpYy5ucjEtaW5zdGFsbC1uZXdyZWxpYyIsInBhdGgiOiJvaGkiLCJyZWNpcGVOYW1lIjoibW9uZ29kYi1vcGVuLXNvdXJjZS1pbnRlZ3JhdGlvbiIsImFjdGl2ZUNvbXBvbmVudCI6IlZUU09Db21tYW5kIiwiYWN0aXZlRW52aXJvbm1lbnQiOiJtb25nb2RiLW9wZW4tc291cmNlLWludGVncmF0aW9uIn0="
  variant="primary"
>
  EU Guided install
</ButtonLink>
</ButtonGroup>

Our guided install uses the infrastructure agent to set up the MongoDB integration. Not only that, it discovers other applications and log sources running in your environment and then recommends which ones you should instrument.

The guided install works with most setups. But if it doesn't suit your needs, you can find other methods below to get started monitoring your MongoDB database.

## Install and activate [#install]

To install the MongoDB integration, follow the instructions for your environment:

<CollapserGroup>
  <Collapser
    id="ecs-install"
    title="ECS"
  >
    See [Monitor service running on ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
  </Collapser>

  <Collapser
    id="k8s-install"
    title="Kubernetes"
  >
    See [Monitor service running on Kubernetes](/docs/monitor-service-running-kubernetes).
  </Collapser>

  <Collapser
    id="linux-install"
    title="Linux"
  >
    1. Follow the instructions for [installing an integration](/docs/install-integrations-package), using the file name `nri-mongodb`.
    2. Change directory to the integrations folder:

       ```
       cd /etc/newrelic-infra/integrations.d
       ```
    3. Copy of the sample configuration file:

       ```
       sudo cp mongodb-config.yml.sample mongodb-config.yml
       ```
    4. Edit the `mongodb-config.yml` file as described in the [configuration settings](#config).
    5. [Restart the infrastructure agent](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).
  </Collapser>

  <Collapser
    id="windows-install"
    title="Windows"
  >
    1. Download the `nri-mongodb` .MSI installer image from:

       [http://download.newrelic.com/infrastructure_agent/windows/integrations/nri-mongodb/nri-mongodb-amd64.msi](http://download.newrelic.com/infrastructure_agent/windows/integrations/nri-mongodb/nri-mongodb-amd64.msi)
    2. To install from the Windows command prompt, run:

       ```
       msiexec.exe /qn /i <var>PATH\TO\</var>nri-mongodb-amd64.msi
       ```
    3. In the Integrations directory, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, create a copy of the sample configuration file by running:

       ```
       cp mongodb-config.yml.sample mongodb-config.yml
       ```
    4. Edit the `mongodb-config.yml` configuration file using the [configuration settings](#config).
    5. [Restart the infrastructure agent](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).
  </Collapser>
</CollapserGroup>

Additional notes:

* **Advanced:** Integrations are also available in [tarball format](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball) to allow for install outside of a package manager.
* **On-host integrations do not automatically update.** For best results, regularly [update the integration package](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) and [the infrastructure agent](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

## Configuration [#configuration]

### Enabling your MongoDB server [#enable-instance]

In the [MongoDB shell](https://docs.mongodb.com/manual/mongo/), execute the following commands to create a `listCollections` role and a new user, then assign `clusterMonitor` and `listCollections` roles to the new user. Note: <var>username</var>, <var>password</var>, and similar user-specific values must be replaced.

See the MongoDB documentation for details on [creating users](https://docs.mongodb.com/manual/reference/method/db.createUser/index.html) and [roles](https://docs.mongodb.com/manual/reference/method/db.createRole/index.html).

<Callout variant="tip">
  Complete these steps on the mongos to be monitored. If mongod-level metrics are to be collected, such as host or replica set statistics, create the role and user on each mongod as well.
</Callout>

1. In the MongoDB shell, enter `use admin`.
2. Use the following command to create the `listCollections` role.

   ```
   db.createRole({
       role: "listCollections",
       privileges: [{
           resource: {db:"",collection:""},
           actions: ["listCollections"]
       }],
       roles: []
   })
   ```
3. Use the following commands to create a new user, and assign `clusterMonitor` and `listCollections` roles to the user.

   ```
   db.createUser({
       user: "<var>username</var>",
       pwd: "<var>password</var>",
       roles: [
           "clusterMonitor",
           "listCollections"
       ]
   })
   ```

### Configure the integration [#config]

There are several ways to configure the integration, depending on how it was installed:

* If enabled via Kubernetes: see [Monitor services running on Kubernetes](/docs/monitor-service-running-kubernetes).
* If enabled via Amazon ECS: see [Monitor services running on ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
* If installed on-host: edit the config in the integration's YAML config file, `mongodb-config.yml`.

An integration's YAML-format configuration is where you can place required login credentials and configure how data is collected. Which options you change depend on your setup and preference.

The configuration file has common settings applicable to all integrations, such as `interval`, `timeout`, `inventory_source`. To read all about these common settings, refer to our [Configuration Format](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) document.

<Callout variant="important">
  If you are still using our legacy configuration/definition files, please refer to this [document](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/) for help.
</Callout>

Specific settings related to MongoDB are defined using the `env` section of the configuration file. These settings control the connection to your MongoDB instance as well as other security settings and features. The list of valid settings is described in the next section of this document.

<Callout variant="tip">
  The MongoDB integration can be configured to monitor either a full MongoDB cluster or a standalone MongoDB instance. To monitor a cluster, the `host` and `port` [arguments](#arguments) should point to one of the `mongos` instances in your cluster.

  If you want to instead monitor a standalone instance, `host` and `port` should point to the `mongod` running the database.
</Callout>

### MongoDB Instance Settings [#instance-settings]

The MongoDB integration collects both metrics and inventory information. In the table, use the **Applies To** column for the settings available to each collection:

<table>
  <thead>
  <tr>
    <th style={{ width: "150px" }}>
      Setting
    </th>
    <th>
      Description
    </th>
    <th>
      Default
    </th>
    <th>
      <nobr>Applies to</nobr>
    </th>
  </tr>
  </thead>

  <tbody>
  <tr>
    <td>
      **MONGODB_CLUSTER_NAME**
    </td>
    <td>
      User-defined name to uniquely identify the cluster being monitored. **Required**.
    </td>
    <td>
      N/A
    </td>
    <td  >
      Metrics/Inventory
    </td>
  </tr>

  <tr>
    <td>
      **HOST**
    </td>
    <td>
      Hostname or IP where MongoDB is running.
    </td>
    <td>
      localhost
    </td>
    <td  >
      Metrics/Inventory
    </td>
  </tr>

  <tr>
    <td>
      **PORT**
    </td>
    <td>
      Port on which MongoDB is listening.
    </td>
    <td>
       27017
    </td>
    <td  >
      Metrics/Inventory
    </td>
  </tr>

  <tr>
    <td>
      **USERNAME**
    </td>
    <td>
      Username for accessing MongoDB server.
    </td>
    <td>
      N/A
    </td>
    <td  >
      Metrics/Inventory
    </td>
  </tr>

  <tr>
    <td>
      **PASSWORD**
    </td>
    <td>
      Password for the given user.
    </td>
    <td>
      N/A
    </td>
    <td  >
      Metrics/Inventory
    </td>
  </tr>

  <tr>
    <td>
      **AUTH_SOURCE**
    </td>
    <td>
      The database to authenticate against.
    </td>
    <td>
      admin
    </td>
    <td  >
      Metrics/Inventory
    </td>
  </tr>

  <tr>
    <td>
      **SSL**
    </td>
    <td>
      Use SSL when communicating with the MongoDB server.
    </td>
    <td>
      false
    </td>
    <td  >
      Metrics/Inventory
    </td>
  </tr>

  <tr>
    <td>
      **SSL_CA_CERTS**
    </td>
    <td>
      Location of SSL certificate on the host. Only required if `SSL` is true.
    </td>
    <td>
      N/A
    </td>
    <td  >
      Metrics/Inventory
    </td>
  </tr>

  <tr>
    <td>
      **SSL_INSECURE_SKIP_VERIFY**
    </td>
    <td>
      Skip the verification of the server's certificate chain and hostname.
    </td>
    <td>
      false
    </td>
    <td  >
      Metrics/Inventory
    </td>
  </tr>

  <tr>
    <td>
      **PEM_KEY_FILE**
    </td>
    <td>
      Location of PEM file containing Private Key and Client Certificate.
    </td>
    <td>
      N/A
    </td>
    <td  >
      Metrics/Inventory
    </td>
  </tr>

  <tr>
    <td>
      **PASSPHRASE**
    </td>
    <td>
      Passphrase to decrypt PEMKeyFile file.
    </td>
    <td>
      N/A
    </td>
    <td  >
      Metrics/Inventory
    </td>
  </tr>

  <tr>
    <td>
      **CONCURRENT_COLLECTIONS**
    </td>
    <td>
      Number of entities to collect metrics for concurrently.
    </td>
    <td>
      50
    </td>
    <td  >
      Metrics
    </td>
  </tr>

  <tr>
    <td>
      **FILTERS**
    </td>
    <td>
      A JSON map of database names to an array of collection names. If empty, defaults to all databases and collections.
    </td>
    <td>
      N/A
    </td>
    <td  >
      Metrics
    </td>
  </tr>

  <tr>
    <td>
      **METRICS**
    </td>
    <td>
      Set to `true` to enable metrics-only collection.
    </td>
    <td>
      false
    </td>
    <td  >
    </td>
  </tr>

  <tr>
    <td>
      **INVENTORY**
    </td>
    <td>
      Set to `true` to enable inventory-only collection.
    </td>
    <td>
      false
    </td>
    <td  >
    </td>
  </tr>

  </tbody>
</table>

The values for these settings can be defined in several ways:
* Adding the value directly in the config file. This is the most common way.
* Replacing the values from environment variables using the `{{}}` notation. This requires infrastructure agent v1.14.0+. Read more [here](/docs/infrastructure/install-infrastructure-agent/configuration/configure-infrastructure-agent/#passthrough) or see the example [below](#envvar-replacement).
* Using secrets management. Use this to protect sensitive information, such as passwords that would be exposed in plain text on the configuration file. For more information, see [Secrets management](https://docs.newrelic.com/docs/integrations/host-integrations/installation/secrets-management).


### Labels/Custom attributes [#labels]

You can further decorate your metrics using labels. Labels allow you to add key/value pair attributes to your metrics, which you can then use to query, filter, or group your metrics on.<br/>
Our default sample config file includes examples of labels; however, as they are not mandatory, you can remove, modify, or add new ones of your choice.

```
 labels:
   env: production
   role: load_balancer
```

## Example configurations [#examples]

<CollapserGroup>
  <Collapser
    id="basic-config"
    title="Basic configuration"
  >
    This is the basic configuration used to collect metrics and inventory from your localhost:

    ```
    integrations:
      - name: nri-mongodb
        env:
          CLUSTER_NAME: my_cluster
          HOST: localhost
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          environment: production
        inventory_source: config/mongodb
    ```
  </Collapser>
  <Collapser
    id="basic-intervals"
    title="Basic configuration with different metric/inventory intervals"
  >
    This configuration collects metrics every 15 seconds and inventory every 60 seconds:

    ```
    integrations:
      - name: nri-mongodb
        env:
          METRICS: true
          CLUSTER_NAME: my_cluster
          HOST: localhost
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          environment: production

      - name: nri-mongodb
        env:
          INVENTORY: true
          CLUSTER_NAME: my_cluster
          HOST: localhost
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 60s
        labels:
          environment: production
        inventory_source: config/mongodb
    ```
  </Collapser>

  <Collapser
    id="envvar-replacement"
    title="Environment variables replacement"
  >
    In this configuration we are using the environment variable `MONGODB_HOST` to populate the HOST setting of the integration:

    ```
    integrations:
      - name: nri-mongodb
        env:
          METRICS: "true"
          CLUSTER_NAME: my_cluster
          HOST: {{MONGODB_HOST}}
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
    ```
  </Collapser>

    <Collapser
    id="filters"
    title="Filters"
  >
    In this configuration we are using filters to narrow down the databases and collections we monitor. With this sample filter the integration will collect:

      * `db1` database metrics and all its collections. Use `null` to collect all collections from a database
      * `db2` database metrics and metrics for `collection1` and `collection2`
      * `db3` database metrics and no collection metrics. Use an empty array `[]` if you want to skip collection metrics


    ```
    integrations:
      - name: nri-mongodb
        env:
          METRICS: "true"
          CLUSTER_NAME: my_cluster
          HOST: localhost
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
          FILTERS: '{“db1”:null,”db2”:[“collection1”,”collection2”],”db3”:[]}'
        interval: 15s
        labels:
          env: production
          role: load_balancer
    ```
  </Collapser>

  <Collapser
    id="multi-instance"
    title="Multi-instance monitoring"
  >
    In this configuration we are monitoring multiple MongoDB servers from the same integration. For the first instance (`HOST: 1st_mongodb_host`) we are collecting metrics and inventory while for the second instance (`HOST: 2nd_mongodb_host`) we will only collect metrics.

    ```
    integrations:
      - name: nri-mongodb
        env:
          METRICS: "true"
          CLUSTER_NAME: my_cluster
          HOST: 1st_mongodb_host
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
      - name: nri-mongodb
        env:
          INVENTORY: "true"
          CLUSTER_NAME: my_cluster
          HOST: 1st_mongodb_host
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 60s
        labels:
          env: production
          role: load_balancer
        inventory_source: config/mongodb

      - name: nri-mongodb
        env:
          METRICS: "true"
          CLUSTER_NAME: my_2nd_cluster
          HOST: 2nd_mongodb_host
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
    ```
  </Collapser>

</CollapserGroup>

## Find and use data [#find-and-use]

Data from this service is reported to an [integration dashboard](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts).

Metrics are attached to these [event types](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic):

* `MongoCollectionSample`
* `MongoConfigServerSample`
* `MongoDatabaseSample`
* `MongodTopSample`
* `MongoSample`
* `MongodSample`
* `MongosSample`

You can [query this data](/docs/using-new-relic/data/understand-data/query-new-relic-data) for troubleshooting purposes or to create custom charts and dashboards.

For more on how to find and use your data, see [Understand integration data](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Metric data [#metrics]

The MongoDB integration collects the following metric data attributes. Some metric name are prefixed with a category indicator and a period, such as `asserts.` or `collection.`.

<Callout variant="tip">
  Different metrics are available depending on whether a cluster or a standalone instance is being monitored. For a standalone instance, only [MongodSample](#mongod-clamshell), [MongoDatabaseSample](#mongo-database-clamshell), [MongodTopSample](#mongo-top-clamshell) and [MongoCollectionSample](#mongo-collection-clamshell) are collected. For a cluster, all event types are collected.
</Callout>

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="mongo-collection-clamshell"
    title="Mongo collection sample metrics"
  >
    These attributes are attached to the `MongoCollectionSample` event type:

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `collection.avgObjSizeInBytes`
          </td>

          <td>
            The size of the average object in the collection, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `collection.capped`
          </td>

          <td>
            Whether or not the collection is capped.
          </td>
        </tr>

        <tr>
          <td>
            `collection.count`
          </td>

          <td>
            The total number of objects in the collection.
          </td>
        </tr>

        <tr>
          <td>
            `collection.indexAccesses`
          </td>

          <td>
            The number of time the index was used.
          </td>
        </tr>

        <tr>
          <td>
            `collection.indexSizeInBytes`
          </td>

          <td>
            The size of index, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `collection.max`
          </td>

          <td>
            The maximum number of documents in a capped collection.
          </td>
        </tr>

        <tr>
          <td>
            `collection.maxSizeInBytes`
          </td>

          <td>
            The maximum size of a capped collection, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `collection.nindexes`
          </td>

          <td>
            The total number of indices on the collection.
          </td>
        </tr>

        <tr>
          <td>
            `collection.sizeInBytes`
          </td>

          <td>
            The total size of the data in the collection plus the size of every indexes on the collection, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `collection.storageSizeInBytes`
          </td>

          <td>
            The total storage space allocated to this collection for document storage, in bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongo-config-server-clamshell"
    title="Mongo config server sample metrics"
  >
    These attributes are attached to the `MongoConfigServerSample` event type:

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `asserts.messagesPerSecond`
          </td>

          <td>
            The number of message assertions raised per second.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.regularPerSecond`
          </td>

          <td>
            The number of regular assertions raised per second.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.rolloversPerSecond`
          </td>

          <td>
            The number of times that the rollover counters roll over. The counters rollover to zero every 2^30 assertions per second.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.userPerSecond`
          </td>

          <td>
            The number of user assertions raised per second.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.warningPerSecond`
          </td>

          <td>
            The number of warnings raised per second.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countFailedPerSecond`
          </td>

          <td>
            The number of times `count` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countPerSecond`
          </td>

          <td>
            The number of times `count` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesFailedPerSecond`
          </td>

          <td>
            The number of times `createIndexes` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesPerSecond`
          </td>

          <td>
            The number of times `createIndexe` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deleteFailedPerSecond`
          </td>

          <td>
            The number of times `delete` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deletePerSecond`
          </td>

          <td>
            The number of times `delete` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalFailedPerSecond`
          </td>

          <td>
            The number of times `eval` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalPerSecond`
          </td>

          <td>
            The number of times `eval` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyFailedPerSecond`
          </td>

          <td>
            The number of times `findAndModify` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyPerSecond`
          </td>

          <td>
            The number of times `findAndModify` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertFailedPerSecond`
          </td>

          <td>
            The number of times `insert` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertPerSecond`
          </td>

          <td>
            The number of times `insert` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updateFailedPerSecond`
          </td>

          <td>
            The number of times `update` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updatePerSecond`
          </td>

          <td>
            The number of times `update` executed.
          </td>
        </tr>

        <tr>
          <td>
            `connections.available`
          </td>

          <td>
            The number of unused available incoming connections the database can provide.
          </td>
        </tr>

        <tr>
          <td>
            `connections.current`
          </td>

          <td>
            The number of connections to the database server from clients.
          </td>
        </tr>

        <tr>
          <td>
            `connections.totalCreated`
          </td>

          <td>
            The total number of connections created.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openNoTimeout`
          </td>

          <td>
            The number of open cursors with the option `DBQueryOptionnotimeout` set to prevent timeout after a period of inactivity.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openPinned`
          </td>

          <td>
            The number of pinned open cursors.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openTotal`
          </td>

          <td>
            The number of cursors that MongoDB is maintaining for clients.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.timedOutPerSecond`
          </td>

          <td>
            The total number of cursors that have timed out since the server process started.
          </td>
        </tr>

        <tr>
          <td>
            `document.deletedPerSecond`
          </td>

          <td>
            The number of documents deleted per second.
          </td>
        </tr>

        <tr>
          <td>
            `document.insertedPerSecond`
          </td>

          <td>
            The number of documents inserted per second.
          </td>
        </tr>

        <tr>
          <td>
            `document.returnedPerSecond`
          </td>

          <td>
            The number of documents returned by queries per second.
          </td>
        </tr>

        <tr>
          <td>
            `document.updatedPerSecond`
          </td>

          <td>
            The number of documents updated per second.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commits`
          </td>

          <td>
            The number of transactions written to the journal during the last journal group commit interval.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInMilliseconds`
          </td>

          <td>
            The amount of time spent for commits, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLock`
          </td>

          <td>
            The count of the commits that occurred while a write lock was held.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLockInMilliseconds`
          </td>

          <td>
            The amount of time spent for commits that occurred while a write lock was held, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.compression`
          </td>

          <td>
            The compression ratio of the data written to the journal.
          </td>
        </tr>

        <tr>
          <td>
            `dur.dataWrittenJournalDataFilesInBytes`
          </td>

          <td>
            The amount of data written from journal to the data files during the last journal group commit interval, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.earlyCommits`
          </td>

          <td>
            The number of times MongoDB has requested a commit before the scheduled journal group commit interval.
          </td>
        </tr>

        <tr>
          <td>
            `dur.journaledInBytes`
          </td>

          <td>
            The amount of data written to journal during the last journal group commit interval, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.preparingInMilliseconds`
          </td>

          <td>
            The amount of time spent preparing to write to the journal, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.remappingInMilliseconds`
          </td>

          <td>
            The amount of time spent remapping copy-on-write memory mapped views, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.timeCollectedCommitsInMilliseconds`
          </td>

          <td>
            The amount of time over which MongoDB collected the `durcommitsInMilliseconds` data, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingDataFilesInMilliseconds`
          </td>

          <td>
            The amount of time spent writing to data files after journaling, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingJournalInMilliseconds`
          </td>

          <td>
            The amount of time spent writing to the journal, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `flush.averageInMilliseconds`
          </td>

          <td>
            The average time for each flush to disk, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `flush.flushesDisk`
          </td>

          <td>
            The number of times the database has flushed all writes to disk.
          </td>
        </tr>

        <tr>
          <td>
            `flush.lastInMilliseconds`
          </td>

          <td>
            The amount of time that the last flush operation took to complete, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `flush.totalInMilliseconds`
          </td>

          <td>
            The total amount of time that the mongod processes have spent writing (that is, flushing) data to disk, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeMillisPerSecond`
          </td>

          <td>
            The number of `getLastError` operations with a specified write concern (for example, `w`) that wait for one or more members of a replica set to acknowledge the write operation per second.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeoutsPerSecond`
          </td>

          <td>
            The number of times that write concern operations have timed out as a result of the wtimeout threshold to `getLastError` per second.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsReaders`
          </td>

          <td>
            The count of the active client connections performing read operations.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsTotal`
          </td>

          <td>
            The total number of active client connections to the database.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsWriters`
          </td>

          <td>
            The count of active client connections performing write operations.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueReaders`
          </td>

          <td>
            The number of operations that are currently queued and waiting for the read lock.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueTotal`
          </td>

          <td>
            The total number of operations queued waiting for the lock.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueWriters`
          </td>

          <td>
            The number of operations that are currently queued and waiting for the write lock.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.totaltime`
          </td>

          <td>
            The time since the database last started and created the global lock.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireExclusive`
          </td>

          <td>
            The number of times the collection lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentExclusive`
          </td>

          <td>
            The number of times the collection lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentShared`
          </td>

          <td>
            The number of times the collection lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireShared`
          </td>

          <td>
            The number of times the collection lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountExclusive`
          </td>

          <td>
            The number of times the collection lock type acquisition in the Exclusive (X) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountShared`
          </td>

          <td>
            The number of times the collection lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosExclusive`
          </td>

          <td>
            The wait time for the collection lock type acquisitions in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosShared`
          </td>

          <td>
            The wait time for the collection lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireExclusive`
          </td>

          <td>
            The number of times the database lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentExclusive`
          </td>

          <td>
            The number of times the database lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentShared`
          </td>

          <td>
            The number of times the database lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireShared`
          </td>

          <td>
            The number of times the database lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitExclusive`
          </td>

          <td>
            The number of times the database lock type acquisition in the Exclusive (X) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentExclusive`
          </td>

          <td>
            The number of times the database lock type acquisition in the Intent Exclusive (IX) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentShared`
          </td>

          <td>
            The number of times the database lock type acquisition in the Intent Shared (IS) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitShared`
          </td>

          <td>
            The number of times the database lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosExclusive`
          </td>

          <td>
            The wait time for the database lock type acquisitions in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            The wait time for the database lock type acquisitions in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            The wait time for the database lock type acquisitions in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosShared`
          </td>

          <td>
            The wait time for the database lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireExclusive`
          </td>

          <td>
            The number of times the global lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentExclusive`
          </td>

          <td>
            The number of times the global lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentShared`
          </td>

          <td>
            The number of times the global lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireShared`
          </td>

          <td>
            The number of times the global lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitExclusive`
          </td>

          <td>
            The number of times the global lock type acquisition in the Exclusive (X) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentExclusive`
          </td>

          <td>
            The number of times the global lock type acquisition in the Intent Exclusive (IX) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentShared`
          </td>

          <td>
            The number of times the global lock type acquisition in the Intent Shared (IS) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitShared`
          </td>

          <td>
            The number of times the global lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            The wait time for the global lock type acquisitions in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            The wait time for the global lock type acquisitions in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            The wait time for the global lock type acquisitions in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosShared`
          </td>

          <td>
            The wait time for the global lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireExclusive`
          </td>

          <td>
            The number of times the metadata lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireShared`
          </td>

          <td>
            The number of times the metadata lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireExclusive`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentExclusive`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentShared`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireShared`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitExclusive`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type acquisition in the Exclusive (X) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentExclusive`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type acquisition in the Intent Exclusive (IX) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentShared`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type acquisition in the Intent Shared (IS) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitShared`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            The wait time for the MMAPv1 storage engine lock type acquisitions in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            The wait time for the MMAPv1 storage engine lock type acquisitions in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            The wait time for the MMAPv1 storage engine lock type acquisitions in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosShared`
          </td>

          <td>
            The wait time for the MMAPv1 storage engine lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireExclusive`
          </td>

          <td>
            The number of times the oplog lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentExclusive`
          </td>

          <td>
            The number of times the oplog lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentShared`
          </td>

          <td>
            The number of times the oplog lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireShared`
          </td>

          <td>
            The number of times the oplog lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitIntentExclusive`
          </td>

          <td>
            The number of times the oplog lock type acquisition in the Intent Exclusive (IX) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitShared`
          </td>

          <td>
            The number of times the oplog lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            The wait time for the oplog lock type acquisitions in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            The wait time for the oplog lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `mem.bits`
          </td>

          <td>
            The size of the in-memory storage engine.
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedInBytes`
          </td>

          <td>
            The amount of mapped memory by the database, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedWithJournalInBytes`
          </td>

          <td>
            The amount of mapped memory, including the memory used for journaling, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `mem.residentInBytes`
          </td>

          <td>
            The amount of memory currently used by the database process, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `mem.virtualInBytes`
          </td>

          <td>
            The amount of virtual memory used by the mongod process, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesInPerSecond`
          </td>

          <td>
            The number of bytes that reflects the amount of network traffic into this database.
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesOutPerSecond`
          </td>

          <td>
            The number of bytes that reflects the amount of network traffic sent from this database.
          </td>
        </tr>

        <tr>
          <td>
            `network.requestsPerSecond`
          </td>

          <td>
            The number of distinct requests that the server has received.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.commandPerSecond`
          </td>

          <td>
            The total number of commands issued to the database per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.deletePerSecond`
          </td>

          <td>
            The number of delete operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.getmorePerSecond`
          </td>

          <td>
            The number of getmore operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.insertPerSecond`
          </td>

          <td>
            The number of insert operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.queryPerSecond`
          </td>

          <td>
            The total number of queries per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.updatePerSecond`
          </td>

          <td>
            The number of update operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.commandPerSecond`
          </td>

          <td>
            The total number of replicated commands issued to the database per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.deletePerSecond`
          </td>

          <td>
            The number of replicated delete operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.getmorePerSecond`
          </td>

          <td>
            The number of replicated getmore operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.insertPerSecond`
          </td>

          <td>
            The number of replicated insert operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.queryPerSecond`
          </td>

          <td>
            The total number of replicated queries per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.updatePerSecond`
          </td>

          <td>
            The number of replicated update operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `operation.fastmodPerSecond`
          </td>

          <td>
            The number of update operations that neither cause documents to grow nor require updates to the index per second.
          </td>
        </tr>

        <tr>
          <td>
            `operation.idhackPerSecond`
          </td>

          <td>
            The number of queries that contain the `_id` field per second.
          </td>
        </tr>

        <tr>
          <td>
            `operation.scanAndOrderPerSecond`
          </td>

          <td>
            The number of queries that return sorted numbers that cannot perform the sort operation using an index per second.
          </td>
        </tr>

        <tr>
          <td>
            `operation.writeConflictsPerSecond`
          </td>

          <td>
            The number of times that write concern operations has encountered a conflict per second.
          </td>
        </tr>

        <tr>
          <td>
            `pageFaultsPerSecond`
          </td>

          <td>
            The number of page faults that require disk operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `queryexecutor.scannedPerSecond`
          </td>

          <td>
            The number of index items scanned during queries and query-plan evaluation per second.
          </td>
        </tr>

        <tr>
          <td>
            `record.movesPerSecond`
          </td>

          <td>
            The number of times documents move within the on-disk representation of the MongoDB data set per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.batchesPerSecond`
          </td>

          <td>
            The number of batches applied across all databases per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.operationsPerSecond`
          </td>

          <td>
            The number of oplog operations applied per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.count`
          </td>

          <td>
            The number of operations in the oplog buffer.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.maxSizeInBytes`
          </td>

          <td>
            The maximum size of the buffer, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.sizeInBytes`
          </td>

          <td>
            The current size of the contents of the oplog buffer, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsLoadedPrefetch`
          </td>

          <td>
            The number of documents loaded during the pre-fetch stage of replication.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsPreloadInMilliseconds`
          </td>

          <td>
            The amount of time spent loading documents as part of the pre-fetch stage of replication, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexLoadedPrefetch`
          </td>

          <td>
            The number of index entries loaded by members before updating documents as part of the pre-fetch stage of replication.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexPreloadInMilliseconds`
          </td>

          <td>
            The amount of time spent loading indices as part of the pre-fetch stage of replication, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.bytesPerSecond`
          </td>

          <td>
            The amount of data read from the replication sync source per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.getmoresPerSecond`
          </td>

          <td>
            The number of getmore operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.operationPerSecond`
          </td>

          <td>
            The number of operations read from the replication source per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.readersCreatedPerSecond`
          </td>

          <td>
            The number of oplog query processes created per second.
          </td>
        </tr>

        <tr>
          <td>
            `replset.health`
          </td>

          <td>
            The Member health value of the replica set: conveys if the member is up (`1`) or down (`0`).
          </td>
        </tr>

        <tr>
          <td>
            `replset.isArbiter`
          </td>

          <td>
            `1` if the mongod is an arbiter, `0` otherwise.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isHidden`
          </td>

          <td>
            `1` if the mongod is hidden, `0` otherwise.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isMaster`
          </td>

          <td>
            `1` if the mongod is the current master, `0` otherwise.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isSecondary`
          </td>

          <td>
            `1` if the mongod is currently secondary, `0` otherwise.
          </td>
        </tr>

        <tr>
          <td>
            `replset.priority`
          </td>

          <td>
            The election priority of the mongod.
          </td>
        </tr>

        <tr>
          <td>
            `replset.replicationLag`
          </td>

          <td>
            The delay between a write operation on the primary and its copy to a secondary.
          </td>
        </tr>

        <tr>
          <td>
            `replset.state`
          </td>

          <td>
            The state of a replica that reflects its disposition within the set.
          </td>
        </tr>

        <tr>
          <td>
            `replset.uptimeInMilliseconds`
          </td>

          <td>
            The number of seconds that the mongos or mongod process has been active, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `replset.voteFraction`
          </td>

          <td>
            The fraction of votes a server will cast in a replica set election.
          </td>
        </tr>

        <tr>
          <td>
            `replset.votes`
          </td>

          <td>
            The number of votes a server will cast in a replica set election.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.deleteDocumentsPerSecond`
          </td>

          <td>
            The number of documents deleted from collections with a ttl index per second.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.removeDocumentPerSecond`
          </td>

          <td>
            The number of times the background process removes documents from collections with a ttl index per second.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheDirtyDataInBytes`
          </td>

          <td>
            The size of the dirty data in the cache, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInBytes`
          </td>

          <td>
            The size of the data currently in cache, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInMemoryPageSplits`
          </td>

          <td>
            The in-memory page splits.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxInBytes`
          </td>

          <td>
            The maximum cache size, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxPageSizeEvictionInBytes`
          </td>

          <td>
            The maximum page size at eviction, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheModifiedPagesEvicted`
          </td>

          <td>
            The number of pages, that have been modified, evicted from the cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedApplicationThreadsPerSecond`
          </td>

          <td>
            The number of page evicted by application threads per second.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedInMemoryMaxPerSecond`
          </td>

          <td>
            The number of pages evicted because they exceeded the cache in-memory maximum, per second.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesHeld`
          </td>

          <td>
            The number of pages currently held in the cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheUnmodifiedPagesEvicted`
          </td>

          <td>
            The number of pages, that were not modified, evicted from the cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadAvailable`
          </td>

          <td>
            The number of available read tickets (concurrent transactions) remaining.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadRemaining`
          </td>

          <td>
            The number of read tickets (concurrent transactions) in use.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadTotal`
          </td>

          <td>
            The total number of read tickets (concurrent transactions) available.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteAvailable`
          </td>

          <td>
            The number of available write tickets (concurrent transactions) remaining.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteRemaining`
          </td>

          <td>
            The number of write tickets (concurrent transactions) in use.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteTotal`
          </td>

          <td>
            The total number of write tickets (concurrent transactions) available.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.failedEvictionsPagesPerSecond`
          </td>

          <td>
            The number of failed eviction of pages that exceeded the in-memory maximum, per second.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongo-database-clamshell"
    title="Mongo database sample metrics"
  >
    These attributes are attached to the `MongoDatabaseSample` event type:

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `stats.dataInBytes`
          </td>

          <td>
            The total size of the data held in this database including the padding factor, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `stats.indexes`
          </td>

          <td>
            The total number of indexes across all collections in the database.
          </td>
        </tr>

        <tr>
          <td>
            `stats.indexInBytes`
          </td>

          <td>
            The total size of all indexes created on this database, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `stats.objects`
          </td>

          <td>
            The number of objects (documents) in the database across all collections.
          </td>
        </tr>

        <tr>
          <td>
            `stats.storageInBytes`
          </td>

          <td>
            The total amount of space allocated to collections in this database for document storage, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `totalDatabases`
          </td>

          <td>
            The total number of existing databases.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongod-top-clamshell"
    title="Mongo top sample metrics"
  >
    These attributes are attached to the `MongodTopSample` event type:

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `usage.commandsInMillisecondsPerSecond`
          </td>

          <td>
            The total time spent performing commands, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `usage.commandsPerSecond`
          </td>

          <td>
            The number of commands per second.
          </td>
        </tr>

        <tr>
          <td>
            `usage.getmoreInMillisecondsPerSecond`
          </td>

          <td>
            The total time spent performing getmore, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `usage.getmorePerSecond`
          </td>

          <td>
            The number of getmore per second.
          </td>
        </tr>

        <tr>
          <td>
            `usage.insertInMillisecondsPerSecond`
          </td>

          <td>
            The total time spent performing inserts, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `usage.insertPerSecond`
          </td>

          <td>
            The number of inserts per second.
          </td>
        </tr>

        <tr>
          <td>
            `usage.queriesInMillisecondsPerSecond`
          </td>

          <td>
            The total time spent performing queries, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `usage.queriesPerSecond`
          </td>

          <td>
            The number of queries per second.
          </td>
        </tr>

        <tr>
          <td>
            `usage.readLockInMillisecondsPerSecond`
          </td>

          <td>
            The total time spent performing read locks, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `usage.readLockPerSecond`
          </td>

          <td>
            The number of read locks per second.
          </td>
        </tr>

        <tr>
          <td>
            `usage.removeInMillisecondsPerSecond`
          </td>

          <td>
            The total time spent performing removes, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `usage.removePerSecond`
          </td>

          <td>
            The number of removes per second.
          </td>
        </tr>

        <tr>
          <td>
            `usage.totalInMillisecondsPerSecond`
          </td>

          <td>
            The total time spent performing operations, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `usage.totalPerSecond`
          </td>

          <td>
            The number of operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `usage.updateInMillisecondsPerSecond`
          </td>

          <td>
            The total time spent performing updates, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `usage.updatePerSecond`
          </td>

          <td>
            The number of updates per second.
          </td>
        </tr>

        <tr>
          <td>
            `usage.writeLockInMillisecondsPerSecond`
          </td>

          <td>
            The total time spent performing write locks, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `usage.writeLockPerSecond`
          </td>

          <td>
            The number of write locks per second.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongo-clamshell"
    title="Mongo sample metrics"
  >
    These attributes are attached to the `MongoSample` event type:

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `totalDatabases`
          </td>

          <td>
            The number of databases on the cluster.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongod-clamshell"
    title="Mongod sample metrics"
  >
    These attributes are attached to the `MongodSample` event type:

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `asserts.messagesPerSecond`
          </td>

          <td>
            The number of message assertions raised per second.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.regularPerSecond`
          </td>

          <td>
            The number of regular assertions raised per second.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.rolloversPerSecond`
          </td>

          <td>
            The number of times that the rollover counters roll over. The counters rollover to zero every 2^30 assertions per second.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.userPerSecond`
          </td>

          <td>
            The number of user assertions raised per second.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.warningPerSecond`
          </td>

          <td>
            The number of warnings raised per second.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countFailedPerSecond`
          </td>

          <td>
            The number of times `count` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countPerSecond`
          </td>

          <td>
            The number of times `count` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesFailedPerSecond`
          </td>

          <td>
            The number of times `createIndexes` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesPerSecond`
          </td>

          <td>
            The number of times `createIndexes` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deleteFailedPerSecond`
          </td>

          <td>
            The number of times `delete` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deletePerSecond`
          </td>

          <td>
            The number of times `delete` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalFailedPerSecond`
          </td>

          <td>
            The number of times `eval` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalPerSecond`
          </td>

          <td>
            The number of times `eval` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyFailedPerSecond`
          </td>

          <td>
            The number of times `findAndModify` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyPerSecond`
          </td>

          <td>
            The number of times `findAndModify` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertFailedPerSecond`
          </td>

          <td>
            The number of times `insert` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertPerSecond`
          </td>

          <td>
            The number of times `insert` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updateFailedPerSecond`
          </td>

          <td>
            The number of times `update` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updatePerSecond`
          </td>

          <td>
            The number of times `update` executed.
          </td>
        </tr>

        <tr>
          <td>
            `connections.available`
          </td>

          <td>
            The number of unused available incoming connections the database can provide.
          </td>
        </tr>

        <tr>
          <td>
            `connections.current`
          </td>

          <td>
            The number of connections to the database server from clients.
          </td>
        </tr>

        <tr>
          <td>
            `connections.totalCreated`
          </td>

          <td>
            The total number of connections created.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openNoTimeout`
          </td>

          <td>
            The number of open cursors with the option `DBQueryOptionnotimeout` set to prevent timeout after a period of inactivity.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openPinned`
          </td>

          <td>
            The number of pinned open cursors.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openTotal`
          </td>

          <td>
            The number of cursors that MongoDB is maintaining for clients.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.timedOutPerSecond`
          </td>

          <td>
            The total number of cursors that have timed out since the server process started.
          </td>
        </tr>

        <tr>
          <td>
            `document.deletedPerSecond`
          </td>

          <td>
            The number of documents deleted per second.
          </td>
        </tr>

        <tr>
          <td>
            `document.insertedPerSecond`
          </td>

          <td>
            The number of documents inserted per second.
          </td>
        </tr>

        <tr>
          <td>
            `document.returnedPerSecond`
          </td>

          <td>
            The number of documents returned by queries per second.
          </td>
        </tr>

        <tr>
          <td>
            `document.updatedPerSecond`
          </td>

          <td>
            The number of documents updated per second.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commits`
          </td>

          <td>
            The number of transactions written to the journal during the last journal group commit interval.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInMilliseconds`
          </td>

          <td>
            The amount of time spent for commits, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLock`
          </td>

          <td>
            The count of the commits that occurred while a write lock was held.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLockInMilliseconds`
          </td>

          <td>
            The amount of time spent for commits that occurred while a write lock was held, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.compression`
          </td>

          <td>
            The compression ratio of the data written to the journal.
          </td>
        </tr>

        <tr>
          <td>
            `dur.dataWrittenJournalDataFilesInBytes`
          </td>

          <td>
            The amount of data written from journal to the data files during the last journal group commit interval, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.earlyCommits`
          </td>

          <td>
            The number of times MongoDB has requested a commit before the scheduled journal group commit interval.
          </td>
        </tr>

        <tr>
          <td>
            `dur.journaledInBytes`
          </td>

          <td>
            The amount of data written to journal during the last journal group commit interval, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.preparingInMilliseconds`
          </td>

          <td>
            The amount of time spent preparing to write to the journal, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.remappingInMilliseconds`
          </td>

          <td>
            The amount of time spent remapping copy-on-write memory mapped views, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.timeCollectedCommitsInMilliseconds`
          </td>

          <td>
            The amount of time over which MongoDB collected the `durcommitsInMilliseconds` data, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingDataFilesInMilliseconds`
          </td>

          <td>
            The amount of time spent writing to data files after journaling, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingJournalInMilliseconds`
          </td>

          <td>
            The amount of time spent writing to the journal, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `flush.averageInMilliseconds`
          </td>

          <td>
            The average time for each flush to disk, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `flush.flushesDisk`
          </td>

          <td>
            The number of times the database has flushed all writes to disk.
          </td>
        </tr>

        <tr>
          <td>
            `flush.lastInMilliseconds`
          </td>

          <td>
            The amount of time that the last flush operation took to complete, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `flush.totalInMilliseconds`
          </td>

          <td>
            The total amount of time that the mongod processes have spent writing (that is, flushing) data to disk, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeMillisPerSecond`
          </td>

          <td>
            The number of `getLastError` operations with a specified write concern (for example, `w`) that wait for one or more members of a replica set to acknowledge the write operation per second.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeoutsPerSecond`
          </td>

          <td>
            The number of times that write concern operations have timed out as a result of the wtimeout threshold to `getLastError` per second.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsReaders`
          </td>

          <td>
            The count of the active client connections performing read operations.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsTotal`
          </td>

          <td>
            The total number of active client connections to the database.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsWriters`
          </td>

          <td>
            The count of active client connections performing write operations.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueReaders`
          </td>

          <td>
            The number of operations that are currently queued and waiting for the read lock.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueTotal`
          </td>

          <td>
            The total number of operations queued waiting for the lock.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueWriters`
          </td>

          <td>
            The number of operations that are currently queued and waiting for the write lock.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.totaltime`
          </td>

          <td>
            The time since the database last started and created the global lock.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireExclusive`
          </td>

          <td>
            The number of times the collection lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentExclusive`
          </td>

          <td>
            The number of times the collection lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentShared`
          </td>

          <td>
            The number of times the collection lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireShared`
          </td>

          <td>
            The number of times the collection lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountExclusive`
          </td>

          <td>
            The number of times the collection lock type acquisition in the Exclusive (X) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountShared`
          </td>

          <td>
            The number of times the collection lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosExclusive`
          </td>

          <td>
            The wait time for the collection lock type acquisitions in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosShared`
          </td>

          <td>
            The wait time for the collection lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireExclusive`
          </td>

          <td>
            The number of times the database lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentExclusive`
          </td>

          <td>
            The number of times the database lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentShared`
          </td>

          <td>
            The number of times the database lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireShared`
          </td>

          <td>
            The number of times the database lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitExclusive`
          </td>

          <td>
            The number of times the database lock type acquisition in the Exclusive (X) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentExclusive`
          </td>

          <td>
            The number of times the database lock type acquisition in the Intent Exclusive (IX) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentShared`
          </td>

          <td>
            The number of times the database lock type acquisition in the Intent Shared (IS) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitShared`
          </td>

          <td>
            The number of times the database lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosExclusive`
          </td>

          <td>
            The wait time for the database lock type acquisitions in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            The wait time for the database lock type acquisitions in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            The wait time for the database lock type acquisitions in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosShared`
          </td>

          <td>
            The wait time for the database lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireExclusive`
          </td>

          <td>
            The number of times the global lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentExclusive`
          </td>

          <td>
            The number of times the global lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentShared`
          </td>

          <td>
            The number of times the global lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireShared`
          </td>

          <td>
            The number of times the global lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitExclusive`
          </td>

          <td>
            The number of times the global lock type acquisition in the Exclusive (X) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentExclusive`
          </td>

          <td>
            The number of times the global lock type acquisition in the Intent Exclusive (IX) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentShared`
          </td>

          <td>
            The number of times the global lock type acquisition in the Intent Shared (IS) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitShared`
          </td>

          <td>
            The number of times the global lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            The wait time for the global lock type acquisitions in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            The wait time for the global lock type acquisitions in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            The wait time for the global lock type acquisitions in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosShared`
          </td>

          <td>
            The wait time for the global lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireExclusive`
          </td>

          <td>
            The number of times the metadata lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireShared`
          </td>

          <td>
            The number of times the metadata lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireExclusive`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentExclusive`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentShared`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireShared`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitExclusive`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type acquisition in the Exclusive (X) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentExclusive`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type acquisition in the Intent Exclusive (IX) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentShared`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type acquisition in the Intent Shared (IS) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitShared`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            The wait time for the MMAPv1 storage engine lock type acquisitions in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            The wait time for the MMAPv1 storage engine lock type acquisitions in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            The wait time for the MMAPv1 storage engine lock type acquisitions in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosShared`
          </td>

          <td>
            The wait time for the MMAPv1 storage engine lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireExclusive`
          </td>

          <td>
            The number of times the oplog lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentExclusive`
          </td>

          <td>
            The number of times the oplog lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentShared`
          </td>

          <td>
            The number of times the oplog lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireShared`
          </td>

          <td>
            The number of times the oplog lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitIntentExclusive`
          </td>

          <td>
            The number of times the oplog lock type acquisition in the Intent Exclusive (IX) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitShared`
          </td>

          <td>
            The number of times the oplog lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            The wait time for the oplog lock type acquisitions in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            The wait time for the oplog lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `mem.bits`
          </td>

          <td>
            The size of the in-memory storage engine.
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedInBytes`
          </td>

          <td>
            The amount of mapped memory by the database, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedWithJournalInBytes`
          </td>

          <td>
            The amount of mapped memory, including the memory used for journaling, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `mem.residentInBytes`
          </td>

          <td>
            The amount of memory currently used by the database process, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `mem.virtualInBytes`
          </td>

          <td>
            The amount of virtual memory used by the mongod process, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesInPerSecond`
          </td>

          <td>
            The number of bytes that reflects the amount of network traffic into this database.
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesOutPerSecond`
          </td>

          <td>
            The number of bytes that reflects the amount of network traffic sent from this database.
          </td>
        </tr>

        <tr>
          <td>
            `network.requestsPerSecond`
          </td>

          <td>
            The number of distinct requests that the server has received.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.commandPerSecond`
          </td>

          <td>
            The total number of commands issued to the database per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.deletePerSecond`
          </td>

          <td>
            The number of delete operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.getmorePerSecond`
          </td>

          <td>
            The number of getmore operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.insertPerSecond`
          </td>

          <td>
            The number of insert operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.queryPerSecond`
          </td>

          <td>
            The total number of queries per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.updatePerSecond`
          </td>

          <td>
            The number of update operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.commandPerSecond`
          </td>

          <td>
            The total number of replicated commands issued to the database per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.deletePerSecond`
          </td>

          <td>
            The number of replicated delete operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.getmorePerSecond`
          </td>

          <td>
            The number of replicated getmore operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.insertPerSecond`
          </td>

          <td>
            The number of replicated insert operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.queryPerSecond`
          </td>

          <td>
            The total number of replicated queries per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.updatePerSecond`
          </td>

          <td>
            The number of replicated update operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `operation.fastmodPerSecond`
          </td>

          <td>
            The number of update operations that neither cause documents to grow nor require updates to the index per second.
          </td>
        </tr>

        <tr>
          <td>
            `operation.idhackPerSecond`
          </td>

          <td>
            The number of queries that contain the `_id` field per second.
          </td>
        </tr>

        <tr>
          <td>
            `operation.scanAndOrderPerSecond`
          </td>

          <td>
            The number of queries that return sorted numbers that cannot perform the sort operation using an index per second.
          </td>
        </tr>

        <tr>
          <td>
            `operation.writeConflictsPerSecond`
          </td>

          <td>
            The number of times that write concern operations has encountered a conflict per second.
          </td>
        </tr>

        <tr>
          <td>
            `pageFaultsPerSecond`
          </td>

          <td>
            The number of page faults that require disk operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `queryexecutor.scannedPerSecond`
          </td>

          <td>
            The number of index items scanned during queries and query-plan evaluation per second.
          </td>
        </tr>

        <tr>
          <td>
            `record.movesPerSecond`
          </td>

          <td>
            The number of times documents move within the on-disk representation of the MongoDB data set per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.batchesPerSecond`
          </td>

          <td>
            The number of batches applied across all databases per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.operationsPerSecond`
          </td>

          <td>
            The number of oplog operations applied per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.count`
          </td>

          <td>
            The number of operations in the oplog buffer.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.maxSizeInBytes`
          </td>

          <td>
            The maximum size of the buffer, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.sizeInBytes`
          </td>

          <td>
            The current size of the contents of the oplog buffer, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsLoadedPrefetch`
          </td>

          <td>
            The number of documents loaded during the pre-fetch stage of replication.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsPreloadInMilliseconds`
          </td>

          <td>
            The amount of time spent loading documents as part of the pre-fetch stage of replication, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexLoadedPrefetch`
          </td>

          <td>
            The number of index entries loaded by members before updating documents as part of the pre-fetch stage of replication.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexPreloadInMilliseconds`
          </td>

          <td>
            The amount of time spent loading indices as part of the pre-fetch stage of replication, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.bytesPerSecond`
          </td>

          <td>
            The amount of data read from the replication sync source per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.getmoresPerSecond`
          </td>

          <td>
            The number of getmore operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.operationPerSecond`
          </td>

          <td>
            The number of operations read from the replication source per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.readersCreatedPerSecond`
          </td>

          <td>
            The number of oplog query processes created per second.
          </td>
        </tr>

        <tr>
          <td>
            `replset.health`
          </td>

          <td>
            The Member health value of the replica set: conveys if the member is up (`1`) or down (`0`).
          </td>
        </tr>

        <tr>
          <td>
            `replset.isArbiter`
          </td>

          <td>
            `1` if the mongod is an arbiter, `0` otherwise.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isHidden`
          </td>

          <td>
            `1` if the mongod is hidden, `0` otherwise.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isMaster`
          </td>

          <td>
            `1` if the mongod is the current master, `0` otherwise.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isSecondary`
          </td>

          <td>
            `1` if the mongod is currently secondary, `0` otherwise.
          </td>
        </tr>

        <tr>
          <td>
            `replset.priority`
          </td>

          <td>
            The election priority of the mongod.
          </td>
        </tr>

        <tr>
          <td>
            `replset.replicationLag`
          </td>

          <td>
            The delay between a write operation on the primary and its copy to a secondary.
          </td>
        </tr>

        <tr>
          <td>
            `replset.state`
          </td>

          <td>
            The state of a replica that reflects its disposition within the set.
          </td>
        </tr>

        <tr>
          <td>
            `replset.uptimeInMilliseconds`
          </td>

          <td>
            The number of seconds that the mongos or mongod process has been active, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `replset.voteFraction`
          </td>

          <td>
            The fraction of votes a server will cast in a replica set election.
          </td>
        </tr>

        <tr>
          <td>
            `replset.votes`
          </td>

          <td>
            The number of votes a server will cast in a replica set election.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.deleteDocumentsPerSecond`
          </td>

          <td>
            The number of documents deleted from collections with a ttl index per second.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.removeDocumentPerSecond`
          </td>

          <td>
            The number of times the background process removes documents from collections with a ttl index per second.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheDirtyDataInBytes`
          </td>

          <td>
            The size of the dirty data in the cache, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInBytes`
          </td>

          <td>
            The size of the data currently in cache, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInMemoryPageSplits`
          </td>

          <td>
            The in-memory page splits.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxInBytes`
          </td>

          <td>
            The maximum cache size, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxPageSizeEvictionInBytes`
          </td>

          <td>
            The maximum page size at eviction, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheModifiedPagesEvicted`
          </td>

          <td>
            The number of pages, that have been modified, evicted from the cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedApplicationThreadsPerSecond`
          </td>

          <td>
            The number of page evicted by application threads per second.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedInMemoryMaxPerSecond`
          </td>

          <td>
            The number of pages evicted because they exceeded the cache in-memory maximum, per second.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesHeld`
          </td>

          <td>
            The number of pages currently held in the cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheUnmodifiedPagesEvicted`
          </td>

          <td>
            The number of pages, that were not modified, evicted from the cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadAvailable`
          </td>

          <td>
            The number of available read tickets (concurrent transactions) remaining.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadRemaining`
          </td>

          <td>
            The number of read tickets (concurrent transactions) in use.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadTotal`
          </td>

          <td>
            The total number of read tickets (concurrent transactions) available.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteAvailable`
          </td>

          <td>
            The number of available write tickets (concurrent transactions) remaining.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteRemaining`
          </td>

          <td>
            The number of write tickets (concurrent transactions) in use.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteTotal`
          </td>

          <td>
            The total number of write tickets (concurrent transactions) available.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.failedEvictionsPagesPerSecond`
          </td>

          <td>
            The number of failed eviction of pages that exceeded the in-memory maximum, per second.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongos-clamshell"
    title="Mongos sample metrics"
  >
    These attributes are attached to the `MongosSample` event type:

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `asserts.messagesPerSecond`
          </td>

          <td>
            The number of message assertions raised per second.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.regularPerSecond`
          </td>

          <td>
            The number of regular assertions raised per second.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.rolloversPerSecond`
          </td>

          <td>
            The number of times that the rollover counters roll over. The counters rollover to zero every 2^30 assertions per second.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.userPerSecond`
          </td>

          <td>
            The number of user assertions raised per second.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.warningPerSecond`
          </td>

          <td>
            The number of warnings raised per second.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countFailedPerSecond`
          </td>

          <td>
            The number of times `count` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countPerSecond`
          </td>

          <td>
            The number of times `count` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesFailedPerSecond`
          </td>

          <td>
            The number of times `createIndexes` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesPerSecond`
          </td>

          <td>
            The number of times `createIndexes` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deleteFailedPerSecond`
          </td>

          <td>
            The number of times `delete` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deletePerSecond`
          </td>

          <td>
            The number of times `delete` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalFailedPerSecond`
          </td>

          <td>
            The number of times `eval` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalPerSecond`
          </td>

          <td>
            The number of times `eval` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyFailedPerSecond`
          </td>

          <td>
            The number of times `findAndModify` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyPerSecond`
          </td>

          <td>
            The number of times `findAndModify` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertFailedPerSecond`
          </td>

          <td>
            The number of times `insert` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertPerSecond`
          </td>

          <td>
            The number of times `insert` executed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updateFailedPerSecond`
          </td>

          <td>
            The number of times `update` failed.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updatePerSecond`
          </td>

          <td>
            The number of times `update` executed.
          </td>
        </tr>

        <tr>
          <td>
            `connections.available`
          </td>

          <td>
            The number of unused available incoming connections the database can provide.
          </td>
        </tr>

        <tr>
          <td>
            `connections.current`
          </td>

          <td>
            The number of connections to the database server from clients.
          </td>
        </tr>

        <tr>
          <td>
            `connections.totalCreated`
          </td>

          <td>
            The total number of connections created.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openNoTimeout`
          </td>

          <td>
            The number of open cursors with the option `DBQueryOptionnotimeout` set to prevent timeout after a period of inactivity.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openPinned`
          </td>

          <td>
            The number of pinned open cursors.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openTotal`
          </td>

          <td>
            The number of cursors that MongoDB is maintaining for clients.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.timedOutPerSecond`
          </td>

          <td>
            The total number of cursors that have timed out since the server process started.
          </td>
        </tr>

        <tr>
          <td>
            `document.deletedPerSecond`
          </td>

          <td>
            The number of documents deleted per second.
          </td>
        </tr>

        <tr>
          <td>
            `document.insertedPerSecond`
          </td>

          <td>
            The number of documents inserted per second.
          </td>
        </tr>

        <tr>
          <td>
            `document.returnedPerSecond`
          </td>

          <td>
            The number of documents returned by queries per second.
          </td>
        </tr>

        <tr>
          <td>
            `document.updatedPerSecond`
          </td>

          <td>
            The number of documents updated per second.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commits`
          </td>

          <td>
            The number of transactions written to the journal during the last journal group commit interval.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInMilliseconds`
          </td>

          <td>
            The amount of time spent for commits, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLock`
          </td>

          <td>
            The count of the commits that occurred while a write lock was held.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLockInMilliseconds`
          </td>

          <td>
            The amount of time spent for commits that occurred while a write lock was held, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.compression`
          </td>

          <td>
            The compression ratio of the data written to the journal.
          </td>
        </tr>

        <tr>
          <td>
            `dur.dataWrittenJournalDataFilesInBytes`
          </td>

          <td>
            The amount of data written from journal to the data files during the last journal group commit interval, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.earlyCommits`
          </td>

          <td>
            The number of times MongoDB has requested a commit before the scheduled journal group commit interval.
          </td>
        </tr>

        <tr>
          <td>
            `dur.journaledInBytes`
          </td>

          <td>
            The amount of data written to journal during the last journal group commit interval, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.preparingInMilliseconds`
          </td>

          <td>
            The amount of time spent preparing to write to the journal, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.remappingInMilliseconds`
          </td>

          <td>
            The amount of time spent remapping copy-on-write memory mapped views, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.timeCollectedCommitsInMilliseconds`
          </td>

          <td>
            The amount of time over which MongoDB collected the `durcommitsInMilliseconds` data, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingDataFilesInMilliseconds`
          </td>

          <td>
            The amount of time spent writing to data files after journaling, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingJournalInMilliseconds`
          </td>

          <td>
            The amount of time spent writing to the journal, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `flush.averageInMilliseconds`
          </td>

          <td>
            The average time for each flush to disk, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `flush.flushesDisk`
          </td>

          <td>
            The number of times the database has flushed all writes to disk.
          </td>
        </tr>

        <tr>
          <td>
            `flush.lastInMilliseconds`
          </td>

          <td>
            The amount of time that the last flush operation took to complete, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `flush.totalInMilliseconds`
          </td>

          <td>
            The total amount of time that the mongod processes have spent writing (that is, flushing) data to disk, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeMillisPerSecond`
          </td>

          <td>
            The number of `getLastError` operations with a specified write concern (for example, `w`) that wait for one or more members of a replica set to acknowledge the write operation per second.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeoutsPerSecond`
          </td>

          <td>
            The number of times that write concern operations have timed out as a result of the wtimeout threshold to `getLastError` per second.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsReaders`
          </td>

          <td>
            The count of the active client connections performing read operations.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsTotal`
          </td>

          <td>
            The total number of active client connections to the database.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsWriters`
          </td>

          <td>
            The count of active client connections performing write operations.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueReaders`
          </td>

          <td>
            The number of operations that are currently queued and waiting for the read lock.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueTotal`
          </td>

          <td>
            The total number of operations queued waiting for the lock.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueWriters`
          </td>

          <td>
            The number of operations that are currently queued and waiting for the write lock.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.totaltime`
          </td>

          <td>
            The time since the database last started and created the global lock.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireExclusive`
          </td>

          <td>
            The number of times the collection lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentExclusive`
          </td>

          <td>
            The number of times the collection lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentShared`
          </td>

          <td>
            The number of times the collection lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireShared`
          </td>

          <td>
            The number of times the collection lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountExclusive`
          </td>

          <td>
            The number of times the collection lock type acquisition in the Exclusive (X) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountShared`
          </td>

          <td>
            The number of times the collection lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosExclusive`
          </td>

          <td>
            The wait time for the collection lock type acquisitions in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosShared`
          </td>

          <td>
            The wait time for the collection lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireExclusive`
          </td>

          <td>
            The number of times the database lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentExclusive`
          </td>

          <td>
            The number of times the database lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentShared`
          </td>

          <td>
            The number of times the database lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireShared`
          </td>

          <td>
            The number of times the database lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitExclusive`
          </td>

          <td>
            The number of times the database lock type acquisition in the Exclusive (X) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentExclusive`
          </td>

          <td>
            The number of times the database lock type acquisition in the Intent Exclusive (IX) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentShared`
          </td>

          <td>
            The number of times the database lock type acquisition in the Intent Shared (IS) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitShared`
          </td>

          <td>
            The number of times the database lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosExclusive`
          </td>

          <td>
            The wait time for the database lock type acquisitions in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            The wait time for the database lock type acquisitions in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            The wait time for the database lock type acquisitions in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosShared`
          </td>

          <td>
            The wait time for the database lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireExclusive`
          </td>

          <td>
            The number of times the global lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentExclusive`
          </td>

          <td>
            The number of times the global lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentShared`
          </td>

          <td>
            The number of times the global lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireShared`
          </td>

          <td>
            The number of times the global lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitExclusive`
          </td>

          <td>
            The number of times the global lock type acquisition in the Exclusive (X) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentExclusive`
          </td>

          <td>
            The number of times the global lock type acquisition in the Intent Exclusive (IX) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentShared`
          </td>

          <td>
            The number of times the global lock type acquisition in the Intent Shared (IS) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitShared`
          </td>

          <td>
            The number of times the global lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            The wait time for the global lock type acquisitions in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            The wait time for the global lock type acquisitions in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            The wait time for the global lock type acquisitions in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosShared`
          </td>

          <td>
            The wait time for the global lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireExclusive`
          </td>

          <td>
            The number of times the metadata lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireShared`
          </td>

          <td>
            The number of times the metadata lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireExclusive`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentExclusive`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentShared`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireShared`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitExclusive`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type acquisition in the Exclusive (X) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentExclusive`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type acquisition in the Intent Exclusive (IX) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentShared`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type acquisition in the Intent Shared (IS) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitShared`
          </td>

          <td>
            The number of times the MMAPv1 storage engine lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            The wait time for the MMAPv1 storage engine lock type acquisitions in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            The wait time for the MMAPv1 storage engine lock type acquisitions in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            The wait time for the MMAPv1 storage engine lock type acquisitions in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosShared`
          </td>

          <td>
            The wait time for the MMAPv1 storage engine lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireExclusive`
          </td>

          <td>
            The number of times the oplog lock type was acquired in the Exclusive (X) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentExclusive`
          </td>

          <td>
            The number of times the oplog lock type was acquired in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentShared`
          </td>

          <td>
            The number of times the oplog lock type was acquired in the Intent Shared (IS) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireShared`
          </td>

          <td>
            The number of times the oplog lock type was acquired in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitIntentExclusive`
          </td>

          <td>
            The number of times the oplog lock type acquisition in the Intent Exclusive (IX) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitShared`
          </td>

          <td>
            The number of times the oplog lock type acquisition in the Shared (S) mode encountered waits because the locks were held in a conflicting mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            The wait time for the oplog lock type acquisitions in the Intent Exclusive (IX) mode.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            The wait time for the oplog lock type acquisitions in the Shared (S) mode.
          </td>
        </tr>

        <tr>
          <td>
            `mem.bits`
          </td>

          <td>
            The size of the in-memory storage engine.
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedInBytes`
          </td>

          <td>
            The amount of mapped memory by the database, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedWithJournalInBytes`
          </td>

          <td>
            The amount of mapped memory, including the memory used for journaling, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `mem.residentInBytes`
          </td>

          <td>
            The amount of memory currently used by the database process, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `mem.virtualInBytes`
          </td>

          <td>
            The amount of virtual memory used by the mongod process, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesInPerSecond`
          </td>

          <td>
            The number of bytes that reflects the amount of network traffic into this database.
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesOutPerSecond`
          </td>

          <td>
            The number of bytes that reflects the amount of network traffic sent from this database.
          </td>
        </tr>

        <tr>
          <td>
            `network.requestsPerSecond`
          </td>

          <td>
            The number of distinct requests that the server has received.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.commandPerSecond`
          </td>

          <td>
            The total number of commands issued to the database per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.deletePerSecond`
          </td>

          <td>
            The number of delete operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.getmorePerSecond`
          </td>

          <td>
            The number of getmore operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.insertPerSecond`
          </td>

          <td>
            The number of insert operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.queryPerSecond`
          </td>

          <td>
            The total number of queries per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.updatePerSecond`
          </td>

          <td>
            The number of update operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.commandPerSecond`
          </td>

          <td>
            The total number of replicated commands issued to the database per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.deletePerSecond`
          </td>

          <td>
            The number of replicated delete operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.getmorePerSecond`
          </td>

          <td>
            The number of replicated getmore operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.insertPerSecond`
          </td>

          <td>
            The number of replicated insert operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.queryPerSecond`
          </td>

          <td>
            The total number of replicated queries per second.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.updatePerSecond`
          </td>

          <td>
            The number of replicated update operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `operation.fastmodPerSecond`
          </td>

          <td>
            The number of update operations that neither cause documents to grow nor require updates to the index per second.
          </td>
        </tr>

        <tr>
          <td>
            `operation.idhackPerSecond`
          </td>

          <td>
            The number of queries that contain the `_id` field per second.
          </td>
        </tr>

        <tr>
          <td>
            `operation.scanAndOrderPerSecond`
          </td>

          <td>
            The number of queries that return sorted numbers that cannot perform the sort operation using an index per second.
          </td>
        </tr>

        <tr>
          <td>
            `operation.writeConflictsPerSecond`
          </td>

          <td>
            The number of times that write concern operations has encountered a conflict per second.
          </td>
        </tr>

        <tr>
          <td>
            `pageFaultsPerSecond`
          </td>

          <td>
            The number of page faults that require disk operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `queryexecutor.scannedPerSecond`
          </td>

          <td>
            The number of index items scanned during queries and query-plan evaluation per second.
          </td>
        </tr>

        <tr>
          <td>
            `record.movesPerSecond`
          </td>

          <td>
            The number of times documents move within the on-disk representation of the MongoDB data set per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.batchesPerSecond`
          </td>

          <td>
            The number of batches applied across all databases per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.operationsPerSecond`
          </td>

          <td>
            The number of oplog operations applied per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.count`
          </td>

          <td>
            The number of operations in the oplog buffer.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.maxSizeInBytes`
          </td>

          <td>
            The maximum size of the buffer, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.sizeInBytes`
          </td>

          <td>
            The current size of the contents of the oplog buffer, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsLoadedPrefetch`
          </td>

          <td>
            The number of documents loaded during the pre-fetch stage of replication.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsPreloadInMilliseconds`
          </td>

          <td>
            The amount of time spent loading documents as part of the pre-fetch stage of replication, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexLoadedPrefetch`
          </td>

          <td>
            The number of index entries loaded by members before updating documents as part of the pre-fetch stage of replication.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexPreloadInMilliseconds`
          </td>

          <td>
            The amount of time spent loading indices as part of the pre-fetch stage of replication, in milliseconds.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.bytesPerSecond`
          </td>

          <td>
            The amount of data read from the replication sync source per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.getmoresPerSecond`
          </td>

          <td>
            The number of getmore operations per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.operationPerSecond`
          </td>

          <td>
            The number of operations read from the replication source per second.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.readersCreatedPerSecond`
          </td>

          <td>
            The number of oplog query processes created per second.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.deleteDocumentsPerSecond`
          </td>

          <td>
            The number of documents deleted from collections with a ttl index per second.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.removeDocumentPerSecond`
          </td>

          <td>
            The number of times the background process removes documents from collections with a ttl index per second.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheDirtyDataInBytes`
          </td>

          <td>
            The size of the dirty data in the cache, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInBytes`
          </td>

          <td>
            The size of the data currently in cache, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInMemoryPageSplits`
          </td>

          <td>
            The in-memory page splits.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxInBytes`
          </td>

          <td>
            The maximum cache size, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxPageSizeEvictionInBytes`
          </td>

          <td>
            The maximum page size at eviction, in bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheModifiedPagesEvicted`
          </td>

          <td>
            The number of pages, that have been modified, evicted from the cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedApplicationThreadsPerSecond`
          </td>

          <td>
            The number of page evicted by application threads per second.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedInMemoryMaxPerSecond`
          </td>

          <td>
            The number of pages evicted because they exceeded the cache in-memory maximum, per second.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesHeld`
          </td>

          <td>
            The number of pages currently held in the cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheUnmodifiedPagesEvicted`
          </td>

          <td>
            The number of pages, that were not modified, evicted from the cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadAvailable`
          </td>

          <td>
            The number of available read tickets (concurrent transactions) remaining.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadRemaining`
          </td>

          <td>
            The number of read tickets (concurrent transactions) in use.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadTotal`
          </td>

          <td>
            The total number of read tickets (concurrent transactions) available.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteAvailable`
          </td>

          <td>
            The number of available write tickets (concurrent transactions) remaining.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteRemaining`
          </td>

          <td>
            The number of write tickets (concurrent transactions) in use.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteTotal`
          </td>

          <td>
            The total number of write tickets (concurrent transactions) available.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.failedEvictionsPagesPerSecond`
          </td>

          <td>
            The number of failed eviction of pages that exceeded the in-memory maximum, per second.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## Inventory data [#inventory]

The MongoDB integration captures all command line options and runtime-configured parameters from each host in the cluster.

The data is available on the [Inventory page](/docs/infrastructure/new-relic-infrastructure/infrastructure-ui-pages/infrastructure-inventory-page-search-your-entire-infrastructure), under the **config/mongodb** source. For more about inventory data, see [Understand integration data](/docs/infrastructure/integrations-getting-started/getting-started/understand-integration-data-data-types#inventory-data).

## Check the source code [#source-code]

This integration is open source software. That means you can [browse its source code](https://github.com/newrelic/nri-mongodb "Link opens in a new window.") and send improvements, or create your own fork and build it.
