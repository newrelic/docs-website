---
title: Azure Spring Apps service through Azure Monitor integration
metaDescription: "New Relic's Microsoft Azure Spring Apps integration: what data it reports and how to enable it."
---

[New Relic's integrations](/docs/infrastructure/integrations-getting-started/getting-started/introduction-infrastructure-integrations) include an integration for reporting your [Microsoft Azure Spring Apps](https://azure.microsoft.com/en-us/services/spring-apps/) metrics and other data to New Relic. This document explains how to activate the integration and describes the data reported.

## Features

New Relic gathers metrics data from Azure Monitor for the Azure Spring Apps service. Azure Spring Apps run large-scale parallel and high-performance computing(HPC) efficiently in Azure. Azure Spring Apps create and manage a pool of compute nodes(virtual machines), installs the applications you want to run and schedules jobs to run on the nodes.

Using New Relic, you can:

* View Azure spring apps data in pre-built dashboards.
* Run [custom queries and visualize the data](/docs/infrastructure/integrations-getting-started/getting-started/use-integration-data-new-relic-insights).
* Create alert conditions to notify you of changes in data.

## Activate integration [#activate]

Follow standard [Azure Monitor integration procedure](/docs/infrastructure/microsoft-azure-integrations/azure-integrations-list/azure-monitor) to activate your Azure service in New Relic infrastructure monitoring.

## Configuration and polling [#polling]

You can change the polling frequency and filter data using [configuration options](/docs/infrastructure/microsoft-azure-integrations/azure-integrations-list/azure-monitor/#settings).

New Relic queries your Azure Spring Apps services through Azure Monitor integration according to a default [polling](/docs/infrastructure/microsoft-azure-integrations/azure-integrations-list/azure-monitor/#settings) interval.

## Find and use data [#find-and-use]

To [explore your integration data](/docs/infrastructure/integrations/find-use-infrastructure-integration-data), go to **[one.newrelic.com/infra](https://one.newrelic.com/infra) > Azure > (select an integration)**.

## Metric data [#metrics]

This integration collects the following [metric data](/docs/infrastructure/integrations-getting-started/getting-started/understand-integration-data-data-types#metric).

### Azure Spring Apps metrics [#Azure-spring-apps]

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Metric
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `active-timer-count`
      </td>

      <td>
        Number of timers that are currently active.
      </td>
    </tr>

    <tr>
      <td>
        `alloc-rate`
      </td>

      <td>
        Number of bytes allocated in the managed heap.
      </td>
    </tr>

    <tr>
      <td>
        `AppCpuUsage`
      </td>

      <td>
        The recent CPU usage for the app. This metric is being deprecated. Please use "App CPU Usage" with metric id "PodCpuUsage"..
      </td>
    </tr>

    <tr>
      <td>
        `assembly-count`
      </td>

      <td>
        Number of Assemblies loaded.
      </td>
    </tr>

    <tr>
      <td>
        `cpu-usage`
      </td>

      <td>
        % time the process has utilized the CPU.
      </td>
    </tr>

    <tr>
      <td>
        `current-requests`
      </td>

      <td>
        Total number of requests in processing in the lifetime of the process.
      </td>
    </tr>

    <tr>
      <td>
        `exception-count`
      </td>

      <td>
       Number of Exceptions.
      </td>
    </tr>

    <tr>
      <td>
        `failed-requests`
      </td>

      <td>
        Total number of failed requests in the lifetime of the process.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayHttpServerRequestsMilliSecondsMax`
      </td>

      <td>
        The max time of requests.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayHttpServerRequestsMilliSecondsSum`
      </td>

      <td>
       The total time of requests.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayHttpServerRequestsSecondsCount`
      </td>

      <td>
       The number of requests.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayJvmGcLiveDataSizeBytes`
      </td>

      <td>
        Size of old generation memory pool after a full GC.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayJvmGcMaxDataSizeBytes`
      </td>

      <td>
        Max size of old generation memory pool.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayJvmGcMemoryAllocatedBytesTotal`
      </td>

      <td>
        Incremented for an increase in the size of the young generation memory pool after one GC to before the next.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayJvmGcMemoryPromotedBytesTotal`
      </td>

      <td>
        Count of positive increases in the size of the old generation memory pool before GC to after GC.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayJvmGcPauseSecondsCount`
      </td>

      <td>
        GC Pause Count.
      </td>
    </tr>
    <tr>
      <td>
        `GatewayJvmGcPauseSecondsMax`
      </td>

      <td>
        GC Pause Max Time.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayJvmGcPauseSecondsSum`
      </td>

      <td>
        GC Pause Total Time.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayJvmMemoryCommittedBytes`
      </td>

      <td>
      Memory assigned to JVM in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayJvmMemoryUsedBytes`
      </td>

      <td>
        Memory used in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayProcessCpuUsage`
      </td>

      <td>
        The recent CPU usage for the JVM process.
      </td>
    </tr>

    <tr>
      <td>
        `GatewayRatelimitThrottledCount`
      </td>

      <td>
        The count of the throttled requests.
      </td>
    </tr>

    <tr>
      <td>
        `GatewaySystemCpuUsage`
      </td>

      <td>
        The recent CPU usage for the whole system.
      </td>
    </tr>

    <tr>
      <td>
        `gc-heap-size`
      </td>

      <td>
        Total heap size reported by the GC (MB).
      </td>
    </tr>

    <tr>
      <td>
        `IngressBytesReceived`
      </td>

      <td>
        Count of bytes received by Azure Spring Apps from the clients.
      </td>
    </tr>

    <tr>
      <td>
        `IngressBytesReceivedRate`
      </td>

      <td>
        Bytes received per second by Azure Spring Apps from the clients.
      </td>
    </tr>

    <tr>
      <td>
        `IngressBytesSent`
      </td>

      <td>
          Count of bytes sent by Azure Spring Apps to the clients.
      </td>
    </tr>

    <tr>
      <td>
        `IngressBytesSentRate`
      </td>

      <td>
        Bytes sent per second by Azure Spring Apps to the clients.
      </td>
    </tr>

    <tr>
      <td>
        `IngressFailedRequests`
      </td>

      <td>
      Count of failed requests by Azure Spring Apps from the clients.
      </td>
    </tr>

    <tr>
      <td>
        `IngressRequests`
      </td>

      <td>
        Count of requests by Azure Spring Apps from the clients.
      </td>
    </tr>

    <tr>
      <td>
        `IngressResponseStatus`
      </td>

      <td>
        HTTP response status returned by Azure Spring Apps. The response status code distribution can be further categorized to show responses in 2xx, 3xx, 4xx, and 5xx categories.
      </td>
    </tr>
    <tr>
      <td>
        `IngressResponseTime`
      </td>

      <td>
        Http response time return by Azure Spring Apps.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.live.data.size`
      </td>

      <td>
        Size of old generation memory pool after a full GC.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.max.data.size`
      </td>

      <td>
        Max size of old generation memory pool.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.memory.allocated`
      </td>

      <td>
        Incremented for an increase in the size of the young generation memory pool after one GC to before the next.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.memory.promoted`
      </td>

      <td>
        Count of positive increases in the size of the old generation memory pool before GC to after GC.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.pause.total.count`
      </td>

      <td>
        GC Pause Count.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.gc.pause.total.time	`
      </td>

      <td>
        GC Pause Total Time.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.memory.committed`
      </td>

      <td>
        Memory assigned to JVM in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.memory.max`
      </td>

      <td>
        The maximum amount of memory in bytes that can be used for memory management.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.memory.used`
      </td>

      <td>
        App Memory used in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `monitor-lock-contention-count`
      </td>

      <td>
        Number of times there were contention when trying to take the monitor lock.
      </td>
    </tr>
    <tr>
      <td>
        `PodCpuUsage`
      </td>

      <td>
        The recent CPU usage for the app.
      </td>
    </tr>

    <tr>
      <td>
        `PodMemoryUsage`
      </td>

      <td>
        The recent Memory usage for the app.
      </td>
    </tr>

    <tr>
      <td>
        `PodNetworkIn`
      </td>

      <td>
        Cumulative count of bytes received in the app.
      </td>
    </tr>

    <tr>
      <td>
        `PodNetworkOut`
      </td>

      <td>
       Cumulative count of bytes sent from the app.
      </td>
    </tr>

    <tr>
      <td>
        `process.cpu.usage`
      </td>

      <td>
        The recent CPU usage for the JVM process.
      </td>
    </tr>

    <tr>
      <td>
        `system.cpu.usage`
      </td>

      <td>
        The recent CPU usage for the whole system.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool-completed-items-count`
      </td>

      <td>
        ThreadPool Completed Work Items Count.
      </td>
    </tr>

    <tr>
      <td>
        `threadpool-queue-length`
      </td>

      <td>
          ThreadPool Work Items Queue Length.
      </td>    
    </tr>
    <tr>
      <td>
        `threadpool-thread-count`
      </td>

      <td>
        Number of ThreadPool Threads.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.global.error`
      </td>

      <td>
        Tomcat Global Error.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.global.received`
      </td>

      <td>
       Tomcat Total Received Bytes.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.global.request.avg.time`
      </td>

      <td>
        Tomcat Request Average Time.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.global.request.max`
      </td>

      <td>
        Tomcat Request Max Time.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.global.request.total.count`
      </td>

      <td>
        Tomcat Request Total Count.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.global.request.total.time`
      </td>

      <td>
          Tomcat Request Total Time.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.global.sent`
      </td>

      <td>
        Tomcat Total Sent Bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.memory.max`
      </td>

      <td>
        The maximum amount of memory in bytes that can be used for memory management.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.sessions.active.current`
      </td>

      <td>
        Tomcat Session Active Count.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.sessions.active.max`
      </td>

      <td>
        Tomcat Session Max Active Count.
      </td>
    </tr>
    <tr>
      <td>
        `tomcat.global.request.total.count`
      </td>

      <td>
        Tomcat Request Total Count.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.global.request.total.time`
      </td>

      <td>
          Tomcat Request Total Time.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.global.sent`
      </td>

      <td>
        Tomcat Total Sent Bytes.
      </td>
    </tr>

    <tr>
      <td>
        `jvm.memory.max`
      </td>

      <td>
        The maximum amount of memory in bytes that can be used for memory management.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.sessions.active.current`
      </td>

      <td>
        Tomcat Session Active Count.
      </td>
    </tr>

    <tr>
      <td>
        `tomcat.sessions.active.max`
      </td>

      <td>
        Tomcat Session Max Active Count.
      </td>
    </tr>
    <tr>
      <td>
        `tomcat.sessions.created`
      </td>

      <td>
        Tomcat Session Created Count.
      </td>
    </tr>
    <tr>
      <td>
        `tomcat.sessions.alive.max`
      </td>

      <td>
       Tomcat Session Max Alive Time.
      </td>
    </tr>
    <tr>
      <td>
        `tomcat.sessions.expired`
      </td>

      <td>
       Tomcat Session Expired Count.
      </td>
    </tr>
    <tr>
      <td>
        `tomcat.sessions.rejected`
      </td>

      <td>
       Tomcat Session Rejected Count.
      </td>
    </tr>
    <tr>
      <td>
        `tomcat.threads.config.max`
      </td>

      <td>
       Tomcat Config Max Thread Count.
      </td>
    </tr>
    <tr>
      <td>
        `tomcat.threads.current`
      </td>

      <td>
       Tomcat Current Thread Count.
      </td>
    </tr>
    <tr>
      <td>
        `total-requests`
      </td>

      <td>
       Total number of requests in the lifetime of the process.
      </td>
    </tr>
    <tr>
      <td>
        `WorkingSetBytes`
      </td>

      <td>
       Spring App working set memory used in bytes.
      </td>
    </tr>
  </tbody>
</table>