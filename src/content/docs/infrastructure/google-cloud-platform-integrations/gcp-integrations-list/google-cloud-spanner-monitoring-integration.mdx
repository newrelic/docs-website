---
title: Google Cloud Spanner monitoring integration
tags:
  - Integrations
  - Google Cloud Platform integrations
  - GCP integrations list
metaDescription: 'New Relic''s Google Cloud Spanner integration: how to activate it and what data it reports.'
redirects:
  - /docs/integrations/google-cloud-platform-integrations/gcp-integrations-list/google-cloud-spanner-monitoring-integration
  - /docs/gcp-gcp_spanner-integration
freshnessValidatedDate: never
---

[New Relic's integrations](/docs/infrastructure/integrations-getting-started/getting-started/introduction-infrastructure-integrations) with the [Google Cloud Platform (GCP)](https://cloud.google.com) include an integration to report [Google Cloud Spanner](https://cloud.google.com/spanner/) data to New Relic. This document explains how to activate the GCP Cloud Spanner integration and describes the data that can be reported.

## Features [#features]

Google Cloud Spanner service is a globally-distributed relational database service built for the cloud. Using the [Google Spanner Console](https://cloud.google.com/spanner/docs/quickstart-console), developers can create a Cloud Spanner instance, add schemas, write and modify data, and run queries.

## Activate integration [#activate]

To enable the integration follow standard procedures to [connect your GCP service to New Relic](/docs/connect-google-cloud-platform-services-infrastructure).

## Polling frequency [#polling]

New Relic integrations query your GCP services according to a polling interval, which varies depending on the integration. The polling frequency for Google Cloud Spanner is five minutes. The resolution is 1 data point every minute.

## Find and use data [#find-data]

After activating the integration and waiting a few minutes (based on the [polling frequency](#polling)), data will appear in the New Relic UI. To [find and use your data](/docs/infrastructure/integrations/find-use-infrastructure-integration-data), including links to your <InlinePopover type="dashboards"/> and alert settings, go to <DNT>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Infrastructure > GCP > (select an integration)**</DNT>.

## Metric data [#metrics]

To view [metric data](/docs/integrations/new-relic-integrations/getting-started/#metric) for your GCP Spanner integration in New Relic, [create NRQL queries](/docs/integrations/new-relic-integrations/getting-started/use-integration-data-new-relic-insights#nrql) for `GcpSpannerInstanceSample` and `GcpSpannerDatabaseSample` [events](/docs/data-apis/understand-data/new-relic-data-types/#event-data) and their related attributes.

### GcpSpannerInstanceSample [#gcp-spanner-instance-sample]

Query `GcpSpannerInstanceSample` events in New Relic to view data for the following attributes:

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `instance.autoscaling.HighPriorityCpuUtilizationTarget`
      </td>

      <td>
        High priority CPU utilization target used for autoscaling.
      </td>
    </tr>

    <tr>
      <td>
        `instance.autoscaling.MaxNodes`
      </td>

      <td>
        Maximum number of nodes autoscaler is allowed to allocate to the instance.
      </td>
    </tr>

    <tr>
      <td>
        `instance.autoscaling.MaxProcessingUnits`
      </td>

      <td>
        Maximum number of processing units autoscaler is allowed to allocate to the instance.
      </td>
    </tr>

    <tr>
      <td>
        `instance.autoscaling.MinNodes`
      </td>

      <td>
        Minimum number of nodes autoscaler is allowed to allocate to the instance.
      </td>
    </tr>

    <tr>
      <td>
        `instance.autoscaling.MinProcessingUnits`
      </td>

      <td>
        Minimum number of processing units autoscaler is allowed to allocate to the instance.
      </td>
    </tr>

    <tr>
      <td>
        `instance.autoscaling.StorageUtilizationTarget`
      </td>

      <td>
        Storage utilization target used for autoscaling.
      </td>
    </tr>

    <tr>
      <td>
        `instance.backup.UsedBytes`
      </td>

      <td>
        Backup storage used in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `instance.cpu.SmoothedUtilization`
      </td>

      <td>
        Twenty-four hour smoothed utilization of provisioned CPU. Values are typically numbers between 0.0 and 1.0 (but might
        exceed 1.0), charts display the values as a percentage between 0% and 100% (or more).
      </td>
    </tr>

    <tr>
      <td>
        `instance.cpu.Utilization`
      </td>

      <td>
        Percent utilization of provisioned CPU. Values are typically numbers between 0.0 and 1.0 (but might exceed 1.0),
        charts display the values as a percentage between 0% and 100% (or more).
      </td>
    </tr>

    <tr>
      <td>
        `instance.cpu.UtilizationByOperationType`
      </td>

      <td>
        Percent utilization of provisioned CPU, by operation type. Values are typically numbers between 0.0 and 1.0 (but
        might exceed 1.0), charts display the values as a percentage between 0% and 100% (or more). Currently, it does
        not include CPU utilization for system tasks.
      </td>
    </tr>

    <tr>
      <td>
        `instance.cpu.UtilizationByPriority`
      </td>

      <td>
        Percent utilization of provisioned CPU, by priority. Values are typically numbers between 0.0 and 1.0 (but might
        exceed 1.0), charts display the values as a percentage between 0% and 100% (or more).
      </td>
    </tr>

    <tr>
      <td>
        `instance.dataBoost.ProcessingUnitSeconds`
      </td>

      <td>
        Total processing units used for DataBoost operations.
      </td>
    </tr>

    <tr>
      <td>
        `instance.LeaderPercentageByRegion`
      </td>

      <td>
        Percentage of leaders by cloud region. Values are typically numbers between 0.0 and 1.0, charts display the
        values as a percentage between 0% and 100%.
      </td>
    </tr>

    <tr>
      <td>
        `instance.nodes`
      </td>

      <td>
        Total number of nodes.
      </td>
    </tr>

    <tr>
      <td>
        `instance.ProcessingUnits`
      </td>

      <td>
        Total number of processing units.
      </td>
    </tr>

    <tr>
      <td>
        `instance.sessions`
      </td>

      <td>
        Number of sessions in use.
      </td>
    </tr>

    <tr>
      <td>
        `instance.storage.LimitBytes`
      </td>

      <td>
        Storage limit for instance in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `instance.storage.LimitBytesPerProcessingUnit`
      </td>

      <td>
        Storage limit per processing unit in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `instance.storage.UsedBytes`
      </td>

      <td>
        Storage used in bytes.
      </td>
    </tr>

    <tr>
      <td>
        `instance.storage.Utilization`
      </td>

      <td>
        Storage used as a fraction of storage limit.
      </td>
    </tr>
  </tbody>
</table>

### GcpSpannerDatabaseSample [#gcp-spanner-database-sample]

Query `GcpSpannerDatabaseSample` events in New Relic to view data for the following attributes:

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `api.apiRequests`
      </td>

      <td>
        Cloud Spanner API requests.
      </td>
    </tr>

    <tr>
      <td>
        `api.ReceivedBytes`
      </td>

      <td>
        Uncompressed request bytes received by Cloud Spanner.
      </td>
    </tr>

    <tr>
      <td>
        `api.Requests`
      </td>

      <td>
        Rate of Cloud Spanner API requests.
      </td>
    </tr>

    <tr>
      <td>
        `api.RequestLatencies`
      </td>

      <td>
        Distribution of server request latencies for a database. This includes latency of request processing in Cloud
        Spanner backends and API layer. It does not include network or reverse-proxy overhead between clients and
        servers.
      </td>
    </tr>

    <tr>
      <td>
        `api.RequestLatenciesByTransactionType`
      </td>

      <td>
        Distribution of server request latencies for a database. This includes latency of request processing in Cloud
        Spanner backends and API layer. It does not include network or reverse-proxy overhead between clients and
        servers.
      </td>
    </tr>

    <tr>
      <td>
        `api.SentBytes`
      </td>

      <td>
        Uncompressed response bytes sent by Cloud Spanner.
      </td>
    </tr>

    <tr>
      <td>
        `lockStat.total.LockWaitTime`
      </td>

      <td>
        Total lock wait time for lock conflicts recorded for the entire database.
      </td>
    </tr>

    <tr>
      <td>
        `queries`
      </td>

      <td>
        Count of queries by database name, status, query type, and used optimizer version.
      </td>
    </tr>

    <tr>
      <td>
        `queryStat.total.BytesReturned`
      </td>

      <td>
        Number of data bytes that the queries returned, excluding transmission encoding overhead.
      </td>
    </tr>

    <tr>
      <td>
        `queryStat.total.CpuTime`
      </td>

      <td>
        Number of seconds of CPU time Cloud Spanner spent on operations to execute the queries.
      </td>
    </tr>

    <tr>
      <td>
        `queryStat.total.Executions`
      </td>

      <td>
        Number of times Cloud Spanner saw queries during the interval.
      </td>
    </tr>

    <tr>
      <td>
        `queryStat.total.FailedExecutions`
      </td>

      <td>
        Number of times queries failed during the interval.
      </td>
    </tr>

    <tr>
      <td>
        `queryStat.total.QueryLatencies`
      </td>

      <td>
        Distribution of total length of time, in seconds, for query executions within the database.
      </td>
    </tr>

    <tr>
      <td>
        `queryStat.total.RemoteServiceCalls`
      </td>

      <td>
        Count of remote service calls.
      </td>
    </tr>

    <tr>
      <td>
        `queryStat.total.RemoteServiceCallsLatencies`
      </td>

      <td>
        Latency of remote service calls.
      </td>
    </tr>

    <tr>
      <td>
        `queryStat.total.RemoteServiceNetworkBytesSizes`
      </td>

      <td>
        Network bytes exchanged with remote service.
      </td>
    </tr>

    <tr>
      <td>
        `queryStat.total.RemoteServiceProcessedRows`
      </td>

      <td>
        Count of rows processed by a remote service.
      </td>
    </tr>

    <tr>
      <td>
        `queryStat.total.RemoteServiceProcessedRowsLatencies`
      </td>

      <td>
        Latency of rows processed by a remote service.
      </td>
    </tr>

    <tr>
      <td>
        `queryStat.total.ReturnedRows`
      </td>

      <td>
        Number of rows that the queries returned.
      </td>
    </tr>

    <tr>
      <td>
        `queryStat.total.ScannedRows`
      </td>

      <td>
        Number of rows that the queries scanned excluding deleted values.
      </td>
    </tr>

    <tr>
      <td>
        `readStat.total.BytesReturned`
      </td>

      <td>
        Total number of data bytes that the reads returned excluding transmission encoding overhead.
      </td>
    </tr>

    <tr>
      <td>
        `readStat.total.ClientWaitTime`
      </td>

      <td>
        Number of seconds spent waiting due to throttling.
      </td>
    </tr>

    <tr>
      <td>
        `readStat.total.CpuTime`
      </td>

      <td>
        Number of seconds of CPU time Cloud Spanner spent execute the reads excluding prefetch CPU and other overhead.
      </td>
    </tr>

    <tr>
      <td>
        `readStat.total.Executions`
      </td>

      <td>
        Number of times Cloud Spanner executed the read shapesduring the interval.
      </td>
    </tr>

    <tr>
      <td>
        `readStat.total.LeaderRefreshDelay`
      </td>

      <td>
        Number of seconds spent coordinating reads across instances in multi-regionconfigurations.
      </td>
    </tr>

    <tr>
      <td>
        `readStat.total.LockingDelays`
      </td>

      <td>
        Distribution of total time in seconds spent waiting due to locking.
      </td>
    </tr>

    <tr>
      <td>
        `readStat.total.ReturnedRows`
      </td>

      <td>
        Number of rows that the reads returned.
      </td>
    </tr>

    <tr>
      <td>
        `rowDeletionPolicy.DeletedRows`
      </td>

      <td>
        Count of rows deleted by the policy since the last sample.
      </td>
    </tr>

    <tr>
      <td>
        `rowDeletionPolicy.ProcessedWatermarkAge`
      </td>

      <td>
        Time between now and the read timestamp of the last successful execution. An execution happens as the background
        task deletes eligible data in batches and is successful even when there are rows that cannot be deleted.
      </td>
    </tr>

    <tr>
      <td>
        `rowDeletionPolicy.UndeletableRows`
      </td>

      <td>
        Number of rows in all tables in the database that can't be deleted. A row can't be deleted if, for example, it
        has so many child rows that a delete would exceed the transaction limit.
      </td>
    </tr>

    <tr>
      <td>
        `transactionStat.total.BytesWritten`
      </td>

      <td>
        Number of bytes written by transactions.
      </td>
    </tr>

    <tr>
      <td>
        `transactionStat.total.CommitAttempts`
      </td>

      <td>
        Number of commit attempts for transactions.
      </td>
    </tr>

    <tr>
      <td>
        `transactionStat.total.CommitRetries`
      </td>

      <td>
        Number of commit attempts that are retries from previously aborted transaction attempts.
      </td>
    </tr>

    <tr>
      <td>
        `transactionStat.total.Participants`
      </td>

      <td>
        Distribution of total number of participants in each commit attempt.
      </td>
    </tr>

    <tr>
      <td>
        `transactionStat.total.TransactionLatencies`
      </td>

      <td>
        Distribution of total seconds takenfrom the first operation of the transaction to commit or abort.
      </td>
    </tr>
  </tbody>
</table>
