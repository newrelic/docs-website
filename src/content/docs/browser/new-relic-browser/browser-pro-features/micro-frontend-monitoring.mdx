---
title: Monitor micro frontends with Browser monitoring
tags:
  - Browser
  - Browser monitoring
  - Micro frontends
metaDescription: "Monitor the performance and user experience of individual micro frontends within your web application using New Relic Browser monitoring."
freshnessValidatedDate: never
---

Micro frontend (MFE) monitoring lets you track the performance and user experience of individual micro frontends within your web application. Instead of seeing all data aggregated at the application level, you can now isolate telemetry data for each micro frontend component into distinct entities in New Relic, giving you precise visibility into how each part of your application performs.

## What are micro frontends? [#what-are-mfes]

Micro frontends are an architectural pattern where large web applications are broken down into smaller, independently deployable components. Each micro frontend can be:

- Owned and maintained by separate team(s)
- Deployed independently of other components
- Representative of a specific business domain or feature

Common micro frontend patterns include:

- **Component-based architecture**: Individual UI components that render within a container application
- **Route-based splitting**: Different application routes handled by separate micro frontends  
- **Server-side composition**: Micro frontends assembled on the server before being sent to the client
- **Client-side composition**: Micro frontends loaded and rendered dynamically in the browser

## Why monitor micro frontends? [#why-monitor-mfes]

Traditional browser monitoring aggregates all data at the page level, making it difficult to:

- **Isolate performance issues** to specific micro frontends
- **Track the impact** of deployments for individual components
- **Set up alerts** for specific team-owned components
- **Debug errors** that originate from specific components
- **Capture custom events** tied to specific portions of the application that detail unique implementations and insights.

Micro frontend monitoring solves these challenges by providing:

- **Scoped timing data** for each micro frontend
- **Independent error and event tracking** with proper attribution
- **Team and Respository assignment** to solve ownership-based questions
- **Relationship mapping** between micro frontends and the container application
- **Granular control of custom data** at the component level

## How New Relic's micro frontend monitoring works [#how-it-works]

New Relic's approach uses a **central agent architecture** where:

1. **One browser agent** runs in the container application, which continues to capture page-wide data. This agent would typically be used by the container-level or platform teams, interested in monitoring holistic application performance.
2. **Each micro frontend registers** with the central agent using the `register` API
3. **Data is scoped and harvested** separately for each registered micro frontend when using the scoped APIs.
4. **New MicroFrontend entities automatically appear** in New Relic when utilized properly.
5. **Relationships are automatically created** between the container and micro frontends.
6. **Entity-level attribution is supported** to facilitate assignment of teams, repositories and tags.

This architecture pattern provides several benefits:

- **Lightweight implementation**: No duplicate agent code is ever loaded on the page
- **Shared infrastructure**: All micro frontends benefit from the container's feature set
- **Consistent harvesting**: Data collection follows the same patterns across all components -- Collect data by using the APIs you are already familiar with.
- **Simplified configuration**: Container team is still in control of what happens on a given page.

## Architecture patterns and implementation [#architecture-patterns]

### How registration works [#how-registration-works]

When you register a micro frontend with the browser agent, the following process occurs:

1. **Call the register API**: You provide a unique ID and name for your micro frontend
2. **Receive a scoped agent**: The agent returns an object containing scoped versions of browser monitoring APIs
3. **Use the scoped APIs**: All data captured through these APIs is automatically attributed to your micro frontend entity
4. **Entity creation**: New Relic automatically creates a new browser entity for your micro frontend if one doesn't exist
5. **Data isolation**: Your micro frontend's telemetry data appears separately in New Relic, distinct from the container application

**Available APIs on the returned object:**

The registration returns an object with the following scoped methods:

- [`addPageAction()`](/docs/browser/new-relic-browser/browser-apis/addpageaction) - Record custom page actions specific to your micro frontend
- [`addRelease()`](/docs/browser/new-relic-browser/browser-apis/addrelease) - Track deployments and releases for your micro frontend
- [`deregister()`](/docs/browser/new-relic-browser/browser-apis/deregister) - Unregister the micro frontend when it unmounts or is no longer needed. Timings describing the lifecycle of your micro frontend will be automatically tabulated based on the usage of this API.
- [`interaction()`](/docs/browser/new-relic-browser/browser-apis/interaction) - Access the SPA interaction API for custom timing
- [`log()`](/docs/browser/new-relic-browser/browser-apis/log) - Capture log messages scoped to your micro frontend
- [`measure()`](/docs/browser/new-relic-browser/browser-apis/measure) - Create custom performance measurements
- [`noticeError()`](/docs/browser/new-relic-browser/browser-apis/noticeerror) - Manually capture errors with micro frontend attribution
- [`register()`](/docs/browser/new-relic-browser/browser-apis/register) - Register an entity for scoped data observability
- [`recordCustomEvent()`](/docs/browser/new-relic-browser/browser-apis/recordcustomevent) - Record custom events for analytics
- [`setApplicationVersion()`](/docs/browser/new-relic-browser/browser-apis/setapplicationversion) - Track the specific version of your micro frontend
- [`setCustomAttribute()`](/docs/browser/new-relic-browser/browser-apis/setcustomattribute) - Add custom attributes that apply to all data from this micro frontend
- [`setUserId()`](/docs/browser/new-relic-browser/browser-apis/setuserid) - Associate a user ID with this micro frontend's data

Each of these methods works identically to the standard browser agent APIs, but automatically scopes all collected data to your micro frontend entity.

### Key Requirements
1. IDs supplied should be generated and managed according to your organization's internal processes and conventions. It serves as a permanent, stable reference to uniquely identify this specific documentation entity across your system. Ensure this value remains consistent and is not duplicated across other documents or entities.
2. **Name**: Choose a meaningful, human-readable name that clearly identifies your micro frontend. This name becomes the entity name in New Relic. Using different names for the same ID across registrations may cause the entity name to vary unpredictably.

### Client-side monitoring

```js
// Container application - loads the browser agent
<script src="https://js-agent.newrelic.com/nr-loader-spa-1.x.x.min.js"></script>

// In your micro frontend module -- Register your entity
const catalogAgent = window.newrelic.register({
  id: '550e8400-e29b-41d4-a716-446655440000',
  name: 'Catalog Viewer',
  tags: ['Documentation', 'Customer Facing']
});

// Set module-specific attributes, which will append attributes to all data collected about your micro frontend
catalogAgent.setCustomAttribute('catalogVersion', '2.1.0');
catalogAgent.setCustomAttribute('displayMode', 'grid');

// Set user context for this micro frontend
catalogAgent.setUserId('user-abc-123');

// Track the version of this specific micro frontend
catalogAgent.setApplicationVersion('catalog-mfe-v2.1.0');

// Track custom page actions
catalogAgent.addPageAction('catalogItemViewed', { 
  itemId: '12345',
  category: 'electronics' 
});

// Capture errors specific to this micro frontend
try {
  // Component logic that might fail
  loadCatalogItems();
} catch (error) {
  catalogAgent.noticeError(error, { 
    context: 'catalog-load', // custom attributes for more information
    failedOperation: 'fetchItems' // custom attributes for more information
  });
}

// Track custom logs specific to this module
catalogAgent.log('Catalog items loaded successfully', { 
  level: 'debug', customAttributes: {
    itemCount: 150,
    loadTime: 245 
  }
});

// Record custom events for analytics
catalogAgent.recordCustomEvent('CatalogInteraction', {
  action: 'filter-applied',
  filterType: 'price-range',
  minPrice: 10,
  maxPrice: 100
});

// Measure custom performance metrics
catalogAgent.measure('catalog-rerender', {
  start: 1234,
  end: 5678
});

// Cleanup when the micro frontend unmounts and is no longer needed
catalogAgent.deregister();
```

## Generic component monitoring [#generic-components]

While primarily designed for micro frontends, this monitoring approach can be used generically for any sub-entities within your browser application:

- **Shared components** across your pages
- **Third-party widgets** embedded in your application
- **Feature flags** and A/B test variants
- **User journey segments** like onboarding flows
- **Dynamic content areas** that load different experiences

```js
// Monitor a third-party chat widget
const chatWidget = window.newrelic.register({
  id: '7f9e4a1b-c3d2-4e8f-9b5a-1d6c8e2f4a3b',
  name: 'Customer Support Chat',
  tags: ['Component', 'Customer Facing']
});

chatWidget.addPageAction('chatStarted');
chatWidget.setCustomAttribute('widgetVersion', '2.1.4');

// Monitor an onboarding flow
const onboardingAgent = window.newrelic.register({
  id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
  name: 'New User Onboarding',
  tags: ['Component', 'Internal']
});

onboardingAgent.addPageAction('onboardingStepCompleted', { step: 3 });
```

## Data relationships and entity synthesis [#relationships]

When you register a micro frontend, New Relic automatically:

1. **Creates a browser entity** for the micro frontend if it doesn't exist
2. **Establishes relationships** between the container and micro frontend entities
3. **Tracks various timings** describing the import and execution times of your micro frontend scripts
4. **Enables distributed tracing** connections between backend services and micro frontends when available
5. **Adds entity tagging and metadata** to help with organization and discovery
6. **Decorates telemetry** with the appropriate attributes necessary for cross-linking between the container and the MFE.

### Nested Relationships

Micro frontends can also be related to other micro frontends.  To achieve this, simply register your nested micro frontend with a micro frontend's register API instead of the window-level register API.

```js
const mfe1 = window.newrelic.register({
  id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
  name: 'Parent MFE'
})

// register another MFE as a child of mfe1
const mfe2 = mfe1.register({
  id: '7f9e4a1b-c3d2-4e8f-9b5a-1d6c8e2f4a3b',
  name: 'Child MFE'
})
```

These entities would then be related in New Relic like: `Browser Agent -- contains --> Parent MFE -- contains --> Child MFE` 

### View your related entities
The relationships appear in your service maps and entity explorer, showing how your micro frontends connect to your broader application architecture.

## Configuration at the container
For detailed implementation steps, see our [micro frontend configuration guide](/docs/browser/new-relic-browser/configuration/configure-micro-frontend-monitoring).

### Enablement
The container browser agent acts as the gatekeeper for the page and controls what any registered children can report. As such, it can be configured to block incoming registration data:

To configure this, edit the application settings in New Relic for your container agent app.  To do so with NPM, ensure that the container agent is supplied with:
```js
{
  init: {
    // ... other configs
    api: {
      allow_registered_children: true|false
    }
  }
}
```

## Data duplication

The container browser agent can be configured to duplicate data reported by registered micro frontends to its own app, thereby ensuring that _all_ data can be observed from the top-level application if desired.
This can be further broken down, as the agent will automatically add `parent.id` and `child.id` attributes to the relevant data reported by each, enabling easy cross-linking as needed.

To configure this, edit the application settings in New Relic for your container agent app.  To do so with NPM, ensure that the container agent is supplied with:
```js
{
  init: {
    // ... other configs
    api: {
      duplicate_registered_data: true|false
    }
  }
}
```

## Performance timing and measurements [#performance-timing]

Micro frontend monitoring can capture the same performance data as standard browser monitoring, but scoped to each component:

- **Performance timings** (when applicable to the micro frontend's initialization) - reported as `MicroFrontEndTiming` events
- **AJAX requests** made from within the micro frontend context  
- **JavaScript errors** that occur in micro frontend code
- **Custom performance marks and measures** specific to the component

## Getting started [#getting-started]

To start monitoring your micro frontends:

1. **Ensure you have a browser agent** (Pro or Pro+SPA) running on your container application
2. **Register each micro frontend** within your application using the `register` API
3. **Use the returned APIs** to capture micro frontend-specific data
4. **Find your new entities** in New Relic under "Browser" > "Micro Front Ends"
5. **Query your data and set up teams, repos, dashboards and alerts** for your individual micro frontend entities

For detailed implementation steps, see our [micro frontend configuration guide](/docs/browser/new-relic-browser/configuration/configure-micro-frontend-monitoring).

<Callout variant="tip">
It's always a good idea to start small by instrumenting one or two micro frontends first, then expand to additional components as you become familiar with the patterns and data. Implement and validate changes in a sandbox or staging environment before exposing to production.
</Callout>

## Next steps [#next-steps]

- [Learn more about registering micro frontends](/docs/browser/new-relic-browser/browser-apis/register) using the register API
- [Configure micro frontend data capture](/docs/browser/new-relic-browser/configuration/configure-micro-frontend-monitoring) for your application
- [Use NPM packages](/docs/browser/new-relic-browser/npm-package/micro-frontend-npm-usage) for micro frontend monitoring
- [Understand micro frontend performance timing](/docs/browser/new-relic-browser/browser-pro-features/micro-frontend-performance-timing)
- [Learn about limitations](/docs/browser/new-relic-browser/troubleshooting/micro-frontend-monitoring-limitations) of micro frontend monitoring