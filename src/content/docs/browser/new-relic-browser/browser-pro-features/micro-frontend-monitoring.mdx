---
title: Monitor micro frontends with Browser monitoring
tags:
  - Browser
  - Browser monitoring
  - Micro frontends
metaDescription: "Monitor the performance and user experience of individual micro frontends within your web application using New Relic Browser monitoring."
freshnessValidatedDate: never
---

Micro frontend (MFE) monitoring lets you track the performance and user experience of individual micro frontends within your web application. Instead of seeing all data aggregated at the application level, you can now isolate telemetry data for each micro frontend component into distinct entities in New Relic, giving you precise visibility into how each part of your application performs.

## What are micro frontends? [#what-are-mfes]

Micro frontends are an architectural pattern where large web applications are broken down into smaller, independently deployable components. Each micro frontend can be:

- Owned and maintained by separate team(s)
- Deployed independently of other components
- Representative of a specific business domain or feature


## Why monitor micro frontends? [#why-monitor-mfes]

Traditional browser monitoring aggregates all data at the page level, making it difficult to:

- **Isolate performance issues** to specific micro frontends
- **Track the impact** of deployments for individual components
- **Set up alerts** for specific team-owned components
- **Debug errors** that originate from specific components
- **Capture custom events** tied to specific portions of the application that detail unique implementations and insights.

Micro frontend monitoring solves these challenges by providing:

- **Scoped timing data** for each micro frontend
- **Independent error and event tracking** with proper attribution
- **Team and Respository assignment** to solve ownership-based questions
- **Relationship mapping** between micro frontends and the container application
- **Granular control of custom data** at the component level

## How New Relic's micro frontend monitoring works [#how-it-works]

New Relic's approach uses a **central agent architecture** where:

1. **One browser agent** runs in the container application, which continues to capture page-wide data. This agent would typically be used by the container-level or platform teams, interested in monitoring holistic application performance.
2. **Each micro frontend registers** with the central agent using the `register` API
3. **Data is scoped and harvested** separately for each registered micro frontend when using the scoped APIs.
4. **New MicroFrontend entities automatically appear** in New Relic when utilized properly.
5. **Relationships are automatically created** between the container and micro frontends.
6. **Entity-level attribution is supported** to facilitate assignment of teams, repositories and tags.

This architecture pattern provides several benefits:

- **Lightweight implementation**: No duplicate agent code is ever loaded on the page
- **Shared infrastructure**: All micro frontends benefit from the container's feature set
- **Consistent harvesting**: Data collection follows the same patterns across all components -- Collect data by using the APIs you are already familiar with.
- **Simplified configuration**: Container team is still in control of what happens on a given page.

## Architecture patterns and implementation [#architecture-patterns]

### How registration works.
All micro frontend activity is facilitated by using the `register` API on the container browser agent. Please refer to the [register API](/docs/browser/new-relic-browser/browser-apis/register) documentation for more information.

### Key Requirements
1. IDs supplied should be generated and managed according to your organization's internal processes and conventions. It serves as a permanent, stable reference to uniquely identify this specific entity across your system. Ensure this value remains consistent and is not duplicated across other entities.
2. **Name**: Choose a meaningful, human-readable name that clearly identifies your micro frontend. This name becomes the entity name in New Relic. Using different names for the same ID across registrations may cause the entity name to vary unpredictably.

### Client-side monitoring

```js
// Container application - loads the browser agent
<script src="https://js-agent.newrelic.com/nr-loader-spa-1.x.x.min.js"></script>

// In your micro frontend module -- Register your entity
const catalogAgent = window.newrelic.register({
  id: '550e8400-e29b-41d4-a716-446655440000',
  name: 'Catalog Viewer',
  tags: ['Documentation', 'Customer Facing']
});

// Set module-specific attributes, which will append attributes to all data collected about your micro frontend
catalogAgent.setCustomAttribute('catalogVersion', '2.1.0');
catalogAgent.setCustomAttribute('displayMode', 'grid');

// Set user context for this micro frontend
catalogAgent.setUserId('user-abc-123');

// Track the version of this specific micro frontend
catalogAgent.setApplicationVersion('catalog-mfe-v2.1.0');

// Track custom page actions
catalogAgent.addPageAction('catalogItemViewed', { 
  itemId: '12345',
  category: 'electronics' 
});

// Capture errors specific to this micro frontend
try {
  // Component logic that might fail
  loadCatalogItems();
} catch (error) {
  catalogAgent.noticeError(error, { 
    context: 'catalog-load', // custom attributes for more information
    failedOperation: 'fetchItems' // custom attributes for more information
  });
}

// Track custom logs specific to this module
catalogAgent.log('Catalog items loaded successfully', { 
    level: 'debug', 
    customAttributes: {
      itemCount: 150,
      loadTime: 245 
    }
  }
);

// Record custom events for analytics
catalogAgent.recordCustomEvent('CatalogInteraction', {
  action: 'filter-applied',
  filterType: 'price-range',
  minPrice: 10,
  maxPrice: 100
});

// Measure custom performance metrics
catalogAgent.measure('catalog-rerender', {
  start: 1234,
  end: 5678
});

// Cleanup when the micro frontend unmounts and is no longer needed
catalogAgent.deregister();
```

## Generic component monitoring [#generic-components]

While primarily designed for micro frontends, this monitoring approach can be used generically for any sub-entities within your browser application:

- **Shared components** across your pages
- **Third-party widgets** embedded in your application
- **Feature flags** and A/B test variants
- **User journey segments** like onboarding flows
- **Dynamic content areas** that load different experiences

```js
// Monitor a third-party chat widget
const chatWidget = window.newrelic.register({
  id: '7f9e4a1b-c3d2-4e8f-9b5a-1d6c8e2f4a3b',
  name: 'Customer Support Chat',
  tags: ['Component', 'Customer Facing']
});

chatWidget.addPageAction('chatStarted');
chatWidget.setCustomAttribute('widgetVersion', '2.1.4');

// Monitor an onboarding flow
const onboardingAgent = window.newrelic.register({
  id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
  name: 'New User Onboarding',
  tags: ['Component', 'Internal']
});

onboardingAgent.addPageAction('onboardingStepCompleted', { step: 3 });
```

## Data relationships and entity synthesis [#relationships]

When you register a micro frontend, New Relic automatically:

1. **Creates a browser entity** for the micro frontend if it doesn't exist
2. **Establishes relationships** between the container and micro frontend entities
3. **Tracks various timings** describing the lifecycle timings of your micro frontend scripts
4. **Enables distributed tracing** connections between backend services and micro frontends when available
5. **Adds entity tagging and metadata** to help with organization and discovery

### Nested Relationships

Micro frontends can also be related to other micro frontends.  To achieve this, simply register your nested micro frontend with a micro frontend's register API instead of the window-level register API.

```js
const mfe1 = window.newrelic.register({
  id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
  name: 'Parent MFE'
})

// register another MFE as a child of mfe1
const mfe2 = mfe1.register({
  id: '7f9e4a1b-c3d2-4e8f-9b5a-1d6c8e2f4a3b',
  name: 'Child MFE'
})
```

These entities would then be related in New Relic like: `Browser Agent -- contains --> Parent MFE -- contains --> Child MFE` 

### View your related entities
The relationships appear in your service maps and entity explorer, showing how your micro frontends connect to your broader application architecture.

## Configuration at the container
For detailed implementation steps, see our [micro frontend configuration guide](/docs/browser/new-relic-browser/configuration/configure-micro-frontend-monitoring).

### Enablement
The container browser agent acts as the gatekeeper for the page and controls what any registered children can report. As such, it can be configured to block incoming registration data:

To configure this, edit the application settings in New Relic for your container agent app.  To do so with NPM, ensure that the container agent is supplied with:
```js
{
  init: {
    // ... other configs
    api: {
      allow_registered_children: true|false // defaults to `false`
    }
  }
}
```

## Data duplication

The container browser agent can be configured to duplicate data reported by registered micro frontends to its own app, thereby ensuring that _all_ data can be observed from the top-level application if desired.
This can be further broken down, as the agent will automatically add `parent.id` and `child.id` attributes to the relevant data reported by each, enabling easy cross-linking as needed.

To configure this, edit the application settings in New Relic for your container agent app. To do so with the Browser Agent NPM package, ensure that the container agent is supplied with:
```js
{
  init: {
    // ... other configs
    api: {
      duplicate_registered_data: true|false
    }
  }
}
```

## Performance timing and measurements [#performance-timing]

Micro frontend monitoring can capture the same performance data as standard browser monitoring, but scoped to each component:

- **Performance timings** (when applicable to the micro frontend's initialization) - reported as `MicroFrontEndTiming` events
- **JavaScript errors** that occur in micro frontend code and captured using the scoped `.noticeError()` API
- **Custom performance marks and measures** specific to the component

## Getting started [#getting-started]

To start monitoring your micro frontends:

1. **Ensure you have a browser agent** (Pro or Pro+SPA) running on your container application
2. **Register each micro frontend** within your application using the `register` API
3. **Use the returned APIs** to capture micro frontend-specific data
4. **Find your new entities** in New Relic under "Browser" > "Micro-Frontends"
5. **Query your data and set up teams, repos, dashboards and alerts** for your individual micro frontend entities

For detailed implementation steps, see our [micro frontend configuration guide](/docs/browser/new-relic-browser/configuration/configure-micro-frontend-monitoring).

<Callout variant="tip">
It's always a good idea to start small by instrumenting one or two micro frontends first, then expand to additional components as you become familiar with the patterns and data. Implement and validate changes in a sandbox or staging environment before exposing to production.
</Callout>

## Next steps [#next-steps]

- [Learn more about registering micro frontends](/docs/browser/new-relic-browser/browser-apis/register) using the register API
- [Configure micro frontend data capture](/docs/browser/new-relic-browser/configuration/configure-micro-frontend-monitoring) for your application
- [Use NPM packages](/docs/browser/new-relic-browser/npm-package/micro-frontend-npm-usage) for micro frontend monitoring
- [Understand micro frontend performance timing](/docs/browser/new-relic-browser/browser-pro-features/micro-frontend-performance-timing)
- [Learn about limitations](/docs/browser/new-relic-browser/troubleshooting/micro-frontend-monitoring-limitations) of micro frontend monitoring