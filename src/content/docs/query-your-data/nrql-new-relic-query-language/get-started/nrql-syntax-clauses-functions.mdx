---
title: 'NRQL syntax, clauses, and functions'
contentType: page
template: basicDoc
topics:
  - Query your data
  - 'NRQL: New Relic Query Language'
  - Get started
japaneseVersion: ''
---

NRQL is a query language you can use to query the New Relic database. This document explains NRQL syntax, clauses, components, and functions.

## Syntax

This document is a reference for the functions and clauses used in a NRQL query. Other resources for understanding NRQL:

* [Intro to NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql): explains what NRQL is used for, what data you can query with it, and basic NRQL syntax
* [Examine NRQL queries used to build New Relic charts](/docs/using-new-relic/user-interface-functions/view-your-data/standard-new-relic-ui-page-functions#view-query)
* [Simulate SQL JOIN functions](/docs/insights/new-relic-insights/using-new-relic-query-language/simulate-sql-join-functions-insights)
* [Use funnels to evaluate a series of related data](/docs/insights/new-relic-insights/features/funnels)
* [Format NRQL for querying with the Event API](/docs/insights/insights-api/get-data/query-insights-event-data-api)

## Query components

Every NRQL query will begin with a `SELECT` statement or a `FROM` clause. All other clauses are optional. The clause definitions below also contain example NRQL queries.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="state-select"
    title="Required: "
    title=" statement"
  >
    ```
    SELECT attribute ...
    ```

    ```
    SELECT function(attribute) ...
    ```

    The `SELECT` specifies what portion of a data type you want to query by specifying an [attribute](/docs/insights/new-relic-insights/decorating-events/insights-attributes) or a [function](#functions). It's followed by one or more arguments separated by commas. In each argument you can:

    * Get the values of all available attributes by using `*` as a wildcard. For example: `SELECT * from Transaction`.
    * Get values associated with a specified attribute or multiple attributes specified in a [comma separated list](#commas).
    * Get aggregated values from specified attributes by selecting an [aggregator function](#functions).
    * Label the results returned in each argument with [the `AS` clause](#sel-as).

    You can also [use `SELECT` with basic math functions](/docs/query-data/nrql-new-relic-query-language/getting-started/nrql-math-using-select).

    <dt id="avg-resp-time-query">
      Avg response time since last week
    </dt>

    <dd>
      This query returns the average response time since last week.

      ```
      SELECT average(duration) FROM PageView SINCE 1 week ago
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-from"
    title="Required: "
    title=" clause"
  >
    ```
    SELECT ...
      FROM data type
      ...
    ```

    Use the `FROM` clause to specify the [data type](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql#what-you-can-query) you wish to query. You can start your query with `FROM` or with [`SELECT`](#state-select). You can merge values for the same attributes across multiple data types in a [comma separated list](#commas).

    <dt id="one-event">
      Query one data type
    </dt>

    <dd>
      This query returns the count of all [APM transactions](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) over the last three days:

      ```
      SELECT count(*) FROM Transaction SINCE 3 days ago
      ```
    </dd>

    <dt id="multiple-events">
      Query multiple data types
    </dt>

    <dd>
      This query returns the count of all [APM transactions](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) and [Browser events](/docs/insights/new-relic-insights/decorating-events/browser-default-attributes-insights#browser-attributes-table) over the last three days:

      ```
      SELECT count(*) FROM Transaction, PageView SINCE 3 days ago
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="show-event-types"
    title=" clause"
  >
    ```
    SHOW EVENT TYPES...
    ```

    `SHOW EVENT TYPES` will return a list of all the data types present in your account for a specific time range. It is used as the first clause in a query instead of `SELECT`.

    <Callout variant="important">
      In this context, "event types" refers to the data types you can access with a NRQL query.
    </Callout>

    <dt id="avg-resp-time-query">
      Data types in the last day
    </dt>

    <dd>
      This query will return all the data types present over the past day:

      ```
      SHOW EVENT TYPES SINCE 1 day ago
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-where"
    title=" clause"
  >
    Use the `WHERE` clause to filter results. NRQL returns the results that fulfill the condition(s) you specify in the clause.

    ```
    SELECT function(attribute) ...
      WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ]
      [AND|OR ...]
      ...
    ```

    * If you specify more than one condition, separate the conditions by the operators `AND` or `OR`.
    * If you want to [simulate a SQL join](/docs/insights/nrql-new-relic-query-language/using-nrql/simulate-sql-join-functions-insights), use custom attributes in a `WHERE` or `FACET` clause.

    <Table id="where-operators">
      <thead>
        <tr>
          <th width={150}>
            **Operators that the `WHERE` clause accepts**
          </th>

          <th>
            **Description**
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `=`, `!=`, `<`, `<=`, `>`, `>=`
          </td>

          <td>
            NRQL accepts standard comparison operators.

            Example: `state = 'WA'`
          </td>
        </tr>

        <tr>
          <td>
            `AND`
          </td>

          <td>
            Used to define an intersection of two conditions.
          </td>
        </tr>

        <tr>
          <td>
            `OR`
          </td>

          <td>
            Used to define a union of two conditions.
          </td>
        </tr>

        <tr>
          <td>
            `IS NULL`
          </td>

          <td>
            Determines if an attribute has a null value.
          </td>
        </tr>

        <tr>
          <td>
            `IS NOT NULL`
          </td>

          <td>
            Determines if an attribute does not have a null value.
          </td>
        </tr>

        <tr>
          <td>
            `IN`
          </td>

          <td>
            Determines if the string value of an attribute is in a specified set. Using this method yields better performance than stringing together multiple `WHERE` clauses.

            Example: `animalType IN ('cat', 'dog', 'fish')`
          </td>
        </tr>

        <tr>
          <td>
            `NOT IN`
          </td>

          <td>
            Determines if the string value of an attribute is not in a specified set. Using this method yields better performance than stringing together multiple `WHERE` clauses.

            Values must be in parentheses, separated by commas. For example:

            ```
            SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `LIKE`
          </td>

          <td>
            Determines if an attribute contains a specified sub-string.

            The string argument for the `LIKE` operator accepts the percent sign (%) as a wildcard anywhere in the string. If the substring does not begin or end the string you are matching against, the wildcard must begin or end the string.

            **Examples:**

            `userAgentName LIKE 'IE%'`

            * IE
            * IE Mobile

            `userAgentName LIKE 'o%a%'`

            * Opera
            * Opera Mini

            `userAgentName LIKE 'o%a'`

            * Opera

            `userAgentName LIKE '%o%a%'`

            * Opera
            * Opera Mini
            * Mozilla Gecko
          </td>
        </tr>

        <tr>
          <td>
            `NOT LIKE`
          </td>

          <td>
            Determines if an attribute does not contain a specified sub-string.
          </td>
        </tr>

        <tr>
          <td>
            `RLIKE`
          </td>

          <td>
            Determines if an attribute contains a specified Regex sub-string. Uses [RE2 syntax](https://github.com/google/re2/wiki/Syntax).

            **Examples:**

            `appName RLIKE 'z.*|q.*''`

            * `z-app`
            * `q-app`

            `hostname RLIKE 'ip-10-351-[0-2]?[0-9]-.*'`

            * `ip-10-351-19-237`
            * `ip-10-351-2-41`
            * `ip-10-351-24-238`
            * `ip-10-351-14-15`

            <Callout variant="important">
              Note:

              * Slashes must be escaped in the Regex pattern. For example, `\d` must be `\\d`.
              * Regex defaults to full-string matching, therefore `^` and `$` are implicit and you do not need to add them.
              * If the Regex pattern contains a capture group, the group will be ignored. That is, the group will not be captured for use later in the query.
            </Callout>
          </td>
        </tr>

        <tr>
          <td>
            `NOT RLIKE`
          </td>

          <td>
            Determines if an attribute does not contain a specified Regex sub-string. Uses [RE2 syntax](https://github.com/google/re2/wiki/Syntax).
          </td>
        </tr>
      </tbody>
    </Table>

    <dt id="query-3-conditions">
      Example query with three conditions
    </dt>

    <dd>
      This query returns the browser response time for pages with `checkout` in the URL for Safari users in the United States and Canada over the past 24 hours.

      ```
      SELECT histogram(duration, 50, 20) FROM PageView
      WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%'
      SINCE 1 day ago
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-as"
    title=" clause"
  >
    ```
    SELECT ...
      AS 'label'
      ...
    ```

    Use the `AS` clause to label an attribute, aggregator, step in a funnel, or the result of a math function with a string delimited by single quotes. The label is used in the resulting chart.

    <dt id="math-as">
      Query using math function and `AS`
    </dt>

    <dd>
      This query returns the number of page views per session:

      ```
      SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session'
        FROM PageView
      ```
    </dd>

    <dt id="funnel-as">
      Query using funnel and `AS`
    </dt>

    <dd>
      This query returns a count of people who have visited both the main page and the careers page of a site over the past week:

      ```
      SELECT funnel(SESSION,
          WHERE name='Controller/about/main' AS 'Step 1',
          WHERE name = 'Controller/about/careers' AS 'Step 2')
          FROM PageView SINCE 1 week ago
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet"
    title=" clause"
  >
    ```
    SELECT ...
      FACET attribute
      ...
    ```

    Use `FACET` to separate and group your results by attribute values. For example, you could `FACET` your `PageView` data by `deviceType` to figure out what percentage of your traffic comes from mobile, tablet, and desktop devices.

    Use the `LIMIT` clause to specify how many facets appear (default is 10). For more complex grouping, use [`FACET CASES`](#sel-facet-cases). `FACET` clauses support up to five attributes, separated by commas.

    The facets are sorted in descending order by the first field you provide in the `SELECT` clause. If you are faceting on attributes with more than 1,000 unique values, a subset of facet values is selected and sorted according to the query type.

    When selecting `min()`, `max()`, or `count()`, `FACET` uses those functions to determine how facets are picked and sorted. When selecting any other [function](#functions), `FACET` uses the frequency of the attribute you are faceting on to determine how facets are picked and sorted.

    For more on faceting on multiple attributes, with some real-world examples, see this [New Relic blog post](https://blog.newrelic.com/2017/12/08/facets-nrql-queries-insights/).

    <dt id="faceted-query">
      Faceted query using `count()`
    </dt>

    <dd>
      This query shows cities with the highest pageview counts. This query uses the total number of pageviews per city to determine how facets are picked and ordered.

      ```
      SELECT count(*) FROM PageView FACET city
      ```
    </dd>

    <dt id="uniquecount">
      Faceted query using `uniqueCount()`
    </dt>

    <dd>
      This query shows the cities that access the highest number of unique URLs. This query uses the total number of times a particular city appears in the results to determine how facets are picked and ordered.

      ```
      SELECT uniqueCount(pageUrl) FROM PageView FACET city
      ```
    </dd>

    <dt id="cohort-analysis">
      Grouping results across time
    </dt>

    <dd>
      [Advanced segmentation](/docs/insights/new-relic-insights/features/advanced-segmentation) and [cohort analysis](/docs/insights/new-relic-insights/features/cohort-analysis-grouping-results-across-time) allow you to facet on bucket functions to more effectively break out your data.

      Cohort analysis is a way to group results together based on timestamps. You can separate them into buckets that cover a specified range of dates and times.
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-cases"
    title=" clause"
  >
    ```
    SELECT ...
      FACET CASES (
        WHERE attribute operator value, WHERE attribute operator value, ...
        )
      ...
    ```

    Use `FACET CASES` to break out your data by more complex conditions than possible with [`FACET`](#sel-facet). Separate multiple conditions with a comma `,`. For example, you could query your PageView data and `FACET CASES` into categories like less than 1 second, from 1 to 10 seconds, and greater than 10 seconds. You can combine multiple attributes within your cases, and label the cases with the [`AS`](#sel-as) selector. Data points will be added to at most one facet case, the first facet case that they match.

    You may also use a [time function](/docs/query-data/nrql-new-relic-query-language/nrql-query-examples/group-results-across-time) with your attribute.

    <dt id="facet-cases-basic">
      Basic usage with `WHERE`
    </dt>

    <dd>
      ```
      SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10)
      ```
    </dd>

    <dt id="facet-cases-mixnmatch">
      Group based on multiple attributes
    </dt>

    <dd>
      This example groups results into one bucket where the transaction name contains `login`, and another where the URL contains `login` and a custom attribute indicates that the user was a paid user:

      ```
      SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid')
      ```
    </dd>

    <dt id="facet-cases-as-label">
      Label groups with `AS`
    </dt>

    <dd>
      This example uses the [`AS`](#sel-as) selector to give your results a human-readable name:

      ```
      SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users')
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-limit"
    title=" clause"
  >
    ```
    SELECT ...
      LIMIT count
      ...
    ```

    Use the `LIMIT` clause to control the maximum number of facet values returned by `FACET` queries or the maximum number of items returned by `SELECT *` queries. This clause takes a single integer value as an argument. If the `LIMIT` clause is not specified, or no value is provided, the limit defaults to 10 for `FACET` queries and 100 in the case of `SELECT *` queries.

    The maximum allowed value for the `LIMIT` clause is 2,000.

    <dt>
      Query using `LIMIT`
    </dt>

    <dd>
      This query shows the top 20 countries by session count and provides 95th percentile of response time for each country for Windows users only.

      ```
      SELECT uniqueCount(session), percentile(duration, 95)
        FROM PageView WHERE userAgentOS = 'Windows'
        FACET countryCode LIMIT 20 SINCE YESTERDAY
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-offset"
    title=" clause"
  >
    ```
    SELECT ...
      LIMIT count OFFSET count
      ...
    ```

    Use the `OFFSET` clause with `LIMIT` to control the portion of rows returned by `SELECT *` or `SELECT column` queries. Like the `LIMIT` clause, `OFFSET` takes a single integer value as an argument. `OFFSET` sets the number of rows to be skipped before the selected rows of your query are returned. This is constrained by `LIMIT`.

    `OFFSET` rows are skipped starting from the most recent record.

    For example, the query `SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1` returns the last 5 values from `Minute_Report` except for the most recent one.
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-since"
    title=" clause"
  >
    ```
    SELECT ...
      SINCE [numerical units AGO | phrase]
      ...
    ```

    The **default** value is **1 hour ago**.

    Use the `SINCE` clause to define the beginning of a time range for the returned data. When using NRQL, you can set a [UTC timestamp](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets#utc-range) or [relative time range](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets#relative-range). You can specify a timezone for the query but not for the results. NRQL results are based on your system time.

    See [Set time range on dashboards and charts](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets) for detailed information and examples.
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-until"
    title=" clause"
  >
    ```
    SELECT ...
      UNTIL integer units AGO
      ...
    ```

    The **default** value is **NOW**. Only use `UNTIL` to specify an end point other than the default.

    Use the `UNTIL` clause to define the end of a time range across which to return data. Once a time range has been specified, the data will be preserved and can be reviewed after the time range has ended. You can specify a [UTC timestamp](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets#utc-range) or [relative time range](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets#relative-range). You can specify a time zone for the query but not for the results. The returned results are based on your system time.

    See [Set time range on dashboards and charts](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets) for detailed information and examples.
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timezone"
    title=" clause"
  >
    ```
    SELECT ... WITH TIMEZONE (selected zone)
      ...
    ```

    By default, query results are displayed in the timezone of the browser you're using.

    Use the `WITH TIMEZONE` clause to select a time zone for a date or time in the query that hasn't already had a time zone specified for it.

    For example, the query clause `SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'` will return data recorded from Monday at midnight, Eastern Standard Time, until midnight Tuesday, Eastern Standard Time.

    <Table style={{ width: "auto" }}>
      <thead>
        <tr>
          <th colSpan={4}>
            Available Time Zone Selections
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            Africa/Abidjan
          </td>

          <td>
            Africa/Addis_Ababa
          </td>

          <td>
            Africa/Algiers
          </td>

          <td>
            Africa/Blantyre
          </td>
        </tr>

        <tr>
          <td>
            Africa/Cairo
          </td>

          <td>
            Africa/Windhoek
          </td>

          <td>
            America/Adak
          </td>

          <td>
            America/Anchorage
          </td>
        </tr>

        <tr>
          <td>
            America/Araguaina
          </td>

          <td>
            America/Argentina/Buenos_Aires
          </td>

          <td>
            America/Belize
          </td>

          <td>
            America/Bogota
          </td>
        </tr>

        <tr>
          <td>
            America/Campo_Grande
          </td>

          <td>
            America/Cancun
          </td>

          <td>
            America/Caracas
          </td>

          <td>
            America/Chicago
          </td>
        </tr>

        <tr>
          <td>
            America/Chihuahua
          </td>

          <td>
            America/Dawson_Creek
          </td>

          <td>
            America/Denver
          </td>

          <td>
            America/Ensenada
          </td>
        </tr>

        <tr>
          <td>
            America/Glace_Bay
          </td>

          <td>
            America/Godthab
          </td>

          <td>
            America/Goose_Bay
          </td>

          <td>
            America/Havana
          </td>
        </tr>

        <tr>
          <td>
            America/La_Paz
          </td>

          <td>
            America/Los_Angeles
          </td>

          <td>
            America/Miquelon
          </td>

          <td>
            America/Montevideo
          </td>
        </tr>

        <tr>
          <td>
            America/New_York
          </td>

          <td>
            America/Noronha
          </td>

          <td>
            America/Santiago
          </td>

          <td>
            America/Sao_Paulo
          </td>
        </tr>

        <tr>
          <td>
            America/St_Johns
          </td>

          <td>
            Asia/Anadyr
          </td>

          <td>
            Asia/Bangkok
          </td>

          <td>
            Asia/Beirut
          </td>
        </tr>

        <tr>
          <td>
            Asia/Damascus
          </td>

          <td>
            Asia/Dhaka
          </td>

          <td>
            Asia/Dubai
          </td>

          <td>
            Asia/Gaza
          </td>
        </tr>

        <tr>
          <td>
            Asia/Hong_Kong
          </td>

          <td>
            Asia/Irkutsk
          </td>

          <td>
            Asia/Jerusalem
          </td>

          <td>
            Asia/Kabul
          </td>
        </tr>

        <tr>
          <td>
            Asia/Katmandu
          </td>

          <td>
            Asia/Kolkata
          </td>

          <td>
            Asia/Krasnoyarsk
          </td>

          <td>
            Asia/Magadan
          </td>
        </tr>

        <tr>
          <td>
            Asia/Novosibirsk
          </td>

          <td>
            Asia/Rangoon
          </td>

          <td>
            Asia/Seoul
          </td>

          <td>
            Asia/Tashkent
          </td>
        </tr>

        <tr>
          <td>
            Asia/Tehran
          </td>

          <td>
            Asia/Tokyo
          </td>

          <td>
            Asia/Vladivostok
          </td>

          <td>
            Asia/Yakutsk
          </td>
        </tr>

        <tr>
          <td>
            Asia/Yekaterinburg
          </td>

          <td>
            Asia/Yerevan
          </td>

          <td>
            Atlantic/Azores
          </td>

          <td>
            Atlantic/Cape_Verde
          </td>
        </tr>

        <tr>
          <td>
            Atlantic/Stanley
          </td>

          <td>
            Australia/Adelaide
          </td>

          <td>
            Australia/Brisbane
          </td>

          <td>
            Australia/Darwin
          </td>
        </tr>

        <tr>
          <td>
            Australia/Eucla
          </td>

          <td>
            Australia/Hobart
          </td>

          <td>
            Australia/Lord_Howe
          </td>

          <td>
            Australia/Perth
          </td>
        </tr>

        <tr>
          <td>
            Chile/EasterIsland
          </td>

          <td>
            Etc/GMT+10
          </td>

          <td>
            Etc/GMT+8
          </td>

          <td>
            Etc/GMT-11
          </td>
        </tr>

        <tr>
          <td>
            Etc/GMT-12
          </td>

          <td>
            Europe/Amsterdam
          </td>

          <td>
            Europe/Belfast
          </td>

          <td>
            Europe/Belgrade
          </td>
        </tr>

        <tr>
          <td>
            Europe/Brussels
          </td>

          <td>
            Europe/Dublin
          </td>

          <td>
            Europe/Lisbon
          </td>

          <td>
            Europe/London
          </td>
        </tr>

        <tr>
          <td>
            Europe/Minsk
          </td>

          <td>
            Europe/Moscow
          </td>

          <td>
            Pacific/Auckland
          </td>

          <td>
            Pacific/Chatham
          </td>
        </tr>

        <tr>
          <td>
            Pacific/Gambier
          </td>

          <td>
            Pacific/Kiritimati
          </td>

          <td>
            Pacific/Marquesas
          </td>

          <td>
            Pacific/Midway
          </td>
        </tr>

        <tr>
          <td>
            Pacific/Norfolk
          </td>

          <td>
            Pacific/Tongatapu
          </td>

          <td>
            UTC
          </td>

          <td>
 
          </td>
        </tr>
      </tbody>
    </Table>

    See [Set time range on dashboards and charts](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets) for detailed information and examples.
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-metric-format"
    title=" clause"
  >
    For information on querying metric data, see [Query metrics](#query-metrics).
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-compare"
    title=" clause"
  >
    ```
    SELECT ... (SINCE or UNTIL) (integer units) AGO
      COMPARE WITH (integer units) AGO
      ...
    ```

    Use the `COMPARE WITH` clause to compare the values for two different time ranges.

    `COMPARE WITH` requires a `SINCE` or `UNTIL` statement. The time specified by `COMPARE WITH` is relative to the time specified by `SINCE` or `UNTIL`. For example, `SINCE 1 day ago COMPARE WITH 1 day ago` compares yesterday with the day before.

    The time range for the`COMPARE WITH` value is always the same as that specified by `SINCE` or `UNTIL`. For example, `SINCE 2 hours ago COMPARE WITH 4 hours ago` might compare 3:00pm through 5:00pm against 1:00 through 3:00pm.

    `COMPARE WITH` can be formatted as either a line chart or a billboard:

    * With `TIMESERIES`, `COMPARE WITH` creates a line chart with the comparison mapped over time.
    * Without `TIMESERIES`, `COMPARE WITH` generates a billboard with the current value and the percent change from the `COMPARE WITH` value.

    **Example:** This query returns data as a line chart showing the 95th percentile for the past hour compared to the same range one week ago. First as a single value, then as a line chart.

    ```
    SELECT percentile(duration) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO

    SELECT percentile(duration) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timeseries"
    title=" clause"
  >
    ```
    SELECT ...
      TIMESERIES integer units
      ...
    ```

    Use the `TIMESERIES` clause to return data as a time series broken out by a specified period of time. Since `TIMESERIES` is used to trigger certain charts, there is no default value.

    To indicate the time range, use `integer units`. For example:

    * `TIMESERIES 1 minute`
    * `TIMESERIES 30 minutes`
    * `TIMESERIES 1 hour`
    * `TIMESERIES 30 seconds`

    <dt id="set-interval">
      Use a set interval
    </dt>

    <dd>
      The value provided indicates the units used to break out the graph. For example, to present a one-day graph showing 30 minute increments:

      ```
      SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes
      ```
    </dd>

    <dt id="timeseries-auto">
      Use automatically set interval
    </dt>

    <dd>
      `TIMESERIES` can also be set to `AUTO`, which will divide your graph into a reasonable number of divisions. For example, a daily chart will be divided into 30 minute intervals and a weekly chart will be divided into 6 hour intervals.

      This query returns data as a line chart showing the 50th and 90th percentile of client-side transaction time for one week with a data point every 6 hours.

      ```
      SELECT average(duration), percentile(duration, 50, 90)
        FROM PageView SINCE 1 week AGO TIMESERIES AUTO
      ```
    </dd>

    <dt id="timeseries-max">
      Use max interval
    </dt>

    <dd>
      You can set `TIMESERIES` to `MAX`, which will automatically adjust your time window to the maximum number of intervals allowed for a given time period. This allows you to update your time windows without having to manually update your `TIMESERIES` buckets and ensures your time window is being split into the peak number of intervals allowed. The maximum number of `TIMESERIES` buckets that will be returned is 366.

      For example, the following query creates 4-minute intervals, which is the ceiling for a daily chart.

      ```
      SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX
      ```
    </dd>

    <Callout variant="important">
      For functions such as `average( )` or `percentile( )`, a large interval can have a significant smoothing effect on outliers.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="extrapolate"
    title=" clause"
  >
    You can use this clause with these data types:

    * `Transaction`
    * `TransactionError`
    * Custom events reported via APM agent APIs

    The purpose of `EXTRAPOLATE` is to mathematically compensate for the effects of [APM agent sampling of event data](/docs/agents/manage-apm-agents/agent-data/new-relic-events-limits-sampling) so that query results more closely represent the total activity in your system.

    This clause will be useful when a New Relic APM agent reports so many [events](/docs/using-new-relic/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#event-data) that it often passes its [harvest cycle](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#harvest-cycle) reporting limits. When that occurs, the agent begins to sample events.

    When `EXTRAPOLATE` is used in a NRQL query that supports its use, the ratio between the **reported events** and the **total events** is used to extrapolate a close approximation of the total unsampled data. When it is used in a NRQL query that doesn’t support its use or that hasn’t used sampled data, it has no effect.

    <Callout variant="important">
      Note that `EXTRAPOLATE` is most useful for homogenous data (like throughput or error rate). It's not effective when attempting to extrapolate a count of distinct things (like `uniqueCount()` or `uniques()`).
    </Callout>

    This clause works only with NRQL queries that use one of the following [aggregator functions](/docs/insights/nrql-new-relic-query-language/nrql-reference/nrql-syntax-components-functions#functions):

    * apdex
    * average
    * count
    * histogram
    * sum
    * percentage (if function it takes as an argument supports `EXTRAPOLATE`)
    * rate (if function it takes as an argument supports `EXTRAPOLATE`)
    * stddev

    <dt id="extrapolate-example-1">
      Example of extrapolating throughput
    </dt>

    <dd>
      A query that will show the extrapolated throughput of a service named `interestingApplication`.

      ```
      SELECT count(*) FROM Transaction WHERE appName='interestingApplication' 
      SINCE 60 minutes ago EXTRAPOLATE
      ```
    </dd>

    <dt id="extrapolate-example-2">
      Example of extrapolating throughput as a time series
    </dt>

    <dd>
      A query that will show the extrapolated throughput of a service named `interestingApplication` by transaction name, displayed as a time series.

      ```
      SELECT count(*) FROM Transaction WHERE appName='interestingApplication' 
      SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE
      ```
    </dd>
  </Collapser>
</CollapserGroup>

## Query metric data

There are several ways to query metric data using NRQL:

* [Query metric timeslice data](/docs/query-data/nrql-new-relic-query-language/nrql-query-tutorials/query-metric-timeslice-data-nrql), which is reported by New Relic APM, Mobile, Browser
* [Query the `Metric` data type](/docs/data-ingest-apis/get-data-new-relic/metric-api/view-query-you-metric-data), which is reported by some of our integrations and Telemetry SDKs

For more on understanding metrics in New Relic, see [Metric data types](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics).

## Aggregator functions

Use aggregator functions to filter and aggregate data in a NRQL query. Some helpful information about using aggregator functions:

* See the New Relic University tutorials for [Filter queries](http://newrelic.wistia.com/medias/8k4xbxlfwj), [Apdex queries](http://newrelic.wistia.com/medias/46dvx1mkm0), and [Percentile queries](http://newrelic.wistia.com/medias/j3htrz66l0). Or, go to the full online course [Writing NRQL queries](https://learn.newrelic.com/writing-nrql-queries).
* Data type "coercion" is not supported. Read about [available type conversion functions](#type-conversion).
* Cohort analysis functions appear on the New Relic Insights [**Cohort analysis** page](/docs/insights/new-relic-insights/features/cohort-analysis). The cohort functions aggregate transactions into time segments.

Here are the available aggregator functions. The definitions below contain example NRQL queries.

Examples:

```
SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
```

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="func-apdex"
  >
    Use the `apdex` function to return an [Apdex score](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#score) for a single transaction or for all your transactions. The [attribute](/docs/insights/new-relic-insights/decorating-events/insights-attributes) can be any attribute based on response time, such as [`duration`](/docs/insights/insights-data-sources/default-events-attributes/apm-default-event-attributes#txn-duration) or [`backendDuration`](/docs/insights/insights-data-sources/default-events-attributes/browser-default-events-attributes-insights#backend-duration). The `t:` argument defines an [Apdex T](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) threshold in seconds.

    The Apdex score returned by the `apdex( )` function is based only on execution time. It does not account for APM errors. If a transaction includes an error but completes in [Apdex T](/docs/apm/new-relic-apm/getting-started/glossary#apdex_t) or less, that transaction will be rated [satisfying](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#bullet-satisfied) by the `apdex ( )` function.

    <dt id="apdex-cust-attributes">
      Get Apdex for specific customers
    </dt>

    <dd>
      If you have [defined custom attributes](/docs/insights/new-relic-insights/decorating-events/insights-custom-attributes), you can filter based on those attributes. For example, you could monitor the Apdex for a particularly important customer:

      ```
      SELECT apdex(duration, t: 0.4) FROM Transaction
        WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago
      ```
    </dd>

    <dt id="apdex-transaction">
      Get Apdex for specific transaction
    </dt>

    <dd>
      Use the `name` attribute to return a score for a specific transaction, or return an overall Apdex by omitting `name`. This query returns an Apdex score for the **Controller/notes/index** transaction over the last hour:

      ```
      SELECT apdex(duration, t: 0.5) from Transaction
        WHERE name='Controller/notes/index' SINCE 1 hour ago
      ```

      ![crop-apdex-function](./images/screen-apdex-function.png "crop-apdex-function")

      The `apdex` function returns an [Apdex score](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) that measures user satisfaction with your site. Arguments are a response time attribute and an Apdex T threshold in seconds.
    </dd>

    <dt>
      Get overall Apdex for your app
    </dt>

    <dd>
      This example query returns an overall Apdex for the application over the last three weeks:

      ```
      SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-average"
  >
    Use the `average( )` function to return the average value for an attribute. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-buckets"
  >
    Use the `buckets()` function to aggregate data split up by a `FACET` clause into buckets based on ranges. You can bucket by any attribute that is stored as a numerical value in the New Relic database.

    It takes three arguments:

    * Attribute name
    * Maximum value of the sample range. Any outliers will appear in the final bucket.
    * Total number of buckets

    For more information and examples, see [Split your data into buckets](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/segment-your-insights-data-buckets).
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-bucket-percentile"
  >
    The `bucketPercentile( )` function is the NRQL equivalent of the [`histogram_quantile`](https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile) function in Prometheus. It is intended to be used with dimensional metric data. Instead of the quantile, New Relic returns the percentile, which is the quantile \* 100.

    Use the `bucketPercentile( )` function to calculate the quantile from the histogram data in a Prometheus format.

    It takes the bucket name as an argument and reports percentiles along the bucket's boundaries:

    ```
    SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago
    ```

    Optionally, you can add percentile specifications as an argument:

    ```
    SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago
    ```

    Because multiple metrics are used to make up Prometheus histogram data, you must query for specific Prometheus metrics in terms of the associated `<basename>`.

    For example, to compute percentiles from a Prometheus histogram, with the `<basename>` `prometheus_http_request_duration_seconds` using NRQL, use `bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)`. Note how \_bucket is added to the end of the `<basename>` as a suffix.

    See [the Prometheus.io documentation](https://prometheus.io/docs/concepts/metric_types/#histogram) for more information.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cardinality"
  >
    Use the `cardinality( )` function to obtain the number of combinations of all the dimensions (attributes) on a [metric](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics).

    It takes three arguments, all optional:

    * Metric name: if present, `cardinality( )` only computes the metric specified.
    * Include: if present, the include list restricts the cardinality computation to those attributes.
    * Exclude: if present, the exclude list causes those attributes to be ignored in the cardinality computation.

    ```
    SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list})
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-count"
  >
    Use the `count( )` function to return a count of available records. It takes a single argument; either `*`, an attribute, or a constant value. Currently, it follows typical SQL behavior and counts all records that have values for its argument.

    Since `count(*)` does not name a specific attribute, the results will be formatted in the default ["humanize"](/docs/insights/new-relic-insights/managing-dashboards-data/data-formatter-setting-default-formats-numeric-values#format) format.
  </Collapser>

  <Collapser
    className="freq-link"
    id="derivative"
  >
    `derivative()` finds the rate of change for a given dataset. The rate of change is calculated using a least-squares regression to approximate the derivative.

    The `time interval` is the period for which the rate of change is calculated. For example, `derivative(attributeName, 1 minute)` will return the rate of change per minute.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-dimensions"
  >
    Use the `dimensions( )` function to return all the dimensional values on a data type.

    You can explicitly include or exclude specific attributes using the optional arguments:

    * Include: if present, the include list limits `dimensions( )` to those attributes.
    * Exclude: if present, the `dimensions( )` calculation ignores those attributes.

    ```
    FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions()
    ```

    When used with a `FACET` clause, `dimensions( )` produces a unique timeseries for all facets available on the event type, similar to how Prometheus behaves with non-aggregated queries.
  </Collapser>

  <Collapser className="freq-link">
    Use the `earliest( )` function to return the earliest value for an attribute over the specified time range.

    It takes a single argument. Arguments after the first will be ignored.

    If used in conjunction with a `FACET` it will return the most recent value for an attribute for each of the resulting facets.

    <dt>
      Get earliest country per user agent from PageView
    </dt>

    <dd>
      This query returns the earliest country code per each user agent from the PageView event.

      ```
      SELECT earliest(countryCode) FROM PageView FACET userAgentName
      ```
    </dd>
  </Collapser>

  <Collapser className="freq-link">
    ```
    ...WHERE eventType() = 'EventNameHere'...
    ...FACET eventType()...
    ```

    Use the `eventType()` function in a [FACET](#sel-facet) clause to break out results by the selected data type or in a [WHERE](#sel-where) clause to filter results to a specific data type. This is particularly useful for targeting specific data types with the [filter()](#func-filter) and [percentage()](#func-percentage) functions.

    <Callout variant="important">
      In this context, "event type" refers to the types of data you can access with a NRQL query.
    </Callout>

    <dt id="filter-eventtype">
      Use `eventType()` in `filter()` function
    </dt>

    <dd>
      This query returns the percentage of total `TransactionError` results out of the total `Transaction` results. You can use the `eventType()` function to target specific types of data with the filter() function.

      ```
      SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago
      ```
    </dd>

    <dt id="facet-eventtype">
      Use `eventType()` with `FACET`
    </dt>

    <dd>
      This query displays a count of how many records each data type (`Transaction` and `TransactionError`) returns.

      ```
      SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-filter"
  >
    Use the `filter( )` function to limit the results for one of the aggregator functions in your SELECT statement. You can use `filter()` in conjunction with `FACET` or `TIMESERIES`.

    <dt>
      Analyze purchases that used offer codes
    </dt>

    <dd>
      You could use `filter()` to compare the items bought in a set of transactions for those using an offer code versus those who aren't:

      ![screenshot insights filter](./images/screenshot_insights_filter_0_0.png "screenshot insights filter")

      Use the `filter( )` function to limit the results for one of the aggregator functions in your SELECT statement.
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-funnel"
  >
    Use the `funnel()` function to generate a funnel chart. It takes an attribute as its first argument. You then specify steps as [`WHERE`](#sel-where) clauses (with optional [`AS`](#sel-as) clauses for labels) separated by commas.

    For details and examples, see the [funnels documentation](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/funnels-evaluate-data-series-events).
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-get-field"
  >
    Use the `getField()` function to extract a field from [complex metrics](/docs/using-new-relic/data/understand-data/new-relic-data-types).

    It takes the following arguments:

    <Table style={{ width: "500px" }}>
      <thead>
        <tr>
          <th>
            Metric type
          </th>

          <th>
            Supported fields
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `summary`
          </td>

          <td>
            count, total, max, min
          </td>
        </tr>

        <tr>
          <td>
            `gauge`
          </td>

          <td>
            count, total, max, min, latest
          </td>
        </tr>

        <tr>
          <td>
            `distribution`
          </td>

          <td>
            count, total, max, min
          </td>
        </tr>

        <tr>
          <td>
            `counter`
          </td>

          <td>
            count
          </td>
        </tr>
      </tbody>
    </Table>
  </Collapser>

  <dd>
    Examples:

    ```
    SELECT max(getField(mySummary, count)) from Metric
    ```

    ```
    SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10
    ```
  </dd>

  <Collapser
    className="freq-link"
    id="func-histogram"
  >
    Use the `histogram( )` function to generate histograms. It takes three arguments:

    * Attribute name
    * Maximum value of the sample range
    * Total number of buckets

    <dt id="histogram-response-times">
      Histogram of response times from PageView events
    </dt>

    <dd>
      This query results in a histogram of response times ranging up to 10 seconds over 20 buckets.

      ```
      SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
      ```
    </dd>

    <dt id="histogram-prometheus">
      Prometheus histogram buckets
    </dt>

    <dd>
      `histogram( )` accepts Prometheus histogram buckets:

      ```
      SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago
      ```
    </dd>

    <dt id="distribution-metric">
      New Relic distribution metric
    </dt>

    <dd>
      `histogram( )` accepts [Distribution metric](/docs/data-ingest-apis/get-data-new-relic/metric-api/events-metrics-service-create-metrics#limits-rules) as an input:

      ```
      SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="keyset"
  >
    Using `keyset()` will allow you to see all of the attributes for a given data type over a given time range. It takes no arguments. It returns a JSON structure containing groups of string-typed keys, numeric-typed keys, boolean-typed keys, and all keys.

    <dt>
      See all attributes for a data type
    </dt>

    <dd>
      This query returns the attributes found for `PageView` events from the last day:

      ```
      SELECT keyset() FROM PageView SINCE 1 day ago
      ```
    </dd>
  </Collapser>

  <Collapser className="freq-link">
    Use the `latest( )` function to return the most recent value for an attribute over a specified time range.

    It takes a single argument. Arguments after the first will be ignored.

    If used in conjunction with a `FACET` it will return the most recent value for an attribute for each of the resulting facets.

    <dt>
      Get most recent country per user agent from PageView
    </dt>

    <dd>
      This query returns the most recent country code per each user agent from the PageView event.

      ```
      SELECT latest(countryCode) FROM PageView FACET userAgentName
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-max"
  >
    Use the `max( )` function to return the maximum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-median"
  >
    Use the `median( )` function to return an attribute's median, or 50th percentile. For more information about percentile queries, see [percentile()](#func-percentile).

    <Callout variant="tip">
      The `median( )` query is only available when using the [query builder](/docs/chart-builder/use-chart-builder/get-started/introduction-chart-builder).
    </Callout>

    <dt>
      Median query
    </dt>

    <dd>
      This query will generate a line chart for the median value.

      ```
      SELECT median(duration) FROM PageView TIMESERIES AUTO
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-min"
  >
    Use the `min( )` function to return the minimum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentage"
  >
    Use the `percentage( )` function to return the percentage of a target data set that matches some condition.

    The first argument requires an [aggregator function](#functions) against the desired attribute. Use exactly two arguments (arguments after the first two will be ignored). If the attribute is not numeric, this function returns a value of 100%.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentile"
  >
    Use the `percentile( )` function to return an attribute's approximate value at a given percentile. It requires an attribute and can take any number of arguments representing percentile points. The `percentile()` function enables percentiles to displays with up to three digits after the decimal point, providing greater precision. Percentile thresholds may be specified as decimal values, but be aware that for most data sets, percentiles closer than 0.1 from each other will not be resolved.

    ![percentile.png](./images/percentile_0.png "percentile.png")

    Percentile display examples

    Use `TIMESERIES` to generate a line chart with percentiles mapped over time.

    * Omit `TIMESERIES` to generate a billboard and attribute sheet showing aggregate values for the percentiles.

    If no percentiles are listed, the default is the 95th percentile. To return only the 50th percentile value, the median, you can also use [median()](#func-median).

    <dt>
      Basic percentile query
    </dt>

    <dd>
      This query will generate a line chart with lines for the 5th, 50th, and 95th percentile.

      ```
      SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="predictLinear"
  >
    `predictLinear()` is an extension of the `derivative()` function. It uses a similar method of least-squares linear regression to predict the future values for a dataset.

    * The `time interval` is how far the query will look into the future. For example, `predictLinear(attributeName, 1 hour)` is a linear prediction 1 hour into the future of the query time window.
    * Generally, `predictLinear()` is helpful for continuously growing values like disk space, or predictions on large trends.
    * Since `predictLinear()` is a linear regression, familiarity with the dataset being queried helps to ensure accurate long-term predictions.
    * Any dataset which grows exponentially, logarithmically, or by other nonlinear means will likely only be successful in very short-term predictions.
    * New Relic recommends against using `predictLinear` in `TIMESERIES` queries. This is because each bucket will be making an individual prediction based on its relative timeframe within the query, meaning that such queries will not show predictions from the end of the timeseries forward.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-rate"
  >
    Use the `rate( )` function to visualize the frequency or rate of a given query per time interval. For example, you might want to know the number of pageviews per minute over an hour-long period or the count of unique sessions on your site per hour over a day-long period.

    * Use [`TIMESERIES`](#sel-timeseries) to generate a line chart with rates mapped over time.
    * Omit [`TIMESERIES`](#sel-timeseries) to generate a billboard showing a single rate value averaged over time.

    <dt>
      Basic rate query
    </dt>

    <dd>
      This query will generate a line chart showing the rate of throughput for APM transactions per 10 minutes over the past 6 hours.

      ```
      SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago 
      TIMESERIES
      ```
    </dd>
  </Collapser>

  <Collapser
    className="freq-link"
    id="round"
  >
    Use the `round( )` function to return the rounded value of an attribute.

    Optionally `round( )` can take a second argument, `to_nearest`, to round the first argument to the closest multiple of the second one. `to_nearest` can be fractional.

    ```
    SELECT round(n [, to_nearest])
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="stddev"
  >
    Use the `stddev( )` function to return one [standard deviation](https://en.wikipedia.org/wiki/Standard_deviation) for a numeric attribute over the time range specified.  
    It takes a single argument. If the attribute is not numeric, it will return a value of zero.
  </Collapser>

  <Collapser
    className="freq-link"
    id="stdvar"
  >
    Use the `stdvar( )` function to return the [standard variance](https://en.wikipedia.org/wiki/Variance) for a numeric attribute over the time range specified.

    It takes a single argument. If the attribute is not numeric, it will return a value of zero.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-sum"
  >
    Use the `sum( )` function to return the sum recorded values of a numeric attribute over the time range specified.

    It takes a single argument. Arguments after the first will be ignored. If the attribute is not numeric, it will return a value of zero.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniqueCount"
  >
    Use the `uniqueCount( )` function to return the number of unique values recorded for an attribute over the time range specified.

    <Callout variant="tip">
      To optimize query performance, this function returns approximate results for queries that inspect more than 256 unique values.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniques"
    title="​"
  >
    Use the `uniques( )` function to return a list of unique values recorded for an attribute over the time range specified. When used along with the `facet` clause, a list of unique attribute values will be returned per each facet value.

    The `limit` parameter is optional. When it is not provided, the default limit of 1,000 unique attribute values per facet is applied. You may specify a different `limit` value, up to a maximum of 10,000. The `uniques( )` function will return the first set of unique attribute values discovered, until the limit is reached. Therefore, if you have 5,000 unique attribute values in your data set, and the limit is set to 1,000, the operator will return the first 1,000 unique values that it discovers, regardless of their frequency.

    The maximum number of values that can be returned in a query result is the product of the `uniques( )` limit times the `facet` limit. In the following query, the theoretical maximum number of values that can be returned is 5 million (5,000 x 1,000).

    ```
    From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000
    ```

    However, depending on the data set being queried, and the complexity of the query, memory protection limits may prevent a very large query from being executed.
  </Collapser>
</CollapserGroup>

## Type conversion

NRQL does not support "coercion." This means that a float stored as a string is treated as a string and cannot be operated on by functions expecting float values.

You can convert a string with a numeric value or a boolean with a string value to their numeric and boolean types with these functions:

* Use the `numeric()` function to convert a number with a string format to a numeric function. The function can be built into a query that uses math functions on query results or NRQL aggregator functions, such as `average()`.
* Use the `boolean()` function to convert a string value of "true" or "false" to the corresponding boolean value.

## For more help
