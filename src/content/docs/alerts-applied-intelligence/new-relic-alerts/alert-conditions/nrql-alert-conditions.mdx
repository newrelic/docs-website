---
title: NRQL and alert conditions
tags:
  - Alerts and applied intelligence
  - Alerts
  - Alert conditions
translate:
  - jp
  - kr
metaDescription: How to define thresholds that trigger alert notifications based on your NRQL queries.
redirects:
  - /docs/new-relic-alerts-nrql-alerts
  - /docs/new-relic-alerts-alert-nrql-queries
  - /docs/alerts/new-relic-alerts/configuring-alert-policies/alert-conditions-nrql-queries
  - /docs/alerts/new-relic-alerts/configuring-alert-policies/create-alert-conditions-nrql-queries
  - /docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries
  - /docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions
---

You can use [NRQL queries](/docs/insights/new-relic-insights/using-new-relic-query-language/using-nrql) to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts incident is created. For more information on key concepts relating to NRQL alert conditions and streaming alerts, see [Streaming alerts: key terms and concepts](/docs/alerts-applied-intelligence/new-relic-alerts/get-started/streaming-alerts-key-terms-concepts).

## NRQL alert syntax [#syntax]

Here's the basic syntax for creating all NRQL alert conditions.

```sql
SELECT function(attribute)
	FROM Event
	WHERE attribute [comparison] [AND|OR ...]
```

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        **Clause**
      </th>

      <th>
        **Notes**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `SELECT function(attribute)`

        **Required**
      </td>

      <td>
        Supported [functions](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#functions) that return numbers include:

        * `apdex`
        * `average`
        * `count`
        * `latest`
        * `max`
        * `min`
        * `percentage`
        * `percentile`
        * `sum`
        * `uniqueCount`

          <Callout variant="tip">
            If you use the `percentile` aggregator in a faceted alert condition with many facets, this may cause this error:

            `An error occurred while fetching chart data.`

            If you see this error, use `average` instead.
          </Callout>
      </td>
    </tr>

    <tr>
      <td>
        `FROM data type`

        **Required**
      </td>

      <td>
        Only one [data type](/docs/data-apis/understand-data/new-relic-data-types/) can be targeted.

        Supported data types:

        * Events
        * `Metric` (RAW data points will be returned)
      </td>
    </tr>

    <tr>
      <td>
        `WHERE attribute [comparison] [AND|OR ...]`
      </td>

      <td>
        Use the `WHERE` clause to specify a series of one or more conditions. All the [operators](/docs/insights/new-relic-insights/using-new-relic-query-language/nrql-reference#where-operators) are supported.
        It's used for filtering down the data returned in the query.
      </td>
    </tr>

    <tr>
      <td id="facet">
        `FACET` attribute
      </td>

      <td>
        Include an optional `FACET` clause in your NRQL syntax depending on the [threshold type](#threshold-types) (static or anomaly).

        Use the [`FACET`](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-facet) clause to separate your results by attribute and alert on each attribute independently. No `LIMIT` clause is allowed, but all queries will receive the maximum number of facets possible.

        Faceted queries can return a maximum of 5000 values for [static and anomaly](#threshold-types) conditions.

        <Callout variant="important">
          If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values.
        </Callout>
      </td>
    </tr>
  </tbody>
</table>

## Reformatting incompatible NRQL [#reformatting]

Some elements of NRQL used in charts don't make sense in the context of streaming alerts. Here's a list of the most common incompatible elements and suggestions for reformatting a NRQL alert query to achieve the same effect.

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        **Element**
      </th>

      <th>
        **Notes**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `SINCE` and `UNTIL`
      </td>

      <td>
        Example:

        ```sql
        SELECT percentile(largestContentfulPaint, 75) FROM PageViewTiming WHERE (appId = 837807) SINCE yesterday
        ```

        NRQL conditions produce a never-ending stream of windowed query results, so the `SINCE` and `UNTIL` keywords to scope the query to a point in time are not compatible. As a convenience, we automatically strip `SINCE` and `UNTIL` from a query when creating a condition from the context of a chart.
      </td>
    </tr>

    <tr>
      <td>
        `TIMESERIES`
      </td>

      <td>
        In NRQL queries, the `TIMESERIES` clause is used to return data as a time series broken out by a specified period of time.

        For NRQL conditions and if not using sliding window aggregation, the equivalent property to `TIMESERIES` is the data aggregation window duration. If you're using sliding window aggregation, the equivalent property is the value of the sliding window aggregation.
      </td>
    </tr>

    <tr>
      <td>
        `histogram()`
      </td>

      <td>
        The `histogram()` aggregation function is used to generate histograms.

        `histogram()` is not compatible with NRQL alerting: histogram aggregations can not be formatted as a time series. To create an alert from a portion of a histogram (for example, 95th percentile), use the [`percentile()`](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#func-percentile) aggregation function.
      </td>
    </tr>

    <tr>
      <td>
        `bytecountestimate()`, `cardinality()`
      </td>

      <td>
        These functions are not yet supported for NRQL alerting.
      </td>
    </tr>

    <tr>
      <td>
        Multiple aggregation functions
      </td>

      <td>
        Each condition can only target a single aggregated value. To alert on multiple values simultaneously, you'll need to decompose them into individual conditions within the same policy.

        Original query:

        ```sql
        SELECT count(foo), average(bar), max(baz) from Transaction
        ```

        Decomposed:

        ```sql
        SELECT count(foo) from Transaction

        SELECT average(bar) from Transaction

        SELECT max(baz) from Transaction
        ```
      </td>
    </tr>

    <tr>
      <td>
        `COMPARE WITH`
      </td>

      <td>
        The `COMPARE WITH` clause is used to compare the values for two different time ranges. This type of query is incompatible with NRQL alerting. We recommend using an [anomaly alert condition](/docs/alerts-applied-intelligence/applied-intelligence/anomaly-detection/custom-anomalies/) to dynamically detect deviations for a particular signal.
      </td>
    </tr>

    <tr>
      <td>
        `SLIDE BY`
      </td>

      <td>
        The `SLIDE BY` clause supports a feature known as [sliding windows](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-conditions-settings/#sliding-window-aggregation). With sliding windows, `SLIDE BY` data is gathered into "windows" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time.

        You can enable sliding windows in the UI. When creating or editing a condition, go to **Adjust to signal behavior > Data aggregation settings > Use sliding window aggregation**.

        For example to create an alert condition equivalent to
        ```sql
        SELECT count(*) from Transaction TIMESERIES 1 minute SLIDE BY 5 minutes
        ```
        You would use a data aggregation window duration of 5 minutes, with a sliding window aggregation of 1 minute.
        
      </td>
    </tr>

    <tr>
      <td>
        `LIMIT`
      </td>

      <td>
        In NRQL queries, the `LIMIT` clause is used to control the amount of data a query returns, either the maximum number of facet values returned by `FACET` queries or the maximum number of items returned by `SELECT \*` queries.

        `LIMIT` is not compatible with NRQL alerting: evaluation is always performed on the full result set.
      </td>
    </tr>

    <tr>
      <td>
        Subqueries
      </td>

      <td>
        [Subqueries](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql) are not compatible with streaming alerts because subquery execution requires multiple passes through data.
      </td>
    </tr>

    <tr>
      <td>
        Subquery JOINs
      </td>

      <td>
        [Subquery JOINS](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/subquery-joins) are not compatible with streaming alerts because subquery execution requires multiple passes through data.
      </td>
    </tr>
  </tbody>
</table>

## NRQL alert threshold examples [#examples]

Here are some common use cases for NRQL conditions. These queries will work for static and anomaly [condition types](#threshold-types).

<CollapserGroup>
  <Collapser
    id="constrained-alerts"
    title="Alert on specific segments of your data"
  >
    Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the `WHERE` clause to define those conditions.

    ```sql
    SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230)
    ```

    ```sql
    SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%'
    ```
  </Collapser>

  <Collapser
    id="nth-percentile"
    title="Alert on Nth percentile of your data"
  >
    Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query based on the aggregation window duration, percentiles will be calculated for each duration separately.

    ```sql
    SELECT percentile(duration, 95) FROM Transaction
    ```

    ```sql
    SELECT percentile(databaseDuration, 75) FROM Transaction
    ```
  </Collapser>

  <Collapser
    id="max-min-avg"
    title="Alert on max, min, avg of your data"
  >
    Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold.

    ```sql
    SELECT max(duration) FROM Transaction
    ```

    ```sql
    SELECT average(duration) FROM Transaction
    ```
  </Collapser>

  <Collapser
    id="percentage"
    title="Alert on a percentage of your data"
  >
    Create alerts when a proportion of your data goes above or below a certain threshold.

    ```sql
    SELECT percentage(count(*), WHERE duration > 2) FROM Transaction
    ```

    ```sql
    SELECT percentage(count(*), WHERE http.statusCode = '500') FROM Transaction
    ```
  </Collapser>

  <Collapser
    id="apdex"
    title="Alert on Apdex with any T-value"
  >
    Create alerts on [Apdex](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction), applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8.

    ```sql
    SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%'
    ```
  </Collapser>
</CollapserGroup>

## NRQL conditions and query order of operations [#query-order]

By default, the aggregation window duration is 1 minute, but you can change the window to suit your needs. Whatever the aggregation window, New Relic will collect data for that window using the function in the NRQL condition's query. The query is parsed and executed by our systems in the following order:

1. `FROM` clause. Which event type needs to be grabbed?
2. `WHERE` clause. What can be filtered out?
3. `SELECT` clause. What information needs to be returned from the now-filtered data set?

### Example: null value returned [#example-null]

Let's say this is your alert condition query:

```sql
SELECT count(*) FROM SyntheticCheck WHERE monitorName = 'My Cool Monitor' AND result = 'FAILED'
```

If there are no failures for the aggregation window:

1. The system will execute the `FROM` clause by grabbing all `SyntheticCheck` events on your account.
2. Then it will execute the `WHERE` clause to filter through those events by looking only for the ones that match the monitor name and result specified.
3. If there are still events left to scan through after completing the `FROM` and `WHERE` operations, the `SELECT` clause will be executed. If there are no remaining events, the `SELECT` clause will not be executed.

This means that aggregators like `count()` and `uniqueCount()` will never return a zero value. When there is a count of 0, the `SELECT` clause is ignored and no data is returned, resulting in a value of `NULL`.

### Example: zero value returned [#example-zero]

If you have a data source delivering legitimate numeric zeroes, the query will return zero values and not null values.

Let's say this is your alert condition query, and that `MyCoolEvent` is an attribute that can sometimes return a zero value.

```sql
SELECT average(MyCoolAttribute) FROM MyCoolEvent
```

If, in the aggregation window being evaluated, there's at least one instance of `MyCoolEvent` and if the average value of all `MyCoolAttribute` attributes from that window is equal to zero, then a `0` value will be returned. If there are no `MyCoolEvent` events during that minute, then a `NULL` will be returned due to the order of operations.

### Example: null vs. zero value returned [#example-null-zero]

To determine how null values will be handled, adjust the loss of signal and gap filling settings in the [Alert conditions UI](/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/streaming-alerts-key-terms-concepts/#signal-loss).

You can avoid `NULL` values entirely with a query order of operations shortcut. To do this, use a `filter` sub-clause, then include all filter elements within that sub-clause. The main body of the query should include a `WHERE` clause that defines at least one entity so, for any aggregation window where the monitor performs a check, the signal will be tied to that entity. The `SELECT` clause will then run and apply the filter elements to the data returned by the main body of the query, which will return a value of `0` if the filter elements result in no matching data.

Here's an example to alert on `FAILED` results:

```sql
SELECT filter(count(*), WHERE result = 'FAILED') FROM SyntheticCheck WHERE monitorName = 'My Favorite Monitor'
```

In this example, a window with a successful result would return a `0`, allowing the condition's threshold to resolve on its own.

For more information, check out our [blog post](https://discuss.newrelic.com/t/relic-solution-how-can-i-figure-out-when-to-use-gap-filling-and-loss-of-signal/120401) on troubleshooting for zero versus null values.

## Nested aggregation NRQL alerts [#h2-nested-aggregation-nrql-alerts]

[Nested aggregation queries](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query) are a powerful way to query your data. However, they have a few restrictions that are important to note.

<CollapserGroup>
  <Collapser
    id="non-faceted_innermost_query"
    title="Nested queries with a non-faceted innermost query are not currently supported"
  >
    Without a `FACET`, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted.

    ```sql
    SELECT max(cpu) FROM (FROM SystemSample SELECT min(cpuPercent) as 'cpu' FACET hostname) ​​​​
    ```
  </Collapser>

  <Collapser
    id="aggregation_window_size"
    title="Queries at all levels must have the same aggregation window size"
  >
    With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported.

    ```sql
    SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)​​
    ```
  </Collapser>

  <Collapser
    id="signal_loss"
    title="Signal loss is not yet supported for nested queries"
  >
    For more information on signal loss, see [NerdGraph API: Loss of signal and gap filling](/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-loss-signal-gap-filling).
  </Collapser>

  <Collapser
    id="with_metric_format"
    title="Nested queries on metric timeslice data are not currently supported"
  >
    Nested queries for [metric timeslice](/docs/data-apis/understand-data/new-relic-data-types/#timeslice-data) isn't supported. More specifically, these terms are not allowed in the inner query of NRQL alert conditions:
    * `WITH METRIC_FORMAT`
    * `metricTimesliceName`
    * `keyset`, `uniques`, `nativesizeestimate`, or `bytecountestimate` called on the `Metric` type
    * `newrelic.timeslice.value`
    * `apm.service.*`, `apm.browser.*` , `apm.mobile.*`, `apm.key.transaction.*`
  </Collapser>
</CollapserGroup>

## NRQL condition creation tips [#condition-tips]

Here are some tips for creating and using a NRQL condition:

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        Topic
      </th>

      <th>
        Tips
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        Threshold types
      </td>

      <td>
        NRQL conditions support [static and anomaly](#threshold-types) threshold types. 
      </td>
    </tr>

    <tr>
      <td>
        Create a description
      </td>

      <td>
        For NRQL conditions, you can create a custom [description](/docs/alerts/new-relic-alerts/defining-conditions/alert-condition-descriptions) to add to each incident. Descriptions can be enhanced with variable substitution based on metadata in the specific incident.
      </td>
    </tr>

    <tr>
      <td>
        Query results
      </td>

      <td>
        Queries must return a number. The condition evaluates the returned number against the thresholds you've set.
      </td>
    </tr>

    <tr>
      <td>
        Time period
      </td>

      <td>
        NRQL conditions evaluate data based on how it's aggregated, using aggregation windows from 30 seconds to 120 minutes. For best results, we recommend using the event flow or event timer aggregation methods.

        For the cadence aggregation method, the implicit `SINCE ... UNTIL` clause specifying which minute to evaluate is controlled by your [delay/timer](#delay-timer) setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for:

        * Applications that run on multiple hosts.
        * `SyntheticCheck` data: Timeouts can take 3 minutes, so 5 minutes or more is recommended.


        Also, if a query will generate intermittent data, consider using the advanced signal [`slide by`](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-conditions-settings/#sliding-window-aggregation) option.
      </td>
    </tr>

    <tr>
      <td>
        Lost signal threshold
        (loss of signal detection)
      </td>

      <td>
        You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that incidents for sporadic data, such as error counts, are closed when no signal is coming in.
      </td>
    </tr>

    <tr>
      <td>
        Advanced signal settings
      </td>

      <td>
        These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window duration, the delay/timer, and an option for filling data gaps. For more on using these, see [Advanced signal settings](#advanced-signal).
      </td>
    </tr>

    <tr>
      <td>
        Condition settings
      </td>

      <td>
        Use the **Condition settings** to:

        * Create a concise, descriptive [condition name](/docs/alerts/new-relic-alerts/configuring-alert-policies/define-alert-conditions#rename-condition).
        * Provide a [custom incident description for the condition](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/alert-custom-incident-descriptions) that will be included in incidents and notifications.
        * Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom incident description.
      </td>
    </tr>

    <tr>
      <td>
        Limits on conditions
      </td>

      <td>
        See the [maximum values](/docs/alerts/new-relic-alerts/getting-started/minimum-maximum-values).
      </td>
    </tr>

    <tr>
      <td>
        Health status
      </td>

      <td>
        In order for a NRQL alert condition [health status display](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/view-entity-health-status-find-entities-without-alert-conditions) to function properly, the query must be scoped to a single entity. To do this, either use a WHERE clause (for example, `WHERE appName = 'MyFavoriteApp'`) or use a FACET clause to scope each signal to a single entity (for example, `FACET hostname` or `FACET appName`).
      </td>
    </tr>

    <tr>
      <td>
        Examples
      </td>

      <td>
        For more information, see:

        * [Expected NRQL syntax](#syntax)
        * [Examples of NRQL condition queries](#examples)
      </td>
    </tr>
  </tbody>
</table>

## Managing tags on conditions [#condition-edit]

When you edit an existing NRQL condition, you have the option to add or remove tags associated with the condition entity. To do this, click the **Manage tags** button below the condition name. In the menu that pops up, add or delete a tag.

## Condition edits can reset condition evaluation [#evaluation-resets]

When you edit NRQL alert conditions in some specific ways (detailed below), their evaluations are reset, meaning that any evaluation up until that point is lost, and the evaluation starts over from that point. The two ways this will affect you're:

* For "for at least x minutes" thresholds: because the evaluation window has been reset, there will be a delay of at least x minutes before any incidents can be reported.
* For [anomaly conditions](/docs/alerts-applied-intelligence/applied-intelligence/anomaly-detection/custom-anomalies/): the condition starts over again and all anomaly learning is lost.

The following actions cause an evaluation reset for NRQL conditions:

* Changing the query
* Changing the aggregation window, aggregation method, or aggregation delay/timer setting
* Changing the "close incidents on signal loss" setting
* Changing any gap fill settings
* Changing the anomaly direction (if applicable)- higher, lower, or higher/lower
* Change the threshold value, threshold window, or threshold operator
* Change the slide-by interval (on [sliding windows aggregation](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-conditions-settings/#sliding-window-aggregation) conditions only)

The following actions (along with any other actions not covered in the above list) will **not** reset the evaluation:

* Changing the loss of signal time window (expiration duration)
* Changing the time function (switching "for at least" to "at least once in," or vice-versa)
* Toggling the "open incident on signal loss" setting

## Alert threshold types [#threshold-types]

When you create a NRQL alert, you can choose from different types of conditions:

<table>
  <thead>
    <tr>
      <th style={{ width: "150px" }}>
        NRQL alert condition types
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        Static
      </td>

      <td>
        This is the simplest type of NRQL condition. It allows you to create a condition based on a NRQL query that returns a numeric value.

        Optional: Include a `FACET` clause.
      </td>
    </tr>

    <tr>
      <td>
        [Anomaly](/docs/alerts-applied-intelligence/applied-intelligence/anomaly-detection/custom-anomalies/)
      </td>

      <td>
        Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type,
        including the optional `FACET` clause.
      </td>
    </tr>
  </tbody>
</table>

