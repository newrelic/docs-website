---
title: Workflows variables
tags:
  - Alerts and Applied Intelligence
  - Applied intelligence
  - workflows
  - Enrichments
  - Issues
metaDescription: For Applied Intelligence, an explanations of the variables used for workflows. 
---

An explanation of the variables used for [incident workflows](/docs/alerts-applied-intelligence/applied-intelligence/incident-workflows/incident-workflows).

## Variables [#variables]

Use the variables from the issue entity to select the kind of issues you would like to send as well as the message template which appear on the notifications. 

Here's a comprehensive list of variables:

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
      Key (First word will be used for grouping)
      </th>
      <th>
      Display Name (First word will be used for grouping)
      </th>
      <th>
      Description
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>accumulations.conditionName</td>
      <td>Alert Condition Names</td>
      <td>New Relic violated condition </td>
    </tr>
    <tr>
      <td>accumulations.origin</td>
      <td>Issue Origin</td>
      <td> New Relic or third party source that created the issue</td>
    </tr>
    <tr>
      <td>accumulations.policyName</td>
      <td>Alert Policy Names</td>
      <td>Incident detection policy name that generated the violation</td>
    </tr>
    <tr>
      <td>accumulations.source</td>
      <td>Issue Source</td>
      <td>The target system reported by the source</td>
    </tr>
    <tr>
      <td>activatedAt</td>
      <td>Issue Activated At</td>
      <td>Timestamp of Issue activation</td>
    </tr>
    <tr>
      <td>annotations.description</td>
      <td>Issue Description</td>
      <td>List of all incident descriptions</td>
    </tr>
    <tr>
      <td>annotations.title</td>
      <td>Issue Title</td>
      <td>List of all incident titles</td>
    </tr>
    <tr>
      <td>closedAt</td>
      <td>Issue ClosedAt</td>
      <td>Timestamp of Issue closure, null if the issue is not closed</td>
    </tr>
    <tr>
      <td>createdAt</td>
      <td>Issue CreatedAt</td>
      <td>Timestamp of Issue creation</td>
    </tr>
    <tr>
      <td>entitiesData.entities</td>
      <td>Impacted Entities Data</td>
      <td>A list of objects describing the impacted entity name, id, type and kind</td>
    </tr>
    <tr>
      <td>entitiesData.ids</td>
      <td>Impacted Entities IDs</td>
      <td>A set of all impacted entity ids</td>
    </tr>
    <tr>
      <td>entitiesData.kinds</td>
      <td>Impacted Entities Kinds</td>
      <td>A set of all impacted entity kinds</td>
    </tr>
    <tr>
      <td>entitiesData.names</td>
      <td>Impacted Entities Names</td>
      <td>A set of all impacted entity names</td>
    </tr>
    <tr>
      <td>entitiesData.types</td>
      <td>Impacted Entities Types</td>
      <td>A set of all impacted entity types</td>
    </tr>
    <tr>
      <td>incidentIds</td>
      <td>Incident IDs</td>
      <td>A list of all the issue's aggregated incidents</td>
    </tr>
    <tr>
      <td>isCorrelated</td>
      <td>Issue Is Correlated</td>
      <td>Is Issue correlated</td>
    </tr>
    <tr>
      <td>issue.pageUrl</td>
      <td>Issue Page URL</td>
      <td>A direct link to the relevant issue Page</td>
    </tr>
    <tr>
      <td>issueId</td>
      <td>Issue ID</td>
      <td>The unique id of the issue</td>
    </tr>
    <tr>
      <td>labels.accountIds</td>
      <td>Issue Environment Associated Account ID</td>
      <td>New Relic AI's enviroinments associated account ID</td>
    </tr>
    <tr>
      <td>labels.aggregationKeys</td>
      <td>Labels Alerts Aggregation Key</td>
      <td>New Relic Incident detection original incident ID</td>
    </tr>
    <tr>
      <td>labels.originalAccountIds</td>
      <td>Labels Account IDs</td>
      <td>Incident detection policy's account ID</td>
    </tr>
    <tr>
      <td>labels.policyIds</td>
      <td>Labels Alert Policy IDs</td>
      <td>Incident detection policy IDs that generated the violation</td>
    </tr>
    <tr>
      <td>priority</td>
      <td>Issue Priority</td>
      <td>Issue's priority level</td>
    </tr>
    <tr>
      <td>priorityText</td>
      <td>Issue Priority text</td>
      <td>Issue priority in lower case</td>
    </tr>
    <tr>
      <td>state</td>
      <td>Issue State</td>
      <td>Issue's current state</td>
    </tr>
    <tr>
      <td>stateText</td>
      <td>Issue state text</td>
      <td>Issue's state in lower case</td>
    </tr>
    <tr>
      <td>status</td>
      <td>Issue Status</td>
      <td>Issue's current status</td>
    </tr>
    <tr>
      <td>totalIncidents</td>
      <td>Incident Count</td>
      <td>The number of incidents that are aggregated or correlated in the issue</td>
    </tr>
    <tr>
      <td>triggeredAt</td>
      <td>Issue Triggered At</td>
      <td>Timestamp of Issue notification triggered</td>
    </tr>
    <tr>
      <td>triggerEvent</td>
      <td>Issue Notification Trigger Event</td>
      <td>The notification trigger event</td>
    </tr>
    <tr>
      <td>updatedAt</td>
      <td>Issue Updated At</td>
      <td>Timestamp of Issue last updated</td>
    </tr>
    <tr>
      <td>workflowName</td>
      <td>Workflow Name</td>
      <td>The name of the workflow that was triggered</td>
    </tr>       
  </tbody>
</table>

## Workflow data enrichment examples [#enrichment-examples]

To get information about the entity that violated a condition, you can use custom variables as part of the `where` statement of the query. For example, to get the state of the EC2 instance use:

```
SELECT latest(ec2State) FROM ComputeSample where provider = 'Ec2Instance' where entityName in <var>{{entitiesData.names}}</var>
```

This query returns a single value (for example, `stopped`), as the query only uses a single field. The variable `entitiesData.names` is a list of identifiers for the entities. You can use any other entity properties in the same way.


You can use custom variables to enrich your workflow data queries in different ways:

<CollapserGroup>
  <Collapser
    id="application-drop"
    title="Query for when application traffic drops"
  >
    There are times when you want to know when traffic to your application drops. You can use the &#x7B;&#x7B;entitiesData.names}} variable in place of your application's name.

    ```
    SELECT count(*) FROM Transaction WHERE appName in {{entitiesData.names}} since 10 minutes ago
    ```
  </Collapser>
  
  <Collapser
    id="non-web-transactions-time"
    title="Non-web transactions time"
  >
    Average time the impacted entities spend processing requests/transactions, broken down by process type

    ```
    SELECT average(apm.service.overview.other) * 1000 FROM Metric WHERE appName IN {{entitiesData.names}} FACET `segmentName` TIMESERIES 
    ```
  </Collapser>
  
   <Collapser
    id="throughput"
    title="Throughput"
  >
    Number of requests per minute the impacted enitities process

    ```
     SELECT rate(count(apm.service.transaction.duration), 1 minute) as 'Non-web throughput' FROM Metric WHERE (appName IN {{entitiesData.names}}) AND (transactionType = 'Other') TIMESERIES 
    ```
  </Collapser>
  
     <Collapser
    id="error-rate"
    title="Error rate"
  >
    Ratio of errors to the total number of requests processes by the impacted entities

    ```
     SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) as 'Non-web errors' FROM Metric WHERE (appName IN {{entitiesData.names}}) AND (transactionType = 'Other') TIMESERIES 
    ```
  </Collapser>

  <Collapser
    id="transaction-failures"
    title="Query for transaction failures"
  >
    There are times when you want to know when your application transactions have failed. This query shows the latest HTTP status code responses filtered by the <var>&#x7B;&#x7B;entitiesData.names}}</var> variable that violated your alert policy threshold.

    ```
    From Transaction select latest(httpResponseCode), average(duration) where appName in {{entitiesData.names}}
    ```
  </Collapser>

  <Collapser
    id="kubernetes-consumption"
    title="Query for Kubernetes consumption overview"
  >
    Use a query like this to get the number of entities and their ingest times within a Kubernetes pod. By identifying what entities have large ingest times, you can begin to address that issue and find a potential remedy.

    ```
    SELECT uniqueCount(displayName), sum(nr.ingestTimeMs) from K8sServiceSample where entityName = {{entitiesData.names}} since 1 hour ago.
    ```
  </Collapser>
</CollapserGroup>
