---
title: NRQL alert conditions tips
tags:
  - Alerts
  - Alert conditions
translate:
  - jp
  - kr
metaDescription: How to define thresholds that trigger alert notifications based on your NRQL queries.
redirects:
  - /docs/new-relic-alerts-nrql-alerts
  - /docs/new-relic-alerts-alert-nrql-queries
  - /docs/alerts/new-relic-alerts/configuring-alert-policies/alert-conditions-nrql-queries
  - /docs/alerts/new-relic-alerts/configuring-alert-policies/create-alert-conditions-nrql-queries
  - /docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries
  - /docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions
  - /docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/queries-nrql_screenshot-full_nrql-alert-conditions
  - /docs/alerts/create-alert/create-alert-condition/create-nrql-alert-conditions
freshnessValidatedDate: 2024-10-28
---

We recommend the use of [New Relic Query Language (NRQL)](/docs/nrql/get-started/introduction-nrql-new-relics-query-language/) to create alert conditions. This doc will guide you through formatting and configuring your NRQL alert conditions to maximize efficiency and reduce noise. If you've just started with New Relic, or you haven't created an alert condition yet, we recommend starting with [Alert conditions](/docs/alerts/alert-conditions/create-alert-conditions).

No matter where you begin creating an alert condition, NRQL is the building block upon which you can define your signal and set your thresholds.

## NRQL alert syntax [#syntax]

Here's the basic syntax for creating all NRQL alert conditions.

```sql
SELECT function(attribute)
FROM Event
WHERE attribute [comparison] [AND|OR ...]
```

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        <DNT>
          **Clause**
        </DNT>
      </th>

      <th>
        <DNT>
          **Notes**
        </DNT>
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `SELECT function(attribute)`

        <DNT>
          **Required**
        </DNT>
      </td>

      <td>
        Supported [functions](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#functions) that return numbers include:

        * `apdex`
        * `average`
        * `count`
        * `latest`
        * `max`
        * `min`
        * `percentage`
        * `percentile`
        * `sum`
        * `uniqueCount`

          <Callout variant="tip">
            If you use the `percentile` aggregator in a faceted alert condition with many facets, this may cause this error:

            `An error occurred while fetching chart data.`

            If you see this error, use `average` instead.
          </Callout>
      </td>
    </tr>

    <tr>
      <td>
        `FROM data type`

        <DNT>
          **Required**
        </DNT>
      </td>

      <td>
        Multiple [data types](/docs/data-apis/understand-data/new-relic-data-types/) can be targeted.

        Supported data types:

        * Events
        * `Metric` (RAW data points will be returned)
      </td>
    </tr>

    <tr>
      <td>
        `WHERE attribute [comparison] [AND|OR ...]`
      </td>

      <td>
        Use the `WHERE` clause to specify a series of one or more conditions. All the [operators](/docs/nrql/nrql-syntax-clauses-functions/#sel-where) are supported. It's used for filtering down the data returned in the query.
      </td>
    </tr>

    <tr>
      <td id="facet">
        `FACET` attribute
      </td>

      <td>
        Include an optional `FACET` clause in your NRQL syntax depending on the [threshold type](#threshold-types) (static or anomaly).

        Use the [`FACET`](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-facet) clause to separate your results by attribute and alert on each attribute independently. No `LIMIT` clause is allowed, but all queries will receive the maximum number of facets possible.

        Faceted queries can return a maximum of 5000 values for [static and anomaly](#threshold-types) conditions.

        <Callout variant="important">
          If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values.
        </Callout>
      </td>
    </tr>
  </tbody>
</table>

## Reformatting incompatible NRQL [#reformatting]

Some elements of NRQL used in charts don't make sense in the context of streaming alerts. Here's a list of the most common incompatible elements and suggestions for reformatting a NRQL alert query to achieve the same effect.

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        <DNT>
          **Element**
        </DNT>
      </th>

      <th>
        <DNT>
          **Notes**
        </DNT>
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `SINCE` and `UNTIL`
      </td>

      <td>
        Example:

        ```sql
        SELECT percentile(largestContentfulPaint, 75) 
        FROM PageViewTiming 
        WHERE (appId = 837807) SINCE yesterday
        ```

        NRQL conditions produce a never-ending stream of windowed query results, so the `SINCE` and `UNTIL` keywords to scope the query to a point in time are not compatible. As a convenience, we automatically strip `SINCE` and `UNTIL` from a query when creating a condition from the context of a chart.
      </td>
    </tr>

    <tr>
      <td>
        `TIMESERIES`
      </td>

      <td>
        In NRQL queries, the `TIMESERIES` clause is used to return data as a time series broken out by a specified period of time.

        For NRQL conditions and if not using sliding window aggregation, the equivalent property to `TIMESERIES` is the data aggregation window duration. If you're using sliding window aggregation, the equivalent property is the value of the sliding window aggregation.
      </td>
    </tr>

    <tr>
      <td>
        `histogram()`
      </td>

      <td>
        The `histogram()` aggregation function is used to generate histograms.

        `histogram()` isn't compatible with NRQL alerting: histogram aggregations can not be formatted as a time series. To create an alert from a portion of a histogram (for example, 95th percentile), use the [`percentile()`](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#func-percentile) aggregation function.
      </td>
    </tr>

    <tr>
      <td>
        `bytecountestimate()`, `cardinality()`
      </td>

      <td>
        These functions are not yet supported for NRQL alerting.
      </td>
    </tr>

    <tr>
      <td>
        Multiple aggregation functions
      </td>

      <td>
        Each condition can only target a single aggregated value. To alert on multiple values simultaneously, you'll need to decompose them into individual conditions within the same policy.

        Original query:

        ```sql
        SELECT count(foo), average(bar), max(baz) 
        FROM Transaction
        ```

        Decomposed:

        ```sql
        SELECT count(foo) FROM Transaction

        SELECT average(bar) FROM Transaction

        SELECT max(baz) FROM Transaction
        ```
      </td>
    </tr>

    <tr>
      <td>
        `COMPARE WITH`
      </td>

      <td>
        The `COMPARE WITH` clause is used to compare the values for two different time ranges. This type of query is incompatible with NRQL alerting. We recommend using an [anomaly alert condition](/docs/alerts-applied-intelligence/applied-intelligence/anomaly-detection/custom-anomalies/) to dynamically detect deviations for a particular signal.
      </td>
    </tr>

    <tr>
      <td>
        `SLIDE BY`
      </td>

      <td>
        The `SLIDE BY` clause supports a feature known as [sliding windows](/docs/alerts/alert-conditions/create-alert-conditions/#sliding-window). With sliding windows, `SLIDE BY` data is gathered into "windows" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time.

        This example creates an alert condition with a data aggregation window duration of 5 minutes and a sliding window aggregation of 1 minute:

        ```sql
        SELECT count(*) 
        FROM Transaction 
        TIMESERIES 1 minute SLIDE BY 5 minutes
        ```
      </td>
    </tr>

    <tr>
      <td>
        `LIMIT`
      </td>

      <td>
        In NRQL queries, the `LIMIT` clause is used to control the amount of data a query returns, either the maximum number of facet values returned by `FACET` queries or the maximum number of items returned by `SELECT *` queries.

        `LIMIT` isn't compatible with NRQL alerting: evaluation is always performed on the full result set.
      </td>
    </tr>

    <tr>
      <td>
        Subqueries
      </td>

      <td>
        [Subqueries](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql) are not compatible with streaming <InlinePopover type="alerts"/> because subquery execution requires multiple passes through data.
      </td>
    </tr>

    <tr>
      <td>
        Subquery JOINs
      </td>

      <td>
        [Subquery JOINS](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/subquery-joins) are not compatible with streaming alerts because subquery execution requires multiple passes through data.
      </td>
    </tr>
  </tbody>
</table>

## NRQL alert threshold examples [#examples]

Here are some common use cases for NRQL conditions. These queries will work for static and anomaly [condition types](#threshold-types).

<CollapserGroup>
  <Collapser
    id="constrained-alerts"
    title="Alert on specific segments of your data"
  >
    Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the `WHERE` clause to define those conditions.

    ```sql
    SELECT average(duration) 
    FROM Transaction 
    WHERE account_id IN (91290, 102021, 20230)
    ```

    ```sql
    SELECT percentile(duration, 95) 
    FROM Transaction 
    WHERE name LIKE 'Controller/checkout/%'
    ```
  </Collapser>

  <Collapser
    id="nth-percentile"
    title="Alert on Nth percentile of your data"
  >
    Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query based on the aggregation window duration, percentiles will be calculated for each duration separately.

    ```sql
    SELECT percentile(duration, 95) 
    FROM Transaction
    ```

    ```sql
    SELECT percentile(databaseDuration, 75) 
    FROM Transaction
    ```
  </Collapser>

  <Collapser
    id="max-min-avg"
    title="Alert on max, min, avg of your data"
  >
    Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold.

    ```sql
    SELECT max(duration) 
    FROM Transaction
    ```

    ```sql
    SELECT min(duration) 
    FROM Transaction
    ```

    ```sql
    SELECT average(duration) 
    FROM Transaction
    ```
  </Collapser>

  <Collapser
    id="percentage"
    title="Alert on a percentage of your data"
  >
    Create alerts when a proportion of your data goes above or below a certain threshold.

    ```sql
    SELECT percentage(count(*), WHERE duration > 2) 
    FROM Transaction
    ```

    ```sql
    SELECT percentage(count(*), WHERE http.statusCode = '500') 
    FROM Transaction
    ```
  </Collapser>

  <Collapser
    id="apdex"
    title="Alert on Apdex with any T-value"
  >
    Create alerts on [Apdex](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction), applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8.

    ```sql
    SELECT apdex(duration, t:0.5) 
    FROM Transaction 
    WHERE appName LIKE '%prod%'
    ```
  </Collapser>
</CollapserGroup>

## NRQL conditions and query order of operations [#query-order]

By default, the aggregation window duration is 1 minute, but you can change the window to suit your needs. Whatever the aggregation window, New Relic will collect data for that window using the function in the NRQL condition's query.
Our systems parse and execute the query following this order:

1. `FROM` clause. What type of event do we need to capture?
2. `WHERE` clause. What can you filter out?
3. `SELECT` clause. What information do we need to return from the now-filtered data set?

### Example: Null value returned [#example-null]

Let's say this is your alert condition query:

```sql
SELECT count(*) 
FROM SyntheticCheck 
WHERE monitorName = 'My Cool Monitor' AND result = 'FAILED'
```

If there are no failures for the aggregation window:

1. The system will execute the `FROM` clause by grabbing all `SyntheticCheck` events on your account.
2. Then it will execute the `WHERE` clause to filter through those events by looking only for the ones that match the name of the monitor and result specified.
3. If events remain after the `FROM` and `WHERE` operations, the system executes the `SELECT` clause. If no events remain, the `SELECT` clause isn't executed.

This means that aggregators like `count()` and `uniqueCount()` will never return a zero value. When there is a count of 0, the system ignores the `SELECT` clause and no data is returned, resulting in a value of `NULL`.

### Example: Zero value returned [#example-zero]

If you've a data source delivering legitimate numeric zeroes, the query will return zero values and not null values.

Let's say this is your alert condition query, and that `MyCoolEvent` is an attribute that can sometimes return a zero value.

```sql
SELECT average(MyCoolAttribute) 
FROM MyCoolEvent
```

If, in the aggregation window, there's at least one instance of `MyCoolEvent` and if the average value of all `MyCoolAttribute` attributes from that window is equal to zero, you'll get a `0` value. If there are no `MyCoolEvent` events during that minute, then you'll get `NULL` due to the order of operations.

### Example: Null vs. zero value returned [#example-null-zero]

To find how we handle `NULL` values, adjust the [loss of signal](/docs/alerts/alert-conditions/create-alert-conditions/#lost-signal) and [gap filling](/docs/alerts/alert-conditions/create-alert-conditions/#gap-filling-strategy) settings in the alert conditions.

You can avoid `NULL` values entirely with a query order of operations shortcut. To do this, use a `filter` sub-clause, then include all filter elements within that sub-clause. The main body of the query should include a `WHERE` clause that defines at least one entity so, for any aggregation window where the system performs a check, the signal will have an association with that entity. The `SELECT` clause will then run and apply the filter elements to the data returned by the main body of the query. It will return a value of `0` if the filter elements result in no matching data.

Here's an example to alert on `FAILED` results:

```sql
SELECT filter(count(*), WHERE result = 'FAILED') 
FROM SyntheticCheck 
WHERE monitorName = 'My Favorite Monitor'
```

In this example, a window with a successful result would return a `0`, allowing the condition's threshold to resolve on its own.

For more information, check out our [blog post](https://discuss.newrelic.com/t/relic-solution-how-can-i-figure-out-when-to-use-gap-filling-and-loss-of-signal/120401) on troubleshooting for zero versus null values.

## Nested aggregation NRQL alerts [#h2-nested-aggregation-nrql-alerts]

[Nested aggregation queries](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query) are a powerful way to query your data. However, they have a few restrictions that are important to note.

<CollapserGroup>
  <Collapser
    id="non-faceted_innermost_query"
    title="Nested queries with a non-faceted innermost query aren't currently supported"
  >
    Without a `FACET`, the inner query produces a single result, giving the outer query nothing to add. If you're using a nested query, make sure you facet your inner query.

    ```sql
    SELECT max(cpu) 
    FROM 
      (
        SELECT min(cpuPercent) AS 'cpu' 
        FROM SystemSample 
        FACET hostname
      ) 
    ```
  </Collapser>

  <Collapser
    id="aggregation_window_size"
    title="Queries at all levels must have the same aggregation window size"
  >
    With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this isn't currently supported.

    ```sql
    SELECT max(cpu) 
    FROM 
      (
        SELECT min(cpuTime) AS cpu TIMESERIES 30 seconds
        FROM Event 
      )
        ```
  </Collapser>

  <Collapser
    id="signal_loss"
    title="Signal loss isn't yet supported for nested queries"
  >
    For more information on signal loss, see [NerdGraph API: Loss of signal and gap filling](/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-loss-signal-gap-filling).
  </Collapser>

  <Collapser
    id="with_metric_format"
    title="Nested queries on metric timeslice data are not currently supported"
  >
    Nested queries for [metric timeslice](/docs/data-apis/understand-data/new-relic-data-types/#timeslice-data) isn't supported. More specifically, these terms are not allowed in the inner query of NRQL alert conditions:

    * `WITH METRIC_FORMAT`
    * `metricTimesliceName`
    * `keyset`, `uniques`, `nativesizeestimate`, or `bytecountestimate` called on the `Metric` type
    * `newrelic.timeslice.value`
    * `apm.service.*`, `apm.browser.*` , `apm.mobile.*`, `apm.key.transaction.*`
  </Collapser>
</CollapserGroup>

## NRQL condition creation tips [#condition-tips]

Here are some tips for creating and using a NRQL condition:

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        Topic
      </th>

      <th>
        Tips
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        Condition types
      </td>

      <td>
        NRQL condition types include [static and anomaly](#threshold-types).
      </td>
    </tr>

    <tr>
      <td>
        Create a description
      </td>

      <td>
        For NRQL conditions, you can create a custom [description](/docs/alerts/new-relic-alerts/defining-conditions/alert-condition-descriptions) to add to each incident. Descriptions can be enhanced with variable substitution based on metadata in the specific incident.
      </td>
    </tr>

    <tr>
      <td>
        Query results
      </td>

      <td>
        Queries must return a number. The condition evaluates the returned number against the thresholds you've set.
      </td>
    </tr>

    <tr>
      <td>
        Time period
      </td>

      <td>
        NRQL conditions evaluate data based on how it's aggregated, using aggregation windows from 30 seconds to 120 minutes, in increments of 15 seconds. For best results, we recommend using the event flow or event timer aggregation methods.

        For the cadence aggregation method, the implicit `SINCE ... UNTIL` clause specifying which minute to evaluate is controlled by your [delay and timer](#delay-timer) setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for:

        * Applications that run on multiple hosts.
        * `SyntheticCheck` data: Timeouts can take 3 minutes, so 5 minutes or more is recommended.

        Also, if a query will generate intermittent data, consider using the advanced signal [`slide by`](#sliding-window-aggregation) option.
      </td>
    </tr>

    <tr>
      <td>
        Lost signal threshold
        (loss of signal detection)
      </td>

      <td>
        You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that incidents for sporadic data, such as error counts, are closed when no signal is coming in.
      </td>
    </tr>

    <tr>
      <td>
        Advanced signal settings
      </td>

      <td>
        These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window duration, the delay and timer, and an option for filling data gaps. For more on using these, see [Advanced signal settings](#advanced-signal).
      </td>
    </tr>

    <tr>
      <td>
        Add details
      </td>

      <td>
        Use the <DNT>**Add details**</DNT> step to:

        * Create a concise, descriptive alert condition name. We recommend giving it a meaningful name that will help you locate your condition easily.
        * Provide a [custom incident description](/docs/alerts/alert-conditions/customize-incidents) because it will be included in incidents and notifications.
        * Add the [runbook URL](/docs/alerts/alert-conditions/provide-runbook) to include your organization's procedures for handling incidents. You may also add this information to the custom incident description.
      </td>
    </tr>

    <tr>
      <td>
        Limits on conditions
      </td>

      <td>
        See the [Alerting rules and limits](/docs/alerts/admin/rules-limits-alerts).
      </td>
    </tr>

    <tr>
      <td>
        Health status
      </td>

      <td>
        In order for a NRQL alert condition [health status display](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/view-entity-health-status-find-entities-without-alert-conditions) to function properly, the query must be scoped to a single entity. To do this, either use a `WHERE` clause (for example, `WHERE appName = 'MyFavoriteApp'`) or use a `FACET` clause to scope each signal to a single entity (for example, `FACET hostname` or `FACET appName`).
      </td>
    </tr>

    <tr>
      <td>
        Examples
      </td>

      <td>
        For more information, see:

        * [Expected NRQL syntax](#syntax)
        * [Examples of NRQL condition queries](#examples)
      </td>
    </tr>
  </tbody>
</table>


## Condition edits can reset condition evaluation [#evaluation-resets]

When you edit NRQL alert conditions in some specific ways (detailed below), their evaluations are reset. This means that you'll lost any evaluation up until that point, and the evaluation starts over from that point. These are the two ways this will affect you:

* For "for at least x minutes" thresholds: Because the evaluation window has been reset, there will be a delay of at least x minutes before the report of any incidents.
* For [anomaly conditions](/docs/alerts-applied-intelligence/applied-intelligence/anomaly-detection/custom-anomalies/): The condition starts over again and you'll lost all anomaly learning.

The following actions cause an evaluation reset for NRQL conditions:

* Changing the query
* Changing the aggregation window, aggregation method, or aggregation delay and timer setting
* Changing the "close incidents on signal loss" setting
* Changing any gap fill settings
* Changing the anomaly direction (if applicable)- higher, lower, or higher/lower
* Change the threshold value, threshold window, or threshold operator
* Change the slide-by interval (on [sliding windows aggregation](/docs/alerts/alert-conditions/create-alert-conditions/#sliding-window) conditions only)

The following actions (along with any other actions not covered in the above list) will **not** reset the evaluation:

* Changing the loss of signal time window (expiration duration)
* Changing the time function (switching "for at least" to "at least once in," or vice-versa)
* Toggling the "open incident on signal loss" setting

## Alert condition types [#threshold-types]

When you create a NRQL alert, you can choose from different types of conditions:

<table>
  <thead>
    <tr>
      <th style={{ width: "150px" }}>
        NRQL alert condition types
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        Static
      </td>

      <td>
        This is the simplest type of NRQL condition. It allows you to create a condition based on a NRQL query that returns a numeric value.

        Optional: Include a `FACET` clause.
      </td>
    </tr>

    <tr>
      <td>
        [Anomaly](/docs/alerts-applied-intelligence/applied-intelligence/anomaly-detection/custom-anomalies/)
        (Dynamic anomaly)
      </td>

      <td>
        Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type,
        including the optional `FACET` clause.
      </td>
    </tr>
  </tbody>
</table>
