---
title: "NerdGraph tutorial: Manage scripted API monitors"
tags:
  - Synthetics
  - APIs
  - NerdGraph
  - Examples
metaDescription: How to use New Relic NerdGraph API to create and update scripted API monitors for synthetic monitoring.
freshnessValidatedDate: never
---

New Relic allows you use NerdGraph to create [scripted API monitors](/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests). Scripted API monitors execute custom JavaScript code to test APIs and backend services without a browser, making HTTP requests and validating responses programmatically. This tutorial provides examples of how to use the NerdGraph API to automate the creation of scripted API monitors.

## Create a scripted API monitor [#create-scripted-api]

You can create a scripted API monitor using the `syntheticsCreateScriptApiMonitor` mutation. This mutation allows you to set up custom API testing that executes your JavaScript code to validate API endpoints.

### Input parameters

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Data Type</th>
      <th>Is it Required?</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`accountId`</td>
      <td>Integer</td>
      <td>Yes</td>
      <td>Your New Relic account ID where the monitor will be created.</td>
    </tr>
    <tr>
      <td>`monitor.locations.public`</td>
      <td>Array</td>
      <td>Yes</td>
      <td>Array of public location identifiers where the monitor will run checks (e.g., `["US_EAST_1", "US_WEST_1"]`).</td>
    </tr>
    <tr>
      <td>`monitor.name`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The display name for your scripted API monitor.</td>
    </tr>
    <tr>
      <td>`monitor.period`</td>
      <td>Enum</td>
      <td>Yes</td>
      <td>How often the monitor runs. Options: `EVERY_MINUTE`, `EVERY_5_MINUTES`, `EVERY_10_MINUTES`, `EVERY_15_MINUTES`, `EVERY_30_MINUTES`, `EVERY_HOUR`, `EVERY_6_HOURS`, `EVERY_12_HOURS`, `EVERY_DAY`.</td>
    </tr>
    <tr>
      <td>`monitor.runtime.runtimeType`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The runtime type used by your monitor. `NODE_API` is the only accepted value.</td>
    </tr>
    <tr>
      <td>`monitor.runtime.runtimeTypeVersion`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The runtime type version used by your monitor. `16.10` is the only accepted value.</td>
    </tr>
    <tr>
      <td>`monitor.runtime.scriptLanguage`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The language used in your monitor. `JAVASCRIPT` is the only accepted value.</td>
    </tr>
    <tr>
      <td>`monitor.script`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The JavaScript code that the monitor executes. This should be plain text, not base64 encoded. The script can use the $http object to make HTTP requests and perform API testing.</td>
    </tr>
    <tr>
      <td>`monitor.status`</td>
      <td>Enum</td>
      <td>Yes</td>
      <td>The monitor status. Options: `ENABLED` (monitor is active and performing checks), `DISABLED` (monitor is inactive).</td>
    </tr>
    <tr>
      <td>`monitor.apdexTarget`</td>
      <td>Float</td>
      <td>No</td>
      <td>The monitor's Apdex target in seconds, used to populate SLA reports. Defaults to 7.0 seconds.</td>
    </tr>
  </tbody>
</table>

### Sample request

```graphql
mutation {
  syntheticsCreateScriptApiMonitor(
    accountId: ACCOUNT_ID
    monitor: {
      locations: { public: ["LOCATION_1", "LOCATION_2"] }
      name: "YOUR_MONITOR_NAME"
      period: PERIOD
      runtime: {
        runtimeType: "RUNTIME_TYPE"
        runtimeTypeVersion: "RUNTIME_TYPE_VERSION"
        scriptLanguage: "SCRIPT_LANGUAGE"
      }
      script: "SCRIPT_CONTENT"
      status: STATUS
      apdexTarget: APDEX_TARGET
    }
  ) {
    errors {
      description
      type
    }
  }
}
```

### Sample response

A successful response returns `null` for errors:

```json
{
  "data": {
    "syntheticsCreateScriptApiMonitor": {
      "errors": null
    }
  }
}
```

If there are any issues creating the monitor, the `errors` array will contain objects with `description` and `type` fields explaining what went wrong.

## Update a scripted API monitor [#update-scripted-api]

You can update an existing scripted API monitor using the `syntheticsUpdateScriptApiMonitor` mutation. This allows you to modify the configuration of a scripted API monitor that has already been created.

### Input parameters

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Data Type</th>
      <th>Is it Required?</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`guid`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The unique entity GUID of the monitor you want to update.</td>
    </tr>
    <tr>
      <td>`monitor.locations.public`</td>
      <td>Array</td>
      <td>No</td>
      <td>Array of public location identifiers where the monitor will run checks (e.g., `["US_EAST_1", "US_WEST_1"]`).</td>
    </tr>
    <tr>
      <td>`monitor.name`</td>
      <td>String</td>
      <td>No</td>
      <td>The updated display name for your scripted API monitor.</td>
    </tr>
    <tr>
      <td>`monitor.period`</td>
      <td>Enum</td>
      <td>No</td>
      <td>How often the monitor runs. Options: `EVERY_MINUTE`, `EVERY_5_MINUTES`, `EVERY_10_MINUTES`, `EVERY_15_MINUTES`, `EVERY_30_MINUTES`, `EVERY_HOUR`, `EVERY_6_HOURS`, `EVERY_12_HOURS`, `EVERY_DAY`.</td>
    </tr>
    <tr>
      <td>`monitor.runtime.runtimeType`</td>
      <td>String</td>
      <td>No</td>
      <td>The runtime type used by your monitor. `NODE_API` is the only accepted value.</td>
    </tr>
    <tr>
      <td>`monitor.runtime.runtimeTypeVersion`</td>
      <td>String</td>
      <td>No</td>
      <td>The runtime type version used by your monitor. `16.10` is the only accepted value.</td>
    </tr>
    <tr>
      <td>`monitor.runtime.scriptLanguage`</td>
      <td>String</td>
      <td>No</td>
      <td>The language used in your monitor. `JAVASCRIPT` is the only accepted value.</td>
    </tr>
    <tr>
      <td>`monitor.script`</td>
      <td>String</td>
      <td>No</td>
      <td>The JavaScript code that the monitor executes. This should be plain text, not base64 encoded.</td>
    </tr>
    <tr>
      <td>`monitor.status`</td>
      <td>Enum</td>
      <td>No</td>
      <td>The monitor status. Options: `ENABLED` (monitor is active and performing checks), `DISABLED` (monitor is inactive).</td>
    </tr>
    <tr>
      <td>`monitor.apdexTarget`</td>
      <td>Float</td>
      <td>No</td>
      <td>The monitor's Apdex target in seconds, used to populate SLA reports. Defaults to 7.0 seconds.</td>
    </tr>
  </tbody>
</table>

### Sample request

```graphql
mutation {
  syntheticsUpdateScriptApiMonitor(
    guid: ENTITY_GUID
    monitor: {
      locations: { public: ["LOCATION_1", "LOCATION_2"] }
      name: "YOUR_MONITOR_NAME"
      period: PERIOD
      runtime: {
        runtimeType: "RUNTIME_TYPE"
        runtimeTypeVersion: "RUNTIME_TYPE_VERSION"
        scriptLanguage: "SCRIPT_LANGUAGE"
      }
      script: "SCRIPT_CONTENT"
      status: STATUS
      apdexTarget: APDEX_TARGET
    }
  ) {
    errors {
      description
      type
    }
  }
}
```

### Sample response

A successful response returns `null` for errors:

```json
{
  "data": {
    "syntheticsUpdateScriptApiMonitor": {
      "errors": null
    }
  }
}
```

If there are any issues updating the monitor, the `errors` array will contain objects with `description` and `type` fields explaining what went wrong.

## Upgrade a scripted API monitor's runtime [#upgrade-monitor-runtime]

You can upgrade a scripted API monitor to use the newer Node.js 16.10 runtime. This ensures your monitor uses the latest Node.js features and security updates.

### Input parameters

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Data Type</th>
      <th>Is it Required?</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`guid`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The unique entity GUID of the monitor you want to upgrade.</td>
    </tr>
    <tr>
      <td>`monitor.runtime.runtimeType`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The runtime type. `NODE_API` is the only accepted value.</td>
    </tr>
    <tr>
      <td>`monitor.runtime.runtimeTypeVersion`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The runtime version. `16.10` is the only accepted value.</td>
    </tr>
    <tr>
      <td>`monitor.runtime.scriptLanguage`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The scripting language. `JAVASCRIPT` is the only accepted value.</td>
    </tr>
  </tbody>
</table>

### Sample request

```graphql
mutation {
  syntheticsUpdateScriptApiMonitor(
    guid: "ENTITY_GUID",
    monitor: {
      runtime: {
        runtimeType: "NODE_API",
        runtimeTypeVersion: "16.10",
        scriptLanguage: "JAVASCRIPT"
      }
    }
  ) {
    errors {
      description
      type
    }
  }
}
```

### Sample response

A successful response returns `null` for errors:

```json
{
  "data": {
    "syntheticsUpdateScriptApiMonitor": {
      "errors": null
    }
  }
}
```

If there are any issues upgrading the monitor runtime, the `errors` array will contain objects with `description` and `type` fields explaining what went wrong.

## Downgrade a scripted API monitor's runtime [#downgrade-monitor-runtime]

You can downgrade a scripted API monitor to use a legacy runtime. This may be necessary for compatibility reasons, but note that legacy runtimes will be end-of-life on October 22, 2024.

<Callout variant="important">
  Legacy runtimes are deprecated and will be end-of-life on October 22, 2024. Downgrading to legacy runtimes is not recommended except for temporary compatibility needs.
</Callout>

### Input parameters

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Data Type</th>
      <th>Is it Required?</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`guid`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The unique entity GUID of the monitor you want to downgrade.</td>
    </tr>
    <tr>
      <td>`monitor.runtime.runtimeType`</td>
      <td>String</td>
      <td>Yes</td>
      <td>Set to empty string `""` to use legacy runtime.</td>
    </tr>
    <tr>
      <td>`monitor.runtime.runtimeTypeVersion`</td>
      <td>String</td>
      <td>Yes</td>
      <td>Set to empty string `""` to use legacy runtime.</td>
    </tr>
    <tr>
      <td>`monitor.runtime.scriptLanguage`</td>
      <td>String</td>
      <td>Yes</td>
      <td>Set to empty string `""` to use legacy runtime.</td>
    </tr>
  </tbody>
</table>

### Sample request

```graphql
mutation {
  syntheticsUpdateScriptApiMonitor(
    guid: "ENTITY_GUID",
    monitor: {
      runtime: {
        runtimeType: "",
        runtimeTypeVersion: "",
        scriptLanguage: ""
      }
    }
  ) {
    errors {
      description
      type
    }
  }
}
```

### Sample response

A successful response returns `null` for errors:

```json
{
  "data": {
    "syntheticsUpdateScriptApiMonitor": {
      "errors": null
    }
  }
}
```

If there are any issues downgrading the monitor runtime, the `errors` array will contain objects with `description` and `type` fields explaining what went wrong.

## Move a scripted API monitor between VSE enabled private locations [#move-monitor]

You can move a scripted API monitor between VSE-enabled private locations. When moving monitors between private locations with verified script execution (VSE) enabled, you must include the script to regenerate HMACs for security validation.

### Input parameters

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Data Type</th>
      <th>Is it Required?</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`guid`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The unique entity GUID of the monitor you want to move.</td>
    </tr>
    <tr>
      <td>`monitor.locations.private`</td>
      <td>Array</td>
      <td>Yes</td>
      <td>Array of private location configurations. Each location requires a `guid` and `vsePassword` for VSE-enabled locations.</td>
    </tr>
    <tr>
      <td>`monitor.locations.private.guid`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The entity GUID of the target private location.</td>
    </tr>
    <tr>
      <td>`monitor.locations.private.vsePassword`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The VSE password for the target private location.</td>
    </tr>
    <tr>
      <td>`monitor.script`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The JavaScript code that the monitor executes. This must be included to regenerate HMACs when moving between VSE-enabled locations.</td>
    </tr>
  </tbody>
</table>

### Sample request

```graphql
mutation {
  syntheticsUpdateScriptApiMonitor(
    guid: "ENTITY_GUID"
    monitor: {
      locations: {
        private: [{
          guid: "LOCATION_GUID",
          vsePassword: "YOUR_VSE_PASSWORD"
        }]
      },
      script: "SCRIPT_CONTENT"
    }
  ) {
    errors {
      description
      type
    }
    monitor {
      status
    }
  }
}
```

### Sample response

A successful response returns `null` for errors and includes the monitor status:

```json
{
  "data": {
    "syntheticsUpdateScriptApiMonitor": {
      "errors": null,
      "monitor": {
        "status": "ENABLED"
      }
    }
  }
}
```

If there are any issues moving the monitor, the `errors` array will contain objects with `description` and `type` fields explaining what went wrong.

## Delete a scripted API monitor [#delete-monitor]

When a scripted API monitor is no longer needed, you can permanently remove it using the `syntheticsDeleteMonitor` mutation.

To delete a monitor, refer to the [Delete Synthetic monitor](/docs/apis/nerdgraph/examples/synthetics-api/ping-monitor/#delete-monitor) section.
