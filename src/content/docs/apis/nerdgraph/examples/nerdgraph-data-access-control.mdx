---
title: "NerdGraph tutorial: Manage data access policies"
tags:
  - APIs
  - NerdGraph
  - Examples
metaDescription: "Use New Relic NerdGraph to create, update, and manage data access policies for controlling access to log partitions."
freshnessValidatedDate: never
---

You can use our [NerdGraph API](/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/) to create, update, query, and delete data access policies. This allows you to programmatically manage which [log partitions](/docs/logs/ui-data/data-partitions/) your users can access.

## Requirements [#requirements]

To manage data access policies via NerdGraph, you need:

* A [Pro or Enterprise](https://newrelic.com/pricing) edition New Relic account
* [Authentication domain manager](/docs/accounts/accounts-billing/new-relic-one-user-management/user-management-concepts#admin-settings) role
* User type of [core user or full platform user](/docs/accounts/accounts-billing/new-relic-one-user-management/user-type)
* A [user key](/docs/apis/intro-apis/new-relic-api-keys/#user-key) for authentication

## Before you begin [#before-you-begin]

Before using the NerdGraph API for data access policies:

* Understand how [data access control](/docs/accounts/accounts-billing/new-relic-one-user-management/data-access-control) works in the UI
* Review our [NerdGraph introduction](/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/)
* You can use the [NerdGraph explorer](https://api.newrelic.com/graphiql) to explore the API and run queries

## Key concepts [#key-concepts]

When working with data access policies via NerdGraph, keep in mind:

* **Policy types**: Policies can either allow or deny access to specific log partitions
* **Wildcard matching**: Use `%` to match multiple partitions (e.g., `log_prod%` matches all partitions starting with "log_prod")
* **Policy assignment**: Policies must be assigned to groups through access grants to take effect
* **Multiple policies**: When users belong to multiple groups with different policies, the most permissive access applies

## Common operations [#operations]

Here are the most common operations for managing data access policies:

<CollapserGroup>

<Collapser
  id="list-policies"
  title="List all data access policies"
>

Use the `customerAdministration` query to retrieve a list of all data access policies in your organization:

```graphql
{
  customerAdministration {
    dataAccessPolicies(
      filter: {organizationId: {eq: "YOUR_ORGANIZATION_ID"}}
    ) {
      items {
        id
        name
        policy
        status
        version
        createdAt
        createdBy {
          email
          id
          name
        }
        updatedAt
        updatedBy {
          email
          id
          name
        }
      }
      nextCursor
    }
  }
}
```

### Parameters

* `organizationId` (required): Your New Relic organization ID

### Response fields

* `id`: Unique identifier for the policy
* `name`: Human-readable name for the policy
* `policy`: JSON string containing the policy rules
* `status`: Current status of the policy (e.g., `ACTIVE`)
* `version`: Policy version (currently `1.0-logs`)
* `createdAt`/`updatedAt`: Timestamps for policy creation and last update
* `createdBy`/`updatedBy`: User information for who created/updated the policy
* `nextCursor`: Pagination cursor for retrieving additional results

### Example response

```json
{
  "data": {
    "customerAdministration": {
      "dataAccessPolicies": {
        "items": [
          {
            "id": "policy-123-abc",
            "name": "Production logs access",
            "policy": "{\"rules\":[{\"partitions\":{\"allow\":[\"log_prod%\"]}}]}",
            "status": "ACTIVE",
            "version": "1.0-logs",
            "createdAt": "2025-01-15T10:30:00Z",
            "createdBy": {
              "email": "admin@example.com",
              "id": "user-456",
              "name": "Admin User"
            },
            "updatedAt": "2025-01-15T10:30:00Z",
            "updatedBy": {
              "email": "admin@example.com",
              "id": "user-456",
              "name": "Admin User"
            }
          }
        ],
        "nextCursor": null
      }
    }
  }
}
```

</Collapser>

<Collapser
  id="create-policy"
  title="Create a data access policy"
>

Use the `dataAccessPolicyCreate` mutation to create a new data access policy:

```graphql
mutation {
  dataAccessPolicyCreate(
    organizationId: "YOUR_ORGANIZATION_ID"
    name: "Development logs access"
    policy: "{\"rules\":[{\"partitions\":{\"allow\":[\"log_dev%\",\"log_test%\"]}}]}"
    version: "1.0-logs"
  ) {
    dataAccessPolicy {
      id
      name
      policy
      status
      version
    }
  }
}
```

### Parameters

* `organizationId` (required): Your New Relic organization ID
* `name` (required): A descriptive name for the policy
* `policy` (required): JSON string defining the policy rules
* `version` (required): Policy version, currently must be `1.0-logs`

### Policy structure

The `policy` parameter is a JSON string with the following structure:

#### Allow-list policy

```json
{
  "rules": [
    {
      "partitions": {
        "allow": ["log_prod%", "log_staging"]
      }
    }
  ]
}
```

#### Deny-list policy

```json
{
  "rules": [
    {
      "partitions": {
        "deny": ["log_sensitive", "log_pii%"]
      }
    }
  ]
}
```

### Example response

```json
{
  "data": {
    "dataAccessPolicyCreate": {
      "dataAccessPolicy": {
        "id": "policy-789-xyz",
        "name": "Development logs access",
        "policy": "{\"rules\":[{\"partitions\":{\"allow\":[\"log_dev%\",\"log_test%\"]}}]}",
        "status": "ACTIVE",
        "version": "1.0-logs"
      }
    }
  }
}
```

</Collapser>

<Collapser
  id="update-policy"
  title="Update a data access policy"
>

Use the `dataAccessPolicyUpdate` mutation to modify an existing policy:

```graphql
mutation {
  dataAccessPolicyUpdate(
    id: "policy-789-xyz"
    name: "Updated dev logs access"
    policy: "{\"rules\":[{\"partitions\":{\"allow\":[\"log_dev%\",\"log_test%\",\"log_qa%\"]}}]}"
    version: "1.0-logs"
  ) {
    dataAccessPolicy {
      id
      name
      policy
      status
      version
      updatedAt
      updatedBy {
        email
        name
      }
    }
  }
}
```

### Parameters

* `id` (required): The ID of the policy to update
* `name` (optional): Updated name for the policy
* `policy` (optional): Updated policy rules
* `version` (required): Policy version, currently must be `1.0-logs`

<Callout variant="tip">
You can update the policy name, rules, or both. Only provide the fields you want to change along with the required `id` and `version`.
</Callout>

### Example response

```json
{
  "data": {
    "dataAccessPolicyUpdate": {
      "dataAccessPolicy": {
        "id": "policy-789-xyz",
        "name": "Updated dev logs access",
        "policy": "{\"rules\":[{\"partitions\":{\"allow\":[\"log_dev%\",\"log_test%\",\"log_qa%\"]}}]}",
        "status": "ACTIVE",
        "version": "1.0-logs",
        "updatedAt": "2025-01-16T14:20:00Z",
        "updatedBy": {
          "email": "admin@example.com",
          "name": "Admin User"
        }
      }
    }
  }
}
```

</Collapser>

<Collapser
  id="delete-policy"
  title="Delete a data access policy"
>

Use the `dataAccessPolicyDelete` mutation to remove a policy:

```graphql
mutation {
  dataAccessPolicyDelete(
    id: "policy-789-xyz"
  ) {
    success
  }
}
```

### Parameters

* `id` (required): The ID of the policy to delete

<Callout variant="important">
Deleting a policy removes it from all assigned groups. Users in those groups will lose the data access restrictions defined by the policy.
</Callout>

### Example response

```json
{
  "data": {
    "dataAccessPolicyDelete": {
      "success": true
    }
  }
}
```

</Collapser>

<Collapser
  id="assign-policy-to-grant"
  title="Assign a policy to an access grant"
>

After creating a policy, you need to assign it to a group through an access grant. First, query the existing grants:

```graphql
{
  customerAdministration {
    grants(
      filter: {organizationId: {eq: "YOUR_ORGANIZATION_ID"}}
    ) {
      items {
        id
        name
        group {
          id
          displayName
        }
        role {
          id
          name
        }
        accountAccessGrants {
          id
        }
        dataAccessPolicy {
          id
          name
        }
      }
    }
  }
}
```

Then use the grant ID to assign or update the data access policy. Note: The specific mutation for this operation may vary based on your implementation. Consult the NerdGraph explorer for the exact mutation available in your environment.

</Collapser>

<Collapser
  id="query-specific-policy"
  title="Query a specific policy by ID"
>

To retrieve details of a specific policy:

```graphql
{
  customerAdministration {
    dataAccessPolicy(
      id: "policy-123-abc"
    ) {
      id
      name
      policy
      status
      version
      createdAt
      createdBy {
        email
        id
        name
      }
      updatedAt
      updatedBy {
        email
        id
        name
      }
    }
  }
}
```

### Parameters

* `id` (required): The unique identifier of the policy

### Example response

```json
{
  "data": {
    "customerAdministration": {
      "dataAccessPolicy": {
        "id": "policy-123-abc",
        "name": "Production logs access",
        "policy": "{\"rules\":[{\"partitions\":{\"allow\":[\"log_prod%\"]}}]}",
        "status": "ACTIVE",
        "version": "1.0-logs",
        "createdAt": "2025-01-15T10:30:00Z",
        "createdBy": {
          "email": "admin@example.com",
          "id": "user-456",
          "name": "Admin User"
        },
        "updatedAt": "2025-01-15T10:30:00Z",
        "updatedBy": {
          "email": "admin@example.com",
          "id": "user-456",
          "name": "Admin User"
        }
      }
    }
  }
}
```

</Collapser>

</CollapserGroup>

## Policy examples [#policy-examples]

Here are some common policy patterns:

### Allow access to production logs only

```json
{
  "rules": [
    {
      "partitions": {
        "allow": ["log_production", "log_prod%"]
      }
    }
  ]
}
```

### Deny access to sensitive logs

```json
{
  "rules": [
    {
      "partitions": {
        "deny": ["log_security", "log_pii%", "log_sensitive%"]
      }
    }
  ]
}
```

### Allow multiple environment logs

```json
{
  "rules": [
    {
      "partitions": {
        "allow": [
          "log_development%",
          "log_staging%",
          "log_test%"
        ]
      }
    }
  ]
}
```

### Allow all except specific partitions

```json
{
  "rules": [
    {
      "partitions": {
        "deny": ["log_admin", "log_internal%"]
      }
    }
  ]
}
```

## Wildcard patterns [#wildcards]

The `%` character acts as a wildcard that matches zero or more characters:

* `log_prod%`: Matches `log_prod`, `log_production`, `log_prod_api`, etc.
* `%test%`: Matches `log_test`, `integration_test_logs`, `test_partition`, etc.
* `log_%_prod`: Matches `log_api_prod`, `log_web_prod`, etc.

## Best practices [#best-practices]

When managing data access policies via NerdGraph:

* **Use descriptive names**: Give policies clear names that explain their purpose
* **Test policies**: Create test policies and verify they work as expected before applying to production groups
* **Document policy intent**: Use policy names and external documentation to explain why each policy exists
* **Review regularly**: Periodically audit your policies to ensure they still match your security requirements
* **Use wildcards wisely**: Be careful with broad wildcards like `%` that might match more partitions than intended
* **Start restrictive**: Begin with deny-all or limited allow policies, then expand access as needed
* **Audit changes**: Track who creates and modifies policies using the `createdBy` and `updatedBy` fields

## Troubleshooting [#troubleshooting]

### Policy not taking effect

If a policy doesn't seem to be working:

1. Verify the policy is assigned to the correct access grant
2. Check that the user belongs to the group associated with the grant
3. Ensure the partition names in the policy match the actual partition names
4. Remember that multiple policies apply additively (most permissive wins)
5. Check for deny rules that might be overriding allow rules

### Invalid policy format error

If you receive an error about invalid policy format:

* Ensure the `policy` parameter is a properly escaped JSON string
* Verify the policy structure matches the expected schema
* Check that partition names don't contain invalid characters
* Confirm the `version` is set to `1.0-logs`

### Authorization errors

If you can't create or modify policies:

* Verify you have the [Authentication domain manager](/docs/accounts/accounts-billing/new-relic-one-user-management/user-management-concepts#admin-settings) role
* Confirm you're using a valid [user key](/docs/apis/intro-apis/new-relic-api-keys/#user-key)
* Check that your account has [Pro or Enterprise](https://newrelic.com/pricing) edition

## Related documentation [#related-docs]

* [Data access control UI guide](/docs/accounts/accounts-billing/new-relic-one-user-management/data-access-control)
* [User management concepts](/docs/accounts/accounts-billing/new-relic-one-user-management/user-management-concepts)
* [NerdGraph user management](/docs/apis/nerdgraph/examples/nerdgraph-manage-users)
* [Log partitions](/docs/logs/ui-data/data-partitions/)
