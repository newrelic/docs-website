---
title: "Set up RAG integration"
metaDescription: Enhance New Relic AI with RAG (Retrieval Augmented Generation)
redirects:
  - /docs/agentic-ai/knowledge-integration/apis-and-communication-protocol
freshnessValidatedDate: never
---

<Callout title="preview">
  We're still working on this feature, but we'd love for you to try it out!

  This feature is currently provided as part of a preview program pursuant to our [pre-release policies](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy).
</Callout>

With New Relic, you can enhance New Relic AI agents with Retrieval Augmented Generation (RAG) by associating your documentation, runbooks, incident retros, and even source code with your services. This process gives New Relic AI better insight into issues with your system. The tutorial outlines how to obtain your organization ID, create a RAG tool, and add your documents to the platform using the Blob API.

After adding your documents, you will create a relationship to associate them with the RAG tool. You can then verify your configuration by querying the relationships between the RAG documents and the RAG tool. The final step is to query the RAG tool itself to retrieve relevant, indexed information.

To learn more about the knowledge connector, refer to [New Relic AI Knowledge connector](/docs/agentic-ai/knowledge-integration/overview).

<Callout variant="important">
 Before performing the following steps, ensure that you have "Org Product Admin" permissions.
</Callout>

To start indexing your content and benefit from the knowledge connector with New Relic AI, follow these mentioned steps:

## Task 1: Create your RAG tool [#create-your-rag-tool]

<CollapserGroup>
<Collapser id ="get-started" title ="Obtain your organization ID">

Organization ID uniquely identifies your account and ensures that any RAG tool you create, documents you upload, or relationships you establish are associated with your organization in New Relic. 

Organization ID is required to perform mutations and queries in NerdGraph when setting up and managing RAG tools and documents. Run the following query and keep the organization ID handy for later steps.

### Sample query
```graphql
{
  actor {
    organization {
      id
    }
  }
}
```
</Collapser>
<Collapser id = "create-rag-tool" title = "Create a RAG tool">

A RAG tool acts as a specialized container for organizing related documents and resources in New Relic. A clear name and accurate description for your RAG tools helps the LLM select the right tool for each prompt, ensuring relevant and context-aware responses.

To create a new RAG tool in your New Relic account, run the following `entityManagementCreateRagTool` mutation:

1. Make sure to replace `${ORGANIZATION_ID}` with your actual organization ID obtained in the previous step.
2. If successful, you'll receive an `id` for your RAG tool.

### Input parameters

<table>
    <thead>
        <tr>
            <th>Parameter Name</th>
            <th>Data Type</th>
            <th>Is it Required?</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>`ragToolEntity`</td>
            <td>Object</td>
            <td>Yes</td>
            <td>The input object that contains the configuration for the new RAG tool.</td>
        </tr>
        <tr>
            <td>`description`</td>
            <td>String</td>
            <td>Yes</td>
            <td>A clear and accurate description of the RAG tool's purpose.</td>
        </tr>
        <tr>
            <td>`name`</td>
            <td>String</td>
            <td>Yes</td>
            <td>The unique name for your RAG tool.</td>
        </tr>
        <tr>
            <td>`scope`</td>
            <td>Object</td>
            <td>Yes</td>
            <td>An object defining the context in which the tool will be created.</td>
        </tr>
        <tr>
            <td>`scope.id`</td>
            <td>String</td>
            <td>Yes</td>
            <td>The unique ID of your organization (`${ORGANIZATION_ID}`).</td>
        </tr>
        <tr>
            <td>`scope.type`</td>
            <td>String</td>
            <td>Yes</td>
            <td>The type of the scope, which must be `ORGANIZATION`.</td>
        </tr>
    </tbody>
</table>

### Sample mutation
```graphql
mutation {
  entityManagementCreateRagTool(
    ragToolEntity: {
      description: "Runbooks for resolving incidents with APIs",
      name: "API Runbooks",
      scope: {id: `${ORGANIZATION_ID}`, type: ORGANIZATION}
    }
  ) {
    entity {
      id
    }
  }
}
```

You should save the `id` returned as you'll need it in later steps to link documents to the tool, verify relationships, and query the tool for relevant information in New Relic.
</Collapser>
</CollapserGroup>

## Task 2 [#task2]
You have two options for providing context to your RAG tool. You can manually upload static files or set up an automated connector for living documentation.

### Option A: Index your documents [#index-your-documents]
If you have static documents such as PDFs, Word files, or local CSVs that are not hosted in a cloud knowledge base, use the Document Knowledge Connector. This method utilizes the Blob API to upload individual files directly to New Relic. Use this option for:

- **One-time context:**Uploading specific runbooks or architectural diagrams that rarely change.

- **Local data:** Indexing proprietary or internal files that live on your local machine rather than a wiki.

- **Agentic testing:** Quickly providing a specific set of documents to an AI agent for a focused workflow.

<CollapserGroup>
<Collapser id = "upload-document" title = "Upload a document via the Blob API">

<Callout variant="important">
 All indexed documents are visible to all users within your organization. Make sure the documents you index comply with your internal policies, and do not upload sensitive or private data.
</Callout>

### The Blob API and its purpose
The Blob API is a New Relic service designed for uploading files, such as documentation and runbooks, to your account. NerdGraph is optimized for structured data queries and mutations and not for efficient transfer of files, so the Blob API is required for uploading documents.

### Authentication requirements
You need a valid New Relic API key with permissions to upload documents. To get the API key for uploading a document to New Relic using the Blob API:

1. Log in to your [New Relic](https://one.newrelic.com/) account.
2. Create and manage your API keys from the [API keys UI page](https://one.newrelic.com/administration/api-keys).
3. Click **Create a key**, and fill the required details (or use an existing one with the required permissions).
4. Click **Create a key** and copy the generated key (it'll look like NRAK-XXXXXXXXXX).

Here's an example of how to upload a document using a `curl` `bash` command:

### Input parameters

<table>
    <thead>
        <tr>
            <th>Parameter Name</th>
            <th>Data Type</th>
            <th>Is it Required?</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>`Api-Key`</td>
            <td>String</td>
            <td>Yes</td>
            <td>Your New Relic API key for authentication.</td>
        </tr>
        <tr>
            <td>`NewRelic-Entity`</td>
            <td>JSON Object</td>
            <td>Yes</td>
            <td>Metadata about the document, such as its name.</td>
        </tr>
        <tr>
            <td>`Content-Type`</td>
            <td>String</td>
            <td>Yes</td>
            <td>The format of the file being uploaded (e.g., `application/json`).</td>
        </tr>
        <tr>
            <td>`payload` (`@incidents.json`)</td>
            <td>File</td>
            <td>Yes</td>
            <td>The document file you are uploading, specified by its file path.</td>
        </tr>
    </tbody>
</table>


### Sample query
```shell
curl -X POST https://blob-api.service.newrelic.com/v1/e/organizations/$ORGANIZATION_ID/RagDocuments \
     -H 'Api-Key: NRAK-XXXXXXXXXX' \
     -H 'NewRelic-Entity: {"name": "Runbooks for API service" }' \
     -H 'Content-Type: application/json' \
     -d @incidents.json
```

### Sample response

<table>
    <thead>
        <tr>
            <th>Response</th>
            <th>Data Type</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>`entityGuid`</td>
            <td>String</td>
            <td>The unique identifier for the uploaded RAG document.</td>
        </tr>
        <tr>
            <td>`blobVersionEntity`</td>
            <td>Object</td>
            <td>Represents the version of the uploaded blob.</td>
        </tr>
    </tbody>
</table>

```json
{
  "entityGuid": "MTIyODU0NTN8TkdFUHxSQUdfRE9DVU1FTlR8MDE5NGUyOTgtYmQzMS03NzA4LWI3NzItYzQ4MTZlYjNhYThk",
  "blobVersionEntity": null
}
```
### Next steps

After uploading your document, it is indexed and becomes available for New Relic AI to search and retrieve. You must save the `entityGuid` from the response to create a relationship with your RAG tool or to query the document in NerdGraph.

</Collapser>
<Collapser id = "view-the-rag-document-entity-represented-in-nerdgraph" title = "View the RAG document entity represented in NerdGraph"> 

After a document is uploaded via the Blob API, running this query confirms that the upload was successful and that the document has been properly registered as a RAG document entity with its own unique identifier and properties.

#### Input parameters

<table>
    <thead>
        <tr>
            <th>Parameter Name</th>
            <th>Data Type</th>
            <th>Is it Required?</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>`id`</td>
            <td>String</td>
            <td>Yes</td>
            <td>The unique GUID of the RAG document to be retrieved.</td>
        </tr>
    </tbody>
</table>

### Sample query

In the query below, replace the `${RAG_DOCUMENT_GUID}` placeholder with the `entityGuid` you received in the previous step.

```graphql
{
  actor {
    entityManagement {
      entity(
        id: `${RAG_DOCUMENT_GUID}`
      ) {
        ... on EntityManagementRagDocumentEntity {
          id
          name
          blob {
            url
          }
          type
        }
      }
    }
  }
}
```

This query will return the following details about your RAG document:

- `id`: The unique ID of the RAG document.
- `name`: The name of the RAG document.
- `blob { url }`: The URL to access the uploaded document.
- `type`: The type of the entity, which in this case is `EntityManagementRagDocumentEntity`.

</Collapser>
<Collapser id = "create-a-relationship-between-the-rag-document-and-the-rag-tool" title = "Create a relationship between the RAG tool and the RAG document">

Now that you've created a RAG tool, uploaded your document, and verified that the upload was successful, the next step is to associate the RAG tool and the RAG document thereby making your document searchable and usable by New Relic AI. To do this, run the `entityManagementCreateRelationship` mutation:

1. Replace `${RAG_DOCUMENT_GUID}` with the `entityGuid` from the response of the document upload via the Blob API.
2. Replace `${RAG_TOOL_GUID}` with the `id` from the response of the RAG tool creation mutation.

### Input parameters

<table>
    <thead>
        <tr>
            <th>Parameter Name</th>
            <th>Data Type</th>
            <th>Is it Required?</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>`relationship`</td>
            <td>Object</td>
            <td>Yes</td>
            <td>The input object that contains the details for the relationship.</td>
        </tr>
        <tr>
            <td>`source`</td>
            <td>Object</td>
            <td>Yes</td>
            <td>The source entity of the relationship, which is the RAG document.</td>
        </tr>
        <tr>
            <td>`source.scope`</td>
            <td>String</td>
            <td>Yes</td>
            <td>The scope of the source entity, which must be `ORGANIZATION`.</td>
        </tr>
        <tr>
            <td>`source.id`</td>
            <td>String</td>
            <td>Yes</td>
            <td>The unique GUID of the RAG document (`${RAG_DOCUMENT_GUID}`).</td>
        </tr>
        <tr>
            <td>`target`</td>
            <td>Object</td>
            <td>Yes</td>
            <td>The target entity of the relationship, which is the RAG tool.</td>
        </tr>
        <tr>
            <td>`target.scope`</td>
            <td>String</td>
            <td>Yes</td>
            <td>The scope of the target entity, which must be `ORGANIZATION`.</td>
        </tr>
        <tr>
            <td>`target.id`</td>
            <td>String</td>
            <td>Yes</td>
            <td>The unique GUID of the RAG tool (`${RAG_TOOL_GUID}`).</td>
        </tr>
        <tr>
            <td>`type`</td>
            <td>String</td>
            <td>Yes</td>
            <td>The type of the relationship, which must be `"INDEXED_FOR"`.</td>
        </tr>
    </tbody>
</table>

### Sample mutation

```graphql
mutation {
  entityManagementCreateRelationship(
    relationship: {
      source: {
        scope: ORGANIZATION,
        id: `${RAG_DOCUMENT_GUID}`
      },
      target: {
        scope: ORGANIZATION,
        id: `${RAG_TOOL_GUID}`
      },
      type: "INDEXED_FOR"
    }
  ) {
    relationship {
      type
      target {
        id
        type
      }
      source {
        id
        type
      }
    }
  }
}
```
</Collapser>
</CollapserGroup>

### Option B: Index your Confluence documents [#index-your-confluence]
If your organization uses Confluence for documentation, you can index your Confluence documents into New Relic without needing to use the Blob API. This option allows you to connect your Confluence instance and select specific documents or spaces to be indexed and associated with your RAG tool. Use this option to ensure New Relic AI always has the latest version of your Confluence pages.

<CollapserGroup>
<Collapser id="confluence-api-token" title="Store your Confluence API token">

The connector requires an Atlassian API token to fetch your pages. Securely store this in the New Relic secrets manager.

### Input parameters

<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Data Type</th>
<th>Required?</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>description</td>
<td>String</td>
<td>No</td>
<td>A brief summary of what the secret is used for.</td>
</tr>
<tr>
<td>key</td>
<td>String</td>
<td>Yes</td>
<td>The unique name used to reference this secret (for example, `CONFLUENCE_API_TOKEN`).</td>
</tr>
<tr>
<td>namespace</td>
<td>String</td>
<td>Yes</td>
<td>Must be set to <strong>rag-datafetching</strong> for the RAG indexer service to access it.</td>
</tr>
<tr>
<td>value</td>
<td>String</td>
<td>Yes</td>
<td>The actual Confluence API token value or password.</td>
</tr>
<tr>
<td>scope</td>
<td>Object</td>
<td>Yes</td>
<td>Defines the organizational context; the type must be <strong>ORGANIZATION</strong>.</td>
</tr>
</tbody>
</table>

### Sample mutation

```graphql
mutation createSecretKey {
  secretsManagementCreateSecret(
    description: "Confluence API token for RAG indexing"
    key: "CONFLUENCE_API_TOKEN"
    namespace: "rag-datafetching"
    scope: {id: "YOUR_ORGANIZATION_ID", type: ORGANIZATION}
    value: "YOUR_CONFLUENCE_API_TOKEN"
  ) {
    key
  }
}
```

</Collapser>

<Collapser id="confluence-integration" title="Create the Confluence integration">

Define the connection to your Confluence instance. This acts as the bridge between New Relic and Atlassian.

### Input parameters

<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Data Type</th>
<th>Required?</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>String</td>
<td>Yes</td>
<td>A descriptive name for the integration (for example, "Engineering Confluence").</td>
</tr>
<tr>
<td>url</td>
<td>String</td>
<td>Yes</td>
<td>Your base Confluence URL (for example, https://example.atlassian.net/wiki).</td>
</tr>
<tr>
<td>confluenceUserId</td>
<td>String</td>
<td>Yes</td>
<td>The email address or ID associated with your Atlassian API token.</td>
</tr>
<tr>
<td>secretKey</td>
<td>String</td>
<td>Yes</td>
<td>The key name you defined in the previous step (`CONFLUENCE_API_TOKEN`).</td>
</tr>
<tr>
<td>scope</td>
<td>Object</td>
<td>Yes</td>
<td>Defines the context for the integration. The type must be set to <strong>ORGANIZATION</strong>.</td>
</tr>
<tr>
<td>tags</td>
<td>Object</td>
<td>No</td>
<td>Optional metadata used to categorize the integration by department or team.</td>
</tr>
</tbody>
</table>

### Sample mutation

```graphql
mutation {
  entityManagementCreateConfluenceIntegration(
    confluenceIntegration: {
      name: "Engineering Confluence Integration"
      url: "https://your-company.atlassian.net/wiki"
      confluenceUserId: "your-confluence-user-id"
      secretKey: "CONFLUENCE_API_TOKEN"  # From Step 2
      scope: {id: "YOUR_ORGANIZATION_ID", type: ORGANIZATION}
      tags: {key: "department", values: "engineering"}
    }
  ) {
    entity {
      id
    }
  }
}
```

</Collapser>

<Collapser id="rag-settings" title="Configure indexing logic (RAG settings)">

Create a RAG settings entity to define what content to fetch and how it should be chunked.

### Input parameters

<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Data Type</th>
<th>Required?</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>confluenceIntegrationId</td>
<td>String</td>
<td>Yes</td>
<td>The unique ID of the Confluence integration created in the previous step.</td>
</tr>
<tr>
<td>confluenceQuery</td>
<td>String</td>
<td>Yes</td>
<td>A CQL (Confluence Query Language) filter (for example, space = 'ENG')..</td>
</tr>
<tr>
<td>intervalSeconds</td>
<td>Int</td>
<td>Yes</td>
<td>The number of seconds between indexing runs (for example, 3600 for every hour).</td>
</tr>
<tr>
<td>chunkSize</td>
<td>Int</td>
<td>Yes</td>
<td>The maximum number of characters in each text segment (for example, 4000).</td>
</tr>
<tr>
<td>chunkOverlap</td>
<td>Int</td>
<td>Yes</td>
<td>The number of characters to overlap between text segments (for example, 100) to maintain context.</td>
</tr>
<tr>
<td>textSplitterType</td>
<td>Enum</td>
<td>Yes</td>
<td>The type of text splitter to use (for example, `MARKDOWN_TEXT_SPLITTER`).</td>
</tr>
<tr>
<td>markdownTextSplitterOptions</td>
<td>Object</td>
<td>No</td>
<td>Configuration for markdown splitting, such as which header levels (#, ##) to split on.</td>
</tr>
<tr>
<td>tokenTextSplitterOptions</td>
<td>Object</td>
<td>No</td>
<td>Configuration for token splitting, including the encoding model (for example, `O200K_BASE`).</td>
</tr>
<tr>
<td>tags</td>
<td>Object</td>
<td>No</td>
<td>Optional metadata to categorize settings (for example, key: `knowledge_category`, values: `documentation`).</td>
</tr>
</tbody>
</table>

#### Text splitter types
Use these types to define the `textSplitterType` parameter:

- `TOKEN_TEXT_SPLITTER`: Accurate token-based splitting.

- `MARKDOWN_TEXT_SPLITTER`: Split by markdown headers.

- `CHARACTER_TEXT_SPLITTER`: Split by character count.

- `JSON_TEXT_SPLITTER`: Split JSON recursively.

If using `TOKEN_TEXT_SPLITTER`, define the encoding in `tokenTextSplitterOptions`:

- `O200K_BASE`: For GPT-4o and newer models (recommended).

- `CL100K_BASE`: For GPT-4 and GPT-3.5.

### Sample mutation

```graphql
mutation {
  entityManagementCreateConfluenceRagSettings(
    confluenceRagSettingsEntity: {
      name: "Engineering Docs RAG Settings"
      scope: {id: "YOUR_ORGANIZATION_ID", type: ORGANIZATION}
      confluenceIntegrationId: "INTEGRATION_ID_FROM_STEP_3"
      confluenceQuery: "space = ENG AND type = page"
      intervalSeconds: 3600  # Re-index every hour

      # Chunking Configuration
      chunkSize: 4000
      chunkOverlap: 100
      textSplitterType: MARKDOWN_TEXT_SPLITTER

      # Optional: Markdown-specific options
      markdownTextSplitterOptions: {
        headersToSplitOn: "#,##,###"
        returnEachLine: false
      }

      # Optional: Token splitter options (if using TOKEN_TEXT_SPLITTER)
      # tokenTextSplitterOptions: {
      #   encodingName: O200K_BASE
      # }

      # Optional: Character splitter options (if using CHARACTER_TEXT_SPLITTER)
      # characterTextSplitterOptions: {
      #   separator: "\n\n"
      #   isSeparatorRegex: false
      # }

      tags: {key: "knowledge_category", values: "documentation"}
    }
  ) {
    entity {
      id
    }
  }
}
```

</Collapser>
<Collapser id="trigger-sync" title="Create relationship">

Linking your RAG settings to your RAG Tool via an `APPLY_TO` relationship activates the automated indexing.

### Input parameters

<table>
<thead>
<tr>
<th>Parameter Name</th>
<th>Data Type</th>
<th>Required?</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>source.id</td>
<td>String</td>
<td>Yes</td>
<td>The ID of the RAG settings created in the previous step.</td>
</tr>
<tr>
<td>target.id</td>
<td>String</td>
<td>Yes</td>
<td>The ID of the RAG tool created in Task 1.</td>
</tr>
<tr>
<td>type</td>
<td>String</td>
<td>Yes</td>
<td>Must be set to `APPLY_TO` for settings-to-tool connections.</td>
</tr>
<tr>
<td>tags </td>
<td>String</td>
<td>Yes</td>
<td>Optional metadata used to label the relationship (for example, key: "`auto_created`", values: "`true`")</td>
</tr>
</tbody>
</table>

### Sample mutation

```graphql
mutation {
  entityManagementCreateRelationship(
    relationship: {
      source: {id: "RAG_SETTINGS_ID_FROM_STEP_4", scope: ORGANIZATION}
      target: {id: "RAG_TOOL_ID_FROM_STEP_1", scope: ORGANIZATION}
      type: "APPLY_TO"
      tags: {key: "auto_created", values: "true"}
    }
  ) {
    relationship {
      type
    }
  }
}
```

</Collapser>
</CollapserGroup>

### Outcome: Automatic indexing triggered
Indexing will now happen automatically!

When the `APPLY_TO` relationship is created between your RAG settings and your RAG tool, the New Relic RAG indexer service initiates the following background process:

1. The service uses your `confluenceQuery` to search your Confluence instance for matching content.

2. It retrieves all matching pages and transforms them into a processable format.

3. The content is split into smaller segments based on your `chunkSize`, `chunkOverlap`, and `textSplitterType` configuration.

4. The service generates dense and sparse embeddings for each chunk and indexes them in the vector database (Pinecone).

5. The connector will re-index your content periodically based on the intervalSeconds you defined to ensure the AI has access to the most up-to-date documentation.

## Task 3: Retrieve relevant information [#retrieve-relevant-information]

<CollapserGroup>
<Collapser id="query-to-see-relationships-between-rag-documents-and-rag-tools" title="Query to see relationships between RAG documents and RAG tools">

After establishing a relationship (either by linking a specific RAG document via `INDEXED_FOR` or applying a Confluence configuration via `APPLY_TO`), you can verify the association and query the tool. This ensures your internal knowledge is properly indexed and available for New Relic AI to surface context-aware answers.

- Replace `${RAG_DOCUMENT_ID}` with the `entityGuid` of your uploaded document.


### Input parameters

<table>
    <thead>
        <tr>
            <th>Parameter Name</th>
            <th>Data Type</th>
            <th>Is it Required?</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>`relationships`</td>
            <td>Query</td>
            <td>Yes</td>
            <td>The query to retrieve relationships between entities.</td>
        </tr>
        <tr>
            <td>`filter`</td>
            <td>Object</td>
            <td>No</td>
            <td>An object used to filter the relationships based on attributes.</td>
        </tr>
        <tr>
            <td>`filter.sourceId`</td>
            <td>Object</td>
            <td>No</td>
            <td>An object to filter by the source entity's unique identifier.</td>
        </tr>
        <tr>
            <td>`filter.sourceId.eq`</td>
            <td>String</td>
            <td>No</td>
            <td>The unique GUID of the RAG document to match.</td>
        </tr>
    </tbody>
</table>

### Sample query

```graphql
{
  actor {
    entityManagement {
      relationships(
        filter: {sourceId: {eq: `${RAG_DOCUMENT_ID}`}}
      ) {
        items {
          type
          target {
            id
            type
          }
        }
      }
    }
  }
}
```

</Collapser>
<Collapser id="query-the-rag-tool" title="Query the RAG tool">

After you've set up your RAG tool and indexed documents, you can query the RAG tool to retrieve relevant information based on your prompt. This allows New Relic AI to surface context-aware answers using your organization's documentation.

### Input parameters

<table>
  <thead>
    <tr>
      <th>Parameter Name</th>
      <th>Data Type</th>
      <th>Is it Required?</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`prompt`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The natural language query you want the RAG tool to process.</td>
    </tr>
    <tr>
      <td>`toolId`</td>
      <td>String</td>
      <td>Yes</td>
      <td>The unique GUID of the RAG tool to be queried.</td>
    </tr>
  </tbody>
</table>

### Sample query
```graphql
{
  actor {
    machineLearning {
      ragQueryData(
        prompt: "tell me about the incident", 
        toolId: `${RAG_TOOL_GUID}`
      ) {
        blobId
        chunk
        documentId
        score
        toolId
      }
    }
  }
}
```
The response will include chunked matches from your indexed documents, which you can use directly or summarize with New Relic AI.
</Collapser>
</CollapserGroup>
