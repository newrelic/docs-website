---
title: "NerdGraph tutorial: Secrets management service"
metaDescription: "Learn how to use the Secret Management Service to securely store and manage your secrets."
freshnessValidatedDate: never
---

When you're working with New Relic, you might need to store sensitive information like tokens, API keys, passwords, or certificates. In New Relic, these sensitive pieces of information are called secrets. The <dnt>Secrets management</dnt> service provides a secure way to store and retrieve these secrets in a centralized location through our [NerdGraph API](/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/). You can store secrets only in string format.

For accessing external services and supported integrations, New Relic applications may need authentication credentials like API tokens or OAuth client details. These credentials must be securely stored in the <dnt>Secrets management</dnt> service to ensure that applications can access necessary functionality without compromising security.

<Callout variant="important">

Customer-specific secrets that are unrelated to New Relic approved functionality and integrations, such as third party or personal passwords, must never be stored in the secrets management service.

</Callout>

Following are the key features of the <dnt>Secrets management</dnt> service:

* **Assign unique keys to secrets**: Assign a unique key to each secret you store. This key is used to identify the secret when you want to retrieve or manage it later.

* **Store secrets at [account or organization level](/docs/accounts/accounts-billing/account-structure/new-relic-account-structure/)**: Choose to store a secret at the organization level if it needs to be accessed and used across multiple accounts. Alternatively, store it at the account level if the secret is specific to an account and doesn't need to be accessed or used when you're in another account.

* **Maintain multiple versions of secrets**: Update a secret without losing the previous version. The Secrets Management service tracks all versions of a secret, allowing you to retrieve up to 10 previous versions.

* **Soft delete and recover secrets**: Soft delete a secret to temporarily remove it, with the option to recover it later. This is useful if you accidentally delete a secret or need to restore a previous version. You can also purge a secret, which permanently removes it from the system.

* **Control access**: As an admin, you can define who can access the secret by setting custom roles and permissions, and specifying the scope of access. The scope can range from basic read-only access to purge access.

The <dnt>Secrets management</dnt> service is an Advanced Compute Product feature offered as an [add-on](/docs/accounts/accounts-billing/new-relic-one-pricing-billing/add-on-billing) or as a part of the Compute pricing model. Advanced [CCUs](/docs/licenses/license-information/product-definitions/new-relic-one-pricing-definitions/#compute-capacity-unit) are consumed when NerdGraph queries are executed to store, retrieve, or manage secrets.

## Access control[#security-and-access-control]
Users with [standard roles](/docs/accounts/accounts-billing/new-relic-one-user-management/user-management-concepts/#standard-roles) can access the <dnt>Secrets management</dnt> service specifc to the account they have access to, with the following permissions.

* **Read Only**: Users can only retrive secrets. They can not create, update or delete secrets.

* **Standard User**: Users can create, update, retrive and delete (soft delete) secrets.

* **All Product Admin**: Users have full access to the <dnt>Secrets management</dnt> service. They can create, update, retrive, delete (soft delete), purge, and fetch list of secrets.

* **Billing User**: Users can only fetch the list of secrets.

As a Full Platform Admin, you can [create custom roles](/docs/accounts/accounts-billing/new-relic-one-user-management/account-user-mgmt-tutorial/#roles) with the specific permissions to use the <dnt>Secrets management</dnt> service.

If you want a group of users to manage secrets at the organization level, assign the [Organization Manager](/docs/accounts/accounts-billing/new-relic-one-user-management/user-management-concepts/#admin-settings) permission to them. This role allows users to create, update, retrieve, delete (soft delete), purge, and fetch the list of secrets at the organization level.

## Requirements[#review-requirements]
 
To use the secrets management service, you need:

 * A [New Relic account](https://newrelic.com/signup)
 * Your API user key for [queries and mutations]((https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/#terminology)).
 * User type and assigned roles can affect your NerdGraph permissions. For more details, refer [Factors affecting access](https://docs.newrelic.com/docs/accounts/accounts-billing/account-structure/factors-affecting-access-features-data/#user-permissions).

## Use the secrets management service [#use-secrets-management-service]
From the [NerdGraph Explorer](/docs/apis/nerdgraph/get-started/nerdgraph-explorer/), you need to use [mutations and queries](/docs/accounts/accounts-billing/account-structure/factors-affecting-access-features-data/#user-permissions) to interact with the <dnt>Secrets management</dnt> service. Following the operations you can perform with the service:

<CollapserGroup>
  <Collapser 
  id="create-secret" 
  title="store a secret">

Use `secretsManagementCreateSecret` mutation with the following partameters. Go through the data type and description of each attribute to understand how to use them.


<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>
            `description` (Optional)
            </td>
            <td>
            String
            </td>
            <td>
             A brief description for the secret for easy identification. This is useful for providing context about the secret's purpose or usage.
            </td>
        </tr>

        <tr>
            <td>
            `key` (Required)
            </td>
            <td>
            String
            </td>
            <td>
             A unique key for a secret that you want to store. This unique key is used to identify the secret when you want to retrieve or manage it later.
            </td>
        </tr>

        <tr>
            <td>
            `scope` (Required)
            </td>
            <td>
            Enum, string
            </td>
            <td>
            Scope defines who can access the secret.
             * `type`: Select `ACCOUNT` or `ORGANIZATION` based on the user level you want to grant access to.
             * `id`: The ID represents the account or organization from which the users can access the secret.
            </td>
        </tr>

          <tr>
            <td>
            `tags` (Optional)
            </td>
            <td>
            Array
            </td>
            <td>
             A tag is a key-value pair that you can use to add metadata to your entities (such as applications, services, hosts, etc.). Tags help you organize, filter, and manage your entities more effectively. They're particularly useful for sharing secrets within related entities.
            </td>
        </tr>
        <tr>
            <td>
            `namespace`
            </td>
            <td>
            String
            </td>
            <td>
            (Optional) The namespace is a logical grouping of secrets. It helps to organize and categorize secrets, making it easier to manage and avoid potential conflicts, especially when dealing with many secrets across various entities. Namespaces can be particularly useful in environments where many teams or projects are using New Relic.
            </td>
        </tr>
        <tr>
            <td>
            `value`
            </td>
            <td>
            String
            </td>
            <td>
            (Required) The value of the secret.
            </td>
        </tr>
    </tbody>
</table>

#### Sample query:

```graphql
mutation {
  secretsManagementCreateSecret(
    key: "testkey2"
    scope: {id: 1, type: ACCOUNT}
    value: "12345"
  ) {
    description
    latestVersion
    namespace
  }
}

```


#### Response


<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
            `description`
            </td>
            <td>
            String
            </td>
            <td>
            The description of the secret.
            </td>
        </tr>
        <tr>
            <td>
            `latestVersion`
            </td>
            <td>
            String
            </td>
            <td>
            The version of the secret.
            </td>
        </tr>
        <tr>
            <td>
            `namespace`
            </td>
            <td>
            Array
            </td>
            <td>
            The namespace of the secret.
            </td>
        </tr>

    </tbody>
</table>


#### Sample response:
    
    ```json
 {
  "data": {
    "secretsManagementCreateSecret": {
      "description": "",
      "latestVersion": 0,
      "namespace": null
    }
  }
    ```

      </Collapser>

  <Collapser 
    id="delete-secrets" 
    title="Delete a secret">


Use the `secretsManagementDeleteSecret` mutation to perform a soft delete operation, temporarily deleting a version of the secret or all versions of the secret. 
You can recover the deleted version of the secret or all versions of the secret using the `secretsManagementRecoverSecret` mutation.
#### Input attributes

<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>
            `scope`
            </td>
            <td>
            Enum, string
            </td>
            <td>
            (Required) Scope defines the type and ID associated with the secret. The scope type is `ACCOUNT`. If the scope type is `ACCOUNT`, the ID represents the account ID.
            </td>
        </tr>
        <tr>
            <td>
            `key`
            </td>
            <td>
            String
            </td>
            <td>
            (Required) The key for the secret that you want to delete.
            </td>
        </tr>
        <tr>
            <td>
            `namespace`
            </td>
            <td>
            String
            </td>
            <td>
            (Optional) If provided, it deletes the secret associated with the namespace.
            </td>
        </tr>
        <tr>
            <td>
            `purge`
            </td>
            <td>
            Boolean
            </td>
            <td>
            (Required) If true, it deletes all versions of the secret. If false, it soft deletes the latest version of the secret and you can retrive it later.
            </td>
        </tr>
    </tbody>
</table>

#### Sample query:

```graphql

mutation {
  secretsManagementDeleteSecret(
    accountId: 12345678
    key: "test_user_key"
    deleteAll: true
  ) {
    key
    latestVersion
    tags
  }
}

```


#### Response


<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
            `key`
            </td>
            <td>
            String
            </td>
            <td>
            The key of the created secret.
            </td>
        </tr>
        <tr>
            <td>
            `latestVersion`
            </td>
            <td>
            String
            </td>
            <td>
            The latest version available corresponding to the key. If `deleteAll` is true or no version is available after delete, `latestVersion` will be null.
            </td>
        </tr>
    </tbody>
</table>


#### Sample response:

```json
{
  "data": {
    "secretsManagementDeleteSecret": {
      "latestVersion": null
    }
  },
}
```
  </Collapser>

<Collapser 
  id="delete-secrets-version"
  title="Delete a specific version of a secret"
>  


Use the `secretsManagementDeleteSecretVersion` mutation to perform a hard delete. It deletes the secret key permanently from the secrets store and you can't recover.


#### Input attributes


<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
            `scope`
            </td>
            <td>
            Enum, string
            </td>
            <td>
            (Required) Scope defines the type and ID associated with the secret. The scope type is `ACCOUNT`. If the scope type is `ACCOUNT`, the ID represents the account ID.
            </td>
        </tr>
        <tr>
            <td>
            `key`
            </td>
            <td>
            String
            </td>
            <td>
            (Required) The secret key that you permanently want to delete.
            </td>
        </tr>
        <tr>
            <td>
            `namespace`
            </td>
            <td>
            String
            </td>
            <td>
            (Optional) If provided, it deletes the secret associated with the namespace.
            </td>
        </tr>
        <tr>
            <td>
            `purge`
            </td>
            <td>
            Boolean
            </td>
            <td>
            (Required)If true, it deletes all versions of the secret permanently. If false, it deletes the specific version of the secret.
            </td>
        </tr>
        <tr>
            <td>
            `version`
            </td>
            <td>
            String
            </td>
            <td>
            (Optional)The version of the secret to delete permanently.
            </td>
        </tr>
    </tbody>
</table>


#### Sample query:

```graphql

mutation {
    secretsManagementDeleteSecretVersion(
        scope: { type: enum(ACCOUNT)!, id: ID! }!
        key: String!,
        namespace: String,
        purge: Boolean = false,
        version: integer,
    )
}

```

#### Response


<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
            `namespace`
            </td>
            <td>
            String
            </td>
            <td>
            Associated namespace of the secret.
            </td>
        </tr>
        <tr>
            <td>
            `latestVersion`
            </td>
            <td>
            String
            </td>
            <td>
            The available latest version corresponding to the key. If `purgeAll` is true or no version is available after purge, latestVersion will be null.
            </td>
        </tr>
    </tbody>
</table>


#### Sample response:

```json
{
  "data": {
    "secretsManagementDeleteSecretVersion": null
    }
  },
}
```
</Collapser>

<Collapser
  id="recover-secrets"
  title="Recover a secret"
>

Use `secretsManagementRecoverSecret` mutation to recover secrets that you deleted using the `secretsManagementDeleteSecret` mutation before.

#### Input attributes

  <table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
            `scope`
            </td>
            <td>
            Enum, string
            </td>
            <td>
            (Required) Scope defines the type and ID associated with the secret. The scope type is `ACCOUNT`. If the scope type is `ACCOUNT`, the ID represents the account ID.
            </td>
        </tr>
        <tr>
            <td>
            `key`
            </td>
            <td>
            String
            </td>
            <td>
            (Required) The key for the secret.
            </td>
        </tr>
        <tr>
            <td>
            `namespace`
            </td>
            <td>
            String
            </td>
            <td>
            (Optional) The namespace to which the secret belongs.
            </td>
        </tr>

    </tbody>
</table>

#### Sample query:

```graphql
mutation {
  secretsManagementRecoverSecret(key: "testkey2", scope: {id: 1}) {
    latestVersion
    namespace
  }
}
```

#### Response


<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
            `key`
            </td>
            <td>
            String
            </td>
            <td>
            The recovered key.
            </td>
        </tr>
        <tr>
            <td>
            `latestVersion`
            </td>
            <td>
            String
            </td>
            <td>
            The latest version of the recovered secret.
            </td>
        </tr>
    </tbody>
</table>

#### Sample response:

```json
{
  "data": {
    "secretsManagementRecoverSecret": {
      "latestVersion": 0,
      "namespace": null
    }
  },
}
```

</Collapser>

<Collapser
  id="recover-secrets-versions"
  title="Recover a secret version"
>

Use `secretsManagementRecoverSecretVersion` mutation to recover specific versions of the secret that you deleted using the `secretsManagementDeleteSecretVersion` mutation before.

#### Input attributes

  <table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
            `scope`
            </td>
            <td>
            Enum, string
            </td>
            <td>
            (Required) Scope defines the type and ID associated with the secret. The scope type is `ACCOUNT`. If the scope type is `ACCOUNT`, the ID represents the account ID.
            </td>
        </tr>
        <tr>
            <td>
            `key`
            </td>
            <td>
            String
            </td>
            <td>
            (Required) The key for the secret.
            </td>
        </tr>
        <tr>
            <td>
            `namespace`
            </td>
            <td>
            String
            </td>
            <td>
            (Optional) The namespace to which the secret belongs.
            </td>
        </tr>
        <tr>
            <td>
            `version`
            </td>
            <td>
            String
            </td>
            <td>
            (Required) The version of the secret that you want to recover.
            </td>
        </tr>

    </tbody>
</table>

#### Sample query:

```graphql
mutation {
  secretsManagementRecoverSecretVersion(
    key: "testkey2"
    scope: {id: 1, type: ACCOUNT}
  ) {
    latestVersion
    namespace
  }
}
```

#### Response


<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
            `namespace`
            </td>
            <td>
            String
            </td>
            <td>
            The recovered namespace.
            </td>
        </tr>
        <tr>
            <td>
            `latestVersion`
            </td>
            <td>
            String
            </td>
            <td>
            The latest version of the recovered secret.
            </td>
        </tr>
    </tbody>
</table>

#### Sample response:

```json
{
  "data": {
    "secretsManagementRecoverSecret": {
      "latestVersion": 0,
      "namespace": null
    }
  },
}
```

</Collapser>

<Collapser
  id="retrive-secret"
  title="Retrieve a secret"
  >


Retrieve the value of a secret using the `secretsManagementRetrieveSecret` mutation.

### Input attributes

<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
            `accountId`
            </td>
            <td>
            String
            </td>
            <td>
            (Required) The account ID associated with the secret.
            </td>
        </tr>
        <tr>
            <td>
            `key`
            </td>
            <td>
            String
            </td>
            <td>
            (Required) The key of the secret for which you want to retrieve the value.
            </td>
        </tr>
        <tr>
            <td>
            `namespace`
            </td>
            <td>
            String
            </td>
            <td>
            (Optional) The namespace to which the secret belongs.
            </td>
        </tr>
        <tr>
            <td>
            `version`
            </td>
            <td>
            String
            </td>
            <td>
            (Optional) The version of the secret that you want to retrieve.
            </td>
        </tr>
    </tbody>
</table>

#### Sample query:

```graphql
mutation {
  secretsManagementRetrieveSecret(
    accountId: 12345678
    key: "
    test_user_key"
  ) { 
    key
    value
  }
}
```

#### Response

<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
            `createdAt`
            </td>
            <td>
            String
            </td>
            <td>
            The time at which you created the secret.
            </td>
        </tr>
        <tr>
            <td>
            `tags`
            </td>
            <td>
            String
            </td>
            <td>
            The tags associated with the secret.
            </td>
        </tr>
        <tr>
            <td>
            `value`
            </td>
            <td>
            String
            </td>
            <td>
            The value of the secret.
            </td>
        </tr>
    </tbody>

</table>

#### Sample response:

```json
{
  "data": {
    "secretsManagementRetrieveSecret
    ": {
      "key": "test_user_key",
      "value": "1234567890"
    }   
  }
}
```
</Collapser>

<Collapser
  id="update-secret"
  title="Update a secret"
  >


Use the `secretsManagementUpdateSecret` mutation to update the value of existing secrets.

<Callout variant="tip">
Each update operation creates a new version of the secret. The latest version is always the most recent version of the secret.
</Callout>

#### Input Parameters

<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
            `scope`
            </td>
            <td>
            Enum, string
            </td>
            <td>
            (Required) Scope defines the type and ID associated with the secret. The scope type is `ACCOUNT`. If the scope type is `ACCOUNT`, the ID represents the account ID.
            </td>
        </tr>
        <tr>
            <td>
            `key`
            </td>
            <td>
            String
            </td>
            <td>
            (Required) The key of the secret for which you want to update the value.
            </td>
        </tr>
        <tr>
            <td>
            `namespace`
            </td>
            <td>
            String
            </td>
            <td>
            (Optional) The namespace to which the secret belongs.
            </td>
        </tr>
        <tr>
            <td>
            `description`
            </td>
            <td>
            String
            </td>
            <td>
            (Optional) The updated description of the secret.
            </td>
        </tr>

        <tr>
            <td>
            `value`
            </td>
            <td>
            String
            </td>
            <td>
            (Required) The updated value for the key.
            </td>
        </tr>
    </tbody>
</table>

#### Sample query:

```graphql
mutation {
  secretsManagementUpdateSecret(
    namespace: "test"
    key: "test_user_key"
    value: "24680"
  ) {
    key
    latestVersion
    createdAt
    updatedAt
  }
}
```

#### Response

<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
            `createdAt`
            </td>
            <td>
            String
            </td>
            <td>
            The time at which you created the secret.
            </td>
        </tr>
        <tr>
            <td>
            `key`
            </td>
            <td>
            String
            </td>
            <td>
            The key of the secret.
            </td>
        </tr>
        <tr>
            <td>
            `latestVersion`
            </td>
            <td>
            String
            </td>
            <td>
            The version of the created secret.
            </td>
        </tr>
        <tr>
            <td>
            `updatedAt`
            </td>
            <td>
            String
            </td>
            <td>
            The time the secret was last updated.
            </td>
        </tr>
    </tbody>
</table>

#### Sample response:

```json
{
  "data": {
    "secretsManagementUpdateSecret": {
      "createdAt": "2024-10-21T08:01:07.593140Z",
      "key": "test_user_key",
      "latestVersion": 0,
      "updatedAt": "2024-10-21T08:03:26.334448074Z"
    }
  },
}
```
</Collapser>
</CollapserGroup>

## NerdGraph query to retrieve data[#nerdgraph-query]

You can use the `customerAdministration` query to retrieve secret’s metadata and optionally returns the value of a given version.


<table>
    <thead>
        <tr>
            <th style={{ width: "200px" }}>
            **Attribute name**
            </th>
            <th style={{ width: "200px" }}>
            **Data type**
            </th>
            <th>
            **Description**
            </th>
        </tr>
    </thead>
    <tbody>


        <tr>
            <td>
            `key`
            </td>
            <td>
            String
            </td>
            <td>
            (Required) A unique key for a secret that you want to store.
            </td>
        </tr>

        <tr>
            <td>
            `value`
            </td>
            <td>
            String
            </td>
            <td>
            (Required) The value of the secret.
            </td>
        </tr>

        <tr>
            <td>
            `scope`
            </td>
            <td>
            Enum, string
            </td>
            <td>
            (Required) Scope defines the type and ID associated with the secret. The scope type is `ACCOUNT`. If the scope type is `ACCOUNT`, the ID represents the account ID.
            </td>
        </tr>

        <tr>
            <td>
            `namespace`
            </td>
            <td>
            String
            </td>
            <td>
            (Optional) The namespace is a logical grouping of secrets. It helps to organize and categorize secrets, making it easier to manage and avoid potential conflicts, especially when dealing with many secrets across various entities. Namespaces can be particularly useful in environments where many teams or projects are using New Relic.
            </td>
        </tr>
        <tr>
            <td>
            `version`
            </td>
            <td>
            Integer
            </td>
            <td>
            (Optional) The version of the secret that you want to query.
            </td>
        </tr>

        <tr>
            <td>
            `unlock`
            </td>
            <td>
            Boolean
            </td>
            <td>
            (Optional) If true, the secret value is retrieved.
            </td>
        </tr>


    </tbody>
</table>

```graphql
mutation {
    secretsManagementCreateSecret(
        scope: { type: enum(ACCOUNT)!, id: ID! }!
        key: String!
        value: SecureValue!
        namespace: String
        description: String
        tags: [ { key: String!, value: String!} ]
    ) {
        scope: { type: enum(ACCOUNT)!, id: ID! }!
        key
        namespace
        latestVersion
        description
        tags [ { key, value } ]
        metadata {
            createdAt
            updatedAt
        }
    }
}
```













