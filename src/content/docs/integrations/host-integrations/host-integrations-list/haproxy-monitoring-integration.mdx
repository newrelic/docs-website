---
title: HAProxy monitoring integration
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
redirects:
  - /docs/haproxy-integration-new-relic-infrastructure
---

Our HAProxy [integration](https://docs.newrelic.com/docs/integrations/host-integrations/getting-started/introduction-host-integrations) collects and sends inventory and metrics from your HAProxy instance to the New Relic platform, where you can aggregate and visualize key performance metrics for the HAProxy server, frontends, and backends.

Read on to install the integration, and to see what data we collect.

## Compatibility and requirements [#comp-req]

Our integration is compatible with HAProxy versions 1.3 - 2.2.

Before installing the integration, make sure that you meet the following requirements:

* HAProxy statistics page is enabled and accessible.
* If HAProxy is **not** running on Kubernetes or Amazon ECS, you must [install the infrastructure agent](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic) on a host running HAProxy. Otherwise:
  * If running on Kubernetes, see [these requirements](https://docs.newrelic.com/docs/monitor-service-running-kubernetes#requirements).
  * If running on ECS, see [these requirements](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).

## Install and activate [#install]

To install the HAProxy integration, follow the instructions for your environment:

<CollapserGroup>
  <Collapser
    id="ecs-install"
    title="ECS"
  >
    See [Monitor service running on ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
  </Collapser>

  <Collapser
    id="k8s-install"
    title="Kubernetes"
  >
    See [Monitor service running on Kubernetes](/docs/monitor-service-running-kubernetes).
  </Collapser>

  <Collapser
    id="linux-install"
    title="Linux"
  >
    1. Follow the instructions for [installing an integration](/docs/install-integrations-package), using the file name `nri-haproxy`.
    2. Change directory to the integrations folder:

       ```
       cd /etc/newrelic-infra/integrations.d
       ```
    3. Copy the sample configuration file:

       ```
       sudo cp haproxy-config.yml.sample haproxy-config.yml
       ```
    4. Edit the `haproxy-config.yml` file as described in the [configuration settings](#config).
    5. [Restart the infrastructure agent](https://docs.newrelic.com/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).
  </Collapser>

  <Collapser
    id="windows-install"
    title="Windows"
  >
    1. Download the `nri-haproxy` .MSI installer image from:

       [http://download.newrelic.com/infrastructure_agent/windows/integrations/nri-haproxy/nri-haproxy-amd64.msi](http://download.newrelic.com/infrastructure_agent/windows/integrations/nri-haproxy/nri-haproxy-amd64.msi)
    2. To install from the Windows command prompt, run:

       ```
       msiexec.exe /qn /i PATH\TO\nri-haproxy-amd64.msi
       ```
    3. In the Integrations directory, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, create a copy of the sample configuration file by running:

       ```
       cp haproxy-config.yml.sample haproxy-config.yml
       ```
    4. Edit the `haproxy-config.yml` configuration file using the [configuration settings](#config).
    5. [Restart the infrastructure agent](https://docs.newrelic.com/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).
  </Collapser>
</CollapserGroup>

Additional notes:

* **Advanced:** Integrations are also available in [tarball format](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball) to allow for install outside of a package manager.
* **On-host integrations do not automatically update.** For best results, regularly [update the integration package](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) and [the infrastructure agent](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

## Configure [#config]

An integration's YAML-format configuration is where you can place required login credentials and configure how data is collected. Which options you change depend on your setup and preference.

There are several ways to configure the integration, depending on how it was installed:

* If enabled via Kubernetes: see [Monitor services running on Kubernetes](/docs/monitor-service-running-kubernetes).
* If enabled via Amazon ECS: see [Monitor services running on ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
* If installed on-host: edit the config in the integration's YAML config file, `haproxy-config.yml`.

For an example configuration, see the [example config file](#example-config).

<Callout variant="important">
  With secrets management, you can configure on-host integrations with New Relic infrastructure's agent to use sensitive data (such as passwords) without having to write them as plain text into the integration's configuration file. For more information, see [Secrets management](https://docs.newrelic.com/docs/integrations/host-integrations/installation/secrets-management).
</Callout>

### Commands

The configuration accepts these commands:

* `all_data`: collects both inventory and metrics for the HAProxy instance.
* `inventory`: collects only the inventory (configuration) data for the HAProxy instance.
* `metrics`: collects only the metrics data for the HAProxy instance.

### Arguments

The config commands accept the following arguments:

* `username`: The username for the HAProxy connection.
* `password`: The password for the HAProxy connection.
* `stats_url`: A URL pointing to the stats page for HAProxy.
* `cluster_name`: A user-defined name to uniquely identify the cluster being monitored. Required.

### Example configuration [#example-config]

Example `haproxy-config.yml` file configuration:

<CollapserGroup>
  <Collapser
    id="example"
    title="Example configuration"
  >
    ```
    integration_name: com.newrelic.haproxy

    instances:
      - name: haproxy
        # Command can be all_data, metrics, or inventory
        command: all_data
        arguments:
          # The URL to the enabled stats page on the 
          # HAProxy instance
          stats_url: http://haproxy-instance/stats
          # HAProxy Cluster Name
          cluster_name: haproxycluster
          # Basic auth username
          username: cacheuser
          # Basic auth password
          password: password
    ```
  </Collapser>
</CollapserGroup>

For more about the general structure of on-host integration configuration, see [Configuration](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview).

## Find and use data [#find-and-use]

This integration's data is reported to a dedicated New Relic [dashboard](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts).

Metrics are attached to the following [event types](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic):

* `HAProxyBackendSample`
* `HAProxyFrontendSample`
* `HAProxyServerSample`

You can [query this data](/docs/using-new-relic/data/understand-data/query-new-relic-data) for troubleshooting purposes or to create custom charts and dashboards.

For more on how to find and use your data, see [Understand integration data](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Metric data [#metrics]

The HAProxy integration collects the following metric data attributes. Each metric name is prefixed with a category indicator and a period, such as `backend.`, `frontend.`, or `server.`.

### HAProxy backend sample metrics [#backend-sample]

These attributes are attached to the `HAProxyBackendSample` event type:

<Table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Metric
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `backend.activeServers`
      </td>

      <td>
        Number of active servers.
      </td>
    </tr>

    <tr>
      <td>
        `backend.averageConnectTimeInSeconds`
      </td>

      <td>
        Average connect time over the 1024 last requests, in milliseconds.
      </td>
    </tr>

    <tr>
      <td>
        `backend.averageQueueTimeInSeconds`
      </td>

      <td>
        Average queue time over the 1024 last requests, in milliseconds.
      </td>
    </tr>

    <tr>
      <td>
        `backend.averageResponseTimeInSeconds`
      </td>

      <td>
        Average response time over the 1024 last requests, in milliseconds.
      </td>
    </tr>

    <tr>
      <td>
        `backend.averageTotalSessionTimeInSeconds`
      </td>

      <td>
        Average total session time over the 1024 last requests, in milliseconds.
      </td>
    </tr>

    <tr>
      <td>
        `backend.backupServers`
      </td>

      <td>
        Number of backup servers.
      </td>
    </tr>

    <tr>
      <td>
        `backend.bytesInPerSecond`
      </td>

      <td>
        Bytes received per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.bytesOutPerSecond`
      </td>

      <td>
        Bytes sent per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.bytesThatBypassedCompressorPerSecond`
      </td>

      <td>
        Number of bytes that bypassed the HTTP compressor per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectingRequestErrorsPerSecond`
      </td>

      <td>
        Number of requests that encountered an error trying to connect to a backend server per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionRetriesPerSecond`
      </td>

      <td>
        Number of times a connection to a server was retried per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.cookieName`
      </td>

      <td>
        The name of the cookie.
      </td>
    </tr>

    <tr>
      <td>
        `backend.currentQueuedRequestsWithoutServer`
      </td>

      <td>
        Current queued requests without a server assigned.
      </td>
    </tr>

    <tr>
      <td>
        `backend.currentSessions`
      </td>

      <td>
        Number of current sessions.
      </td>
    </tr>

    <tr>
      <td>
        `backend.dataTransfersAbortedByClientPerSecond`
      </td>

      <td>
        Number of data transfers aborted by the client per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.dataTransfersAbortedByServerPerSecond`
      </td>

      <td>
        Number of data transfers aborted by the server per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.downtimeInSeconds`
      </td>

      <td>
        Total downtime in seconds.
      </td>
    </tr>

    <tr>
      <td>
        `backend.http100ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 1xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.http200ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 2xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.http300ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 3xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.http400ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 4xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.http500ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 5xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.httpOtherResponsesPerSecond`
      </td>

      <td>
        HTTP responses with other codes (protocol error) per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.httpRequestsPerSecond`
      </td>

      <td>
        HTTP requests per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.httpResponseBytesEmittedByCompressorPerSecond`
      </td>

      <td>
        Number of HTTP response bytes emitted by the compressor per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.httpResponseBytesFedToCompressorPerSecond`
      </td>

      <td>
        Number of HTTP response bytes fed to the compressor per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.httpResponsesCompressedPerSecond`
      </td>

      <td>
        Number of HTTP responses that were compressed per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.interceptedRequestsPerSecond`
      </td>

      <td>
        Intercepted requests per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.maxQueuedRequestsWithoutServer`
      </td>

      <td>
        Maximum queued requests without a server assigned.
      </td>
    </tr>

    <tr>
      <td>
        `backend.maxSessions`
      </td>

      <td>
        Maximum number of sessions.
      </td>
    </tr>

    <tr>
      <td>
        `backend.maxSessionsPerSecond`
      </td>

      <td>
        Maximum number of new sessions per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.mode`
      </td>

      <td>
        The proxy mode. Options: tcp, http, health, unknown.
      </td>
    </tr>

    <tr>
      <td>
        `backend.proxyName`
      </td>

      <td>
        The name of the proxy.
      </td>
    </tr>

    <tr>
      <td>
        `backend.requestRedispatchPerSecond`
      </td>

      <td>
        Number of times a request was redispatched to another server per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.requestsDenied.securityConcernPerSecond`
      </td>

      <td>
        Requests denied bytcp-request connection rules per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.responseErrorsPerSecond`
      </td>

      <td>
        Response errors per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.responsesDenied.securityConcernPerSecond`
      </td>

      <td>
        Requests denied bytcp-request session rules per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.serverSelectedPerSecond`
      </td>

      <td>
        Number of times a server was selected per second, either for new sessions, or when re-dispatching.
      </td>
    </tr>

    <tr>
      <td>
        `backend.sessionsPerSecond`
      </td>

      <td>
        Sessions created per second.
      </td>
    </tr>

    <tr>
      <td>
        `backend.status`
      </td>

      <td>
        Status. Options: UP, DOWN, NOLB, MAINT, MAINT(via), MAINT(resolution).
      </td>
    </tr>

    <tr>
      <td>
        `backend.timeSinceLastSessionAssignedInSeconds`
      </td>

      <td>
        Number of seconds since last session assigned to backend.
      </td>
    </tr>

    <tr>
      <td>
        `backend.timeSinceLastUpDownTransitionInSeconds`
      </td>

      <td>
        Number of seconds since the last UP&lt;->DOWN transition.
      </td>
    </tr>

    <tr>
      <td>
        `backend.totalWeight`
      </td>

      <td>
        Total weight of the backend.
      </td>
    </tr>

    <tr>
      <td>
        `backend.type`
      </td>

      <td>
        Type of backend. `0` = frontend, `1` = backend, `2` = server, `3` = socket/listener.
      </td>
    </tr>

    <tr>
      <td>
        `backend.upToDownTransitionsPerSecond`
      </td>

      <td>
        Number of UP->DOWN transitions per second.
      </td>
    </tr>
  </tbody>
</Table>

### HAProxy frontend sample metrics [#frontend-sample]

These attributes are attached to the `HAProxyFrontendSample` event type:

<Table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Metric
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `frontend.bytesInPerSecond`
      </td>

      <td>
        Number of bytes received per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.bytesOutPerSecond`
      </td>

      <td>
        Number of bytes sent per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.connectionsPerSecond`
      </td>

      <td>
        Number of connections per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.currentSessions`
      </td>

      <td>
        Number of current sessions.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.http100ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 1xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.http200ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 2xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.http300ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 3xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.http400ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 4xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.http500ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 5xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.httpOtherResponsesPerSecond`
      </td>

      <td>
        HTTP responses with other codes (protocol error).
      </td>
    </tr>

    <tr>
      <td>
        `frontend.httpRequests.maxPerSecond`
      </td>

      <td>
        Max number of HTTP requests per second observed.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.httpRequestsPerSecond`
      </td>

      <td>
        HTTP requests per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.interceptedRequestsPerSecond`
      </td>

      <td>
        Intercepted requests per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.maxConnectionsPerSecond`
      </td>

      <td>
        Maximum number of connections.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.maxSessions`
      </td>

      <td>
        Maximum number of sessions.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.maxSessionsPerSecond`
      </td>

      <td>
        Maximum number of new sessions per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.mode`
      </td>

      <td>
        Proxy mode. One of tcp, http, health, unknown.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.proxyName`
      </td>

      <td>
        The name of the proxy.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.requestErrors`
      </td>

      <td>
        Request errors per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.requestsDenied.securityConcernsPerSecond`
      </td>

      <td>
        Requests denied because of security concerns per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.requestsDenied.tcpRequestConnectionRulesPerSecond`
      </td>

      <td>
        Requests denied bytcp-request connection rules per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.requestsDenied.tcpRequestSessionRulesPerSecond`
      </td>

      <td>
        Requests denied bytcp-request session rules per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.responsesDenied.securityConcernsPerSecond`
      </td>

      <td>
        Responses denied because of security concerns per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.serviceName`
      </td>

      <td>
        The name of the service.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.sessionsPerSecond`
      </td>

      <td>
        Sessions created per second.
      </td>
    </tr>

    <tr>
      <td>
        `frontend.status`
      </td>

      <td>
        The status of the frontend. Options: UP, DOWN, NOLB, MAINT, MAINT(via), MAINT(resolution).
      </td>
    </tr>

    <tr>
      <td>
        `frontend.type`
      </td>

      <td>
        Type of frontend. `0` = frontend, `1` = backend, `2` = server, `3` = socket/listener.
      </td>
    </tr>
  </tbody>
</Table>

### HAProxy server sample metrics [#server-sample]

These attributes are attached to the `HAProxyServerSample` event type:

<Table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Metric
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `server.agentCheckContents`
      </td>

      <td>
        Last agent check contents or textual error.
      </td>
    </tr>

    <tr>
      <td>
        `server.agentDurationInSeconds`
      </td>

      <td>
        Time taken to finish last check, in milliseconds.
      </td>
    </tr>

    <tr>
      <td>
        `server.agentStatus`
      </td>

      <td>
        Status of the agent.
      </td>
    </tr>

    <tr>
      <td>
        `server.agentStatusDescription`
      </td>

      <td>
        Short human-readable description of `agent_status`.
      </td>
    </tr>

    <tr>
      <td>
        `server.averageConnectTimeInSeconds`
      </td>

      <td>
        Average connect time over the 1024 last requests, in milliseconds.
      </td>
    </tr>

    <tr>
      <td>
        `server.averageQueueTimeInSeconds`
      </td>

      <td>
        Average queue time over the 1024 last requests, in milliseconds.
      </td>
    </tr>

    <tr>
      <td>
        `server.averageResponseTimeInSeconds`
      </td>

      <td>
        Average response time over the 1024 last requests, in milliseconds.
      </td>
    </tr>

    <tr>
      <td>
        `server.averageTotalSessionTimeInSeconds`
      </td>

      <td>
        Average total session time over the 1024 last requests, in milliseconds.
      </td>
    </tr>

    <tr>
      <td>
        `server.bytesInPerSecond`
      </td>

      <td>
        Bytes received per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.bytesOutPerSecond`
      </td>

      <td>
        Bytes sent per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.checkStatusDescription`
      </td>

      <td>
        Short human-readable description of `check_status`.
      </td>
    </tr>

    <tr>
      <td>
        `server.connectingToBackendRequestErrorsPerSecond`
      </td>

      <td>
        Number of requests that encountered an error trying to connect to a backend server per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.connectionRetriesPerSecond`
      </td>

      <td>
        Number of times a connection to a server was retried per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.cookieValue`
      </td>

      <td>
        Server's cookie value.
      </td>
    </tr>

    <tr>
      <td>
        `server.currentSessions`
      </td>

      <td>
        Number of current sessions.
      </td>
    </tr>

    <tr>
      <td>
        `server.dataTransfersAbortedByClientPerSecond`
      </td>

      <td>
        Number of data transfers aborted by the client per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.dataTransfersAbortedByServerPerSecond`
      </td>

      <td>
        Number of data transfers aborted by the server per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.downtimeInSeconds`
      </td>

      <td>
        Total downtime in seconds.
      </td>
    </tr>

    <tr>
      <td>
        `server.failedChecksPerSecond`
      </td>

      <td>
        Number of failed checks per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.failedHealthCheckDetails`
      </td>

      <td>
        Failed health check details.
      </td>
    </tr>

    <tr>
      <td>
        `server.healthCheckContents`
      </td>

      <td>
        Last health check contents or textual error.
      </td>
    </tr>

    <tr>
      <td>
        `server.healthCheckDurationInMilliseconds`
      </td>

      <td>
        Time it took to finish the last health check, in milliseconds.
      </td>
    </tr>

    <tr>
      <td>
        `server.healthCheckStatus`
      </td>

      <td>
        Health check status.
      </td>
    </tr>

    <tr>
      <td>
        `server.http100ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 1xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.http200ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 2xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.http300ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 3xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.http400ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 4xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.http500ResponsesPerSecond`
      </td>

      <td>
        HTTP responses with 5xx code per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.httpOtherResponsesPerSecond`
      </td>

      <td>
        HTTP responses with other codes (protocol error).
      </td>
    </tr>

    <tr>
      <td>
        `server.isActive`
      </td>

      <td>
        Whether the server is active. `0` = Inactive, `1` = Active.
      </td>
    </tr>

    <tr>
      <td>
        `server.isBackup`
      </td>

      <td>
        Whether the server is a backup. `0` = Not Backup, `1` = Backup.
      </td>
    </tr>

    <tr>
      <td>
        `server.layerCode`
      </td>

      <td>
        Layer 5-7 code, if available.
      </td>
    </tr>

    <tr>
      <td>
        `server.maximumQueuedRequests`
      </td>

      <td>
        Maximum queued requests.
      </td>
    </tr>

    <tr>
      <td>
        `server.maxSessions`
      </td>

      <td>
        Number of maximum sessions.
      </td>
    </tr>

    <tr>
      <td>
        `server.maxSessionsPerSecond`
      </td>

      <td>
        Max sessions per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.mode`
      </td>

      <td>
        Proxy mode. One of tcp, http, health, unknown.
      </td>
    </tr>

    <tr>
      <td>
        `server.proxyName`
      </td>

      <td>
        The name of the proxy.
      </td>
    </tr>

    <tr>
      <td>
        `server.queuedRequests`
      </td>

      <td>
        Current queued requests.
      </td>
    </tr>

    <tr>
      <td>
        `server.requestRedispatchPerSecond`
      </td>

      <td>
        Number of times a request was redispatched to another server per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.requestsDenied.securityConcernPerSecond`
      </td>

      <td>
        Requests denied because of security concerns per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.responseErrorsPerSecond`
      </td>

      <td>
        Response errors per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.responsesDenied.securityConcernPerSecond`
      </td>

      <td>
        Responses denied because of security concerns per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.serverID`
      </td>

      <td>
        The server ID.
      </td>
    </tr>

    <tr>
      <td>
        `server.serverSelectedPerSecond`
      </td>

      <td>
        Number of times a server was selected per second, either for new sessions, or when re-dispatching.
      </td>
    </tr>

    <tr>
      <td>
        `server.serverWeight`
      </td>

      <td>
        The server weight.
      </td>
    </tr>

    <tr>
      <td>
        `server.serviceName`
      </td>

      <td>
        The name of the service.
      </td>
    </tr>

    <tr>
      <td>
        `server.sessionsPerSecond`
      </td>

      <td>
        Sessions per second.
      </td>
    </tr>

    <tr>
      <td>
        `server.status`
      </td>

      <td>
        The status of the server. Options: UP, DOWN, NOLB, MAINT, MAINT(via), MAINT(resolution).
      </td>
    </tr>

    <tr>
      <td>
        `server.throttlePercentage`
      </td>

      <td>
        Throttle percentage for the server, when slowstart is active. Or no value if not in slowstart.
      </td>
    </tr>

    <tr>
      <td>
        `server.timeSinceLastSessionAssignedInSeconds`
      </td>

      <td>
        Number of seconds since last session assigned to backend.
      </td>
    </tr>

    <tr>
      <td>
        `server.timeSinceLastUpDownTransitionInSeconds`
      </td>

      <td>
        Number of seconds since the last UP&lt;->DOWN transition.
      </td>
    </tr>

    <tr>
      <td>
        `server.type`
      </td>

      <td>
        The type of server. `0` = frontend, `1` = backend, `2` = server, `3` = socket/listener.
      </td>
    </tr>

    <tr>
      <td>
        `server.upToDownTransitionsPerSecond`
      </td>

      <td>
        Number of UP->DOWN transitions per second.
      </td>
    </tr>
  </tbody>
</Table>

## Inventory data [#inventory]

The HAProxy integration captures the configuration parameters of the HAProxy instance. The data is available on the infrastructure [Inventory page](/docs/infrastructure/new-relic-infrastructure/infrastructure-ui-pages/infrastructure-inventory-page-search-your-entire-infrastructure), under the **config/haproxy** source. For more about inventory data, see [Understand integration data](/docs/infrastructure/integrations-getting-started/getting-started/understand-integration-data-data-types#inventory-data).

The integration captures data for the following configuration parameters:

### Backend inventory

<Table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `iid`
      </td>

      <td>
        The backend proxy ID.
      </td>
    </tr>

    <tr>
      <td>
        `pid`
      </td>

      <td>
        The backend process ID.
      </td>
    </tr>

    <tr>
      <td>
        `slim`
      </td>

      <td>
        The backend session limit.
      </td>
    </tr>
  </tbody>
</Table>

### Frontend inventory

<Table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `iid`
      </td>

      <td>
        The frontend proxy ID.
      </td>
    </tr>

    <tr>
      <td>
        `pid`
      </td>

      <td>
        The frontend process ID.
      </td>
    </tr>

    <tr>
      <td>
        `rate_lim`
      </td>

      <td>
        New session per second limit.
      </td>
    </tr>

    <tr>
      <td>
        `slim`
      </td>

      <td>
        The frontend session limit.
      </td>
    </tr>
  </tbody>
</Table>

### Server inventory

<Table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Name
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `iid`
      </td>

      <td>
        The backend proxy ID.
      </td>
    </tr>

    <tr>
      <td>
        `pid`
      </td>

      <td>
        The server process ID.
      </td>
    </tr>

    <tr>
      <td>
        `qmax`
      </td>

      <td>
        The configured max queue. `0` = no limit.
      </td>
    </tr>

    <tr>
      <td>
        `sid`
      </td>

      <td>
        The server ID.
      </td>
    </tr>

    <tr>
      <td>
        `slim`
      </td>

      <td>
        The server session limit.
      </td>
    </tr>
  </tbody>
</Table>

## Check the source code [#source-code]

This integration is open source software. That means you can [browse its source code](https://github.com/newrelic/nri-haproxy "Link opens in a new window.") and send improvements, or create your own fork and build it.
