---
title: Diagnose slow transactions
metaDescription: Improve transaction performance with the New Relic transactions UI.
---

import journeyIntro from 'images/journey_screenshot-intro.webp'
import journeyConsuming from 'images/journey_screenshot-consuming.webp'
import journeySegment from 'images/journey_screenshot-segment.webp'
import journeySlow from 'images/journey_screenshot-slow.webp'

## Objectives [#objectives]



<SideBySide>
    <Side>
By the end of this tutorial, you will:

* Understand transactions and traces
* Have identified any problematic transactions
* Reviewed and optimized problematic segments in your app
    </Side>
    <Side>
  <img
  title="Transaction home page"
  alt="The transactions home page"
  src={journeyIntro}
  />
    </Side>
</SideBySide>


## The what and why of transactions [#why]

Customer activity on your web app creates routes through your code that begin when an app receives a web request and ends when a response returns. These routes are transactions, or a unit of work made up of function calls and method calls. Think about a critical business point, like a customer submitting payment on a purchase. If a customer reports that their payment either failed to process or processed after significant delay, you’re left guessing about the cause of that failure. Did an API cause the failure, or was it a recent bug fix deployed earlier that day? 

## Observe transactions to improve performance [#observe]

Our transactions UI helps you diagnose the source of a problem so you can improve the performance of specific transactions. The following steps guide you through identifying slow transactions and improving your apps performance:

<Steps>
    <Step>
    Navigate to the transactions UI: Go to **[one.newrelic.com](https://one.newrelic.com/nr1-core) > APM & services > (select an app) > Monitor > Transactions**
    </Step>
    <Step>

    Find your slow transactions: 

    1. Sort your transactions by most time consuming on the top of the page.
    2. Take a look at the **Top 20 transactions** chart. This list represents the best opportunity to reduce load of your application. Shaving time off these frequently called transactions will reduce the footprint of your application as they are high volume requests. Take note of the top few transactions in this chart.
    3. Sort your transactions by slowest average response on the top of the page.
    4. Take a look at the **Top 20 transactions** chart again. This chart now shows the average time per request from the total volume of a particular request. Take note of the top few transactions in this chart.
    <SideBySide>
    <Side>
  <img
  title="Most consuming transactions chart"
  alt="Most consuming transactions chart"
  src={journeyConsuming}
  />
    </Side>
    <Side>
  <img
  title="Slowest transactions chart"
  alt="Slowest transactions chart"
  src={journeySlow}
  />
</SideBySide>
    </Step>
    <Step>

    Improve your performance:

    <SideBySide>
    <Side>
    You’ve identified what transactions may cause delays in your code, but knowing about an issue isn’t the same as finding a solution for your customers. With the transactions identified above, you can find a breakdown of where in your code this particular route spends the most time.
    </Side>
    <Side>
  <img
  title="The transaction segment view"
  alt="The transactions segment view"
  src={journeySegment}
  />
    </Side>
</SideBySide>

    For each of your transactions, click on their name in the top 20 chart and do the following:

    1. Check the segment breakdown chart. This shows where your request spends most of its time. If, on average, a route stalls in one part of your code, then focus on optimizing in that segment.
    2. Check the transaction traces table and gather your slowest traces. While your slowest traces are outliers, they’re good indicators of what methods, databases, or HTTP calls have the biggest impact on your app’s performance.

    Use the information above to optimize your application at a code level.
    </Step>
</Steps>


## Check your work [#check]

You’ve scoped out the problem and found a potential solution. Push your fix to development, then run a typical load test to get a sense for how your app will run in production. 

As you monitor your response times, keep a close eye on your app’s transactions. 

* Are your transactions normal? You're done!
* Did they improve? Use what you've learned to figure out why they improved beyond normal. 
* Are you still seeing slow response times? Maybe there's a [database problem](/docs/journey-app-slow/slow-database-queries), or maybe your [external services]() are running slowly:

<DocTiles numbered>
  <DocTile title='Prepare to triage your application' path="/docs/journey-app-slow/root-causes" ></DocTile>
  <DocTile title='Identify problematic transactions' label={{text: 'Current doc', color: '#87CEFA'}} path="/docs/journey-app-slow/problematic-transactions" ></DocTile>
</DocTiles>

<DocTiles>
  <DocTile title='Identify slow database queries' number='3' path="/docs/journey-app-slow/slow-database-queries" ></DocTile>
  <DocTile title='Identify slow external services' number='4' path="/docs/journey-app-slow/external-services" ></DocTile>
  <DocTile title='Create performance benchmarks' number='5' path="/docs/journey-app-slow/create-benchmarks/" ></DocTile>
</DocTiles>