---
title: Service Architecture Intelligence with GitHub Enterprise (on-premises)
tags:
  - New Relic integrations
  - GitHub Enterprise integration
metaDescription: Integrate your on-premise GitHub Enterprise (GHE) environment with New Relic using a secure collector service and GitHub App for automated data ingestion.
freshnessValidatedDate: never
---

<Callout title="PREVIEW">

  We're still working on this feature, but we'd love for you to try it out!

  This feature is currently provided as part of a preview program pursuant to our [pre-release policies](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy).
</Callout>

Are you looking to gain deeper insights into your service architecture by leveraging data from your on-premise GitHub Enterprise account? The New Relic GitHub Enterprise integration imports repositories, teams, and user data directly into the New Relic platform using a secure collector service deployed within your private network.

This integration streamlines the onboarding process for users and teams while simplifying role management. It also clarifies entity ownership mapping, reducing setup time and effort. Due to the restricted nature of GHE environments, integration is achieved via a local collector service deployed within your private network. This integration aims to enhance the management and visibility of [Catalogs](/docs/service-architecture-intelligence/catalogs/catalogs) and [Scorecards](/docs/service-architecture-intelligence/scorecards/getting-started) within New Relic. For more information, refer to the [Service Architecture Intelligence capability](/docs/service-architecture-intelligence/getting-started).

**Prerequisites**

* GitHub Enterprise on-premises account that you want to integrate with New Relic.
* Docker environment to run the collector service within your GHE network.

**To set up the GitHub Enterprise integration:**

1. **Create and configure a GitHub app**: In your GHE instance, navigate to **Settings → Developer Settings → GitHub Apps → New GitHub App**. For detailed instructions on creating a GitHub App, refer to the [GitHub documentation on registering a GitHub App](https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/registering-a-github-app).
    
    a. **Configure Permissions**: Set the specific permissions required for the app to perform real-time and initial data syncs. For detailed guidance on GitHub App permissions, refer to the [GitHub documentation on setting permissions for GitHub Apps](https://docs.github.com/en/apps/creating-github-apps/setting-up-a-github-app/setting-permissions-for-github-apps).
    b. **Set Up Webhooks**: Configure the Webhook URL and create a custom Event Secret for secure communication:

       - **Webhook URL**: Use the following format based on your collector service deployment:
         - For HTTP: `http://your-collector-host:8080/webhook`
         - For HTTPS: `https://your-collector-host:8443/webhook`

         **Example**: If your collector service is deployed at `collector.yourcompany.com`, the webhook URL would be:
         `https://collector.yourcompany.com:8443/webhook`

       - **Event Secret**: Generate a secure random string (32+ characters) for webhook authentication. Save this value as you'll need it for the `EVENT_SECRET` environment variable.
    c. **Install the App**: Install the created GitHub App on the relevant GHE organizations that you want to integrate with New Relic.
    d. **Generate Keys**: Upon creation, the app will generate a unique App ID and a Private Key file (.pem format). Save these securely as they will be needed for the collector service configuration.
    e. **Convert Private Key to Base64**: The collector service requires the private key in Base64 format. Convert your downloaded private key file using the following command:

       ```bash
       # For Linux/macOS
       base64 -i your-private-key.pem

       # For Windows (using PowerShell)
       [Convert]::ToBase64String([IO.File]::ReadAllBytes("your-private-key.pem"))

       # Alternative for Windows (using certutil)
       certutil -encode your-private-key.pem temp.b64 && findstr /v /c:- temp.b64
       ```

       Copy the resulting Base64 string and use it as the value for `GITHUB_APP_PRIVATE_KEY` environment variable in your collector configuration.

2. **Prepare environment variables**: Before deploying the collector service, gather the following information:

    <table>
      <thead>
        <tr>
          <th>Variable</th>
          <th>Source</th>
          <th>How to obtain</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>`NR_API_KEY`</td>
          <td>New Relic</td>
          <td>Generate an API key from the New Relic dashboard.</td>
        </tr>
        <tr>
          <td>`NR_LICENSE_KEY`</td>
          <td>New Relic</td>
          <td>Generate a License Key from the New Relic dashboard.</td>
        </tr>
        <tr>
          <td>`GHE_BASE_URL`</td>
          <td>GHE Server</td>
          <td>The base URL for your GHE server (e.g., `https://source.datanot.us`).</td>
        </tr>
        <tr>
          <td>`GITHUB_APP_ID`</td>
          <td>GitHub App</td>
          <td>The unique App ID generated when you created the GitHub App.</td>
        </tr>
        <tr>
          <td>`GITHUB_APP_PRIVATE_KEY`</td>
          <td>GitHub App</td>
          <td>The content of the private key (`.pem`) file, converted to a Base64 string. We will provide the necessary conversion command.</td>
        </tr>
        <tr>
          <td>`EVENT_SECRET`</td>
          <td>GitHub App</td>
          <td>The custom Event Secret value you set when creating the GitHub App.</td>
        </tr>
      </tbody>
    </table>

    The following are optional environment variables for making API HTTPS.

    <table>
      <thead>
        <tr>
          <th>Optional Variable</th>
          <th>Source</th>
          <th>How to obtain</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>`SERVER_SSL_KEY_STORE`</td>
          <td>SSL Configuration</td>
          <td>Path to the SSL keystore file for HTTPS configuration. See SSL certificate setup instructions below.</td>
        </tr>
        <tr>
          <td>`SERVER_SSL_KEY_STORE_PASSWORD`</td>
          <td>SSL Configuration</td>
          <td>Password for the SSL keystore file. This is the password you set when creating the PKCS12 keystore.</td>
        </tr>
        <tr>
          <td>`SERVER_SSL_KEY_STORE_TYPE`</td>
          <td>SSL Configuration</td>
          <td>Type of the SSL keystore (e.g., PKCS12, JKS). Use PKCS12 when following the SSL setup instructions below.</td>
        </tr>
        <tr>
          <td>`SERVER_SSL_KEY_ALIAS`</td>
          <td>SSL Configuration</td>
          <td>Alias for the SSL key within the keystore. This is the name you specify when creating the keystore.</td>
        </tr>
        <tr>
          <td>`SERVER_PORT`</td>
          <td>SSL Configuration</td>
          <td>Server port for HTTPS communication. Use 8443 for HTTPS.</td>
        </tr>
      </tbody>
    </table>

    **SSL Certificate Setup Instructions**

    To obtain an SSL certificate from a trusted Certificate Authority (CA) for HTTPS configuration, follow these steps:

    1. **Generate a private key and a Certificate Signing Request (CSR)**:

       ```bash
       openssl req -new -newkey rsa:2048 -nodes -keyout mycert.key -out mycert.csr
       ```

    2. **Submit the CSR to your chosen CA**: Submit the `mycert.csr` file to your chosen Certificate Authority (e.g., DigiCert, Let's Encrypt, GoDaddy).

    3. **Complete domain validation**: Complete any required domain validation steps as instructed by the CA.

    4. **Download the certificate**: Download the issued certificate files from the CA (commonly a `.crt` or `.pem` file).

    5. **Create a PKCS12 keystore**: Combine the certificate and private key into a PKCS12 keystore:

       ```bash
       openssl pkcs12 -export -in mycert.crt -inkey mycert.key -out keystore.p12 -name mycert
       ```

    6. **Use the keystore**: Use the generated `keystore.p12` file as the value for `SERVER_SSL_KEY_STORE` in your Docker configuration.

3. **Deploy the collector service**: The collector service is delivered as a Docker image. Deployment can be done in one of two ways:

    **Option A: Using Docker Compose (Recommended)**

    We will provide a sample Docker Compose file that automates the download and deployment of the service.

    a. Download the provided Docker Compose file.
    b. Configure the environment variables as described in step 2.
    c. Run the following command:

       ```bash
       docker-compose up -d
       ```

    **Option B: Direct Docker image run**

    You can download the Docker image directly from our [Docker Hub registry](https://hub.docker.com/repository/docker/newrelic/nr-ghe-collector/general) and run it using your organization's preferred CI/CD pipeline or deployment method.

4. **Access the New Relic UI**: 
    
    1. Once the collector service is running and the GitHub App is installed on your GHE organization(s), the corresponding GHE organizations will appear in the New Relic UI.
    2. Click **First time sync** to start the initial data synchronization.
    3. *(Optional)* Click **On-demand sync** to manually sync the data.

        <Callout variant="tip" title="tip">

            You can manually synchronize the data once every 4 hours. The **On-demand sync** button remains disabled if sync has occurred within the previous 4 hours.

        </Callout>

    4. After you view the Sync started message, click **Continue**. The **GitHub Enterprise Integration** screen will then display the count of teams and repositories, refreshing every 5 seconds. Allow a few minutes for the complete import of all data.

5. On the **GitHub Enterprise integration** screen:

    - Click **Go to Teams** to view the imported teams information on [Teams](/docs/service-architecture-intelligence/teams/teams).
    - Click **Go to Repositories** to view the imported repositories information on [Catalogs](/docs/service-architecture-intelligence/catalogs/catalogs).

**Assigning repositories to New Relic Teams**

You can auto-assign GitHub repositories to their teams by adding `teamOwningRepo` as a custom property in GitHub Enterprise.

1. Create the custom property at the organization level and assign a value for the custom property at the repository level. Additionally, you can set up a custom property for multiple repositories at the organization level simultaneously.
2. Then, in New Relic Teams, enable the [Automated Ownership](/docs/service-architecture-intelligence/teams/manage-teams/#assign-ownership) feature, making sure to use `team` as the tag key.

Once this is set up, we'll automatically match each repo with its correct team.

For more information on creating custom properties, refer to the [GitHub documentation](https://docs.github.com/en/organizations/managing-organization-settings/managing-custom-properties-for-repositories-in-your-organization).

**Uninstallation**

To uninstall the GHE integration, you must:

1. Navigate to your GitHub Enterprise UI.
2. Go to the organization's settings where the app is installed.
3. Uninstall the GitHub App directly from the GHE interface. This action will trigger the backend process to cease data collection.


