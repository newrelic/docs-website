---
title: Built-in log parsing rules
tags:
  - Logs
  - Log management
  - UI and data
metaDescription: "A list of all New Relic's log parsing rules, which you can use to easily parse common log formats."
redirects:
  - /docs/logs/new-relic-logs/ui-data/new-relic-logs-parsing-built-rules-custom-parsing
  - /docs/logs/log-management/ui-data/new-relic-logs-parsing-built-rules-custom-parsing
  - /docs/logs/log-management/ui-data/logs-parsing-built-rules-custom-parsing
  - /docs/logs/log-management/ui-data/built-log-parsing-rulesets
  - /docs/logs/ui-data/built-log-parsing-rulesets
---

New Relic can parse common log formats according to built-in rules, so that you don't have to create your own parsing rules. Here are the log parsing rules, their [Grok](https://grokdebug.herokuapp.com/patterns# "Link opens in a new window.") patterns, and what fields are parsed.

* To enable built-in log parsing, see our documentation for [adding the `logtype` attribute](/docs/logs/ui-data/parsing#logtype).
* To manage your parsing rules programmatically, use NerdGraph, our GraphQL-format API, at [api.newrelic.com/graphiql](https://api.newrelic.com/graphiql). For more information, see the [NerdGraph tutorial](/docs/apis/nerdgraph/examples/nerdgraph-log-parsing-rules-tutorial) to create, query, and delete your parsing rules.

<CollapserGroup>
  <Collapser
    id="apache"
    title="Apache"
  >
    Source: `logtype = 'apache'`

    Grok:

    ```grok
    %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent}
    ```

    **Results:**

    * `clientip`: The IP address of the client.
    * `verb`: The HTTP verb
    * `ident`: The user identity of the client making the request
    * `response`: The HTTP status code of the response
    * `request`: The URI and request being made
    * `httpversion`: The HTTP version of the request
    * `rawrequest`: The raw HTTP request if data is posted
    * `bytes`: The number of bytes sent
    * `referrer`: The HTTP referrer
    * `agent`: The client's user agent
  </Collapser>

  <Collapser
    id="apache_error"
    title="Apache Error"
  >
    Source: `logtype = 'apache_error'`

    Grok:

    ```grok
    \[%{DATA:apache_error.timestamp}\] \[%{WORD:apache_error.source}:%{DATA:level}\] \[pid %{NUMBER:apache_error.pid}(:tid %{NUMBER:apache_error.tid})?\] (%{DATA:apache_error.sourcecode}\(%{NUMBER:apache_error.linenum}\): )?(?:\[client %{IPORHOST:apache_error.clientip}:%{POSINT:apache_error.port}\] ){0,1}%{GREEDYDATA:apache_error.message}
    ```

    ### Results

    * `apache_error.timestamp`: The timestamp of the log statement
    * `apache_error.source`: The source module
    * `level`: The log level
    * `apache_error.pid`: The apache PID (process identifier)
    * `apache_error.tid`: The apache TID (thread identifier)
    * `apache_error.sourcecode`: The apache sourcecode
    * `apache_error.linenum`: The sourcecode line number
    * `apache_error.clientip`: The client IP address
    * `apache_error.port`: The client IP port number
    * `apache_error.message`: The error message
  </Collapser>

  <Collapser
    id="application-load-balancer"
    title="Application Load Balancer"
  >
    Source: `logtype = 'alb'`

    Grok:

    ```grok
    ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} "%{DATA:request}" "%{DATA:user_agent}" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} "%{DATA:trace_id}" "%{NOTSPACE:domain_name}" "%{NOTSPACE:chosen_cert_arn}" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} "%{NOTSPACE:actions_executed}" "%{NOTSPACE:redirect_url}" "%{NOTSPACE:error_reason}" (?:"|)%{DATA:target_port_list}(?:"|) (?:"|)%{DATA:target_status_code_list}(?:"|) "%{NOTSPACE:classification}" "%{NOTSPACE:classification_reason}"
    ```

    ### Results

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Field
          </th>

          <th>
            Definition
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `type`
          </td>

          <td>
            The type of request or connection. Possible values are:

            * `http`:  HTTP
            * `https`: HTTP over SSL/TLS
            * `h2`: HTTP/2 over SSL/TLS
            * `ws`: WebSockets
            * `wss`: WebSockets over SSL/TLS
          </td>
        </tr>

        <tr>
          <td>
            `elb`
          </td>

          <td>
            The resource ID of the load balancer. If you are parsing access log entries, note that resources IDs can contain forward slashes (`/`).
          </td>
        </tr>

        <tr>
          <td>
            `client`
          </td>

          <td>
            The IP address and port of the requesting client
          </td>
        </tr>

        <tr>
          <td>
            `target`
          </td>

          <td>
            The IP address and port of the target that processed this request.

            * If the client didn't send a full request, the load balancer can't dispatch the request to a target, and this value is set to `-`.
            * If the target is a Lambda function, this value is set to `-`.
            * If the request is blocked by AWS WAF, this value is set to `-`, and the value of `elb_status_code` is set to `403`.
          </td>
        </tr>

        <tr>
          <td>
            `request_processing_time`
          </td>

          <td>
            The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the request until the time it sent it to a target.

            * This value is set to `-1` if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request.
            * This value can also be set to `-1` if the registered target does not respond before the idle timeout.
          </td>
        </tr>

        <tr>
          <td>
            `target_processing_time`
          </td>

          <td>
            The total time elapsed (in seconds, with millisecond precision) from the time the load balancer sent the request to a target until the target started to send the response headers.

            * This value is set to `-1` if the load balancer can't dispatch the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request.
            * This value can also be set to `-1` if the registered target does not respond before the idle timeout.
          </td>
        </tr>

        <tr>
          <td>
            `response_processing_time`
          </td>

          <td>
            The total time elapsed (in seconds, with millisecond precision) from the time the load balancer received the response header from the target until it started to send the response to the client. This includes both the queuing time at the load balancer and the connection acquisition time from the load balancer to the client.

            This value is set to `-1` if the load balancer can't send the request to a target. This can happen if the target closes the connection before the idle timeout or if the client sends a malformed request.
          </td>
        </tr>

        <tr>
          <td>
            `elb_status_code`
          </td>

          <td>
            The status code of the response from the load balancer
          </td>
        </tr>

        <tr>
          <td>
            `target_status_code`
          </td>

          <td>
            The status code of the response from the target. This value is recorded only if a connection was established to the target and the target sent a response. Otherwise, it is set to `-`.
          </td>
        </tr>

        <tr>
          <td>
            `received_bytes`
          </td>

          <td>
            The size of the request, in bytes, received from the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes received from the client on the connection.
          </td>
        </tr>

        <tr>
          <td>
            `sent_bytes`
          </td>

          <td>
            The size of the response, in bytes, sent to the client (requester). For HTTP requests, this includes the headers. For WebSockets, this is the total number of bytes sent to the client on the connection.
          </td>
        </tr>

        <tr>
          <td>
            `method`
          </td>

          <td>
            The HTTP verb of the request
          </td>
        </tr>

        <tr>
          <td>
            `uri`
          </td>

          <td>
            The URI the request was targeting
          </td>
        </tr>

        <tr>
          <td>
            `http_version`
          </td>

          <td>
            The HTTP version number of the request
          </td>
        </tr>

        <tr>
          <td>
            `user_agent`
          </td>

          <td>
            User-Agent string that identifies the client that originated the request, enclosed in double quotes. The string consists of one or more product identifiers, product/version. If the string is longer than 8 KB, it is truncated.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            The SSL cipher. This value is set to `-` if the listener is not an HTTPS listener.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            The SSL protocol. This value is set to `-` if the listener is not an HTTPS listener.
          </td>
        </tr>

        <tr>
          <td>
            `target_group_arn`
          </td>

          <td>
            The Amazon Resource Name (ARN) of the target group
          </td>
        </tr>

        <tr>
          <td>
            `trace_id`
          </td>

          <td>
            The contents of the `X-Amzn-Trace-Id header`, enclosed in double quotes
          </td>
        </tr>

        <tr>
          <td>
            `domain_name`
          </td>

          <td>
            The SNI domain provided by the client during the TLS handshake, enclosed in double quotes. This value is set to `-` if the client doesn't support SNI or the domain doesn't match a certificate and the default certificate is presented to the client.
          </td>
        </tr>

        <tr>
          <td>
            `chosen_cert_arn`
          </td>

          <td>
            The ARN of the certificate presented to the client, enclosed in double quotes.

            * Set to `session-reused` if the session is reused.
            * Set to `-` if the listener is not an HTTPS listener.
          </td>
        </tr>

        <tr>
          <td>
            `matched_rule_priority`
          </td>

          <td>
            The priority value of the rule that matched the request.

            * If a rule matched, this is a value from `1` to `50000`.
            * If no rule matched and the default action was taken, this value is set to `0`.
            * If an error occurs during rules evaluation, it is set to `-1`.
            * For any other error, it is set to `-`.
          </td>
        </tr>

        <tr>
          <td>
            `request_creation_time`
          </td>

          <td>
            The time when the load balancer received the request from the client, in ISO 8601 format.
          </td>
        </tr>

        <tr>
          <td>
            `actions_executed`
          </td>

          <td>
            The actions taken when processing the request, enclosed in double quotes. This value is a comma-separated list that can include the values described in `actions_taken`. If no action was taken, such as for a malformed request, this value is set to `-`.
          </td>
        </tr>

        <tr>
          <td>
            `redirect_url`
          </td>

          <td>
            The URL of the redirect target for the location header of the HTTP response, enclosed in double quotes. If no redirect actions were taken, this value is set to `-`.
          </td>
        </tr>

        <tr>
          <td>
            `error_reason`
          </td>

          <td>
            The error reason code, enclosed in double quotes.

            * If the request failed, this is one of the error codes described in Error Reason Codes.
            * If the actions taken do not include an authenticate action or the target is not a Lambda function, this value is set to `-`.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="cloudfront"
    title="Cloudfront"
  >
    **Source:** `logtype = 'cloudfront-web'`

    **Grok:**

    ```
    ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end}
    ```

    **Results:**

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Field
          </th>

          <th>
            Definition
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, `DFW3`.

            The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.)
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, `1045619`. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            The IP address of the viewer that made the request, either in IPv4 or IPv6 format. If the viewer used an HTTP proxy or a load balancer to send the request, the value of `c_ip` is the IP address of the proxy or load balancer. See also `X-Forwarded-For`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            The HTTP request method: `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, or `PUT`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            The domain name of the CloudFront distribution; for example, `d111111abcdef8.cloudfront.net`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            The portion of the URI that identifies the path and object; for example, `/images/cat.jpg`. Question marks in URLs and query strings are not included.
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            An HTTP status code; for example, `200`. Status code `000` indicates the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request. If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code.
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            The name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website.
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request, and which search engine if applicable.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            The cookie header in the request, including name-value pairs and the associated attributes.

            * If you enable cookie logging, CloudFront logs the cookies in all requests regardless of which cookies you choose to forward to the origin.
            * If a request doesn't include a cookie header, this field's value is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            An encrypted string that uniquely identifies a request. In the response header, this is `x-amz-cf-id`.
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            The value that the viewer included in the Host header for this request. This is the domain name in the request.

            * If you're using the CloudFront domain name in your object URLs, this field contains that domain name.
            * If you're using alternate domain names in your object URLs, such as `http://example.com/logo.png`, this field contains the alternate domain name, such as `example.com`. To use alternate domain names, you must add them to your distribution.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            The protocol that the viewer specified in the request: `http`, `https`, `ws`, or `wss`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection.
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server.

            From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering.
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            If the viewer used an HTTP proxy or a load balancer to send the request, the value of `c_ip` in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request.

            This field contains IPv4 and IPv6 addresses as applicable. If the viewer did not use an HTTP proxy or a load balancer, the value of `x_forwarded_for` is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            When `cs_protocol` in field 17 is `https`, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include:

            * SSLv3
            * TLSv1
            * TLSv1.1
            * TLSv1.2

              When `cs_protocol` in field 17 is `http`, the value for this field is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            When `cs_protocol` in field 17 is `https`, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include:

            * `ECDHE-RSA-AES128-GCM-SHA256`
            * `ECDHE-RSA-AES128-SHA256`
            * `ECDHE-RSA-AES128-SHA`
            * `ECDHE-RSA-AES256-GCM-SHA384`
            * `ECDHE-RSA-AES256-SHA384`
            * `ECDHE-RSA-AES256-SHA`
            * `AES128-GCM-SHA256`
            * `AES256-GCM-SHA384`
            * `AES128-SHA256`
            * `AES256-SHA`
            * `AES128-SHA`
            * `DES-CBC3-SHA`
            * `RC4-MD5`

              When `cs_protocol` in field 17 is `http`, the value for this field is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            How CloudFront classified the response just before returning the response to the viewer. Possible values include:

            * `Hit`: CloudFront served the object to the viewer from the edge cache.
            * `RefreshHit`: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object.
            * `Miss`: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer.
            * `LimitExceeded`: The request was denied because a CloudFront limit was exceeded.
            * `CapacityExceeded`: CloudFront returned a `503` error because the edge location didn't have enough capacity at the time of the request to serve the object.
            * `Error`: Typically this means the request resulted in a client error (`sc_status` is `4xx`) or a server error (`sc_status` is `5xx`). If the value of `x_edge_result_type` is `Error` and the value of this field is **not** `Error`, the client disconnected before finishing the download.
            * `Redirect`: CloudFront redirects from HTTP to HTTPS. If `sc_status` is `403` and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            The HTTP version that the viewer specified in the request. Possible values include:

            * `HTTP/0.9`
            * `HTTP/1.0`
            * `HTTP/1.1`
            * `HTTP/2.0`
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed.

            If field-level encryption is not configured for the distribution, the value is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `fle-encrypted-fields`
          </td>

          <td>
            The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so `fle-encrypted-fields` can have a value even if the value of `fle-status` is an error.

            If field-level encryption is not configured for the distribution, the value of `fle-encrypted-fields` is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            The port number of the request from the viewer.
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            The number of seconds between receiving the request and writing the first byte of the response, as measured on the server.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            When `x-edge-result-type` **is not** `Error`, this field contains the same value as `x-edge-result-type`. When `x-edge-result-type` **is** `Error`, this field contains the specific type of error.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            The value of the HTTP Content-Type header of the response.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            The value of the HTTP Content-Length header of the response.
          </td>
        </tr>

        <tr>
          <td>
            `sc_range_start`
          </td>

          <td>
            When the response contains the HTTP Content-Range header, this field contains the range start value.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            When the response contains the HTTP Content-Range header, this field contains the range end value.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="elastic-load-balancer"
    title="Elastic Load Balancer"
  >
    Source: `logtype = 'elb'`

    Grok:

    ```grok
    ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} "%{DATA:request}" "%{DATA:user_agent}" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol}
    ```

    ### Results

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Field
          </th>

          <th>
            Definition
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            The edge location that served the request. Each edge location is identified by a three-letter code and an arbitrarily assigned number; for example, `DFW3`. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.)
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            The total number of bytes that CloudFront served to the viewer in response to the request, including headers; for example, `1045619`. For WebSocket connections, this is the total number of bytes sent from the server to the client through the connection.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            The IP address of the viewer that made the request. If the viewer used an HTTP proxy or a load balancer to send the request, the value of `c_ip` is the IP address of the proxy or load balancer.
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            The HTTP request method: `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, or `PUT`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            The domain name of the CloudFront distribution; for example, `d111111abcdef8.cloudfront.net`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            The portion of the URI that identifies the path and object; for example, `/images/cat.jpg`. Question marks (`?`) in URLs and query strings are not included in the log.
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            An HTTP status code (for example, `200`). Status code `000` indicates that the viewer closed the connection (for example, closed the browser tab) before CloudFront could respond to a request.

            If the viewer closes the connection after CloudFront starts to send the response, the log contains the applicable HTTP status code.
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            he name of the domain that originated the request. Common referrers include search engines, other websites that link directly to your objects, and your own website.
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            The value of the User-Agent header in the request. The User-Agent header identifies the source of the request, such as the type of device and browser that submitted the request and which search engine if applicable.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            The query string portion of the URI, if any. When a URI doesn't contain a query string, this field's value is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            The cookie header in the request, including name-value pairs and the associated attributes.

            * If you enable cookie logging, CloudFront logs the cookies in all requests, regardless of which cookies you choose to forward to the origin.
            * If a request doesn't include a cookie header, this field's value is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            How CloudFront classifies the response after the last byte left the edge location. In some cases, the result type can change between the time that CloudFront is ready to send the response and the time that CloudFront has finished sending the response.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            An encrypted string that uniquely identifies a request. In the response header, this is `x-amz-cf-id`.
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            The value that the viewer included in the Host header for this request. This is the domain name in the request.

            * If you're using the CloudFront domain name in your object URLs, this field contains that domain name.
            * If you're using alternate domain names in your object URLs, such as `[http://example.com/logo.png`, this field contains the alternate domain name, such as `example.com`. To use alternate domain names, you must add them to your distribution.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            The protocol that the viewer specified in the request: `http`, `https`, `ws`, or `wss`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            The number of bytes of data that the viewer included in the request, including headers. For WebSocket connections, this is the total number of bytes sent from the client to the server on the connection.
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            The number of seconds (to the thousandth of a second; for example, 0.002) between the time that a CloudFront edge server receives a viewer's request and the time that CloudFront writes the last byte of the response to the edge server's output queue as measured on the server.

            From the perspective of the viewer, the total time to get the full object will be longer than this value due to network latency and TCP buffering.
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            If the viewer used an HTTP proxy or a load balancer to send the request, the value of `c_ip` in field 5 is the IP address of the proxy or load balancer. In that case, this field is the IP address of the viewer that originated the request. This field contains IPv4 and IPv6 addresses as applicable.

            If the viewer did not use an HTTP proxy or a load balancer, the value of `x_forwarded_for` is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            When `cs_protocol` in field 17 is `https`, this field contains the SSL/TLS protocol that the client and CloudFront negotiated for transmitting the request and response. Possible values include:

            * SSLv3
            * TLSv1
            * TLSv1.1
            * TLSv1.2
              When `cs_protocol` in field 17 is `http`, the value for this field is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            When `cs_protocol` in field 17 is `https`, this field contains the SSL/TLS cipher that the client and CloudFront negotiated for encrypting the request and response. Possible values include:

            * `ECDHE-RSA-AES128-GCM-SHA256`
            * `ECDHE-RSA-AES128-SHA256`
            * `ECDHE-RSA-AES128-SHA`
            * `ECDHE-RSA-AES256-GCM-SHA384`
            * `ECDHE-RSA-AES256-SHA384`
            * `ECDHE-RSA-AES256-SHA`
            * `AES128-GCM-SHA256`
            * `AES256-GCM-SHA384`
            * `AES128-SHA256`
            * `AES256-SHA`
            * `AES128-SHA`
            * `DES-CBC3-SHA`
            * `RC4-MD5`

              When `cs_protocol` is `http`, the value for this field is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            How CloudFront classified the response just before returning the response to the viewer. Possible values include:

            * `Hit`: CloudFront served the object to the viewer from the edge cache.
            * `RefreshHit`: CloudFront found the object in the edge cache but it had expired, so CloudFront contacted the origin to verify that the cache has the latest version of the object.
            * `Miss`: The request could not be satisfied by an object in the edge cache, so CloudFront forwarded the request to the origin server and returned the result to the viewer.
            * `LimitExceeded`: The request was denied because a CloudFront limit was exceeded.
            * `CapacityExceeded`: CloudFront returned a `503` error because the edge location didn't have enough capacity at the time of the request to serve the object.
            * `Error`: Typically this means the request resulted in a client error (`sc_status` is `4xx`) or a server error (`sc_status` is `5xx`). If the value of `x_edge_result_type` is `Error` and the value of this field is **not** `Error`, the client disconnected before finishing the download.
            * `Redirect`: CloudFront redirects from HTTP to HTTPS. If `sc_status` is `403` and you configured CloudFront to restrict the geographic distribution of your content, the request might have come from a restricted location.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            The HTTP version that the viewer specified in the request. Possible values include:

            * `HTTP/0.9`
            * `HTTP/1.0`
            * `HTTP/1.1`
            * `HTTP/2.0`
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            When field-level encryption is configured for a distribution, this field contains a code that indicates whether the request body was successfully processed. If field-level encryption is not configured for the distribution, the value of this field is a hyphen (`-`).

            When CloudFront successfully processes the request body, encrypts values in the specified fields, and forwards the request to the origin, the value of this field is `Processed`. The value of `x_edge_result_type` can still indicate a client-side or server-side error in this case.

            If the request exceeds a field-level encryption limit, `fle-status` contains one of the following error codes, and CloudFront returns HTTP status code `400` to the viewer.
          </td>
        </tr>

        <tr>
          <td>
            `fle-encrypted-fields`
          </td>

          <td>
            The number of fields that CloudFront encrypted and forwarded to the origin. CloudFront streams the processed request to the origin as it encrypts data, so `fle_encrypted_fields` can have a value even if the value of `fle_status` is an error.

            If field-level encryption is not configured for the distribution, the value of `fle_encrypted_fields` is a hyphen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            The port number of the request from the viewer.
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            The number of seconds between receiving the request and writing the first byte of the response, as measured on the server.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            When `x_edge_result_type` **is not** `Error`, this field contains the same value as `x_edge_result_type`. When `x_edge_result_type` **is** `Error`, this field contains the specific type of error.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            The value of the HTTP Content-Type header of the response.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            The value of the HTTP Content-Length header of the response.
          </td>
        </tr>

        <tr>
          <td>
            `sc_range_start`
          </td>

          <td>
            When the response contains the HTTP Content-Range header, this field contains the range start value.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            When the response contains the HTTP Content-Range header, this field contains the range end value.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="haproxy"
    title="HAProxy"
  >
    Source: `logtype = 'haproxy_http'`

    Grok:

    ```grok
    %{HOSTPORT:client} \\[%{NOTSPACE:haproxy_timestamp}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{NUMBER:time_queue}/%{NUMBER:time_backend_connect}/%{NUMBER:time_duration} %{NUMBER:bytes_read} %{NOTSPACE:termination_state} %{NUMBER:actconn}/%{NUMBER:feconn}/%{NUMBER:beconn}/%{NUMBER:srvconn}/%{NUMBER:retries} %{NUMBER:srv_queue}/%{NUMBER:backend_queue}
    ```

    ```
    %{HOSTPORT:client} \\[%{NOTSPACE:haproxy_timestamp}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{NUMBER:time_client_req}/%{NUMBER:time_queue}/%{NUMBER:time_backend_connect}/%{NUMBER:time_server_response}/%{NUMBER:time_duration} %{NUMBER:status_code} %{NUMBER:bytes_read} %{NOTSPACE:captured_request_cookie} %{NOTSPACE:captured_response_cookie} %{NOTSPACE:termination_state_with_cookie_status} %{NUMBER:actconn}/%{NUMBER:feconn}/%{NUMBER:beconn}/%{NUMBER:srvconn}/%{NUMBER:retries} %{NUMBER:srv_queue}/%{NUMBER:backend_queue}?( \\\"%{GREEDYDATA:full_http_request}\\\")?( %{NOTSPACE:captured_response_headers})?
    ```

    ### Results

    * `client`: Source IP/Port of this request
    * `haproxy_timestamp`: Timestamp when this request was accepted
    * `frontend_name`: Name of the frontend used in this request
    * `backend_name`: Name of the backend used in this request
    * `server_name`: Server name in the backend group used in this request
    * `time_client_req`: Time waiting for full request from client (ms)
    * `time_queue`: Time waiting in queues (ms)
    * `time_backend_connect`: Time to establish connection to destination server (ms)
    * `time_server_response`: Time for destination server to send response (ms)
    * `time_duration`: Total time request active in HAProxy (ms)
    * `status_code`: HTTP response code
    * `bytes_read`: Total bytes read in this request
    * `captured_request_cookie`: Captured cookie from the request
    * `captured_response_cookie`: Captured cookie from the response
    * `termination_state`: Session state at disconnection
    * `termination_state_with_cookie_status`: Session state, including cookie status, at disconnection
    * `actconn`: Active connections
    * `feconn`: Front-end connections
    * `beconn`: Back-end connections
    * `srvconn`: Server connections
    * `retries`: Retries
    * `srv_queue`: Server queue size
    * `backend_queue`: Back-end queue size
    * `full_http_request`: The complete HTTP request line
    * `captured_response_headers`: Captured header from the response
  </Collapser>

  <Collapser
    id="ktranslate-health"
    title="KTranslate Health"
  >
    Source: `logtype = 'ktranslate-health'`

    Grok:

    ```grok
    %{NOTSPACE:timestamp} ktranslate(/)?(%{GREEDYDATA:container_service})? \[%{NOTSPACE:severity}] %{GREEDYDATA:message}
    ```

    ### Results

    * `timestamp`: The time of the log
    * `container_service`: The unique identifier used to distinguish containers in ktranslate. This is set during Docker runtime with the optional `--service_name` flag
    * `severity`: The severity of the log line
    * `message`: The message field contains a free-form message that provides information about the event
  </Collapser>

  <Collapser
    id="iis"
    title="Microsoft IIS"
  >
    Source: `logtype = 'iis_w3c'`

    Grok:

    ```grok
    %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken}
    ```
    
    <Callout variant="important">
      IIS allows for several <a href="https://docs.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms524877(v=vs.90)">configuration options</a>.
      If you've configured any options outside of the default, our Grok pattern won't parse your logs.
      In this case, we recommended that you use <a href="https://docs.newrelic.com/docs/logs/ui-data/parsing/#custom-parsing">custom parsing</a>.
    </Callout>
    
  </Collapser>

  <Collapser
    id="mongodb"
    title="Mongodb"
  >
    Source: `logtype = 'mongodb'`

    Grok:

    ```grok
    %{TIMESTAMP_ISO8601:mongodb.timestamp} %{WORD:mongodb.severity} %{WORD:mongodb.component} *\[%{WORD:mongodb.context}\] %{GREEDYDATA:mongodb.message}
    ```

    ### Results

    * `mongodb.timestamp`: The timestamp of the log statement
    * `mongodb.severity`: The severity level of the log statement (F=Fatal, E=Error, W=Warning, I=Informational, D1-5=Debug)
    * `mongodb.component`: The category of the thread issuing the log statement
    * `mongodb.context`: The name of the thread issuing the log statement
    * `mongodb.message`: The raw mongodb message
  </Collapser>

  <Collapser
    id="monit"
    title="Monit"
  >
    Source: `logtype = 'monit'`

    Grok:

    ```grok
    \\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message}
    ```

    ### Results

    * `state`: The severity of the log line
    * `message`: The message
  </Collapser>

  <Collapser
    id="mysql-error"
    title="MySQL Error"
  >
    Source: `logtype = 'mysql-error'`

    Grok:

    ```grok
    \\[%{WORD:log_level}\\]
    ```

    ### Results

    * `log_level`: The severity of the log line
  </Collapser>

  <Collapser
    id="nginx"
    title="NGINX"
  >
    Source: `logtype = 'nginx'`

    Grok:

    ```grok
    %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent}
    ```

    ### Results

    * `clientip`: The IP address of the client
    * `verb`: The HTTP verb
    * `ident`: The user identity of the client making the request
    * `response`: The HTTP status code of the response
    * `request`: The URI and request being made
    * `httpversion`: The HTTP version of the request
    * `rawrequest`: The raw HTTP request if data is posted
    * `bytes`: The number of bytes sent
    * `referrer`: The HTTP referrer
    * `agent`: The client's user agent
  </Collapser>

  <Collapser
    id="nginx-error"
    title="NGINX Error"
  >
    Source: `logtype = 'nginx-error'`

    Grok:

    ```grok
    ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \\[%{LOGLEVEL:severity}\\] %{POSINT:pid}#%{NUMBER}: %{GREEDYDATA:errormessage}(?:, client: (?<client>%{IP:clientip}|%{HOSTNAME:hostname}))(?:, server: %{IPORHOSTORUNDERSCORE:server})(?:, request: %{QS:request})?(?:, upstream: \"%{URI:upstream}\")?(?:, host: %{QS:host})?(?:, referrer: \"%{URI:referrer}\")?$
    ```

    ### Results

    * `severity`: The severity of the log line
    * `pid`: The server process ID
    * `errormessage`: The error message
    * `clientip`: The IP address of the calling client
    * `server`: The server IP address
    * `request`: The full request
    * `upstream`: The upstream URI
    * `host`: The server's hostname
    * `referrer`: The HTTP referrer
  </Collapser>

  <Collapser
    id="rabbitmq"
    title="Rabbitmq"
  >
    Source: `logtype = 'rabbitmq'`

    Grok

    ```grok
    %{TIMESTAMP_ISO8601:rabbitmq.timestamp} \[%{LOGLEVEL:rabbitmq.log.level}\] \<%{DATA:rabbitmq.pid}\> %{GREEDYDATA:rabbitmq.message}
    ```

    ### Results

    * `redistimestamp`: The timestamp of the log
    * `rabbitmq.log.level`: The log level of the message (debug, info, warning, error, critical, none)
    * `rabbitmq.pid`: The process id of the log line
    * `rabbitmq.message`: The rabbitmq error message
  </Collapser>

  <Collapser
    id="redis"
    title="Redis"
  >
    Source: `logtype = 'redis'`

    Grok:

    ```grok
    %{POSINT:redis.pid}:%{NOTSPACE:redis.role} (?<redistimestamp>[\d-]+ [a-zA-Z]+ [\d]+ [\d:]+.[\d]{3}) %{NOTSPACE:redis.log.level} %{GREEDYDATA:redis.message}
    ```

    ### Results

    * `redis.pid`: The process id of the log line
    * `redis.role`: The role for the instance (X sentinel, C RDB/AOF writing child, S slave, M master)
    * `redistimestamp`: The timestamp of the log
    * `redis.log.level`: The log level of the message (. debug, - verbose, \* notice, # warning)
    * `redis.message`: The redis error message
  </Collapser>

  <Collapser
    id="route53"
    title="Route 53"
  >
    Source: `logtype = 'route-53'`

    Grok:

    ```grok
    %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet}
    ```

    ### Results

    * `log_format_version`: A versioned format for the log.
    * `zone_id`: The ID of the hosted zone that is associated with all the DNS queries in this log.
    * `query`: The domain or subdomain that was specified in the request.
    * `query_type`: Either the DNS record type that was specified in the request, or `ANY`.
    * `response_code`: The DNS response code that Route 53 returned in response to the DNS query.
    * `protocol`: The protocol that was used to submit the query, either TCP or UDP.
    * `edge_location`: The Route 53 edge location that responded to the query. Each edge location is identified by a three-letter code and an arbitrary number; for example, `DFW3`. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.)
    * `resolver_ip`: The IP address of the DNS resolver that submitted the request to Route 53.
    * `edns_client_subnet`: A partial IP address for the client that the request originated from, if available from the DNS resolver.
  </Collapser>

  <Collapser
    id="syslog-rfc5424"
    title="Syslog RFC-5424"
  >
    Source: `logtype = 'syslog-rfc5424'`

    Grok:

    ```grok
    <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\-|%{NOTSPACE:app.name}) +(?:\\-|%{NOTSPACE:procid}) (?:\\-|%{NOTSPACE:msgid}) +(?:\[%{DATA:structured.data}\]|-|) +%{GREEDYDATA:message}
    ```

    ### Results

    * `pri`: The priority represents both the message facility and severity.
    * `version`: Syslog protocol version.
    * `log.timestamp`: Original timestamp.
    * `hostname`: The machine that originally sent the Syslog message.
    * `app.name`: The device or application that originated the message.
    * `procid`: The process name or process ID associated with a Syslog system.
    * `msgid`: Identifies the type of message.
    * `structured.data`: Structured data string value.
    * `sd.<var>sd-id</var>.<var>sd-param-name</var>`: The `structured.data` content is also parsed into separate attributes following a predefined naming convention: `sd.<var>sd-id</var>.<var>sd-param-name</var>`. See the structured data parsing examples, which follow.
    * `message`: Free-form message that provides information about the event.

      #### Structured data parsing examples:

      The structured data `[example one="1" two="2"]` would be parsed into two different attributes:

      ```
      sd.example.one: "1"
      sd.example.two: "2"
      ```

      If the same structured data block contains duplicate param names, it also appends an index-based suffix on the attribute name. For example, the structured data `[example number="1" number="2"]` would be parsed as:

      ```
      sd.example.number.0: "1"
      sd.example.number.1: "2"
      ```

      For structured data with enterprise numbers assigned, an extra attribute is also parsed. For example, the structured data `[example@123 number="1"]` would be parsed as:

      ```
      sd.example.enterprise.number: 123
      sd.example.number: "1"
      ```
  </Collapser>
</CollapserGroup>
