---
title: 'OpenTelemetry in the UI: JVMs page'
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: Here are some tips for understanding the OpenTelemetry JVMs page in the New Relic UI.
freshnessValidatedDate: never
---

After you've sent us your OpenTelemetry data and opened your service (entity) in the UI, click **JVMs** to identify which service instances have unusual or unhealthy performance patterns related to the behavior of the Java Virtual Machine.

You can choose several service instances to compare based on summaries of key metrics: response time, throughput, error rate, garbage collection time, and memory usage. Then, you can compare all those instances' JVM metrics collected by OpenTelemetry instrumentation using timeseries charts to spot problems.

Here's a typical workflow:

1. Click **JVMs**.
2. Find interesting JVMs using the table of summarized health metrics:
   * Use the filter bar to narrow down your search
   * Sort the columns of metric values to find outliers
3. Select those interesting JVMs.
4. Click **Compare** to see a display of the health and runtime metrics faceted by JVM.

You can also view all the runtime metrics for a single JVM by clicking the name of the instance in the table.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="metric-details"
    title="Runtime metric details"
  >
    When you compare JVMs or drill into a single JVM, you will see several timeseries charts of runtime metric data, including garbage collection and memory usage. The JVM-specific runtime metrics are specified in the [OpenTelemetry semantic conventions](https://opentelemetry.io/docs/reference/specification/metrics/semantic_conventions/runtime-environment-metrics/#jvm-metrics) and [implemented](https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/instrumentation/runtime-metrics/library/src/main/java/io/opentelemetry/instrumentation/runtimemetrics) in recent versions of the OTel auto-instrumentation agent.
  </Collapser>

  <Collapser
    className="freq-link"
    id="config-steps"
    title="How to ensure your data appears"
  >
    For your data to appear in this section, make sure it has the following:

    * The OpenTelemetry resource attribute `service.instance.id`, used to group JVM metrics by instance
  </Collapser>

  <Collapser
    className="freq-link"
    id="jvms-and-metric-types"
    title="Gauges versus counters"
  >
We recommend you use the OpenTelemetry Java agent 1.13.0 or higher, which collects JVM memory usage as an asynchronous gauge. These agent versions allow you to view metrics in New Relic without the workarounds you'd need to do if you were using older agents.

If you're using older OpenTelemetry Java agents (versions 1.10.0 through 1.12.0), keep in mind that JVM memory usage switched from being collected as an asynchronous gauge to an asynchronous UpDownCounter. This has implications on the exported data. Gauges and counters export differently:

* Asynchronous gauges export as OTLP gauges.
* Asynchronous UpDownCounters export as OTLP non-monotonic sums.

If you configure your SDK to export metrics using delta aggregation temporality (which is required for counter and histogram instruments to function with New Relic), that results in asynchronous UpDownCounters exported as non-monotonic delta sums. New Relic can't perform any useful analysis of non-monotonic delta sum data.

If you have to use OpenTelemetry Java agent versions 1.10.0 through 1.12.0, the workaround is to use the View API to indicate that asynchronous UpDownCounters should be aggregated using [last value aggregation](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#last-value-aggregation) instead of the default sum aggregation. This results in JVM memory usage being exported as gauge data, which is required for a useful experience in New Relic.

The way you configure the View API varies based on whether you're using the OpenTelemetry Java agent:

* If you are using the OpenTelemetry Java agent, you need to configure the View API in an [extension](https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/agent-config.md#extensions). Extensions allow you to hook into the SDK configuration (among other things) and apply programmatic configuration that isn't available by environment variables or system properties. This [example](https://github.com/newrelic/newrelic-opentelemetry-examples/tree/main/other-examples/java/agent-nr-config) demonstrates how you can use an extension to [customize](https://github.com/newrelic/newrelic-opentelemetry-examples/blob/main/java/agent-nr-config/config-extension/src/main/java/com/newrelic/otel/extension/Customizer.java#L28-L37) the `SdkMeterProvider`'s views.
* If you're not using the OpenTelemetry Java agent, review this simple [example](https://github.com/newrelic/newrelic-opentelemetry-examples/pull/89/files#diff-da355ef6d1092534a55829e95160ab8468884bdd521f9018feeaaa66aea6ac5bR82-R86) that shows how to register a view when configuring `SdkMeterProvider`.
  </Collapser>
</CollapserGroup>

To learn about OpenTelemetry in other UI pages, see the [UI overview](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-view-your-data).
