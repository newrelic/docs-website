---
title: Compare  New Relic agents with OpenTelemetry
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: Compare the feature of New Relic agents with OpenTelemetry
---
If you're a New Relic APM user considering whether to migrate to OpenTelemetry, the following comparisons may help you make your decision. New Relic APM and OpenTelemetry are like similar wrenches in your toolbox: the challenge is to choose the one best suited for what you want to accomplish.

## _Mock-up 1: Without groupings by menu sections_

* * *

## Summary page [#summary]

_Using a table for the yes/no doesn't look great since it spans the entire width!_
<table>
  <tbody>
    <tr>
      <td>
        APM agent
      </td>
      <td>
        ✅
      </td>
    </tr>
    <tr>
      <td>
        OpenTelemetry
      </td>
      <td>
        ✅
      </td>
    </tr>
  </tbody>
</table>

_Putting the Yes/No side-by-side seems pretty scannable:_

APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ✅

The **Summary** page offers an overview of a service’s health, charting golden signals about your entity: response time, throughput, and error rate. These are also broken down by service instance ID (OpenTelemetry) or hostname (New Relic agent).

OpenTelemetry services use spans to create golden signals, whereas New Relic agent services use metrics.

## Distributed tracing [#dt]

APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ✅

Distributed tracing is supported today by our agents and OpenTelemetry. Both provide W3C Trace Context compatibility. Furthermore, OpenTelemetry supports W3C Baggage, highly configurable sampling options, and events on spans, or "span events" as they're referred to in New Relic.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="trace-context"
    title="W3C Trace Context"
  >
  APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ✅

  This support means that in a distributed system where some services are instrumented with OpenTelemetry and others with APM agents, trace context can be propagated successfully from one service to the next. This gives you visibility into activity across the system even when you use more than one instrumentation technology.
  </Collapser>
  <Collapser
    className="freq-link"
    id="baggage"
    title="W3C Baggage"
  >
  _Stacking the Yes/No doesn't seem quite as scannable:_
  
  APM agent: ❌

  OpenTelemetry: ✅

  In OpenTelemetry, baggage is a mechanism to propagate key:value pairs. It allows for observability events in a downstream service to be indexed with attributes provided by an upstream service in the same transaction/trace, without having to pull the attributes from a database. For instance, a user ID added as baggage will be accessible to downstream services, and they can then also index their spans and metrics by the user ID.

  You can view baggage in New Relic in the form of attributes on data, such as spans. The  baggage specification is only focused on the propagation of data, not the presentation. For instance, you can add the user ID from the example above to a span to view it as an attribute on that span in New Relic.
  </Collapser>
  <Collapser
    className="freq-link"
    id="sampling"
    title="Sampling"
  >
  
  APM agent: ✅

  OpenTelemetry: ✅

  APM agents support both head- and tail-based sampling, which you can implement by enabling distributed tracing or Infinite Tracing, respectively.

  OpenTelemetry SDKs by default implement parent-based sampling, though there are a number of built-in samplers that are available to choose from.

  Additionally, OpenTelemetry offers a standalone service called a collector, a configurable telemetry-processing system. This means you can configure a custom sampling strategy (or strategies) that makes the most sense for your observability needs. However, configuring and operating collectors can be complex. Another option for tail-based sampling with OpenTelemetry is using New Relic’s Infinite Tracing with OTLP. There is a tail-based sampling processor available today for the collector, but it is in the process of being deprecated in favor of a more native solution.
  </Collapser>
  <Collapser
    className="freq-link"
    id="span-events"
    title="Span events"
  >

  APM agent: ❌

  OpenTelemetry: ✅ 

  Clarification on terminology: In New Relic documentation, “span event” in the context of APM agents refers to event data of type `Span`, which is how segments of distributed traces are stored in NRDB. “Span events” as a distinct data type are not supported directly by APM agents.

  In OpenTelemetry, “span events” are generally referred to as “events on spans.” An event on a span represents “something happening” during the span’s lifecycle, and is displayed as a human-readable message. For example, exceptions that occur on a span will be displayed as a span event.
  </Collapser>
  <Collapser
    className="freq-link"
    id="cat"
    title="Cross application tracing"
  >
  Cross-application tracing (CAT) is a deprecated New Relic-specific precursor to New Relic distributed tracing and W3C trace context.
  </Collapser>
</CollapserGroup>

## Transactions [#transactions]

  APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ✅

  Transactions are a New Relic concept, representing an aggregation of requests to a particular endpoint. For OpenTelemetry we map this concept using trace data. See https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-opentelemetry-data-new-relic#transactions.

  The key difference between transactions (as a New Relic concept) and traces is the process boundary. A transaction is meant to encapsulate a single process. An agent attaches to a process; the process may make calls to external services, but the boundary for a transaction begins and ends at that process. 

  A trace, on the other hand, does not have the same boundary and thus includes spans across all services that may be involved.

  The work of a single process can sometimes be identified within an OpenTelemetry trace by checking the attribute `span.kind`. For instance, `span.kind=’server’` can signify work done within a transaction.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="messages"
    title="Messages"
  >
  APM agent: ✅

  OpenTelemetry: Limited support

  For APM agents, if your service is sending data from a message consumer (for example, Kafka, RabbitMQ), you can find that data in the Transactions page and in the transaction traces UI. For OpenTelemetry services, you can find the data in the distributed tracing  page or you can query it.
  </Collapser>
  <Collapser
    className="freq-link"
    id="trx-traces"
    title="Transaction Traces"
  >
  APM agent: ✅

  OpenTelemetry: ❌

  OpenTelemetry traces are like New Relic transaction traces, but also include spans (“segments”) outside a single service. They are also designed to be captured for a sampling (up to 100%) of requests.

  The New Relic agent Transaction Trace UI is similar to, but not quite the same as, the Trace UI used by both OpenTelemetry and New Relic agent data. Transaction traces are meant to capture a small sample of slow and/or important requests.
  </Collapser>
  <Collapser
    className="freq-link"
    id="trx-error-events"
    title="TransactionError events"
  >

  APM agent: ✅

  OpenTelemetry: ❌

  </Collapser>
  <Collapser
    className="freq-link"
    id="key-trx"
    title="Key Transactions"
  >

  APM agent: ✅

  OpenTelemetry: ❌

  </Collapser>

</CollapserGrou  </Collapser>p>

_... Here is an example where we could appropriate the grouping "Reports" and use it as a heading:_

## Reports [#reports]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="scalability"
    title="Scalability report"
  >
   APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ❌
  </Collapser>

  <Collapser
    className="freq-link"
    id="Capacity"
    title="Capacity report"
  >
    APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ❌
  </Collapser>

  <Collapser
    className="freq-link"
    id="web-transactions"
    title="Web transactions report"  
  >
    APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ❌
  </Collapser>

  <Collapser
    className="freq-link"
    id="database-report"
    title="Database report"  
  >
    APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ❌
  </Collapser>

  <Collapser
    className="freq-link"
    id="background-job"
    title="Background jobs report"  
  >
    APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ❌
  </Collapser>

  <Collapser
    className="freq-link"
    id="sla-report"
    title="SLA report"  
  >
    APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ❌
  </Collapser>
</CollapserGroup>


## _Mock-up 2: With parent-child (h2/h3) headings_

The sections are grouped by menu sections in the New Relic UI.

## Summary page [#summary]

APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ✅

The **Summary** page offers an overview of a service’s health, charting golden signals about your entity: response time, throughput, and error rate. These are also broken down by service instance ID (OpenTelemetry) or hostname (New Relic agent).

OpenTelemetry services use spans to create golden signals, whereas New Relic agent services use metrics.

## Monitoring features [#monitor]

The pages under **Monitor** in the left navigation offer you a variety of features to track your data.

### Distributed tracing [#dt]

APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ✅

Distributed tracing is supported today by our agents and OpenTelemetry. Both provide W3C Trace Context compatibility. Furthermore, OpenTelemetry supports W3C Baggage, highly configurable sampling options, and events on spans, or "span events" as they're referred to in New Relic.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="trace-context"
    title="W3C Trace Context"
  >
  APM agent: ✅ &nbsp; &nbsp; &nbsp; OpenTelemetry: ✅

  This support means that in a distributed system where some services are instrumented with OpenTelemetry and others with APM agents, trace context can be propagated successfully from one service to the next. This gives you visibility into activity across the system even when you use more than one instrumentation technology.
  </Collapser>
  <Collapser
    className="freq-link"
    id="baggage"
    title="W3C Baggage"
  >
  APM agent: ❌ &nbsp; &nbsp; &nbsp; OpenTelemetry: ✅

  In OpenTelemetry, baggage is a mechanism to propagate key:value pairs. It allows for observability events in a downstream service to be indexed with attributes provided by an upstream service in the same transaction/trace, without having to pull the attributes from a database. For instance, a user ID added as baggage will be accessible to downstream services, and they can then also index their spans and metrics by the user ID.

  You can view baggage in New Relic in the form of attributes on data, such as spans. The  baggage specification is only focused on the propagation of data, not the presentation. For instance, you can add the user ID from the example above to a span to view it as an attribute on that span in New Relic.
  </Collapser>
  <Collapser
    className="freq-link"
    id="sampling"
    title="Sampling"
  >
  APM agent: ✅

  OpenTelemetry: ✅

  APM agents support both head- and tail-based sampling, which you can implement by enabling distributed tracing or Infinite Tracing, respectively.

  OpenTelemetry SDKs by default implement parent-based sampling, though there are a number of built-in samplers that are available to choose from.

  Additionally, OpenTelemetry offers a standalone service called a collector, a configurable telemetry-processing system. This means you can configure a custom sampling strategy (or strategies) that makes the most sense for your observability needs. However, configuring and operating collectors can be complex. Another option for tail-based sampling with OpenTelemetry is using New Relic’s Infinite Tracing with OTLP. There is a tail-based sampling processor available today for the collector, but it is in the process of being deprecated in favor of a more native solution.
  </Collapser>
  <Collapser
    className="freq-link"
    id="span-events"
    title="Span events"
  >
  APM agent: ❌

  OpenTelemetry: ✅ 

  Clarification on terminology: In New Relic documentation, “span event” in the context of APM agents refers to event data of type `Span`, which is how segments of distributed traces are stored in NRDB. “Span events” as a distinct data type are not supported directly by APM agents.

  In OpenTelemetry, “span events” are generally referred to as “events on spans.” An event on a span represents “something happening” during the span’s lifecycle, and is displayed as a human-readable message. For example, exceptions that occur on a span will be displayed as a span event.
  </Collapser>
  <Collapser
    className="freq-link"
    id="cat"
    title="Cross application tracing"
  >
  Cross-application tracing (CAT) is a deprecated New Relic-specific precursor to New Relic distributed tracing and W3C trace context.
  </Collapser>
</CollapserGroup>

### Transactions [#transactions]

  APM agent: ✅

  OpenTelemetry: ✅

  Transactions are a New Relic concept, representing an aggregation of requests to a particular endpoint. For OpenTelemetry we map this concept using trace data. See https://docs.newrelic.com/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-opentelemetry-data-new-relic#transactions.

  The key difference between transactions (as a New Relic concept) and traces is the process boundary. A transaction is meant to encapsulate a single process. An agent attaches to a process; the process may make calls to external services, but the boundary for a transaction begins and ends at that process. 

  A trace, on the other hand, does not have the same boundary and thus includes spans across all services that may be involved.

  The work of a single process can sometimes be identified within an OpenTelemetry trace by checking the attribute `span.kind`. For instance, `span.kind=’server’` can signify work done within a transaction.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="messages"
    title="Messages"
  >
  APM agent: ✅

  OpenTelemetry: Limited support

  For APM agents, if your service is sending data from a message consumer (for example, Kafka, RabbitMQ), you can find that data in the Transactions page and in the transaction traces UI. For OpenTelemetry services, you can find the data in the distributed tracing  page or you can query it.
  </Collapser>
  <Collapser
    className="freq-link"
    id="trx-traces"
    title="Transaction Traces"
  >
  APM agent: ✅

  OpenTelemetry: ❌

  OpenTelemetry traces are like New Relic transaction traces, but also include spans (“segments”) outside a single service. They are also designed to be captured for a sampling (up to 100%) of requests.

  The New Relic agent Transaction Trace UI is similar to, but not quite the same as, the Trace UI used by both OpenTelemetry and New Relic agent data. Transaction traces are meant to capture a small sample of slow and/or important requests.
  </Collapser>
  <Collapser
    className="freq-link"
    id="trx-error-events"
    title="TransactionError events"
  >

  APM agent: ✅

  OpenTelemetry: ❌

  </Collapser>
  <Collapser
    className="freq-link"
    id="key-trx"
    title="Key Transactions"
  >

  APM agent: ✅

  OpenTelemetry: ❌

  </Collapser>

</CollapserGroup>

## _Mock-up 3: Use a table_

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        Experience
      </th>
      <th>
        New Relic agents
      </th>
      <th>
        OpenTelemetry
      </th>
      <th>
        Comments
      </th>
    </tr>
  </thead>
    <tbody>
    <tr>
      <td>
        Summary
      </td>
      <td>
        ✅
      </td>
      <td>
        ✅
      </td>
      <td>
        The **Summary** page offers an overview of a service’s health, charting golden signals about your entity: response time, throughput, and error rate. These are also broken down by service instance ID (OpenTelemetry) or hostname (New Relic agent).

        OpenTelemetry services use spans to create golden signals, whereas New Relic agent services use metrics.       
      </td>
    </tr>
    <tr>
      <td>
        Distributed tracing
      </td>
      <td>
        ✅
      </td>
      <td>
        ✅
      </td>
      <td>
        Distributed tracing is supported today by our agents and OpenTelemetry. Both provide W3C Trace Context compatibility. Furthermore, OpenTelemetry supports W3C Baggage, highly configurable sampling options, and events on spans, or "span events" as they're referred to in New Relic.
      </td>
    </tr>
    <tr>
      <td>
        Distributed Tracing: W3C Trace Context
      </td>
      <td>
        ✅
      </td>
      <td>
        ✅
      </td>
      <td>
        This support means that in a distributed system where some services are instrumented with OpenTelemetry and others with APM agents, trace context can be propagated successfully from one service to the next. This gives you visibility into activity across the system even when using more than one instrumentation technology.
      </td>
    </tr>
    <tr>
      <td>
        Distributed Tracing: W3C Baggage
      </td>
      <td>
        ❌
      </td>
      <td>
        ✅
      </td>
      <td>
        In OpenTelemetry, baggage is a mechanism to propagate key:value pairs. It allows for observability events in a downstream service to be indexed with attributes provided by an upstream service in the same transaction/trace, without having to pull the attributes from a database. For instance, a user ID added as baggage will be accessible to downstream services, and they can then also index their spans and metrics by the user ID.

        You can view baggage in New Relic in the form of attributes on data, such as spans. The  baggage specification is only focused on the propagation of data, not the presentation. For instance, you can add the user ID from the example above to a span to view it as an attribute on that span in New Relic.
      </td>
    </tr>
    <tr>
      <td>
        Distributed Tracing: Sampling
      </td>
      <td>
        ✅
      </td>
      <td>
        ✅        
      </td>
      <td>
        APM agents support both head- and tail-based sampling, which you can implement by enabling distributed tracing or Infinite Tracing, respectively.

        OpenTelemetry SDKs by default implement parent-based sampling, though there are a number of built-in samplers that are available to choose from.

        Additionally, OpenTelemetry offers a standalone service called a collector, a configurable telemetry-processing system. This means you can configure a custom sampling strategy (or strategies) that makes the most sense for your observability needs. However, configuring and operating collectors can be complex. Another option for tail-based sampling with OpenTelemetry is using New Relic’s Infinite Tracing with OTLP. There is a tail-based sampling processor available today for the collector, but it is in the process of being deprecated in favor of a more native solution. 
      </td>
    </tr>
    <tr>
      <td>
        Distributed Tracing: Span events
      </td>
      <td>
        ❌
      </td>
      <td>
        ✅        
      </td>
      <td>
        Clarification on terminology: In New Relic documentation, “span event” in the context of APM agents refers to event data of type `Span`, which is how segments of distributed traces are stored in NRDB. “Span events” as a distinct data type are not supported directly by APM agents.

        In OpenTelemetry, “span events” are generally referred to as “events on spans.” An event on a span represents “something happening” during the span’s lifecycle, and is displayed as a human-readable message. For example, exceptions that occur on a span will be displayed as a span event.
      </td>
    </tr>
    <tr>
      <td>
        Cross-application tracing
      </td>
      <td>
        Deprecated
      </td>
      <td>
        ❌
      </td>
      <td>
        Cross-application tracing (CAT) is a deprecated New Relic-specific precursor to New Relic distributed tracing and W3C trace context.
      </td>
    </tr>
    </tbody>
</table>

## Mock-up 4: Use a combination of headings and tables (no collapsers)

On second thought, this is still tough to read because we can't control the widths of the table columns.

## Monitoring Features


### Summary Page [#summary]

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        Experience
      </th>
      <th>
        New Relic agents
      </th>
      <th>
        OpenTelemetry
      </th>
      <th>
        Comments
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        Summary
      </td>
      <td>
        ✅
      </td>
      <td>
        ✅
      </td>
      <td>
        The **Summary** page offers an overview of a service’s health, charting golden signals about your entity: response time, throughput, and error rate. These are also broken down by service instance ID (OpenTelemetry) or hostname (New Relic agent).

        OpenTelemetry services use spans to create golden signals, whereas New Relic agent services use metrics.       
      </td>
    </tr>
    <tr>
      <td>
        Web transactions time breakdown
      </td>
      <td>
        ✅
      </td>
      <td>
        ❌
      </td>
      <td>
        OpenTelemetry does not specify or collect metrics breaking down service response time
      </td>
    </tr>
  </tbody>
</table>

### Filter/group data in the UI [#filter-group-ui]

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        Experience
      </th>
      <th>
        New Relic agents
      </th>
      <th>
        OpenTelemetry
      </th>
      <th>
        Comments
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        Filter/group data in the UI
      </td>
      <td>
        Limited
      </td>
      <td>
        ✅
      </td>
      <td>
        OpenTelemetry’s service UIs in New Relic let you filter/group data in charts using any attribute. In New Relic One, only OpenTelemetry services have the filter bars shown below:

        [INSERT IMAGE HERE]

        In contrast, the New Relic agent-based UI can be filtered/grouped by a more limited set of attributes. For example, all data can be filtered by host/instance. Several specialized views provide fixed groupings of their metrics, for example: by database query, by transaction/endpoint, by external service call, by error message and exception type, etc. In addition, event data available for many of these views can be filtered/grouped by any attribute.
      </td>
    </tr>
  </tbody>
</table>

### Distributed tracing [#distributed-tracing]

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        Experience
      </th>
      <th>
        New Relic agents
      </th>
      <th>
        OpenTelemetry
      </th>
      <th>
        Comments
      </th>
    </tr>
  </thead>
    <tbody>
      <tr>
        <td>
        Distributed tracing
        </td>
        <td>
          ✅
        </td>
        <td>
          ✅
        </td>
        <td>
          Distributed tracing is supported today by our agents and OpenTelemetry. Both provide W3C Trace Context compatibility. Furthermore, OpenTelemetry supports W3C Baggage, highly configurable sampling options, and events on spans, or "span events" as they're referred to in New Relic.
        </td>
      </tr>
      <tr>
        <td>
          Distributed Tracing: W3C Trace Context
        </td>
        <td>
          ✅
        </td>
        <td>
          ✅
        </td>
        <td>
          This support means that in a distributed system where some services are instrumented with OpenTelemetry and others with APM agents, trace context can be propagated successfully from one service to the next. This gives you visibility into activity across the system even when using more than one instrumentation technology.
        </td>
      </tr>
      <tr>
        <td>
          Distributed Tracing: W3C Baggage
        </td>
        <td>
          ❌
        </td>
        <td>
          ✅
        </td>
        <td>
          In OpenTelemetry, baggage is a mechanism to propagate key:value pairs. It allows for observability events in a downstream service to be indexed with attributes provided by an upstream service in the same transaction/trace, without having to pull the attributes from a database. For instance, a user ID added as baggage will be accessible to downstream services, and they can then also index their spans and metrics by the user ID.

          You can view baggage in New Relic in the form of attributes on data, such as spans. The  baggage specification is only focused on the propagation of data, not the presentation. For instance, you can add the user ID from the example above to a span to view it as an attribute on that span in New Relic.
        </td>
      </tr>
      <tr>
        <td>
          Distributed Tracing: Sampling
        </td>
        <td>
          ✅
        </td>
        <td>
          ✅        
        </td>
        <td>
          APM agents support both head- and tail-based sampling, which you can implement by enabling distributed tracing or Infinite Tracing, respectively.

          OpenTelemetry SDKs by default implement parent-based sampling, though there are a number of built-in samplers that are available to choose from.

          Additionally, OpenTelemetry offers a standalone service called a collector, a configurable telemetry-processing system. This means you can configure a custom sampling strategy (or strategies) that makes the most sense for your observability needs. However, configuring and operating collectors can be complex. Another option for tail-based sampling with OpenTelemetry is using New Relic’s Infinite Tracing with OTLP. There is a tail-based sampling processor available today for the collector, but it is in the process of being deprecated in favor of a more native solution. 
        </td>
      </tr>
      <tr>
        <td>
          Distributed Tracing: Span events
        </td>
        <td>
          ❌
        </td>
        <td>
          ✅        
        </td>
        <td>
          Clarification on terminology: In New Relic documentation, “span event” in the context of APM agents refers to event data of type `Span`, which is how segments of distributed traces are stored in NRDB. “Span events” as a distinct data type are not supported directly by APM agents.

          In OpenTelemetry, “span events” are generally referred to as “events on spans.” An event on a span represents “something happening” during the span’s lifecycle, and is displayed as a human-readable message. For example, exceptions that occur on a span will be displayed as a span event.
        </td>
      </tr>
      <tr>
        <td>
          Cross-application tracing
        </td>
        <td>
          Deprecated
        </td>
        <td>
          ❌
        </td>
        <td>
          Cross-application tracing (CAT) is a deprecated New Relic-specific precursor to New Relic distributed tracing and W3C trace context.
        </td>
    </tr>
    </tbody>
</table>