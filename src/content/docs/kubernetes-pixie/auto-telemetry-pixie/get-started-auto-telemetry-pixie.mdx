---
title: Auto-telemetry with Pixie for instant Kubernetes observability 
tags:
  - Pixie Auto-telemetry
  - Service monitoring
  - Kubernetes
  - eBPF
metaDescription: 
redirects:
  - /docs/auto-telemetry-pixie/get-started-auto-telemetry-pixie
  - /docs/full-stack-observability/get-started-auto-telemetry-pixie
  - /docs/full-stack-observability/observe-everything/get-started/get-started-auto-telemetry-pixie
  - /docs/full-stack-observability/observe-everything/get-started/pixie-account-link
---

import serviceGraph from 'images/service-graph.png'

import flamegraph from 'images/flamegraph.png'

When we say auto-telemetry, we’re not talking about cars — we're talking about instant baseline visibility into your Kubernetes clusters. With the New Relic integration with [Pixie](https://pixielabs.ai/), you get similar data to traditional language agents, but without manually instrumenting your code or redeploying your application.

Pixie auto-telemetry is powered by [eBPF](https://ebpf.io/), a virtual machine-like construct that enables Pixie to seamlessly collect fine-grained telemetry data — service-level metrics, unsampled requests, and more. With one install command, you get deeper insight into your Kubernetes clusters and workloads. No language agents required.

<img
  title="service graph in live debugger"
  alt="service-graph"
  src={serviceGraph}
/>

<figcaption>
  **Live debugging with Pixie** shows a service graph listing the namespaces and the node that are available on the current cluster.
</figcaption>

Simply put, Auto-telemetry with Pixie offers the quickest option for getting observability into your Kubernetes services.

Ready to get started? You'll be able to configure Pixie to suit your environnment after you [create a New Relic account](https://newrelic.com/signup) (it's free, forever!) and [install our Pixie integration](/docs/kubernetes-pixie/auto-telemetry-pixie/install-auto-telemetry-pixie/).

## Quickly start observing and debugging Kubernetes clusters

Our Pixie integration gives you the best of both worlds: Pixie’s fast and simple Kubernetes observability coupled with New Relic’s incident correlation, intelligent alerting, and long-term retention.

You’ll get visibility into HTTP services using golden signals, HTTP transactions, database transactions, distributed tracing, and JVM metrics. You can operate, debug, and scale your Kubernetes clusters based on the information you learn about how your clusters and services are running. Using the New Relic [Explorer](/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts/), you can see key metrics and events at every level, starting with the cluster, and diving down into namespaces, deployments, and pods. You can quickly spot anomalous behavior, and where it’s happening.

And then dive deeper using embedded visualizations of your Pixie data. Quickly identify hot spots with a [flame graph display](#flamegraph). On the [Live debugging with Pixie tab](#live-debugging), answer questions like what SQL requests your app is making or which services are talking to each other.

This short video (approx. 6:20 minutes) shows how Pixie and Kubernetes work together so you can debug faster with code-level insights:

<Video
  id="QO7vz0jQEUI"
  type="youtube"
/>

<Callout variant="important">
  Auto-telemetry with Pixie leverages [Community Cloud with Pixie](http://pixielabs.ai/), a separate platform from New Relic. Use of Community Cloud with Pixie is subject to separate [terms of service](https://pixielabs.ai/terms).
</Callout>

## Explore your cluster

Access the Pixie UI via New Relic's **Live debugging with Pixie** area of your Kubernetes clusters. The cluster explorer provides a quick overview of the nodes in your cluster, including CPU, memory, and storage, as well as the status of each pod (**healthy**, **warning**, or **critical**). You can also find out what services are running in each container, their latency, throughput, and error rate.

For more information about using the cluster explorer, see [Navigate the Kubernetes cluster explorer](/docs/integrations/kubernetes-integration/understand-use-data/kubernetes-cluster-explorer/). Note that you cannot log directly into the Pixie UI unless you have created a separate Pixie login.

<Callout variant="tip">
  Containers might be listed for up to four hours after they get decommissioned.
</Callout>

You can query the Pixie data in New Relic and create dashboards for at-a-glance monitoring. For more information, see our documentation about the [data model and sample queries](/docs/integrations/kubernetes-integration/understand-use-data/auto-telemetry-pixie-data-model).

## Investigate usage spikes using the flame graph [#flamegraph]

<img
  title="Pixie flame graph"
  alt="Pixie flame graph"
  src={flamegraph}
/>

Debugging is orders of magnitude easier when you can quickly see what your application is doing. The Pixie flame graph display requires no instrumentation, redeploying, or recompiling. It works for compiled languages like Go, C+, Rust, to name a few. And at a glance, the flame graph tells you what functions your application is spending time on and where you have hot spots.

Flame graphs are especially useful for hierarchical resource use, like disk usage and CPU utilization. For more information on how to read a flame graph, see the [Pixie flame graph docs](https://docs.pixielabs.ai/tutorials/profiler#reading-the-flamegraph).

## Debug live [#live-debugging]

On the **Live debugging with Pixie** tab, run PxL scripts — scripts written in Pixie's PxL language — to view live data captured through eBPF. Select the **script** drop-down and then select a script to run in the tab. (For best results, select a time range that is recent in the time picker.)

Scripts enable you to debug:

* Traffic in multiple formats: HTTP and HTTPs (including encrypted), DNS, Postgres, MySQL, Cassandra, Redis (currently supporting SQL and HTTP in beta). Learn more: [Request tracing tutorial](https://docs.px.dev/tutorials/pixie-101/request-tracing/).
* Database request performance. Learn more: [Database Query Profiling tutorial](https://docs.px.dev/tutorials/pixie-101/database-query-profiling/).
* Service maps to learn which services are talking to each other. Learn more: [Service Performance tutorial](https://docs.px.dev/tutorials/pixie-101/service-performance/).
* Network traffic maps to learn which nodes are talking to each other. Learn more: [Network Monitoring tutorial](https://docs.px.dev/tutorials/pixie-101/network-monitoring/).
* Monitor resource usage by Node and Pod. Learn more: [Infra health tutorial](https://docs.px.dev/tutorials/pixie-101/infra-health/).
