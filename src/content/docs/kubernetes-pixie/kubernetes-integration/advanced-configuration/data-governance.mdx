---
title: Data governance
tags:
  - Integrations
  - Kubernetes integration
  - Configuration
metaDescription: How to manage your data from the Kubernetes integration.
freshnessValidatedDate: never
---
## Logs
The collection of  [Logs](https://github.com/newrelic/helm-charts/blob/master/charts/newrelic-logging/values.yaml#L27) in Kubernetes is  done  using the [New Relic kubernetes plugin](https://docs.newrelic.com/docs/logs/forward-logs/kubernetes-plugin-log-forwarding/), an output plugin for Fluentbit.

The configuration of **fluentbit** includes:
- **Input Plugin**: This is where we define the log sources that we wish to collect, as in our case we are talking about k8s logs.
- **Parser Plugins**: to convert and structure log messages (JSON, Regexp, LTSV, Logfmt, etc.)
- **Filter Plugins**: to modify, enrich and delete   information from your logs (Nest, Throttle, Expect, Geoplp, Grep, K8s, etc.) For filtering, you can also use a LUA script.
- **Output Plugins**: send the log stream to several outputs which will be responsible for storing the log stream and displaying them. In this case, we speak of NRDB (New Relic Database).

Logs can be filtered following the methods below:
### Change the path
In the input configuration, we have the **path** defined, which would point the fluentbit agent to the **log paths** that need to be collected.

For k8s containers, logs are stored in files with the format: **"/var/log/containers/<podname>_<namespace>....log"** (file example: **/var/log/containers/nri-bundle-newrelic-logging-pjdfks_default_newrelic-logging-1d45d23135d7062c1fcd7c872472a74d5294c55edd0592a2130c10b046234.log**)

If you would like to concentrate for example the collection of logs on 3, 4 pods: you would have to specify the paths according to the pods names and the wildcard  (*):

```yaml
fluentBit:
  logLevel: "info"
  path: "/var/log/containers/myPod1*.log, /var/log/containers/myPod2*.log"
```

So it ends up looking like:

```yaml
global:
  licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
  cluster: _K8S_CLUSTER_NAME_

# ... Other settings

# Configuration for newrelic-logging
newrelic-logging:
  # ... Other settings
  fluentBit:
    logLevel: "info"
    path: "/var/log/containers/myPod1*.log, /var/log/containers/myPod2*.log"
    # ... Other settings
```

->In the example above, Path has been changed to focus on the podnames **“myPod1”** and **“myPod2”**.

With such configuration, fluentbit would **only** collect logs from containers for pods starting with the names **mypod1** and **mypod2**.

### Exclude certain path(s)

With this method, you would rely on the **"Exclude_Path"**  parameter in the **input** configuration.

This would allow you to define one or more comma-separated shell patterns to exclude files matching certain criteria.

Use this method if you're looking for excluding log collection from certain namespaces. 

```yaml
inputs: |
  [INPUT]
      Name              tail
      Tag               kube.*
      Path              ${PATH}
      multiline.parser  ${LOG_PARSER}
      DB                ${FB_DB}
      Mem_Buf_Limit     7MB
      Skip_Long_Lines   On
      Refresh_Interval  10
      Exclude_Path      /var/log/containers/*_newrelic_*.log, /var/log/containers/*_kube-system_*.log
```

So it ends up looking like:

```yaml
global:
  licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
  cluster: _K8S_CLUSTER_NAME_

# ... Other settings

# Configuration for newrelic-logging
newrelic-logging:
  # ... Other settings
  fluentBit:
    # ... Other settings
    config: 

      [INPUT]
          Name              tail
          Tag               kube.*
          Path              ${PATH}
          multiline.parser  ${LOG_PARSER}
          DB                ${FB_DB}
          Mem_Buf_Limit     7MB
          Skip_Long_Lines   On
          Refresh_Interval  10
          Exclude_Path      /var/log/containers/*_newrelic_*.log, /var/log/containers/*_kube-system_*.log

          # ... Other settings
```

**“Exclude_path”** parameter is set to exclude the **“newrelic”** and **“kube-system”** namespaces from log collection

Fluentbit will collect  logs from all pods in the  cluster **except** pods that are deployed in the **“newrelic”** and **“kube-system”** namespaces.

### Through Pod Annotations

In Fluentbit, Kubernetes **annotations** are essentially filters that you can set to control which logs Fluenbit should process. 

Adding the **fluentbit.io/exclude** annotation, will tell Fluent not to process it.

The annotation value can be expressed as **"true"** or **"false"** and must include quotation marks.

This setting will only be processed if you first enable **K8S-Logging.Exclude** in the Fluent Bit Kubernetes filter, which is disabled by default.

```yaml
  fluentBit:
    path: "/var/log/containers/*.log"
    # ... Other settings
    k8sLoggingExclude: "On"
```

So it ends up looking like:

```yaml
global:
  licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
  cluster: _K8S_CLUSTER_NAME_

# ... Other settings

# Configuration for newrelic-logging
newrelic-logging:
  # ... Other settings
  fluentBit:
    path: "/var/log/containers/*.log"
    # ... Other settings
    k8sLoggingExclude: "On"

    # ... Other settings
```

**k8sLoggingExclude** is set to  **"On"** (by default it is set to **"Off"**).

-> Assuming that ou would like to exclude logs collection for the pod **test-pod**, therefore, you would need to **annotate** the pod **“test-pod”** with **fluentbit.io/exclude="true"** ( kubectl annotate pod test-pod fluentbit.io/exclude=true )

In this case, Fluentbit will collect logs from all pods except "test-pod".

## Metrics
### Change the scrape interval [#scrape-interval]

The [New Relic Kubernetes integration v3](/docs/kubernetes-pixie/kubernetes-integration/advanced-configuration/changes-since-v3/) and above allows changing the interval at which metrics are gathered from the cluster. This allows choosing a tradeoff between data resolution and usage. We recommend choosing an interval between 15 and 30 seconds for optimal experience.

In order to change the scrape interval, add the following to your `values-newrelic.yaml`, under the `newrelic-infrastructure` section:

```yaml
common:
  config:
    interval: 25s
```

So it ends up looking like:

```yaml
global:
  licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
  cluster: _K8S_CLUSTER_NAME_

# ... Other settings

# Configuration for newrelic-infrastructure
newrelic-infrastructure:
  # ... Other settings
  common:
    config:
      interval: 25s
```

<Callout variant="important">
  Setting `interval` to values larger than `40s` is not allowed.
</Callout>

### Filtering Namespaces [#filter-namespace]

The Kubernetes integration v3 and above allows filtering on which namespaces are scraped by labelling them. All namespaces are scraped by default.

We use the `namespaceSelector` in the same way Kubernetes does. In order to include only namespaces matching a label, change the `namespaceSelector` by adding the following to your `values-newrelic.yaml`, under the `newrelic-infrastructure` section:

```yaml
common:
  config:
    namespaceSelector:
      matchLabels:
        key1 : "value1"
```

In this example only namespaces with the label `newrelic.com/scrape` set to `true` will be scraped:

```yaml
global:
  licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
  cluster: _K8S_CLUSTER_NAME_

# ... Other settings 

# Configuration for newrelic-infrastructure
newrelic-infrastructure:
  # ... Other settings 
  common:
    config:
      namespaceSelector:
        matchLabels:
          newrelic.com/scrape: "true"
```

You can also use Kubernetes expressions to include or exclude namespaces using the following syntax:

```yaml
common:
  config:
    namespaceSelector:
      matchExpressions:
      - {key: newrelic.com/scrape, operator: NotIn, values: ["false"]}
      - {key: key1, operator: In, values: ["value1"]}
```

<Callout variant="tip">
  The expressions under `matchExpressions` are concatenated.
</Callout>

In this example, namespaces with the label `newrelic.com/scrape` set to `false` will be excluded:

```yaml
global:
  licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
  cluster: _K8S_CLUSTER_NAME_

# ... Other settings 

# Configuration for newrelic-infrastructure
newrelic-infrastructure:
  # ... Other settings
  common:
    config:
      namespaceSelector:
        matchExpressions:
        - {key: newrelic.com/scrape, operator: NotIn, values: ["false"]}
```

See a full list of settings that can be modified in the [chart's README file](https://github.com/newrelic/nri-kubernetes/tree/main/charts/newrelic-infrastructure).

#### How can I find out which namespaces are excluded? [#excluded-namespaces]

All the namespaces within the cluster are listed thanks to the `K8sNamespace` sample. The `nrFiltered` attribute determines whether the data related to the namespace is going to be scraped.

Use this query to find out which namespaces are being monitored:

```sql
FROM K8sNamespaceSample SELECT displayName, nrFiltered WHERE clusterName = <clusterName> SINCE 2 MINUTES AGO
```

#### What data is being discarded from the excluded namespaces? [#namespaces-discarded-data]

The following samples won't be available for the excluded namespaces:

- `K8sContainerSample`
- `K8sDaemonsetSample`
- `K8sDeploymentSample`
- `K8sEndpointSample`
- `K8sHpaSample`
- `K8sPodSample`
- `K8sReplicasetSample`
- `K8sServiceSample`
- `K8sStatefulsetSample`
- `K8sVolumeSample`
