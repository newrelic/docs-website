---
title: Find and use your Kubernetes data
tags:
  - Integrations
  - Kubernetes integration
  - Understand and use data
metaDescription: 'New Relic''s Kubernetes integration: How to install and activate the integration, and what data is reported.'
redirects:
  - /docs/integrations/kubernetes-integration/understand-use-data/find-use-your-kubernetes-data
  - /docs/integrations/kubernetes-integration/understand-use-data/understand-use-data
---

You can build your own charts and [query](/docs/using-new-relic/data/understand-data/query-new-relic-data) all your [Kubernetes integration](/docs/integrations/kubernetes-integration/get-started/introduction-kubernetes-integration) data using the query builder and the NerdGraph API. Our integration collects Kubernetes data by instrumenting the container orchestration layer. For a simpler and more visual experience, use the [cluster explorer](/docs/integrations/kubernetes-integration/understand-use-data/kubernetes-cluster-explorer).

![New Relic One - Kubernetes dashboard](./images/2020-04-28-17.33.47.gif "2020-04-28 17.33.47.gif")

<figcaption>
  **[one.newrelic.com](https://one.newrelic.com) > Dashboards**: Using the [query builder](/docs/chart-builder/use-chart-builder/get-started/introduction-chart-builder) you can query your Kubernetes data and create clear visualizations.
</figcaption>

## Query Kubernetes data [#view-data]

The simplest way to [query your Kubernetes data](/docs/using-new-relic/data/understand-data/query-new-relic-data) is using the [query builder](/docs/query-your-data/explore-query-data/query-builder/use-advanced-nrql-mode-specify-data), which accepts [NRQL queries](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql). Alternatively, you can use the [NerdGraph API](/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph) to retrieve Kubernetes data.

### Event types [#event-types]

Kubernetes data is attached to the following [event types](/docs/using-new-relic/data/understand-data/new-relic-data-types#event-data):

<table>
  <thead>
    <tr>
      <th style={{ width: "275px" }}>
        Event name
      </th>

      <th>
        Type of Kubernetes data
      </th>

      <th style={{ width: "200px" }}>
        Available since
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `K8sNodeSample`
      </td>

      <td>
        [Node data](#node-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sNamespaceSample`
      </td>

      <td>
        [Namespace data](#namespace-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sDeploymentSample`
      </td>

      <td>
        [Deployment data](#deployment-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sReplicasetSample`
      </td>

      <td>
        [ReplicaSet data](#replica-set-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sDaemonsetSample`
      </td>

      <td>
        [DaemonSet data](#daemonset-data)
      </td>

      <td>
        v1.13.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sStatefulsetSample`
      </td>

      <td>
        [StatefulSet data](#statefulset-data)
      </td>

      <td>
        v1.13.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sPodSample`
      </td>

      <td>
        [Pod data](#pod-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sClusterSample`
      </td>

      <td>
        [Cluster data](#cluster-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sContainerSample`
      </td>

      <td>
        [Container data](#container-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sVolumeSample`
      </td>

      <td>
        [Volume data](#volume-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sApiServerSample`
      </td>

      <td>
        [API server data](#api-server-data)
      </td>

      <td>
        v1.11.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sControllerManagerSample`
      </td>

      <td>
        [Controller manager data](#controller-manager-data)
      </td>

      <td>
        v1.11.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sSchedulerSample`
      </td>

      <td>
        [Scheduler data](#scheduler-data)
      </td>

      <td>
        v1.11.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sEtcdSample`
      </td>

      <td>
        [etcd data](#etcd-data)
      </td>

      <td>
        v1.11.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sEndpointSample`
      </td>

      <td>
        [Endpoint data](#endpoint-data)
      </td>

      <td>
        v1.13.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sServiceSample`
      </td>

      <td>
        [Service data](#service-data)
      </td>

      <td>
        v1.13.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sHpaSample`
      </td>

      <td>
        [Horizontal Pod Autoscaler data](#hpa-data)
      </td>

      <td>
        v2.3.0
      </td>
    </tr>
  </tbody>
</table>

## Manage alerts [#alerts]

You can be notified about alert violations for your Kubernetes data:

<CollapserGroup>
  <Collapser
    id="create-alert"
    title="Create an alert condition"
  >
    To create an alert condition for the Kubernetes integration:

    1. Go to [**one.newrelic.com**](http://one.newrelic.com) **> Infrastructure > Settings > Alerts > Kubernetes**, then select **Create alert condition**.
    2. To filter the alert to Kubernetes entities that only have the chosen attributes, select **Filter**.
    3. Select the threshold settings. For more on the **Trigger an alert when...** options, see [Alert types](#alert-types).
    4. Select an existing [alert policy](/docs/alerts/new-relic-alerts/configuring-alert-policies/create-or-rename-alert-policy), or create a new one.
    5. Select **Create**.

    When an alert condition's threshold is triggered, New Relic sends a [notification](#notifications) to the policy's notification channels.
  </Collapser>

  <Collapser
    id="alert-types"
    title="Use the predefined alert types and thresholds"
  >
    The Kubernetes integration comes with its own alert policy and alert conditions. To see what the predefined alert conditions are, see [Kubernetes integration: Predefined alert policy](/docs/integrations/kubernetes-integration/kubernetes-events/kubernetes-integration-predefined-alert-policy).

    In addition, you can create an alert condition for any metric collected by any [New Relic integration](/docs/integrations/new-relic-integrations/getting-started/introduction-infrastructure-integrations) you use, including the Kubernetes integration:

    1. Select the alert type **Integrations**.
    2. From the **Select a data source** dropdown, select a Kubernetes (K8s) data source.
  </Collapser>

  <Collapser
    id="notifications"
    title="Select alert notifications"
  >
    When an alert condition's threshold is triggered, New Relic sends a message to the notification channel(s) chosen in the alert policy. Depending on the type of notification, you may have the following options:

    * [View the incident](/docs/alerts/new-relic-alerts/reviewing-alert-incidents/view-violation-event-details-incidents).
    * [Acknowledge the incident](/docs/alerts/new-relic-alerts/reviewing-alert-incidents/acknowledge-alert-incidents).
    * Go to a chart of the incident data by selecting the identifier name.

    The entity identifier that triggered the alert appears near the top of the notification message. The format of the identifier depends on the alert type:

    * **Available pods are less than desired pods** alerts:

      ```
      K8s:<var>CLUSTER_NAME</var>:<var>PARENT_NAMESPACE</var>:replicaset:<var>REPLICASET_NAME</var>
      ```
    * **CPU or memory usage** alerts:

      ```
      K8s:<var>CLUSTER_NAME</var>:<var>PARENT_NAMESPACE</var>:<var>POD_NAME</var>:container:<var>CONTAINER_NAME</var>
      ```

    Here are some examples.

    <CollapserGroup>
      <Collapser
        id="pod-alerts"
        title="Pod alert notification example"
      >
        For **Available pods are less than desired pods** alerts, the ID of the `ReplicaSet` triggering the issue might look like this:

        ```
        k8s:beam-production:default:replicaset:nginx-deployment-1623441481
        ```

        This identifier contains the following information:

        * Cluster name: `beam-production`
        * Parent namespace: `default`
        * `ReplicaSet` name: `nginx-deployment-1623441481`
      </Collapser>

      <Collapser
        id="container-resource"
        title="Container resource notification example"
      >
        For container CPU or memory usage alerts, the entity might look like this:

        ```
        k8s:beam-production:kube-system:kube-state-metrics-797bb87c75-zncwn:container:kube-state-metrics
        ```

        This identifier contains the following information:

        * Cluster name: `beam-production`
        * Parent namespace: `kube-system`
        * Pod namespace: `kube-state-metrics-797bb87c75-zncwn`
        * Container name: `kube-state-metrics`
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    id="nrql-alerts"
    title="Create alert conditions using NRQL"
  >
    Follow standard procedures to [create alert conditions for NRQL queries](/docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries).
  </Collapser>
</CollapserGroup>

## Kubernetes attributes and metrics [#metrics]

The Kubernetes integration collects the following metrics and other [attributes](/docs/accounts-partnerships/education/getting-started-new-relic/glossary#attribute).

### Node data [#node-data]

Query the `K8sNodeSample` event for node data:

<table>
  <thead>
    <tr>
      <th style={{ width: "325px" }}>
        Node attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `allocatableCpuCores`
      </td>

      <td>
        Node allocatable CPU cores
      </td>
    </tr>

    <tr>
      <td>
        `allocatableMemoryBytes`
      </td>

      <td>
        Node allocatable memory bytes
      </td>
    </tr>

    <tr>
      <td>
        `allocatablePods`
      </td>

      <td>
        Node allocatable pods
      </td>
    </tr>

    <tr>
      <td>
        `allocatableEphemeralStorageBytes`
      </td>

      <td>
        Node allocatable ephemeral-storage bytes
      </td>
    </tr>

    <tr>
      <td>
        `capacityCpuCores`
      </td>

      <td>
        Node CPU capacity
      </td>
    </tr>

    <tr>
      <td>
        `capacityMemoryBytes`
      </td>

      <td>
        Node memory capacity (in bytes)
      </td>
    </tr>

    <tr>
      <td>
        `capacityPods`
      </td>

      <td>
        Pod capacity of the node
      </td>
    </tr>

    <tr>
      <td>
        `capacityEphemeralStorageBytes`
      </td>

      <td>
        Node ephemeral-storage capacity
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name that you assigned to the cluster when you installed the Kubernetes integration
      </td>
    </tr>

    <tr>
      <td>
        `condition.{conditionName}={conditionValue}`
      </td>

      <td>
        Status of the current observed node condition. The reported conditions can vary depending on your Kubernetes flavor and installed operators.<br />
        Examples of common conditions are: Ready, DiskPressure, MemoryPressure, PIDPressure and NetworkUnavailable.<br />
        Condition values can be `1` (true), `0` (false), or `-1` (unknown).
      </td>
    </tr>

    <tr>
      <td>
        `cpuUsedCoreMilliseconds`
      </td>

      <td>
        Node CPU usage measured in core milliseconds
      </td>
    </tr>

    <tr>
      <td>
        `cpuUsedCores`
      </td>

      <td>
        Node CPU usage measured in cores
      </td>
    </tr>

    <tr>
      <td>
        `cpuRequestedCores`
      </td>

      <td>
        Total amount of CPU cores requested
      </td>
    </tr>

    <tr>
      <td>
        `allocatableCpuCoresUtilization`
      </td>

      <td>
        Percentage of CPU cores actually used with respect to the CPU cores allocatable
      </td>
    </tr>

    <tr>
      <td>
        `fsAvailableBytes`
      </td>

      <td>
        Bytes available in the node filesystem
      </td>
    </tr>

    <tr>
      <td>
        `fsCapacityBytes`
      </td>

      <td>
        Total capacity of the node filesystem in bytes
      </td>
    </tr>

    <tr>
      <td>
        `fsInodes`
      </td>

      <td>
        Total number of inodes in the node filesystem
      </td>
    </tr>

    <tr>
      <td>
        `fsInodesFree`
      </td>

      <td>
        Free inodes in the node filesystem
      </td>
    </tr>

    <tr>
      <td>
        `fsInodesUsed`
      </td>

      <td>
        Used inodes in the node filesystem
      </td>
    </tr>

    <tr>
      <td>
        `fsUsedBytes`
      </td>

      <td>
        Used bytes in the node filesystem
      </td>
    </tr>

    <tr>
      <td>
        `fsCapacityUtilization`
      </td>

      <td>
        Percentage of used bytes in the node filesystem with respect to the capacity
      </td>
    </tr>

    <tr>
      <td>
        `memoryAvailableBytes`
      </td>

      <td>
        Bytes of memory available in the node
      </td>
    </tr>

    <tr>
      <td>
        `memoryMajorPageFaultsPerSecond`
      </td>

      <td>
        Number of major page faults per second in the node
      </td>
    </tr>

    <tr>
      <td>
        `memoryPageFaults`
      </td>

      <td>
        Number of page faults in the node
      </td>
    </tr>

    <tr>
      <td>
        `memoryRssBytes`
      </td>

      <td>
        Bytes of rss memory
      </td>
    </tr>

    <tr>
      <td>
        `memoryUsedBytes`
      </td>

      <td>
        Bytes of memory used
      </td>
    </tr>

    <tr>
      <td>
        `memoryWorkingSetBytes`
      </td>

      <td>
        Bytes of memory in the working set
      </td>
    </tr>

    <tr>
      <td>
        `memoryRequestedBytes`
      </td>

      <td>
        Total amount of requested memory
      </td>
    </tr>

    <tr>
      <td>
        `allocatableMemoryUtilization`
      </td>

      <td>
        Percentage of bytes of memory in the working set with respect to the node allocatable memory
      </td>
    </tr>

    <tr>
      <td>
        `net.errorCountPerSecond`
      </td>

      <td>
        Number of errors per second while receiving/transmitting over the network
      </td>
    </tr>

    <tr>
      <td>
        `nodeName`
      </td>

      <td>
        Host name that the pod is running on
      </td>
    </tr>

    <tr>
      <td>
        `runtimeAvailableBytes`
      </td>

      <td>
        Bytes available to the container runtime filesystem
      </td>
    </tr>

    <tr>
      <td>
        `runtimeCapacityBytes`
      </td>

      <td>
        Total capacity assigned to the container runtime filesystem in bytes
      </td>
    </tr>

    <tr>
      <td>
        `runtimeInodes`
      </td>

      <td>
        Total number of inodes in the container runtime filesystem
      </td>
    </tr>

    <tr>
      <td>
        `runtimeInodesFree`
      </td>

      <td>
        Free inodes in the container runtime filesystem
      </td>
    </tr>

    <tr>
      <td>
        `runtimeInodesUsed`
      </td>

      <td>
        Used inodes in the container runtime filesystem
      </td>
    </tr>

    <tr>
      <td>
        `runtimeUsedBytes`
      </td>

      <td>
        Used bytes in the container runtime filesystem
      </td>
    </tr>

    <tr>
      <td>
        `unschedulable`
      </td>

      <td>
        Status of node schedulability of new pods. Its value can be 0 (false) or 1 (true)
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        Labels associated with your node, so you can filter and query for specific nodes
      </td>
    </tr>
  </tbody>
</table>

### Namespace data [#namespace-data]

Query the `K8sNamespaceSample` event for namespace data:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        Namespace attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name that you assigned to the cluster when you installed the Kubernetes integration
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        Timestamp of the namespace when it was created
      </td>
    </tr>

    <tr>
      <td>
        `namespace`
      </td>

      <td>
        Name of the namespace to be used as an identifier
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        Labels associated with your namespace, so you can filter and query for specific namespaces
      </td>
    </tr>

    <tr>
      <td>
        `status`
      </td>

      <td>
        Current status of the namespace.

        The value can be `Active` or `Terminated`
      </td>
    </tr>
  </tbody>
</table>

### Deployment data [#deployment-data]

Query the `K8sDeploymentSample` event for deployment data:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        Deployment attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name that you assigned to the cluster when you installed the Kubernetes integration
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        Timestamp of when the deployment was created
      </td>
    </tr>

    <tr>
      <td>
        `deploymentName`
      </td>

      <td>
        Name of the deployment to be used as an identifier
      </td>
    </tr>

    <tr>
      <td>
        `namespace`
      </td>

      <td>
        Name of the namespace that the deployment belongs to
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        Labels associated with your deployment, so you can filter and query for specific deployments
      </td>
    </tr>

    <tr>
      <td>
        `podsAvailable`
      </td>

      <td>
        Number of replicas that are currently available
      </td>
    </tr>

    <tr>
      <td>
        `podsDesired`
      </td>

      <td>
        Number of replicas that you defined in the deployment
      </td>
    </tr>

    <tr>
      <td>
        `podsTotal`
      </td>

      <td>
        Total number of replicas that are currently running
      </td>
    </tr>

    <tr>
      <td>
        `podsUnavailable`
      </td>

      <td>
        Number of replicas that are currently unavailable
      </td>
    </tr>

    <tr>
      <td>
        `podsUpdated`
      </td>

      <td>
        Number of replicas that have been updated to achieve the desired state of the deployment
      </td>
    </tr>

    <tr>
      <td>
        `podsMissing`
      </td>

      <td>
        Total number of replicas that are missing (number of desired replicas, podsDesired, minus the total number of replicas, podsTotal)
      </td>
    </tr>

  </tbody>
</table>

### ReplicaSet data [#replica-set-data]

Query the `K8sReplicasetSample` event for `ReplicaSet` data:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        Replica attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name that you assigned to the cluster when you installed the Kubernetes integration
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        Timestamp of when the `ReplicaSet` was created
      </td>
    </tr>

    <tr>
      <td>
        `deploymentName`
      </td>

      <td>
        Name of the deployment to be used as an identifier
      </td>
    </tr>

    <tr>
      <td>
        `namespace`
      </td>

      <td>
        Name of the namespace that the `ReplicaSet` belongs to
      </td>
    </tr>

    <tr>
      <td>
        `observedGeneration`
      </td>

      <td>
        Integer representing generation observed by the `ReplicaSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsDesired`
      </td>

      <td>
        Number of replicas that you defined in the deployment
      </td>
    </tr>

    <tr>
      <td>
        `podsFullyLabeled`
      </td>

      <td>
        Number of pods that have labels that match the `ReplicaSet` pod template labels
      </td>
    </tr>

    <tr>
      <td>
        `podsReady`
      </td>

      <td>
        Number of replicas that are ready for this `ReplicaSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsTotal`
      </td>

      <td>
        Total number of replicas that are currently running
      </td>
    </tr>

    <tr>
      <td>
        `podsMissing`
      </td>

      <td>
        Total number of replicas that are currently missing (number of desired replicas, podsDesired, minus the number of ready replicas, podsReady)
      </td>
    </tr>

    <tr>
      <td>
        `replicasetName`
      </td>

      <td>
        Name of the `ReplicaSet` to be used as an identifier
      </td>
    </tr>
  </tbody>
</table>

### DaemonSet data [#daemonset-data]

Query the `K8sDaemonsetSample` event for `DaemonSet` data:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        DaemonSet attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name that you assigned to the cluster when you installed the Kubernetes integration
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        Timestamp of when the `DaemonSet` was created
      </td>
    </tr>

    <tr>
      <td>
        `namespaceName`
      </td>

      <td>
        Name of the namespace that the `DaemonSet` belongs to
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        Labels associated with your `DaemonSet`, so you can filter and query for specific `DaemonSet`
      </td>
    </tr>

    <tr>
      <td>
        daemonsetName
      </td>

      <td>
        Name associated with the `DaemonSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsDesired`
      </td>

      <td>
        The number of nodes that should be running the daemon pod
      </td>
    </tr>

    <tr>
      <td>
        `podsScheduled`
      </td>

      <td>
        The number of nodes running at least one daemon pod and are supposed to
      </td>
    </tr>

    <tr>
      <td>
        `podsAvailable`
      </td>

      <td>
        The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available
      </td>
    </tr>

    <tr>
      <td>
        `podsReady`
      </td>

      <td>
        The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready
      </td>
    </tr>

    <tr>
      <td>
        `podsUnavailable`
      </td>

      <td>
        The number of nodes that should be running the daemon pod and have none of the daemon pod running and available
      </td>
    </tr>

    <tr>
      <td>
        `podsMisscheduled`
      </td>

      <td>
        The number of nodes running a daemon pod but are not supposed to
      </td>
    </tr>

    <tr>
      <td>
        `podsUpdatedScheduled`
      </td>

      <td>
        The total number of nodes that are running updated daemon pod
      </td>
    </tr>

    <tr>
      <td>
        `podsMissing`
      </td>

      <td>
        Total number of replicas that are currently missing (number of desired replicas, podsDesired, minus the number of ready replicas, podsReady)
      </td>
    </tr>

    <tr>
      <td>
        `metadataGeneration`
      </td>

      <td>
        Sequence number representing a specific generation of the desired state
      </td>
    </tr>
  </tbody>
</table>

### StatefulSet data [#statefulset-data]

Query the `K8sStatefulsetSample` event for `StatefulSet` data:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        StatefulSet attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name that you assigned to the cluster when you installed the Kubernetes integration
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        Timestamp of when the `StatefulSet` was created
      </td>
    </tr>

    <tr>
      <td>
        `namespaceName`
      </td>

      <td>
        Name of the namespace that the `StatefulSet` belongs to
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        Labels associated with your `StatefulSet`, so you can filter and query for specific `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `statefulsetName`
      </td>

      <td>
        Name associated with the `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsDesired`
      </td>

      <td>
        Number of desired pods for a `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsReady`
      </td>

      <td>
        The number of ready replicas per `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsCurrent`
      </td>

      <td>
        The number of current replicas per `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsTotal`
      </td>

      <td>
        The number of replicas per `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsUpdated`
      </td>

      <td>
        The number of updated replicas per `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsMissing`
      </td>

      <td>
        Total number of replicas that are currently missing (number of desired replicas, podsDesired, minus the number of ready replicas, podsReady)
      </td>
    </tr>

    <tr>
      <td>
        `observedGeneration`
      </td>

      <td>
        The generation observed by the `StatefulSet` controller
      </td>
    </tr>

    <tr>
      <td>
        `metadataGeneration`
      </td>

      <td>
        Sequence number representing a specific generation of the desired state for the `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `currentRevision`
      </td>

      <td>
        Indicates the version of the `StatefulSet` used to generate pods in the sequence. Value range: between <var>0</var> and <var>podsCurrent</var>
      </td>
    </tr>

    <tr>
      <td>
        `updateRevision`
      </td>

      <td>
        Indicates the version of the `StatefulSet` used to generate pods in the sequence. Value range: between <var>podsDesired-podsUpdated</var> and <var>podsDesired</var>
      </td>
    </tr>
  </tbody>
</table>

### Pod data [#pod-data]

Query the `K8sPodSample` event for pod data:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        Pod attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name that you assigned to the cluster when you installed the Kubernetes integration
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        Timestamp of when the pod was created in epoch seconds
      </td>
    </tr>

    <tr>
      <td>
        `createdBy`
      </td>

      <td>
        Name of the Kubernetes object that created the pod.

        For example, `newrelic-infra`
      </td>
    </tr>

    <tr>
      <td>
        `createdKind`
      </td>

      <td>
        Kind of Kubernetes object that created the pod.

        For example, `DaemonSet`.
      </td>
    </tr>

    <tr>
      <td>
        `deploymentName`
      </td>

      <td>
        Name of the deployment to be used as an identifier
      </td>
    </tr>

    <tr>
      <td>
        `isReady`
      </td>

      <td>
        Boolean representing whether or not the pod is ready to serve requests
      </td>
    </tr>

    <tr>
      <td>
        `isScheduled`
      </td>

      <td>
        Boolean representing whether or not the pod has been scheduled to run on a node
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        Labels associated with your pod, so you can filter and query for specific pods
      </td>
    </tr>

    <tr>
      <td>
        `message`
      </td>

      <td>
        Details related to the last pod status change
      </td>
    </tr>

    <tr>
      <td>
        `namespace`
      </td>

      <td>
        Name of the namespace that the pod belongs to
      </td>
    </tr>

    <tr>
      <td>
        `net.errorCountPerSecond`
      </td>

      <td>
        Number of errors per second while receiving/transmitting over the network
      </td>
    </tr>

    <tr>
      <td>
        `net.errorsPerSecond`
      </td>

      <td>
        Number of errors per second
      </td>
    </tr>

    <tr>
      <td>
        `net.rxBytesPerSecond`
      </td>

      <td>
        Number of bytes per second received over the network
      </td>
    </tr>

    <tr>
      <td>
        `net.txBytesPerSecond`
      </td>

      <td>
        Number of bytes per second transmitted over the network
      </td>
    </tr>

    <tr>
      <td>
        `nodeIP`
      </td>

      <td>
        Host IP address that the pod is running on
      </td>
    </tr>

    <tr>
      <td>
        `nodeName`
      </td>

      <td>
        Host name that the pod is running on
      </td>
    </tr>

    <tr>
      <td>
        `podIP`
      </td>

      <td>
        IP address of the pod. If it doesn't have an IP, it'll be empty
      </td>
    </tr>

    <tr>
      <td>
        `podName`
      </td>

      <td>
        Name of the pod to be used as an identifier
      </td>
    </tr>

    <tr>
      <td>
        `reason`
      </td>

      <td>
        Reason why the pod is in the current status
      </td>
    </tr>

    <tr>
      <td>
        `startTime`
      </td>

      <td>
        Timestamp of when the pod started running in epoch seconds
      </td>
    </tr>

    <tr>
      <td>
        `status`
      </td>

      <td>
        Current status of the pod.

        Value can be `Pending`, `Running`, `Succeeded`, `Failed`, `Unknown`
      </td>
    </tr>
  </tbody>
</table>

### Cluster data [#cluster-data]

Query the `K8sClusterSample` event to see cluster data:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        Cluster attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name that you assigned to the cluster when you installed the Kubernetes integration
      </td>
    </tr>

    <tr>
      <td>
        `clusterK8sVersion`
      </td>

      <td>
        Kubernetes version that the cluster is running
      </td>
    </tr>
  </tbody>
</table>

### Container data [#container-data]

Query the `K8sContainerSample` event for container data:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        Container attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name that you assigned to the cluster when you installed the Kubernetes integration
      </td>
    </tr>

    <tr>
      <td>
        `containerID`
      </td>

      <td>
        Unique ID associated with the container. If you are running Docker, this is the Docker container id
      </td>
    </tr>

    <tr>
      <td>
        `containerImage`
      </td>

      <td>
        Name of the image that the container is running
      </td>
    </tr>

    <tr>
      <td>
        `containerImageID`
      </td>

      <td>
        Unique ID associated with the image that the container is running
      </td>
    </tr>

    <tr>
      <td>
        `containerName`
      </td>

      <td>
        Name associated with the container
      </td>
    </tr>

    <tr>
      <td>
        `cpuLimitCores`
      </td>

      <td>
        Integer representing limit CPU cores defined for the container in the pod specification
      </td>
    </tr>

    <tr>
      <td>
        `cpuRequestedCores`
      </td>

      <td>
        Requested CPU cores defined for the container in the pod specification
      </td>
    </tr>

    <tr>
      <td>
        `cpuUsedCores`
      </td>

      <td>
        CPU cores actually used by the container
      </td>
    </tr>

    <tr>
      <td>
        `cpuCoresUtilization`
      </td>

      <td>
        Percentage of CPU cores actually used by the container with respect to the CPU limit specified. This percentage is based on this calculation: (`cpuUsedCores` / `cpuLimitCores`) \* 100
      </td>
    </tr>

    <tr>
      <td>
        `requestedCpuCoresUtilization`
      </td>

      <td>
        Percentage of CPU cores actually used by the container with respect to the CPU request specified
      </td>
    </tr>

    <tr>
      <td>
        `deploymentName`
      </td>

      <td>
        Name of the deployment to be used as an identifier
      </td>
    </tr>

    <tr>
      <td>
        `isReady`
      </td>

      <td>
        Boolean. Whether or not the container's readiness check succeeded
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        Labels associated with your container, so you can filter and query for specific containers
      </td>
    </tr>

    <tr>
      <td>
        `memoryLimitBytes`
      </td>

      <td>
        Integer representing limit bytes of memory defined for the container in the pod specification
      </td>
    </tr>

    <tr>
      <td>
        `memoryRequestedBytes`
      </td>

      <td>
        Integer. Requested bytes of memory defined for the container in the pod specification
      </td>
    </tr>

    <tr>
      <td>
        `memoryUsedBytes`
      </td>

      <td>
        Integer. Bytes of memory actually used by the container
      </td>
    </tr>

    <tr>
      <td>
        `memoryUtilization`
      </td>

      <td>
        Percentage of memory actually used by the container with respect to the memory limit specified
      </td>
    </tr>

    <tr>
      <td>
        `requestedMemoryUtilization`
      </td>

      <td>
        Percentage of memory actually used by the container with respect to the memory request specified
      </td>
    </tr>

    <tr>
      <td>
        `memoryWorkingSetBytes`
      </td>

      <td>
        Integer. Bytes of memory in the working set
      </td>
    </tr>
    <tr>
      <td>
        `memoryWorkingSetUtilization`
      </td>

      <td>
        Percentage of working set memory actually used by the container with respect to the memory limit specified
      </td>
    </tr>

    <tr>
      <td>
        `requestedMemoryWorkingSetUtilization`
      </td>

      <td>
        Percentage of working set memory actually used by the container with respect to the memory request specified
      </td>
    </tr>

    <tr>
      <td>
        `namespace`
      </td>

      <td>
        Name of the namespace that the container belongs to
      </td>
    </tr>

    <tr>
      <td>
        `nodeIP`
      </td>

      <td>
        Host IP address the container is running on
      </td>
    </tr>

    <tr>
      <td>
        `nodeName`
      </td>

      <td>
        Host name that the container is running on
      </td>
    </tr>

    <tr>
      <td>
        `podName`
      </td>

      <td>
        Name of the pod that the container is in, to be used as an identifier
      </td>
    </tr>

    <tr>
      <td>
        `reason`
      </td>

      <td>
        Provides a reason why the container is in the current status
      </td>
    </tr>

    <tr>
      <td>
        `restartCount`
      </td>

      <td>
        Number of times the container has been restarted
      </td>
    </tr>

    <tr>
      <td>
        `status`
      </td>

      <td>
        Current status of the container.

        Value can be `Running`, `Terminated`, or `Unknown`
      </td>
    </tr>

    <tr>
      <td>
        `containerCpuCfsPeriodsDelta`
      </td>

      <td>
        Delta change of elapsed enforcement period intervals
      </td>
    </tr>

    <tr>
      <td>
        `containerCpuCfsThrottledPeriodsDelta`
      </td>

      <td>
        Delta change of throttled period intervals
      </td>
    </tr>

    <tr>
      <td>
        `containerCpuCfsThrottledSecondsDelta`
      </td>

      <td>
        Delta change of duration the container has been throttled, in seconds
      </td>
    </tr>

    <tr>
      <td>
        `containerCpuCfsPeriodsTotal`
      </td>

      <td>
        Total number of elapsed enforcement period intervals
      </td>
    </tr>

    <tr>
      <td>
        `containerCpuCfsThrottledPeriodsTotal`
      </td>

      <td>
        Total number of throttled period intervals
      </td>
    </tr>

    <tr>
      <td>
        `containerCpuCfsThrottledSecondsTotal`
      </td>

      <td>
        Total time duration the container has been throttled, in seconds
      </td>
    </tr>

    <tr>
      <td>
        `containerMemoryMappedFileBytes`
      </td>

      <td>
        Total size of memory mapped files used by this container, in bytes
      </td>
    </tr>
  </tbody>
</table>

### Volume data [#volume-data]

Query the `K8sVolumeSample` event for volume data:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        Volume attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `volumeName`
      </td>

      <td>
        Name that you assigned to the volume at creation
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Cluster where the volume is configured
      </td>
    </tr>

    <tr>
      <td>
        `namespace`
      </td>

      <td>
        Namespace where the volume is configured
      </td>
    </tr>

    <tr>
      <td>
        `podName`
      </td>

      <td>
        The pod that the volume is attached to. The Kubernetes monitoring integration lists Volumes that are attached to a pod
      </td>
    </tr>

    <tr>
      <td>
        `persistent`
      </td>

      <td>
        If this is a [persistent](https://kubernetes.io/docs/concepts/storage/persistent-volumes/) volume, this value is set to `true`
      </td>
    </tr>

    <tr>
      <td>
        `pvcNamespace`
      </td>

      <td>
        Namespace where the Persistent Volume Claim is configured
      </td>
    </tr>

    <tr>
      <td>
        `pvcName`
      </td>

      <td>
        Name that you assigned to the Persistent Volume Claim at creation
      </td>
    </tr>

    <tr>
      <td>
        `fsCapacityBytes`
      </td>

      <td>
        Capacity of the volume, in bytes
      </td>
    </tr>

    <tr>
      <td>
        `fsUsedBytes`
      </td>

      <td>
        Usage of the volume, in bytes
      </td>
    </tr>

    <tr>
      <td>
        `fsAvailableBytes`
      </td>

      <td>
        Capacity available of the volume, in bytes
      </td>
    </tr>

    <tr>
      <td>
        `fsUsedPercent`
      </td>

      <td>
        Usage of the volume in percentage
      </td>
    </tr>

    <tr>
      <td>
        `fsInodes`
      </td>

      <td>
        Total `inodes` of the volume
      </td>
    </tr>

    <tr>
      <td>
        `fsInodesUsed`
      </td>

      <td>
        `inodes` used in the volume
      </td>
    </tr>

    <tr>
      <td>
        `fsInodesFree`
      </td>

      <td>
        `inodes` available in the volume
      </td>
    </tr>
  </tbody>
</table>

Volume data is available for volume plugins that implement the MetricsProvider interface:

* AWSElasticBlockStore
* AzureDisk
* AzureFile
* Cinder
* Flexvolume
* Flocker
* GCEPersistentDisk
* GlusterFS
* iSCSI
* NFS
* StorageOS
* VsphereVolume

### API server data [#api-server-data]

Query the `K8sApiServerSample` [event](/docs/telemetry-data-platform/understand-data/new-relic-data-types/#events-new-relic) to see API Server data. For more information, see [Configure control plane monitoring](http://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/configure-control-plane-monitoring):

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        API server attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `processResidentMemoryBytes`
      </td>

      <td>
        Resident memory size, in bytes
      </td>
    </tr>

    <tr>
      <td>
        `processCpuSecondsDelta`
      </td>

      <td>
        Difference of the user and system CPU time spent, in seconds
      </td>
    </tr>

    <tr>
      <td>
        `goThreads`
      </td>

      <td>
        Number of OS threads created
      </td>
    </tr>

    <tr>
      <td>
        `goGoroutines`
      </td>

      <td>
        Number of goroutines that currently exist
      </td>
    </tr>

    <tr>
      <td>
        `apiserverRequestDelta_verb_VERB_code_CODE`
      </td>

      <td>
        Difference of the number of apiserver requests, broken out for each verb and HTTP response code
      </td>
    </tr>

    <tr>
      <td>
        `apiserverRequestRate_verb_VERB_code_CODE`
      </td>

      <td>
        Rate of apiserver requests, broken out for each verb and HTTP response code
      </td>
    </tr>

    <tr>
      <td>
        `restClientRequestsDelta_code_CODE_method_METHOD`
      </td>

      <td>
        Difference of the number of HTTP requests, partitioned by method and code
      </td>
    </tr>

    <tr>
      <td>
        `restClientRequestsRate_code_CODE_method_METHOD`
      </td>

      <td>
        Rate of the number of HTTP requests, partitioned by method and code
      </td>
    </tr>

    <tr>
      <td>
        `etcdObjectCounts_resource_RESOURCE-KIND`
      </td>

      <td>
        Number of stored objects at the time of last check, split by kind
      </td>
    </tr>
  </tbody>
</table>

### Controller manager data [#controller-manager-data]

Query the `K8sControllerManagerSample` event to see Controller manager data. For more information, see [Configure control plane monitoring](http://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/configure-control-plane-monitoring):

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        Controller manager attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `processResidentMemoryBytes`
      </td>

      <td>
        Resident memory size, in bytes
      </td>
    </tr>

    <tr>
      <td>
        `processCpuSecondsDelta`
      </td>

      <td>
        Difference of the user and system CPU time spent in seconds
      </td>
    </tr>

    <tr>
      <td>
        `goThreads`
      </td>

      <td>
        Number of OS threads created
      </td>
    </tr>

    <tr>
      <td>
        `goGoroutines`
      </td>

      <td>
        Number of goroutines that currently exist
      </td>
    </tr>

    <tr>
      <td>
        `workqueueAddsDelta_name_WORK-QUEUE-NAME`
      </td>

      <td>
        Difference of the total number of adds handled by workqueue
      </td>
    </tr>

    <tr>
      <td>
        `workqueueDepth_name_WORK-QUEUE-NAME`
      </td>

      <td>
        Current depth of workqueue
      </td>
    </tr>

    <tr>
      <td>
        `workqueueRetriesDelta_name_WORK-QUEUE-NAME`
      </td>

      <td>
        Difference of the total number of retries handled by workqueue
      </td>
    </tr>

    <tr>
      <td>
        `leaderElectionMasterStatus`
      </td>

      <td>
        Gauge of if the reporting system is master of the relevant lease, `0` indicates `backup`, `1` indicates `master`
      </td>
    </tr>
  </tbody>
</table>

### Scheduler data [#scheduler-data]

Query the `K8sSchedulerSample` event to see Scheduler data. For more information, see [Configure control plane monitoring](http://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/configure-control-plane-monitoring):

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        Scheduler attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `processResidentMemoryBytes`
      </td>

      <td>
        Resident memory size, in bytes
      </td>
    </tr>

    <tr>
      <td>
        `processCpuSecondsDelta`
      </td>

      <td>
        Difference of the user and system CPU time spent in seconds
      </td>
    </tr>

    <tr>
      <td>
        `goThreads`
      </td>

      <td>
        Number of OS threads created
      </td>
    </tr>

    <tr>
      <td>
        `goGoroutines`
      </td>

      <td>
        Number of goroutines that currently exist
      </td>
    </tr>

    <tr>
      <td>
        `leaderElectionMasterStatus`
      </td>

      <td>
        Gauge of if the reporting system is master of the relevant lease, `0` indicates `backup`, `1` indicates `master`
      </td>
    </tr>

    <tr>
      <td>
        `httpRequestDurationMicroseconds_handler_HANDLER_quantile_QUANTILE`
      </td>

      <td>
        The HTTP request latencies in microseconds, per quantile
      </td>
    </tr>

    <tr>
      <td>
        `httpRequestDurationMicroseconds_handler_HANDLER_sum`
      </td>

      <td>
        The sum of the HTTP request latencies, in microseconds
      </td>
    </tr>

    <tr>
      <td>
        `httpRequestDurationMicroseconds_handler_HANDLER_count`
      </td>

      <td>
        The number of observed HTTP requests events
      </td>
    </tr>

    <tr>
      <td>
        `restClientRequestsDelta_code_CODE_host_HOST_method_METHOD`
      </td>

      <td>
        Difference of the number of HTTP requests, partitioned by status code, method, and host
      </td>
    </tr>

    <tr>
      <td>
        `restClientRequestsRate_code_CODE_host_HOST_method_METHOD`
      </td>

      <td>
        Rate of the number of HTTP requests, partitioned by status code, method, and host
      </td>
    </tr>

    <tr>
      <td>
        `schedulerScheduleAttemptsDelta_result_RESULT`
      </td>

      <td>
        Difference of the number of attempts to schedule pods, by the result. `unschedulable` means a pod could not be scheduled, while `error` means an internal scheduler problem
      </td>
    </tr>

    <tr>
      <td>
        `schedulerScheduleAttemptsRate_result_RESULT`
      </td>

      <td>
        Rate of the number of attempts to schedule pods, by the result. `unschedulable` means a pod could not be scheduled, while `error` means an internal scheduler problem
      </td>
    </tr>

    <tr>
      <td>
        `schedulerSchedulingDurationSeconds_operation_OPERATION_quantile_QUANTILE`
      </td>

      <td>
        Scheduling latency in seconds split by sub-parts of the scheduling operation
      </td>
    </tr>

    <tr>
      <td>
        `schedulerSchedulingDurationSeconds_operation_OPERATION_sum`
      </td>

      <td>
        The sum of scheduling latency in seconds split by sub-parts of the scheduling operation
      </td>
    </tr>

    <tr>
      <td>
        `schedulerSchedulingDurationSeconds_operation_OPERATION_count`
      </td>

      <td>
        The number of observed events of schedulings split by sub-parts of the scheduling operation.
      </td>
    </tr>

    <tr>
      <td>
        `schedulerPreemptionAttemptsDelta`
      </td>

      <td>
        Difference of the total preemption attempts in the cluster till now
      </td>
    </tr>

    <tr>
      <td>
        `schedulerPodPreemptionVictims`
      </td>

      <td>
        Number of selected preemption victims
      </td>
    </tr>
  </tbody>
</table>

### etcd data [#etcd-data]

Query the `K8sEtcdSample` [event](/docs/telemetry-data-platform/understand-data/new-relic-data-types/#events-new-relic) to see etcd data. For more information, see [Configure control plane monitoring](http://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/configure-control-plane-monitoring):

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        etcd attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `processResidentMemoryBytes`
      </td>

      <td>
        Resident memory size, in bytes
      </td>
    </tr>

    <tr>
      <td>
        `processCpuSecondsDelta`
      </td>

      <td>
        Difference of the user and system CPU time spent in seconds
      </td>
    </tr>

    <tr>
      <td>
        `goThreads`
      </td>

      <td>
        Number of OS threads created
      </td>
    </tr>

    <tr>
      <td>
        `goGoroutines`
      </td>

      <td>
        Number of goroutines that currently exist
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerHasLeader`
      </td>

      <td>
        Whether or not a leader exists. `1` is existence, `0` is not
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerLeaderChangesSeenDelta`
      </td>

      <td>
        Difference of the number of leader changes seen
      </td>
    </tr>

    <tr>
      <td>
        `etcdMvccDbTotalSizeInBytes`
      </td>

      <td>
        Total size of the underlying database physically allocated, in bytes
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsCommittedDelta`
      </td>

      <td>
        Difference of the total number of consensus proposals committed
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsCommittedRate`
      </td>

      <td>
        Rate of the total number of consensus proposals committed
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsAppliedDelta`
      </td>

      <td>
        Difference of the total number of consensus proposals applied
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsAppliedRate`
      </td>

      <td>
        Rate of the total number of consensus proposals applied
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsPending`
      </td>

      <td>
        The current number of pending proposals to commit
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsFailedDelta`
      </td>

      <td>
        Difference of the total number of failed proposals seen
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsFailedRate`
      </td>

      <td>
        Rate of the total number of failed proposals seen
      </td>
    </tr>

    <tr>
      <td>
        `processOpenFds`
      </td>

      <td>
        Number of open file descriptors
      </td>
    </tr>

    <tr>
      <td>
        `processMaxFds`
      </td>

      <td>
        Maximum number of open file descriptors
      </td>
    </tr>

    <tr>
      <td>
        `processFdsUtilization`
      </td>

      <td>
        Percentage open file descriptors with respect to the maximum number that can be opened
      </td>
    </tr>

    <tr>
      <td>
        `etcdNetworkClientGrpcReceivedBytesRate`
      </td>

      <td>
        Rate of the total number of bytes received from gRPC clients
      </td>
    </tr>

    <tr>
      <td>
        `etcdNetworkClientGrpcSentBytesRate`
      </td>

      <td>
        Rate of the total number of bytes sent to gRPC clients
      </td>
    </tr>
  </tbody>
</table>

### Endpoint data [#endpoint-data]

Query the `K8sEndpointSample` event for endpoint data:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        Endpoint attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name that you assigned to the cluster when you installed the Kubernetes integration
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        Timestamp of when the endpoint was created
      </td>
    </tr>

    <tr>
      <td>
        `namespaceName`
      </td>

      <td>
        Name of the namespace that the endpoint belongs to
      </td>
    </tr>

    <tr>
      <td>
        `endpointName`
      </td>

      <td>
        Name associated with the endpoint
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        Labels associated with your endpoint, so you can filter and query for specific endpoints
      </td>
    </tr>

    <tr>
      <td>
        `addressAvailable`
      </td>

      <td>
        Number of addresses available in endpoint
      </td>
    </tr>

    <tr>
      <td>
        `addressNotReady`
      </td>

      <td>
        Number of addresses not ready in endpoint
      </td>
    </tr>
  </tbody>
</table>

### Service data [#service-data]

Query the `K8sServiceSample` [event](/docs/telemetry-data-platform/understand-data/new-relic-data-types/#events-new-relic) for service data:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        Service attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name that you assigned to the cluster when you installed the Kubernetes integration
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        Timestamp of when the service was created
      </td>
    </tr>

    <tr>
      <td>
        `namespaceName`
      </td>

      <td>
        Name of the namespace that the service belongs to
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        Labels associated with your service, so you can filter and query for specific service
      </td>
    </tr>

    <tr>
      <td>
        `serviceName`
      </td>

      <td>
        Name associated with the service
      </td>
    </tr>

    <tr>
      <td>
        `loadBalancerIP`
      </td>

      <td>
        The IP of the external load balancer, if `Spectype` is `LoadBalancer`.
      </td>
    </tr>

    <tr>
      <td>
        `externalName`
      </td>

      <td>
        The external name value, if `Spectype` is `ExternalName`
      </td>
    </tr>

    <tr>
      <td>
        `clusterIP`
      </td>

      <td>
        The internal cluster IP, if `Spectype` is `ClusterIP`
      </td>
    </tr>

    <tr>
      <td>
        `specType`
      </td>

      <td>
        Type of the service
      </td>
    </tr>

    <tr>
      <td>
        `selector.LABEL_NAME`
      </td>

      <td>
        The label selector that this service targets
      </td>
    </tr>
  </tbody>
</table>

### Horizontal Pod Autoscaler data [#hpa-data]

Query the `K8sHpaSample` event for Horizontal Pod Autoscaler data:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        HPA attribute
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Name that you assigned to the cluster when you installed the Kubernetes integration
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        Labels associated with your HPA, so you can filter and query for specific autoscaler
      </td>
    </tr>

    <tr>
      <td>
        `currentReplicas`
      </td>

      <td>
        Current number of replicas of pods managed by this autoscaler
      </td>
    </tr>

    <tr>
      <td>
        `desiredReplicas`
      </td>

      <td>
        Desired number of replicas of pods managed by this autoscaler
      </td>
    </tr>

    <tr>
      <td>
        `minReplicas`
      </td>

      <td>
        Lower limit for the number of pods that can be set by the autoscaler, 1 by default
      </td>
    </tr>

    <tr>
      <td>
        `maxReplicas`
      </td>

      <td>
        Upper limit for the number of pods that can be set by the autoscaler; cannot be smaller than `minReplicas`
      </td>
    </tr>

    <tr>
      <td>
        `targetMetric`
      </td>

      <td>
        The metric specifications used by this autoscaler when calculating the desired replica count
      </td>
    </tr>

    <tr>
      <td>
        `isAble`
      </td>

      <td>
        Boolean representing whether or not the autoscaler is able to fetch and update scales, as well as whether or not any backoff-related conditions would prevent scaling
      </td>
    </tr>

    <tr>
      <td>
        `isActive`
      </td>

      <td>
        Boolean representing whether or not the autoscaler is enabled (if it's able to calculate the desired scales)
      </td>
    </tr>

    <tr>
      <td>
        `isLimited`
      </td>

      <td>
        Boolean representing whether or not the autoscaler is capped, either up or down, by the maximum or minimum replicas configured
      </td>
    </tr>

    <tr>
      <td>
        `labels`
      </td>

      <td>
        Number of Kubernetes labels converted to Prometheus labels
      </td>
    </tr>

    <tr>
      <td>
        `metadataGeneration`
      </td>

      <td>
        The generation observed by the HorizontalPodAutoscaler controller
      </td>
    </tr>
  </tbody>
</table>

## Kubernetes metadata in APM-monitored applications [#apm-custom-attributes]

[By linking your applications with Kubernetes](/docs/integrations/kubernetes-integration/metadata-injection/kubernetes-apm-metadata-injection), the following attributes are added to application trace and distributed trace:

* `nodeName`
* `containerName`
* `podName`
* `clusterName`
* `deploymentName`
* `namespaceName`

## For more help [#logs-versions]
