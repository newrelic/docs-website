---
title: Introduction to Core Tracing
tags:
  - Understand dependencies
  - Distributed tracing
  - Core Tracing
metaDescription: Control distributed tracing volume and granularity with Core Tracing to reduce costs while maintaining visibility.
freshnessValidatedDate: never
---

Core Tracing gives you configurable controls to manage the volume and granularity of your distributed tracing data. Think of it as having "dials" you can adjust to balance cost, coverage, and detail based on what matters most for each service.

This isn't a separate version of distributed tracing—it's a set of configuration options within your existing DT setup that lets you tune your data to match your needs.

## What problems does Core Tracing solve? [#problems-solved]

Distributed tracing is powerful, but we've heard from customers facing three common challenges:

### High barrier to entry for new customers

You want to see the value of distributed tracing, but instrumenting your entire service landscape feels like a big investment. The cost and effort can make it hard to justify before you've seen the results.

### Trace fragmentation from incomplete instrumentation

When only some of your services send traces, you end up with broken-looking maps and incomplete visibility. It's hard to know what you're missing or how to fix it.

### Inflexible cost management

Full distributed tracing data can get expensive at scale. You're forced into an all-or-nothing choice: capture everything from a service or capture nothing at all. You need a middle ground.

Core Tracing solves these problems by letting you control exactly how much data you collect from each service.

## How Core Tracing works [#how-it-works]

Core Tracing provides three configuration "dials" you can adjust independently:

### Dial 1: Minimal spans tracing (MST)

Reduce the number of spans by controlling which span types get captured:

* **All spans** (default): Entry spans, exit spans, and in-process spans
* **Entry and exit only**: Skip in-process spans
* **Minimal**: Entry spans plus unique exit spans only

This can reduce span volume by 50-70% while preserving service-to-service connectivity.

### Dial 2: Low-granularity tracing (LGT)

Reduce the size of each span by sending only essential attributes:

* **All attributes** (default): Complete span metadata
* **Minimal attributes**: Just what's needed for service relationships and flow maps

This can reduce data volume by 30-45% while maintaining trace connectivity.

### Dial 3: Adaptive sampling rate

Control how many traces get sampled per minute:

* **Default**: 10 traces/minute (most agents) or 120 traces/minute (Java)
* **Custom**: Adjust up to capture rare errors or down to reduce costs

You can combine these dials. For example, use MST + LGT together for maximum cost reduction on low-priority services, while keeping full tracing on business-critical services.

## What you keep vs what you lose [#tradeoffs]

Core Tracing is designed to preserve what matters most for troubleshooting while reducing costs:

<table>
  <thead>
    <tr>
      <th width={200}>
        You keep
      </th>
      <th>
        You lose
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        * Complete end-to-end traces
        * Service-to-service relationships
        * Request flow visualization
        * Dynamic Flow Map connectivity
        * Transaction 360 data
        * Error tracking across services
      </td>
      <td>
        * In-process method-level detail (MST)
        * Detailed span attributes (LGT)
        * Some custom attributes (LGT)
        * Internal code path visibility
      </td>
    </tr>
  </tbody>
</table>

The key insight: you maintain the "what" and "where" of your system behavior while reducing the "how" details.

## When should you use Core Tracing? [#when-to-use]

Consider Core Tracing if you're in any of these situations:

<CollapserGroup>
  <Collapser
    id="new-customer"
    title="You're new to distributed tracing and want to start small"
  >
    Use LGT to light up your entire service map at low cost. You'll see complete traces and prove the value quickly. Then dial up detail on services that matter most.

    **Recommended config:** LGT on all services, then add full DT selectively.
  </Collapser>

  <Collapser
    id="fragmented-traces"
    title="You have gaps in your trace coverage"
  >
    Use LGT on uninstrumented services to fill the gaps. You'll get complete end-to-end traces without the cost of full instrumentation everywhere.

    **Recommended config:** LGT on services currently not sending traces.
  </Collapser>

  <Collapser
    id="cost-optimization"
    title="You need to reduce distributed tracing costs"
  >
    Prioritize your services and use different configurations based on importance. Business-critical services keep full DT, while supporting services use MST or MST + LGT.

    **Recommended config:** Tiered approach based on service priority.
  </Collapser>

  <Collapser
    id="large-deployment"
    title="You have many microservices generating lots of span data"
  >
    Use MST to dramatically reduce span volume while maintaining connectivity. This is especially effective for services with deep call stacks.

    **Recommended config:** MST on services with many in-process spans.
  </Collapser>
</CollapserGroup>

## Requirements [#requirements]

To use Core Tracing, you need:

* Distributed tracing enabled on your services
* Compatible agent versions (see configuration docs for specific version requirements)
* Standard New Relic user permissions for configuration changes

Core Tracing works with both New Relic agents and OpenTelemetry instrumentation. When services with different configurations communicate, trace context propagates correctly—you can mix Core Tracing and full DT configurations across your architecture.

## Get started [#get-started]

Ready to configure Core Tracing? Choose your approach:

* [Configure minimal spans tracing](/docs/distributed-tracing/core-tracing/configure-minimal-spans-tracing): Reduce span volume by controlling which span types get captured
* [Configure low-granularity tracing](/docs/distributed-tracing/core-tracing/configure-low-granularity-tracing): Reduce span size by limiting attributes
* [Configure adaptive sampling rate](/docs/distributed-tracing/core-tracing/configure-adaptive-sampling-rate): Control how many traces get sampled

Or explore strategic guidance:

* [Cost optimization strategies](/docs/distributed-tracing/core-tracing/cost-optimization-strategies): Learn how to reduce costs while maintaining visibility
* [Use cases and examples](/docs/distributed-tracing/core-tracing/use-cases-examples): See real-world scenarios for Core Tracing

<Callout variant="tip">
  Start conservative. Enable Core Tracing on a small subset of services first, monitor the impact for 1-2 weeks, then expand based on results.
</Callout>
