---
title: 'Automatically instrument your app with OpenTelemetry'
metaDescription: 'Automatically instrument your app with OpenTelemetry'
freshnessValidatedDate: never
---

OpenTelemetry standardizes the way we work with telemetry. So, before you learn about what OpenTelemetry is, how it works, and why it's valuable, you need to have a solid understanding of what telemetry is.

## Objectives [#objectives]

In this first chapter, you learn answers to questions like:

- What is telemetry?
- What kinds of data is it concerned with?
- What are the traditional ways of working with telemetry data?

## Prerequisite knowledge [#prereq-knowledge]

As this chapter introduces you to the basics of telemetry, you don't need to have any previous experience with it to follow along. That said, you would benefit from a familiarity with:

- [Traces](/docs/data-apis/understand-data/new-relic-data-types/#trace-data)
- [Metrics](/docs/data-apis/understand-data/new-relic-data-types/#dimensional-metrics)
- [Logs](/docs/data-apis/understand-data/new-relic-data-types/#log-data)
- Telemetry agents, like New Relic's

## Procedures [#procedures]

<Steps>
    <Step>
    ### Set up your lab environment [#set-up]

    1. Clone the lab repository:

        ```bash
        git clone https://github.com/newrelic-experimental/opentelemetry-dotnet-lab-materials
        ```

    2. Restore dependencies, build, and run the application:

        ```
        cd opentelemetry-dotnet-lab-materials
        dotnet restore app
        dotnet build app
        dotnet run --project app
        ```
        In the output, you see a url for your app:

        ```bash
        [output]   Determining projects to restore...
        [output]   All projects are up-to-date for restore.
        [output] Microsoft (R) Build Engine version 17.0.0+c9eb9dd64 for .NET
        [output] Copyright (C) Microsoft Corporation. All rights reserved.
        [output]
        [output]   Determining projects to restore...
        [output]   All projects are up-to-date for restore.
        [output]   opentelemetry-dotnet-lab-materials -> /workspace/opentelemetry-dotnet-lab-materials/app/bin/Debug/net6.0/opentelemetry-dotnet-lab-materials.dll
        [output]
        [output] {success}Build succeeded.
        [output]     0 Warning(s)
        [output]     0 Error(s)
        [output]
        [output] Time Elapsed 00:00:01.42
        [output] Building...
        [output] {success}info: {plain}Microsoft.Hosting.Lifetime[14]
        [output]       Now listening on: {blue}https://localhost:7072
        [output] {success}info: {plain}Microsoft.Hosting.Lifetime[0]
        [output]       Application started. Press Ctrl+C to shut down.
        [output] {success}info: {plain}Microsoft.Hosting.Lifetime[0]
        [output]       Hosting environment: Development
        [output] {success}info: {plain}Microsoft.Hosting.Lifetime[0]
        [output]       Content root path: /workspace/opentelemetry-dotnet-lab-materials/app/
        ```

        The application has a single endpoint at `/WeatherForcast`, which you can visit in your browser or with curl:

        ```bash
        curl -k https://localhost:7072/WeatherForecast
        [output] [{"date":"2021-11-18T16:03:02.655159-05:00","temperatureC":38,"temperatureF":100,"summary":"Chilly"},{"date":"2021-11-19T16:03:02.655161-05:00","temperatureC":-3,"temperatureF":27,"summary":"Mild"},{"date":"2021-11-20T16:03:02.655162-05:00","temperatureC":-8,"temperatureF":18,"summary":"Hot"},{"date":"2021-11-21T16:03:02.655162-05:00","temperatureC":3,"temperatureF":37,"summary":"Cool"},{"date":"2021-11-22T16:03:02.655162-05:00","temperatureC":10,"temperatureF":49,"summary":"Warm"}]
        ```

        <Callout variant="tip">
            You use the `-k` option to instruct curl to not verify the site's SSL certification. This is fine because you're making a request against localhost.
        </Callout>

        Leave this open so you can simulate requests against it.

    3. In another terminal window, run the load generator:

        ```bash
        cd opentelemetry-dotnet-lab-materials/sim
        pip install requests
        python simulator.py
        ```
    </Step>
    <Step>
    ### Instrument your application with OpenTelemetry [#instrument]

    Your .NET application is running and is getting a lot of traffic. You want to instrument it with OpenTelemetry because it lets you avoid being locked into a single vendor, it's open source, and it's supported by many actors in the observability space.

    Here, you learn how easy it is to configure the [OpenTelemetry SDK](https://github.com/open-telemetry/opentelemetry-dotnet) to automatically collect metrics and traces from your application and send them to New Relic so you can analyze the results later.

    1. Shut down your server.

    In the terminal window that's running your development server, press `<CTRL-C>`. You should see your server shut down. Now you can add some dependencies and update your app logic.

    2. Add the OpenTelemetry SDK and supporting packages:

    ```bash
    dotnet add app package --prerelease OpenTelemetry
    dotnet add app package --prerelease OpenTelemetry.Instrumentation.AspNetCore
    dotnet add app package --prerelease OpenTelemetry.Exporter.OpenTelemetryProtocol
    dotnet add app package --prerelease OpenTelemetry.Extensions.Hosting
    ```
    3. Create two environment variables that you use to configure your OpenTelemetry pipelines. Don't forget to replace the placeholders with real values:

    ```bash
    export OTEL_EXPORTER_OTLP_ENDPOINT=<REGION-BASED-OTLP-ENDPOINT>
    export NR_LICENSE_KEY=<YOUR-NEW-RELIC-LICENSE-KEY>
    ```

    The [OpenTelemetry Protocol](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md) (OTLP) endpoint is the url of our OpenTelemetry receiver. Your service sends data directly to New Relic through this endpoint. [We have a US endpoint and an EU endpoint](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/get-started/opentelemetry-get-started-intro/), so make sure you choose the appropriate one based on your region.

    There are several different types of API keys to choose from in New Relic that each serve a different purpose. To instrument your application with OpenTelemetry, you need a [license key](/docs/apis/intro-apis/new-relic-api-keys).

    4. In `app/Program.cs`, create a resource builder:

    ```jsx fileName=app/Program.cs
    using OpenTelemetry.Resources;

    var builder = WebApplication.CreateBuilder(args);

    builder.Services.AddControllers();
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddSwaggerGen();

    var resourceBuilder = ResourceBuilder
        .CreateDefault()
        .AddService("Weather-Forecast")
        .AddAttributes(new Dictionary<string, object> {
            { "environment", "production" }
        })
        .AddTelemetrySdk();

    var app = builder.Build();

    if (app.Environment.IsDevelopment())
    {
        app.UseSwagger();
        app.UseSwaggerUI();
    }

    app.UseHttpsRedirection();

    app.UseAuthorization();

    app.MapControllers();

    app.Run();
    ```
    An [OpenTelemetry resource](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/resource/sdk.md) describes a service as a collection of attributes.

    Here, on top of the default resource attributes, you define a service name and an environment. You also call `AddTelemetrySdk()`, which adds a suite of standard attributes defined within OpenTelemetry's sematic conventions such as:

        - `telemetry.sdk.name`
        - `telemetry.sdk.language`
        - `telemetry.sdk.version`

    This is important because it helps New Relic present you with an experience that's tailored to your application. You configure your telemetry pipelines with this resource builder. That way, these attributes are associated with all metrics and traces that this service generates.

5. Configure the OpenTelemetry SDK for [traces](/docs/apm/transactions/transaction-traces/introduction-transaction-traces):

    ```jsx fileName=app/Program.cs
    using OpenTelemetry.Resources;
    using OpenTelemetry.Trace;

    var builder = WebApplication.CreateBuilder(args);

    builder.Services.AddControllers();
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddSwaggerGen();

    var resourceBuilder = ResourceBuilder
        .CreateDefault()
        .AddService("Weather-Forecast")
        .AddAttributes(new Dictionary<string, object> {
            { "environment", "production" }
        })
        .AddTelemetrySdk();

    builder.Services.AddOpenTelemetryTracing(tracerProviderBuilder =>
    {
        tracerProviderBuilder
            .SetResourceBuilder(resourceBuilder);

        tracerProviderBuilder
            .AddAspNetCoreInstrumentation(options =>
            {
                options.RecordException = true;
                options.Filter = (context) =>
                {
                    return context.Request.Method == "GET";
                };
            });

        tracerProviderBuilder
            .AddSource("WeatherForecast");

        tracerProviderBuilder
            .AddOtlpExporter(options =>
            {
                options.Endpoint = new Uri($"{Environment.GetEnvironmentVariable("OTEL_EXPORTER_OTLP_ENDPOINT")}");
                options.Headers = $"api-key={Environment.GetEnvironmentVariable("NR_LICENSE_KEY")}";
            });
    });

    var app = builder.Build();

    if (app.Environment.IsDevelopment())
    {
        app.UseSwagger();
        app.UseSwaggerUI();
    }

    app.UseHttpsRedirection();

    app.UseAuthorization();

    app.MapControllers();

    app.Run();
    ```

    `AddOpenTelemetryTracing()` takes a delegate that builds a tracer provider that, in turn, automatically provides traces to your OpenTelemetry exporter.

    First in configuring your tracer provider, you specify the resource builder you created in the last step. This ties the attributes you previously defined to all traces from your service. Next, with `tracerProviderBuilder.AddAspNetCoreInstrumentation()`, you configure the SDK to listen to auto-instrumentation. You also tell it to record exceptions and only track GET requests. Finally, you configure the OTLP exporter to export traces to New Relic using the environment variables you defined earlier.

6. Configure the OpenTelemetry SDK for [metrics](/docs/data-apis/understand-data/new-relic-data-types):

    ```jsx fileName=app/Program.cs
    using OpenTelemetry.Metrics;
    using OpenTelemetry.Resources;
    using OpenTelemetry.Trace;

    var builder = WebApplication.CreateBuilder(args);

    builder.Services.AddControllers();
    builder.Services.AddEndpointsApiExplorer();
    builder.Services.AddSwaggerGen();

    var resourceBuilder = ResourceBuilder
        .CreateDefault()
        .AddService("Weather-Forecast")
        .AddAttributes(new Dictionary<string, object> {
            { "environment", "production" }
        })
        .AddTelemetrySdk();

    builder.Services.AddOpenTelemetryTracing(tracerProviderBuilder =>
    {
        tracerProviderBuilder
            .SetResourceBuilder(resourceBuilder);

        tracerProviderBuilder
            .AddAspNetCoreInstrumentation(options =>
            {
                options.RecordException = true;
                options.Filter = (context) =>
                {
                    return context.Request.Method == "GET";
                };
            });

        tracerProviderBuilder
            .AddSource("WeatherForecast");

        tracerProviderBuilder
            .AddOtlpExporter(options =>
            {
                options.Endpoint = new Uri($"{Environment.GetEnvironmentVariable("OTEL_EXPORTER_OTLP_ENDPOINT")}");
                options.Headers = $"api-key={Environment.GetEnvironmentVariable("NR_LICENSE_KEY")}";
            });
    });

    builder.Services.AddOpenTelemetryMetrics(meterProviderBuilder =>
    {
        meterProviderBuilder
            .SetResourceBuilder(resourceBuilder);

        meterProviderBuilder
            .AddAspNetCoreInstrumentation();

        meterProviderBuilder
            .AddOtlpExporter(options =>
            {
                options.Endpoint = new Uri($"{Environment.GetEnvironmentVariable("OTEL_EXPORTER_OTLP_ENDPOINT")}");
                options.Headers = $"api-key={Environment.GetEnvironmentVariable("NR_LICENSE_KEY")}";
                options.AggregationTemporality = AggregationTemporality.Delta;
            });
    });

    var app = builder.Build();

    if (app.Environment.IsDevelopment())
    {
        app.UseSwagger();
        app.UseSwaggerUI();
    }

    app.UseHttpsRedirection();

    app.UseAuthorization();

    app.MapControllers();

    app.Run();
    ```

    Besides configuring a `MetricsProviderBuilder`, this is mostly the same as how you configured tracing.

    There is one important detail, however. Currently, New Relic only supports sending metrics over OTLP using [delta aggregation temporality](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/datamodel.md#temporality). The SDK's default aggregation temporality is cumulative, so you specify `Delta` here.

**Restart your application**

Now that you've changed the application logic, you need to restart your local server. Make sure you do this in the same terminal window where you set your environment variables.

1. Restart it:

    ```bash
    dotnet restore app
    dotnet build app
    dotnet run --project app
    [output]
    [output]   Determining projects to restore...
    [output]   All projects are up-to-date for restore.
    [output] Microsoft (R) Build Engine version 17.0.0+c9eb9dd64 for .NET
    [output] Copyright (C) Microsoft Corporation. All rights reserved.
    [output]
    [output]   Determining projects to restore...
    [output]   All projects are up-to-date for restore.
    [output]   opentelemetry-dotnet-lab-materials -> /workspace/opentelemetry-dotnet-lab-materials/app/bin/Debug/net6.0/app.dll
    [output]
    [output] {success}Build succeeded.
    [output]     0 Warning(s)
    [output]     0 Error(s)
    [output]
    [output] Time Elapsed 00:00:01.16
    [output] Building...
    [output] {green}info: {plain}Microsoft.Hosting.Lifetime[14]
    [output]       Now listening on: {blue}https://localhost:7072
    [output] {green}info: {plain}Microsoft.Hosting.Lifetime[0]
    [output]       Application started. Press Ctrl+C to shut down.
    [output] {green}info: {plain}Microsoft.Hosting.Lifetime[0]
    [output]       Hosting environment: Development
    [output] {green}info: {plain}Microsoft.Hosting.Lifetime[0]
    [output]       Content root path: /workspace/opentelemetry-dotnet-lab-materials/app/
    [output] {green}info: {plain}Microsoft.Hosting.Lifetime[0]
    ```

    Now, your server is running again. However, because you shut it down, your load generator might have failed, having been unable to find your app. If it's no longer running, restart that too.

2. In the terminal window where you ran your load generator, restart it:

    ```bash
    python simulator.py
    ```

    You've instrumented your application to send metrics and traces to New Relic using our OTLP receiver. You've also restarted your service and load generator. Now, it's time to view your data.

    </Step>

    <Step>
    
    ### View your OpenTelemetry data in New Relic [#view]

    You've instrumented your weather forecast application with OpenTelemetry and you're sending metric and trace data to New Relic.

    Here, you move to New Relic to see the kinds of detailed telemetry data that OpenTelemetry was able to collect automatically with just a few lines of SDK code.

    1. Log into [New Relic](https://one.newrelic.com).

    2. In the entity explorer, click the **Weather-Forecast** OpenTelemetry service This brings you to a service view that shows trace data from your application, including:

        - Response time
        - Throughput
        - Error rate

    3. In the left-hand navigation, click **Distributed tracing**. This shows trace data that the OpenTelemetry SDK automatically captured in your service, such as:

        - Trace count
        - Trace duration
        - Trace groups

    4. Under **Trace groups** click the **WeatherForecast** group. This group shows similar traces. Since your application has only one endpoint, all traces are grouped together.

    5. Click one of the traces. Because your weather application is simple, there is only one span in the trace.

    6. Click on the span. Here, you see information about the particular span, including not only performance metrics, but also attributes that OpenTelemetry sent.

    7. Click **Attributes**. You configured many of the attributes you see here in your SDK code.

    8. While New Relic doesn't yet have a curated experience for .NET OpenTelemetry metrics data, you can see the metrics in the metrics explorer.

    </Step>

</Steps>

## Summary [#summary]

As the developer of WeatherForecast, you've now instrumented your application with OpenTelemetry to send automatically collected metrics and traces to New Relic. And because you instrumented your app with OpenTelemetry instead of a .NET agent, you are more flexible in how you can use your data. For example, if you want to add additional backend data sources besides New Relic, you can easily change that without having to add another vendor-specific agent.

Now that you know how to instrument a .NET application with OpenTelemetry and send that data to New Relic, here are some things you can do next to familiarize yourself even more with New Relic and OpenTelemetry:

    - Check out our [repository of OpenTelemetry examples](https://github.com/newrelic/newrelic-opentelemetry-examples)
    - Learn more about [OpenTelemetry's .NET SDK](https://github.com/open-telemetry/opentelemetry-dotnet)
    - Read our [documentation on New Relic + OpenTelemetry](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-introduction/)

