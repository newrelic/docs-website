---
title: 'NGINX OpenTelemetry monitoring overview'
metaDescription: 'Learn about monitoring self-hosted NGINX with OpenTelemetry, its benefits, use cases, and collected metrics for comprehensive observability.'
redirects:
  - /docs/infrastructure/host-integrations/host-integrations-list/nginx/nginx-otel-overview
freshnessValidatedDate: never
---

Get complete visibility into your NGINX web servers with OpenTelemetry integration. This solution uses the [OpenTelemetry Collector](https://github.com/open-telemetry/opentelemetry-collector-contrib) and [nginxreceiver](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/nginxreceiver) to automatically collect and send performance data, connection statistics, and operational insights to New Relic.

<img
  title="NGINX dashboard"
  alt="Image of the NGINX dashboard"
  src="/images/opentelemetry_screenshot-nginx-dashboard.webp"
/>

<figcaption>
  Dashboard available through the [New Relic NGINX OpenTelemetry Monitor quickstart](https://newrelic.com/instant-observability/nginx-otel).
</figcaption>

<Callout variant="important">
  - To monitor **NGINX Plus**, see [Monitor NGINX Plus with OpenTelemetry](/docs/opentelemetry/nginx-plus/nginx-plus-otel/).
  - To monitor **NGINX on Kubernetes**, see [Monitor NGINX on Kubernetes with OpenTelemetry](/docs/opentelemetry/nginx/nginx-otel-kubernetes/).
  - Ready to implement? Continue to [NGINX OpenTelemetry setup guide](/docs/opentelemetry/nginx/nginx-otel-host/).
</Callout>

## Why monitor NGINX with OpenTelemetry? [#why-monitor]

NGINX monitoring is essential for maintaining web application performance and reliability. OpenTelemetry provides a standardized approach to collect and analyze this critical data.

### Key benefits

- **Performance optimization**: Identify bottlenecks, track response times, make data-driven scaling decisions
- **Proactive monitoring**: Get alerts before user impact, detect issues early
- **Operational insights**: Understand traffic patterns, track SLA compliance, maintain audit trails
- **Future-proof**: Open-source OpenTelemetry standard, vendor-neutral integration

### Use case

Whether you're running an e-commerce website, API gateway, or content delivery platform, NGINX monitoring helps you maintain fast, reliable web services. Get notified when your checkout process slows down, detect when your API endpoints are overwhelmed, or identify which geographic regions are experiencing issues. This monitoring is essential for websites handling customer transactions, mobile app backends, microservices architectures, and any web application where downtime or slow performance directly impacts your users and business.

## Collected metrics and attributes [#metrics]

The OpenTelemetry Collector Contrib's [nginxreceiver](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/nginxreceiver) collects the following metrics from the NGINX stub status module:

### Core metrics

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Metric
      </th>
      <th>
        Description
      </th>
      <th>
        Type
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        `nginx.connections_accepted`
      </td>
      <td>
        The total number of accepted client connections. Use this to track connection acceptance rates over time.
      </td>
      <td>
        Sum
      </td>
    </tr>
    <tr>
      <td>
        `nginx.connections_handled`
      </td>
      <td>
        The total number of handled connections. Generally, the parameter value is the same as nginx.connections_accepted unless some resource limits have been reached (for example, the worker_connections limit). A gap between accepted and handled suggests resource constraints.
      </td>
      <td>
        Sum
      </td>
    </tr>
    <tr>
      <td>
        `nginx.connections_current`
      </td>
      <td>
        The current number of nginx connections by state. States include: <strong>active</strong> (total active connections), <strong>reading</strong> (reading request headers), <strong>writing</strong> (writing responses), <strong>waiting</strong> (keep-alive connections waiting for next request).
      </td>
      <td>
        Sum
      </td>
    </tr>
    <tr>
      <td>
        `nginx.requests`
      </td>
      <td>
        Total number of requests made to the server since it started. Use rate calculations to derive requests per second for performance monitoring.
      </td>
      <td>
        Sum
      </td>
    </tr>
  </tbody>
</table>

**Capacity planning tips:**
- High `waiting` connections may indicate keep-alive tuning opportunities
- Gap between `accepted` and `handled` connections suggests resource constraints
- Request-to-connection ratios help optimize worker configurations

### Resource attributes

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        Attribute
      </th>
      <th style={{ width: "350px" }}>
        Description
      </th>
      <th>
        Example Values
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        `state`
      </td>
      <td>
        The state of a connection (applicable to `nginx.connections_current` metric)
      </td>
      <td>
        `active`, `reading`, `writing`, `waiting`
      </td>
    </tr>
    <tr>
      <td>
        `nginx.server.endpoint`
      </td>
      <td>
        The NGINX stub status endpoint URL
      </td>
      <td>
        `http://localhost:8080/stub_status`
      </td>
    </tr>
    <tr>
      <td>
        `nginx.deployment.name`
      </td>
      <td>
        A unique name to identify this NGINX deployment
      </td>
      <td>
        `production-web-01`, `staging-api`
      </td>
    </tr>
    <tr>
      <td>
        `nginx.display.name`
      </td>
      <td>
        A display-friendly name combining "server" prefix with deployment name
      </td>
      <td>
        `server:production-web-01`
      </td>
    </tr>
    <tr>
      <td>
        `host.name`
      </td>
      <td>
        The hostname of the system where NGINX is running
      </td>
      <td>
        `web-server-01.example.com`
      </td>
    </tr>
    <tr>
      <td>
        `host.id`
      </td>
      <td>
        The unique identifier of the host system
      </td>
      <td>
        `i-1234567890abcdef0`
      </td>
    </tr>
    <tr>
      <td>
        `logtype`
      </td>
      <td>
        The type of log being collected (applicable to logs only). Used by New Relic's built-in [parsing rules](https://docs.newrelic.com/docs/logs/ui-data/built-log-parsing-rules/#nginx). This attribute is only available when log forwarding is enabled.
      </td>
      <td>
        `nginx` (for access logs), `nginx-error` (for error logs)
      </td>
    </tr>
  </tbody>
</table>

For more technical details and implementation examples, see the [NGINX receiver documentation](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/nginxreceiver/documentation.md).

## Next steps [#next-steps]

Ready to start monitoring your NGINX servers?

**Continue to the implementation guide:**
- [NGINX OpenTelemetry setup guide](/docs/opentelemetry/nginx/nginx-otel-host/) - Complete step-by-step instructions for configuration, setup, and troubleshooting

**Explore related monitoring options:**
- [Monitor NGINX Plus with OpenTelemetry](/docs/opentelemetry/nginx-plus/nginx-plus-otel/) - For commercial NGINX Plus deployments
- [Monitor NGINX on Kubernetes](/docs/opentelemetry/nginx/nginx-otel-kubernetes/) - For containerized environments

**Learn more about OpenTelemetry:**
- [OpenTelemetry best practices](/docs/opentelemetry/best-practices/opentelemetry-otlp/) - Optimize your OpenTelemetry setup
- [OpenTelemetry Collector documentation](https://opentelemetry.io/docs/collector/) - Comprehensive collector reference

<Callout variant="tip">
**Setup time**: approximately 20 minutes | **Skill level**: Intermediate (requires basic Linux/NGINX knowledge)
</Callout>