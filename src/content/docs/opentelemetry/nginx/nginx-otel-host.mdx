---
title: 'Monitor self-hosted NGINX with OpenTelemetry'
metaDescription: 'Send your NGINX metrics and logs to New Relic using the OpenTelemetry Collector.'
redirects:
  - /docs/infrastructure/host-integrations/host-integrations-list/nginx/nginx-otel-host
freshnessValidatedDate: never
---

The New Relic NGINX OpenTelemetry integration provides comprehensive monitoring for your self-hosted NGINX servers using industry-standard OpenTelemetry protocols. This integration gives you deep visibility into your NGINX performance, helping you identify bottlenecks, track user experience, and maintain optimal server health.

**Why choose this OpenTelemetry approach?**
- **Industry standard**: Uses open-source OpenTelemetry protocols that work with any observability platform
- **Comprehensive monitoring**: Collects both metrics and logs from your NGINX servers
- **Real-time insights**: Monitor request rates, connection states, and server performance in real-time
- **Automated discovery**: Easy setup with minimal configuration changes
- **Cost effective**: Efficient data collection with built-in filtering and processing

**What you'll monitor:**
- **Request metrics**: Requests per second, response times, and throughput
- **Connection statistics**: Active connections, connection states (reading, writing, waiting)
- **Server health**: Error rates, upstream status, and resource utilization
- **Access logs**: Detailed request information for debugging and analysis (optional)
- **Error logs**: Server errors and configuration issues (optional)

**Use case:** A web application team uses NGINX as a reverse proxy for their microservices. With this integration, they can see when traffic spikes occur, identify which upstream services are slow, and get alerted when error rates increase - all from unified dashboards in New Relic. When users report slow page loads, the team can quickly correlate NGINX metrics with application performance to pinpoint the root cause.

<Callout variant="tip">
**Ready to get started?** This integration takes about 20-25 minutes to set up. You'll have NGINX monitoring dashboards and be able to create custom alerts for your specific needs.
</Callout>

---

## Step 1: Before you begin [#prerequisites]

To successfully complete this integration, verify you have the following requirements:

<Callout variant="tip">
**Estimated time**: 20-25 minutes
**Difficulty**: Intermediate
**Skills needed**: Basic command line knowledge and NGINX administration
</Callout>

### 1. New Relic account and license key

You'll need a New Relic account to send your NGINX data.

**How to verify:**
- **Have an account?** [Sign up for free](https://newrelic.com/signup) if you don't have one
- **Find your license key:** Go to [one.newrelic.com](https://one.newrelic.com) > API Keys > "Ingest - License" > Show key

**What you'll need:** Your <InlinePopover type="licenseKey"/> for Step 4 of this guide.

### 2. NGINX with stub status module enabled

The stub status module provides basic performance metrics that the OpenTelemetry Collector will scrape.

**How to verify it's enabled:**
```bash
nginx -V 2>&1 | grep -o with-http_stub_status_module
```

**Expected result:** You should see `with-http_stub_status_module` in the output.

**If not enabled:**
- **Ubuntu/Debian:** Install `nginx-full` package: `sudo apt install nginx-full`
- **RHEL/CentOS:** The module is included by default in most distributions
- **Compiled from source:** You'll need to recompile with `--with-http_stub_status_module`

### 3. OpenTelemetry Collector installed and running

The Collector receives metrics from NGINX and forwards them to New Relic.

**How to verify it's installed:**
```bash
which otelcol-contrib && otelcol-contrib --version
```

**Expected result:** Version output (minimum v0.88.0 required)

**If not installed:**
- **Download:** Get the latest [OpenTelemetry Collector Contrib](https://github.com/open-telemetry/opentelemetry-collector-contrib/releases/latest)
- **Install on Linux:** Use the `.deb` or `.rpm` package for your distribution
- **Verify service:** `sudo systemctl status otelcol-contrib`

### 4. Network connectivity requirements

Your OpenTelemetry Collector needs network access to both NGINX and New Relic.

**Test NGINX connectivity:**
```bash
curl -I http://localhost:80  # Test basic NGINX access
```

**Test New Relic OTLP endpoint:**
```bash
curl -I https://otlp.nr-data.net:443  # US region
# OR
curl -I https://otlp.eu01.nr-data.net:443  # EU region
```

**Expected result:** Both should return HTTP status codes (200, 301, etc.) not connection errors.

**Network requirements:**
- **Inbound:** Collector can reach NGINX (typically localhost or internal network)
- **Outbound:** HTTPS (port 443) to [New Relic's OTLP endpoint](/docs/opentelemetry/best-practices/opentelemetry-otlp)
- **Firewall:** Ensure no blocking rules for these connections

### 5. System requirements

**Operating System:** Linux (Ubuntu, RHEL, CentOS, Debian)
**RAM:** Minimum 512MB available for the Collector
**Disk:** At least 100MB for Collector logs and temporary data
**User permissions:** Root or sudo access for service configuration

**Ready to continue?** If all verification steps pass, you're ready to configure NGINX for monitoring!

## Step 2: Configure NGINX stub status [#configure-nginx]

The stub status module provides basic performance metrics that the OpenTelemetry Collector will scrape. You'll need to configure an endpoint that exposes these metrics securely.

### Add stub status configuration to NGINX

1. **Open your NGINX configuration file:**
   ```bash
   sudo nano /etc/nginx/nginx.conf
   ```

2. **Add a stub status location block.** Choose one of the configuration options below:

<CollapserGroup>
  <Collapser id="basic-config" title="Basic configuration (recommended)">
    Add this configuration inside your existing `server` block or create a new one:

    ```nginx
    server {
        listen 8080;
        server_name localhost;

        # Stub status endpoint for monitoring
        location /nginx_status {
            stub_status on;
            access_log off;           # Don't log monitoring requests
            allow 127.0.0.1;         # Only allow localhost access
            allow ::1;               # Allow IPv6 localhost
            deny all;                # Deny all other access
        }

        # Optional: Basic health check endpoint
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
    ```

    **What this does:**
    - Creates a dedicated server listening on port 8080
    - Exposes metrics at `http://localhost:8080/nginx_status`
    - Restricts access to localhost only for security
    - Disables access logging for the monitoring endpoint
    - Adds a simple health check endpoint
  </Collapser>

  <Collapser id="existing-server" title="Add to existing server block">
    If you prefer to add the status endpoint to an existing server, add this location block:

    ```nginx
    server {
        # Your existing server configuration...
        listen 80;
        server_name example.com;

        # Add this location block for monitoring
        location /nginx_status {
            stub_status on;
            access_log off;
            allow 127.0.0.1;    # Only allow localhost
            allow ::1;          # Allow IPv6 localhost
            deny all;           # Deny all other access
        }

        # Your other location blocks...
    }
    ```

    **Security note:** This exposes metrics on your main server. Ensure firewall rules prevent external access to this endpoint.
  </Collapser>

  <Collapser id="advanced-config" title="Advanced configuration with authentication">
    For additional security, you can add basic authentication:

    ```nginx
    server {
        listen 8080;
        server_name localhost;

        location /nginx_status {
            stub_status on;
            access_log off;

            # IP-based restrictions
            allow 127.0.0.1;
            allow 10.0.0.0/8;      # Allow private network if needed
            deny all;

            # Optional: Basic authentication
            auth_basic "NGINX Status";
            auth_basic_user_file /etc/nginx/.htpasswd;
        }
    }
    ```

    **To create the password file:**
    ```bash
    sudo htpasswd -c /etc/nginx/.htpasswd monitoring_user
    ```
  </Collapser>
</CollapserGroup>

### Test and apply the configuration

3. **Test your NGINX configuration for syntax errors:**
   ```bash
   sudo nginx -t
   ```

   **Expected output:** `nginx: configuration file /etc/nginx/nginx.conf test is successful`

4. **If the test passes, reload NGINX:**
   ```bash
   sudo nginx -s reload
   ```

### Verify stub status is working

5. **Test the stub status endpoint:**
   ```bash
   curl http://127.0.0.1:8080/nginx_status
   ```

   **Expected output:**
   ```
   Active connections: 1
   server accepts handled requests
    16 16 16
   Reading: 0 Writing: 1 Waiting: 0
   ```

6. **Verify the HTTP response is successful:**
   ```bash
   curl -I http://127.0.0.1:8080/nginx_status
   ```

   **Expected output:** Should start with `HTTP/1.1 200 OK`

### Troubleshooting NGINX configuration

**If you get "404 Not Found":**
- Check that the location path in your config matches the URL you're testing
- Verify the configuration is in the correct server block

**If you get "403 Forbidden":**
- Check your `allow`/`deny` directives
- Ensure you're testing from localhost (`127.0.0.1`)
- Verify NGINX user has permission to read the config file

**If NGINX won't start:**
- Run `sudo nginx -t` to check for syntax errors
- Check NGINX error logs: `sudo tail -f /var/log/nginx/error.log`
- Ensure port 8080 isn't already in use: `sudo netstat -tlnp | grep :8080`

**Security considerations:**
- Never expose stub status publicly without authentication
- Use IP allowlists to restrict access to monitoring systems only
- Consider using a non-standard port or path name
- Monitor access logs for unauthorized access attempts

**Ready for the next step?** Once you see the stub status output, your NGINX is ready for OpenTelemetry monitoring!

## Step 3: Configure the OpenTelemetry Collector [#configure-collector]

In the below OpenTelemetry Collector config snippet:

- Update the `nginx.deployment.name` value to with a unique name to identify this NGINX server in a New Relic account.
- Update the `endpoint` and `nginx.server.endpoint` value to match your stub status path and port.

Merge the receivers, processors, exporters, and service pipelines from the snippet below into your current configuration (typically located at `/etc/otelcol-contrib/config.yaml`).

```yaml
receivers:
  nginx:
    metrics:
      nginx.requests:
        enabled: true
      nginx.connections_accepted:
        enabled: true
      nginx.connections_handled:
        enabled: true
      nginx.connections_current:
        enabled: true
    endpoint: <STUB_STATUS_ENDPOINT>
    collection_interval: 30s
processors:
  resourcedetection:
    detectors: [system]
    system:
      resource_attributes:
        host.name:
          enabled: true
        host.id:
          enabled: true
  resource:
    attributes:
      - action: upsert
        key: nginx.server.endpoint
        value: <STUB_STATUS_ENDPOINT>
      - action: upsert
        key: nginx.deployment.name
        value: <DEPLOYMENT_NAME>
  batch:
    timeout: 30s
    send_batch_size: 512
  transform/nginx_metrics:
    metric_statements:
      - context: resource
        statements:
          - set(attributes["nginx.display.name"], Concat(["server", attributes["nginx.deployment.name"]], ":"))
exporters:
  otlphttp/newrelic:
    endpoint: ${env:NEWRELIC_OTLP_ENDPOINT}
    headers:
      api-key: ${env:NEWRELIC_LICENSE_KEY}
service:
  pipelines:
    metrics:
      receivers: [nginx]
      processors: [resourcedetection, resource, batch, transform/nginx_metrics]
      exporters: [otlphttp/newrelic]
```

Save the file and ensure the `otelcol-contrib` system user can read it.

## Step 4: Configure authentication [#set-environment]

The OpenTelemetry Collector needs your New Relic credentials to send data. Instead of putting sensitive information directly in the configuration file, we'll use environment variables for security.

### Why environment variables?

**Security benefits:**
- Keeps credentials out of configuration files that might be shared or stored in version control
- Easier to rotate credentials without editing multiple config files
- Follows security best practices for credential management

**How it works:** The Collector configuration uses `${env:VARIABLE_NAME}` syntax to read values from environment variables at runtime.

### Gather your New Relic credentials

You'll need two pieces of information:

1. **License Key**:
   - Go to [one.newrelic.com](https://one.newrelic.com) → API Keys
   - Under "Ingest - License", click "Show key" and copy the value
   - This authenticates your data with your New Relic account

2. **OTLP Endpoint**: Choose based on your New Relic region:
   - **US region**: `https://otlp.nr-data.net:4318`
   - **EU region**: `https://otlp.eu01.nr-data.net:4318`
   - **Need help choosing?** Check your New Relic URL - if it includes "eu01", use the EU endpoint

### Configure the Collector service

1. **Create a systemd configuration directory:**
   ```bash
   sudo mkdir -p /etc/systemd/system/otelcol-contrib.service.d
   ```

   **What this does:** Creates a directory for service configuration overrides without modifying the main service file.

2. **Add your credentials to the service:**
   ```bash
   cat <<EOF | sudo tee /etc/systemd/system/otelcol-contrib.service.d/environment.conf
   [Service]
   Environment="NEWRELIC_OTLP_ENDPOINT=YOUR_OTLP_ENDPOINT"
   Environment="NEWRELIC_LICENSE_KEY=YOUR_LICENSE_KEY"
   EOF
   ```

   **Replace the placeholder values:**
   - `YOUR_OTLP_ENDPOINT`: Your actual endpoint from step 2 above
   - `YOUR_LICENSE_KEY`: Your actual license key from step 1 above

   **Example with real values:**
   ```bash
   cat <<EOF | sudo tee /etc/systemd/system/otelcol-contrib.service.d/environment.conf
   [Service]
   Environment="NEWRELIC_OTLP_ENDPOINT=https://otlp.nr-data.net:4318"
   Environment="NEWRELIC_LICENSE_KEY=NRAK-ABC123XYZ789..."
   EOF
   ```

3. **Apply the changes and restart the Collector:**
   ```bash
   sudo systemctl daemon-reload
   sudo systemctl restart otelcol-contrib.service
   ```

   **What these commands do:**
   - `daemon-reload`: Tells systemd to read the new configuration
   - `restart`: Restarts the Collector with the new environment variables

### Verify the Collector is running

4. **Check the service status:**
   ```bash
   sudo systemctl status otelcol-contrib.service
   ```

   **What to look for:**
   - `Active: active (running)` - Service is running properly
   - No recent error messages in the logs
   - Service has been running for more than a few seconds

5. **Check recent logs for any authentication errors:**
   ```bash
   sudo journalctl -u otelcol-contrib.service -n 20
   ```

   **Good signs:**
   - No "401 Unauthorized" or "403 Forbidden" errors
   - Messages about successful metric collection
   - No connection refused errors

### Troubleshooting authentication issues

**If you see "401 Unauthorized" errors:**
- Double-check your license key is correct and complete
- Ensure there are no extra spaces or characters in the key
- Verify the key is for the correct New Relic account

**If you see "connection refused" errors:**
- Check your OTLP endpoint URL is correct for your region
- Test connectivity: `curl -I https://otlp.nr-data.net:4318`
- Verify firewall isn't blocking outbound HTTPS traffic on port 4318

**If the service won't start:**
- Check for syntax errors: `sudo systemctl status otelcol-contrib.service`
- Verify config file syntax: `sudo -u otelcol-contrib otelcol-contrib validate --config /etc/otelcol-contrib/config.yaml`
- Check file permissions: `ls -l /etc/otelcol-contrib/config.yaml`

**Ready for the next step?** Once the Collector is running without authentication errors, you can optionally configure log forwarding or skip to viewing your data in New Relic!

## Step 5: Forward NGINX logs (Optional) [#forward-logs]

In addition to metrics, you can send NGINX access and error logs to New Relic for comprehensive monitoring. This gives you detailed request information for debugging and security monitoring.

### Why forward logs?

**Benefits of log forwarding:**
- **Debugging**: See detailed request information when investigating performance issues
- **Security monitoring**: Detect suspicious access patterns, bot traffic, or attack attempts
- **Correlation**: Connect metric spikes with specific requests in your logs
- **Compliance**: Maintain audit trails for regulatory requirements

**Skip this step if:** You only need basic NGINX metrics and don't require detailed request logs.

### Configure structured logging in NGINX

Structured logs are easier to parse and query in New Relic. We'll configure NGINX to output JSON-formatted logs.

1. **Edit your NGINX configuration file:**
   ```bash
   sudo nano /etc/nginx/nginx.conf
   ```

2. **Add a structured log format inside the `http` block:**
   ```nginx
   http {
       # Add this structured log format
       log_format json_combined escape=json
       '{'
         '"time_local":"$time_local",'
         '"remote_addr":"$remote_addr",'
         '"request":"$request",'
         '"status":$status,'
         '"body_bytes_sent":$body_bytes_sent,'
         '"request_time":$request_time,'
         '"http_referer":"$http_referer",'
         '"http_user_agent":"$http_user_agent",'
         '"http_x_forwarded_for":"$http_x_forwarded_for"'
       '}';

       # Update your access log to use the new format
       access_log /var/log/nginx/access.log json_combined;
       error_log /var/log/nginx/error.log warn;

       # Your existing server configurations...
   }
   ```

   **What this log format includes:**
   - **time_local**: When the request was processed
   - **remote_addr**: Client IP address
   - **request**: HTTP method, path, and protocol
   - **status**: HTTP response code (200, 404, 500, etc.)
   - **body_bytes_sent**: Size of response sent to client
   - **request_time**: How long the request took to process
   - **http_referer**: Where the request came from
   - **http_user_agent**: Client browser/application information
   - **http_x_forwarded_for**: Real client IP if behind a proxy

3. **Test and reload NGINX:**
   ```bash
   sudo nginx -t && sudo nginx -s reload
   ```

4. **Verify the new log format is working:**
   ```bash
   # Make a test request
   curl http://localhost

   # Check the log output
   sudo tail -1 /var/log/nginx/access.log
   ```

   **Expected output:** You should see JSON-formatted log entries instead of the default format.

### Configure the OpenTelemetry Collector for log forwarding

5. **Update your Collector configuration** (`/etc/otelcol-contrib/config.yaml`):

<CollapserGroup>
  <Collapser id="add-log-config" title="Add to existing configuration">
    Add these sections to your existing configuration file:

    **Add to the `receivers` section:**
    ```yaml
    receivers:
      nginx:
        # Your existing nginx receiver configuration...

      # Add these log receivers
      filelog/nginx_access:
        include:
          - /var/log/nginx/access.log
        start_at: beginning
        operators:
          - type: json_parser
            parse_from: attributes.message
          - type: move
            from: attributes.message
            to: body

      filelog/nginx_error:
        include:
          - /var/log/nginx/error.log
        start_at: beginning
    ```

    **Add to the `processors` section:**
    ```yaml
    processors:
      # Your existing processors...

      # Add these log processors
      transform/nginx_logs:
        log_statements:
          - context: resource
            statements:
              - set(attributes["service.name"], "nginx")
              - set(attributes["nginx.deployment.name"], "production-web-01")  # Update this
    ```

    **Update the `service.pipelines` section:**
    ```yaml
    service:
      pipelines:
        metrics:
          # Your existing metrics pipeline...

        # Add these log pipelines
        logs/nginx-access:
          receivers: [filelog/nginx_access]
          processors: [resourcedetection, resource, batch, transform/nginx_logs]
          exporters: [otlphttp/newrelic]

        logs/nginx-error:
          receivers: [filelog/nginx_error]
          processors: [resourcedetection, resource, batch, transform/nginx_logs]
          exporters: [otlphttp/newrelic]
    ```
  </Collapser>
</CollapserGroup>

### Grant file access permissions

6. **Allow the Collector to read NGINX log files:**
   ```bash
   # Add collector user to adm group (has read access to logs)
   sudo usermod -a -G adm otelcol-contrib

   # Ensure log files are readable
   sudo chmod 644 /var/log/nginx/access.log
   sudo chmod 644 /var/log/nginx/error.log
   ```

   **What this does:** The `adm` group has read access to system log files. Adding the Collector user to this group allows it to read NGINX logs.

### Apply the configuration

7. **Validate your configuration:**
   ```bash
   sudo -u otelcol-contrib otelcol-contrib validate --config /etc/otelcol-contrib/config.yaml
   ```

8. **Restart the Collector:**
   ```bash
   sudo systemctl restart otelcol-contrib.service
   ```

9. **Verify the Collector is running:**
   ```bash
   sudo systemctl status otelcol-contrib.service
   ```

### Verify logs are flowing to New Relic

10. **Generate some test traffic:**
    ```bash
    # Make a few test requests
    curl http://localhost
    curl http://localhost/nonexistent  # This will generate a 404
    ```

11. **Check New Relic for logs:**
    - Go to [one.newrelic.com](https://one.newrelic.com) → Logs
    - Search for: `service.name:nginx`
    - You should see NGINX access logs appearing within 1-2 minutes

### Troubleshooting log forwarding

**If no logs appear in New Relic:**

- **Check Collector logs:** `sudo journalctl -u otelcol-contrib -f`
- **Verify file permissions:** `sudo -u otelcol-contrib cat /var/log/nginx/access.log`
- **Check log file paths:** Ensure paths in config match actual log locations
- **Test log rotation:** NGINX may rotate logs, breaking file handles

**If logs appear but aren't parsed correctly:**

- **Verify JSON format:** `sudo tail -1 /var/log/nginx/access.log | jq .`
- **Check for syntax errors:** Ensure NGINX config has valid JSON format
- **Review parsing errors:** Look for JSON parsing errors in Collector logs

**Common permission issues:**

```bash
# If permission denied errors:
sudo chmod 644 /var/log/nginx/*.log
sudo chown root:adm /var/log/nginx/*.log

# Verify collector user group membership:
groups otelcol-contrib
```

**Ready for the next step?** Once logs are flowing (or if you skipped log forwarding), you can view your NGINX data in New Relic dashboards!

## Step 6: Find and use data [#find-data]

1. Go to **[one.newrelic.com](https://one.newrelic.com) > Integrations & Agents**.
2. Select **Dashboards**, and click **NGINX OTel overview dashboard**.
3. In the popup window, select your account.
4. Click View dashboard, and see your NGINX data in New Relic.

The NGINX metrics are attached to the `Metric` [event type](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic). You can [query this data](/docs/using-new-relic/data/understand-data/query-new-relic-data) for troubleshooting purposes or to create custom charts and dashboards.

## Metrics collected [#metrics]

The OpenTelemetry Collector Contrib's [nginxreceiver](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/nginxreceiver) collects the following metrics from the NGINX stub status module:

<CollapserGroup>
  <Collapser
    id="nginx-metrics"
    title="Metrics"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Metric
          </th>
          <th>
            Description
          </th>
          <th>
            Type
          </th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            `nginx.connections_accepted`
          </td>
          <td>
            The total number of accepted client connections
          </td>
          <td>
            Sum
          </td>
        </tr>
        <tr>
          <td>
            `nginx.connections_handled`
          </td>
          <td>
            The total number of handled connections. Generally, the parameter value is the same as nginx.connections_accepted unless some resource limits have been reached (for example, the worker_connections limit)
          </td>
          <td>
            Sum
          </td>
        </tr>
        <tr>
          <td>
            `nginx.connections_current`
          </td>
          <td>
            The current number of nginx connections by state
          </td>
          <td>
            Sum
          </td>
        </tr>
        <tr>
          <td>
            `nginx.requests`
          </td>
          <td>
            Total number of requests made to the server since it started
          </td>
          <td>
            Sum
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="nginx-attributes"
    title="Attributes"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Attribute
          </th>
          <th style={{ width: "350px" }}>
            Description
          </th>
          <th>
            Example Values
          </th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            `state`
          </td>
          <td>
            The state of a connection (applicable to `nginx.connections_current` metric)
          </td>
          <td>
            `active`, `reading`, `writing`, `waiting`
          </td>
        </tr>
        <tr>
          <td>
            `nginx.server.endpoint`
          </td>
          <td>
            The NGINX stub status endpoint URL
          </td>
          <td>
            `http://localhost:8080/stub_status`
          </td>
        </tr>
        <tr>
          <td>
            `nginx.deployment.name`
          </td>
          <td>
            A unique name to identify this NGINX deployment
          </td>
          <td>
            `production-web-01`, `staging-api`
          </td>
        </tr>
        <tr>
          <td>
            `nginx.display.name`
          </td>
          <td>
            A display-friendly name combining "server" prefix with deployment name
          </td>
          <td>
            `server:production-web-01`
          </td>
        </tr>
        <tr>
          <td>
            `host.name`
          </td>
          <td>
            The hostname of the system where NGINX is running
          </td>
          <td>
            `web-server-01.example.com`
          </td>
        </tr>
        <tr>
          <td>
            `host.id`
          </td>
          <td>
            The unique identifier of the host system
          </td>
          <td>
            `i-1234567890abcdef0`
          </td>
        </tr>
        <tr>
          <td>
            `logtype`
          </td>
          <td>
            The type of log being collected (applicable to logs only). Used by New Relic's built-in [parsing rules](https://docs.newrelic.com/docs/logs/ui-data/built-log-parsing-rules/#nginx)
          </td>
          <td>
            `nginx` (for access logs), `nginx-error` (for error logs)
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

</CollapserGroup>

For more details, see the [NGINX receiver documentation](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/nginxreceiver/documentation.md).
