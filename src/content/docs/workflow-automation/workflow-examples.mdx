---
title: Workflow examples
tags:
  - workflow automation
  - workflow
  - automation
  - examples
metaDescription: "Common workflow automation scenarios and examples for incident response, infrastructure management, and integrations."
freshnessValidatedDate: never
---

Common automation scenarios for Workflow Automation, progressing from basic to advanced patterns. Use as starting points or explore the [template library](/docs/workflow-automation/create-a-workflow-automation/use-a-template) for ready-to-deploy solutions.

## Getting started - Basic patterns

Foundational examples demonstrating workflow operations and data passing between steps.

### HTTP GET - Fetch and process data

Fetch data from REST API endpoints. Headers and URL parameters must be stringified JSON.

  ```yaml
    name: http_get_example

    workflowInputs:
      apiUrl:
        type: String
        defaultValue: 'https://api.example.com/data'

    steps:
      - name: fetchData
        type: action
        action: http.get
        version: 1
        inputs:
          url: ${{ .workflowInputs.apiUrl }}
          headers: '{"Authorization": "Bearer ${{ :secrets:api_token }}"}'
          urlParams: '{"filter": "active", "limit": "10"}'
          selectors:
            - name: status
              expression: .statusCode
            - name: data
              expression: .responseBody | fromjson

      - name: logResponse
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: 'API returned status: ${{ .steps.fetchData.outputs.status }}'
              attributes:
                responseData: ${{ .steps.fetchData.outputs.data }}
  ```

**Key actions**: `http.get`, `newrelic.ingest.sendLogs`

### HTTP POST - Send data to external systems

Send data to webhooks, APIs, or notification services. Headers must be stringified JSON, body must be a string.

  ```yaml
    name: http_post_example

    workflowInputs:
      webhookUrl:
        type: String
      alertMessage:
        type: String

    steps:
      - name: sendNotification
        type: action
        action: http.post
        version: 1
        inputs:
          url: ${{ .workflowInputs.webhookUrl }}
          headers: '{"Content-Type": "application/json"}'
          body: '{"event": "alert_triggered", "message": "${{ .workflowInputs.alertMessage }}", "severity": "high"}'
          selectors:
            - name: httpStatus
              expression: .statusCode
            - name: response
              expression: .responseBody

      - name: logResult
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: 'Webhook returned status: ${{ .steps.sendNotification.outputs.httpStatus }}'
  ```

**Common use cases**:
- Trigger deployments via CI/CD webhooks
- Send data to ticketing systems (Jira, ServiceNow)
- Post to custom notification services
- Integrate with third-party APIs

**Key actions**: `http.post`, `newrelic.ingest.sendLogs`

### JSON Parsing

Fetch JSON from New Relic status API, parse component statuses, and log issues. Requires status API access and log ingest permissions.

**What this workflow does:**
  - Fetches JSON data from the New Relic status API
  - Extracts and categorizes components by their operational status
  - Conditionally logs operational components (if enabled)
  - Conditionally logs non-operational components (if enabled)
  - Handles HTTP errors and logs error messages

**Key actions**: `http.get`, `newrelic.ingest.sendLogs`

  ```yaml
    name: parse_status_api

    steps:
      - name: fetchStatus
        type: action
        action: http.get
        version: 1
        inputs:
          url: 'https://status.newrelic.com/api/v2/summary.json'
          selectors:
            - name: operational
              expression: '.components[] | select(.status == "operational") | .name'
            - name: degraded
              expression: '.components[] | select(.status != "operational") | .name'

      - name: logNonOperational
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: 'Services with issues: ${{ .steps.fetchStatus.outputs.degraded | tostring }}'
              attributes:
                operationalServices: ${{ .steps.fetchStatus.outputs.operational }}
  ```

### Passing data between steps

Reference outputs from previous steps using template syntax to chain actions and build complex automation.

#### Using workflow inputs

Use `${{ .workflowInputs.variableName }}` to pass dynamic values at runtime in endpoint URLs and other input fields.

**Example:**

  ```json
    {
      "inputs": [
        {
          "key": "urlParams",
          "value": "{\"filter\": \"active\"}"
        },
        {
          "key": "headers",
          "value": "{\"Api-Key\": \"your-api-key\"}"
        }
      ]
    }
  ```

#### Basic data passing

Query alert issues from New Relic and send notifications to Slack for each active issue.

  ```yaml
    name: alertSlack
    description: "query Alert Issues and send notifications to Slack"

    workflowInputs:
      accountId:
        type: Int

    steps:
      - name: getAlert
        type: action
        action: newrelic.nerdgraph.execute
        version: 1
        inputs:
          graphql: |
            query GetAlertIssues($accountId: Int!) {
              actor {
                account(id: $accountId) {
                  aiIssues {
                    issues(filter: {states: ACTIVATED}) {
                      issues {
                        issueId
                        priority
                        state
                        title
                      }
                    }
                  }
                }
              }
            }
          variables:
            accountId: ${{ .workflowInputs.accountId }}

      - name: loopStep
        type: loop
        for:
          in: ${{ .steps.getAlert.outputs.data.actor.account.aiIssues.issues.issues }}
          steps:
            - name: sendToSlack
              type: action
              action: slack.chat.postMessage
              version: 1
              inputs:
                token: ${{ :secrets:your_slack_token }}
                channel: incident-channel
                text: >
                  issueId: ${{ .steps.loopStep.loop.element.issueId }}
                  priority: ${{ .steps.loopStep.loop.element.priority }}
                  state: ${{ .steps.loopStep.loop.element.state }}
                  title: ${{ .steps.loopStep.loop.element.title | tostring }}
  ```

#### Loop structure

Iterate through lists, maps, or collections using loops.

Loops iterate over collections defined by `in`, automatically creating `index` and `element` variables for each iteration. Access these with [JQ expression](https://play.jqlang.org/) `${{ .steps.<loopStepName>.loop.element }}` or `${{ .steps.<loopStepName>.loop.index }}`.

**Parameters:**

  - **`for`** (Required): Signals loop start
  - **`in`** (Required, string expression): Expression evaluating to a collection
  - **`steps`** (Required): Steps executed each iteration. Can include any step type, including nested loops

**Loop with workflow inputs:**

  ```yaml
    name: myWorkflow
    steps:
      - name: loopStep
        type: loop
        for:
          in: '${{ .workflowInputs.count }}'
          steps:
            - name: step1
              type: action
              action: internal.example.sayHello
              version: '1'
              inputs:
                name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
  ```

**Important notes:**
  - `for`: required. Top-level element indicating loop start
  - `in`: required. Input collection must be castable to Java Array
  - `steps`: required. Steps execute each iteration
  - `element` and `index` automatically assigned per loop iteration
  - `index` is zero-based
  - `element` can be complex type for complex collections
  - Loop variables and step outputs only accessible within the loop
  - Variables cleared on loop exit and null if accessed outside
  - Loops can access variables defined outside the loop

**Simple loop on integers:**

  ```yaml
    name: myWorkflow
    steps:
      - name: loopStep
        type: loop
        for:
          in: ${{ [range(1; 6)] }}
          steps:
            - name: step1
              type: action
              action: internal.example.sayHello
              version: '1'
              inputs:
                name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
  ```

**Simple loop for map:**

  ```yaml
    name: myWorkflow
    steps:
      - name: loopStep
        type: loop
        for:
          in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
          steps:
            - name: step1
              type: action
              action: internal.example.sayHello
              version: '1'
              inputs:
                name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
  ```

**Jump within a loop:**

Only jump between named steps within the same loop. Jumping in/out of loops, to inner/outer loops, or between different loops is not allowed.

  ```yaml
    name: myWorkflow
    steps:
      - name: firstStep
        type: action
        action: internal.example.sayHello
        version: '1'
      - name: loopStep
        type: loop
        for:
          in: '${{ .workflowInputs.count }}'
          steps:
            - name: step1
              type: action
              action: internal.example.sayHello
              version: '1'
              inputs:
                name: '${{ .steps.loopStep.loop.element }}'
              next: step3  # Okay within the loop
            - name: step2
              type: action
              action: internal.example.sayHello
              version: '1'
              inputs:
                name: '${{ .steps.step1.outputs.greeting }}'
            - name: step3
              type: action
              action: internal.example.sayHello
              version: '1'
              next: firstStep  # Not okay, first step is not in the loop context
  ```

**Use break/continue in a loop:**

Change loop flow with `next: break` or `next: continue`. These are reserved jump targets implicitly defined within loops. Outside loops, they jump to workflow end.

`end` behaves as `break` inside loops. `next` works in switch steps or any step type.

  ```yaml
    name: myWorkflow
    steps:
      - name: loopStep
        type: loop
        for:
          in: '${{ [range(1; 6)] }}'
          steps:
            - name: insideLoopStep1
              type: action
              action: internal.example.sayHello
              version: '1'
              inputs:
                name: '${{ .steps.loopStep.loop.element }}'
              next: continue
            - name: insideLoopStep2
              type: action
              action: internal.example.sayHello
              version: '1'
              inputs:
                name: '${{ .steps.loopStep.loop.element }}'
      - name: loopStepAgain
        type: loop
        for:
          in: '${{ .workflowInputs.count }}'
          steps:
            - name: switchStep
              type: switch
              switch:
                - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                  next: break
            - name: insideLoopStepAgain
              type: action
              action: internal.example.sayHello
              version: '1'
              inputs:
                name: '${{ .steps.loopStepAgain.loop.element }}'
  ```

#### Conditional logic with data

  ```yaml
    steps:
      - name: checkCPU
        type: action
        action: newrelic.nerdgraph.execute
        version: 1
        # ... query configuration

      - name: decideAction
        type: switch
        switch:
          - condition: "${{ .steps.checkCPU.outputs.data.actor.account.nrql.results[0].average > 90 }}"
            next: resizeInstance
          - condition: "${{ .steps.checkCPU.outputs.data.actor.account.nrql.results[0].average > 70 }}"
            next: sendWarning
        next: normalOperation

      - name: resizeInstance
        type: action
        action: aws.ec2.modifyInstanceAttribute
        version: 1
        # ... resize configuration

      - name: sendWarning
        type: action
        action: slack.chat.postMessage
        version: 1
        # ... warning message

      - name: normalOperation
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        # ... log normal status
  ```

## Common integrations

Integrate workflows with popular services like Slack, AWS, and REST APIs.

### Send a report to Slack

Execute NRQL query, convert results to CSV, and post to Slack. Requires NRQL query and Slack token in secrets.

**What this workflow does:**
  - Execute NRQL query against New Relic account
  - Generate CSV from query results
  - Post CSV to Slack channel with message

**Key actions**: `newrelic.nrdb.query`, `utils.transform.toCSV`, `slack.chat.postMessage`

### AWS SQS messaging

Send messages to AWS SQS queues using IAM role authentication. Requires AWS credentials with `sqs:SendMessage` permission and SQS queue URL (see [Set up AWS credentials](/docs/workflow-automation/setup-and-configuration/set-up-aws-credentials)).

**What this workflow does:**
  - Send message to SQS queue
  - Use AWS IAM role authentication
  - Return message ID and success status

**Key actions**: `aws.execute.api`, `(sqs.send_message)`

  ```yaml
    name: aws_execute_api_sqs_example

    workflowInputs:
      awsRoleArn:
        type: String
      awsRegion:
        type: String
        defaultValue: us-west-2
      awsQueueUrl:
        type: String

    steps:
      - name: sendSqsMessage
        type: action
        action: aws.execute.api
        version: 1
        inputs:
          awsRoleArn: ${{ .workflowInputs.awsRoleArn }}
          region: ${{ .workflowInputs.awsRegion }}
          service: sqs
          api: send_message
          parameters:
            QueueUrl: "${{ .workflowInputs.awsQueueUrl }}"
            MessageBody: |
              {
                "message": "deployment is bad",
                "status": "not good"
              }
          selectors:
            - name: success
              expression: '.success'
            - name: messageId
              expression: '.response.MessageId'
  ```

### REST API polling and logging

Poll a REST API endpoint, loop through results, and log data to New Relic.

<Callout variant="important">
Selectors are optional for full payloads. Most workflow tools support direct response object references.
</Callout>

#### Simple GET and log

Basic API polling and full response logging:

**What this workflow does:**
  - Trigger via schedule (e.g., every 5 minutes) or manual run
  - HTTP Request Step:
    - Method: GET
    - URL: https://pokeapi.co/api/v2/pokemon
    - Save response body to variable (e.g., `{{.http_response}}`)
  - Log/Create Event Step:
    - Send entire `{{.http_response.body}}` as payload
    - No selectors neededâ€”pass through raw JSON

#### REST API with loops and selectors

Fetch all results from REST API, loop through items, make individual calls, and log extracted data. Requires API access and log ingest permissions.

**What this workflow does:**
  - Fetch all results from REST API endpoint
  - Loop through each response result
  - Make individual API calls per item using loop data
  - Extract specific fields using selectors
  - Log extracted data to New Relic with custom attributes

**Key actions**: `http.get`, `newrelic.ingest.sendLogs`

  ```yaml
    name: pokemon_workflow
    description: ''
    steps:
      - name: get_all_pokemons
        type: action
        action: http.get
        version: '1'
        inputs:
          url: https://pokeapi.co/api/v2/pokemon
          selectors:
            - name: pokemons
              expression: .responseBody | fromjson.results
      - name: pokemon_loop
        type: loop
        for:
          in: ${{ .steps.get_all_pokemons.outputs.pokemons }}
          steps:
            - name: get_individual_pokemon
              type: action
              action: http.get
              version: '1'
              inputs:
                url: ${{ .steps.pokemon_loop.loop.element.url }}
                selectors:
                  - name: pokemon_name
                    expression: .responseBody | fromjson.name
                  - name: pokemon_id
                    expression: .responseBody | fromjson.id
                  - name: pokemon_stats
                    expression: .responseBody | fromjson.stats
            - name: log_pokemon_info
              type: action
              action: newrelic.ingest.sendLogs
              version: '1'
              inputs:
                logs:
                  - message: >-
                      Pokemon name is: ${{
                      .steps.get_individual_pokemon.outputs.pokemon_name}}, Id: ${{
                      .steps.get_individual_pokemon.outputs.pokemon_id}}
                    attributes:
                      pokemon_stats: ${{ .steps.get_individual_pokemon.outputs.pokemon_stats}}
              next: continue
        next: end
  ```

#### REST API to CSV conversion

Fetch API data, convert JSON to CSV, log to New Relic, and share via Slack. Requires API access and Slack token in secrets.

**What this workflow does:**
  - Fetch time data from World Time API by timezone
  - Convert JSON response to CSV
  - Log CSV to New Relic
  - Post CSV to Slack channel

**Key actions**: `http.get`, `utils.transform.toCSV`, `newrelic.ingest.sendLogs`, `slack.chat.postMessage`

  ```yaml
    name: jsontocsv

    workflowInputs:
      timezone:
        type: String
        defaultValue: 'America/Los_Angeles'

    steps:
      - name: getCurrentTime
        type: action
        action: http.get
        version: 1
        inputs:
          url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'

      - name: csv1
        type: action
        action: utils.transform.toCSV
        version: 1
        inputs:
          json: ${{ .steps.getCurrentTime.outputs.responseBody }}

      - name: logOutput
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: 'CSV: ${{ .steps.csv1.outputs.csv }}'

      - name: postCsv
        type: action
        action: slack.chat.postMessage
        version: 1
        inputs:
          channel: test-channel-workflow
          text: "Current Date details"
          attachment:
            filename: 'file.csv'
            content: ${{ .steps.csv1.outputs.csv }}
          token: ${{ :secrets:dn_staging_slack_token }}
  ```

## Advanced automation workflows

Complex, production-ready automation for infrastructure management and incident response.

### Complex NRQL alerting

Compare NRQL results across time windows to detect anomalies standard alerts can't catch. Requires New Relic account, email destination (see [Send notifications](/docs/workflow-automation/setup-and-configuration/create-destinations)), and schedule via [CreateSchedule API](/docs/workflow-automation/workflow-automation-apis/create-schedule).

**Key actions**: `newrelic.nrdb.query`, `newrelic.notification.sendEmail`

**Use case**: Use this pattern when standard alerts can't meet requirements, such as:
  - Comparing metrics across multiple time windows
  - Applying custom mathematical operations on query results
  - Triggering only when specific thresholds or patterns are detected
  - Combining data from multiple queries with conditional logic

  ```yaml
    name: Complex_Alert_Workflow
    description: 'Compares NRQL results across time windows and sends alerts when new events are detected'

    workflowInputs:
      destinationId:
        type: String
      query:
        type: String
        defaultValue: 'FROM Span SELECT count(*)'

    steps:
      - name: query1
        type: action
        action: newrelic.nrdb.query
        version: 1
        inputs:
          query: "${{ .workflowInputs.query }} SINCE 10 minutes ago UNTIL 5 minutes ago"
          accountIds:
            - 7401815
          selectors:
            - name: length
              expression: '[ .results[] | length ]'
            - name: count
              expression: '[ .results[0].count ]'

      - name: query2
        type: action
        action: newrelic.nrdb.query
        version: 1
        inputs:
          query: "${{ .workflowInputs.query }} SINCE 5 minutes ago"
          accountIds:
            - 7401815
          selectors:
            - name: length
              expression: '[ .results[] | length ]'
            - name: count
              expression: '[ .results[0].count ]'

      - name: CheckForNewEvents
        type: switch
        switch:
          - condition: >-
              ${{ (.steps.query2.outputs.count - .steps.query1.outputs.count) > 0 }}
            next: sendEmail
        next: end

      - name: sendEmail
        type: action
        action: newrelic.notification.sendEmail
        version: 1
        inputs:
          destinationId: ${{ .workflowInputs.destinationId }}
          subject: Hello there!
          message: >-
            More spans incoming!!!
            There are --- ${{ (.steps.query2.outputs.count - .steps.query1.outputs.count) }} ---
            new Spans that were ingested in the last 5 minutes
          attachments:
            - type: QUERY
              query: ${{ .workflowInputs.query }} SINCE 5 minutes ago
              format: CSV
              filename: span_count.csv
        next: end
  ```

**To schedule**, use [CreateSchedule API](/docs/workflow-automation/create-a-workflow-automation/start-schedule#scheduled) with cron expression `*/10 * * * *` (every 10 minutes). Minimum interval is 10 minutes. See [workflow limits](/docs/workflow-automation/limitations-and-faq/workflow-limits) for details.

### Deployment rollback

Monitor New Relic entity health and trigger rollback notifications via AWS SQS or HTTP webhooks when issues detected. Requires New Relic entity monitoring and (optional) AWS SQS queue or HTTP webhook endpoint.

**What this workflow does:**
  - Monitor entity alert severity for specified duration (default 30 minutes)
  - Check entity health every minute
  - Log unhealthy status if entity becomes CRITICAL or WARNING
  - Send AWS SQS rollback notifications (if configured) with entity details
  - Send HTTP webhook rollback notifications (if configured)
  - Log success if entity remains healthy for full duration
  - Stop monitoring if entity not found

**Key actions**: `newrelic.nerdgraph.execute`, `newrelic.ingest.sendLogs`, `aws.execute.api`, `(sqs.send_message)`, `http.post`

### EC2 instance management

Respond to New Relic CPU alerts, request Slack approval, and automate EC2 instance resizing via AWS Systems Manager. Requires AWS credentials (EC2 + Systems Manager), New Relic alert condition, and Slack token.

**What this workflow does:**
  - Receive high CPU alerts from New Relic
  - Retrieve alert details and identify impacted EC2 instance
  - Send Slack notification with instance details and request approval
  - Create SSM document after approval to automate resizing
  - Stop instance, modify instance type, and restart
  - Send progress updates to Slack during resizing
  - Wait for completion and send status
  - Clean up SSM document and send final confirmation

**Key actions**: `newrelic.nerdgraph.execute`, `newrelic.nrdb.query`, `slack.chat.postMessage`, `slack.chat.getReactions`, `aws.systemsManager.writeDocument`, `aws.systemsManager.startAutomation`, `aws.systemsManager.waitForAutomationStatus`, `aws.systemsManager.deleteDocument`, `utils.datetime.fromEpoch`, `utils.uuid.generate`

### API gateway rollback

Detect deployments via New Relic change tracking, send Slack approval requests, and automate API Gateway rollback using AWS Systems Manager. Requires AWS credentials (API Gateway + Systems Manager), Slack token, and New Relic entity monitoring.

**What this workflow does:**
  - Detect recent deployments using New Relic change tracking
  - Send Slack notifications with approval buttons `(:+1: or :-1:)`
  - Create SSM document after approval to automate rollback
  - Roll back API Gateway integration to previous Lambda version
  - Create new deployment to apply rollback
  - Send status notifications to Slack
  - Clean up SSM document after completion

**Key actions**: `newrelic.nerdgraph.execute`, `slack.chat.postMessage`, `slack.chat.getReactions`, `aws.systemsManager.writeDocument`, `aws.systemsManager.startAutomation`, `aws.systemsManager.waitForAutomationStatus`, `aws.systemsManager.deleteDocument`

## Available template workflows

Access templates directly in New Relic Workflow Automation UI:

1. Go to **All Capabilities > Workflow Automation**
2. Click **Create workflow**
3. Select **Use a template**
4. Browse the template library and choose a workflow matching your use case

Templates include:
  - Pre-configured workflow steps and logic
  - Example input parameters
  - Required credentials and integrations
  - Documentation of expected outcomes

Use templates as-is or customize to fit specific requirements.

## What's next

- **[Troubleshooting](/docs/workflow-automation/troubleshooting)**: Fix credential errors, integration issues, and workflow failures.
- **[Best practices](/docs/workflow-automation/limitations-and-faq/workflow-best-practices)**: Error handling, performance optimization, testing strategies.
- **[Workflow limits](/docs/workflow-automation/limitations-and-faq/workflow-limits)**: Understand timeouts, rate limits, and constraints.
