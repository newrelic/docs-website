---
title: 'Track changes using NerdGraph'
tags:
  - APM
  - APM UI pages
  - Events
  - Browser
  - Mobile
  - NerdGraph
metaDescription: "Here's how to use NerdGraph (GraphQL) to designate what you want to capture with change tracking."
redirects:
  - /docs/change-tracking/change-tracking-graphql
freshnessValidatedDate: never
---

The change tracking feature allows you to track the effect of various changes on your customers and systems. For example, if you make some deployments, you can use the change tracking feature to monitor the results in New Relic UI charts. You'll also get access to features that help you understand the effects of those changes.

Instead of designating which changes you want to monitor by using our CLI or a CI/CD integration, you can do the same thing using GraphQL mutations via our NerdGraph API.

For general information on using NerdGraph, see [Introduction to NerdGraph](/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph).

## Prerequisites [#prerequisites]

* [NerdGraph requirements](/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/#authentication)
* User permissions: Any [user type](/docs/accounts/accounts-billing/new-relic-one-user-management/user-type) can use NerdGraph to create change events and deployment markers, but only full platform users can access the curated change tracking UI experiences



<Tabs>
  <TabsBar>
    <TabsBarItem id="event">Change tracking events</TabsBarItem>
    <TabsBarItem id="deployment">Change tracking deployments (Legacy)</TabsBarItem>
  </TabsBar>

  <TabsPages>

  <TabsPageItem id="event">



Change tracking events provide comprehensive monitoring for any system modification including deployments, feature flags, business events, operational changes, and custom activities. This method offers flexible categorization, custom attributes, and unified cross-account visibility. You can create change tracking events using the `changeTrackingCreateEvent` mutation. These markers are stored in NRDB.



<CollapserGroup>
  <Collapser
    className="freq-link"
    id="attributes"
    title="Event attributes"
  >

      <table>
      <thead>
        <tr>
          <th style={{ width: "220px" }}>Attributes</th>
          <th>Datatype</th>
          <th>Required?</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>`category`</td>
          <td>String</td>
          <td>Yes</td>
          <td>
            A `category` attribute allows you to categorize changes using various category and type combinations. You can either use our predefined [standard categories and types](#standard-categories-types) or define your own custom ones.

            * To use our [standard categories and types](#standard-categories-types):
                * If you set `category` to `Deployment`:
                    * You must set the `categoryFields` argument to `Deployment`.
                    * This `deployment` argument must include a `version`.
                * If you set `category` to `Feature Flag`:
                    * You must set the `categoryFields` argument to `FeatureFlag`.
                    * This `featureFlag` argument must include a `featureFlagId`.
            * To use Custom categories or types:
                * Within the `dataHandlingRules` attribute, set the `validationFlags` field to `ALLOW_CUSTOM_CATEGORY_OR_TYPE`.
        </td>
        </tr>
        <tr>
          <td>`dataHandlingRules`</td>
          <td>String</td>
          <td> Yes </td>
          <td>
            To use a custom `category`, `type`, or a non-standard combination, set the `dataHandlingRules` attribute and the `validationFlags` attribute to `ALLOW_CUSTOM_CATEGORY_OR_TYPE`.

            If you do not set `validationFlags` to `ALLOW_CUSTOM_CATEGORY_OR_TYPE`, New Relic will return an error for any custom or non-standard value. For example, pairing a standard `category` like `Deployment` with a custom `type` such as `Rainbow` requires adding both `ALLOW_CUSTOM_CATEGORY_OR_TYPE` to `validationFlags`.

            <Callout variant="tip">
              When using custom values, ensure your `category` and `type` strings use the exact casing you want to appear in the New Relic UI.
            </Callout>
          </td>
        </tr>
        <tr>
          <td>`entitySearch.query`</td>
          <td>String</td>
          <td> Yes </td>
          <td>

            The entity search query enables you to find a specific entity within New Relic. You can search by using its specific entity guid using the `id` field or by providing other identifying information if the entity guid is unknown. An entity guid is a unique identifier that New Relic assigns to your system components such as applications or microservices during their instrumentation or setup. For more information about entities, refer to [New Relic Entities](/docs/new-relic-solutions/new-relic-one/core-concepts/what-entity-new-relic/#what-is-entity).

            * Query specific entities: You can search for an exact or fuzzy matching on various attributes, including `id` and `name`, but your query must be specific enough to resolve to exactly one entity.

            * Supported operators: The `=`, `AND`, `IN`, and `LIKE` operators are supported for entity search queries.

            * Using special characters: Special characters such as `(`, `.` `,`, `;`, `:`, `*`,`-`, `_`, and `)` are treated as whitespace in the query string. For example, a query like `name LIKE ':aws:'` will match entity names containing `-aws` or `foo.aws`.
            * Tags: You can reference tags with or without backticks. You can filter entities based on default entity properties and tags.

                * Default entity properties:

                    * `id`

                    * `accountId`

                    * `name`

                    * `domainId`

                    * `alertSeverity`

                    * `reporting`

                    * `indexedAt`

                    * `firstIndexedAt`

                    * `lastReportingChangeAt`

                * Tags: Tags are metadata typically linked to a more specific domain type or group of domain types. For example:

                    * `language`: Specifies the agent language for APM applications

                    * `clusterAgentId`: For Browser applications, this tag links to the associated APM application's cluster agent.

                    * `aws.accountId`: The `AWS account ID` for infrastructure entities monitored from AWS.

                Examples:

                    * To find an entity by its entity guid: `"id = '<entity guid>'"`
                    * To find an entity using its REST v2 API application ID: `"domainId = '<app id>' AND domain = 'APM'"`
                    * To find an OpenTelemetry service in a specific account: `"name = '<service name>' AND domain = 'EXT' AND type = 'SERVICE' AND accountId = '<account id>'"`
            </td>
        </tr>
        <tr>
          <td>`featureFlagId`</td>
          <td>String</td>
          <td> Yes </td>
          <td>If you select `Feature Flag` as your category, under the `categoryFields` attribute, you must also select `featureFlag` and include a `featureFlagId`. This `featureFlagId` can be any string you would like to identify your feature flag by.</td>
        </tr>
        <tr>
          <td>`type`</td>
          <td> String </td>
          <td>Yes</td>
          <td>
            The `type` attribute provides a further distinction for a change event and is used in conjunction with the `category`. For example, if an event's `category` is `Deployment`, its type might be `Rolling`.

            You can use a predefined standard `type` typically associated with a standard `category` or define a custom `type`.
            If you define a custom type, you must also:
                * Configure the `dataHandlingRules` attribute.
                * Set the `validationFlags` attribute to `ALLOW_CUSTOM_CATEGORY_OR_TYPE`.
          </td>
        </tr>
        <tr>
          <td>`version`</td>
          <td> String </td>
          <td> Yes </td>
          <td> If the `category` attribute is set to `Deployment`, then within the `categoryFields` attribute, you must define a `deployment` field and ensure this `deployment` field includes a `version`.</td>
        </tr>
        <tr>
          <td>`changelog`</td>
          <td>String</td>
          <td>No</td>
          <td>If the `category` is set to `Deployment`, then you can optionally include `changelog` information.</td>
        </tr>
        <tr>
          <td>`commit`</td>
          <td>String</td>
          <td>No</td>
          <td>If the `category` is set to `Deployment`, then you can optionally include `commit` information such as a commit SHA.</td>
        </tr>
        <tr>
          <td>`deepLink`</td>
          <td>String</td>
          <td>No</td>
          <td>If the `category` is set to `Deployment`, then you can optionally include `deepLink` such as a URL. </td>
        </tr>
        <tr>
          <td>`description`</td>
          <td>String</td>
          <td>No</td>
          <td>A description for the change tracking event. For example: `A change event to track the marketing campaign impact.`</td>
        </tr>
        <tr>
          <td>`groupId`</td>
          <td>String</td>
          <td>No</td>
          <td> 
          A `groupId` attribute lets you organize the related changes across one or more entities. By using the same `groupId` for each related change, you can easily view these changes together in New Relic interfaces or refine query results. You can also use the same `groupId` to add changes to an existing group.

            <Callout variant="tip" title="TIP">
              New Relic recommends using the `groupId` attribute when making multiple updates to one or more entities or implementing various changes across your system.
            </Callout>
            </td>
        </tr>
        <tr>
          <td>`shortDescription`</td>
          <td>String</td>
          <td>No</td>
          <td>
          A short description for each change lets you identify the change events sent to New Relic quickly. If left blank, an autogenerated description is created that includes the entity, user, and version. The short description appears in the following areas:

            * In the **marker flag** as a tool tip, when you hover over a change marker on the chart.
            * In the **Activity stream** panels.

            <img
              style={{ align: 'left',maxWidth: '100%' }}
              title="Usage of short description in change marker flag"
              alt="Usage of short description in change marker flag"
              src="/images/change-tracking-screenshot-short-description-marker.webp"
            />
          </td>
        </tr>
        <tr>
          <td>`user`</td>
          <td>String</td>
          <td>No</td>
          <td>User identification or a valid email address. For example, user: `datanerd@example.com`.</td>
        </tr>
    </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="custom-attributes"
    title="Custom attributes"
  >
    You can define your custom attributes as key-value pairs to add additional metadata to change events.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>Parameters</th>
          <th>Datatype</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>`customAttributes`</td>
          <td>Object</td>
          <td>
            A `customAttributes` field is specified as `key-value` pairs in JavaScript object format, where values can be of `string`, `boolean`, or `number` types. JavaScript numbers are stored as Java `long` or `double` values. Unlike `JSON`, keys in JavaScript objects are not quoted. To add a custom attribute, structure it as follows:

            ``` customAttributes: {keyName : "value", anotherKeyName: 2.1} ```
            </td>
        </tr>
      </tbody>
    </table>

    To prevent naming conflicts with default attribute names and NRQL keywords, the following custom attribute names are restricted:
    * `accountId`
    * `ago`
    * `and`
    * `appID`
    * `as`
    * `auto`
    * `begin`
    * `begintime`
    * `category`
    * `categoryType`
    * `changeTrackingId`
    * `compare`
    * `customAttributes`
    * `customType`
    * `day`
    * `days`
    * `description`
    * `end`
    * `endtime`
    * `entity.domain`
    * `entity.guid`
    * `entity.name`
    * `entity.type`
    * `entityGuid`
    * `entityName`
    * `explain`
    * `eventType`
    * `facet`
    * `from`
    * `fb.input`
    * `groupId`
    * `hostname`
    * `hour`
    * `hours`
    * `in`
    * `is`
    * `like`
    * `limit`
    * `log`
    * `minute`
    * `minutes`
    * `month`
    * `months`
    * `not`
    * `null`
    * `offset`
    * `or`
    * `plugin.type`
    * `raw`
    * `second`
    * `seconds`
    * `select`
    * `since`
    * `timeseries`
    * `timestamp`
    * `type`
    * `until`
    * `user`
    * `week`
    * `weeks`
    * `where`
    * `with`
  </Collapser>

  <Collapser
    className="freq-link"
    id="set-attributes"
    title="Auto-generated attributes"
  >
    New Relic automatically sets the `timestamp` and `changeTrackingId` attributes. You can provide the `timestamp` value as long as it is within one day before or after the current time. However, the `changeTrackingId` must be unique and will always be generated by New Relic.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>Parameters</th>
          <th>Datatype</th>
          <th>Description</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `changeTrackingId`
          </td>
          <td>
            String
          </td>
          <td>
            The `changeTrackingId` is a unique identifier generated when a change is recorded. You can use this ID in NerdGraph and NRQL queries to identify specific changes. For example: `changeTrackingId = '8a3a594c-e726-4bc2-8078-26dffec9a3d8'`.
          </td>
        </tr>
        <tr>
          <td>
            timestamp
          </td>
          <td>
            `EpochMilliseconds`
          </td>
          <td>
            The `timestamp` attribute shows when a NerdGraph call was received. You can provide it by specifying the number of milliseconds since the Unix epoch. For example: `timestamp: 1032480000000`.

            <Callout variant="important">
              Timestamps must be applied within +/- 24 hours of the current time when the NerdGraph call is made, or the payload will be rejected.
            </Callout>
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

</CollapserGroup>

#### Sample mutations [#mutation-examples]

The following examples show NerdGraph mutations, with their required and optional attributes, for creating tracking markers:

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="simple-mutation"
    title="Mutation with only required fields"
  >
    ```graphql
        mutation {
          changeTrackingCreateEvent(
            changeTrackingEvent: {
              categoryAndTypeData: {
                categoryFields: { deployment: { version: "1234" } }
                kind: { category: "deployment", type: "basic" }
              }
              entitySearch: { query: "id = 'entity guid goes here'" }
            }
          ) {
            changeTrackingEvent {
              category
              categoryAndType
              changeTrackingId
              customAttributes
              description
              entity {
                name
                guid
              }
              groupId
              shortDescription
              timestamp
              user
              type
            }
            messages
          }
        }
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="optional-mutation-example"
    title="Mutation with optional fields"
  >
    ```graphql

        mutation {
          changeTrackingCreateEvent(
            changeTrackingEvent: {
              categoryAndTypeData: {
                kind: { category: "BUSINESS_EVENT", type: "CONVENTION" }
              }
              user: "testUser"
              shortDescription: "sample activity event description"
              description: "sample event description"
              groupId: "testGroup123"
              customAttributes: {
                isProduction: true
                region: "us-east-1"
                instances: 2
                deployTimeMs: 10.5
              }
              entitySearch: {
                query: "id = 'entity guid goes here'"
              }
            }
          ) {
            changeTrackingEvent {
              category
              categoryAndType
              changeTrackingId
              customAttributes
              description
              entity {
                name
                guid
              }
              groupId
              shortDescription
              timestamp
              user
              type
            }
            messages
          }
        }
    ```
  </Collapser>

    <Collapser
    className="freq-link"
    id="custom-category-and-type-mutation"
    title="Mutation with validation flag for custom category or type"
  >
    ```graphql
        mutation {
          changeTrackingCreateEvent(
            changeTrackingEvent: {
              categoryAndTypeData: {
                kind: { category: "External Event", type: "Cloud Provider Outage" }
              }
              user: "product@example.com"
              description: "Cloud Provider outage for US-East for Production customer database"
              entitySearch: {
                query: "id = 'entity guid goes here'"
              }
            }
            dataHandlingRules: { validationFlags: [ALLOW_CUSTOM_CATEGORY_OR_TYPE] }
          ) {
            changeTrackingEvent {
              category
              categoryAndType
              changeTrackingId
              customAttributes
              description
              entity {
                name
                guid
              }
              groupId
              shortDescription
              timestamp
              user
              type
            }
            messages
          }
        }
    ```

  </Collapser>
  
</CollapserGroup>


### Use case examples for change tracking events [#use-case-examples]

Here are example GraphQL mutations for creating change tracking events:

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="simple-event-mutation"
    title="Simple deployment event mutation"
  >
    ```graphql
        mutation {
          changeTrackingCreateEvent(
            changeTrackingEvent: {
              categoryAndTypeData: {
                categoryFields: { deployment: { version: "1.2.3" } }
                kind: { category: "deployment", type: "basic" }
              }
              entitySearch: {
                query: "id = 'entity guid goes here'"
              }
            }
          ) {
            changeTrackingEvent {
              category
              categoryAndType
              changeTrackingId
              customAttributes
              description
              entity {
                name
                guid
              }
              groupId
              shortDescription
              timestamp
              user
              type
            }
            messages
          }
        }
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="business-event-mutation"
    title="Business event mutation with custom attributes"
  >
    ```graphql
        mutation {
          changeTrackingCreateEvent(
            changeTrackingEvent: {
              categoryAndTypeData: {
                kind: { category: "BUSINESS_EVENT", type: "MARKETING_CAMPAIGN" }
              }
              user: "marketing@example.com"
              shortDescription: "Black Friday campaign launch"
              description: "Launched Black Friday marketing campaign with 30% discount"
              groupId: "blackfriday2024"
              customAttributes: {
                campaignType: "seasonal"
                discountPercent: 30
                targetAudience: "premium_customers"
              }
              entitySearch: {
                query: "name = 'ecommerce-app' AND domain = 'APM'"
              }
            }
          ) {
            changeTrackingEvent {
              category
              categoryAndType
              changeTrackingId
              customAttributes
              description
              entity {
                name
                guid
              }
              groupId
              shortDescription
              timestamp
              user
              type
            }
            messages
          }
        }
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="feature-flag-mutation"
    title="Feature flag event mutation"
  >
    ```graphql
        mutation {
          changeTrackingCreateEvent(
            changeTrackingEvent: {
              categoryAndTypeData: {
                categoryFields: { featureFlag: { featureFlagId: "new-checkout-flow" } }
                kind: { category: "FEATURE_FLAG", type: "BASIC" }
              }
              user: "product@example.com"
              shortDescription: "Enabled new checkout flow"
              description: "Rolled out new streamlined checkout process to 25% of users"
              entitySearch: {
                query: "id = 'entity guid goes here'"
              }
            }
          ) {
            changeTrackingEvent {
              category
              categoryAndType
              changeTrackingId
              customAttributes
              description
              entity {
                name
                guid
              }
              groupId
              shortDescription
              timestamp
              user
              type
            }
            messages
          }
        }
    ```

  </Collapser>
</CollapserGroup>

## Standard categories and types [#standard-categories-types]

<Collapser
  className="freq-link"
  id="standard-types"
  title="standard-categories-types"
>


For change tracking events, these are the valid predefined category and type pairs:

<table>
  <thead>
    <tr>
      <th>Category</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`Deployment`</td>
      <td>
        * `Basic` 
        * `Blue Green`
        * `Canary`
        * `Rolling`
        * `Shadow`
      </td>
    </tr>
    <tr>
      <td>`Deployment Lifecycle`</td>
      <td>
        * `Artifact Copy`
        * `Artifact Deletion`
        * `Artifact Deployment`
        * `Artifact Move`
        * `Build Deletion`
        * `Build Promotion`
        * `Build Upload`
        * `Image Deletion`
        * `Image Promotion`
        * `Image Push`
        * `Release Bundle Creation`
        * `Release Bundle Deletion`
        * `Release Bundle Sign`
      </td>
    </tr>
    <tr>
      <td>`Feature Flag`</td>
      <td>`Basic`</td>
    </tr>
    <tr>
      <td>`Business Event`</td>
      <td>
        * `Convention`
        * `Marketing Campaign`
        * `Other`
      </td>
    </tr>
    <tr>
      <td>`Operational`</td>
      <td>
        * `Crash`
        * `Other`
        * `Scheduled Maintenance Period`
        * `Server Reboot`
      </td>
    </tr>
  </tbody>
</table>

</Collapser>

  </TabsPageItem>

  <TabsPageItem id="deployment">


Change tracking deployments provide specialized tracking for code deployments and infrastructure changes. This is the legacy method that focuses specifically on deployment events. You can create deployment markers using the `changeTrackingCreateDeployment` mutation. These markers are stored in NRDB.

<Callout variant="tip">
  New Relic recommends migrating to change tracking events using `changeTrackingCreateEvent` for better flexibility and feature support. Deployment markers will continue to work but have limited functionality compared to change events.
</Callout>

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="required-fields"
    title="Required attributes"
  >
    To track a change, such as a deployment, you must set the following:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Attribute
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `entityGuid`
          </td>

          <td>
            The `entityGuid` value is the unique identifier assigned by New Relic to your system components during instrumentation and setup processes. For more information on New Relic Entities and finding Entity GUIDs, see this [guide](/docs/new-relic-solutions/new-relic-one/core-concepts/what-entity-new-relic/#find).
          </td>
        </tr>

        <tr>
          <td>
            `version`
          </td>

          <td>
            The version attribute value can be anything, although we recommend using the version number set during your build process. To see an example of how this can be done, see our [Jenkins deployments plugin documentation](#jenkins-markers) below. If you already report version numbers to New Relic <InlinePopover type="mobile"/> or by some other means, we recommend using the same here to set yourself up for forthcoming features that will allow you to facet and correlate data by version.
          </td>
        </tr>
      </tbody>
    </table>

    <Callout variant="tip">
      If you are transitioning away from the legacy REST API, you'll need to start using your application's entity GUID instead of the appID. You can easily find the GUID in NerdGraph with this query:

      ```graphql
      {
        actor {
          entitySearch(query: "domainId=INSERT_YOUR_APPID") {
            count
            query
            results {
              entities {
                entityType
                name
                guid
              }
            }
          }
        }
      }
      ```
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="optional-fields"
    title="Optional attributes"
  >
    You can define some optional and useful attributes to add context to the change you are tracking. These attributes can also enable certain change tracking features.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Attribute
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `changelog`
          </td>

          <td>
            You can submit a URL or any string for the changelog attribute. For example: `changelog: "Added: /v2/deployments.rb, Removed: None"` or `changelog: "https://github.com/nodejs/node/blob/v4.2.3/CHANGELOG.md"`.
          </td>
        </tr>
        <tr>
          <td>
            `commit`
          </td>

          <td>
            You can submit any string for the `commit` attribute, and we suggest using the commit SHA associated with the deployment or change, for example, `commit: "r3ws4sa43f"`.
          </td>
        </tr>
        <tr>
          <td>
            `description`
          </td>

          <td>
            You can submit any string for the description attribute. For example: `description: "Added a deployments resource to the v2 API"`.

            The description attribute may be where you choose to insert codified information from your internal deployment management processes. You can use IDs or tags you assign to each commit or deployment that describes organizational or business aspect of the work, for example, `EU_MAINT_DMARK_v101`.
          </td>
        </tr>
        <tr>
          <td>
            `deepLink`
          </td>

          <td>
            You can submit any URL for the `deepLink` attribute.  We suggest using one that will help someone evaluating a change on New Relic to quickly get to a place where they can take further action, such as Jenkins, ArgoCD, or GitHub Actions. Here's an example: `deepLink: "http://localhost:8080/job/PipelineV2/configure"`.
          </td>
        </tr>

        <tr>
          <td>
            `deploymentType`
          </td>

          <td>
            You can divide changes related to deployments into different types. These types align with common deployment techniques, but there is also an `OTHER` type. Types include:

            * `BASIC`
            * `BLUE_GREEN`
            * `CANARY`
            * `ROLLING`
            * `SHADOW`
            * `OTHER`

            Assigning a type to each deployment will help you filter results on change tracking interfaces and NerdGraph/NRQL query results.
          </td>
        </tr>

        <tr>
          <td>
            `groupId`
          </td>

          <td>
            You may want to group deployments in cases where you're making a series of changes to one or more entities or releasing many changes across many entities within your system. By setting the same `groupId` attribute value for each related deployment, you can more easily see these changes together in New Relic interfaces or use the `groupId` to narrow query results.

            The `groupId` can be any string of your choosing, and you can continue to add deployments to a group after the first use of the `groupId` (in case you want to relate this deployment to one that happened weeks or even months ago).

            <Callout variant="tip">
              In addition to using the `groupId` to relate many deployments, you may also use the attribute to define long-running changes. For example, two deployments with the same `groupId` could bracket a period during which alerts were suppressed or some migration was taking place.
            </Callout>
          </td>
        </tr>
        <tr>
          <td>
            user
          </td>

          <td>
            Can be any string, for example, `user: "datanerd@example.com"`.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="nr-attributes"
    title="Attributes set by New Relic"
  >
    New Relic automatically sets the `timestamp` and `deploymentId` attributes. You can provide a `timestamp` value as an override, but `deploymentId` will always be generated by New Relic to ensure uniqueness.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Attribute
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            timestamp
          </td>

          <td>
            The time at which the NerdGraph call was received. You can provide an override here as the number of milliseconds since the Unix epoch. For example: `timestamp: 1032480000000`.

            <Callout variant="important">
              There is a firm limitation applied that all timestamps must be +/- 24 hours of the current time when the NerdGraph call is received or the payload will be rejected.
            </Callout>
          </td>
        </tr>

        <tr>
          <td>
            `deploymentId`
          </td>

          <td>
            A unique identifier generated when the deployment is recorded. While you cannot set `deploymentId`, you can use it in your NerdGraph and NRQL queries to locate specific deployments. Here's an example: `deploymentId: "8a3a594c-e726-4bc2-8078-26dffec9a3d8"`.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>


### Deployment mutation examples [#deployment-mutation-examples]

The examples below show how to create deployment markers using the legacy API:


<CollapserGroup>
  <Collapser
    className="freq-link"
    id="simple-mutation"
    title="Mutation with only required fields"
  >
    ```graphql
    mutation {
      changeTrackingCreateDeployment(
        deployment: {
          version: "0.0.1",
          entityGuid: "INSERT_YOUR_GUID"
        }
      )
        {
          deploymentId
          entityGuid
        }
    }
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="optional-mutation-example"
    title="Mutation with optional fields"
  >
    ```graphql
    mutation {
      changeTrackingCreateDeployment(
        deployment: {
          version: "0.0.1",
          user: "INSERT_YOUR_NAME",
          timestamp: INSERT_MS_EPOCH_TIMESTAMP,
          groupId: "78641",
          entityGuid: "INSERT_YOUR_GUID",
          description: "create a new marker",
          deploymentType: BASIC,
          deepLink: "example.com/path",
          commit: "INSERT_A_COMMIT_HASH",
          changelog: "test log"
        }
      )
      {
        changelog
        commit
        deepLink
        deploymentId
        deploymentType
        description
        entityGuid
        groupId
        timestamp
        user
        version
      }
    }
    ```
  </Collapser>
</CollapserGroup>

  </TabsPageItem>
  </TabsPages>
  </Tabs>


## What's next [#whats-next]

<DocTiles>
  <DocTile title="View and analyze changes" path="/docs/change-tracking/view-analyze-data/">Learn advanced techniques for correlating change data with performance metrics and system behavior.</DocTile>
  <DocTile title="Query your changes" path="/docs/change-tracking/query-data">Learn how to query your change data in New Relic.</DocTile>
  <DocTile title="Notify your team" path="/docs/change-tracking/change-tracking-webhooks">Learn how to set up notifications for your change tracking events.</DocTile>
</DocTiles>