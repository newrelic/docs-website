---
title: 'Java agent: Instrument Kafka message queues'
tags:
  - Agents
  - Java agent
  - Instrumentation
metaDescription: 'New Relic for Java includes built-in Kafka monitoring, as well as advanced event and distributed tracing data collection.'
redirects:
  - /docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues
  - /docs/agents/java-agent/instrumentation/use-kafka-message-queues
  - /docs/agents/java-agent/instrumentation/instrument-kafka-message-queues
---

The New Relic Java agent automatically collects data from [Kafka](https://kafka.apache.org/documentation/)'s Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases.

This document explains how to collect and view three types of Kafka data:

* [Kafka metrics](#view-kafka-metrics)
* [Kafka events](#collect-kafka-events)
* [Enable Kafka Streams transactions](#collect-kafka-streams-transactions)
* [Kafka distributed traces](#collect-kafka-distributed-traces)

<Callout variant="tip">
  We also have a Kafka integration. For details on that, see [Kafka monitoring integration](/docs/integrations/host-integrations/host-integrations-list/kafka-monitoring-integration).
</Callout>

## Requirements [#requirements]

Kafka clients instrumentation is available in Java agent versions 4.12.0 or higher. Kafka streams instrumentation is available in Java Agent versions 8.1.0 or higher. To see all supported Kafka libraries, check the [Java compatibility and requirements page](/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent). Note that Kafka Streams runs on top of Kafka clients so all of the instrumentation that applies to Kafka clients also applies to Streams.

## View Kafka metrics

After [installation](/docs/agents/java-agent/installation/install-java-agent), the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all [Kafka consumer and producer metrics](https://kafka.apache.org/documentation/#monitoring) (but not connect or stream metrics).

To view these metrics, create a custom dashboard:

1. Go to the [New Relic metric explorer](/docs/insights/use-insights-ui/explore-data/metric-explorer-search-chart-metrics-sent-new-relic-agents).
2. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder:

   ```
   MessageBroker/Kafka/Internal/KafkaMetricName
   ```

   For example, the `request-rate` metric is located at:

   ```
   MessageBroker/Kafka/Internal/consumer-metrics/request-rate
   ```
   
   If you are using Kafka Streams, you can find streams metrics in this metric folder:
   
   ```
   Kafka/Streams/KafkaStreamsMetricName
   ```
   
   For example, the `poll-latency-avg` metric is located at:
   
   ```
   Kafka/Streams/stream-thread-metrics/poll-latency-avg
   ```

   <Callout variant="tip">
     For a full list of Kafka consumer, producer, and streams metrics, see the [Kafka docs](https://kafka.apache.org/documentation/#remote_jmx). The metrics in those docs are searchable via JMX. Keep in mind not every metric mentioned in the docs will be exported into New Relic. This could be due to one of these reasons:

      * The metric is not actually generated by Kafka clients or Kafka Streams. This may be due to using an older version of clients or Streams or based on how you setup and use your Kafka libraries.
      * The metric is not numeric or its value is `NaN`. New Relic only accepts metrics with a numeric value.     
   </Callout>
3. Add the metrics you want to monitor to a dashboard by clicking **Add to dashboard**.

## Enable Kafka event collection [#collect-kafka-events]

You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see [data collection](/docs/using-new-relic/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#overview)). This allows you to use [NRQL](/docs/insights/nrql-new-relic-query-language/using-nrql/introduction-nrql) to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from [Kafka consumer and produce metrics](https://kafka.apache.org/documentation/#monitoring) captured since the previous event.

If you are using Kafka Streams, the agent generates a seperate event that contains all of the data from [Kafka stream metrics](https://kafka.apache.org/documentation/#remote_jmx) captured since the previous event. The event is also collected every 30 seconds.

<Callout variant="important">
  The agent records up to 2000 events per [harvest cycle](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#harvest-cycle), though you can change this value with [`max_samples_stored`](/docs/agents/java-agent/configuration/java-agent-configuration-config-file#ae-max_samples_stored). Kafka event data is included in this pool. If you use the `recordCustomEvent()` API call to send [custom events](/docs/insights/insights-data-sources/custom-data/insert-custom-events-new-relic-apm-agents) to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events.
</Callout>

To enable Kafka event collection:

1. Add the `kafka.metrics.as_events.enabled` element to your `newrelic.yml` config file:

   ```
   kafka.metrics.as_events.enabled: true
   ```
2. Restart your JVM.
3. Use the [event explorer](/docs/insights/use-insights-ui/explore-data/event-explorer-query-chart-your-event-data) to view your Kafka events, located in the `KafkaMetrics` event type. Or, use [NRQL](/docs/insights/nrql-new-relic-query-language/using-nrql/introduction-nrql) to query your events directly. For example:

   ```
   SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries
   ```
   If you are querying Kafka Streams metrics, use the `KafkaStreamsMetrics` event type to access streams-specific metrics.

<Callout variant="important">
  Keep in mind that the limitations on what kind of Kafka metrics you can send to New Relic as timeslice metrics also applies to events. That is, non-numeric and NaN metrics are not included as event attributes.
</Callout>
   
## Enable Kafka Streams transactions [#collect-kafka-streams-transactions]

If you're using Kafka Streams, by default we do not enable transactions. This is to prevent unnecessary overhead because Kafka applications tend to have high throughput. 

Unlike JMS transactions, Kafka Streams transactions are not processed per record. Instead, a transaction begins when a Kafka consumer polls records and then the resulting data gets processed.

If you do wish to create transactions, you need to enable a `kafka-streams-spans` module:

```
class_transformer:
  kafka-streams-spans:
    enabled: true
```

## Enable Kafka distributed traces [#collect-kafka-distributed-traces]

The Java agent can also collect [distributed traces](/docs/apm/distributed-tracing/getting-started/introduction-distributed-tracing) from Kafka clients. Because Kafka Streams runs on top of Kafka clients, the steps to manage distributed tracing also apply. Enabling traces doesn't affect the agent's normal operations; it will still report metric or event data from Kafka.

Impacts and requirements to consider before enabling:

* **The instrumentation adds a 150 to 200 byte payload to message headers.** If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production.
* Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher.
* If you have **not** enabled distributed tracing for your app before, read the [Transition guide](/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing) before enabling.
* To propagate W3C trace context via Kafka message headers, see the [distributed tracing API usage guide](/docs/agents/java-agent/api-guides/guide-using-java-agent-api#trace-calls) for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see [Using Java agent trace APIs with Kafka](https://github.com/newrelic/newrelic-java-examples/tree/main/newrelic-java-agent/distributed-tracing/kafka-examples).
* If you're using Kafka Streams, you need to enable a span instrumentation module (refer to the [Kafka Streams transaction section](#collect-kafka-streams-transactions)). Because a transaction is not recorded per record, accepting distributed trace headers will only work for one record.

The complete process of enabling this is described below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) call the [Java agent API](/docs/agents/java-agent/api-guides/guide-using-java-agent-api) to instrument transactions on both the producer and consumer side.

To collect distributed traces from Kafka:

<CollapserGroup>
  <Collapser
    id="enable-dt-kafka"
    title="1. Enable distributed tracing in the config file"
  >
    If you have not enabled distributed tracing for your app before, read the [distributed tracing transition guide](/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing) before you enable it.

    To enable Kafka distributed tracings, these two settings must be enabled in your [`newrelic.yml` config file](/docs/agents/java-agent/configuration/java-agent-configuration-config-file#Structure):

    * Make sure the [`distributed_tracing`](/docs/agents/java-agent/configuration/java-agent-configuration-config-file#distributed-tracing) element is enabled:

      ```
      distributed_tracing:
        enabled: true
      ```
    * Enable the Kafka-specific distributed tracing features by adding the following to your config file:

      ```
      class_transformer:
        com.newrelic.instrumentation.kafka-clients-spans-0.11.0.0:
          enabled: true
      ```
  </Collapser>

  <Collapser
    id="instrument-kafka-producer"
    title="2. Instrument the Kafka producer"
  >
    To instrument your Kafka producer, you'll need to start a transaction before any calls to `Producer.send(ProducerRecord<K, V> record)`. To do this, add the Java agent `@Trace(dispatcher = true)` annotation to the method.

    For example:

    ```
    @Trace(dispatcher = true)
    public static void createAndSend(KafkaProducer<String, String> producer){
        ProducerRecord<String, String> data = new ProducerRecord<String, String>("topic", "key", "value");
        producer.send(data);
    }
    ```
    <Callout variant="important"> 
      If you're using Kafka Streams, you don't need to directly start a transaction or send data to a producer.
    </Callout>
  </Collapser>

  <Collapser
    id="instrument-kafka-consumer"
    title="3. Instrument the Kafka consumer"
  >
    To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the `newrelic` key or under the W3C's `traceparent` and `tracestate` keys. Retrieve the header, then call the New Relic transaction API to accept the payload.

    For example:

    ```
    @Trace(dispatcher = true)
    private static void processMessage(ConsumerRecord<String, String> rec) {
      // create a distributed trace headers map
      Headers dtHeaders = ConcurrentHashMapHeaders.build(HeaderType.MESSAGE);

      // Iterate through each record header and insert the trace headers into the dtHeaders map
      for (Header header : rec.headers()) {
        String headerValue = new String(header.value(), StandardCharsets.UTF_8);

        // using the newrelic key
        if (header.key().equals("newrelic")) {
          dtHeaders.addHeader("newrelic", headerValue);
        }

        // or using the W3C keys
        if (header.key().equals("traceparent")) {
          dtHeaders.addHeader("traceparent", headerValue);
        }

        if (header.key().equals("tracestate")) {
          dtHeaders.addHeader("tracestate", headerValue);
        }
      }

      // Accept distributed tracing headers to link this request to the originating request
      NewRelic.getAgent().getTransaction().acceptDistributedTraceHeaders(TransportType.Kafka, dtHeaders);
    }
    ```
    <Callout variant="important"> 
      If you enabled transactions with Kafka Streams (refer to the [Kafka Streams transaction section](#collect-kafka-streams-transactions)), 
      even though a transaction applies to many records, accepting distributed trace headers will only apply to one record.
    </Callout>
  </Collapser>
</CollapserGroup>
