---
title: "Agent Control architecture"
metaDescription: "Learn about the architecture of Agent Control"
freshnessValidatedDate: never
draft: true
---
<Callout title="preview">
  We're still working on this feature, but we'd love for you to try it out!

  This feature is currently provided as part of a preview program pursuant to our [pre-release policies](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy).
</Callout>

**Agent Control** is New Relic's solution for managing infrastructure-level instrumentation at scale. It addresses the high toil and complexity of deploying, configuring, and updating agents across New Relic and OpenTelemetry ecosystems. 

On Kubernetes, Agent Control acts as a lightweight supervisor that uses a powerful, declarative approach to manage all your agents. It automates these tasks to provide a seamless and consistent experience across your fleets. 

## The challenge of managing observability at scale

Managing observability infrastructure across a large, diverse environment is challenging. Manually deploying and configuring multiple agents on Kubernetes clusters is time-consuming, prone to errors, and difficult to keep consistent. This manual toil makes it hard to quickly add new instrumentation, optimize configurations, and keep agents updated.

Agent Control provides a single, unified solution for managing all your New Relic and OpenTelemetry agents. It runs as a lightweight supervisor on your hosts or within your Kubernetes clusters, communicating with the New Relic platform to receive remote configurations and deployment instructions. This eliminates the need for manual intervention on each host, allowing you to manage your entire fleet from a single, centralized location.

## How Agent Control works

Agent Control's power comes from its use of a declarative, GitOps-like approach to agent management. It treats the desired state of your instrumentation as a single source of truth, ensuring that what you configure in New Relic Control is what's running on your clusters.

### The declarative engine: Flux on Kubernetes

On Kubernetes, Agent Control leverages **[Flux](https://fluxcd.io/)**, a powerful and widely adopted CNCF project, as its declarative engine. Flux's controllers automatically deploy and update agents based on the configuration provided by Agent Control.

This declarative approach provides several key benefits:

- **Consistency:** Eliminates configuration drift across your clusters.
- **Automation:** Automatically applies configuration changes and updates, reducing manual toil.
- **Reliability:** Provides a self-healing mechanism, as Flux continuously monitors and reconciles the state of your agents to match your desired configuration.
 
The diagram below shows how Agent Control connects to New Relic Control (the backend and UI) and Flux (the on-cluster engine) to manage your agents:

<img
  title="Agent Control architecture"
  alt="Agent Control architecture for Agent Management"
  src="/images/agent-control-architecture.png"
/>

### Centralized remote configuration

Agent Control can use local or remote configurations. While local configurations are defined in the initial installation file, remote configurations are fetched from New Relic Control and rendered directly to your agents. This allows you to manage everything from a central point (and UI), including:

- **Credentials:** Agent Control can pull sensitive credentials from external secret providers like Vault, rendering them into the agent's configuration at runtime. This enhances security by keeping credentials out of the configuration itself. 
- **Agent Configuration:** It automatically converts remote configurations into a format that is compatible with the underlying agent. This means you can manage different types of agents (e.g., Infrastructure Agent, OpenTelemetry Collector) with a single, unified process. 

### The future of agent management

This powerful architecture lays the foundation for future features that will further enhance your observability experience:
- **Fleet-wide commands:** The ability to send commands and perform actions on your entire fleet of agents.
- **Advanced communication:** Direct, real-time communication with agents for on-demand troubleshooting and data collection.
- **Enhanced security:** Further integration with security providers and automated credential management.

<Callout title="warning">
  To enable this level of control and communication, Agent Control requires specific permissions. It needs to be configured with the necessary access to pull configurations and to interact with local systems to manage the agent lifecycle. When deploying Agent Control, ensure you understand and grant the required permissions to maintain a secure and functional environment.
  Please refer to the following section [Permissions](#permissions)
</Callout>

{/* ## A powerful supervisor

Agent Control is designed to be a supervisor able to manage your instrumentation, which requires it to perform powerful actions within your environment. To ensure a secure and functional setup, it's critical to understand and grant the required permissions. */}

## Agent Control permissions
Deploying and managing agents in a Kubernetes cluster requires a clear understanding of the necessary permissions. Here, we'll explain the roles of both Agent Control and Flux and how they interact to securely install, update, and remove agents while ensuring that each agent only has the permissions it needs.

### Kubernetes
In a Kubernetes environment, Agent Control uses Flux as its declarative engine to install, update, and uninstall agents. As such, Agent Control needs permissions to manage Flux resources, and Flux itself needs elevated permissions to manage the agent workloads.

- **Permissions for Agent Control:** Agent Control requires permissions to create, read, update, and delete Flux-specific Custom Resources, such as `HelmRelease` and `HelmRepository`. This allows Agent Control to tell Flux what to do without needing direct cluster-admin access itself.
- **Permissions for Flux:** Flux requires high-level permissions, typically with a `cluster-admin` role, to manage the lifecycle of any Helm chart it's instructed to deploy. This includes creating `Deployments`, `DaemonSets`, `Services`, and other core Kubernetes resources on behalf of the user. For security, it's a best practice to ensure that only trusted and verified configurations are used with Agent Control.

{/* #### Host-based Systems
For host-based systems (currently in public preview), Agent Control also requires elevated access. The supervisor needs to run with root or equivalent privileges to perform tasks such as:

- **Installing new agents:** Placing agent binaries and configuration files in system-level directories.
- **Managing agent processes:** Starting, stopping, and restarting services (e.g., using systemd).
- **Reading system data:** Accessing system-level logs and performance metrics.

Similar to Kubernetes, the host-based supervisor's power is balanced by the declarative model: it only takes actions that are defined in its configuration. This ensures that its elevated privileges are used to maintain the desired state of the agents, not to perform arbitrary, unapproved actions. */}

### Agent-specific permissions
Different agent types and their configurations require different permissions. For example, an agent that collects metrics from the Kubernetes API needs more permissions than an agent that only reads logs from files.

Agent Control is designed to manage these permissions flexibly. While Flux requires a high level of access to function, our goal is to ensure that Agent Control only requests the **minimum required permissions** for the specific combination of agents you are deploying.

For detailed information on the specific permissions required by each agent, refer to [Supported agent types](/docs/new-relic-control/agent-control/agent-types). 

{/* We are continually working to improve our permissions model to give you granular control, so you can maintain a secure environment with only the necessary access granted. */}