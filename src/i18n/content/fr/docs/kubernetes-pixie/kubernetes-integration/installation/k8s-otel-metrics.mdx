---
title: New Relic OTel K8s modélisation métriques
tags:
  - Kubernetes integration
  - OpenTelemetry
metaDescription: Learn how to monitor your Kubernetes Cluster using OpenTelemetry
freshnessValidatedDate: never
translationType: machine
---

Les métriques Kubernetes OpenTelemetry sont collectées par OpenTelemetry Collector et envoyées à New Relic à l&apos;aide de l&apos;intégration New Relic Kubernetes.

Ce document fournit une modélisation des métriques Kubernetes OpenTelemetry vers les métriques New Relic Kubernetes . Cette modélisation vous aide à comprendre les métriques et les attributs disponibles pour monitoring votre cluster Kubernetes.

<CollapserGroup>
  <Collapser id="for-api-server" title="Pour le serveur API">
    Le tableau suivant mappe les métriques Kubernetes OpenTelemetry aux métriques New Relic Kubernetes. Ces métriques proviennent du `API server` configuré avec le `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Métrique OTel
          </th>

          <th>
            Métrique New Relic
          </th>

          <th>
            Nom de l&apos;événement New Relic
          </th>

          <th>
            Type : Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `apiserver_storage_objects`
          </td>

          <td>
            `apiserverStorageObjects_resource_RESOURCE-KIND`
          </td>

          <td>
            `K8sApiServerSample`
          </td>

          <td>
            **Jauge :**

             nombre d&apos;objets stockés dans le serveur API.
          </td>
        </tr>

        <tr>
          <td>
            `go_goroutines`
          </td>

          <td>
            `goGoroutines`
          </td>

          <td>
            `K8sApiServerSample`
          </td>

          <td>
            **Jauge :**

             nombre de 

            `goroutines`

             qui existent actuellement.
          </td>
        </tr>

        <tr>
          <td>
            `go_threads`
          </td>

          <td>
            `goThreads`
          </td>

          <td>
            `K8sApiServerSample`

            , 

            `K8sControllerManagerSample`

            , 

            `K8sEtcdSample`

            , 

            `K8sSchedulerSample`
          </td>

          <td>
            **Jauge :**

             nombre de threads du système d&apos;exploitation créés.
          </td>
        </tr>

        <tr>
          <td>
            `process_resident_memory_bytes`
          </td>

          <td>
            `processResidentMemoryBytes`
          </td>

          <td>
            `K8sApiServerSample`
          </td>

          <td>
            **Jauge :**

             taille de la mémoire résidente en octets.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-cAdvisor" title="Pour cAdvisor">
    Le tableau suivant mappe les métriques Kubernetes OpenTelemetry aux métriques New Relic Kubernetes. Ces métriques proviennent du `cAdvisor` configuré avec le `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Métrique OTel
          </th>

          <th>
            Métrique New Relic
          </th>

          <th>
            Nom de l&apos;événement New Relic
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `container_cpu_cfs_periods_total`
          </td>

          <td>
            `containerCpuCfsPeriodsTotal`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Compteur :**

             Nombre total d&apos;intervalles de période d&apos;application écoulés.
          </td>
        </tr>

        <tr>
          <td>
            `container_cpu_cfs_throttled_periods_total`
          </td>

          <td>
            `containerCpuCfsThrottledPeriodsTotal`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Compteur :**

             nombre total d&apos;intervalles de période limités.
          </td>
        </tr>

        <tr>
          <td>
            `container_cpu_usage_seconds_total`
          </td>

          <td>
            `cpuUsedCores`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Compteur :**

             Temps CPU total consommé.
          </td>
        </tr>

        <tr>
          <td>
            `container_memory_working_set_bytes`
          </td>

          <td>
            `memoryWorkingSetBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             taille de l&apos;ensemble de travail de la mémoire en octets.
          </td>
        </tr>

        <tr>
          <td>
            `container_network_receive_bytes_total`
          </td>

          <td>
            `net.rxBytesPerSecond`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Compteur :**

             Nombre cumulé d&apos;octets reçus.
          </td>
        </tr>

        <tr>
          <td>
            `container_network_receive_errors_total`
          </td>

          <td>
            `net.txBytesPerSecond`
          </td>

          <td>
            `memoryRequestedBytes`
          </td>

          <td>
            **Compteur :**

             nombre cumulé d&apos;erreurs de réception rencontrées.
          </td>
        </tr>

        <tr>
          <td>
            `container_network_transmit_bytes_total`
          </td>

          <td>
            `net.errorsPerSecond`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Compteur :**

             Nombre cumulé d&apos;octets transmis.
          </td>
        </tr>

        <tr>
          <td>
            `container_network_transmit_errors_total`
          </td>

          <td>
            `net.errorsPerSecond`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Compteur :**

             nombre cumulé d’erreurs de transmission rencontrées.
          </td>
        </tr>

        <tr>
          <td>
            `container_spec_memory_limit_bytes`
          </td>

          <td>
            `memoryLimitBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             Limite de mémoire du conteneur en octets.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-controller-manager" title="Pour le gestionnaire du contrôleur">
    Le tableau suivant mappe les métriques Kubernetes OpenTelemetry aux métriques New Relic Kubernetes. Ces métriques proviennent du `controller manager` configuré avec le `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Métrique OTel
          </th>

          <th>
            Métrique New Relic
          </th>

          <th>
            Nom de l&apos;événement New Relic
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `go_goroutines`
          </td>

          <td>
            `goGoroutines`
          </td>

          <td>
            `K8sControllerManagerSample`
          </td>

          <td>
            **Jauge :**

             nombre de 

            `goroutines`

             qui existent actuellement.
          </td>
        </tr>

        <tr>
          <td>
            `process_resident_memory_bytes`
          </td>

          <td>
            `processResidentMemoryBytes`
          </td>

          <td>
            `K8sControllerManagerSample`
          </td>

          <td>
            **Jauge :**

             taille de la mémoire résidente en octets.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-kubelet" title="Pour kubelet">
    Le tableau suivant mappe les métriques Kubernetes OpenTelemetry aux métriques New Relic Kubernetes. Ces métriques proviennent du `kubelet` configuré avec le `KubeletStats Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "150px" }}>
            Métrique OTel
          </th>

          <th>
            Métrique New Relic
          </th>

          <th>
            Nom de l&apos;événement New Relic
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `container.cpu.utilization`
          </td>

          <td>
            `cpuCoresUtilization`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             pourcentage d&apos;utilisation du processeur du conteneur.
          </td>
        </tr>

        <tr>
          <td>
            `container.filesystem.capacity`
          </td>

          <td>
            `fsCapacityBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             capacité totale du système de fichiers pour le conteneur.
          </td>
        </tr>

        <tr>
          <td>
            `container.filesystem.usage`
          </td>

          <td>
            `fsUsedBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             espace du système de fichiers utilisé pour le conteneur.
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.usage`
          </td>

          <td>
            `memoryUsedBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             utilisation totale de la mémoire du conteneur.
          </td>
        </tr>

        <tr>
          <td>
            `go_goroutines`
          </td>

          <td>
            `goGoroutines`
          </td>

          <td>
            `K8sEtcdSample`
          </td>

          <td>
            **Jauge :**

             nombre de 

            `goroutines`

             qui existent actuellement.
          </td>
        </tr>

        <tr>
          <td>
            `go_threads`
          </td>

          <td>
            `goThreads`
          </td>

          <td>
            `K8sApiServerSample`

            , 

            `K8sControllerManagerSample`

            , 

            `K8sEtcdSample`

            , 

            `K8sSchedulerSample`
          </td>

          <td>
            **Jauge :**

             nombre de threads du système d&apos;exploitation créés.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.cpu.time`
          </td>

          <td>
            `cpuUsedCoreMilliseconds`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Jauge :**

             temps CPU total utilisé par le nœud.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.cpu.utilization`
          </td>

          <td>
            `allocatableCpuCoresUtilization`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Jauge :**

             pourcentage d&apos;utilisation du processeur du nœud.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.filesystem.capacity`
          </td>

          <td>
            `fsCapacityBytes`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Jauge :**

             capacité totale du système de fichiers pour le nœud.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.filesystem.usage`
          </td>

          <td>
            `fsUsedBytes`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Jauge :**

             espace du système de fichiers utilisé pour le nœud.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.memory.available`
          </td>

          <td>
            `memoryAvailableBytes`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Jauge :**

             mémoire disponible pour le nœud.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.memory.working_set`
          </td>

          <td>
            `memoryWorkingSetBytes`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Jauge :**

             taille de l&apos;ensemble de travail de la mémoire du nœud.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.pod.filesystem.available`
          </td>

          <td>
            `fsAvailableBytes`
          </td>

          <td>
            `K8sVolumeSample`
          </td>

          <td>
            **Jauge :**

             espace disponible dans le système de fichiers pour le pod.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.pod.filesystem.capacity`
          </td>

          <td>
            `fsCapacityBytes`
          </td>

          <td>
            `K8sVolumeSample`
          </td>

          <td>
            **Jauge :**

             capacité totale du système de fichiers pour le pod.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.pod.filesystem.usage`
          </td>

          <td>
            `fsUsedBytes`
          </td>

          <td>
            `K8sVolumeSample`
          </td>

          <td>
            **Jauge :**

             espace du système de fichiers utilisé pour le pod.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.pod.memory.working_set`
          </td>

          <td>
            `memoryWorkingSetBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             taille de l&apos;ensemble de travail de la mémoire du pod.
          </td>
        </tr>
      </tbody>
    </table>

    Le tableau suivant mappe les métriques Kubernetes OpenTelemetry aux métriques New Relic Kubernetes. Ces métriques proviennent du `kubelet` configuré avec le `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Métrique OTel
          </th>

          <th>
            Métrique New Relic
          </th>

          <th>
            Nom de l&apos;événement New Relic
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `process_resident_memory_bytes`
          </td>

          <td>
            `processResidentMemoryBytes`
          </td>

          <td>
            `K8sApiServerSample`
          </td>

          <td>
            **Jauge :**

             taille de la mémoire résidente en octets.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-kube-state-metrics" title="Pour les métriques d'état du kube">
    Le tableau suivant mappe les métriques Kubernetes OpenTelemetry aux métriques New Relic Kubernetes. Ces métriques proviennent du `kubeStateMetrics` configuré avec le `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Métrique OTel
          </th>

          <th>
            Métrique New Relic
          </th>

          <th>
            Nom de l&apos;événement New Relic
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `kube_cronjob_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sCronjobSample`
          </td>

          <td>
            **Jauge :**

             Horaire de création du CronJob.
          </td>
        </tr>

        <tr>
          <td>
            `kube_cronjob_spec_suspend`
          </td>

          <td>
            `isSuspended`
          </td>

          <td>
            `K8sCronjobSample`
          </td>

          <td>
            **Jauge :**

             indicateur de suspension du CronJob.
          </td>
        </tr>

        <tr>
          <td>
            `kube_cronjob_status_active`
          </td>

          <td>
            `isActive`
          </td>

          <td>
            `K8sCronjobSample`
          </td>

          <td>
            **Jauge :**

             nombre d&apos;instances CronJob actives.
          </td>
        </tr>

        <tr>
          <td>
            `kube_cronjob_status_last_schedule_time`
          </td>

          <td>
            `lastScheduledTime`
          </td>

          <td>
            `K8sCronjobSample`
          </td>

          <td>
            **Jauge :**

             dernière heure planifiée du CronJob.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Jauge :**

             Horodatage de création du DaemonSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_desired_number_scheduled`
          </td>

          <td>
            `podsScheduled`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Jauge :**

             nombre souhaité d&apos;instances DaemonSet planifiées.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_number_misscheduled`
          </td>

          <td>
            `podsMisscheduled`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Jauge :**

             nombre d&apos;instances DaemonSet mal planifiées.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_number_ready`
          </td>

          <td>
            `podsReady`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Jauge :**

             nombre d&apos;instances DaemonSet prêtes.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_number_unavailable`
          </td>

          <td>
            `podsUnavailable`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Jauge :**

             nombre d&apos;instances DaemonSet indisponibles.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_updated_number_scheduled`
          </td>

          <td>
            `podsUpdatedScheduled`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Jauge :**

             nombre mis à jour d&apos;instances DaemonSet planifiées.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Jauge :**

             Horodatage de création du déploiement.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_metadata_generation`
          </td>

          <td>
            `metadataGeneration`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Jauge :**

             numéro de génération des métadonnées de déploiement.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_spec_replicas`
          </td>

          <td>
            `podsDesired`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Jauge :**

             nombre de répliques souhaitées pour le déploiement.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_spec_strategy_rollingupdate_max_surge`
          </td>

          <td>
            `rollingUpdateMaxPodsSurge`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Jauge :**

             surtension maximale autorisée lors de la mise à jour continue.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_condition`
          </td>

          <td>
            `conditionAvailable`

            , 

            `conditionProgressing`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Jauge :**

             Conditions d&apos;état de déploiement.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_observed_generation`
          </td>

          <td>
            `observedGeneration`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Jauge :**

             La génération la plus récente observée pour ce déploiement.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas`
          </td>

          <td>
            `podsTotal`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Jauge :**

             Nombre de répliques pour le déploiement.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas_available`
          </td>

          <td>
            `podsAvailable`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Jauge :**

             nombre de répliques disponibles pour le déploiement.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas_ready`
          </td>

          <td>
            `podsReady`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Jauge :**

             nombre de répliques prêtes pour le déploiement.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas_unavailable`
          </td>

          <td>
            `podsUnavailable`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Jauge :**

             nombre de répliques indisponibles pour le déploiement.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas_updated`
          </td>

          <td>
            `podsUpdated`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Jauge :**

             nombre de répliques mises à jour pour le déploiement.
          </td>
        </tr>

        <tr>
          <td>
            `kube_horizontalpodautoscaler_spec_min_replicas`
          </td>

          <td>
            `minReplicas`
          </td>

          <td>
            `K8sHpaSample`
          </td>

          <td>
            **Jauge :**

             nombre minimum de répliques pour HorizontalPodAutoscaler.
          </td>
        </tr>

        <tr>
          <td>
            `kube_horizontalpodautoscaler_status_condition`
          </td>

          <td>
            `isActive`
          </td>

          <td>
            `K8sHpaSample`
          </td>

          <td>
            **Jauge :**

             conditions d&apos;état de l&apos;HorizontalPodAutoscaler.
          </td>
        </tr>

        <tr>
          <td>
            `kube_horizontalpodautoscaler_status_current_replicas`
          </td>

          <td>
            `currentReplicas`
          </td>

          <td>
            `K8sHpaSample`
          </td>

          <td>
            **Jauge :**

             nombre actuel de répliques pour HorizontalPodAutoscaler.
          </td>
        </tr>

        <tr>
          <td>
            `kube_horizontalpodautoscaler_status_desired_replicas`
          </td>

          <td>
            `desiredReplicas`
          </td>

          <td>
            `K8sHpaSample`
          </td>

          <td>
            **Jauge :**

             nombre souhaité de répliques pour HorizontalPodAutoscaler.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_complete`
          </td>

          <td>
            `isComplete`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Jauge :**

             si le travail est terminé 

            `(1)`

             ou non 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Jauge :**

             Horodatage de création du Job.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_failed`
          </td>

          <td>
            `failed`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Jauge :**

             si le travail a échoué 

            `(1)`

             ou non 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_spec_active_deadline_seconds`
          </td>

          <td>
            `specActiveDeadlineSeconds`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Jauge :**

             nombre de secondes pendant lesquelles le travail peut s&apos;exécuter avant d&apos;être terminé.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_spec_completions`
          </td>

          <td>
            `specCompletions`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Jauge :**

             nombre souhaité de pods terminés avec succès pour le travail.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_spec_parallelism`
          </td>

          <td>
            `specParallelism`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Jauge :**

             nombre maximal souhaité de pods exécutés en parallèle pour le travail.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_active`
          </td>

          <td>
            `activePods`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Jauge :**

             Nombre de pods actifs pour le Job.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_completion_time`
          </td>

          <td>
            `completedAt`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Jauge :**

             Temps d&apos;achèvement du travail.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_failed`
          </td>

          <td>
            `failedPods`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Jauge :**

             nombre de pods ayant échoué pour le travail.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_start_time`
          </td>

          <td>
            `startedAt`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Jauge :**

             Heure de début du travail.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_succeeded`
          </td>

          <td>
            `succeededPods`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Jauge :**

             nombre de pods réussis pour le travail.
          </td>
        </tr>

        <tr>
          <td>
            `kube_node_status_allocatable`
          </td>

          <td>
            `memoryWorkingSetUtilization`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             Ressources allouables du nœud.
          </td>
        </tr>

        <tr>
          <td>
            `kube_node_status_condition`
          </td>

          <td>
            `condition.CONDITION_NAME=CONDITION_VALUE`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Jauge :**

             État de l&apos;état du nœud.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolume_capacity_bytes`
          </td>

          <td>
            `capacityBytes`
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Jauge :**

             Capacité du PersistentVolume en octets.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolume_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Jauge :**

             Horodatage de création du PersistentVolume.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolume_info`
          </td>

          <td />

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Jauge :**

             informations sur le PersistentVolume.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolume_status_phase`
          </td>

          <td>
            `statusPhase`
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Jauge :**

             Phase du PersistentVolume.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolumeclaim_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Jauge :**

             horodatage de création du PersistentVolumeClaim.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolumeclaim_info`
          </td>

          <td>
            Tous les attributs décrivant le volume
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Jauge :**

             informations sur le PersistentVolumeClaim.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolumeclaim_resource_requests_storage_bytes`
          </td>

          <td>
            `requestedStorageBytes`
          </td>

          <td>
            `K8sPersistentVolumeClaimSample`
          </td>

          <td>
            **Jauge :**

             requests de ressources de stockage du PersistentVolumeClaim en octets.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolumeclaim_status_phase`
          </td>

          <td>
            `statusPhase`
          </td>

          <td>
            `K8sPersistentVolumeClaimSample`
          </td>

          <td>
            **Jauge :**

             Phase du PersistentVolumeClaim.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_resource_limits`
          </td>

          <td>
            `cpuLimitCores`

            , 

            `memoryLimitBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             Limites de ressources du conteneur pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_resource_requests`
          </td>

          <td>
            `cpuRequestedCores`

            , 

            `memoryRequestedBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             requests de ressources du conteneur pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_status_phase`
          </td>

          <td>
            `status`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             Phase actuelle du conteneur pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_status_ready`
          </td>

          <td>
            `isReady`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             Si le conteneur de pod est prêt 

            `(1)`

             ou non 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_status_restarts_total`
          </td>

          <td>
            `restartCount`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Compteur :**

             Nombre total de redémarrages pour le conteneur pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_status_waiting_reason`
          </td>

          <td>
            `reason`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Jauge :**

             Raison de l&apos;état d&apos;attente du conteneur.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Jauge :**

             Horodatage de création du pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_info`
          </td>

          <td>
            Tous les attributs décrivant le pod
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Jauge :**

             Informations sur le pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_phase`
          </td>

          <td>
            `status`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Jauge :**

             Phase actuelle de l&apos;état du pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_ready`
          </td>

          <td>
            `isReady`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Jauge :**

             Si le pod est prêt 

            `(1)`

             ou non 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_ready_time`
          </td>

          <td>
            `startTime`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Jauge :**

             Heure à laquelle l&apos;état du pod est devenu prêt.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_scheduled`
          </td>

          <td>
            `isScheduled`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Jauge :**

             si le pod est planifié 

            `(1)`

             ou non 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_scheduled_time`
          </td>

          <td />

          <td />

          <td>
            **Jauge :**

             Heure à laquelle le pod est devenu programmé.
          </td>
        </tr>

        <tr>
          <td>
            `kube_resourcequota`
          </td>

          <td />

          <td>
            Exemple de quota de ressources K8s
          </td>

          <td>
            **Jauge :**

             l&apos;utilisation actuelle et la limite stricte d&apos;une ressource définie dans un ResourceQuota.
          </td>
        </tr>

        <tr>
          <td>
            `kube_resourcequota_created`
          </td>

          <td />

          <td>
            Exemple de quota de ressources K8s
          </td>

          <td>
            **Jauge :**

             Horaire de création du ResourceQuota.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_annotations`
          </td>

          <td>
            `selector.ANNOTATIONS`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Jauge :**

             Annotations appliquées au Service.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Jauge :**

             Horaire de création du Service.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_info`
          </td>

          <td>
            Tous les attributs décrivant le Service
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Jauge :**

             Informations sur le Service.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_labels`
          </td>

          <td>
            `label.LABEL_NAME`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Jauge :**

             Étiquettes appliquées au Service.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_spec_type`
          </td>

          <td>
            `specType`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Jauge :**

             Type de spécification de service.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_status_load_balancer_ingress`
          </td>

          <td>
            filtre avec 

            `WHERE specType = 'LoadBalancer'`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Jauge :**

             état de l&apos;entrée de l&apos;équilibreur de charge pour le service.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Jauge :**

             horodatage de création du StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_persistentvolumeclaim_retention_policy`
          </td>

          <td>
            `filter with WHERE persistent = 'true'`
          </td>

          <td>
            `K8sVolumeSample`
          </td>

          <td>
            **Jauge :**

             politique de conservation des PersistentVolumeClaims pour le StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_replicas`
          </td>

          <td>
            `podsDesired`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Jauge :**

             nombre souhaité de répliques pour le StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_current_revision`
          </td>

          <td>
            `currentRevision`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Jauge :**

             révision actuelle du StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas`
          </td>

          <td>
            `podsTotal`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Jauge :**

             nombre de répliques pour le StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas_available`
          </td>

          <td>
            `podsTotal - podsCurrent`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Jauge :**

             nombre de répliques disponibles pour le StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas_current`
          </td>

          <td>
            `podsCurrent`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Jauge :**

             nombre de répliques actuelles pour le StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas_ready`
          </td>

          <td>
            `podsReady`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Jauge :**

             nombre de répliques prêtes pour le StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas_updated`
          </td>

          <td>
            `podsUpdated`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Jauge :**

             nombre de répliques mises à jour pour le StatefulSet.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="k8s-otel" title="Pour le nœud">
    Le tableau suivant mappe les métriques Kubernetes OpenTelemetry aux métriques New Relic Kubernetes. Ces métriques proviennent du `node` configuré avec le `HostMetric Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "100px" }}>
            Métrique OTel
          </th>

          <th>
            Métrique New Relic
          </th>

          <th>
            Nom de l&apos;événement New Relic
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `process.cpu.utilization`
          </td>

          <td>
            `cpuPercent`
          </td>

          <td>
            `ProcessSample`
          </td>

          <td>
            **Jauge :**

             utilisation du processeur du processus en pourcentage.
          </td>
        </tr>

        <tr>
          <td>
            `process.disk.io`
          </td>

          <td>
            `ioTotalReadCount+ioTotalWriteCount`
          </td>

          <td>
            `ProcessSample`
          </td>

          <td>
            **Compteur :**

             nombre d’opérations I/O de disque effectuées par le processus.
          </td>
        </tr>

        <tr>
          <td>
            `process.memory.usage`
          </td>

          <td>
            `memoryResidentSizeBytes`
          </td>

          <td>
            `ProcessSample`
          </td>

          <td>
            **Jauge :**

             Utilisation de la mémoire du processus en octets.
          </td>
        </tr>

        <tr>
          <td>
            `process.memory.virtual`
          </td>

          <td>
            `memoryVirtualSizeBytes`
          </td>

          <td>
            `ProcessSample`
          </td>

          <td>
            **Jauge :**

             Utilisation de la mémoire virtuelle du processus en octets.
          </td>
        </tr>

        <tr>
          <td>
            `system.cpu.load_average.15m`
          </td>

          <td>
            `loadAverageFifteenMinute`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Jauge :**

             charge moyenne du système au cours des 15 dernières minutes.
          </td>
        </tr>

        <tr>
          <td>
            `system.cpu.load_average.1m`
          </td>

          <td>
            `loadAverageOneMinute`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Jauge :**

             charge moyenne du système au cours de la dernière minute.
          </td>
        </tr>

        <tr>
          <td>
            `system.cpu.load_average.5m`
          </td>

          <td>
            `loadAverageFiveMinute`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Jauge :**

             charge moyenne du système au cours des 5 dernières minutes.
          </td>
        </tr>

        <tr>
          <td>
            `system.cpu.utilization`
          </td>

          <td>
            `cpuPercent`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Jauge :**

             pourcentage d&apos;utilisation totale du processeur.
          </td>
        </tr>

        <tr>
          <td>
            `system.disk.io`
          </td>

          <td>
            `readBytesPerSecond+writeBytesPerSecond`
          </td>

          <td>
            `StorageSample`
          </td>

          <td>
            **Compteur :**

             nombre d&apos;opérations I/O de disque effectuées.
          </td>
        </tr>

        <tr>
          <td>
            `system.disk.io_time`
          </td>

          <td>
            `diskReadsPerSecond+diskWritesPerSecond`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Compteur :**

             temps passé dans les opérations I/O sur disque en secondes.
          </td>
        </tr>

        <tr>
          <td>
            `system.disk.operation_time`
          </td>

          <td>
            `diskWriteUtilizationPercent`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Compteur :**

             Temps total passé dans les opérations sur le disque en secondes.
          </td>
        </tr>

        <tr>
          <td>
            `system.disk.operations`
          </td>

          <td>
            `readIoPerSecond`
          </td>

          <td>
            `StorageSample`
          </td>

          <td>
            **Compteur :**

             Nombre d&apos;opérations de disque effectuées.
          </td>
        </tr>

        <tr>
          <td>
            `system.filesystem.usage`
          </td>

          <td>
            `diskUsedBytes`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Jauge :**

             utilisation de l&apos;espace du système de fichiers en octets.
          </td>
        </tr>

        <tr>
          <td>
            `system.filesystem.utilization`
          </td>

          <td>
            `diskUsedPercent`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Jauge :**

             Utilisation du système de fichiers en pourcentage.
          </td>
        </tr>

        <tr>
          <td>
            `system.memory.usage`
          </td>

          <td>
            `memoryUsedBytes`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Jauge :**

             utilisation totale de la mémoire en octets.
          </td>
        </tr>

        <tr>
          <td>
            `system.memory.utilization`
          </td>

          <td>
            `memoryUsedPercent`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Jauge :**

             utilisation de la mémoire en pourcentage.
          </td>
        </tr>

        <tr>
          <td>
            `system.network.errors`
          </td>

          <td>
            `transmitErrorsPerSecond`
          </td>

          <td>
            `NetworkSample`
          </td>

          <td>
            **Compteur :**

             Nombre d&apos;erreurs réseau.
          </td>
        </tr>

        <tr>
          <td>
            `system.network.io`
          </td>

          <td>
            `receiveBytesPerSecond`

            , 

            `transmitBytesPerSecond`
          </td>

          <td>
            `NetworkSample`
          </td>

          <td>
            **Compteur :**

             Nombre d&apos;opérations I/O réseau.
          </td>
        </tr>

        <tr>
          <td>
            `system.network.packets`
          </td>

          <td>
            `transmitPacketsPerSecond+receivePacketsPerSecond`
          </td>

          <td>
            `NetworkSample`
          </td>

          <td>
            **Compteur :**

             Nombre de paquets réseau transmis et reçus.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-scheduler" title="Pour le planificateur">
    Le tableau suivant mappe les métriques Kubernetes OpenTelemetry aux métriques New Relic Kubernetes. Ces métriques proviennent du `scheduler` configuré avec le `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "100px" }}>
            Métrique OTel
          </th>

          <th>
            Métrique New Relic
          </th>

          <th>
            Nom de l&apos;événement New Relic
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `go_goroutines`
          </td>

          <td>
            `goGoroutines`
          </td>

          <td>
            `K8sSchedulerSample`
          </td>

          <td>
            **Jauge :**

             nombre de 

            `goroutines`

             qui existent actuellement.
          </td>
        </tr>

        <tr>
          <td>
            `process_resident_memory_bytes`
          </td>

          <td>
            `processResidentMemoryBytes`
          </td>

          <td>
            `K8sSchedulerSample`
          </td>

          <td>
            **Jauge :**

             taille de la mémoire résidente en octets.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>