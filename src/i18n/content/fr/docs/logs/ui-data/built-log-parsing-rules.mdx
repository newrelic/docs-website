---
title: Règles d'analyse des logintégrées
tags:
  - Logs
  - Log management
  - UI and data
metaDescription: 'A list of all New Relic''s log parsing rules, which you can use to easily parse common log formats.'
freshnessValidatedDate: never
translationType: machine
---

New Relic peut analyser les formats log courants selon des règles intégrées, de sorte que vous n&apos;avez pas besoin de créer vos propres règles d&apos;analyse. Voici les règles d&apos;analyse des log , leurs modèles [Grok](https://github.com/thekrakken/java-grok/tree/master/src/main/resources/patterns) et les champs analysés.

* Pour activer l&apos;analyse intégrée des log , consultez notre documentation pour [ajouter l&apos;attribut `logtype` ](/docs/logs/ui-data/parsing#logtype).
* Pour gérer vos règles d&apos;analyse par programmation, utilisez NerdGraph, notre API au format GraphQL, sur [api.newrelic.com/graphiql](https://api.newrelic.com/graphiql). Pour plus d&apos;informations, consultez le [didacticiel NerdGraph](/docs/apis/nerdgraph/examples/nerdgraph-log-parsing-rules-tutorial) pour créer, interroger et supprimer vos règles d&apos;analyse.

<CollapserGroup>
  <Collapser id="apache" title="Apache">
    <DNT>**Source:**</DNT> `logtype = 'apache'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `clientip`: L&apos;adresse IP du client.
    * `verb`:Le verbe HTTP
    * `ident`: L&apos;identité de l&apos;utilisateur du client effectuant la demande
    * `response`: Le code d&apos;état HTTP de la réponse
    * `request`: L&apos;URI et la demande en cours
    * `httpversion`:La version HTTP de la requête
    * `rawrequest`:La requête HTTP brute si les données sont publiées
    * `bytes`: Le nombre d&apos;octets envoyés
    * `referrer`: Le référent HTTP
    * `agent`: L&apos;agent utilisateur du client
  </Collapser>

  <Collapser id="apache_error" title="Erreur Apache">
    <DNT>**Source:**</DNT> `logtype = 'apache_error'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    \[%{DATA:apache_error.timestamp}\] \[%{WORD:apache_error.source}:%{DATA:level}\] \[pid %{NUMBER:apache_error.pid}(:tid %{NUMBER:apache_error.tid})?\] (%{DATA:apache_error.sourcecode}\(%{NUMBER:apache_error.linenum}\): )?(?:\[client %{IPORHOST:apache_error.clientip}:%{POSINT:apache_error.port}\] ){0,1}%{GREEDYDATA:apache_error.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `apache_error.timestamp`: L&apos;horodatage de l&apos;instruction log
    * `apache_error.source`: Le module source
    * `level`: Le niveau de log
    * `apache_error.pid`:Le PID d&apos;Apache (identifiant de processus)
    * `apache_error.tid`: L&apos;identifiant de thread (TID) d&apos;Apache
    * `apache_error.sourcecode`: Le code source d&apos;Apache
    * `apache_error.linenum`: Le numéro de ligne du code source
    * `apache_error.clientip`: L&apos;adresse IP du client
    * `apache_error.port`: Le numéro de port IP du client
    * `apache_error.message`:Le message d&apos;erreur
  </Collapser>

  <Collapser id="application-load-balancer" title="Équilibreur de charge d'application">
    <DNT>**Source:**</DNT> `logtype = 'alb'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} "%{DATA:request}" "%{DATA:user_agent}" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} "%{DATA:trace_id}" "%{NOTSPACE:domain_name}" "%{NOTSPACE:chosen_cert_arn}" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} "%{NOTSPACE:actions_executed}" "%{NOTSPACE:redirect_url}" "%{NOTSPACE:error_reason}" (?:"|)%{DATA:target_port_list}(?:"|) (?:"|)%{DATA:target_status_code_list}(?:"|) "%{NOTSPACE:classification}" "%{NOTSPACE:classification_reason}"
    ```

    <DNT>
      **Results:**
    </DNT>

    <table>
      <thead>
        <tr>
          <th style={{ width: "250px" }}>
            Champ
          </th>

          <th>
            Définition
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `type`
          </td>

          <td>
            Le type de demande ou de connexion. Les valeurs possibles sont :

            * `http`: HTTP
            * `https`: HTTP sur SSL/TLS
            * `h2`: HTTP/2 sur SSL/TLS
            * `ws`: WebSockets
            * `wss`: WebSockets sur SSL/TLS
          </td>
        </tr>

        <tr>
          <td>
            `elb`
          </td>

          <td>
            L&apos;ID de ressource de l&apos;équilibreur de charge. Si vous analysez les entrées log d&apos;accès, notez que les ID de ressources peuvent contenir des barres obliques (`/`).
          </td>
        </tr>

        <tr>
          <td>
            `client_ip`
          </td>

          <td>
            L&apos;adresse IP du client demandeur
          </td>
        </tr>

        <tr>
          <td>
            `client_port`
          </td>

          <td>
            Le port IP du client demandeur
          </td>
        </tr>

        <tr>
          <td>
            `target_ip`
          </td>

          <td>
            L&apos;adresse IP de la cible qui a traité cette demande.

            * Si le client n&apos;a pas envoyé de demande complète, l&apos;équilibreur de charge ne peut pas envoyer la demande à une cible et cette valeur est définie sur `-`.
            * Si la cible est une fonction Lambda, cette valeur est définie sur `-`.
            * Si la demande est bloquée par AWS WAF, cette valeur est définie sur `-` et la valeur de `elb_status_code` est définie sur `403`.
          </td>
        </tr>

        <tr>
          <td>
            `target_port`
          </td>

          <td>
            Le port IP de la cible qui a traité cette demande.

            * Si le client n&apos;a pas envoyé de demande complète, l&apos;équilibreur de charge ne peut pas envoyer la demande à une cible et cette valeur est définie sur `-`.
            * Si la cible est une fonction Lambda, cette valeur est définie sur `-`.
            * Si la demande est bloquée par AWS WAF, cette valeur est définie sur `-` et la valeur de `elb_status_code` est définie sur `403`.
          </td>
        </tr>

        <tr>
          <td>
            `target_port_list`
          </td>

          <td>
            L&apos;adresse IP et le port de la cible qui a traité cette demande.

            * Si le client n&apos;a pas envoyé de demande complète, l&apos;équilibreur de charge ne peut pas envoyer la demande à une cible et cette valeur est définie sur `-`.
            * Si la cible est une fonction Lambda, cette valeur est définie sur `-`.
            * Si la demande est bloquée par AWS WAF, cette valeur est définie sur `-` et la valeur de `elb_status_code` est définie sur `403`.
          </td>
        </tr>

        <tr>
          <td>
            `request_processing_time`
          </td>

          <td>
            Le temps total écoulé (en secondes, avec une précision de l&apos;ordre de la milliseconde) depuis le moment où l&apos;équilibreur de charge a reçu la demande jusqu&apos;au moment où il l&apos;a envoyée à une cible.

            * Cette valeur est définie sur `-1` si l&apos;équilibreur de charge ne peut pas envoyer la requête à une cible. Cela peut se produire si la cible ferme la connexion avant l&apos;expiration du délai d&apos;inactivité ou si le client envoie une demande mal formée.
            * Cette valeur peut également être définie sur `-1` si la cible enregistrée ne répond pas avant le délai d&apos;inactivité.
          </td>
        </tr>

        <tr>
          <td>
            `target_processing_time`
          </td>

          <td>
            Le temps total écoulé (en secondes, avec une précision de l&apos;ordre de la milliseconde) depuis le moment où l&apos;équilibreur de charge a envoyé la demande à une cible jusqu&apos;à ce que la cible commence à envoyer les en-têtes de réponse.

            * Cette valeur est définie sur `-1` si l&apos;équilibreur de charge ne peut pas envoyer la requête à une cible. Cela peut se produire si la cible ferme la connexion avant l&apos;expiration du délai d&apos;inactivité ou si le client envoie une demande mal formée.
            * Cette valeur peut également être définie sur `-1` si la cible enregistrée ne répond pas avant le délai d&apos;inactivité.
          </td>
        </tr>

        <tr>
          <td>
            `response_processing_time`
          </td>

          <td>
            Le temps total écoulé (en secondes, avec une précision de l&apos;ordre de la milliseconde) depuis le moment où l&apos;équilibreur de charge a reçu l&apos;en-tête de réponse de la cible jusqu&apos;à ce qu&apos;il commence à envoyer la réponse au client. Cela inclut à la fois le temps de mise en file d&apos;attente au niveau de l&apos;équilibreur de charge et le temps d&apos;acquisition de la connexion de l&apos;équilibreur de charge au client.

            Cette valeur est définie sur `-1` si l&apos;équilibreur de charge ne peut pas envoyer la requête à une cible. Cela peut se produire si la cible ferme la connexion avant l&apos;expiration du délai d&apos;inactivité ou si le client envoie une demande mal formée.
          </td>
        </tr>

        <tr>
          <td>
            `elb_status_code`
          </td>

          <td>
            Le code d&apos;état de la réponse de l&apos;équilibreur de charge
          </td>
        </tr>

        <tr>
          <td>
            `target_status_code_list`
          </td>

          <td>
            Le code d&apos;état de la réponse de la cible. Cette valeur est enregistrée uniquement si une connexion a été établie avec la cible et que la cible a envoyé une réponse. Sinon, il est défini sur `-`.
          </td>
        </tr>

        <tr>
          <td>
            `received_bytes`
          </td>

          <td>
            La taille de la requête, en octets, reçue du client (demandeur). Pour requests HTTP, cela inclut les en-têtes. Pour les WebSockets, il s’agit du nombre total d’octets reçus du client sur la connexion.
          </td>
        </tr>

        <tr>
          <td>
            `sent_bytes`
          </td>

          <td>
            La taille de la réponse, en octets, envoyée au client (demandeur). Pour requests HTTP, cela inclut les en-têtes. Pour les WebSockets, il s&apos;agit du nombre total d&apos;octets envoyés au client sur la connexion.
          </td>
        </tr>

        <tr>
          <td>
            `request`
          </td>

          <td>
            La requête HTTP
          </td>
        </tr>

        <tr>
          <td>
            `user_agent`
          </td>

          <td>
            Chaîne d&apos;agent utilisateur qui identifie le client à l&apos;origine de la demande, entourée de guillemets. La chaîne se compose d&apos;un ou plusieurs identifiants de produit, produit/version. Si la chaîne est plus longue que 8 Ko, elle est tronquée.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            Le chiffrement SSL. Cette valeur est définie sur `-` si l&apos;écouteur n&apos;est pas un écouteur HTTPS.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            Le protocole SSL. Cette valeur est définie sur `-` si l&apos;écouteur n&apos;est pas un écouteur HTTPS.
          </td>
        </tr>

        <tr>
          <td>
            `target_group_arn`
          </td>

          <td>
            Le nom de ressource Amazon (ARN) du groupe cible
          </td>
        </tr>

        <tr>
          <td>
            `trace_id`
          </td>

          <td>
            Le contenu du `X-Amzn-Trace-Id header`, entre guillemets
          </td>
        </tr>

        <tr>
          <td>
            `domain_name`
          </td>

          <td>
            Le domaine SNI fourni par le client lors de la négociation TLS, placé entre guillemets. Cette valeur est définie sur `-` si le client ne prend pas en charge SNI ou si le domaine ne correspond pas à un certificat et le certificat par défaut est présenté au client.
          </td>
        </tr>

        <tr>
          <td>
            `chosen_cert_arn`
          </td>

          <td>
            L&apos;ARN du certificat présenté au client, entre guillemets.

            * Définissez sur `session-reused` si la session est réutilisée.
            * Définissez sur `-` si l&apos;écouteur n&apos;est pas un écouteur HTTPS.
          </td>
        </tr>

        <tr>
          <td>
            `matched_rule_priority`
          </td>

          <td>
            La valeur de priorité de la règle qui correspond à la demande.

            * Si une règle correspond, il s&apos;agit d&apos;une valeur comprise entre `1` et `50000`.
            * Si aucune règle ne correspond et que l&apos;action par défaut a été effectuée, cette valeur est définie sur `0`.
            * Si une erreur se produit lors de l’évaluation des règles, elle est définie sur `-1`.
            * Pour toute autre erreur, il est défini sur `-`.
          </td>
        </tr>

        <tr>
          <td>
            `request_creation_time`
          </td>

          <td>
            L&apos;heure à laquelle l&apos;équilibreur de charge a reçu la demande du client, au format ISO 8601.
          </td>
        </tr>

        <tr>
          <td>
            `actions_executed`
          </td>

          <td>
            Les actions entreprises lors du traitement de la demande, entre guillemets. Cette valeur est une liste séparée par des virgules qui peut inclure les valeurs décrites dans `actions_taken`. Si aucune action n&apos;a été entreprise, comme dans le cas d&apos;une demande mal formée, cette valeur est définie sur `-`.
          </td>
        </tr>

        <tr>
          <td>
            `redirect_url`
          </td>

          <td>
            L&apos;URL de la cible de redirection pour l&apos;en-tête d&apos;emplacement de la réponse HTTP, entourée de guillemets doubles. Si aucune action de redirection n&apos;a été effectuée, cette valeur est définie sur `-`.
          </td>
        </tr>

        <tr>
          <td>
            `error_reason`
          </td>

          <td>
            Le code de raison de l&apos;erreur, placé entre guillemets.

            * Si la demande a échoué, il s’agit de l’un des codes d’erreur décrits dans Codes de raison d’erreur.
            * Si les actions entreprises n&apos;incluent pas d&apos;action d&apos;authentification ou si la cible n&apos;est pas une fonction Lambda, cette valeur est définie sur `-`.
          </td>
        </tr>

        <tr>
          <td>
            `classification`
          </td>

          <td>
            Classification.
          </td>
        </tr>

        <tr>
          <td>
            `classification_reason`
          </td>

          <td>
            La raison de la classification.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="cassandra" title="Cassandre">
    Source: `logtype = 'cassandra'`

    Grok

    ```grok
    %{WORD:level}%{SPACE}\\[%{NOTSPACE:cassandra.thread}\\] %{TIMESTAMP_ISO8601:cassandra.timestamp} %{NOTSPACE:cassandra.source}:%{INT:cassandra.line.number} - %{GREEDYDATA:cassandra.message}
    ```

    ### Résultats

    * `level`: Le niveau de log du message (all, trace, debug, info, warn, error, off)
    * `cassandra.thread`: Le nom du thread émettant l&apos;instruction log
    * `cassandra.timestamp`: L&apos;horodatage de l&apos;instruction log
    * `cassandra.source`: Le nom du fichier source
    * `cassandra.line.number`: Le numéro de ligne du message
    * `cassandra.message`:Le message brut de Cassandre
  </Collapser>

  <Collapser id="cloudfront" title="CloudFront (log standard)">
    <DNT>**Source:**</DNT> `logtype = 'cloudfront-web'`

    <DNT>
      **Grok:**
    </DNT>

    ```
    ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end}
    ```

    <DNT>
      **Results:**
    </DNT>

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Champ
          </th>

          <th>
            Définition
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            L&apos;emplacement du bord qui a servi la requête. Chaque emplacement de bord est identifié par un code à trois lettres et un numéro attribué arbitrairement ; par exemple, `DFW3`.

            Le code à trois lettres correspond généralement au code d&apos;aéroport de l&apos;Association du transport aérien international pour un aéroport proche de l&apos;emplacement périphérique. (Ces abréviations pourraient changer à l&apos;avenir.)
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            Le nombre total d&apos;octets que CloudFront a servis au spectateur en réponse à la requête, y compris les en-têtes ; par exemple, `1045619`. Pour les connexions WebSocket, il s&apos;agit du nombre total d&apos;octets envoyés du serveur au client via la connexion.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            L&apos;adresse IP du spectateur qui a effectué la demande, au format IPv4 ou IPv6. Si le spectateur a utilisé un proxy HTTP ou un équilibreur de charge pour envoyer la requête, la valeur de `c_ip` est l&apos;adresse IP du proxy ou de l&apos;équilibreur de charge. Voir aussi `X-Forwarded-For`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            La méthode de requête HTTP : `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST` ou `PUT`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            Le nom de domaine de la distribution CloudFront ; par exemple, `d111111abcdef8.cloudfront.net`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            La partie de l&apos;URI qui identifie le chemin et l&apos;objet ; par exemple, `/images/cat.jpg`. Les points d’interrogation dans les URL et les chaînes de requête ne sont pas inclus.
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            Un code d’état HTTP ; par exemple, `200`. Le code d&apos;état `000` indique que le spectateur a fermé la connexion (par exemple, fermé l&apos;onglet du navigateur) avant que CloudFront puisse répondre à une demande. Si le visualiseur ferme la connexion après que CloudFront a commencé à envoyer la réponse, le log contient le code d&apos;état HTTP applicable.
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            Le nom du domaine à l&apos;origine de la demande. Les référents courants incluent les moteurs de recherche, d’autres sites Web qui renvoient directement vers vos objets et votre propre site Web.
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            La valeur de l&apos;en-tête utilisateur-Agent dans la requête. L&apos;en-tête utilisateur-Agent identifie la source de la demande, comme le type d&apos;appareil et de navigateur qui a soumis la demande, ainsi que le moteur de recherche, le cas échéant.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            La partie chaîne de requête de l&apos;URI, le cas échéant. Lorsqu&apos;un URI ne contient pas de chaîne de requête, la valeur de ce champ est un trait d&apos;union (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            L&apos;en-tête du cookie dans la demande, y compris les paires nom-valeur et l&apos;attribut associé.

            * Si vous activez le logging des cookies, CloudFront enregistre les cookies dans toutes requests , quels que soient les cookies que vous choisissez de transmettre à l&apos;origine.
            * Si une demande n&apos;inclut pas d&apos;en-tête de cookie, la valeur de ce champ est un tiret (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            Comment CloudFront classe la réponse après que le dernier octet a quitté l&apos;emplacement périphérique. Dans certains cas, le type de résultat peut changer entre le moment où CloudFront est prêt à envoyer la réponse et le moment où CloudFront a terminé d&apos;envoyer la réponse.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            Une chaîne cryptée qui identifie de manière unique une demande. Dans l&apos;en-tête de réponse, il s&apos;agit `x-amz-cf-id`.
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            La valeur que le spectateur a incluse dans l&apos;en-tête Hôte pour cette requête. Il s&apos;agit du nom de domaine dans la demande.

            * Si vous utilisez le nom de domaine CloudFront dans les URL de votre objet, ce champ contient ce nom de domaine.
            * Si vous utilisez des noms de domaine alternatifs dans vos URL d&apos;objet, tels que `http://example.com/logo.png`, ce champ contient le nom de domaine alternatif, tel que `example.com`. Pour utiliser des noms de domaine alternatifs, vous devez les ajouter à votre distribution.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            Le protocole que le spectateur a spécifié dans la requête : `http`, `https`, `ws` ou `wss`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            Le nombre d&apos;octets de données que le spectateur a inclus dans la demande, y compris les en-têtes. Pour les connexions WebSocket, il s&apos;agit du nombre total d&apos;octets envoyés du client au serveur sur la connexion.
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            Le nombre de secondes (au millième de seconde ; par exemple, 0,002) entre le moment où un serveur de périphérie CloudFront reçoit la demande d&apos;un spectateur et le moment où CloudFront écrit le dernier octet de la réponse dans la file d&apos;attente de sortie du serveur de périphérie, tel que mesuré sur le serveur.

            Du point de vue du spectateur, le temps total nécessaire pour obtenir l’objet complet sera plus long que cette valeur en raison de la latence du réseau et de la mise en mémoire tampon TCP.
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            Si le spectateur a utilisé un proxy HTTP ou un équilibreur de charge pour envoyer la requête, la valeur de `c_ip` dans le champ 5 est l&apos;adresse IP du proxy ou de l&apos;équilibreur de charge. Dans ce cas, ce champ est l&apos;adresse IP du spectateur à l&apos;origine de la demande.

            Ce champ contient les adresses IPv4 et IPv6 selon le cas. Si le spectateur n&apos;a pas utilisé de proxy HTTP ou d&apos;équilibreur de charge, la valeur de `x_forwarded_for` est un tiret (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            Lorsque `cs_protocol` dans le champ 17 est `https`, ce champ contient le protocole SSL/TLS que le client et CloudFront ont négocié pour transmettre la demande et la réponse. Les valeurs possibles incluent :

            * SSLv3

            * TLSv1

            * TLSv1.1

            * TLSv1.2

              Lorsque `cs_protocol` dans le champ 17 est `http`, la valeur de ce champ est un trait d&apos;union (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            Lorsque `cs_protocol` dans le champ 17 est `https`, ce champ contient le chiffrement SSL/TLS que le client et CloudFront ont négocié pour chiffrer la demande et la réponse. Les valeurs possibles incluent :

            * `ECDHE-RSA-AES128-GCM-SHA256`

            * `ECDHE-RSA-AES128-SHA256`

            * `ECDHE-RSA-AES128-SHA`

            * `ECDHE-RSA-AES256-GCM-SHA384`

            * `ECDHE-RSA-AES256-SHA384`

            * `ECDHE-RSA-AES256-SHA`

            * `AES128-GCM-SHA256`

            * `AES256-GCM-SHA384`

            * `AES128-SHA256`

            * `AES256-SHA`

            * `AES128-SHA`

            * `DES-CBC3-SHA`

            * `RC4-MD5`

              Lorsque `cs_protocol` dans le champ 17 est `http`, la valeur de ce champ est un trait d&apos;union (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            Comment CloudFront a classé la réponse juste avant de renvoyer la réponse au spectateur. Les valeurs possibles incluent :

            * `Hit`:CloudFront a fourni l&apos;objet au spectateur à partir du cache de périphérie.
            * `RefreshHit`:CloudFront a trouvé l&apos;objet dans le cache Edge, mais il avait expiré. CloudFront a donc contacté l&apos;origine pour vérifier que le cache dispose de la dernière version de l&apos;objet.
            * `Miss`:La demande n&apos;a pas pu être satisfaite par un objet dans le cache de périphérie, donc CloudFront a transmis la demande au serveur d&apos;origine et a renvoyé le résultat au visualiseur.
            * `LimitExceeded`:La demande a été refusée car une limite CloudFront a été dépassée.
            * `CapacityExceeded`: CloudFront a renvoyé une erreur `503` car l&apos;emplacement périphérique n&apos;avait pas suffisamment de capacité au moment de la demande pour servir l&apos;objet.
            * `Error`: En général, cela signifie que la demande a entraîné une erreur client (`sc_status` est `4xx`) ou une erreur serveur (`sc_status` est `5xx`). Si la valeur de `x_edge_result_type` est `Error` et que la valeur de ce champ **n&apos;est pas** `Error`, le client s&apos;est déconnecté avant de terminer le téléchargement.
            * `Redirect`: CloudFront redirige de HTTP vers HTTPS. Si `sc_status` est `403` et que vous avez configuré CloudFront pour restreindre la distribution géographique de votre contenu, la demande peut provenir d&apos;un emplacement restreint.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            La version HTTP que le spectateur a spécifiée dans la requête. Les valeurs possibles incluent :

            * `HTTP/0.9`
            * `HTTP/1.0`
            * `HTTP/1.1`
            * `HTTP/2.0`
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            Lorsque le chiffrement au niveau du champ est configuré pour une distribution, ce champ contient un code qui indique si le corps de la demande a été traité avec succès.

            Si le chiffrement au niveau du champ n&apos;est pas configuré pour la distribution, la valeur est un tiret (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `fle-encrypted-fields`
          </td>

          <td>
            Le nombre de champs que CloudFront a chiffrés et transmis à l&apos;origine. CloudFront transmet la requête traitée à l&apos;origine pendant qu&apos;il crypte les données, de sorte que `fle-encrypted-fields` peut avoir une valeur même si la valeur de `fle-status` est une erreur.

            Si le chiffrement au niveau du champ n&apos;est pas configuré pour la distribution, la valeur de `fle-encrypted-fields` est un tiret (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            Le numéro de port de la demande du spectateur.
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            Le nombre de secondes entre la réception de la demande et l&apos;écriture du premier octet de la réponse, tel que mesuré sur le serveur.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            Lorsque `x-edge-result-type` <DNT>**is not**</DNT> `Error`, ce champ contient la même valeur que `x-edge-result-type`. Lorsque `x-edge-result-type` <DNT>**is**</DNT> `Error`, ce champ contient le type spécifique d&apos;erreur.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            La valeur de l&apos;en-tête HTTP Content-Type de la réponse.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            La valeur de l&apos;en-tête HTTP Content-Length de la réponse.
          </td>
        </tr>

        <tr>
          <td>
            `sc_range_start`
          </td>

          <td>
            Lorsque la réponse contient l&apos;en-tête HTTP Content-Range, ce champ contient la valeur de début de la plage.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            Lorsque la réponse contient l&apos;en-tête HTTP Content-Range, ce champ contient la valeur de fin de la plage.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="cloudfront-rtl" title="CloudFront (log des temps réels)">
    <DNT>**Source:**</DNT> `logtype = 'cloudfront-rtl'`

    <DNT>
      **Grok:**
    </DNT>

    ```
    ^%{NOTSPACE:timestamp}.\d{3}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:cs_ip_version}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_cookie}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:c_country}%{SPACE}%{NOTSPACE:cs_accept_encoding}%{SPACE}%{NOTSPACE:cs_accept}%{SPACE}%{NOTSPACE:cache_behavior_path_pattern}%{SPACE}%{NOTSPACE:cs_headers}%{SPACE}%{NOTSPACE:cs_header_names}%{SPACE}%{NOTSPACE:cs_headers_count}$
    ```

    <DNT>
      **Results:**
    </DNT>

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Champ
          </th>

          <th>
            Définition
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `timestamp`
          </td>

          <td>
            La date et l’heure auxquelles le serveur Edge a fini de répondre à la demande.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            L&apos;adresse IP du spectateur qui a effectué la demande, par exemple, `192.0.2.183` ou `2001:0db8:85a3:0000:0000:8a2e:0370:7334`. Si le spectateur a utilisé un proxy HTTP ou un équilibreur de charge pour envoyer la requête, la valeur de ce champ est l&apos;adresse IP du proxy ou de l&apos;équilibreur de charge. Voir également le champ `x-forwarded-for` .
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            Le nombre de secondes entre la réception de la demande et l&apos;écriture du premier octet de la réponse, tel que mesuré sur le serveur.
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            Un code d’état HTTP ; par exemple, `200`. Le code d&apos;état `000` indique que le spectateur a fermé la connexion (par exemple, fermé l&apos;onglet du navigateur) avant que CloudFront puisse répondre à une demande. Si le visualiseur ferme la connexion après que CloudFront a commencé à envoyer la réponse, le log contient le code d&apos;état HTTP applicable.
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            Le nombre total d&apos;octets que le serveur a envoyé au spectateur en réponse à la demande, y compris les en-têtes. Pour les connexions WebSocket, il s&apos;agit du nombre total d&apos;octets envoyés du serveur au client via la connexion.
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            La méthode de requête HTTP reçue du spectateur.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            Le protocole de la demande du spectateur (http, https, ws ou wss).
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            La valeur que le spectateur a incluse dans l&apos;en-tête Hôte de la requête. Si vous utilisez le nom de domaine CloudFront dans les URL de votre objet (par exemple, d111111abcdef8.cloudfront.net), ce champ contient ce nom de domaine. Si vous utilisez des noms de domaine alternatifs (CNAME) dans les URL de votre objet (tels que [www.exemple.com](http://www.example.com)), ce champ contient le nom de domaine alternatif.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            L&apos;URL de la demande complète, y compris la chaîne de requête (si elle existe), mais sans le nom de domaine. Par exemple, `/images/cat.webp?mobile=true`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            Le nombre total d&apos;octets de données que le spectateur a inclus dans la demande, y compris les en-têtes. Pour les connexions WebSocket, il s&apos;agit du nombre total d&apos;octets envoyés du client au serveur sur la connexion.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            L&apos;emplacement du bord qui a servi la requête. Chaque emplacement de bord est identifié par un code à trois lettres et un numéro attribué arbitrairement (par exemple, DFW3). Le code à trois lettres correspond généralement au code d&apos;aéroport de l&apos;Association du transport aérien international (IATA) pour un aéroport proche de l&apos;emplacement géographique de l&apos;emplacement périphérique. (Ces abréviations pourraient changer à l&apos;avenir.)
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            Comment CloudFront classe la réponse après que le dernier octet a quitté l&apos;emplacement périphérique. Dans certains cas, le type de résultat peut changer entre le moment où CloudFront est prêt à envoyer la réponse et le moment où CloudFront a terminé d&apos;envoyer la réponse.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            Une chaîne opaque qui identifie de manière unique une demande. CloudFront envoie également cette chaîne dans l&apos;en-tête de réponse x-amz-cf-id.
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            Le nom de domaine de la distribution CloudFront (par exemple, `d111111abcdef8.cloudfront.net`).
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            Le nombre de secondes (au millième de seconde, par exemple, 0,082) entre le moment où le serveur reçoit la demande du spectateur et le moment où le serveur écrit le dernier octet de la réponse dans la file d&apos;attente de sortie, tel que mesuré sur le serveur. Du point de vue du spectateur, le temps total nécessaire pour obtenir la réponse complète sera plus long que cette valeur en raison de la latence du réseau et de la mise en mémoire tampon TCP.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            La version HTTP que le spectateur a spécifiée dans la requête. Les valeurs possibles incluent `HTTP/0.9`, `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0` et `HTTP/3.0`.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip_version`
          </td>

          <td>
            La version IP de la requête (IPv4 ou IPv6).
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            La valeur de l&apos;en-tête utilisateur-Agent dans la requête. L&apos;en-tête utilisateur-Agent identifie la source de la demande, comme le type d&apos;appareil et de navigateur qui a soumis la demande ou, si la demande provient d&apos;un moteur de recherche, quel moteur de recherche.
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            La valeur de l&apos;en-tête Referer dans la requête. Il s’agit du nom du domaine à l’origine de la demande. Les référents courants incluent les moteurs de recherche, d’autres sites Web qui renvoient directement vers vos objets et votre propre site Web.
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            L&apos;en-tête du cookie dans la demande, y compris les paires nom-valeur et l&apos;attribut associé.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            La partie chaîne de requête de l&apos;URL de la demande, le cas échéant.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            Comment le serveur a classé la réponse juste avant de renvoyer la réponse au spectateur. Voir également le champ x-edge-result-type. Les valeurs possibles incluent :

            * `Hit`:Le serveur a fourni l&apos;objet au spectateur à partir du cache.
            * `RefreshHit`:Le serveur a trouvé l&apos;objet dans le cache mais l&apos;objet avait expiré, le serveur a donc contacté l&apos;origine pour vérifier que le cache contenait la dernière version de l&apos;objet.
            * `Miss`:La demande n&apos;a pas pu être satisfaite par un objet dans le cache, le serveur a donc transmis la demande au serveur d&apos;origine et a renvoyé le résultat au visualiseur.
            * `LimitExceeded`:La demande a été refusée car un quota CloudFront (anciennement appelé limite) a été dépassé
            * `CapacityExceeded`:Le serveur a renvoyé une erreur 503 car il n&apos;avait pas suffisamment de capacité au moment de la demande pour servir l&apos;objet.
            * `Error`:En général, cela signifie que la demande a entraîné une erreur client (la valeur du champ sc-status est dans la plage 4xx) ou une erreur serveur (la valeur du champ sc-status est dans la plage 5xx). Si la valeur du champ x-edge-result-type est Error et que la valeur de ce champ n&apos;est pas Error, le client s&apos;est déconnecté avant de terminer le téléchargement.
            * `Redirect`:Le serveur a redirigé le spectateur de HTTP vers HTTPS en fonction des paramètres de distribution.
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            Si le spectateur a utilisé un proxy HTTP ou un équilibreur de charge pour envoyer la requête, la valeur du champ c-ip est l&apos;adresse IP du proxy ou de l&apos;équilibreur de charge. Dans ce cas, ce champ est l&apos;adresse IP du spectateur à l&apos;origine de la demande. Ce champ contient une adresse IPv4 (par exemple, `192.0.2.183`) ou une adresse IPv6 (par exemple, `2001:0db8:85a3:0000:0000:8a2e:0370:7334`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            Lorsque la requête utilise HTTPS, ce champ contient le protocole SSL/TLS que le visualiseur et le serveur ont négocié pour transmettre la requête et la réponse.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            Lorsque la requête utilise HTTPS, ce champ contient le chiffrement SSL/TLS que le visualiseur et le serveur ont négocié pour crypter la requête et la réponse.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            Comment le serveur a classé la réponse après que le dernier octet a quitté le serveur. Dans certains cas, le type de résultat peut changer entre le moment où le serveur est prêt à envoyer la réponse et le moment où il termine l&apos;envoi de la réponse. Voir également le champ `x-edge-response-result-type` . Par exemple, dans le streaming HTTP, supposons que le serveur trouve un segment du flux dans le cache. Dans ce scénario, la valeur de ce champ serait normalement `Hit`. Cependant, si le spectateur ferme la connexion avant que le serveur n&apos;ait livré l&apos;intégralité du segment, le type de résultat final (et la valeur de ce champ) est `Error`. Les connexions WebSocket auront une valeur de `Miss` pour ce champ car le contenu n&apos;est pas mis en cache et est envoyé directement à l&apos;origine.

            Les valeurs possibles incluent :

            * `Hit`:Le serveur a fourni l&apos;objet au spectateur à partir du cache.
            * `RefreshHit`:Le serveur a trouvé l&apos;objet dans le cache mais l&apos;objet avait expiré, le serveur a donc contacté l&apos;origine pour vérifier que le cache contenait la dernière version de l&apos;objet.
            * `Miss`:La requête n&apos;a pas pu être satisfaite par un objet dans le cache, le serveur a donc transmis la requête à l&apos;origine et a renvoyé le résultat au spectateur.
            * `LimitExceeded`:La demande a été refusée car un quota CloudFront (anciennement appelé limite) a été dépassé.
            * `CapacityExceeded`:Le serveur a renvoyé un code d&apos;état HTTP 503 car il n&apos;avait pas suffisamment de capacité au moment de la demande pour traiter l&apos;objet.
            * `Error`:En général, cela signifie que la demande a entraîné une erreur client (la valeur du champ sc-status est dans la plage 4xx) ou une erreur serveur (la valeur du champ sc-status est dans la plage 5xx). Si la valeur du champ `sc-status` est `200`, ou si la valeur de ce champ est `Error` et la valeur du champ `x-edge-response-result-type` n&apos;est pas `Error`, cela signifie que la requête HTTP a réussi mais que le client s&apos;est déconnecté avant de recevoir tous les octets.
            * `Redirect`:Le serveur a redirigé le spectateur de HTTP vers HTTPS en fonction des paramètres de distribution.
          </td>
        </tr>

        <tr>
          <td>
            `fle_encrypted_fields`
          </td>

          <td>
            Le nombre de champs de chiffrement au niveau du champ que le serveur a chiffrés et transmis à l&apos;origine. Les serveurs CloudFront diffusent la demande traitée vers l&apos;origine pendant qu&apos;ils chiffrent les données. Ce champ peut donc avoir une valeur même si la valeur de `fle-status` est une erreur.
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            Lorsque le chiffrement au niveau du champ est configuré pour une distribution, ce champ contient un code qui indique si le corps de la demande a été traité avec succès. Lorsque le serveur traite avec succès le corps de la demande, crypte les valeurs dans les champs spécifiés et transmet la demande à l&apos;origine, la valeur de ce champ est Traité. La valeur de `x-edge-result-type` peut toujours indiquer une erreur côté client ou côté serveur dans ce cas.

            Les valeurs possibles pour ce champ incluent : \*`ForwardedByContentType`: le serveur a transmis la demande à l&apos;origine sans analyse ni chiffrement, car aucun type de contenu n&apos;a été configuré.

            * `ForwardedByQueryArgs`:Le serveur a transmis la demande à l&apos;origine sans analyse ni chiffrement, car la demande contient un argument de requête qui n&apos;était pas dans la configuration du chiffrement au niveau du champ.
            * `ForwardedDueToNoProfile`:Le serveur a transmis la demande à l&apos;origine sans analyse ni chiffrement, car aucun profil n&apos;a été spécifié dans la configuration pour le chiffrement au niveau du champ.
            * `MalformedContentTypeClientError`:Le serveur a rejeté la demande et a renvoyé un code d&apos;état HTTP 400 au visualiseur car la valeur de l&apos;en-tête Content-Type était dans un format non valide.
            * `MalformedInputClientError`:Le serveur a rejeté la demande et a renvoyé un code d&apos;état HTTP 400 au spectateur car le corps de la demande était dans un format non valide.
            * `MalformedQueryArgsClientError`:Le serveur a rejeté la demande et a renvoyé un code d&apos;état HTTP 400 au visualiseur car un argument de requête était vide ou dans un format non valide.
            * `RejectedByContentType`:Le serveur a rejeté la demande et a renvoyé un code d’état HTTP 400 au visualiseur car aucun type de contenu n’a été spécifié dans la configuration pour le chiffrement au niveau du champ.
            * `RejectedByQueryArgs`:Le serveur a rejeté la demande et a renvoyé un code d’état HTTP 400 au visualiseur car aucun argument de requête n’a été spécifié dans la configuration pour le chiffrement au niveau du champ.
            * `ServerError`:Le serveur d&apos;origine a renvoyé une erreur. Si la demande dépasse un quota de chiffrement au niveau du champ (anciennement appelé limite), ce champ contient l&apos;un des codes d&apos;erreur suivants et le serveur renvoie le code d&apos;état HTTP 400 au visualiseur.
            * `FieldLengthLimitClientError`:Un champ configuré pour être chiffré a dépassé la longueur maximale autorisée
            * `FieldNumberLimitClientError`:Une demande que la distribution est configurée pour chiffrer contient plus que le nombre de champs autorisés.
            * `RequestLengthLimitClientError`:La longueur du corps de la requête a dépassé la longueur maximale autorisée lorsque le chiffrement au niveau du champ est configuré.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            La valeur de l&apos;en-tête HTTP Content-Type de la réponse.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            La valeur de l&apos;en-tête HTTP Content-Length de la réponse.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-start`
          </td>

          <td>
            Lorsque la réponse contient l&apos;en-tête HTTP Content-Range, ce champ contient la valeur de début de la plage.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            Lorsque la réponse contient l&apos;en-tête HTTP Content-Range, ce champ contient la valeur de fin de la plage.
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            Le numéro de port de la demande du spectateur.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            Lorsque la valeur du champ `x-edge-result-type` est `Error`, ce champ contient le type spécifique d&apos;erreur. Lorsque l&apos;objet a été servi au spectateur à partir du cache Origin Shield, ce champ contient `OriginShieldHit`. Dans tous les autres cas, ce champ contient la même valeur que `x-edge-result-type`. Les valeurs possibles pour ce champ incluent :

            * `AbortedOrigin`:Le serveur a rencontré un problème avec l&apos;origine.
            * `OriginCommError`:La demande a expiré lors de la connexion à l&apos;origine ou de la lecture des données à partir de l&apos;origine.
            * `ClientCommError`:La réponse au spectateur a été interrompue en raison d&apos;un problème de communication entre le serveur et le spectateur.
            * `ClientGeoBlocked`:La distribution est configurée pour refuser requests provenant de l&apos;emplacement géographique du spectateur.
            * `ClientHungUpRequest`:Le spectateur s&apos;est arrêté prématurément lors de l&apos;envoi de la requête.
            * `Error` – Une erreur s’est produite dont le type d’erreur ne correspond à aucune des autres catégories. Ce type d’erreur peut se produire lorsque le serveur fournit une réponse d’erreur à partir du cache.
            * `InvalidRequest`:Le serveur a reçu une demande non valide de la part du spectateur.
            * `InvalidRequestBlocked`:L&apos;accès à la ressource demandée est bloqué.
            * `InvalidRequestCertificate`:La distribution ne correspond pas au certificat SSL/TLS pour lequel la connexion HTTPS a été établie.
            * `InvalidRequestHeader`:La demande contenait un en-tête non valide.
            * `InvalidRequestMethod`:La distribution n&apos;est pas configurée pour gérer la méthode de requête HTTP qui a été utilisée. Cela peut se produire lorsque la distribution ne prend en charge que requests pouvant être mises en cache.
            * `OriginConnectError`:Le serveur n&apos;a pas pu se connecter à l&apos;origine.
            * `OriginContentRangeLengthError`: L&apos;en-tête Content-Length dans la réponse de l&apos;origine ne correspond pas à la longueur de l&apos;en-tête Content-Range.
            * `OriginDnsError`:Le serveur n&apos;a pas pu résoudre le nom de domaine d&apos;origine.
            * `OriginError`:L&apos;origine a renvoyé une réponse incorrecte.
            * `OriginHeaderTooBigError`:Un en-tête renvoyé par l&apos;origine est trop volumineux pour être traité par le serveur Edge.
            * `OriginInvalidResponseError`:L&apos;origine a renvoyé une réponse non valide.
            * `OriginReadError`:Le serveur n&apos;a pas pu lire depuis l&apos;origine.
            * `OriginShieldHit`:L&apos;objet a été servi au spectateur à partir du cache Origin Shield.
            * `OriginWriteError`:Le serveur n&apos;a pas pu écrire à l&apos;origine.
            * `OriginZeroSizeObjectError`:Un objet de taille zéro envoyé depuis l&apos;origine a généré une erreur.
            * `SlowReaderOriginError`:Le spectateur a mis du temps à lire le message qui a provoqué l&apos;erreur d&apos;origine.
          </td>
        </tr>

        <tr>
          <td>
            `c_country`
          </td>

          <td>
            Un code de pays qui représente l&apos;emplacement géographique du spectateur, tel que déterminé par l&apos;adresse IP du spectateur.
          </td>
        </tr>

        <tr>
          <td>
            `cs_accept_encoding`
          </td>

          <td>
            La valeur de l&apos;en-tête `Accept-Encoding` dans la demande du visualiseur.
          </td>
        </tr>

        <tr>
          <td>
            `cs_accept`
          </td>

          <td>
            La valeur de l&apos;en-tête `Accept` dans la demande du visualiseur.
          </td>
        </tr>

        <tr>
          <td>
            `cache_behavior_path_pattern`
          </td>

          <td>
            Le modèle de chemin qui identifie le comportement du cache correspondant à la demande du visualiseur.
          </td>
        </tr>

        <tr>
          <td>
            `cs_headers`
          </td>

          <td>
            Les en-têtes HTTP (noms et valeurs) dans la demande du visualiseur.
          </td>
        </tr>

        <tr>
          <td>
            `cs_header_names`
          </td>

          <td>
            Les noms des en-têtes HTTP (pas des valeurs) dans la demande du visualiseur.
          </td>
        </tr>

        <tr>
          <td>
            `cs_headers_count`
          </td>

          <td>
            Le nombre d&apos;en-têtes HTTP dans la demande du visualiseur.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="elastic-load-balancer" title="Équilibreur de charge Elastic">
    <DNT>**Source:**</DNT> `logtype = 'elb'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} "%{DATA:request}" "%{DATA:user_agent}" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol}
    ```

    <DNT>
      **Results:**
    </DNT>

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Champ
          </th>

          <th>
            Définition
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            L&apos;emplacement du bord qui a servi la requête. Chaque emplacement de bord est identifié par un code à trois lettres et un numéro attribué arbitrairement ; par exemple, `DFW3`. Le code à trois lettres correspond généralement au code d&apos;aéroport de l&apos;Association du transport aérien international pour un aéroport proche de l&apos;emplacement périphérique. (Ces abréviations pourraient changer à l&apos;avenir.)
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            Le nombre total d&apos;octets que CloudFront a servis au spectateur en réponse à la requête, y compris les en-têtes ; par exemple, `1045619`. Pour les connexions WebSocket, il s&apos;agit du nombre total d&apos;octets envoyés du serveur au client via la connexion.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            L&apos;adresse IP du spectateur qui a fait la demande. Si le spectateur a utilisé un proxy HTTP ou un équilibreur de charge pour envoyer la requête, la valeur de `c_ip` est l&apos;adresse IP du proxy ou de l&apos;équilibreur de charge.
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            La méthode de requête HTTP : `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST` ou `PUT`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            Le nom de domaine de la distribution CloudFront ; par exemple, `d111111abcdef8.cloudfront.net`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            La partie de l&apos;URI qui identifie le chemin et l&apos;objet ; par exemple, `/images/cat.jpg`. Les points d&apos;interrogation (`?`) dans les URL et les chaînes de requête ne sont pas inclus dans le log.
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            Un code d’état HTTP (par exemple, `200`). Le code d&apos;état `000` indique que le spectateur a fermé la connexion (par exemple, fermé l&apos;onglet du navigateur) avant que CloudFront puisse répondre à une demande.

            Si le visualiseur ferme la connexion après que CloudFront a commencé à envoyer la réponse, le log contient le code d&apos;état HTTP applicable.
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            le nom du domaine à l&apos;origine de la demande. Les référents courants incluent les moteurs de recherche, d’autres sites Web qui renvoient directement vers vos objets et votre propre site Web.
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            La valeur de l&apos;en-tête utilisateur-Agent dans la requête. L&apos;en-tête utilisateur-Agent identifie la source de la demande, comme le type d&apos;appareil et de navigateur qui a soumis la demande et le moteur de recherche, le cas échéant.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            La partie chaîne de requête de l&apos;URI, le cas échéant. Lorsqu&apos;un URI ne contient pas de chaîne de requête, la valeur de ce champ est un trait d&apos;union (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            L&apos;en-tête du cookie dans la demande, y compris les paires nom-valeur et l&apos;attribut associé.

            * Si vous activez le logging des cookies, CloudFront enregistre les cookies dans toutes requests, quels que soient les cookies que vous choisissez de transmettre à l&apos;origine.
            * Si une demande n&apos;inclut pas d&apos;en-tête de cookie, la valeur de ce champ est un tiret (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            Comment CloudFront classe la réponse après que le dernier octet a quitté l&apos;emplacement périphérique. Dans certains cas, le type de résultat peut changer entre le moment où CloudFront est prêt à envoyer la réponse et le moment où CloudFront a terminé d&apos;envoyer la réponse.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            Une chaîne cryptée qui identifie de manière unique une demande. Dans l&apos;en-tête de réponse, il s&apos;agit `x-amz-cf-id`.
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            La valeur que le spectateur a incluse dans l&apos;en-tête Hôte pour cette requête. Il s&apos;agit du nom de domaine dans la demande.

            * Si vous utilisez le nom de domaine CloudFront dans les URL de votre objet, ce champ contient ce nom de domaine.
            * Si vous utilisez des noms de domaine alternatifs dans vos URL d&apos;objet, tels que `[http://example.com/logo.png`, ce champ contient le nom de domaine alternatif, tel que `example.com`. Pour utiliser des noms de domaine alternatifs, vous devez les ajouter à votre distribution.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            Le protocole que le spectateur a spécifié dans la requête : `http`, `https`, `ws` ou `wss`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            Le nombre d&apos;octets de données que le spectateur a inclus dans la demande, y compris les en-têtes. Pour les connexions WebSocket, il s&apos;agit du nombre total d&apos;octets envoyés du client au serveur sur la connexion.
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            Le nombre de secondes (au millième de seconde ; par exemple, 0,002) entre le moment où un serveur de périphérie CloudFront reçoit la demande d&apos;un spectateur et le moment où CloudFront écrit le dernier octet de la réponse dans la file d&apos;attente de sortie du serveur de périphérie, tel que mesuré sur le serveur.

            Du point de vue du spectateur, le temps total nécessaire pour obtenir l’objet complet sera plus long que cette valeur en raison de la latence du réseau et de la mise en mémoire tampon TCP.
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            Si le spectateur a utilisé un proxy HTTP ou un équilibreur de charge pour envoyer la requête, la valeur de `c_ip` dans le champ 5 est l&apos;adresse IP du proxy ou de l&apos;équilibreur de charge. Dans ce cas, ce champ est l&apos;adresse IP du spectateur à l&apos;origine de la demande. Ce champ contient les adresses IPv4 et IPv6 selon le cas.

            Si le spectateur n&apos;a pas utilisé de proxy HTTP ou d&apos;équilibreur de charge, la valeur de `x_forwarded_for` est un tiret (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            Lorsque `cs_protocol` dans le champ 17 est `https`, ce champ contient le protocole SSL/TLS que le client et CloudFront ont négocié pour transmettre la demande et la réponse. Les valeurs possibles incluent :

            * SSLv3
            * TLSv1
            * TLSv1.1
            * TLSv1.2 Lorsque `cs_protocol` dans le champ 17 est `http`, la valeur de ce champ est un trait d&apos;union (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            Lorsque `cs_protocol` dans le champ 17 est `https`, ce champ contient le chiffrement SSL/TLS que le client et CloudFront ont négocié pour chiffrer la demande et la réponse. Les valeurs possibles incluent :

            * `ECDHE-RSA-AES128-GCM-SHA256`

            * `ECDHE-RSA-AES128-SHA256`

            * `ECDHE-RSA-AES128-SHA`

            * `ECDHE-RSA-AES256-GCM-SHA384`

            * `ECDHE-RSA-AES256-SHA384`

            * `ECDHE-RSA-AES256-SHA`

            * `AES128-GCM-SHA256`

            * `AES256-GCM-SHA384`

            * `AES128-SHA256`

            * `AES256-SHA`

            * `AES128-SHA`

            * `DES-CBC3-SHA`

            * `RC4-MD5`

              Lorsque `cs_protocol` est `http`, la valeur de ce champ est un trait d&apos;union (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            Comment CloudFront a classé la réponse juste avant de renvoyer la réponse au spectateur. Les valeurs possibles incluent :

            * `Hit`:CloudFront a fourni l&apos;objet au spectateur à partir du cache de périphérie.
            * `RefreshHit`:CloudFront a trouvé l&apos;objet dans le cache Edge, mais il avait expiré. CloudFront a donc contacté l&apos;origine pour vérifier que le cache dispose de la dernière version de l&apos;objet.
            * `Miss`:La demande n&apos;a pas pu être satisfaite par un objet dans le cache de périphérie, donc CloudFront a transmis la demande au serveur d&apos;origine et a renvoyé le résultat au visualiseur.
            * `LimitExceeded`:La demande a été refusée car une limite CloudFront a été dépassée.
            * `CapacityExceeded`: CloudFront a renvoyé une erreur `503` car l&apos;emplacement périphérique n&apos;avait pas suffisamment de capacité au moment de la demande pour servir l&apos;objet.
            * `Error`: En général, cela signifie que la demande a entraîné une erreur client (`sc_status` est `4xx`) ou une erreur serveur (`sc_status` est `5xx`). Si la valeur de `x_edge_result_type` est `Error` et que la valeur de ce champ **n&apos;est pas** `Error`, le client s&apos;est déconnecté avant de terminer le téléchargement.
            * `Redirect`: CloudFront redirige de HTTP vers HTTPS. Si `sc_status` est `403` et que vous avez configuré CloudFront pour restreindre la distribution géographique de votre contenu, la demande peut provenir d&apos;un emplacement restreint.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            La version HTTP que le spectateur a spécifiée dans la requête. Les valeurs possibles incluent :

            * `HTTP/0.9`
            * `HTTP/1.0`
            * `HTTP/1.1`
            * `HTTP/2.0`
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            Lorsque le chiffrement au niveau du champ est configuré pour une distribution, ce champ contient un code qui indique si le corps de la demande a été traité avec succès. Si le chiffrement au niveau du champ n&apos;est pas configuré pour la distribution, la valeur de ce champ est un tiret (`-`).

            Lorsque CloudFront traite avec succès le corps de la demande, crypte les valeurs dans les champs spécifiés et transmet la demande à l&apos;origine, la valeur de ce champ est `Processed`. La valeur de `x_edge_result_type` peut toujours indiquer une erreur côté client ou côté serveur dans ce cas.

            Si la demande dépasse une limite de chiffrement au niveau du champ, `fle-status` contient l’un des codes d’erreur suivants et CloudFront renvoie le code d’état HTTP `400` au visualiseur.
          </td>
        </tr>

        <tr>
          <td>
            `fle-encrypted-fields`
          </td>

          <td>
            Le nombre de champs que CloudFront a chiffrés et transmis à l&apos;origine. CloudFront transmet la requête traitée à l&apos;origine pendant qu&apos;il crypte les données, de sorte que `fle_encrypted_fields` peut avoir une valeur même si la valeur de `fle_status` est une erreur.

            Si le chiffrement au niveau du champ n&apos;est pas configuré pour la distribution, la valeur de `fle_encrypted_fields` est un tiret (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            Le numéro de port de la demande du spectateur.
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            Le nombre de secondes entre la réception de la demande et l&apos;écriture du premier octet de la réponse, tel que mesuré sur le serveur.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            Lorsque `x_edge_result_type` <DNT>**is not**</DNT> `Error`, ce champ contient la même valeur que `x_edge_result_type`. Lorsque `x_edge_result_type` <DNT>**is**</DNT> `Error`, ce champ contient le type spécifique d&apos;erreur.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            La valeur de l&apos;en-tête HTTP Content-Type de la réponse.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            La valeur de l&apos;en-tête HTTP Content-Length de la réponse.
          </td>
        </tr>

        <tr>
          <td>
            `sc_range_start`
          </td>

          <td>
            Lorsque la réponse contient l&apos;en-tête HTTP Content-Range, ce champ contient la valeur de début de la plage.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            Lorsque la réponse contient l&apos;en-tête HTTP Content-Range, ce champ contient la valeur de fin de la plage.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="haproxy" title="HAProxy">
    <DNT>**Source:**</DNT> `logtype = 'haproxy_http'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{HOSTPORT:client} \\[%{NOTSPACE:haproxy_timestamp}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{NUMBER:time_queue}/%{NUMBER:time_backend_connect}/%{NUMBER:time_duration} %{NUMBER:bytes_read} %{NOTSPACE:termination_state} %{NUMBER:actconn}/%{NUMBER:feconn}/%{NUMBER:beconn}/%{NUMBER:srvconn}/%{NUMBER:retries} %{NUMBER:srv_queue}/%{NUMBER:backend_queue}
    ```

    ```
    %{HOSTPORT:client} \\[%{NOTSPACE:haproxy_timestamp}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{NUMBER:time_client_req}/%{NUMBER:time_queue}/%{NUMBER:time_backend_connect}/%{NUMBER:time_server_response}/%{NUMBER:time_duration} %{NUMBER:status_code} %{NUMBER:bytes_read} %{NOTSPACE:captured_request_cookie} %{NOTSPACE:captured_response_cookie} %{NOTSPACE:termination_state_with_cookie_status} %{NUMBER:actconn}/%{NUMBER:feconn}/%{NUMBER:beconn}/%{NUMBER:srvconn}/%{NUMBER:retries} %{NUMBER:srv_queue}/%{NUMBER:backend_queue}?( \\\"%{GREEDYDATA:full_http_request}\\\")?( %{NOTSPACE:captured_response_headers})?
    ```

    <DNT>
      **Results:**
    </DNT>

    * `client`: IP/Port source de cette requête
    * `haproxy_timestamp`: horaire lorsque cette demande a été acceptée
    * `frontend_name`: Nom du frontend utilisé dans cette requête
    * `backend_name`: Nom du backend utilisé dans cette requête
    * `server_name`: Nom du serveur dans le groupe backend utilisé dans cette requête
    * `time_client_req`: Temps d&apos;attente pour la demande complète du client (ms)
    * `time_queue`: Temps d&apos;attente dans les files d&apos;attente (ms)
    * `time_backend_connect`:Temps nécessaire pour établir la connexion au serveur de destination (ms)
    * `time_server_response`:Temps nécessaire au serveur de destination pour envoyer la réponse (ms)
    * `time_duration`: Temps total de requête active dans HAProxy (ms)
    * `status_code`:Code de réponse HTTP
    * `bytes_read`: Nombre total d&apos;octets lus dans cette requête
    * `captured_request_cookie`:Cookie capturé à partir de la requête
    * `captured_response_cookie`:Cookie capturé à partir de la réponse
    * `termination_state`: État de la session à la déconnexion
    * `termination_state_with_cookie_status`: État de la session, y compris l&apos;état des cookies, lors de la déconnexion
    * `actconn`:Connexions actives
    * `feconn`:Connexions frontales
    * `beconn`:Connexions backend
    * `srvconn`: Connexions au serveur
    * `retries`:Réessais
    * `srv_queue`: Taille de la file d&apos;attente du serveur
    * `backend_queue`: Taille de la file d&apos;attente du backend
    * `full_http_request`:La ligne de requête HTTP complète
    * `captured_response_headers`: En-tête capturé de la réponse
  </Collapser>

  <Collapser id="ktranslate-health" title="KTranslate Santé">
    <DNT>**Source:**</DNT> `logtype = 'ktranslate-health'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{NOTSPACE:timestamp} ktranslate(/)?(%{GREEDYDATA:container_service})? \[%{NOTSPACE:severity}] %{GREEDYDATA:message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `timestamp`: L&apos;heure du log
    * `container_service`: L&apos;identifiant unique utilisé pour distinguer le conteneur dans ktranslate. Ceci est défini pendant l&apos;exécution de Docker avec l&apos;indicateur facultatif `--service_name`
    * `severity`:La gravité de la ligne de log
    * `message`:Le champ de message contient un message de forme libre qui fournit des informations sur l&apos;événement
  </Collapser>

  <Collapser id="linux_cron" title="Cron Linux (/var/log/cron)">
    <DNT>**Source:**</DNT> `logtype = 'linux_cron'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{SYSLOGTIMESTAMP:linux_cron.timestamp} %{NOTSPACE:linux_cron.hostname} %{DATA:linux_cron.process}(\[%{NUMBER:linux_cron.pid:integer}\])?: (\(%{DATA:linux_cron.user}\))?%{GREEDYDATA:linux_cron.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `linux_cron.timestamp`: L&apos;heure du log
    * `linux_cron.hostname`: Le serveur Linux nom d&apos;hôte
    * `linux_cron.process`: Le nom du processus cron Linux
    * `linux_cron.pid`:Le PID cron Linux (identifiant de processus)
    * `linux_cron.user`: L&apos;utilisateur Linux qui a exécuté le cron
    * `linux_cron.message`: Le message de log
  </Collapser>

  <Collapser id="linux_messages" title="Messages Linux (/var/message de log)">
    <DNT>**Source:**</DNT> `logtype = 'linux_messages'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{SYSLOGTIMESTAMP:linux_messages.timestamp} %{NOTSPACE:linux_messages.hostname} %{DATA:linux_messages.process}(\[%{NUMBER:linux_messages.pid:integer}\])?: %{GREEDYDATA:linux_messages.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `linux_messages.timestamp`: L&apos;heure du log
    * `linux_messages.hostname`: Le serveur Linux nom d&apos;hôte
    * `linux_messages.process`: Le nom du processus Linux
    * `linux_messages.pid`:Le PID Linux (identifiant de processus)
    * `linux_messages.message`: Le message de log
  </Collapser>

  <Collapser id="iis" title="Microsoft IIS">
    <DNT>**Source:**</DNT> `logtype = 'iis_w3c'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken}
    ```

    <DNT>
      **Results:**
    </DNT>

    IIS permet plusieurs [options de configuration](https://docs.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms524877\(v=vs.90\)). Si vous avez configuré des options en dehors de la valeur par défaut, notre modèle Grok n&apos;analysera pas votre log. Dans ce cas, nous vous recommandons d’utiliser [une analyse personnalisée](/docs/logs/ui-data/parsing/#custom-parsing).
  </Collapser>

  <Collapser id="mongodb" title="MongoDB">
    <DNT>**Source:**</DNT> `logtype = 'mongodb'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{TIMESTAMP_ISO8601:mongodb.timestamp} %{WORD:mongodb.severity} %{WORD:mongodb.component} *\[%{WORD:mongodb.context}\] %{GREEDYDATA:mongodb.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `mongodb.timestamp`: L&apos;horodatage de l&apos;instruction log
    * `mongodb.severity`:Le niveau de gravité de l&apos;instruction log (F=Fatal, E=Erreur, W=Avertissement, I=Informationnel, D1-5=Débogage)
    * `mongodb.component`: La catégorie du thread émettant l&apos;instruction log
    * `mongodb.context`: Le nom du thread émettant l&apos;instruction log
    * `mongodb.message`:Le message brut de MongoDB
  </Collapser>

  <Collapser id="monit" title="Monit">
    <DNT>**Source:**</DNT> `logtype = 'monit'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    \\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `state`:La gravité de la ligne de log
    * `message`:Le message
  </Collapser>

  <Collapser id="mysql-error" title="Erreur MySQL">
    <DNT>**Source:**</DNT> `logtype = 'mysql-error'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    \\[%{WORD:log_level}\\]
    ```

    <DNT>
      **Results:**
    </DNT>

    * `log_level`:La gravité de la ligne de log
  </Collapser>

  <Collapser id="nginx" title="NGINX">
    <DNT>**Source:**</DNT> `logtype = 'nginx'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `clientip`: L&apos;adresse IP du client
    * `verb`:Le verbe HTTP
    * `ident`: L&apos;identité de l&apos;utilisateur du client effectuant la demande
    * `response`: Le code d&apos;état HTTP de la réponse
    * `request`: L&apos;URI et la demande en cours
    * `httpversion`:La version HTTP de la requête
    * `rawrequest`:La requête HTTP brute si les données sont publiées
    * `bytes`: Le nombre d&apos;octets envoyés
    * `referrer`: Le référent HTTP
    * `agent`: L&apos;agent utilisateur du client
  </Collapser>

  <Collapser id="nginx-error" title="Erreur NGINX">
    <DNT>**Source:**</DNT> `logtype = 'nginx-error'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \[%{WORD:severity}\] %{POSINT:pid}#%{NUMBER}: \*%{NUMBER} %{GREEDYDATA:errormessage} client: %{IPORHOST:client}, server: %{NOTSPACE:server}, request: (\\)?"%{DATA:request}", (?:, upstream: \"%{URI:upstream}\")?host: (\\)?"%{NOTSPACE:host}(\\)?"(, referrer: (\\)?"%{URI:referrer}(\\)?")?
    ```

    <DNT>
      **Results:**
    </DNT>

    * `severity`:La gravité de la ligne de log
    * `pid`: L&apos;ID du processus serveur
    * `errormessage`:Le message d&apos;erreur
    * `clientip`: L&apos;adresse IP du client appelant
    * `server`: L&apos;adresse IP du serveur
    * `request`:La demande complète
    * `upstream`: L&apos;URI en amont
    * `host`: Le nom d&apos;hôte du serveur
    * `referrer`: Le référent HTTP
  </Collapser>

  <Collapser id="postgresql" title="PostgreSQL">
    Source: `logtype = 'postgresql'`

    Grok:

    ```grok
    %{DATA:postgresql.timestamp} \[%{NUMBER:postgresql.pid}\] %{WORD:level}:\s+%{GREEDYDATA:postgresql.message}
    ```

    ### Résultats

    * `postgresql.timestamp`: L&apos;horodatage du log
    * `postgresql.pid`: L&apos;ID du processus serveur
    * `level`: Le niveau de log du message
    * `postgresql.message`: Le message de log
  </Collapser>

  <Collapser id="rabbitmq" title="Lapinmq">
    <DNT>**Source:**</DNT> `logtype = 'rabbitmq'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{TIMESTAMP_ISO8601:rabbitmq.timestamp} \[%{LOGLEVEL:level}\] \<%{DATA:rabbitmq.pid}\> %{GREEDYDATA:rabbitmq.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `rabbitmq.timestamp`: L&apos;horodatage du log
    * `level`: Le niveau de log du message (debug, info, warning, error, critical, none)
    * `rabbitmq.pid`: L&apos;ID de processus de la ligne log
    * `rabbitmq.message`: Le message d&apos;erreur lapinmq
  </Collapser>

  <Collapser id="redis" title="Redis">
    <DNT>**Source:**</DNT> `logtype = 'redis'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{POSINT:redis.pid}:%{NOTSPACE:redis.role} (?<redistimestamp>[\d-]+ [a-zA-Z]+ [\d]+ [\d:]+.[\d]{3}) %{NOTSPACE:level} %{GREEDYDATA:redis.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `redis.pid`: L&apos;ID de processus de la ligne log
    * `redis.role`: Le rôle de l&apos;instance (X sentinelle, C RDB/AOF écriture enfant, S esclave, M maître)
    * `redistimestamp`: L&apos;horodatage du log
    * `level`: Le niveau de log du message (. debug, - verbose, \* notice, # warning)
    * `redis.message`: Le message d&apos;erreur redis
  </Collapser>

  <Collapser id="route53" title="Route 53">
    <DNT>**Source:**</DNT> `logtype = 'route-53'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `log_format_version`: Un format versionné pour le log.
    * `zone_id`: L&apos;ID de la zone hébergée associée à toutes les requêtes DNS dans ce log.
    * `query`: Le domaine ou le sous-domaine qui a été spécifié dans la demande.
    * `query_type`: Soit le type d&apos;enregistrement DNS qui a été spécifié dans la demande, soit `ANY`.
    * `response_code`:Le code de réponse DNS que Route 53 a renvoyé en réponse à la requête DNS.
    * `protocol`: Le protocole utilisé pour soumettre la requête, TCP ou UDP.
    * `edge_location`:L&apos;emplacement du bord de la Route 53 qui a répondu à la requête. Chaque emplacement de bord est identifié par un code à trois lettres et un numéro arbitraire ; par exemple, `DFW3`. Le code à trois lettres correspond généralement au code d&apos;aéroport de l&apos;Association du transport aérien international pour un aéroport proche de l&apos;emplacement périphérique. (Ces abréviations pourraient changer à l&apos;avenir.)
    * `resolver_ip`: L&apos;adresse IP du résolveur DNS qui a soumis la demande à Route 53.
    * `edns_client_subnet`: Une adresse IP partielle pour le client à l&apos;origine de la demande, si disponible auprès du résolveur DNS.
  </Collapser>

  <Collapser id="syslog-rfc5424" title="Syslog RFC-5424">
    <DNT>**Source:**</DNT> `logtype = 'syslog-rfc5424'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\-|%{NOTSPACE:app.name}) +(?:\\-|%{NOTSPACE:procid}) (?:\\-|%{NOTSPACE:msgid}) +(?:\[%{DATA:structured.data}\]|-|) +%{GREEDYDATA:message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `pri`:La priorité représente à la fois la facilité et la gravité du message.
    * `version`:Version du protocole Syslog.
    * `log.timestamp`:Horodatage original.
    * `hostname`: La machine qui a initialement envoyé le message Syslog.
    * `app.name`: L&apos;appareil ou l&apos;application à l&apos;origine du message.
    * `procid`: Le nom du processus ou l&apos;ID du processus associé à un système Syslog.
    * `msgid`: Identifie le type de message.
    * `structured.data`:Valeur de chaîne de données structurée.
    * `sd.sd-id.sd-param-name`:Le contenu `structured.data` est également analysé dans un attribut distinct suivant une convention de dénomination prédéfinie : `sd.sd-id.sd-param-name`. Consultez les exemples d’analyse de données structurées qui suivent.
    * `message`:Message libre qui fournit des informations sur l&apos;événement.

    <DNT>
      **Structured data parsing examples:**
    </DNT>

    Les données structurées `[example one="1" two="2"]` seraient analysées en deux attributs différents :

    ```
    sd.example.one: "1"
    sd.example.two: "2"
    ```

    Si le même bloc de données structuré contient des noms de paramètres en double, il ajoute également un suffixe basé sur un index au nom de l&apos;attribut. Par exemple, les données structurées `[example number="1" number="2"]` seraient analysées comme suit :

    ```
    sd.example.number.0: "1"
    sd.example.number.1: "2"
    ```

    Pour les données structurées auxquelles sont attribués des numéros d&apos;entreprise, un attribut supplémentaire est également analysé. Par exemple, les données structurées `[example@123 number="1"]` seraient analysées comme suit :

    ```
    sd.example.enterprise.number: 123
    sd.example.number: "1"
    ```
  </Collapser>
</CollapserGroup>