---
title: Référence du navigateur scripté de Synthétique (versions de moniteur 0.5.0 et 0.6.0)
tags:
  - Synthetics
  - Synthetic monitoring
  - Scripting monitors
metaDescription: Description of every function available for synthetic scripted monitors for versions 0.5.0 and 0.6.0.
freshnessValidatedDate: never
translationType: machine
---

Ce document décrit les fonctions de navigateur scriptées disponibles pour les versions 0.5.0 ou 0.6.0 du moniteur Synthétique. Si vous utilisez une version plus récente du moniteur, consultez la [documentation de la version Chrome 100 et plus récente du moniteur](/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetic-scipted-browser-reference-monitor-versions-chrome100). Si vous utilisez des versions de Monitorer plus anciennes, consultez la [documentation de Monitorer version 0.4.0 et inférieure](/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetics-scripted-browser-reference).

Pour en savoir plus sur les versions du moniteur et les différences d’exécution, consultez [Environnements d’exécution](/docs/synthetics/new-relic-synthetics/scripting-monitors/scripted-monitor-runtime-environment).

<Callout variant="important">
  À compter du 26 août 2024, vous ne pouvez plus créer de nouveaux moniteurs à l&apos;aide legacy runtimes sur des sites publics ou privés. Le 22 octobre 2024, nous mettrons [fin à la vie](/whats-new/2024/04/whats-new-04-09-eol-synthetics-runtime-cpm) des versions conteneurisées subordonnées privées (appels par minute) et legacy versions synthétiques du runtime.

  * Pour un emplacement public, utilisez [l&apos;UI de mise à niveau de l&apos;environnement d&apos;exécution](/docs/synthetics/synthetic-monitoring/using-monitors/runtime-upgrade-ui/) pour mettre à jour votre moniteur avec les environnements d&apos;exécution les plus récents.
  * Pour les sites privés, veuillez consulter nos [étapes de migration recommandées](/docs/synthetics/synthetic-monitoring/private-locations/job-manager-transition-guide/#monitorMigration) pour éviter la dégradation du moniteur.

  L&apos;environnement d&apos;exécution du navigateur Chrome 100+ offre une prise en charge rétrocompatible pour les versions 0.5.0 et 0.6.0 syntaxe d&apos;exécution du navigateur.
</Callout>

Pour quelques exemples d&apos;utilisation courante, voir [Introduction au moniteur de navigateur scripté](/docs/synthetics/synthetic-monitoring/scripting-monitors/introduction-scripted-browser-monitors).

## API Webdriver de Sélénium [#selenium]

En utilisant les variables `$driver` et `$browser`, vos [navigateurs scriptés](/docs/synthetics/new-relic-synthetics/scripting-monitors/write-scripted-browsers) ont accès aux API Sélénium Webdriver 3.6.0 pour la version 0.6.x du moniteur et les API sélénium Webdriver 3.5.0 pour la version du moniteur 0.5.x.

En particulier:

* `$driver` fournit toutes les exportations du module `selenium-webdriver` (par exemple, `ActionSequence`, `Button`, `By`, `WebElement`, etc.).
* `$browser` est une Synthétique monitoring instance `selenium-webdriver.WebDriver()`de. Il expose les principales API de base `WebDriver` comme `get()` et `findElement()`, ainsi que certaines API personnalisées de Synthétique.

## Fonctions de niveau supérieur : créez votre script [#structure]

New Relic appelle les fonctions de niveau supérieur directement depuis votre instance `$browser` . Ils offrent une large gamme de fonctionnalités couvrant de nombreuses actions scriptables de base.

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="browser-actions">
      <td>
        `$browser.actions()`
      </td>

      <td>
        Crée une nouvelle séquence d&apos;action à l&apos;aide de ce pilote. Pour une liste des actions disponibles, voir [ActionSequence](#actionsequence).

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-addHeader">
      <td>
        `$browser.addHeader(headerKey: string, headerValue: string)`
      </td>

      <td>
        Ajoute l&apos;en-tête `headerKey` avec la valeur `headerValue` à l&apos;exécution.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-addHeaders">
      <td>
        `$browser.addHeaders(headers: ?)`
      </td>

      <td>
        Ajoute une carte d’en-têtes à l’exécution.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-deleteHeader">
      <td>
        `$browser.deleteHeader(header: string)`
      </td>

      <td>
        Supprime un en-tête spécifique de l&apos;exécution.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-deleteHeaders">
      <td>
        `$browser.deleteHeaders(header: [string])`
      </td>

      <td>
        Supprime tous les en-têtes de l&apos;argument lors de l&apos;exécution.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-addHostnameToBlacklist">
      <td>
        `$browser.addHostnameToBlacklist(hostname: string)`
      </td>

      <td>
        Ajoute un nom d’hôte à votre liste de refus. Permet d&apos;utiliser [des caractères génériques](#wildcard-use).

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-addHostnamesToBlacklist">
      <td>
        `$browser.addHostnamesToBlacklist(hostnameArr: [string])`
      </td>

      <td>
        Ajoute tous les noms d&apos;hôte dans un éventail d&apos;arguments à votre liste de refus. Permet d&apos;utiliser [des caractères génériques](#wildcard-use).

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-addHostnameToWhitelist">
      <td>
        `$browser.addHostnameToWhitelist(hostname: string)`
      </td>

      <td>
        Ajoute un nom d&apos;hôte bloqué par défaut dans monitoring Synthétique à votre liste de domaines autorisés.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-addHostnamesToWhitelist">
      <td>
        `$browser.addHostnamesToWhitelist(hostnameArr: [string])`
      </td>

      <td>
        Ajoute tous les noms d&apos;hôte dans l&apos;argument à votre liste de domaines autorisés.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-deleteHostnameFromBlacklist">
      <td>
        `$browser.deleteHostnameFromBlacklist(hostname: string)`
      </td>

      <td>
        Supprime un nom d’hôte pour cette instance de navigateur de votre liste de refus.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-deleteHostnamesFromBlacklist">
      <td>
        `$browser.deleteHostnamesFromBlacklist(hostnameArr: [string])`
      </td>

      <td>
        Supprime tous les noms d&apos;hôte dans l&apos;argument de votre liste de refus.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-deleteHostnameFromWhitelist">
      <td>
        `$browser.deleteHostnameFromWhitelist(hostnameArr: [string])`
      </td>

      <td>
        Supprime un nom d&apos;hôte pour cette instance de navigateur de votre liste de domaines autorisés.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-deleteHostnamesFromWhitelist">
      <td>
        `$browser.deleteHostnamesFromWhitelist(hostnameArr: [string])`
      </td>

      <td>
        Supprime tous les noms d&apos;hôte dans l&apos;argument de votre liste de domaines autorisés pour cette instance de navigateur.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-executeAsyncScript">
      <td>
        `$browser.executeAsyncScript(script: ?, var_args: ?)`
      </td>

      <td>
        Planifie une commande pour exécuter du JavaScript asynchrone dans le contexte du cadre ou de la fenêtre actuellement sélectionné.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-executeScript">
      <td>
        `$browser.executeScript(script: ?, var_args: ?)`
      </td>

      <td>
        Planifie une commande pour exécuter JavaScript dans le contexte du cadre ou de la fenêtre actuellement sélectionné.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-findElement">
      <td>
        `$browser.findElement(locator: $driver.Locator)`
      </td>

      <td>
        Planifiez une commande pour [rechercher un élément sur la page](#locators). Si non trouvé, Synthétique monitoring renvoie une erreur.

        Valeur de retour : WebElementPromise
      </td>
    </tr>

    <tr id="browser-findElements">
      <td>
        `$browser.findElements(locator: $driver.Locator)`
      </td>

      <td>
        Planifiez une commande pour [rechercher plusieurs éléments sur la page](#locators).

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-waitForAndFindElement">
      <td>
        `$browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number)`
      </td>

      <td>
        Planifiez une commande pour attendre et [rechercher un élément sur la page](#locators), et une autre commande pour attendre qu&apos;il soit visible. Si non trouvé, Synthétique monitoring renvoie une erreur.

        La valeur du délai d&apos;expiration est facultative. Elle s&apos;applique séparément aux deux tâches de recherche de l&apos;élément et d&apos;attente de sa visibilité. Cela signifie que dans le pire des cas, cette méthode peut prendre jusqu&apos;à deux fois la valeur de délai d&apos;expiration fournie. La valeur de délai d&apos;expiration par défaut est de 1 000 ms (1 seconde).

        Valeur de retour : WebElementPromise
      </td>
    </tr>

    <tr id="browser-get">
      <td>
        `$browser.get(url: string)`
      </td>

      <td>
        Charge une page Web dans un navigateur Synthétique.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-getAllWindowHandles">
      <td>
        `$browser.getAllWindowHandles()`
      </td>

      <td>
        Planifie une commande pour récupérer la liste actuelle des poignées de fenêtre disponibles.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-getCapabilities">
      <td>
        `$browser.getCapabilities()`
      </td>

      <td>
        Une promesse qui se résoudra avec les capacités de l&apos;instance.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-getCurrentUrl">
      <td>
        `$browser.getCurrentUrl()`
      </td>

      <td>
        Planifie une commande pour récupérer l&apos;URL de la page actuelle.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-getHeaders">
      <td>
        `$browser.getHeaders()`
      </td>

      <td>
        Renvoie une carte des en-têtes actuellement configurés.

        Valeur de retour : carte
      </td>
    </tr>

    <tr id="browser-getPageSource">
      <td>
        `$browser.getPageSource()`
      </td>

      <td>
        Planifie une commande pour récupérer la source de la page actuelle. La source de la page renvoyée est une représentation du DOM sous-jacent. Ne vous attendez pas à ce qu&apos;il soit formaté ou échappé de la même manière que la réponse envoyée depuis le serveur Web.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-getSession">
      <td>
        `$browser.getSession()`
      </td>

      <td>
        Une promesse pour la séance de ce client.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-getTitle">
      <td>
        `$browser.getTitle()`
      </td>

      <td>
        Planifie une commande pour récupérer le titre de la page actuelle.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-getWindowHandle">
      <td>
        `$browser.getWindowHandle()`
      </td>

      <td>
        Planifie une commande pour récupérer le handle de fenêtre actuel.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-manage">
      <td>
        `$browser.manage()`
      </td>

      <td>
        L&apos;interface d&apos;options pour cette instance. Vous pouvez gérer [les cookies, les délais d&apos;expiration et d&apos;autres options de fenêtre](#options).

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-navigate">
      <td>
        `$browser.navigate()`
      </td>

      <td>
        L&apos;[interface de navigation (historique des fonctions du navigateur)](#navigate) pour cette instance.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-schedule">
      <td>
        `$browser.schedule(command: ?, description: string)`
      </td>

      <td>
        Planifie une commande à exécuter par `CommandExecutor` de ce pilote.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-sleep">
      <td>
        `$browser.sleep()`
      </td>

      <td>
        Planifie une commande pour mettre le pilote en veille pendant la durée donnée.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-switchTo">
      <td>
        `$browser.switchTo()`
      </td>

      <td>
        L&apos;interface cible localisateur pour cette instance.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="browser-takeScreenshot">
      <td>
        `$browser.takeScreenshot()`
      </td>

      <td>
        Planifie une commande pour effectuer une capture d&apos;écran.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="browser-wait">
      <td>
        `$browser.wait(fn: $driver.Condition, timeout: number, opt_message: string)`
      </td>

      <td>
        Planifie une [commande pour attendre qu&apos;une condition soit remplie](#until), telle que définie par votre fonction fournie.

        Valeur de retour : WebElement
      </td>
    </tr>

    <tr id="browser-waitforpending">
      <td>
        `$browser.waitForPendingRequests(timeout: number)`
      </td>

      <td>
        Force le script à attendre que requests qui ont été initiées soient renvoyées, jusqu&apos;au délai d&apos;expiration. Utile pour suivre les ressources non bloquantes.

        Valeur de retour : promesse
      </td>
    </tr>
  </tbody>
</table>

## Liste de refus : utilisation de caractères génériques [#wildcard-use]

Si vous souhaitez ajouter un domaine à la liste de refus pour votre instance de navigateur, les caractères génériques doivent correspondre à la syntaxe de l&apos;URL à bloquer.

Une liste de refus globale `.com` doit contenir ces fonctions :

<table>
  <thead>
    <tr>
      <th>
        Fonction
      </th>

      <th style={{ width: "200px" }}>
        Action de blocage
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="options-manage-addCookie">
      <td>
        `$browser.addHostnameToBlacklist('*.com');`
      </td>

      <td>
        `a.com`
      </td>
    </tr>

    <tr>
      <td>
        `$browser.addHostnameToBlacklist('*.*.com');`
      </td>

      <td>
        `a.b.com`
      </td>
    </tr>

    <tr>
      <td>
        `$browser.addHostnameToBlacklist('*.*.*.com');`
      </td>

      <td>
        `a.b.c.com`
      </td>
    </tr>

    <tr>
      <td>
        `$browser.addHostnameToBlacklist('www.*.com');`
      </td>

      <td>
        `www.a.com`
      </td>
    </tr>

    <tr>
      <td>
        `$browser.addHostnameToBlacklist('www.*.*.com');`
      </td>

      <td>
        `www.a.b.com`
      </td>
    </tr>

    <tr>
      <td>
        `$browser.addHostnameToBlacklist('www.*.*.*.com');`
      </td>

      <td>
        `www.a.b.c.com`
      </td>
    </tr>
  </tbody>
</table>

## Options : Gérer l&apos;instance du navigateur [#options]

Ces fonctions gèrent les options de votre instance de navigateur, telles que les cookies, les délais d&apos;expiration et la taille de la fenêtre. Accédez à ces options via la fonction [`$browser.manage()`](#browser-manage) .

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="options-manage-addCookie">
      <td>
        `$browser.manage().addCookie(spec: object)`
      </td>

      <td>
        Planifie une commande pour ajouter un cookie.

        `spec` est un objet d&apos;enregistrement décrivant un cookie de navigateur. Pour plus d&apos;informations, consultez la [documentation Webdriver](https://www.w3.org/TR/webdriver1/#cookies).

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-deleteAllCookies">
      <td>
        `$browser.manage().deleteAllCookies()`
      </td>

      <td>
        Planifie une commande pour supprimer tous les cookies visibles sur la page actuelle.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-deleteCookie">
      <td>
        `$browser.manage().deleteCookie(name: string)`
      </td>

      <td>
        Planifie une commande pour supprimer le cookie avec le nom donné. Cette commande est un no-op s&apos;il n&apos;y a pas de cookie avec le nom donné visible sur la page actuelle.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-getCookie">
      <td>
        `$browser.manage().getCookie(name: string)`
      </td>

      <td>
        Planifie une commande pour récupérer le cookie avec le nom donné. Renvoie null s&apos;il n&apos;existe pas de tel cookie. Le cookie sera renvoyé sous forme d&apos;objet JSON comme décrit par le protocole Webdriver.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-getCookies">
      <td>
        `$browser.manage().getCookies()`
      </td>

      <td>
        Planifie une commande pour récupérer tous les cookies visibles sur la page actuelle. New Relic Syntheticcs renvoie chaque cookie sous forme d&apos;objet JSON comme décrit par le protocole Webdriver.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-timeouts-implicitlyWait">
      <td>
        `$browser.manage().timeouts().implicitlyWait(ms: number)`
      </td>

      <td>
        Spécifie la durée pendant laquelle le pilote doit attendre lors de la recherche d&apos;un élément s&apos;il n&apos;est pas immédiatement présent. La définition du délai d’attente sur `0` désactive l’attente implicite.

        Soyez prudent lorsque vous augmentez le délai d&apos;attente, car cela augmentera les temps d&apos;exécution des tests, en particulier avec des stratégies de localisation plus lentes comme XPath. La valeur par défaut est de 10 secondes.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-timeouts-pageLoadTimeout">
      <td>
        `$browser.manage().timeouts().pageLoadTimeout(ms: number)`
      </td>

      <td>
        Définit la durée d&apos;attente pour que le chargement d&apos;une page soit terminé avant de renvoyer une erreur. Si le délai d&apos;attente est négatif, le chargement des pages peut durer jusqu&apos;à 180 secondes. La valeur par défaut est de 60 secondes.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-timeouts-setScriptTimeout">
      <td>
        `$browser.manage().timeouts().setScriptTimeout(ms: number)`
      </td>

      <td>
        Définit la durée d&apos;attente, en millisecondes, pour qu&apos;un script asynchrone termine son exécution avant de renvoyer une erreur. La valeur par défaut est de 30 secondes.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-window-getPosition">
      <td>
        `$browser.manage().window().getPosition()`
      </td>

      <td>
        Récupère la position actuelle de la fenêtre, par rapport au coin supérieur gauche de l&apos;écran.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-window-getSize">
      <td>
        `$browser.manage().window().getSize()`
      </td>

      <td>
        Récupère la taille actuelle de la fenêtre.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-window-maximize">
      <td>
        `$browser.manage().window().maximize()`
      </td>

      <td>
        Maximise la fenêtre actuelle.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-window-setPosition">
      <td>
        `$browser.manage().window().setPosition(x: number, y: number)`
      </td>

      <td>
        Repositionne la fenêtre actuelle.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-window-setSize">
      <td>
        `$browser.manage().window().setSize(width: number, height: number)`
      </td>

      <td>
        Redimensionne la fenêtre actuelle.

        Valeur de retour : promesse
      </td>
    </tr>
  </tbody>
</table>

## localisateur : Rechercher un élément de page [#locators]

Les localisateurs sont une collection de fonctions d&apos;usine permettant de créer une instance `locator` . localisateur recherche des éléments DOM , qui peuvent être passés à des fonctions telles que [`$browser.findElement`](#browser-findElement). Appelez-les via `$driver.By`.

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="driver-by-className">
      <td>
        `$driver.By.className(className: string)`
      </td>

      <td>
        Localise un élément qui a un nom de classe spécifique. Le localisateur renvoyé équivaut à la recherche d&apos;éléments avec le sélecteur CSS `.class`.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="driver-by-css">
      <td>
        `$driver.By.css(cssName: string)`
      </td>

      <td>
        Localise un élément à l&apos;aide d&apos;un sélecteur CSS.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="driver-by-id">
      <td>
        `$driver.By.id(id: string)`
      </td>

      <td>
        Localise un élément par son ID.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="driver-by-linkText">
      <td>
        `$driver.By.linkText(linkText: string)`
      </td>

      <td>
        Localise les éléments de lien dont le texte visible correspond à la chaîne donnée.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="driver-by-js">
      <td>
        `$driver.By.js(js: string)`
      </td>

      <td>
        Localise un élément en évaluant une expression JavaScript.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="driver-by-name">
      <td>
        `$driver.By.name(name: string)`
      </td>

      <td>
        Localise les éléments dont l&apos;attribut name a la valeur donnée.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="driver-by-partialLinkText">
      <td>
        `$driver.By.partialLinkText(partialLinkText: string)`
      </td>

      <td>
        Localise les éléments de lien dont [getText](#webElement-getText) visible contient la sous-chaîne donnée.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="driver-by-tagName">
      <td>
        `$driver.By.tagName(tagName: string)`
      </td>

      <td>
        Localise les éléments avec un nom tag donné. Le localisateur renvoyé équivaut à utiliser la fonction DOM `getElementsByTagName` .

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="driver-by-xpath">
      <td>
        `$driver.By.xpath(xpath: string)`
      </td>

      <td>
        Localise les éléments correspondant à un sélecteur XPath.

        Valeur de retour : localisateur
      </td>
    </tr>
  </tbody>
</table>

## WebElement : Interagir avec l&apos;élément de page [#webelement]

Lorsqu&apos;une fonction telle que [`$browser.findElement`](#browser-findElement) ou [`$browser.waitForAndFindElement`](#browser-waitForAndFindElement) renvoie une référence WebElement, ces fonctions peuvent être utilisées pour interagir avec cet élément. Par exemple, vous pouvez cliquer sur des boutons, envoyer du texte aux entrées de formulaire et obtenir les attributs des éléments à tester.

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="webElement-click">
      <td>
        `click()`
      </td>

      <td>
        Clique sur cet élément.

        Valeur de retour : auto-référence
      </td>
    </tr>

    <tr id="webElement-sendKeys">
      <td>
        `sendKeys(var_args: ?)`
      </td>

      <td>
        Planifie une commande pour taper une séquence sur l&apos;élément DOM représenté par cette instance.

        Valeur de retour : WebElement
      </td>
    </tr>

    <tr id="webElement-getTagName">
      <td>
        `getTagName()`
      </td>

      <td>
        Planifie une commande pour interroger le nom tag/ nœud de cet élément.

        Valeur de retour : WebElement
      </td>
    </tr>

    <tr id="webElement-getCssValue">
      <td>
        `getCssValue(name: string)`
      </td>

      <td>
        Planifie une commande pour interroger le style calculer de l&apos;élément représenté par cette instance. Si l&apos;élément hérite du style nommé de son parent, le parent sera interrogé pour sa valeur. Dans la mesure du possible, les valeurs de couleur seront converties en leur représentation hexadécimale (par exemple, `#00ff00` au lieu de `rgb(0, 255, 0)`).

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-getAttribute">
      <td>
        `getAttribute(name: string)`
      </td>

      <td>
        Planifie une commande pour interroger la valeur de l&apos;attribut donné de l&apos;élément.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-getText">
      <td>
        `getText(name: string)`
      </td>

      <td>
        Récupère le `innerText` visible (non masqué par CSS) de cet élément, y compris les sous-éléments, sans aucun espace blanc de début ou de fin.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-getSize">
      <td>
        `getSize()`
      </td>

      <td>
        Planifie une commande pour calculer la taille de la boîte englobante de cet élément, en pixels.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-getLocation">
      <td>
        `getLocation()`
      </td>

      <td>
        Planifie une commande pour calculer l&apos;emplacement de cet élément, dans l&apos;espace de la page.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-isEnabled">
      <td>
        `isEnabled()`
      </td>

      <td>
        Planifie une commande pour demander si l&apos;élément DOM représenté par cette instance est activé, comme indiqué par l&apos;attribut désactivé.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-isSelected">
      <td>
        `isSelected()`
      </td>

      <td>
        Planifie une commande pour demander si cet élément est sélectionné.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-submit">
      <td>
        `submit()`
      </td>

      <td>
        Planifie une commande pour soumettre le formulaire contenant cet élément (ou cet élément s&apos;il s&apos;agit d&apos;un élément `FORM` ). Cette commande est nulle si l&apos;élément n&apos;est pas contenu dans un formulaire.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-clear">
      <td>
        `clear()`
      </td>

      <td>
        Planifie une commande pour effacer la valeur de cet élément.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-isDisplayed">
      <td>
        `isDisplayed()`
      </td>

      <td>
        Planifie une commande pour tester si cet élément est actuellement affiché.

        Valeur de retour : promesse
      </td>
    </tr>
  </tbody>
</table>

## ActionSequence : Lier plusieurs actions [#actionsequence]

Les séquences d&apos;actions peuvent créer une interaction complexe entre l&apos;utilisateur et votre site Web.

* Pour créer une nouvelle séquence d’actions, utilisez [`$browser.actions()`](#browser-actions).
* Pour lier plusieurs actions ensemble dans une séquence, incluez [`perform()`](#actionSequence-perform) après chacune. Cela exécute puis termine des séquences individuelles, y compris des séquences à action unique.

Le tableau suivant contient une liste des actions disponibles. Pour plus d&apos;informations, consultez la [documentation Webdriver ActionSequence sur GitHub](https://github.com/browserstack/selenium-webdriver-nodejs/blob/master/docs/class_webdriver_ActionSequence.html).

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="actionSequence-click">
      <td>
        `click(opt_elementOrButton: ?, opt_button: ?)`
      </td>

      <td>
        Clique sur un bouton de la souris. Si un élément est fourni, la souris sera d&apos;abord déplacée au centre de cet élément. Ceci est équivalent à [`WebElement.click()`](#webElement-click).

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-doubleClick">
      <td>
        `doubleClick(opt_elementOrButton: ?, opt_button: ?)`
      </td>

      <td>
        Double-clique sur un bouton de la souris. Si un élément est fourni, la souris sera d&apos;abord déplacée au centre de cet élément.

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-dragAndDrop">
      <td>
        `dragAndDrop(element: ?, location: ?)`
      </td>

      <td>
        Fonction pratique pour effectuer une manœuvre de glisser-déposer. L&apos;élément cible peut être déplacé vers l&apos;emplacement d&apos;un autre élément, ou par un décalage (en pixels). L&apos;emplacement est un objet avec deux propriétés `x` et `y`: `{x: x_offset, y: y_offset}`.

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-keyDown">
      <td>
        `keyDown(key: ?)`
      </td>

      <td>
        Effectue une pression sur une touche de modification. Doit être l’un des suivants : `ALT`, `CONTROL`, `SHIFT`, `COMMAND` ou `META`. La touche de modification n&apos;est pas désactivée tant que [`keyUp()`](#actionSequence-keyUp) ou [`sendKeys()`](#actionSequence-sendKeys) n&apos;est pas appelé. La touche enfoncée sera ciblée sur l&apos;élément actuellement focalisé.

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-keyUp">
      <td>
        `keyUp(key: ?)`
      </td>

      <td>
        Effectue une sortie de touche de modification. La sortie vise l&apos;élément actuellement focalisé.

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-mouseDown">
      <td>
        `mouseDown(opt_elementOrButton: ?, opt_button: ?)`
      </td>

      <td>
        Appuie sur un bouton de la souris. Le bouton de la souris ne sera pas désactivé tant que [`mouseUp`](#actionSequence-mouseUp) ne sera pas appelé, que cet appel soit effectué dans cette séquence ou dans une autre. Le comportement d&apos;un événement hors service (comme l&apos;appel `mouseDown()` ou `click()` lorsque le bouton est déjà maintenu enfoncé) n&apos;est pas défini.

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-mouseUp">
      <td>
        `mouseUp(opt_elementOrButton: ?, opt_button: ?)`
      </td>

      <td>
        sortir un bouton de la souris. Le comportement n&apos;est pas défini pour l&apos;appel de cette fonction sans un appel préalable à [`mouseDown()`](#actionSequence-mouseDown).

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-mouseMove">
      <td>
        `mouseMove(location: ?, offset: ?)`
      </td>

      <td>
        Déplace la souris. L&apos;emplacement vers lequel se déplacer peut être spécifié en termes de position actuelle de la souris, d&apos;un décalage par rapport au coin supérieur gauche d&apos;un élément ou d&apos;un élément (auquel cas le milieu de l&apos;élément est utilisé).

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-perform">
      <td>
        `perform()`
      </td>

      <td>
        Exécute cette séquence d&apos;actions.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="actionSequence-sendKeys">
      <td>
        `sendKeys(args: ?)`
      </td>

      <td>
        Simule la saisie de plusieurs touches. Chaque touche de modification rencontrée dans la séquence ne sera pas désactivée jusqu&apos;à ce qu&apos;elle soit rencontrée à nouveau. Tous les événements clés seront ciblés sur l&apos;élément actuellement focalisé. Pour obtenir la liste complète des clés non alphanumériques prises en charge, consultez la [documentation de la clé d&apos;énumération Webdriver sur GitHub](https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/Keys.html).

        Valeur de retour : actionsequence
      </td>
    </tr>
  </tbody>
</table>

## Promesses : Lier les actions en séquences [#promises]

Vous pouvez également exécuter des fonctions directement sur les promesses. Synthétique monitoring est un environnement Node.js natif et utilise les promesses standards Node.js

Ces fonctions évaluent l’état des promesses, les annulent, etc. En particulier, vous pouvez créer des séquences d&apos;actions avec la fonction [`then()`](#promises-then) et ses sœurs, [`finally()`](#promises-thenFinally) et [`catch()`](#promises-thenCatch). Pour plus d&apos;informations, voir [Actions de séquence](/docs/synthetics/new-relic-synthetics/scripting-monitors/write-scripted-browsers#sequence).

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="promises-isPending">
      <td>
        `isPending()`
      </td>

      <td>
        La valeur de cette promesse est-elle encore en cours de calcul ?

        Valeur de retour : booléen
      </td>
    </tr>

    <tr id="promises-then">
      <td>
        `then(opt_callback: fn(T: ?), opt_errback: fn())`
      </td>

      <td>
        Enregistre les auditeurs lorsque cette instance est résolue. Il s&apos;agit de la fonction de base utilisée pour lier des actions synchrones dans votre script.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="promises-thenFinally">
      <td>
        `finally(callback: fn())`
      </td>

      <td>
        Enregistre un écouteur à invoquer lorsque cette promesse est résolue, que la valeur de la promesse ait été calculée avec succès ou non.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="promises-thenCatch">
      <td>
        `catch(callback: fn())`
      </td>

      <td>
        Enregistre un auditeur pour le cas où cette promesse est rejetée.

        Valeur de retour : promesse
      </td>
    </tr>
  </tbody>
</table>

## Naviguer : parcourir l&apos;historique du navigateur [#promises]

La fonction `$browser.navigate()` expose un certain nombre de fonctions qui vous permettent de vous déplacer en arrière et en avant dans l&apos;historique de votre navigateur, d&apos;actualiser votre page et de naviguer vers de nouvelles pages.

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="navigate-back">
      <td>
        `back()`
      </td>

      <td>
        Revenir en arrière d&apos;une étape dans l&apos;historique du navigateur.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="navigate-forward">
      <td>
        `forward()`
      </td>

      <td>
        Avancer d&apos;une étape dans l&apos;historique du navigateur.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="navigate-refresh">
      <td>
        `refresh()`
      </td>

      <td>
        Rafraîchir la page actuelle.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="navigate-to">
      <td>
        `to(string: url)`
      </td>

      <td>
        Charger une nouvelle page Web dans la fenêtre actuelle du navigateur. `$browser.navigate().to()` est équivalent à `$browser.get()`.

        Valeur de retour : void
      </td>
    </tr>
  </tbody>
</table>

## Conditions : Pause et attente des conditions [#until]

<Callout variant="tip">
  Vous pouvez en apprendre plus sur les attentes dans Sélénium [ici](https://www.selenium.dev/documentation/en/webdriver/waits/).
</Callout>

Utilisé avec `$browser.wait`, `until` interrompt l&apos;exécution de votre script jusqu&apos;à ce que la condition soit remplie. Pour plus d&apos;informations, consultez [la documentation Webdriver `until` de sélénium](http://www.seleniumhq.org/docs/04_webdriver_advanced.jsp).

Les fonctions suivantes sont disponibles pour `$driver.until.Condition`:

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="conditions-ableToSwitchToFrame">
      <td>
        `ableToSwitchToFrame(frame: ?)`
      </td>

      <td>
        Crée une condition qui attendra que le pilote d&apos;entrée puisse basculer vers le cadre désigné. Le cadre cible peut être spécifié comme :

        * Un index numérique dans `window.frames` pour la trame actuelle

        * Un `webdriver.WebElement`, qui doit référencer un élément `FRAME` ou `IFRAME` sur la page actuelle

        * Un localisateur qui peut être utilisé pour localiser d&apos;abord un `FRAME` ou `IFRAME` sur la page actuelle avant de tenter d&apos;y accéder

          Une fois cette condition résolue avec succès, le conducteur pourra se concentrer sur le nouveau cadre.

          Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-alertIsPresent">
      <td>
        `alertIsPresent()`
      </td>

      <td>
        Crée une condition qui attend qu&apos;une alerte soit ouverte. En cas de succès, la promesse renvoyée sera remplie avec le handle de l&apos;alerte ouverte.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementIsDisabled">
      <td>
        `elementIsDisabled(element: $driver.WebElement)`
      </td>

      <td>
        Crée une condition qui attendra que l&apos;élément donné soit désactivé.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementIsEnabled">
      <td>
        `elementIsEnabled(element: $driver.WebElement)`
      </td>

      <td>
        Crée une condition qui attendra que l&apos;élément donné soit activé.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementIsNotVisible">
      <td>
        `elementIsNotVisible(element: $driver.WebElement)`
      </td>

      <td>
        Crée une condition qui attendra que l&apos;élément donné soit dans le DOM, mais non visible pour l&apos;utilisateur.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementIsVisible">
      <td>
        `elementIsVisible(element: $driver.WebElement)`
      </td>

      <td>
        Crée une condition qui attendra que l&apos;élément donné devienne visible.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementIsSelected">
      <td>
        `elementIsSelected(element: $driver.WebElement)`
      </td>

      <td>
        Crée une condition qui attendra que l&apos;élément donné soit sélectionné.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementLocated">
      <td>
        `elementLocated(element: $driver.Locator)`
      </td>

      <td>
        Crée une condition qui bouclera jusqu&apos;à ce qu&apos;un élément soit trouvé avec le localisateur donné.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementsLocated">
      <td>
        `elementsLocated(element: $driver.Locator)`
      </td>

      <td>
        Crée une condition qui bouclera jusqu&apos;à ce qu&apos;au moins un élément soit trouvé avec le localisateur donné.

        Valeur de retour : condition

        n
      </td>
    </tr>

    <tr id="conditions-elementTextContains">
      <td>
        `elementTextContains(element: $driver.WebElement, substr: string)`
      </td>

      <td>
        Crée une condition qui attendra que le texte visible de l&apos;élément donné contienne la sous-chaîne donnée.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementTextIs">
      <td>
        `elementTextIs(element: $driver.WebElement, text: string)`
      </td>

      <td>
        Sensible aux majuscules et minuscules. Crée une condition qui attendra que le texte visible de l&apos;élément donné corresponde exactement au texte donné.

        Valeur de retour : condition

        n
      </td>
    </tr>

    <tr id="conditions-elementTextMatches">
      <td>
        `elementTextMatches(element: $driver.WebElement, regex: string)`
      </td>

      <td>
        Crée une condition qui attendra que le texte visible de l&apos;élément donné corresponde à une expression régulière.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-stalenessOf">
      <td>
        `stalenessOf(element: $driver.WebElement)`
      </td>

      <td>
        Crée une condition qui attendra que l&apos;élément donné devienne obsolète. Un élément est considéré comme obsolète une fois qu&apos;il est supprimé du DOM ou qu&apos;une nouvelle page a été chargée.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-titleContains">
      <td>
        `titleContains(substr: string)`
      </td>

      <td>
        Crée une condition qui attendra que le titre de la page actuelle contienne la sous-chaîne donnée.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-titleIs">
      <td>
        `titleIs(title: string)`
      </td>

      <td>
        Crée une condition qui attendra que le titre de la page actuelle corresponde à la valeur donnée.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-titleMatches">
      <td>
        `titleMatches(regex: string)`
      </td>

      <td>
        Crée une condition qui attendra que le titre de la page actuelle corresponde aux expressions régulières données.

        Valeur de retour : condition
      </td>
    </tr>
  </tbody>
</table>