---
title: Référence du navigateur scripté Synthétique (versions de moniteur 0.4.x ou inférieures)
tags:
  - Synthetics
  - Synthetic monitoring
  - Scripting monitors
metaDescription: 'Synthetic scripted monitors version 0.4.0 or lower: Every function available for monitor versions 0.4.0 and below.'
freshnessValidatedDate: never
translationType: machine
---

Ce document concerne les versions 0.4.x ou inférieures du moniteur Synthétique. Voir également la documentation des [versions 0.5 ou 0.6.0 du monitorer Synthétique](/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050) et [la version 100 et plus récente du monitorer Chrome ](/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetic-scipted-browser-reference-monitor-versions-chrome100).

<Callout variant="important">
  À compter du 26 août 2024, vous ne pouvez plus créer de nouveaux moniteurs à l&apos;aide legacy runtimes sur des sites publics ou privés. Le 22 octobre 2024, nous mettrons [fin à la vie](/whats-new/2024/04/whats-new-04-09-eol-synthetics-runtime-cpm) des versions conteneurisées subordonnées privées (appels par minute) et legacy versions synthétiques du runtime.

  * Pour un emplacement public, utilisez [l&apos;UI de mise à niveau de l&apos;environnement d&apos;exécution](/docs/synthetics/synthetic-monitoring/using-monitors/runtime-upgrade-ui/) pour mettre à jour votre moniteur avec les environnements d&apos;exécution les plus récents.
  * Pour les sites privés, veuillez consulter nos [étapes de migration recommandées](/docs/synthetics/synthetic-monitoring/private-locations/job-manager-transition-guide/#monitorMigration) pour éviter la dégradation du moniteur.
</Callout>

Pour quelques exemples d&apos;utilisation courante, voir [Introduction au moniteur de navigateur scripté](/docs/synthetics/synthetic-monitoring/scripting-monitors/introduction-scripted-browser-monitors).

## Présentation

[Les navigateurs scriptés](/docs/synthetics/new-relic-synthetics/scripting-monitors/write-scripted-browsers) Synthétique vous donnent accès aux [API Sélénium Webdriver 2.47.0](http://nr-synthetics-sw-jsdoc.s3-website-us-east-1.amazonaws.com/) via les variables `$driver` et `$browser`. En particulier:

* `$driver` fournit toutes les exportations du module `selenium-webdriver` (par exemple, `ActionSequence`, `Button`, `By`, `WebElement`, etc.).
* `$browser` est une instance de `selenium-webdriver.WebDriver()` à saveur Synthétique : elle expose les principales API de base `WebDriver` comme `get()` et `findElement()`, ainsi que certaines API personnalisées de Synthétique.

Ce document décrit les fonctions disponibles pour Synthétique moniteur de navigateur scripté version 0.4.0 ou inférieure. Pour la documentation la plus récente du moniteur, consultez [la documentation du moniteur version 0.5.0+](/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050/).

Autres documents pertinents :

* Pour en savoir plus sur le script Synthétique, voir [Écrire des navigateurs scriptés](/docs/synthetics/new-relic-synthetics/scripting-monitors/write-scripted-browsers).
* Pour des exemples de scripts, voir [Exemples de navigateurs scriptés](/docs/synthetics/new-relic-synthetics/scripting-monitors/scripted-browser-examples).
* Pour plus d&apos;informations sur les versions du moniteur et les différences d&apos;exécution, consultez [Environnements d&apos;exécution](/docs/synthetics/new-relic-synthetics/scripting-monitors/scripted-monitor-runtime-environment).
* Pour afficher et partager des exemples de navigateur scripté, consultez les sujets étiquetés [synthetic-script](https://forum.newrelic.com/s/?c__tags=%5B%7B%22id%22%3A%22a9P8W0000004KS5UAM%22%2C%22sObjectType%22%3A%22Tag__c%22%2C%22subtitle%22%3A%22%22%2C%22title%22%3A%22syntheticsscript%22%2C%22titleFormatted%22%3A%22%3Cstrong%3Esyn%3C%2Fstrong%3Etheticsscript%22%2C%22subtitleFormatted%22%3A%22%22%2C%22icon%22%3A%22standard%3Adefault%22%7D%5D) dans [le forum d&apos;assistance](https://discuss.newrelic.com/c/support-products-agents/synthetics) de New Relic.

## Fonctions de niveau supérieur : créez votre script [#structure]

New Relic appelle les fonctions de niveau supérieur directement depuis votre instance `$browser` . Ils offrent une large gamme de fonctionnalités couvrant de nombreuses actions scriptables de base.

<table>
  <thead>
    <tr>
      <th>
        Fonction
      </th>

      <th style={{ width: "150px" }}>
        Valeur de retour
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="browser-actions">
      <td>
        `$browser.actions()`

        Crée une nouvelle séquence d&apos;action à l&apos;aide de ce pilote. Pour obtenir la liste des actions disponibles, voir [ActionSequence : Lier plusieurs actions](#actionsequence).
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-addHeader">
      <td>
        `$browser.addHeader(headerKey: string, headerValue: string)`

        Ajoute l&apos;en-tête `headerKey` avec la valeur `headerValue` à l&apos;exécution.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-addHeaders">
      <td>
        `$browser.addHeaders(headers: ?)`

        Ajoute une carte d’en-têtes à l’exécution.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-deleteHeader">
      <td>
        `$browser.deleteHeader(header: string)`

        Supprime un en-tête spécifique de l&apos;exécution.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-deleteHeaders">
      <td>
        `$browser.deleteHeaders(header: [string])`

        Supprime tous les en-têtes de l&apos;argument lors de l&apos;exécution.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-addHostnameToBlacklist">
      <td>
        `$browser.addHostnameToBlacklist(hostname: string)`

        Interdit un nom d&apos;hôte. Permet d&apos;utiliser [des caractères génériques](#wildcard-use).
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-addHostnamesToBlacklist">
      <td>
        `$browser.addHostnamesToBlacklist(hostnameArr: [string])`

        Interdit tout nom d&apos;hôte dans un éventail d&apos;arguments. Permet d&apos;utiliser [des caractères génériques](#wildcard-use).
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-addHostnameToWhitelist">
      <td>
        `$browser.addHostnameToWhitelist(hostname: string)`

        Permet un nom d&apos;hôte bloqué par défaut dans monitoring Synthétique.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-addHostnamesToWhitelist">
      <td>
        `$browser.addHostnamesToWhitelist(hostnameArr: [string])`

        Permet tout nom d&apos;hôte en argumentation.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-deleteHostnameFromBlacklist">
      <td>
        `$browser.deleteHostnameFromBlacklist(hostname: string)`

        Supprime un nom d&apos;hôte de la liste noire de cette instance de navigateur.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-deleteHostnamesFromBlacklist">
      <td>
        `$browser.deleteHostnamesFromBlacklist(hostnameArr: [string])`

        Supprime tous les noms d&apos;hôte en argument de la liste non autorisée.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-deleteHostnameFromWhitelist">
      <td>
        `$browser.deleteHostnameFromWhitelist(hostnameArr: [string])`

        Supprime un nom d&apos;hôte de la liste autorisée de cette instance de navigateur.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-deleteHostnamesFromWhitelist">
      <td>
        `$browser.deleteHostnamesFromWhitelist(hostnameArr: [string])`

        Supprime tous les noms d&apos;hôte en argument de la liste autorisée de cette instance de navigateur.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-executeAsyncScript">
      <td>
        `$browser.executeAsyncScript(script: ?, var_args: ?)`

        Planifie une commande pour exécuter du JavaScript asynchrone dans le contexte du cadre ou de la fenêtre actuellement sélectionné.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-executeScript">
      <td>
        `$browser.executeScript(script: ?, var_args: ?)`

        Planifie une commande pour exécuter JavaScript dans le contexte du cadre ou de la fenêtre actuellement sélectionné.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-findElement">
      <td>
        `$browser.findElement(locator: $driver.Locator)`

        Planifiez une commande pour [rechercher un élément sur la page](#locators). S&apos;il n&apos;est pas trouvé, New Relic renvoie une erreur.
      </td>

      <td>
        Élément Web
      </td>
    </tr>

    <tr id="browser-findElements">
      <td>
        `$browser.findElements(locator: $driver.Locator)`

        Planifiez une commande pour [rechercher plusieurs éléments sur la page](#locators).
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-waitForAndFindElement">
      <td>
        `$browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number)`

        Planifiez une commande pour attendre et [rechercher un élément sur la page](#locators), et une autre commande pour attendre qu&apos;il soit visible. S&apos;il n&apos;est pas trouvé, New Relic renvoie une erreur. La valeur du délai d&apos;expiration est facultative et s&apos;applique séparément aux deux tâches de recherche de l&apos;élément et d&apos;attente de sa visibilité. Cela signifie que dans le pire des cas, cette méthode peut prendre jusqu&apos;à deux fois la valeur de délai d&apos;expiration fournie. La valeur de délai d&apos;expiration par défaut est de 1 000 ms (1 seconde).
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-get">
      <td>
        `$browser.get(url: string)`

        Charge une page Web dans un navigateur Synthétique.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-getAllWindowHandles">
      <td>
        `$browser.getAllWindowHandles()`

        Planifie une commande pour récupérer la liste actuelle des poignées de fenêtre disponibles.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-getCapabilities">
      <td>
        `$browser.getCapabilities()`

        Une promesse qui se résoudra avec les capacités de l&apos;instance.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-getCurrentUrl">
      <td>
        `$browser.getCurrentUrl()`

        Planifie une commande pour récupérer l&apos;URL de la page actuelle.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-getHeaders">
      <td>
        `$browser.getHeaders()`

        Renvoie une carte des en-têtes actuellement configurés.
      </td>

      <td>
        carte
      </td>
    </tr>

    <tr id="browser-getPageSource">
      <td>
        `$browser.getPageSource()`

        Planifie une commande pour récupérer la source de la page actuelle. La source de la page renvoyée est une représentation du DOM sous-jacent ; ne vous attendez pas à ce qu&apos;elle soit formatée ou échappée de la même manière que la réponse envoyée depuis le serveur Web.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-getSession">
      <td>
        `$browser.getSession()`

        Une promesse pour la séance de ce client.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-getTitle">
      <td>
        `$browser.getTitle()`

        Planifie une commande pour récupérer le titre de la page actuelle.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-getWindowHandle">
      <td>
        `$browser.getWindowHandle()`

        Planifie une commande pour récupérer le handle de fenêtre actuel.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-isElementPresent">
      <td>
        `$browser.isElementPresent(locatorOrElement: $driver.Locator)`

        Planifie une commande pour tester si un élément est présent sur la page. Si un élément DOM est donné, cette fonction vérifiera s&apos;il appartient au document sur lequel le pilote se concentre actuellement. Sinon, la fonction testera si au moins un élément peut être trouvé avec les critères de recherche donnés.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-manage">
      <td>
        `$browser.manage()`

        L&apos;interface d&apos;options pour cette instance. Vous pouvez gérer [les cookies, les délais d&apos;expiration et d&apos;autres options de fenêtre](#options).
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-navigate">
      <td>
        `$browser.navigate()`

        L&apos;[interface de navigation (historique des fonctions du navigateur)](#navigate) pour cette instance.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-schedule">
      <td>
        `$browser.schedule(command: ?, description: string)`

        Planifie une commande à exécuter par le CommandExecutor de ce pilote.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-sleep">
      <td>
        `$browser.sleep()`

        Planifie une commande pour mettre le pilote en veille pendant la durée donnée.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-switchTo">
      <td>
        `$browser.switchTo()`

        L&apos;interface cible localisateur pour cette instance.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="browser-takeScreenshot">
      <td>
        `$browser.takeScreenshot()`

        Planifiez une commande pour effectuer une capture d&apos;écran.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="browser-wait">
      <td>
        `$browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string)`

        Planifie une [commande pour attendre qu&apos;une condition soit remplie](#until), telle que définie par une fonction fournie par l&apos;utilisateur.
      </td>

      <td>
        élément web
      </td>
    </tr>

    <tr id="browser-waitforpending">
      <td>
        `$browser.waitForPendingRequests(timeout: number)`

        Force le script à attendre que requests qui ont été initiées soient renvoyées, jusqu&apos;au délai d&apos;expiration. Utile pour suivre les ressources non bloquantes.
      </td>

      <td>
        promesse
      </td>
    </tr>
  </tbody>
</table>

## Liste d&apos;interdiction : utilisation de caractères génériques [#wildcard-use]

L&apos;interdiction du domaine pour votre instance de navigateur nécessite que des caractères génériques correspondent à la syntaxe de l&apos;URL à bloquer.

Une liste globale `.com` non autorisée doit contenir ces fonctions :

<table>
  <thead>
    <tr>
      <th>
        Fonction
      </th>

      <th style={{ width: "175px" }}>
        Action de blocage
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="options-manage-addCookie">
      <td>
        `$browser.addHostnameToBlacklist('*.com');`
      </td>

      <td>
        `a.com`
      </td>
    </tr>

    <tr>
      <td>
        `$browser.addHostnameToBlacklist('*.*.com');`
      </td>

      <td>
        `a.b.com`
      </td>
    </tr>

    <tr>
      <td>
        `$browser.addHostnameToBlacklist('*.*.*.com');`
      </td>

      <td>
        `a.b.c.com`
      </td>
    </tr>

    <tr>
      <td>
        `$browser.addHostnameToBlacklist('www.*.com');`
      </td>

      <td>
        `www.a.com`
      </td>
    </tr>

    <tr>
      <td>
        `$browser.addHostnameToBlacklist('www.*.*.com');`
      </td>

      <td>
        `www.a.b.com`
      </td>
    </tr>

    <tr>
      <td>
        `$browser.addHostnameToBlacklist('www.*.*.*.com');`
      </td>

      <td>
        `www.a.b.c.com`
      </td>
    </tr>
  </tbody>
</table>

## Options : Gérer l&apos;instance du navigateur [#options]

Ces fonctions gèrent les options de votre instance de navigateur telles que les cookies, les délais d&apos;expiration et la taille de la fenêtre. Accédez à ces options via la fonction [`$browser.manage()`](#browser-manage) .

<table>
  <thead>
    <tr>
      <th>
        Fonction
      </th>

      <th style={{ width: "150px" }}>
        Valeur de retour
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="options-manage-addCookie">
      <td>
        `$browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number)`

        Planifie une commande pour ajouter un cookie.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="options-manage-deleteAllCookies">
      <td>
        `$browser.manage().deleteAllCookies()`

        Planifie une commande pour supprimer tous les cookies visibles sur la page actuelle.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="options-manage-deleteCookie">
      <td>
        `$browser.manage().deleteCookie(name: string)`

        Planifie une commande pour supprimer le cookie avec le nom donné. Cette commande est un no-op s&apos;il n&apos;y a pas de cookie avec le nom donné visible sur la page actuelle.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="options-manage-getCookie">
      <td>
        `$browser.manage().getCookie(name: string)`

        Planifie une commande pour récupérer le cookie avec le nom donné. Renvoie null s&apos;il n&apos;existe pas de tel cookie. Le cookie sera renvoyé sous forme d&apos;objet JSON comme décrit par le protocole Webdriver.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="options-manage-getCookies">
      <td>
        `$browser.manage().getCookies()`

        Planifie une commande pour récupérer tous les cookies visibles sur la page actuelle. New Relic Syntheticcs renvoie chaque cookie sous forme d&apos;objet JSON comme décrit par le protocole Webdriver.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="options-manage-timeouts-implicitlyWait">
      <td>
        `$browser.manage().timeouts().implicitlyWait(ms: number)`

        Spécifie la durée pendant laquelle le pilote doit attendre lors de la recherche d&apos;un élément s&apos;il n&apos;est pas immédiatement présent. La définition du délai d’attente sur `0` désactive l’attente implicite.

        Soyez prudent lorsque vous augmentez le délai d&apos;attente, car cela augmentera les temps d&apos;exécution des tests, en particulier avec des stratégies de localisation plus lentes comme XPath. La valeur par défaut est de 10 secondes.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="options-manage-timeouts-pageLoadTimeout">
      <td>
        `$browser.manage().timeouts().pageLoadTimeout(ms: number)`

        Définit la durée d&apos;attente pour que le chargement d&apos;une page soit terminé avant de renvoyer une erreur. Si le délai d&apos;attente est négatif, le chargement des pages peut durer jusqu&apos;à 180 secondes. La valeur par défaut est de 60 secondes.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="options-manage-timeouts-setScriptTimeout">
      <td>
        `$browser.manage().timeouts().setScriptTimeout(ms: number)`

        Définit la durée d&apos;attente, en millisecondes, pour qu&apos;un script asynchrone termine son exécution avant de renvoyer une erreur. La valeur par défaut est de 30 secondes.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="options-manage-window-getPosition">
      <td>
        `$browser.manage().window().getPosition()`

        Récupère la position actuelle de la fenêtre, par rapport au coin supérieur gauche de l&apos;écran.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="options-manage-window-getSize">
      <td>
        `$browser.manage().window().getSize()`

        Récupère la taille actuelle de la fenêtre.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="options-manage-window-maximize">
      <td>
        `$browser.manage().window().maximize()`

        Maximise la fenêtre actuelle.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="options-manage-window-setPosition">
      <td>
        `$browser.manage().window().setPosition(x: number, y: number)`

        Repositionne la fenêtre actuelle.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="options-manage-window-setSize">
      <td>
        `$browser.manage().window().setSize(width: number, height: number)`

        Redimensionne la fenêtre actuelle.
      </td>

      <td>
        promesse
      </td>
    </tr>
  </tbody>
</table>

## localisateur : Rechercher un élément de page [#locators]

Les localisateurs sont une collection de fonctions d&apos;usine permettant de créer une instance `locator` . localisateur recherche des éléments DOM , qui peuvent être passés à des fonctions telles que [`$browser.findElement`](#browser-findElement) ou [`$browser.isElementPresent`](#browser-isElementPresent). Appelez-les via `$driver.By`.

<table>
  <thead>
    <tr>
      <th>
        Fonction
      </th>

      <th style={{ width: "150px" }}>
        Valeur de retour
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="driver-by-className">
      <td>
        `$driver.By.className(className: string)`

        Localise un élément qui a un nom de classe spécifique. Le localisateur renvoyé équivaut à la recherche d&apos;éléments avec le sélecteur CSS `.class`.
      </td>

      <td>
        localisateur
      </td>
    </tr>

    <tr id="driver-by-css">
      <td>
        `$driver.By.css(cssName: string)`

        Localise un élément à l&apos;aide d&apos;un sélecteur CSS.
      </td>

      <td>
        localisateur
      </td>
    </tr>

    <tr id="driver-by-id">
      <td>
        `$driver.By.id(id: string)`

        Localise un élément par son ID.
      </td>

      <td>
        localisateur
      </td>
    </tr>

    <tr id="driver-by-linkText">
      <td>
        `$driver.By.linkText(linkText: string)`

        Localise les éléments de lien dont le texte visible correspond à la chaîne donnée.
      </td>

      <td>
        localisateur
      </td>
    </tr>

    <tr id="driver-by-js">
      <td>
        `$driver.By.js(js: string)`

        Localise un élément en évaluant une expression JavaScript.
      </td>

      <td>
        localisateur
      </td>
    </tr>

    <tr id="driver-by-name">
      <td>
        `$driver.By.name(name: string)`

        Localise les éléments dont l&apos;attribut name a la valeur donnée.
      </td>

      <td>
        localisateur
      </td>
    </tr>

    <tr id="driver-by-partialLinkText">
      <td>
        `$driver.By.partialLinkText(partialLinkText: string)`

        Localise les éléments de lien dont [getText](#webElement-getText) visible contient la sous-chaîne donnée.
      </td>

      <td>
        localisateur
      </td>
    </tr>

    <tr id="driver-by-tagName">
      <td>
        `$driver.By.tagName(tagName: string)`

        Localise les éléments avec un nom tag donné. Le localisateur renvoyé équivaut à utiliser la fonction DOM `getElementsByTagName` .
      </td>

      <td>
        localisateur
      </td>
    </tr>

    <tr id="driver-by-xpath">
      <td>
        `$driver.By.xpath(xpath: string)`

        Localise les éléments correspondant à un sélecteur XPath.
      </td>

      <td>
        localisateur
      </td>
    </tr>
  </tbody>
</table>

## WebElement : Interagir avec l&apos;élément de page [#webelement]

Lorsqu&apos;une fonction telle que [`$browser.findElement`](#browser-findElement) ou [`$browser.waitForAndFindElement`](#browser-waitForAndFindElement) renvoie une référence WebElement, ces fonctions peuvent être utilisées pour interagir avec cet élément. Grâce à eux, vous pouvez cliquer sur des boutons, envoyer du texte aux entrées du formulaire et obtenir les attributs des éléments à tester.

<table>
  <thead>
    <tr>
      <th>
        Fonction
      </th>

      <th style={{ width: "150px" }}>
        Valeur de retour
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="webElement-click">
      <td>
        `click()`

        Clique sur cet élément.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="webElement-sendKeys">
      <td>
        `sendKeys(var_args: ?)`

        Planifie une commande pour taper une séquence sur l&apos;élément DOM représenté par cette instance.
      </td>

      <td>
        Élément Web
      </td>
    </tr>

    <tr id="webElement-getTagName">
      <td>
        `getTagName()`

        Planifie une commande pour interroger le nom tag/ nœud de cet élément.
      </td>

      <td>
        Élément Web
      </td>
    </tr>

    <tr id="webElement-getCssValue">
      <td>
        `getCssValue(name: string)`

        Planifie une commande pour interroger le style calculer de l&apos;élément représenté par cette instance. Si l&apos;élément hérite du style nommé de son parent, le parent sera interrogé pour sa valeur. Dans la mesure du possible, les valeurs de couleur seront converties en leur représentation hexadécimale (par exemple, `#00ff00` au lieu de `rgb(0, 255, 0)`).
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="webElement-getAttribute">
      <td>
        `getAttribute(name: string)`

        Planifie une commande pour interroger la valeur de l&apos;attribut donné de l&apos;élément.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="webElement-getText">
      <td>
        `getText(name: string)`

        Récupère le `innerText` visible (non masqué par CSS) de cet élément, y compris les sous-éléments, sans aucun espace blanc de début ou de fin.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="webElement-getSize">
      <td>
        `getSize()`

        Planifie une commande pour calculer la taille de la boîte englobante de cet élément, en pixels.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="webElement-getLocation">
      <td>
        `getLocation()`

        Planifie une commande pour calculer l&apos;emplacement de cet élément, dans l&apos;espace de la page.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="webElement-isEnabled">
      <td>
        `isEnabled()`

        Planifie une commande pour demander si l&apos;élément DOM représenté par cette instance est activé, comme indiqué par l&apos;attribut désactivé.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="webElement-isSelected">
      <td>
        `isSelected()`

        Planifie une commande pour demander si cet élément est sélectionné.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="webElement-submit">
      <td>
        `submit()`

        Planifie une commande pour soumettre le formulaire contenant cet élément (ou cet élément s&apos;il s&apos;agit d&apos;un élément `FORM` ). Cette commande est nulle si l&apos;élément n&apos;est pas contenu dans un formulaire.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="webElement-clear">
      <td>
        `clear()`

        Planifie une commande pour effacer la valeur de cet élément.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="webElement-isDisplayed">
      <td>
        `isDisplayed()`

        Planifie une commande pour tester si cet élément est actuellement affiché.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="webElement-getOuterHtml">
      <td>
        `getOuterHtml()`

        Planifie une commande pour récupérer le code HTML externe de cet élément.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="webElement-getInnerHtml">
      <td>
        `getInnerHtml()`

        Planifie une commande pour récupérer le code HTML interne de cet élément.
      </td>

      <td>
        promesse
      </td>
    </tr>
  </tbody>
</table>

## ActionSequence : Lier plusieurs actions [#actionsequence]

Les séquences d&apos;actions peuvent créer une interaction complexe entre l&apos;utilisateur et votre site Web.

* Pour créer une nouvelle séquence d’actions, utilisez [`$browser.actions()`](#browser-actions).
* Pour lier plusieurs actions ensemble dans une séquence, incluez [`perform()`](#actionSequence-perform) après chacune. Cela exécute puis termine des séquences individuelles, y compris des séquences à action unique.

Le tableau suivant contient une liste des actions disponibles. Pour plus d&apos;informations, consultez la [documentation des actions Webdriver](https://www.selenium.dev/documentation/webdriver/actions_api/).

<table>
  <thead>
    <tr>
      <th>
        Fonction
      </th>

      <th style={{ width: "150px" }}>
        Valeur de retour
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="actionSequence-click">
      <td>
        `click(opt_elementOrButton: ?, opt_button: ?)`

        Clique sur un bouton de la souris. Si un élément est fourni, la souris sera d&apos;abord déplacée au centre de cet élément. Ceci est équivalent à [`WebElement.click()`](#webElement-click).
      </td>

      <td>
        séquence d&apos;actions
      </td>
    </tr>

    <tr id="actionSequence-doubleClick">
      <td>
        `doubleClick(opt_elementOrButton: ?, opt_button: ?)`

        Double-clique sur un bouton de la souris. Si un élément est fourni, la souris sera d&apos;abord déplacée au centre de cet élément.
      </td>

      <td>
        séquence d&apos;actions
      </td>
    </tr>

    <tr id="actionSequence-dragAndDrop">
      <td>
        `dragAndDrop(element: ?, location: ?)`

        Fonction pratique permettant d&apos;effectuer une manœuvre de type « glisser-déposer ». L&apos;élément cible peut être déplacé vers l&apos;emplacement d&apos;un autre élément, ou par un décalage (en pixels). L&apos;emplacement est un objet avec deux propriétés `x` et `y`: `{x: x_offset, y: y_offset}`.
      </td>

      <td>
        séquence d&apos;actions
      </td>
    </tr>

    <tr id="actionSequence-keyDown">
      <td>
        `keyDown(key: ?)`

        Effectue une pression sur une touche de modification. Doit être l’un des suivants : `ALT`, `CONTROL`, `SHIFT`, `COMMAND` ou `META`. La touche de modification n&apos;est pas désactivée tant que [`keyUp()`](#actionSequence-keyUp) ou [`sendKeys()`](#actionSequence-sendKeys) n&apos;est pas appelé. La touche enfoncée sera ciblée sur l&apos;élément actuellement focalisé.
      </td>

      <td>
        séquence d&apos;actions
      </td>
    </tr>

    <tr id="actionSequence-keyUp">
      <td>
        `keyUp(key: ?)`

        Effectue une sortie de touche de modification. La sortie vise l&apos;élément actuellement focalisé.
      </td>

      <td>
        séquence d&apos;actions
      </td>
    </tr>

    <tr id="actionSequence-mouseDown">
      <td>
        `mouseDown(opt_elementOrButton: ?, opt_button: ?)`

        Appuie sur un bouton de la souris. Le bouton de la souris ne sera pas désactivé tant que [`mouseUp`](#actionSequence-mouseUp) ne sera pas appelé, que cet appel soit effectué dans cette séquence ou dans une autre. Le comportement d&apos;un événement hors service (comme l&apos;appel `mouseDown()` ou `click()` lorsque le bouton est déjà maintenu enfoncé) n&apos;est pas défini.
      </td>

      <td>
        séquence d&apos;actions
      </td>
    </tr>

    <tr id="actionSequence-mouseUp">
      <td>
        `mouseUp(opt_elementOrButton: ?, opt_button: ?)`

        sortir un bouton de la souris. Le comportement n&apos;est pas défini pour l&apos;appel de cette fonction sans un appel préalable à [`mouseDown()`](#actionSequence-mouseDown).
      </td>

      <td>
        séquence d&apos;actions
      </td>
    </tr>

    <tr id="actionSequence-mouseMove">
      <td>
        `mouseMove(location: ?, offset: ?)`

        Déplace la souris. L&apos;emplacement vers lequel se déplacer peut être spécifié en termes de position actuelle de la souris, d&apos;un décalage par rapport au coin supérieur gauche d&apos;un élément ou d&apos;un élément (auquel cas le milieu de l&apos;élément est utilisé).
      </td>

      <td>
        séquence d&apos;actions
      </td>
    </tr>

    <tr id="actionSequence-perform">
      <td>
        `perform()`

        Exécute cette séquence d&apos;actions.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="actionSequence-sendKeys">
      <td>
        `sendKeys(args: ?)`

        Simule la saisie de plusieurs touches. Chaque touche de modification rencontrée dans la séquence ne sera pas désactivée jusqu&apos;à ce qu&apos;elle soit rencontrée à nouveau. Tous les événements clés seront ciblés sur l&apos;élément actuellement focalisé. Pour une liste complète des clés non alphanumériques prises en charge, consultez la [documentation de la clé d&apos;énumération Webdriver](https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/Keys.html).
      </td>

      <td>
        séquence d&apos;actions
      </td>
    </tr>
  </tbody>
</table>

## Promesses : Lier les actions en séquences [#promises]

Vous pouvez également exécuter des fonctions directement sur les promesses. Synthétique monitoring est un environnement Node.js natif et utilise les promesses standards Node.js

Ces fonctions évaluent l’état des promesses, les annulent, etc. En particulier, vous pouvez créer des séquences d&apos;actions avec la fonction [`then()`](#promises-then) et ses sœurs, [`thenFinally()`](#promises-thenFinally) et [`thenCatch()`](#promises-thenCatch). Pour plus d&apos;informations, voir [Actions de séquence](/docs/synthetics/new-relic-synthetics/scripting-monitors/write-scripted-browsers#sequence).

<table>
  <thead>
    <tr>
      <th>
        Fonction
      </th>

      <th style={{ width: "150px" }}>
        Valeur de retour
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="promises-cancel">
      <td>
        `cancel(string: reason)`

        Annule le calcul de la valeur de cette promesse, rejetant ainsi la promesse dans le processus. Cette méthode est un no-op si la promesse a déjà été résolue.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="promises-isPending">
      <td>
        `isPending()`

        La valeur de cette promesse est-elle encore en cours de calcul ?
      </td>

      <td>
        booléen
      </td>
    </tr>

    <tr id="promises-then">
      <td>
        `then(opt_callback: fn(T: ?), opt_errback: fn())`

        Enregistre les auditeurs lorsque cette instance est résolue. Il s&apos;agit de la fonction de base utilisée pour lier des actions synchrones dans votre script.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="promises-thenFinally">
      <td>
        `thenFinally(callback: fn())`

        Enregistre un écouteur à invoquer lorsque cette promesse est résolue, que la valeur de la promesse ait été calculée avec succès ou non.
      </td>

      <td>
        promesse
      </td>
    </tr>

    <tr id="promises-thenCatch">
      <td>
        `thenCatch(callback: fn())`

        Enregistre un auditeur pour le cas où cette promesse est rejetée.
      </td>

      <td>
        promesse
      </td>
    </tr>
  </tbody>
</table>

## Naviguer : parcourir l&apos;historique du navigateur [#navigate]

La fonction `$browser.navigate()` expose un certain nombre de fonctions qui vous permettent de vous déplacer en arrière et en avant dans l&apos;historique de votre navigateur, d&apos;actualiser votre page et de naviguer vers de nouvelles pages.

<table>
  <thead>
    <tr>
      <th>
        Fonction
      </th>

      <th style={{ width: "150px" }}>
        Valeur de retour
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="navigate-back">
      <td>
        `back()`

        Revenir en arrière d&apos;une étape dans l&apos;historique du navigateur.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="navigate-forward">
      <td>
        `forward()`

        Avancer d&apos;une étape dans l&apos;historique du navigateur.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="navigate-refresh">
      <td>
        `refresh()`

        Rafraîchir la page actuelle.
      </td>

      <td>
        vide
      </td>
    </tr>

    <tr id="navigate-to">
      <td>
        `to(string: url)`

        Charger une nouvelle page Web dans la fenêtre actuelle du navigateur. `$browser.navigate().to()` est équivalent à `$browser.get()`.
      </td>

      <td>
        vide
      </td>
    </tr>
  </tbody>
</table>

## Conditions : Pause et attente des conditions [#until]

Utilisé avec `$browser.wait`, `until` interrompt l&apos;exécution de votre script jusqu&apos;à ce que la condition soit remplie. Pour plus d&apos;informations sur les attentes explicites et implicites, consultez la [documentation Webdriver](http://www.seleniumhq.org/docs/04_webdriver_advanced.jsp).

Pour les exemples d&apos;utilisation `.wait` et `.until` , voir les exemples de [Webdriver.wait](https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/lib/until.html) .

Les fonctions suivantes sont disponibles pour `$driver.until.Condition`:

<table>
  <thead>
    <tr>
      <th>
        Fonction
      </th>

      <th style={{ width: "150px" }}>
        Valeur de retour
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="conditions-ableToSwitchToFrame">
      <td>
        `ableToSwitchToFrame(frame: ?)`

        Crée une condition qui attendra que le pilote d&apos;entrée puisse basculer vers le cadre désigné. Le cadre cible peut être spécifié comme :

        * Un index numérique dans `window.frames` pour la trame actuelle

        * Un `webdriver.WebElement`, qui doit référencer un élément `FRAME` ou `IFRAME` sur la page actuelle

        * Un localisateur qui peut être utilisé pour localiser d&apos;abord un `FRAME` ou `IFRAME` sur la page actuelle avant de tenter d&apos;y accéder

          Une fois cette condition résolue avec succès, le conducteur pourra se concentrer sur le nouveau cadre.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-alertIsPresent">
      <td>
        `alertIsPresent()`

        Crée une condition qui attend qu&apos;une alerte soit ouverte. En cas de succès, la promesse renvoyée sera remplie avec le handle de l&apos;alerte ouverte.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-elementIsDisabled">
      <td>
        `elementIsDisabled(element: $driver.WebElement)`

        Crée une condition qui attendra que l&apos;élément donné soit désactivé.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-elementIsEnabled">
      <td>
        `elementIsEnabled(element: $driver.WebElement)`

        Crée une condition qui attendra que l&apos;élément donné soit activé.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-elementIsNotVisible">
      <td>
        `elementIsNotVisible(element: $driver.WebElement)`

        Crée une condition qui attendra que l&apos;élément donné soit dans le DOM, mais non visible pour l&apos;utilisateur.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-elementIsVisible">
      <td>
        `elementIsVisible(element: $driver.WebElement)`

        Crée une condition qui attendra que l&apos;élément donné devienne visible.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-elementIsSelected">
      <td>
        `elementIsSelected(element: $driver.WebElement)`

        Crée une condition qui attendra que l&apos;élément donné soit sélectionné.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-elementLocated">
      <td>
        `elementLocated(element: $driver.Locator)`

        Crée une condition qui bouclera jusqu&apos;à ce qu&apos;un élément soit trouvé avec le localisateur donné.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-elementsLocated">
      <td>
        `elementsLocated(element: $driver.Locator)`

        Crée une condition qui bouclera jusqu&apos;à ce qu&apos;au moins un élément soit trouvé avec le localisateur donné.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-elementTextContains">
      <td>
        `elementTextContains(element: $driver.WebElement, substr: string)`

        Crée une condition qui attendra que le texte visible de l&apos;élément donné contienne la sous-chaîne donnée.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-elementTextIs">
      <td>
        `elementTextIs(element: $driver.WebElement, text: string)`

        Sensible aux majuscules et minuscules. Crée une condition qui attendra que le texte visible de l&apos;élément donné corresponde exactement au texte donné.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-elementTextMatches">
      <td>
        `elementTextMatches(element: $driver.WebElement, regex: string)`

        Crée une condition qui attendra que le texte visible de l&apos;élément donné corresponde à une expression régulière.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-stalenessOf">
      <td>
        `stalenessOf(element: $driver.WebElement)`

        Crée une condition qui attendra que l&apos;élément donné devienne obsolète. Un élément est considéré comme obsolète une fois qu&apos;il est supprimé du DOM ou qu&apos;une nouvelle page a été chargée.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-titleContains">
      <td>
        `titleContains(substr: string)`

        Crée une condition qui attendra que le titre de la page actuelle contienne la sous-chaîne donnée.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-titleIs">
      <td>
        `titleIs(title: string)`

        Crée une condition qui attendra que le titre de la page actuelle corresponde à la valeur donnée.
      </td>

      <td>
        condition
      </td>
    </tr>

    <tr id="conditions-titleMatches">
      <td>
        `titleMatches(regex: string)`

        Crée une condition qui attendra que le titre de la page actuelle corresponde aux expressions régulières données.
      </td>

      <td>
        condition
      </td>
    </tr>
  </tbody>
</table>