---
title: Référence du navigateur scripté synthétique (Chrome et Firefox)
tags:
  - Synthetics
  - Synthetic monitoring
  - Scripting monitors
metaDescription: Description of every function available for synthetic scripted browser monitors.
freshnessValidatedDate: never
translationType: machine
---

Pour exécuter votre moniteur de navigateur scripté en utilisant [les API Sélénium Webdriver 4.1](https://www.selenium.dev/documentation/webdriver/), assurez-vous que la syntaxe de votre script utilise les variables `$selenium` et `$webDriver`. Pour accéder aux APIs sélénium Webdriver 3.6.0, utilisez les variables `$driver` et `$browser` comme décrit dans la [documentation de référence du navigateur 0.5.0+](/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050/).

En particulier:

* `$selenium` fournit toutes les exportations du module `selenium-webdriver` (par exemple, `ActionSequence`, `Button`, `By` ou `WebElement`). Cela correspond à l&amp;apos;utilisation `$driver` dans les environnements d&amp;apos;exécution plus anciens.
* `$webDriver` est une Synthétique monitoring instance `selenium-webdriver.WebDriver()`de. Il expose les principales API de base `WebDriver` comme `get()` et `findElement()`, ainsi que certaines API personnalisées de Synthétique. Cela correspond à l&amp;apos;utilisation de `$browser` dans les environnements d&amp;apos;exécution plus anciens.
* `$headers` offre la possibilité de modifier les en-têtes de requête. Cette fonctionnalité était disponible dans les anciens environnements d&amp;apos;exécution dans plusieurs méthodes `$browser`
* `$urlFilter` offre la possibilité de créer des listes d&amp;apos;autorisation et de refus pour limiter requests à certains domaines. Cette fonctionnalité était disponible dans les anciens environnements d&amp;apos;exécution dans plusieurs méthodes `$browser`

Si vous utilisez une ancienne version du moniteur, consultez la [documentation des versions 0.5.0 et 0.6.0 du moniteur](/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050) ou la [documentation des versions 0.4.0 et inférieures du moniteur](/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetics-scripted-browser-reference).

Pour en savoir plus sur les versions du moniteur et les différences d’exécution, consultez [Environnements d’exécution](/docs/synthetics/new-relic-synthetics/scripting-monitors/scripted-monitor-runtime-environment).

<Callout variant="important">
  Le gestionnaire de promesses / contrôle de flux Sélénium Webdriver permettait à certaines fonctions de s&apos;exécuter dans l&apos;ordre, sans gérer manuellement les promesses/fonctions asynchrones. Cela a été supprimé dans sélénium Webdriver 4.0 et n&apos;est plus disponible dans l&apos;environnement d&apos;exécution. Toutes les fonctions asynchrones et les promesses doivent être gérées avec la chaîne de promesses `await` ou `.then` . Cela garantira que les fonctions de script s&amp;apos;exécuteront dans l&amp;apos;ordre prévu.
</Callout>

Pour quelques exemples d&apos;utilisation courante, voir [Introduction au moniteur de navigateur scripté](/docs/synthetics/synthetic-monitoring/scripting-monitors/introduction-scripted-browser-monitors).

## Fonctions de niveau supérieur : créez votre script [#structure]

New Relic appelle les fonctions de niveau supérieur directement depuis votre instance `$webDriver` . Ils offrent une large gamme de fonctionnalités couvrant de nombreuses actions scriptables de base.

Les méthodes `waitForAndFindElement(locator, timeout)` et `waitForPendingRequests(timeout)` ont été supprimées de l&amp;apos;environnement d&amp;apos;exécution et ne sont pas disponibles via `$webDriver`. La compatibilité descendante est disponible, mais elle est considérée comme obsolète et peut être supprimée des futurs runtimes. Utilisez l’extrait de code suivant pour remplacer leur fonctionnalité :

<CollapserGroup>
  <Collapser id="waitForAndFindElement" title="Méthode waitForAndFindElement(localisateur, timeout)">
    ```js
    const element = await $webDriver.wait($selenium.until.elementLocated(locator), timeout, 'Timed-out waiting for element to be located using: '+locator);
    await $webDriver.wait($selenium.until.elementIsVisible(element), timeout, 'Timed-out waiting for element to be visible using ${element}');
    return await $webDriver.findElement(locator);
    ```
  </Collapser>

  <Collapser id="waitForPendingRequests" title="méthode waitForPendingRequests(timeout)">
    ```js
    await $webDriver.wait($webDriver.executeScript('return document.readyState == \'complete\''), optTimeoutMs, 'waitForPendingRequests');
    ```
  </Collapser>
</CollapserGroup>

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="webDriver-actions">
      <td>
        `$webDriver.actions()`
      </td>

      <td>
        Crée une nouvelle séquence d&apos;action à l&apos;aide de ce pilote. Pour une liste des actions disponibles, voir [ActionSequence](#actionsequence).

        Valeur de retour : void
      </td>
    </tr>

    <tr id="headers-add">
      <td>
        `$headers.add(headerKey: string, headerValue: string)`
      </td>

      <td>
        Ajoute l&apos;en-tête `headerKey` avec la valeur `headerValue` à l&amp;apos;exécution.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="headers-addMultiple">
      <td>
        `$headers.addMultiple(headers: {key:value...})`
      </td>

      <td>
        Ajoute plusieurs en-têtes à l&apos;exécution.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="headers-get">
      <td>
        `$headers.get(headerKey: string)`
      </td>

      <td>
        Renvoie une carte des en-têtes actuellement configurés.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="headers-getAll">
      <td>
        `$headers.getAll()`
      </td>

      <td>
        Renvoie une carte des en-têtes actuellement configurés.

        Valeur de retour : carte
      </td>
    </tr>

    <tr id="headers-getKeys">
      <td>
        `$headers.getKeys()`
      </td>

      <td>
        Renvoie un éventail de clés d&apos;en-tête actuellement configurées.

        Valeur de retour : éventail
      </td>
    </tr>

    <tr id="headers-has">
      <td>
        `$headers.has(headerKey: string)`
      </td>

      <td>
        Renvoie un booléen indiquant si cet en-tête existe.

        Valeur de retour : booléen
      </td>
    </tr>

    <tr id="headers-remove">
      <td>
        `$headers.remove(header: string)`
      </td>

      <td>
        Supprime un en-tête spécifique de l&apos;exécution.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="headers-removeMultiple">
      <td>
        `$headers.removeMultiple(headers: {key:value...})`
      </td>

      <td>
        Supprime tous les en-têtes de l&apos;argument lors de l&apos;exécution.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="headers-clear">
      <td>
        `$headers.clear()`
      </td>

      <td>
        Supprime tous les en-têtes de l&apos;exécution.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="urlFilter-addToDenyList">
      <td>
        `$urlFilter.addToDenyList(hostnameArr: [string])`
      </td>

      <td>
        Ajoute tous les noms d&apos;hôte dans un éventail d&apos;arguments à votre liste de refus. Permet d&apos;utiliser [des caractères génériques](#wildcard-use).

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="urlFilter-addToAllowList">
      <td>
        `$urlFilter.addToAllowList(hostnameArr: [string])`
      </td>

      <td>
        Ajoute tous les noms d&apos;hôte dans un éventail d&apos;arguments à votre liste de domaines autorisés. Permet d&apos;utiliser [des caractères génériques](#wildcard-use).

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="urlFilter-removeFromDenyList">
      <td>
        `$urlFilter.removeFromDenyList(hostnameArr: [string])`
      </td>

      <td>
        Supprime tous les noms d&apos;hôte dans l&apos;argument de votre liste de refus.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="urlFilter-removeFromAllowList">
      <td>
        `$urlFilter.removeFromAllowList(hostnameArr: [string])`
      </td>

      <td>
        Supprime tous les noms d&apos;hôte dans l&apos;argument de votre liste de domaines autorisés.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-executeAsyncScript">
      <td>
        `$webDriver.executeAsyncScript(script: ?, var_args: ?)`
      </td>

      <td>
        Planifie une commande pour exécuter du JavaScript asynchrone dans le contexte du cadre ou de la fenêtre actuellement sélectionné.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-executeScript">
      <td>
        `$webDriver.executeScript(script: ?, var_args: ?)`
      </td>

      <td>
        Planifie une commande pour exécuter JavaScript dans le contexte du cadre ou de la fenêtre actuellement sélectionné.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-findElement">
      <td>
        `$webDriver.findElement(locator: $selenium.Locator)`
      </td>

      <td>
        Planifiez une commande pour [rechercher un élément sur la page](#locators). Si non trouvé, Synthétique monitoring renvoie une erreur.

        Valeur de retour : WebElementPromise
      </td>
    </tr>

    <tr id="webDriver-findElements">
      <td>
        `$webDriver.findElements(locator: $selenium.Locator)`
      </td>

      <td>
        Planifiez une commande pour [rechercher plusieurs éléments sur la page](#locators).

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-get">
      <td>
        `$webDriver.get(url: string)`
      </td>

      <td>
        Charge une page Web dans un navigateur Synthétique.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-getAllWindowHandles">
      <td>
        `$webDriver.getAllWindowHandles()`
      </td>

      <td>
        Planifie une commande pour récupérer la liste actuelle des poignées de fenêtre disponibles.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-getCapabilities">
      <td>
        `$webDriver.getCapabilities()`
      </td>

      <td>
        Une promesse qui se résoudra avec les capacités de l&apos;instance.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-getCurrentUrl">
      <td>
        `$webDriver.getCurrentUrl()`
      </td>

      <td>
        Planifie une commande pour récupérer l&apos;URL de la page actuelle.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-getPageSource">
      <td>
        `$webDriver.getPageSource()`
      </td>

      <td>
        Planifie une commande pour récupérer la source de la page actuelle. La source de la page renvoyée est une représentation du DOM sous-jacent. Ne vous attendez pas à ce qu&apos;il soit formaté ou échappé de la même manière que la réponse envoyée depuis le serveur Web.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-getSession">
      <td>
        `$webDriver.getSession()`
      </td>

      <td>
        Une promesse pour la séance de ce client.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-getTitle">
      <td>
        `$webDriver.getTitle()`
      </td>

      <td>
        Planifie une commande pour récupérer le titre de la page actuelle.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-getWindowHandle">
      <td>
        `$webDriver.getWindowHandle()`
      </td>

      <td>
        Planifie une commande pour récupérer le handle de fenêtre actuel.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-manage">
      <td>
        `$webDriver.manage()`
      </td>

      <td>
        L&apos;interface d&apos;options pour cette instance. Vous pouvez gérer [les cookies, les délais d&apos;expiration et d&apos;autres options de fenêtre](#options).

        Valeur de retour : void
      </td>
    </tr>

    <tr id="webDriver-navigate">
      <td>
        `$webDriver.navigate()`
      </td>

      <td>
        L&apos;[interface de navigation (historique des fonctions du navigateur)](#navigate) pour cette instance.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="webDriver-sleep">
      <td>
        `$webDriver.sleep()`
      </td>

      <td>
        Planifie une commande pour mettre le pilote en veille pendant la durée donnée.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-switchTo">
      <td>
        `$webDriver.switchTo()`
      </td>

      <td>
        L&apos;interface cible localisateur pour cette instance.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="webDriver-takeScreenshot">
      <td>
        `$webDriver.takeScreenshot()`
      </td>

      <td>
        Planifie une commande pour effectuer une capture d&apos;écran.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webDriver-wait">
      <td>
        `$webDriver.wait(fn: $driver.Condition, timeout: number, opt_message: string)`
      </td>

      <td>
        Planifie une [commande pour attendre qu&apos;une condition soit remplie](#until), telle que définie par votre fonction fournie.

        Valeur de retour : WebElement
      </td>
    </tr>

    <tr id="browser-waitforpending">
      <td>
        `$browser.waitForPendingRequests(timeout: number)`
      </td>

      <td>
        Force le script à attendre que requests qui ont été initiées soient renvoyées, jusqu&apos;au délai d&apos;expiration. Utile pour suivre les ressources non bloquantes.

        Valeur de retour : promesse
      </td>
    </tr>
  </tbody>
</table>

## Liste de refus : utilisation de caractères génériques [#wildcard-use]

Si vous souhaitez ajouter un domaine à la liste de refus pour votre instance de navigateur, les caractères génériques doivent correspondre à la syntaxe de l&apos;URL à bloquer.

Une liste de refus globale `.com` doit contenir ces fonctions :

<table>
  <thead>
    <tr>
      <th>
        Fonction
      </th>

      <th style={{ width: "200px" }}>
        Action de blocage
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="deny-list-wildcard-examples">
      <td>
        `$urlFilter.addToDenyList(['*.com']);`
      </td>

      <td>
        `a.com`
      </td>
    </tr>

    <tr>
      <td>
        `$urlFilter.addToDenyList([*.*.com']);`
      </td>

      <td>
        `a.b.com`
      </td>
    </tr>

    <tr>
      <td>
        `$urlFilter.addToDenyList([*.*.*.com']);`
      </td>

      <td>
        `a.b.c.com`
      </td>
    </tr>

    <tr>
      <td>
        `$urlFilter.addToDenyList([www.*.com']);`
      </td>

      <td>
        `www.a.com`
      </td>
    </tr>

    <tr>
      <td>
        `$urlFilter.addToDenyList([www.*.*.com']);`
      </td>

      <td>
        `www.a.b.com`
      </td>
    </tr>

    <tr>
      <td>
        `$urlFilter.addToDenyList(['www.*.*.*.com']);`
      </td>

      <td>
        `www.a.b.c.com`
      </td>
    </tr>
  </tbody>
</table>

## Options : Gérer l&apos;instance du navigateur [#options]

Ces fonctions gèrent les options de votre instance de navigateur, telles que les cookies, les délais d&apos;expiration et la taille de la fenêtre. Accédez à ces options via la fonction [`$webDriver.manage()`](#webDriver-manage) .

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="options-manage-addCookie">
      <td>
        `$webDriver.manage().addCookie(spec: object)`
      </td>

      <td>
        Planifie une commande pour ajouter un cookie.

        `spec` est un objet d&amp;apos;enregistrement décrivant un cookie de navigateur. Pour plus d&amp;apos;informations, consultez la [documentation Webdriver](https://www.w3.org/TR/webdriver1/#cookies).

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-deleteAllCookies">
      <td>
        `$webDriver.manage().deleteAllCookies()`
      </td>

      <td>
        Planifie une commande pour supprimer tous les cookies visibles sur la page actuelle.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-deleteCookie">
      <td>
        `$webDriver.manage().deleteCookie(name: string)`
      </td>

      <td>
        Planifie une commande pour supprimer le cookie avec le nom donné. Cette commande est un no-op s&apos;il n&apos;y a pas de cookie avec le nom donné visible sur la page actuelle.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-getCookie">
      <td>
        `$webDriver.manage().getCookie(name: string)`
      </td>

      <td>
        Planifie une commande pour récupérer le cookie avec le nom donné. Renvoie null s&apos;il n&apos;existe pas de tel cookie. Le cookie sera renvoyé sous forme d&apos;objet JSON comme décrit par le protocole Webdriver.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-getCookies">
      <td>
        `$webDriver.manage().getCookies()`
      </td>

      <td>
        Planifie une commande pour récupérer tous les cookies visibles sur la page actuelle. New Relic Syntheticcs renvoie chaque cookie sous forme d&apos;objet JSON comme décrit par le protocole Webdriver.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-get-timeouts">
      <td>
        `$webDriver.manage().getTimeouts()`
      </td>

      <td>
        Renvoie le script actuel, la pageLoad et les délais d&apos;expiration implicites.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-set-timeouts-implicit">
      <td>
        `$webDriver.manage().setTimeouts({implicit: numberMS})`
      </td>

      <td>
        Spécifie la durée pendant laquelle le pilote doit attendre lors de la recherche d&apos;un élément s&apos;il n&apos;est pas immédiatement présent. La définition du délai d’attente sur `0` désactive l’attente implicite.

        Soyez prudent lorsque vous augmentez le délai d&apos;attente, car cela augmentera les temps d&apos;exécution des tests, en particulier avec des stratégies de localisation plus lentes comme XPath. La valeur par défaut est de 10 secondes.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-set-timeouts-pageLoad">
      <td>
        `$webDriver.manage().setTimeouts({pageLoad: numberMS})`
      </td>

      <td>
        Définit la durée d&apos;attente pour que le chargement d&apos;une page soit terminé avant de renvoyer une erreur. Si le délai d&apos;attente est négatif, le chargement des pages peut durer jusqu&apos;à 180 secondes. La valeur par défaut est de 60 secondes.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-set-timeouts-script">
      <td>
        `$webDriver.manage().setTimeouts({script: numberMS})`
      </td>

      <td>
        Définit la durée d&apos;attente, en millisecondes, pour qu&apos;un script asynchrone termine son exécution avant de renvoyer une erreur. La valeur par défaut est de 30 secondes.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-window-getRect">
      <td>
        `$webDriver.manage().window().getRect()`
      </td>

      <td>
        Récupère la position actuelle de la fenêtre (en x et y), par rapport au coin supérieur gauche de l&apos;écran et la taille de la fenêtre (en largeur et en hauteur).

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-window-maximize">
      <td>
        `$webDriver.manage().window().maximize()`
      </td>

      <td>
        Maximise la fenêtre actuelle.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="options-manage-window-setRect">
      <td>
        `$webDriver.manage().window().setRect({x: number|undefined, y: number|undefined, width: number|undefined, height: number|undefined})`
      </td>

      <td>
        Définissez la position actuelle de la fenêtre (comme x et y), par rapport au coin supérieur gauche de l&apos;écran et la taille de la fenêtre (comme largeur et hauteur).

        Valeur de retour : promesse
      </td>
    </tr>
  </tbody>
</table>

## localisateur : Rechercher un élément de page [#locators]

Les localisateurs sont une collection de fonctions d&apos;usine permettant de créer une instance `locator` . localisateur recherche des éléments DOM , qui peuvent être passés à des fonctions telles que [`$webDriver.findElement`](#webDriver-findElement). Appelez-les via `$selenium.By`.

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="selenium-by-className">
      <td>
        `$selenium.By.className(className: string)`
      </td>

      <td>
        Localise un élément qui a un nom de classe spécifique. Le localisateur renvoyé équivaut à la recherche d&apos;éléments avec le sélecteur CSS `.class`.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="selenium-by-css">
      <td>
        `$selenium.By.css(cssName: string)`
      </td>

      <td>
        Localise un élément à l&apos;aide d&apos;un sélecteur CSS.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="selenium-by-id">
      <td>
        `$selenium.By.id(id: string)`
      </td>

      <td>
        Localise un élément par son ID.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="selenium-by-linkText">
      <td>
        `$selenium.By.linkText(linkText: string)`
      </td>

      <td>
        Localise les éléments de lien dont le texte visible correspond à la chaîne donnée.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="selenium-by-js">
      <td>
        `$selenium.By.js(js: string)`
      </td>

      <td>
        Localise un élément en évaluant une expression JavaScript.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="selenium-by-name">
      <td>
        `$selenium.By.name(name: string)`
      </td>

      <td>
        Localise les éléments dont l&apos;attribut name a la valeur donnée.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="selenium-by-partialLinkText">
      <td>
        `$selenium.By.partialLinkText(partialLinkText: string)`
      </td>

      <td>
        Localise les éléments de lien dont [getText](#webElement-getText) visible contient la sous-chaîne donnée.

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="selenium-by-tagName">
      <td>
        `$selenium.By.tagName(tagName: string)`
      </td>

      <td>
        Localise les éléments avec un nom tag donné. Le localisateur renvoyé équivaut à utiliser la fonction DOM `getElementsByTagName` .

        Valeur de retour : localisateur
      </td>
    </tr>

    <tr id="selenium-by-xpath">
      <td>
        `$selenium.By.xpath(xpath: string)`
      </td>

      <td>
        Localise les éléments correspondant à un sélecteur XPath.

        Valeur de retour : localisateur
      </td>
    </tr>
  </tbody>
</table>

## WebElement : Interagir avec l&apos;élément de page [#webelement]

Lorsqu&apos;une fonction telle que [`$webDriver.findElement`](#webDriver-findElement) renvoie une référence WebElement, ces fonctions peuvent être utilisées pour interagir avec cet élément. Par exemple, vous pouvez cliquer sur des boutons, envoyer du texte aux entrées de formulaire et obtenir les attributs des éléments à tester.

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="webElement-click">
      <td>
        `click()`
      </td>

      <td>
        Clique sur cet élément.

        Valeur de retour : auto-référence
      </td>
    </tr>

    <tr id="webElement-sendKeys">
      <td>
        `sendKeys(var_args: ?)`
      </td>

      <td>
        Planifie une commande pour taper une séquence sur l&apos;élément DOM représenté par cette instance.

        Valeur de retour : WebElement
      </td>
    </tr>

    <tr id="webElement-getTagName">
      <td>
        `getTagName()`
      </td>

      <td>
        Planifie une commande pour interroger le nom tag/ nœud de cet élément.

        Valeur de retour : WebElement
      </td>
    </tr>

    <tr id="webElement-getCssValue">
      <td>
        `getCssValue(name: string)`
      </td>

      <td>
        Planifie une commande pour interroger le style calculer de l&apos;élément représenté par cette instance. Si l&apos;élément hérite du style nommé de son parent, le parent sera interrogé pour sa valeur. Dans la mesure du possible, les valeurs de couleur seront converties en leur représentation hexadécimale (par exemple, `#00ff00` au lieu de `rgb(0, 255, 0)`).

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-getAttribute">
      <td>
        `getAttribute(name: string)`
      </td>

      <td>
        Planifie une commande pour interroger la valeur de l&apos;attribut donné de l&apos;élément.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-getText">
      <td>
        `getText()`
      </td>

      <td>
        Récupère le `innerText` visible (non masqué par CSS) de cet élément, y compris les sous-éléments, sans aucun espace blanc de début ou de fin.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-isEnabled">
      <td>
        `isEnabled()`
      </td>

      <td>
        Planifie une commande pour demander si l&apos;élément DOM représenté par cette instance est activé, comme indiqué par l&apos;attribut désactivé.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-isSelected">
      <td>
        `isSelected()`
      </td>

      <td>
        Planifie une commande pour demander si cet élément est sélectionné.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-submit">
      <td>
        `submit()`
      </td>

      <td>
        Planifie une commande pour soumettre le formulaire contenant cet élément (ou cet élément s&apos;il s&apos;agit d&apos;un élément `FORM` ). Cette commande est nulle si l&amp;apos;élément n&amp;apos;est pas contenu dans un formulaire.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-clear">
      <td>
        `clear()`
      </td>

      <td>
        Planifie une commande pour effacer la valeur de cet élément.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="webElement-isDisplayed">
      <td>
        `isDisplayed()`
      </td>

      <td>
        Planifie une commande pour tester si cet élément est actuellement affiché.

        Valeur de retour : promesse
      </td>
    </tr>
  </tbody>
</table>

## ActionSequence : Lier plusieurs actions [#actionsequence]

Les séquences d&apos;actions peuvent créer une interaction complexe entre l&apos;utilisateur et votre site Web.

* Pour créer une nouvelle séquence d’actions, utilisez [`$webDriver.actions()`](#webDriver-actions).
* Pour lier plusieurs actions ensemble dans une séquence, incluez [`perform()`](#actionSequence-perform) après chacune. Cela exécute puis termine des séquences individuelles, y compris des séquences à action unique.

Le tableau suivant contient une liste des actions disponibles. Pour plus d&apos;informations, consultez la [documentation Webdriver ActionSequence sur GitHub](https://github.com/browserstack/selenium-webdriver-nodejs/blob/master/docs/class_webdriver_ActionSequence.html).

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="actionSequence-click">
      <td>
        `click(opt_elementOrButton: ?, opt_button: ?)`
      </td>

      <td>
        Clique sur un bouton de la souris. Si un élément est fourni, la souris sera d&apos;abord déplacée au centre de cet élément. Ceci est équivalent à [`WebElement.click()`](#webElement-click).

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-doubleClick">
      <td>
        `doubleClick(opt_elementOrButton: ?, opt_button: ?)`
      </td>

      <td>
        Double-clique sur un bouton de la souris. Si un élément est fourni, la souris sera d&apos;abord déplacée au centre de cet élément.

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-dragAndDrop">
      <td>
        `dragAndDrop(element: ?, location: ?)`
      </td>

      <td>
        Fonction pratique pour effectuer une manœuvre de glisser-déposer. L&apos;élément cible peut être déplacé vers l&apos;emplacement d&apos;un autre élément, ou par un décalage (en pixels). L&apos;emplacement est un objet avec deux propriétés `x` et `y`: `{x: x_offset, y: y_offset}`.

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-keyDown">
      <td>
        `keyDown(key: ?)`
      </td>

      <td>
        Effectue une pression sur une touche de modification. Doit être l’un des suivants : `ALT`, `CONTROL`, `SHIFT`, `COMMAND` ou `META`. La touche de modification n&amp;apos;est pas désactivée tant que [`keyUp()`](#actionSequence-keyUp) ou [`sendKeys()`](#actionSequence-sendKeys) n&amp;apos;est pas appelé. La touche enfoncée sera ciblée sur l&amp;apos;élément actuellement focalisé.

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-keyUp">
      <td>
        `keyUp(key: ?)`
      </td>

      <td>
        Effectue une sortie de touche de modification. La sortie vise l&apos;élément actuellement focalisé.

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-mouseDown">
      <td>
        `press(opt_elementOrButton: ?, opt_button: ?)`
      </td>

      <td>
        Appuie sur un bouton de la souris. Le bouton de la souris ne sera pas désactivé tant que [`release`](#actionSequence-mouseUp) ne sera pas appelé, que cet appel soit effectué dans cette séquence ou dans une autre. Le comportement d&amp;apos;un événement hors service (comme l&amp;apos;appel `press()` ou `click()` lorsque le bouton est déjà maintenu enfoncé) n&amp;apos;est pas défini.

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-mouseUp">
      <td>
        `release(opt_elementOrButton: ?, opt_button: ?)`
      </td>

      <td>
        sortir un bouton de la souris. Le comportement n&apos;est pas défini pour l&apos;appel de cette fonction sans un appel préalable à [`press()`](#actionSequence-mouseDown).

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-mouseMove">
      <td>
        `move(location: ?, offset: ?)`
      </td>

      <td>
        Déplace la souris. L&apos;emplacement vers lequel se déplacer peut être spécifié en termes de position actuelle de la souris, d&apos;un décalage par rapport au coin supérieur gauche d&apos;un élément ou d&apos;un élément (auquel cas le milieu de l&apos;élément est utilisé).

        Valeur de retour : actionsequence
      </td>
    </tr>

    <tr id="actionSequence-perform">
      <td>
        `perform()`
      </td>

      <td>
        Exécute cette séquence d&apos;actions.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="actionSequence-sendKeys">
      <td>
        `sendKeys(args: ?)`
      </td>

      <td>
        Simule la saisie de plusieurs touches. Chaque touche de modification rencontrée dans la séquence ne sera pas désactivée jusqu&apos;à ce qu&apos;elle soit rencontrée à nouveau. Tous les événements clés seront ciblés sur l&apos;élément actuellement focalisé. Pour obtenir la liste complète des clés non alphanumériques prises en charge, consultez la [documentation de la clé d&apos;énumération Webdriver sur GitHub](https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/Keys.html).

        Valeur de retour : actionsequence
      </td>
    </tr>
  </tbody>
</table>

## Promesses : Lier les actions en séquences [#promises]

Vous pouvez également exécuter des fonctions directement sur les promesses. Synthétique monitoring est un environnement Node.js natif et utilise les promesses standards Node.js

Ces fonctions évaluent l’état des promesses, les annulent, etc. En particulier, vous pouvez créer des séquences d&apos;actions avec la fonction [`then()`](#promises-then) et ses sœurs, [`finally()`](#promises-thenFinally) et [`catch()`](#promises-thenCatch). Pour plus d&amp;apos;informations, voir [Actions de séquence](/docs/synthetics/new-relic-synthetics/scripting-monitors/write-scripted-browsers#sequence).

<Callout variant="tip">
  En plus de prendre en charge la chaîne de promesses à l&apos;aide de .then syntaxe, cet environnement d&apos;exécution prend également en charge la syntaxe async-await.
</Callout>

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="promises-isPending">
      <td>
        `isPending()`
      </td>

      <td>
        La valeur de cette promesse est-elle encore en cours de calcul ?

        Valeur de retour : booléen
      </td>
    </tr>

    <tr id="promises-then">
      <td>
        `then(opt_callback: fn(T: ?), opt_errback: fn())`
      </td>

      <td>
        Enregistre les auditeurs lorsque cette instance est résolue. Il s&apos;agit de la fonction de base utilisée pour lier des actions synchrones dans votre script.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="promises-thenFinally">
      <td>
        `finally(callback: fn())`
      </td>

      <td>
        Enregistre un écouteur à invoquer lorsque cette promesse est résolue, que la valeur de la promesse ait été calculée avec succès ou non.

        Valeur de retour : promesse
      </td>
    </tr>

    <tr id="promises-thenCatch">
      <td>
        `catch(callback: fn())`
      </td>

      <td>
        Enregistre un auditeur pour le cas où cette promesse est rejetée.

        Valeur de retour : promesse
      </td>
    </tr>
  </tbody>
</table>

## Naviguer : parcourir l&apos;historique du navigateur [#promises]

La fonction `$webDriver.navigate()` expose un certain nombre de fonctions qui vous permettent de vous déplacer en arrière et en avant dans l&amp;apos;historique de votre navigateur, d&amp;apos;actualiser votre page et de naviguer vers de nouvelles pages.

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="navigate-back">
      <td>
        `back()`
      </td>

      <td>
        Revenir en arrière d&apos;une étape dans l&apos;historique du navigateur.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="navigate-forward">
      <td>
        `forward()`
      </td>

      <td>
        Avancer d&apos;une étape dans l&apos;historique du navigateur.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="navigate-refresh">
      <td>
        `refresh()`
      </td>

      <td>
        Rafraîchir la page actuelle.

        Valeur de retour : void
      </td>
    </tr>

    <tr id="navigate-to">
      <td>
        `to(string: url)`
      </td>

      <td>
        Charger une nouvelle page Web dans la fenêtre actuelle du navigateur. `$webDriver.navigate().to()` est équivalent à `$webDriver.get()`.

        Valeur de retour : void
      </td>
    </tr>
  </tbody>
</table>

## Conditions : Pause et attente des conditions [#until]

<Callout variant="tip">
  Vous pouvez en apprendre plus sur les attentes dans sélénium [dans leur documentation officielle](https://www.selenium.dev/documentation/en/webdriver/waits/).
</Callout>

Utilisé avec `$webDriver.wait`, `until` interrompt l&amp;apos;exécution de votre script jusqu&amp;apos;à ce que la condition soit remplie. Pour plus d&amp;apos;informations, consultez [la documentation Webdriver `until` de sélénium](http://www.seleniumhq.org/docs/04_webdriver_advanced.jsp).

Les fonctions suivantes sont disponibles pour `$selenium.until.Condition`:

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Fonction
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="conditions-ableToSwitchToFrame">
      <td>
        `ableToSwitchToFrame(frame: ?)`
      </td>

      <td>
        Crée une condition qui attendra que le pilote d&apos;entrée puisse basculer vers le cadre désigné. Le cadre cible peut être spécifié comme :

        * Un index numérique dans `window.frames` pour la trame actuelle

        * Un `webdriver.WebElement`, qui doit référencer un élément `FRAME` ou `IFRAME` sur la page actuelle

        * Un localisateur qui peut être utilisé pour localiser d&apos;abord un `FRAME` ou `IFRAME` sur la page actuelle avant de tenter d&amp;apos;y accéder

          Une fois cette condition résolue avec succès, le conducteur pourra se concentrer sur le nouveau cadre.

          Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-alertIsPresent">
      <td>
        `alertIsPresent()`
      </td>

      <td>
        Crée une condition qui attend qu&apos;une alerte soit ouverte. En cas de succès, la promesse renvoyée sera remplie avec le handle de l&apos;alerte ouverte.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementIsDisabled">
      <td>
        `elementIsDisabled(element: $selenium.WebElement)`
      </td>

      <td>
        Crée une condition qui attendra que l&apos;élément donné soit désactivé.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementIsEnabled">
      <td>
        `elementIsEnabled(element: $selenium.WebElement)`
      </td>

      <td>
        Crée une condition qui attendra que l&apos;élément donné soit activé.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementIsNotVisible">
      <td>
        `elementIsNotVisible(element: $selenium.WebElement)`
      </td>

      <td>
        Crée une condition qui attendra que l&apos;élément donné soit dans le DOM, mais non visible pour l&apos;utilisateur.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementIsVisible">
      <td>
        `elementIsVisible(element: $selenium.WebElement)`
      </td>

      <td>
        Crée une condition qui attendra que l&apos;élément donné devienne visible.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementIsSelected">
      <td>
        `elementIsSelected(element: $selenium.WebElement)`
      </td>

      <td>
        Crée une condition qui attendra que l&apos;élément donné soit sélectionné.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementLocated">
      <td>
        `elementLocated(element: $selenium.Locator)`
      </td>

      <td>
        Crée une condition qui bouclera jusqu&apos;à ce qu&apos;un élément soit trouvé avec le localisateur donné.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementsLocated">
      <td>
        `elementsLocated(element: $selenium.Locator)`
      </td>

      <td>
        Crée une condition qui bouclera jusqu&apos;à ce qu&apos;au moins un élément soit trouvé avec le localisateur donné.

        Valeur de retour : condition

        n
      </td>
    </tr>

    <tr id="conditions-elementTextContains">
      <td>
        `elementTextContains(element: $selenium.WebElement, substr: string)`
      </td>

      <td>
        Crée une condition qui attendra que le texte visible de l&apos;élément donné contienne la sous-chaîne donnée.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-elementTextIs">
      <td>
        `elementTextIs(element: $selenium.WebElement, text: string)`
      </td>

      <td>
        Sensible aux majuscules et minuscules. Crée une condition qui attendra que le texte visible de l&apos;élément donné corresponde exactement au texte donné.

        Valeur de retour : condition

        n
      </td>
    </tr>

    <tr id="conditions-elementTextMatches">
      <td>
        `elementTextMatches(element: $selenium.WebElement, regex: string)`
      </td>

      <td>
        Crée une condition qui attendra que le texte visible de l&apos;élément donné corresponde à une expression régulière.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-stalenessOf">
      <td>
        `stalenessOf(element: $selenium.WebElement)`
      </td>

      <td>
        Crée une condition qui attendra que l&apos;élément donné devienne obsolète. Un élément est considéré comme obsolète une fois qu&apos;il est supprimé du DOM ou qu&apos;une nouvelle page a été chargée.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-titleContains">
      <td>
        `titleContains(substr: string)`
      </td>

      <td>
        Crée une condition qui attendra que le titre de la page actuelle contienne la sous-chaîne donnée.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-titleIs">
      <td>
        `titleIs(title: string)`
      </td>

      <td>
        Crée une condition qui attendra que le titre de la page actuelle corresponde à la valeur donnée.

        Valeur de retour : condition
      </td>
    </tr>

    <tr id="conditions-titleMatches">
      <td>
        `titleMatches(regex: string)`
      </td>

      <td>
        Crée une condition qui attendra que le titre de la page actuelle corresponde aux expressions régulières données.

        Valeur de retour : condition
      </td>
    </tr>
  </tbody>
</table>

## Exemple avancé [#example]

L&apos;exemple suivant sépare le code en sections fonctionnelles : Constantes, dépendance, configuration, élément de page, fonctions et début de script. Il montre comment vous pouvez :

* Configurez les délais d&apos;attente pour minimiser les durées d&apos;échec pour de meilleures performances.
* Localisez les éléments par CSS ou ID.
* Définir `waitForAndFindElement`.
* Utilisez `console.log()` pour organiser le et identifier les script log problèmes liés aux échecs d’assertion ou aux délais d’expiration.
* Gérez les erreurs avec un bloc try/catch qui génère un message d’erreur utile identifiant l’étape d’échec.
* Permet l&apos;utilisation du niveau supérieur `await` car nous exécutons l&amp;apos;intégralité du script dans une fonction asynchrone en coulisses.

```js
/**
 * Script Name: Advanced Example
 * Author:      New Relic
 * Version:     1.6
 */

// -------------------- CONSTANTS
const SCRIPT_NAME = "Best Practices - Chrome 100"                        // name to record in script log
const IMPLICIT_TIMEOUT = 3000                                            // default implicit timeout is 10 seconds
const PAGE_LOAD_TIMEOUT = 60000                                          // default page load timeout is 60 seconds, fail early to prevent long duration timeouts
const SCRIPT_TIMEOUT = 20000                                             // default script timeout is 30 seconds
const USER_AGENT = "default"                                             // set the user agent for Chrome
const PROTOCOL = "https://"                                              // set the protocol
const USERNAME = ""                                                      // username:
const PASSWORD = ""                                                      // password@
const DOMAIN = "docs.newrelic.com"                                       // your domain
const PATH = "/docs/new-relic-solutions/get-started/intro-new-relic/"    // path to main page
const CHECK = "Get started with New Relic"                               // text to match on page
const AUTH = USERNAME + PASSWORD                                         // could be stored as secure credentials
const MAIN_URL = PROTOCOL + AUTH + DOMAIN + PATH

// -------------------- DEPENDENCIES
const assert = require("assert")

// -------------------- CONFIGURATION
await $webDriver.manage().setTimeouts({
  implicit: IMPLICIT_TIMEOUT,  // sets element load timeout
  pageLoad: PAGE_LOAD_TIMEOUT, // sets page load timeout
  script: SCRIPT_TIMEOUT       // sets script timeout
})

// -------------------- ELEMENTS
const By = $selenium.By
const loc = {
  title: By.css("#gatsby-focus-wrapper > div.css-1uz5ayg > div > main > div > h1"),
  start: [
    { step: 'signup',     selector: By.id("sign-up-for-new-relic-if-you-havent-already") },
    { step: 'add',        selector: By.id("add-your-data") },
    { step: 'explore',    selector: By.id("explore-your-data") },
    { step: 'query',      selector: By.id("query-your-data") },
    { step: 'dashboard',  selector: By.id("set-up-a-dashboard") },
    { step: 'alerts',     selector: By.id("configure-alerts") }
  ]
}

// -------------------- FUNCTIONS
// for backwards compatibility with legacy runtimes
async function waitForAndFindElement(locator, timeout) {
  const element = await $webDriver.wait(
    $selenium.until.elementLocated(locator),
    timeout,
    "Timed-out waiting for element to be located using: " + locator
  )
  await $webDriver.wait(
    $selenium.until.elementIsVisible(element),
    timeout,
    "Timed-out waiting for element to be visible using ${element}"
  )
  return await $webDriver.findElement(locator)
}

// -------------------- START OF SCRIPT
// Start logging
const start_time = new Date()
console.log("Starting synthetics script: " + SCRIPT_NAME)

// confirm timeouts are set
const {implicit, pageLoad, script} = await $webDriver.manage().getTimeouts()
console.log("Timeouts are set to:")
console.log("  IMPLICIT: " + implicit / 1000 + "s")
console.log("  PAGE LOAD: " + pageLoad / 1000 + "s")
console.log("  SCRIPT: " + script / 1000 + "s")

// Setting User Agent is not then-able, so we do this first (if defined and not default)
if (USER_AGENT && 0 !== USER_AGENT.trim().length && USER_AGENT != "default") {
  $headers.add("User-Agent", USER_AGENT)
  console.log("Setting User-Agent to " + USER_AGENT)
}

// if an error happens at any step, script execution is halted and a failed result is returned
console.log("1. get: " + MAIN_URL)
await $webDriver.get(MAIN_URL)

console.log("2. waitForAndFindElement: " + loc.title)
const textBlock = await waitForAndFindElement(loc.title, IMPLICIT_TIMEOUT)

console.log("3. getText: " + CHECK)
const text1 = await textBlock.getText()

console.log("4. assert.equal: " + text1)
assert.equal(text1, CHECK, "title validation text not found")

console.log("5. takeScreenshot")
await $webDriver.takeScreenshot()

console.log("6. findElement")
loc.start.forEach(async function (nr, i) {
  let n = i + 1
  try{
    // verify each asset has loaded
    console.log("  " + n + ". " + nr.step + ": " + nr.selector)
    await $webDriver.findElement(nr.selector)
  }catch(exception){
    console.error("Failure in Step 6." + n)
    throw exception
  }
})

// End logging
const end_time = new Date()

// Calculate the duration
const script_duration = (end_time - start_time) / 1000

// Log the times
console.log("Start time: " + start_time)
console.log("End time: " + end_time)
console.log("Duration: " + script_duration + "s")
```

## Shadow DOM : Recherche d&apos;éléments [#shadow]

L&apos;environnement d&apos;exécution prend également en charge l&apos;accès aux éléments DOM fantômes à l&apos;aide de la nouvelle méthode Sélénium Webdriver `getShadowRoot()`.

1. Utilisez `findElement` ou une [fonction de niveau supérieur](#structure) similaire pour trouver l’hôte fantôme. Il s’agit de l’élément sur lequel la racine d’ombre est montée.
2. Utilisez la méthode `getShadowRoot()` sur l’élément trouvé à l’étape 1 pour obtenir la racine de l’ombre.
3. En utilisant la racine d&apos;ombre, vous pouvez désormais utiliser findElement ou des fonctions similaires pour rechercher des éléments à l&apos;intérieur de la racine d&apos;ombre. Si plusieurs niveaux de DOM fantôme sont utilisés, ces étapes devront être répétées jusqu&apos;à ce que vous accédiez à l&apos;objet racine fantôme qui contient l&apos;élément avec lequel vous devez interagir.

<Callout variant="tip">
  Chrome ne prend pas en charge l&apos;utilisation du localisateur XPath à l&apos;intérieur d&apos;un objet racine fantôme. Utilisez une [option de localisateur](#locators) différente pour rechercher des éléments à l’intérieur d’un objet racine d’ombre.
</Callout>

Exemple:

```js
// Find the shadow host
let myShadowHost = await $webDriver.findElement($selenium.By.id('exampleShadowHost'));
// Get the shadow root
let myShadowRoot = await myShadowHost.getShadowRoot();
// Interact with an element inside the shadow root
let el = await myShadowRoot.findElement($selenium.By.id('myButton'));
await el.click();
```