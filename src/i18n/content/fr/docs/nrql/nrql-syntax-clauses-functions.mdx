---
title: Référence NRQL
tags:
  - Query your data
  - 'NRQL: New Relic Query Language'
  - Get started
metaDescription: 'A detailed reference list of clauses and functions in NRQL, the New Relic query language.'
freshnessValidatedDate: never
translationType: machine
---

Pour écrire une bonne requête [NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language) , il est utile de comprendre comment fonctionnent nos différentes clauses et fonctions NRQL . Ce document contient des définitions de clauses et de fonctions NRQL et donne des exemples de leur utilisation.

Vous recherchez des règles de syntaxe NRQL de base ? Voir [Comment utiliser NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-how-nrql-works). Pour un didacticiel, voir [le didacticiel d&apos;introduction à NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-tutorial).

## Composants de la requête [#clauses]

Comme indiqué dans notre [document de syntaxe NRQL de base](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-how-nrql-works/#syntax), chaque requête NRQL contiendra une clause `SELECT` et une clause `FROM` , toutes les autres clauses étant facultatives. Les définitions de clauses ci-dessous contiennent également des exemples de requête NRQL .

### mot-clé DELETE [#delete]

Le mot-clé `DELETE` dans le langage de requête New Relic (NRQL) est utilisé pour supprimer des données et des attributs spécifiques dans le contrôle de pipeline. Cela permet de gérer les données ingérées dans la base de données New Relic (NRDB).

Le mot-clé `DELETE` est appliqué dans la requête NRQL pour spécifier quelles données ou quels attributs doivent être supprimés. Voici quelques exemples :

Voici quelques exemples :

* **Suppression de métriques spécifiques :**

  ```sql
  DELETE FROM Metric 
  WHERE metricName = 'newrelic.goldenmetrics.infra.kubernetes_pod.podScheduled'
  ```

  * Supprime les métriques portant le nom spécifié.

* **Suppression de plages spécifiques :**

  ```sql
  DELETE FROM Span WHERE appName = 'external-usage-consumer (test-odd-wire)'
  ```

  * Supprime les étendues associées à l&apos;application spécifiée.

* **Suppression de mises à jour d&apos;agents spécifiques :**

  ```sql
  DELETE FROM AgentUpdate WHERE a = 'b'
  ```

  * Supprime les mises à jour de l&apos;agent lorsque l&apos;attribut `a` est égal à `b`.

### Clauses obligatoires [#required]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="state-select"
    title={<>Obligatoire : instruction <InlineCode>
      SELECT
    </InlineCode></>
    }
  >
    ```sql
    SELECT attribute ...
    ```

    ```sql
    SELECT function(attribute) ...
    ```

    Le `SELECT` spécifie quelle partie d&apos;un type de données vous souhaitez interroger en spécifiant un [attribut](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#attribute) ou une [fonction](#functions). Il est suivi d&apos;un ou plusieurs arguments séparés par des virgules. Dans chaque argument vous pouvez :

    * Obtenez les valeurs de tous les attributs disponibles en utilisant `*` comme caractère générique. Par exemple : `SELECT * FROM Transaction`.
    * Obtenir les valeurs associées à un attribut spécifié ou à plusieurs attributs spécifiés dans une liste séparée par des virgules.
    * Obtenez des valeurs agrégées à partir d&apos;un attribut spécifié en sélectionnant une [fonction d&apos;agrégateur](#functions).
    * Étiquetez les résultats renvoyés dans chaque argument avec [la clause `AS` ](#sel-as).

    Vous pouvez également [utiliser `SELECT` avec des fonctions mathématiques de base](/docs/query-data/nrql-new-relic-query-language/getting-started/nrql-math-using-select).

    <CollapserGroup>
      <Collapser id="avg-resp-time-query" title="Temps de réponse moyen depuis la semaine dernière">
        Cette requête renvoie le temps de réponse moyen depuis la semaine dernière.

        ```sql
        SELECT average(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>

    Vous pouvez inclure à la fois le caractère générique `*` et l&apos;attribut individuel, [les fonctions](#non-aggregator-functions), les expressions mathématiques et [les variables NRQL ](#with-as-nrql-var)dans la même instruction `SELECT`. `*` peut apparaître au début ou à la fin de la liste `SELECT` , et les colonnes supplémentaires sélectionnées apparaîtront respectivement au début ou à la fin du tableau des résultats :

    ```sql
    SELECT *, attribute, function(attribute), attribute1 + attribute2 FROM ...
    ```

    ```sql
    WITH attribute1 + attribute2 AS attrSum SELECT attrSum, attribute, function(attribute), * FROM ...
    ```

    <CollapserGroup>
      <Collapser
        id="select-star-with-columns-query"
        title={<><InlineCode>
          SELECT *
        </InlineCode> avec des colonnes supplémentaires</>
        }
      >
        Cette requête renvoie tous les attributs PageView disponibles avec des colonnes supplémentaires au début.

        ```sql
        WITH concat('(', asnLatitude, ', ', asnLongitude, ')') AS coordinates
        SELECT coordinates, city, connectionSetupDuration + pageRenderingDuration AS partialDuration, *
        FROM PageView
        ```

        <img title="select star with additional columns" alt="select star with additional columns" src="/images/nrql_screenshot-select-star-with-additional-columns.webp" />

        <figcaption>
          <InlineCode>
            SELECT \*
          </InlineCode> avec exemple de colonnes supplémentaires
        </figcaption>
      </Collapser>
    </CollapserGroup>

    <Callout variant="tip">
      Seules [les fonctions non agrégatrices](#non-aggregator-functions) sont prises en charge dans la liste `SELECT` avec `*`.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-from"
    title={<>Obligatoire : clause <InlineCode>
      FROM
    </InlineCode></>
    }
  >
    ```sql
    SELECT ...
    FROM data type
    ...
    ```

    Utilisez la clause `FROM` pour spécifier le [type de données](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql#what-you-can-query) que vous souhaitez interroger. Vous pouvez commencer votre requête avec `FROM` ou avec [`SELECT`](#state-select). Vous pouvez fusionner des valeurs pour le même attribut sur plusieurs types de données dans une liste séparée par des virgules.

    <CollapserGroup>
      <Collapser id="one-event" title="Type de données de la requête 1">
        Cette requête renvoie le nombre de toutes [les transactions APM](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) au cours des sept derniers jours :

        ```sql
        SELECT count(*) FROM Transaction SINCE 7 days ago
        ```
      </Collapser>

      <Collapser id="multiple-events" title="requête sur plusieurs types de données">
        Cette requête renvoie le nombre de toutes [les transactions APM](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) et [des événements du navigateur](/docs/insights/new-relic-insights/decorating-events/browser-default-attributes-insights#browser-attributes-table) au cours des trois derniers jours :

        ```sql
        SELECT count(*) FROM Transaction, PageView SINCE 3 days ago
        ```
      </Collapser>

      <Collapser id="from-lookups" title="requête de données à partir d'une table de recherche">
        Voir [`lookup()`](#func-lookup).
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### Clauses facultatives [#optional]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="sel-as"
    title={<><InlineCode>
      AS
    </InlineCode> clause</>
    }
  >
    ```sql
    SELECT ...
    AS 'label'
    ...
    ```

    Utilisez la clause `AS` pour étiqueter un attribut, un agrégateur, une étape dans un entonnoir ou le résultat d&apos;une fonction mathématique avec une chaîne délimitée par des guillemets simples. L&apos;étiquette est utilisée dans le graphique résultant. Notez que les étiquettes de clause `AS` dans les graphiques de séries chronologiques ne seront pas affichées si une clause `FACET` est utilisée.

    <CollapserGroup>
      <Collapser
        id="math-as"
        title={<>requête utilisant la fonction mathématique et <InlineCode>
          AS
        </InlineCode></>
        }
      >
        Cette requête renvoie le nombre de pages vues par session :

        ```sql
        SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session'
        FROM PageView
        ```
      </Collapser>

      <Collapser
        id="funnel-as"
        title={<>requête utilisant des entonnoirs et <InlineCode>
          AS
        </InlineCode></>
        }
      >
        Cette requête renvoie le nombre de personnes qui ont visité à la fois la page principale et la page carrières d&apos;un site au cours de la semaine écoulée :

        ```sql
        SELECT funnel(SESSION,
          WHERE name = 'Controller/about/main' AS 'Step 1',
          WHERE name = 'Controller/about/careers' AS 'Step 2')
        FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-compare"
    title={<><InlineCode>
      COMPARE WITH
    </InlineCode> clause</>
    }
  >
    ```sql
    SELECT ... 
    (SINCE or UNTIL) (integer units) AGO
    COMPARE WITH (integer units) AGO
    ...
    ```

    Utilisez la clause `COMPARE WITH` pour comparer les valeurs de deux plages horaires différentes.

    `COMPARE WITH` nécessite une instruction `SINCE` ou `UNTIL` . Le temps spécifié par `COMPARE WITH` est relatif au temps spécifié par `SINCE` ou `UNTIL`. Par exemple, `SINCE 1 day ago COMPARE WITH 1 day ago` compare hier avec la veille.

    La plage horaire pour la valeur`COMPARE WITH` est toujours la même que celle spécifiée par `SINCE` ou `UNTIL`. Par exemple, `SINCE 2 hours ago COMPARE WITH 4 hours ago` peut comparer la période de 15h00 à 17h00 avec la période de 11h00 à 13h00.

    `COMPARE WITH` peut être formaté soit sous forme de graphique linéaire, soit sous forme de panneau d&apos;affichage :

    * Avec `TIMESERIES`, `COMPARE WITH` crée un graphique linéaire avec la comparaison mappée au fil du temps.
    * Sans `TIMESERIES`, `COMPARE WITH` génère un panneau d&apos;affichage avec la valeur actuelle et le pourcentage de changement par rapport à la valeur `COMPARE WITH` .

    <DNT>**Example**</DNT>:Cette requête renvoie des données sous forme de graphique linéaire affichant le 95e percentile de la semaine dernière par rapport à la même plage il y a une semaine. D&apos;abord sous forme de valeur unique, puis sous forme de graphique linéaire.

    ```sql
    SELECT percentile(duration, 95) FROM PageView
    SINCE 1 week ago COMPARE WITH 1 week AGO

    SELECT percentile(duration, 95) FROM PageView
    SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO
    ```

    <Callout variant="important">
      Pour la requête `FACET` utilisant `COMPARE WITH`, les facettes du résultat sont sélectionnées en fonction de la plage horaire spécifiée à l&apos;aide `SINCE` et `UNTIL` et non de la plage horaire précédente comparée. Les résultats d’une requête `FACET` portant uniquement sur la plage de temps précédente peuvent inclure un ensemble différent de facettes.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="extrapolate"
    title={<><InlineCode>
      EXTRAPOLATE
    </InlineCode> clause</>
    }
  >
    Vous pouvez utiliser cette clause avec ces types de données :

    * `Transaction`

    * `TransactionError`

    * événement personnalisé signalé via <InlinePopover type="apm" />API d&apos;agent

      L&apos;objectif de `EXTRAPOLATE` est de compenser mathématiquement les effets de [l&apos;échantillonnage des données d&apos;événement par l&apos;agent APM](/docs/agents/manage-apm-agents/agent-data/new-relic-events-limits-sampling) afin que les résultats de la requête représentent plus fidèlement l&apos;activité totale de votre système.

      Cette clause sera utile lorsqu&apos;un agent APM signale tellement d&apos;[événements](/docs/using-new-relic/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#event-data) qu&apos;il dépasse souvent ses limites de rapport [de cycle de collecte](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#harvest-cycle) . Lorsque cela se produit, l’agent commence à échantillonner l’événement.

      Lorsque `EXTRAPOLATE` est utilisé dans une requête NRQL qui prend en charge son utilisation, le rapport entre <DNT>**reported events**</DNT> et <DNT>**total events**</DNT> est utilisé pour extrapoler une approximation proche des données totales non échantillonnées. Lorsqu&apos;il est utilisé dans une requête NRQL qui ne prend pas en charge son utilisation ou qui n&apos;a pas utilisé de données échantillonnées, il n&apos;a aucun effet.

      <Callout variant="important">
        Notez que `EXTRAPOLATE` est particulièrement utile pour les données homogènes (comme le débit ou le taux d&apos;erreur). Ce n&apos;est pas efficace lorsqu&apos;on tente d&apos;extrapoler un nombre de choses distinctes (comme `uniqueCount()` ou `uniques()`).
      </Callout>

      Cette clause fonctionne uniquement avec les requêtes NRQL qui utilisent l&apos;une des [fonctions d&apos;agrégation](/docs/insights/nrql-new-relic-query-language/nrql-reference/nrql-syntax-components-functions#functions) suivantes :

    * `apdex`

    * `average`

    * `count`

    * `histogram`

    * `sum`

    * `percentage` (si la fonction qu&apos;elle prend comme argument supporte `EXTRAPOLATE`)

    * `rate` (si la fonction qu&apos;elle prend comme argument supporte `EXTRAPOLATE`)

    * `stddev`

      <CollapserGroup>
        <Collapser id="extrapolate-example-1" title="Exemple d'extrapolation du débit">
          Une requête qui affichera le débit extrapolé d&apos;un service nommé `interestingApplication`.

          ```sql
          SELECT count(*) FROM Transaction WHERE appName = 'interestingApplication' 
          SINCE 60 minutes ago EXTRAPOLATE
          ```
        </Collapser>

        <Collapser id="extrapolate-example-2" title="Exemple d'extrapolation du débit sous forme de série chronologique">
          Une requête qui affichera le débit extrapolé d&apos;un service nommé `interestingApplication` par nom de transaction, affiché sous forme de série chronologique.

          ```sql
          SELECT count(*) FROM Transaction WHERE appName = 'interestingApplication'
          SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet"
    title={<><InlineCode>
      FACET
    </InlineCode> clause</>
    }
  >
    ```sql
    SELECT ...
    FACET attribute
    ...
    ```

    Utilisez `FACET` pour séparer et regrouper vos résultats par valeurs d’attribut. Par exemple, vous pouvez `FACET` vos données `PageView` à `deviceType` pour déterminer quel pourcentage de votre trafic provient des appareils mobiles, des tablettes et des ordinateurs de bureau.

    Utilisez la clause `LIMIT` pour spécifier le nombre de facettes qui apparaissent (la valeur par défaut est 10). Pour un regroupement plus complexe, utilisez [`FACET CASES`](#sel-facet-cases). Les clauses `FACET` prennent en charge jusqu&apos;à cinq attributs, séparés par des virgules.

    Les facettes sont triées par ordre décroissant en fonction du premier champ que vous fournissez dans la clause `SELECT` . Si vous effectuez un facettage sur un attribut avec plus de 5 000 valeurs uniques, un sous-ensemble de valeurs de facette est sélectionné et trié en fonction du type de requête. Notez que si un graphique de séries chronologiques ne renvoie aucune donnée (correspondance NRQL sans données correspondantes, NRQL non valide, etc.), il affichera uniquement une ligne plate avec l&apos;étiquette correspondant à la première table de la clause `FROM` .

    Lors de la sélection de `min()`, `max()`, `percentile()`, `average()` ou `count()`, `FACET` utilise ces fonctions pour déterminer comment les facettes sont sélectionnées et triées. Lorsque vous sélectionnez une autre [fonction](#functions), `FACET` utilise la fréquence de l&apos;attribut sur lequel vous effectuez le facettage pour déterminer comment les facettes sont sélectionnées et triées.

    <CollapserGroup>
      <Collapser
        id="faceted-query"
        title={<>Requête à facettes utilisant <InlineCode>
          count()
        </InlineCode></>
        }
      >
        Cette requête affiche les villes avec le nombre de pages vues le plus élevé. Cette requête utilise le nombre total de pages vues par ville pour déterminer comment les facettes sont sélectionnées et classées.

        ```sql
        SELECT count(*) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="uniquecount"
        title={<>Requête à facettes utilisant <InlineCode>
          uniqueCount()
        </InlineCode></>
        }
      >
        Cette requête affiche les villes qui accèdent au plus grand nombre d&apos;URL uniques. Cette requête utilise le nombre total de fois qu&apos;une ville particulière apparaît dans les résultats pour déterminer comment les facettes sont sélectionnées et classées.

        ```sql
        SELECT uniqueCount(pageUrl) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser id="cohort-analysis" title="Regroupement des résultats dans le temps">
        [La segmentation avancée](/docs/insights/new-relic-insights/features/advanced-segmentation) et [l&apos;analyse de cohorte](/docs/insights/new-relic-insights/features/cohort-analysis-grouping-results-across-time) vous permettent d&apos;effectuer des facettes sur des fonctions de compartiment pour répartir plus efficacement vos données.

        L’analyse de cohorte est un moyen de regrouper les résultats en fonction d’un horodatage. Vous pouvez les séparer en groupes couvrant une plage spécifiée de dates et d&apos;heures.
      </Collapser>
    </CollapserGroup>

    <Callout variant="important">
      Lorsque vous utilisez des fonctions pour agréger des valeurs d&apos;attribut, il est important que l&apos;attribut agrégé dans la première fonction de votre requête contienne des valeurs non nulles. Les facettes ne seront choisies que pour les lignes contenant une valeur non nulle pour l&apos;attribut dans la première fonction.

      Exemple:

      ```sql
      FROM Event SELECT average(attribute) FACET name
      ```

      Les noms ne seront choisis qu&apos;à partir des lignes où l&apos;attribut n&apos;est pas nul.

      Pour vérifier si l&apos;attribut que vous utilisez dans votre fonction contient des valeurs non nulles, exécutez la requête suivante :

      ```sql
      FROM Event SELECT attribute, name WHERE attribute IS NOT NULL
      ```
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="facet-as"
    title={<><InlineCode>
      FACET ... AS
    </InlineCode> clause</>
    }
  >
    Utilisez `FACET ... AS` pour nommer les facettes en utilisant le mot-clé `AS` dans la requête. Cette clause est utile pour ajouter des noms plus clairs ou simplifiés pour les facettes dans vos résultats. Il peut également être utilisé pour renommer des facettes dans une requête [d&apos;agrégation imbriquée](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query) .

    `FACET ... AS` la requête modifiera les noms des facettes dans les résultats (lorsqu&apos;ils apparaissent comme en-têtes dans les tableaux, par exemple), mais pas les noms des facettes eux-mêmes.

    ```sql
    FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type'
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-cases"
    title={<><InlineCode>
      FACET CASES
    </InlineCode> clause</>
    }
  >
    ```sql
    SELECT ...
    FACET CASES 
    (
      WHERE attribute operator value, 
      WHERE attribute operator value, 
      ...
    )
    ...
    ```

    Utilisez `FACET CASES` pour décomposer vos données selon des conditions plus complexes que possible avec [`FACET`](#sel-facet). Séparez les conditions multiples par une virgule `,`. Par exemple, vous pouvez interroger vos données `PageView` et `FACET CASES` dans des catégories telles que moins d&apos;une seconde, de 1 à 10 secondes et plus de 10 secondes. Vous pouvez combiner plusieurs attributs dans vos cas et étiqueter les cas avec le sélecteur [`AS`](#sel-as) . Les points de données seront ajoutés à un seul cas de facette au plus, le premier cas de facette auquel ils correspondent.

    Vous pouvez également utiliser une [fonction temporelle](/docs/query-data/nrql-new-relic-query-language/nrql-query-examples/group-results-across-time) avec votre attribut et utiliser l&apos;opérateur `OR` pour facetter les résultats qui ne correspondent à aucun de vos cas spécifiés.

    <CollapserGroup>
      <Collapser
        id="facet-cases-basic"
        title={<>Utilisation de base avec <InlineCode>
          WHERE
        </InlineCode></>
        }
      >
        ```sql
        SELECT count(*) FROM PageView 
        FACET CASES 
        (
          WHERE duration < 1, 
          WHERE duration > 1 AND duration < 10, 
          WHERE duration > 10
        )
        ```
      </Collapser>

      <Collapser id="facet-cases-mixnmatch" title="Groupe basé sur plusieurs attributs">
        Cet exemple regroupe les résultats dans un compartiment où le nom de la transaction contient `login` et un autre où l&apos;URL contient `login` et un attribut personnalisé indique que l&apos;utilisateur était un utilisateur payant :

        ```sql
        SELECT count(*) FROM Transaction 
        FACET CASES 
        (
          WHERE name LIKE '%login%', 
          WHERE name LIKE '%feature%' AND customer_type = 'Paid'
        )
        ```
      </Collapser>

      <Collapser
        id="facet-cases-as-label"
        title={<>Groupes d'étiquettes avec <InlineCode>
          AS
        </InlineCode></>
        }
      >
        Cet exemple utilise le sélecteur [`AS`](#sel-as) pour donner à vos résultats un nom lisible par l&apos;homme :

        ```sql
        SELECT count(*) FROM Transaction 
        FACET CASES 
        (
          WHERE name LIKE '%login%' AS 'Total Logins', 
          WHERE name LIKE '%feature%' AND customer_type = 'Paid' AS 'Feature Visits from Paid Users'
        )
        ```
      </Collapser>

      <Collapser
        id="facet-cases-with-or"
        title={<>Données non correspondantes à la facette avec <InlineCode>
          OR
        </InlineCode></>
        }
      >
        Cet exemple utilise l&apos;opérateur `OR` pour facetter les résultats qui ne correspondent à aucun de vos cas :

        ```sql
        SELECT count(*) FROM Transaction 
        FACET CASES 
        (
          WHERE name LIKE '%login%', 
          WHERE name LIKE '%feature%' AND customer_type = 'Paid'
        ) 
        OR name
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-order"
    title={<><InlineCode>
      FACET ... ORDER BY
    </InlineCode> clause</>
    }
  >
    Dans NRQL, la valeur par défaut est que la première agrégation dans la clause `SELECT` guide la sélection des facettes dans une requête. `FACET ... ORDER BY` vous permet de remplacer ce comportement par défaut en ajoutant une fonction d&apos;agrégation avec le modificateur `ORDER BY` pour spécifier comment les facettes sont sélectionnées. Plus précisément, la clause remplacera la priorité selon laquelle les facettes sont choisies pour figurer dans le résultat final avant d&apos;être limitées par la clause `LIMIT` . Cette clause peut être utilisée dans les requêtes mais pas pour les alertes ou le streaming.

    Cet exemple montre comment utiliser `FACET ... ORDER BY` pour trouver les durées moyennes des transactions d&apos;application, en affichant les 10 durées les plus élevées (limite par défaut) par application ayant la taille de réponse la plus élevée. Dans ce cas, si `FACET ... ORDER BY` n&apos;est pas utilisé, les résultats de la requête afficheront à la place les 10 premiers par durée la plus élevée, la taille de la réponse n&apos;étant pas pertinente pour la sélection de l&apos;application.

    ```sql
    FROM Transaction SELECT average(duration) TIMESERIES 
    FACET appName ORDER BY max(responseSize)
    ```

    Gardez à l’esprit que si vous utilisez la clause `FACET ... ORDER BY` , vous ne pouvez pas modifier l’ordre de tri en ajoutant les modificateurs `ASC` et `DESC` . Par défaut, cette clause utilise `DESC`.

    <Callout variant="tip">
      Étant donné que les opérations sont effectuées avant l&apos;application de la clause `LIMIT` , `FACET ... ORDER BY` n&apos;a pas d&apos;impact sur le type de résultats de la requête finale, ce qui sera particulièrement visible dans les résultats des requêtes sans séries temporelles.
    </Callout>

    <Callout variant="important">
      Le modificateur `ORDER BY` dans ce cas fonctionne différemment de la clause `ORDER BY` . Lors de l&apos;analyse des requêtes qui suivent le format `FACET attribute1 ORDER BY attribute2`, New Relic les lira comme des requêtes `FACET ... ORDER BY` , mais seulement si `ORDER BY` apparaît immédiatement après `FACET`. Sinon, `ORDER BY` sera interprété par New Relic comme une clause.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-join"
    title={<><InlineCode>
      JOIN
    </InlineCode> clause</>
    }
  >
    Utilisez la clause `JOIN` pour combiner les données d’un type d’événement avec les résultats d’une sous-requête basée sur un attribut ou une clé commune.

    ```sql
    FROM Event [INNER|LEFT] JOIN (SELECT... FROM...) ON [key =] key SELECT ...
    ```

    Il existe quelques règles simples pour les jointures de sous-requêtes :

    * La clause `JOIN` doit toujours suivre immédiatement la clause [`FROM`](#sel-from) .
    * La préfixation d&apos;un type de jointure (`INNER` ou `LEFT`) est facultative. Lorsqu&apos;il est omis, le type de jointure par défaut est `INNER`.
    * Les parenthèses contenant une [sous-requête](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql) doivent immédiatement suivre `JOIN`.
    * La clause `ON` doit immédiatement suivre la sous-requête.

    <table id="join-types">
      <thead>
        <tr>
          <th colSpan={2}>
            <DNT>
              **Join types**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td style={{ width: "300px" }}>
            `INNER`
          </td>

          <td>
            Le résultat inclura uniquement les valeurs de la requête externe qui ont une valeur correspondante dans les résultats de la sous-requête jointe. Il s&apos;agit du type de jointure par défaut.
          </td>
        </tr>

        <tr>
          <td>
            `LEFT`
          </td>

          <td>
            Le résultat inclura les événements de la requête externe qui n&apos;ont pas de correspondance avec la sous-requête jointe.
          </td>
        </tr>
      </tbody>
    </table>

    <table id="join-on">
      <thead>
        <tr>
          <th colSpan={2}>
            <DNT>
              **Join `ON` clause**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td style={{ width: "300px" }}>
            `ON parentKey = subqueryKey`
          </td>

          <td>
            Définit la valeur clé à comparer dans la sous-requête et la requête externe. Le seul opérateur de comparaison autorisé est l&apos;égalité.

            * Le côté gauche est toujours la clé utilisée dans la requête parent et peut être un attribut ou une fonction.
            * Le côté droit est utilisé pour la valeur clé de la sous-requête, et doit être un identifiant.
          </td>
        </tr>

        <tr>
          <td>
            `ON key`
          </td>

          <td>
            Il s&apos;agit d&apos;une syntaxe abrégée lorsque l&apos;identifiant de clé est le même dans les deux contextes. Cela équivaut à `ON key = key`.
          </td>
        </tr>
      </tbody>
    </table>

    Restrictions et limitations à prendre en compte :

    * La sous-requête jointe continuera d&apos;avoir une valeur par défaut [`LIMIT`](#sel-limit) de 10, avec un maximum `LIMIT` de 5 000. Notez que le `LIMIT` de la requête externe n&apos;affecte pas la requête interne.
    * L&apos;utilisation de `TIMESERIES` dans la sous-requête jointe n&apos;est pas prise en charge. Si votre requête externe utilise `TIMESERIES`, gardez à l&apos;esprit que la sous-requête jointe fournira un seul résultat pour toute la durée de la requête.
    * Comme toutes les sous-requêtes, les sous-requêtes jointes ne peuvent pas être utilisées en condition d&apos;alerte.
    * Bien que `SELECT *` soit pris en charge dans la requête parent, il n&apos;est pas pris en charge dans la sous-requête jointe.
    * La cardinalité de la jointure est limitée à 1 : 100, ce qui signifie qu&apos;une seule clé de jointure ne peut pas correspondre à plus de cent lignes dans le résultat de la sous-requête.

    Pour un examen approfondi de la clause `JOIN` , veuillez consulter le didacticiel [sur les jointures de sous-requêtes NRQL](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/subquery-joins) .

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          INNER JOIN
        </InlineCode> avec une sous-requête à facettes</>
        }
        id="example-faceted-inner-join"
      >
        Cette requête trouve le nombre d&apos;événements à facettes par `browserTransactionName` à partir du type d&apos;événement `PageView` , puis par `currentUrl` à partir du type d&apos;événement `PageAction` . Cela joint les deux types d&apos;événements en fonction des valeurs d&apos;attribut `session` communes.

        ```sql
        FROM PageView
        JOIN 
        (
          FROM PageAction 
          SELECT count(*) 
          FACET session, currentUrl
        ) 
        ON session
        SELECT count(*) FACET browserTransactionName, currentUrl
        ```

        <img title="screenshot faceted inner join" alt="screenshot faceted inner join" src="/images/nrql_screenshot-crop_example-faceted-inner-join.webp" />

        <figcaption>
          Exemple de <InlineCode>
            INNER JOIN
          </InlineCode> à facettes
        </figcaption>
      </Collapser>

      <Collapser
        title={<><InlineCode>
          LEFT JOIN
        </InlineCode> avec une sous-requête à facettes</>
        }
      >
        Cet exemple interroge les mêmes données que l&apos;[exemple à facettes `INNER JOIN` ](#example-faceted-inner-join), mais en tant que requête `LEFT JOIN` , les résultats incluent des éléments de la table `PageView` qui n&apos;ont pas de valeurs `session` correspondantes dans les résultats de la sous-requête `PageAction` .

        ```sql
        FROM PageView
        LEFT JOIN 
        (
          FROM PageAction 
          SELECT count(*) 
          FACET session, currentUrl
        ) 
        ON session
        SELECT count(*) FACET browserTransactionName, currentUrl
        ```

        <img title="screenshot faceted left join" alt="screenshot faceted left join" src="/images/nrql_screenshot-crop_example-faceted-left-join.webp" />

        <figcaption>
          Exemple de <InlineCode>
            LEFT JOIN
          </InlineCode> à facettes
        </figcaption>
      </Collapser>

      <Collapser
        title={<><InlineCode>
          INNER JOIN
        </InlineCode> avec une sous-requête non agrégée</>
        }
      >
        Ici, nous effectuons une sous-requête non agrégée, ligne par ligne, avec la requête externe trouvant le nombre d&apos;événements à facettes par `currentUrl` à partir du type d&apos;événement `PageAction` , puis par `browserTransactionNamed` à partir du type d&apos;événement `PageView` . Cela joint les deux types d&apos;événements en fonction des valeurs d&apos;attribut `session` communes.

        Notez que la valeur `session` `34d5ce6acf4c60be` a deux valeurs `browserTransactionName` du type d&apos;événement `PageView` de la sous-requête, ajoutant des lignes supplémentaires au résultat.

        ```sql
        FROM PageAction
        LEFT JOIN 
        (
          FROM PageView 
          SELECT session, browserTransactionName 
          LIMIT MAX
        ) 
        ON session
        SELECT count(*) FACET session, currentUrl, browserTransactionName LIMIT MAX
        ```

        <img title="screenshot columnar inner join" alt="screenshot columnar inner join" src="/images/nrql_screenshot-crop_example-columnar-inner-join.webp" />

        <figcaption>
          Exemple non agrégé <InlineCode>
            INNER JOIN
          </InlineCode>
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-limit"
    title={<><InlineCode>
      LIMIT
    </InlineCode> clause</>
    }
  >
    ```sql
    SELECT ...
    LIMIT count
    ...
    ```

    Utilisez la clause `LIMIT` pour contrôler le nombre maximal de valeurs de facette renvoyées par la requête `FACET` ou le nombre maximal d&apos;éléments renvoyés par la requête `SELECT *` . Cette clause prend une seule valeur entière comme argument. Si la clause `LIMIT` n&apos;est pas spécifiée ou si aucune valeur n&apos;est fournie, la limite par défaut est de 10 pour la requête `FACET` et de 100 dans le cas de la requête `SELECT *` .

    La valeur maximale autorisée pour la clause `LIMIT` est 5 000. la requête peut utiliser la clause `LIMIT MAX` au lieu d&apos;une valeur spécifique, qui correspond automatiquement par défaut à la valeur maximale actuelle. Vous pouvez l&apos;utiliser si vous souhaitez toujours publier le nombre maximum de résultats, même s&apos;il change à l&apos;avenir. Si vous souhaitez que le comportement de votre requête reste inchangé, spécifiez une valeur explicite au lieu d&apos;utiliser `LIMIT MAX`.

    <CollapserGroup>
      <Collapser
        title={<>requête utilisant <InlineCode>
          LIMIT
        </InlineCode></>
        }
      >
        Cette requête affiche les 20 premiers pays par nombre de sessions et fournit le 95e percentile des temps de réponse pour chaque pays pour les utilisateurs Windows uniquement.

        ```sql
        SELECT uniqueCount(session), percentile(duration, 95)
        FROM PageView WHERE userAgentOS = 'Windows'
        FACET countryCode LIMIT 20 SINCE YESTERDAY
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-offset"
    title={<><InlineCode>
      OFFSET
    </InlineCode> clause</>
    }
  >
    ```sql
    SELECT ...
    LIMIT count OFFSET count
    ...
    ```

    Utilisez la clause `OFFSET` avec `LIMIT` pour contrôler la partie des lignes renvoyées par la requête `SELECT *` ou `SELECT column` . Comme la clause `LIMIT` , `OFFSET` prend une seule valeur entière comme argument. `OFFSET` définit le nombre de lignes à ignorer avant que les lignes sélectionnées de votre requête ne soient renvoyées. Ceci est limité par `LIMIT`.

    `OFFSET` les lignes sont ignorées à partir de l&apos;enregistrement le plus récent.

    Par exemple, la requête `SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1` renvoie les 5 dernières valeurs de `Minute_Report` à l’exception de la plus récente.
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-order-by"
    title={<><InlineCode>
      ORDER BY
    </InlineCode> clause</>
    }
  >
    La clause `ORDER BY` vous permet de spécifier comment vous souhaitez trier les résultats de votre requête dans une requête qui sélectionne l&apos;attribut événement par ligne.

    Cette requête ordonne deux attributs de transaction spécifiques par durée.

    ```sql
    FROM Transaction SELECT appName, duration ORDER BY duration
    ```

    L&apos;ordre de tri par défaut est croissant, mais cela peut être modifié en ajoutant les modificateurs `ASC` ou `DESC` .

    Cette requête classe tous les attributs de transaction par durée dans l&apos;ordre décroissant.

    ```sql
    FROM Transaction SELECT * ORDER BY duration DESC
    ```

    <Callout variant="important">
      La clause `ORDER BY` ne s&apos;applique pas à la requête `FACET` . Il ne faut pas la confondre avec la clause `FACET ... ORDER BY` , qui guide la sélection des facettes. Pour plus d&apos;informations, voir [`FACET ... ORDER BY`](#sel-facet-order).
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="#sel-prediction"
    title={<><InlineCode>
      PREDICT
    </InlineCode> clause</>
    }
  >
    <Callout title="Aperçu">
      Nous travaillons toujours sur cette fonctionnalité, mais nous aimerions que vous l&apos;essayiez !

      Cette fonctionnalité est actuellement fournie dans le cadre d&apos;un programme d&apos;aperçu conformément à nos [politiques de pré-sortie](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy).
    </Callout>

    ```sql
    FROM Transaction SELECT count(*) WHERE error IS TRUE TIMESERIES PREDICT
    ...
    ```

    Avec la clause `PREDICT` , vous pouvez ajouter des prédictions de tendances de données futures dans des graphiques linéaires basés sur des données historiques. Tenez compte des points suivants lorsque vous utilisez cette clause :

    * S&apos;applique uniquement aux requêtes avec une clause `TIMESERIES` .
    * Utilise `TIMESERIES <time period>` comme intervalle pour les points de données prédits.
    * Ne prend pas en charge [les données d&apos;intervalle de temps métrique](/docs/data-analysis/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#timeslice-data) en mode Aperçu public.

    <Callout variant="important">
      La clause `PREDICT` ne peut pas être utilisée avec la clause [`COMPARE WITH`](/docs/nrql/nrql-syntax-clauses-functions/#sel-compare) ou [des agrégations imbriquées](/docs/nrql/using-nrql/nested-aggregation-make-ordered-computations-single-query) dans [des sous-requêtes](/docs/nrql/using-nrql/subqueries-in-nrql/).
    </Callout>

    ### Personnalisation

    Vous pouvez personnaliser les prédictions en définissant manuellement les hyperparamètres du modèle d&apos;entraînement et en ajoutant les mots-clés `USING` et `BY` . Pour en savoir plus sur NRQL et sa syntaxe, reportez-vous à [la documentation NRQL](/docs/nrql/get-started/introduction-nrql-new-relics-query-language).

    <CollapserGroup>
      <Collapser id="predict-defaults" title="Valeurs par défaut">
        La clause PREDICT dans une requête est livrée avec les comportements par défaut suivants :

        Saisonnalité : détecte automatiquement si la saisonnalité est présente dans les données historiques. Si une saisonnalité est détectée, la durée de la saison identifiée est utilisée dans l&apos;algorithme saisonnier Holt-Winters. Si aucune saisonnalité n’est trouvée, il construit un modèle non saisonnier.

        Hyperparamètres : définit les hyperparamètres de l’algorithme Holt-Winters en fonction de la saisonnalité et des données historiques.

        Fenêtre de prédiction : prédit une plage égale à 20 % de la durée totale spécifiée dans votre fenêtre de requête.

        Données historiques pour la formation : utilise les données historiques de la fenêtre de requête actuelle et des deux précédentes pour générer des prédictions.

        Intervalle de temps : s&apos;aligne sur l&apos;intervalle de points de données de la série chronologique dans la fenêtre de requête pour garantir la cohérence de la projection des données.
      </Collapser>

      <Collapser id="hyperparameters" title="Définir la saisonnalité et les hyperparamètres du modèle Holt-Winters.">
        Actuellement, <DNT>**NRQL predictions**</DNT> prend uniquement en charge l&apos;algorithme <DNT>**[Holt-Winters](https://en.wikipedia.org/wiki/Exponential_smoothing#Triple_exponential_smoothing_\(Holt_Winters\))**</DNT>, également connu sous le nom de lissage exponentiel, pour les séries chronologiques saisonnières et non saisonnières. Il s’agit d’un algorithme couramment utilisé et standard pour les tâches de prévision et de prédiction. Nous prenons en charge les durées saisonnières horaires, quotidiennes et hebdomadaires pour le modèle Holt-Winters. Les autres hyperparamètres de l’algorithme Holt-Winters sont accessibles et modifiables, mais les valeurs par défaut sont déterminées en fonction des données historiques de votre métrique. Les hyperparamètres peuvent être modifiés en ajoutant `holtwinters(<hyperparameter>: <value>)` après la clause `PREDICT` dans votre requête. N&apos;importe quelle combinaison des paramètres suivants peut être ajoutée pour modifier le résultat des prédictions :

        * `seasonality` Spécifie si vous souhaitez utiliser une durée de saison connue, une détection automatique de saisonnalité ou aucune saisonnalité (`<season length>`, `AUTO`, `NONE`).
          * `<season length>` doit être un `integer unit` de temps (c&apos;est-à-dire, `1 day` ou `3 hours`)
        * `alpha` Le facteur de lissage de niveau (`[0, 1.0]`) où une valeur plus grande donne plus de poids aux valeurs récentes
        * `beta` Le facteur de lissage de tendance (`[0, 1.0]`) où une valeur plus grande donne plus de poids aux valeurs récentes
        * `gamma` Le facteur de lissage saisonnier (`[0, 1.0]`) où une valeur plus grande donne plus de poids aux valeurs récentes
          * Non compatible avec l&apos;option `seasonality: NONE` car un modèle non saisonnier n&apos;utilise pas l&apos;hyperparamètre `gamma`. La requête renverra une erreur si vous essayez de spécifier `holtwinters(seasonality: NONE, gamma: <value>)`
        * `phi` Le paramètre d&apos;amortissement de la tendance (`[0.98, 1.0]`) où une valeur plus petite indique un amortissement plus important de la tendance et une prédiction qui s&apos;aplatira

        Exemple de requête avec modifications d&apos;hyperparamètres :

        ```sql
        FROM Transaction SELECT count(*) WHERE error IS TRUE TIMESERIES PREDICT holtwinters(seasonality: 1 hour, alpha: 0.2, beta: 0.5, gamma: 0.5, phi: 0.99)
        ```
      </Collapser>

      <Collapser
        id="by"
        title={<>Ajoutez le mot-clé <InlineCode>
          BY
        </InlineCode> .</>
        }
      >
        Utilisez le mot-clé `BY` pour définir la période à laquelle vous souhaitez que le modèle prédise. Par exemple, `PREDICT BY 3 hours` génère une prédiction de trois heures dans le futur à partir du dernier point de la série chronologique. Assurez-vous que la durée est de `integer unit`. Le montant maximum que vous pouvez prédire est de 360 fenêtres temporelles (c&apos;est-à-dire la taille de votre fenêtre de série temporelle multipliée par 360).

        Exemple de requête avec le mot-clé `BY` qui générera des prédictions pour les 30 prochaines minutes :

        ```sql
        FROM Transaction SELECT count(*) WHERE error IS TRUE TIMESERIES PREDICT BY 30 minutes
        ```
      </Collapser>

      <Collapser
        id="using"
        title={<>Ajoutez le mot-clé <InlineCode>
          USING
        </InlineCode> .</>
        }
      >
        Utilisez le mot-clé `USING` pour spécifier la quantité de données historiques que vous souhaitez utiliser pour entraîner le modèle. Par exemple, `PREDICT USING 1 day` utilise la fenêtre de requête avec les données du jour précédent pour former le modèle. Assurez-vous que la durée est un nombre entier (`integer unit`). Il existe une limite à la quantité de données pouvant être utilisée pour entraîner un modèle et si vous spécifiez une quantité qui dépasse la limite, vous recevrez un message d&apos;erreur. Cette limite est de 3 660 points de données et vous pouvez déterminer combien de temps cela représente en utilisant la fenêtre de séries chronologiques. Ainsi, par exemple, si vous interrogez une série chronologique avec une fenêtre temporelle d&apos;une minute, vous ne pourrez spécifier qu&apos;une quantité de données d&apos;entraînement allant jusqu&apos;à 3 660 minutes, soit 61 heures ou environ 2,5 jours.

        Exemple de requête avec le mot-clé `USING` qui utilisera 2 jours de données historiques :

        ```sql
        FROM Transaction SELECT count(*) WHERE error IS TRUE TIMESERIES PREDICT USING 2 days
        ```
      </Collapser>
    </CollapserGroup>

    Exemple de requête avec la clause `PREDICT` spécifiant des hyperparamètres personnalisés et ajoutant les mots-clés `BY` et `USING` :

    ```sql
    FROM Transaction SELECT count(*) WHERE error IS TRUE TIMESERIES PREDICT holtwinters(seasonality: AUTO, alpha: 0.2) BY 1 hour USING 2 hours
    ```

    Cette requête définit la saisonnalité sur la détection automatique et met l&apos;accent sur les données historiques en ajustant le facteur de lissage de niveau. Il prédit une heure dans le futur et entraîne le modèle en utilisant la longueur de la fenêtre de requête ainsi que les deux heures précédentes de données historiques.

    Pour en savoir plus sur comment et quand vous pouvez utiliser `PREDICT`, reportez-vous à [Prédictions NRQL](/docs/query-your-data/explore-query-data/use-charts/nrql-predictions/).
  </Collapser>

  <Collapser
    className="freq-link"
    id="show-event-types"
    title={<><InlineCode>
      SHOW EVENT TYPES
    </InlineCode> clause</>
    }
  >
    ```sql
    SHOW EVENT TYPES...
    ```

    `SHOW EVENT TYPES` renverra une liste de tous les types de données présents dans votre compte pour une plage horaire spécifique. Il est utilisé comme première clause dans une requête au lieu de `SELECT`.

    <Callout variant="important">
      Dans ce contexte, « types d&apos;événements » fait référence aux types de données auxquels vous pouvez accéder avec une requête NRQL .
    </Callout>

    <CollapserGroup>
      <Collapser id="avg-resp-time-query" title="Types de données au cours du dernier jour">
        Cette requête renverra tous les types de données présents au cours de la dernière journée :

        ```sql
        SHOW EVENT TYPES SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-since"
    title={<><InlineCode>
      SINCE
    </InlineCode> clause</>
    }
  >
    ```sql
    SELECT ...
    SINCE [numerical units AGO | phrase]
    ...
    ```

    La valeur <DNT>**default**</DNT> est <DNT>**1 hour ago**</DNT>.

    Utilisez la clause `SINCE` pour définir le début inclusif d’une plage horaire pour les données renvoyées. Vous pouvez spécifier un fuseau horaire pour la requête mais pas pour les résultats. Les résultats NRQL sont basés sur l&apos;heure de votre système.

    Lorsque vous utilisez NRQL, vous pouvez définir un horodatage UTC, une heure relative ou une chaîne `DateTime` . Voir [Spécification d&apos;une heure](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/#spec-time).

    Voir aussi :

    * [Définition de la plage horaire d&apos;une requête](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/)
    * [JUSQU&apos;À](#sel-until)
  </Collapser>

  <Collapser
    className="freq-link"
    id="slide-by"
    title={<><InlineCode>
      SLIDE BY
    </InlineCode> clause</>
    }
  >
    La clause `SLIDE BY` prend en charge une fonctionnalité connue sous le nom de fenêtres coulissantes. Avec les fenêtres coulissantes, les données `SLIDE BY` sont collectées dans des « fenêtres » de temps qui se chevauchent les unes avec les autres. Ces fenêtres peuvent aider à lisser les graphiques linéaires avec beaucoup de variations dans les cas où l&apos;agrégat mobile (comme une moyenne mobile) est plus important que les agrégats provenant de fenêtres temporelles étroites.

    Pour utiliser `SLIDE BY`, placez-le dans une requête après la clause `TIMESERIES` . Par exemple, cette requête extrait des données dans des fenêtres de 5 minutes avec un intervalle `SLIDE BY` de 1 minute, ce qui signifie que chaque fenêtre dure 5 minutes, mais la fenêtre 1 commence à 0 minute, la fenêtre 2 commence à 1 minute, la fenêtre 3 commence à 2 minutes, et ainsi de suite.

    ```sql
    SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute
    ```

    Pour en savoir plus sur comment et quand vous pouvez utiliser `SLIDE BY`, voir [Créer des graphiques plus fluides avec des fenêtres coulissantes](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows). Ou regardez cette courte vidéo (environ (3:20 minutes).

    <Video id="b9WVyb1wU6w" type="youtube" />

    <CollapserGroup>
      <Collapser
        id="sliding-window-max-auto"
        title={<>Utilisez <InlineCode>
          SLIDE BY
        </InlineCode> avec l'intervalle <InlineCode>
          MAX
        </InlineCode> ou <InlineCode>
          AUTO
        </InlineCode></>
        }
      >
        Vous pouvez utiliser des fenêtres coulissantes en combinaison avec `MAX` ou `AUTO`. Cependant, `MAX` ou `AUTO` ne peuvent pas être placés entre `TIMESERIES` et `SLIDE BY`.

        Cette requête décidera automatiquement d&apos;un intervalle de fenêtre `SLIDE BY` .

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO
        ```

        Cette requête définira la fenêtre `SLIDE BY` sur la granularité d&apos;intervalle maximale.

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX
        ```

        <Callout variant="important">
          La valeur `SLIDE BY` déterminée par `AUTO` ou `MAX` peut produire un intervalle d&apos;étape supérieur à la taille de la fenêtre, ce qui peut entraîner des écarts et des résultats inattendus.
        </Callout>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timeseries"
    title={<><InlineCode>
      TIMESERIES
    </InlineCode> clause</>
    }
  >
    ```sql
    SELECT ...
    TIMESERIES integer units
    ...
    ```

    Utilisez la clause `TIMESERIES` pour renvoyer des données sous forme de série chronologique répartie sur une période donnée. Étant donné que `TIMESERIES` est utilisé pour déclencher certains graphiques, il n’y a pas de valeur par défaut.

    Pour indiquer la plage horaire, utilisez `integer units`. Par exemple:

    * `TIMESERIES 1 minute`
    * `TIMESERIES 30 minutes`
    * `TIMESERIES 1 hour`
    * `TIMESERIES 30 seconds`

    `TIMESERIES` peut être combiné avec des arguments tels que `MAX`, `AUTO` et `SLIDE BY` pour personnaliser davantage les résultats de la requête, comme indiqué dans les exemples ci-dessous.

    <Callout variant="important">
      Pour des fonctions telles que `average()` ou `percentile()`, une grande fenêtre d&apos;agrégation peut avoir un effet de lissage significatif sur la valeur hors norme. Ceci est vrai que la requête utilise ou non des fenêtres glissantes.
    </Callout>

    <CollapserGroup>
      <Collapser id="set-interval" title="Utiliser un intervalle défini">
        La valeur fournie indique les unités utilisées pour décomposer le graphique. Par exemple, pour présenter un graphique d&apos;une journée montrant des incréments de 30 minutes :

        ```sql
        SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes
        ```
      </Collapser>

      <Collapser id="timeseries-auto" title="Utiliser un intervalle défini automatiquement">
        `TIMESERIES` peut également être défini sur `AUTO`, ce qui divisera votre graphique en un nombre raisonnable de divisions. Par exemple, un graphique journalier sera divisé en intervalles de 30 minutes et un graphique hebdomadaire sera divisé en intervalles de 6 heures.

        Cette requête renvoie des données sous forme de graphique linéaire affichant le 50e et le 90e percentile du temps de transaction côté client pendant une semaine avec un point de données toutes les 6 heures.

        ```sql
        SELECT average(duration), percentile(duration, 50, 90)
        FROM PageView SINCE 1 week AGO TIMESERIES AUTO
        ```
      </Collapser>

      <Collapser
        id="timeseries-max"
        title={<>Utiliser l'intervalle <InlineCode>
          MAX
        </InlineCode></>
        }
      >
        Vous pouvez définir `TIMESERIES` sur `MAX`, ce qui ajustera automatiquement votre fenêtre temporelle au nombre maximal d&apos;intervalles autorisés pour une période donnée. Cela vous permet de mettre à jour vos fenêtres temporelles sans avoir à mettre à jour manuellement vos compartiments `TIMESERIES` et garantit que votre fenêtre temporelle est divisée en un nombre maximal d&apos;intervalles autorisés. Le nombre maximum de `TIMESERIES` buckets qui seront renvoyés est 366.

        Par exemple, la requête suivante crée des intervalles de 4 minutes, ce qui correspond au plafond d’un graphique journalier.

        ```sql
        SELECT average(duration) FROM Transaction SINCE 1 day ago TIMESERIES MAX
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-until"
    title={<><InlineCode>
      UNTIL
    </InlineCode> clause</>
    }
  >
    ```sql
    SELECT ...
    UNTIL integer units AGO
    ...
    ```

    Utilisez la clause `UNTIL` pour définir la fin de la plage horaire à laquelle s&apos;adresser. La valeur est exclusive, ce qui signifie que la plage horaire ira jusqu&apos;à l&apos;instant spécifié dans le temps, mais ne l&apos;inclura pas.

    La valeur <DNT>**default**</DNT> est <DNT>**NOW**</DNT>. Utilisez uniquement `UNTIL` pour spécifier un point de terminaison autre que celui par défaut.

    Voir aussi :

    * [Définition de la plage horaire d&apos;une requête](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/)
    * [DEPUIS](#sel-since)
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-where"
    title={<><InlineCode>
      WHERE
    </InlineCode> clause</>
    }
  >
    Utilisez la clause `WHERE` pour filtrer les résultats. NRQL renvoie les résultats qui remplissent les conditions que vous spécifiez dans la clause.

    ```sql
    SELECT function(attribute) ...
    WHERE attribute [operator 'value' | IN ('value' [, 'value']) | IS [NOT] NULL ]
    [AND|OR ...]
    ...
    ```

    * Si vous spécifiez plusieurs conditions, séparez les conditions par les opérateurs `AND` ou `OR`.

    <table id="where-operators">
      <thead>
        <tr>
          <th width={150}>
            <DNT>
              **Operators that the `WHERE` clause accepts**
            </DNT>
          </th>

          <th>
            <DNT>
              **Description**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `=`, `!=`, `<`, `<=`, `>`, `>=`
          </td>

          <td>
            NRQL accepte les opérateurs de comparaison standard. Exemple: `state = 'WA'`

            Pour les attributs avec des valeurs booléennes, utilisez `IS` et non `=`.
          </td>
        </tr>

        <tr>
          <td>
            `AND`
          </td>

          <td>
            Utilisé pour définir une intersection de deux conditions.
          </td>
        </tr>

        <tr>
          <td>
            `OR`
          </td>

          <td>
            Utilisé pour définir une union de deux conditions.
          </td>
        </tr>

        <tr>
          <td>
            `IS NULL`
          </td>

          <td>
            Détermine si un attribut a une valeur nulle.
          </td>
        </tr>

        <tr>
          <td>
            `IS NOT NULL`
          </td>

          <td>
            Détermine si un attribut n&apos;a pas de valeur nulle.
          </td>
        </tr>

        <tr>
          <td>
            `IS TRUE`
          </td>

          <td>
            Détermine si un attribut a une valeur booléenne de `true`.
          </td>
        </tr>

        <tr>
          <td>
            `IS FALSE`
          </td>

          <td>
            Détermine si un attribut a une valeur booléenne de `false`.
          </td>
        </tr>

        <tr>
          <td>
            `IN`
          </td>

          <td>
            Détermine si la valeur de chaîne d&apos;un attribut est dans un ensemble spécifié. L’utilisation de cette méthode produit de meilleures performances que l’enchaînement de plusieurs clauses `WHERE` .

            Exemple:

            ```sql
            animalType IN ('cat', 'dog', 'fish')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `NOT IN`
          </td>

          <td>
            Détermine si la valeur de chaîne d&apos;un attribut n&apos;est pas dans un ensemble spécifié. L’utilisation de cette méthode produit de meilleures performances que l’enchaînement de plusieurs clauses `WHERE` .

            Les valeurs doivent être entre parenthèses, séparées par des virgules. Par exemple:

            ```sql
            SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `LIKE`
          </td>

          <td>
            Détermine si un attribut contient une sous-chaîne spécifiée.

            L&apos;argument de chaîne pour l&apos;opérateur `LIKE` accepte le signe de pourcentage (`%`) comme caractère générique n&apos;importe où dans la chaîne.

            Gardez à l’esprit les points suivants :

            * L&apos;opérateur `LIKE` n&apos;est pas sensible à la casse.

            * Si vous n&apos;incluez aucun caractère générique, vous obtiendrez des correspondances en majuscules et en minuscules pour votre chaîne. Par exemple, cette requête sans caractères génériques correspondra à `B` et `b`:

              ```sql
              FROM foo
              SELECT *
              WHERE bar LIKE 'B'
              ```

            <DNT>
              **Examples:**
            </DNT>

            `userAgentName LIKE 'IE%'`

            * IE

            * IE Mobile

              `userAgentName LIKE 'o%a%'`

            * Opéra

            * Opera Mini

              `userAgentName LIKE 'o%a'`

            * Opéra

              `userAgentName LIKE '%o%a%'`

            * Opéra

            * Opera Mini

            * Mozilla Gecko
          </td>
        </tr>

        <tr>
          <td>
            `NOT LIKE`
          </td>

          <td>
            Détermine si un attribut ne contient pas une sous-chaîne spécifiée.
          </td>
        </tr>

        <tr>
          <td>
            `RLIKE`
          </td>

          <td>
            Détermine si un attribut contient une sous-chaîne Regex spécifiée. Utilise [la syntaxe RE2](https://github.com/google/re2/wiki/Syntax).

            <DNT>
              **Examples:**
            </DNT>

            `appName RLIKE r'z.*|q.*'`

            * `z-app`

            * `q-app`

              `hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*'`

            * `ip-10-351-19-237`

            * `ip-10-351-2-41`

            * `ip-10-351-24-238`

            * `ip-10-351-14-15`

              <Callout variant="important">
                Par défaut, Regex correspond à une correspondance de chaîne complète. Par conséquent, `^` et `$` sont implicites et vous n&apos;avez pas besoin de les ajouter.
              </Callout>
          </td>
        </tr>

        <tr>
          <td>
            `NOT RLIKE`
          </td>

          <td>
            Détermine si un attribut ne contient pas de sous-chaîne Regex spécifiée. Utilise [la syntaxe RE2](https://github.com/google/re2/wiki/Syntax).
          </td>
        </tr>
      </tbody>
    </table>

    <CollapserGroup>
      <Collapser id="query-3-conditions" title="Exemple de requête avec trois conditions">
        Cette requête renvoie les temps de réponse du navigateur pour les pages avec `checkout` dans l&apos;URL de l&apos;utilisateur Safari aux États-Unis et au Canada au cours des dernières 24 heures.

        ```sql
        SELECT histogram(duration, 50, 20) FROM PageView
        WHERE countryCode IN ('CA', 'US') AND userAgentName = 'Safari' AND pageUrl LIKE '%checkout%'
        SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-metric-format"
    title={<><InlineCode>
      WITH METRIC_FORMAT
    </InlineCode> clause</>
    }
  >
    Pour plus d&apos;informations sur l&apos;interrogation des données métriques, voir [requête métriques](#query-metrics).
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-as-nrql-var"
    title={<><InlineCode>
      WITH ... AS
    </InlineCode> clause (variables NRQL)</>
    }
  >
    ```sql
    FROM ...
    WITH function(attribute) AS var
    SELECT var
    ...
    ```

    Utilisez la clause `WITH ... AS` pour définir des variables NRQL afin de stocker des valeurs sous forme de variables pouvant être référencées n&apos;importe où dans la requête. Quelques règles et conseils :

    * La clause `WITH ... AS` peut être placée avant, entre ou directement après la clause `FROM` ou `SELECT`
    * Seules les fonctions par ligne (par exemple, `capture()`) peuvent être définies comme variable. les fonctions d&apos;agrégation, telles que `average()`, ne sont pas prises en charge.
    * Un seul `WITH` peut être utilisé, mais vous pouvez utiliser plusieurs variables NRQL à condition qu&apos;elles soient séparées par une virgule.
    * Si une variable NRQL définie utilise le même nom qu&apos;un attribut existant, la variable aura la priorité.
    * Les noms de variables ne peuvent pas inclure le symbole `%` .

    <Callout variant="important">
      Les règles [d&apos;événement à métriques](/docs/data-apis/convert-to-metrics/analyze-monitor-data-trends-metrics/) ne prennent pas en charge la clause `WITH ... AS` dans [la requête NRQL ](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/).
    </Callout>

    Voici quelques exemples de requêtes :

    <CollapserGroup>
      <Collapser id="basic-nrql-var" title="Utilisation de base d'une variable">
        ```sql
        FROM Transaction
        WITH duration * 1000 AS millisec
        SELECT millisec
        ```
      </Collapser>

      <Collapser id="multiple-nrql-var" title="Utilisation de plusieurs variables">
        ```sql
        FROM Log
        WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice)
        SELECT itemId, unitPrice
        ```

        En savoir plus sur [l’analyse d’ancrage](#func-aparse) (`aparse()`).
      </Collapser>

      <Collapser id="nrql-var-other-clauses" title="Utiliser une variable dans d'autres clauses">
        Dans cet exemple, une variable NRQL, `unitPrice`, est utilisée pour créer une autre variable, `unitPriceNum`, convertissant la chaîne extraite en nombre. Les variables sont ensuite utilisées dans les clauses `SELECT`, `WHERE` et `FACET` .

        ```sql
        FROM Log
        WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice),
          numeric(unitPrice) AS unitPriceNum
        SELECT sum(unitPriceNum)
        FACET itemId
        WHERE unitPriceNum < 100
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timezone"
    title={<><InlineCode>
      WITH TIMEZONE
    </InlineCode> clause</>
    }
  >
    ```sql
    SELECT ... WITH TIMEZONE (selected zone)
    ...
    ```

    Utilisez la clause `WITH TIMEZONE` pour sélectionner un fuseau horaire pour une date ou une heure dans la requête pour laquelle aucun fuseau horaire n&apos;a déjà été spécifié.

    Si vous incluez la clause `WITH TIMEZONE` sans spécifier de fuseau horaire dans une date et une heure, les clauses `since` et `until` restent dans le fuseau horaire fourni.

    Si vous n&apos;incluez pas la clause `WITH TIMEZONE` , mais que vous incluez un fuseau horaire dans une chaîne de date et d&apos;heure, votre fuseau horaire de chaîne de date et d&apos;heure est conservé.

    <Callout variant="important">
      Le fuseau horaire par défaut est toujours UTC s&apos;il n&apos;est pas spécifié. Les valeurs d&apos;horodatage brutes (telles que vues dans la vue JSON) dans les résultats sont toujours UTC. L&apos;UI affiche les résultats dans le fuseau horaire que vous avez spécifié dans les paramètres de votre compte. Un fuseau horaire dans une chaîne d&apos;horodatage fonctionne toujours. Elle remplace la zone `WITH TIMEZONE` .
    </Callout>

    Par exemple, la clause de requête `SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'` renvoie les données enregistrées du lundi à minuit, heure américaine/New York, jusqu&apos;au mardi à minuit, heure américaine/New York.

    Voici quelques exemples de clauses de durée de requête :

    * Aucun fuseau horaire dans la chaîne de date et d&apos;heure à l&apos;aide de la clause `WITH TIMEZONE` :

      ```sql
      SINCE today UNTIL '2022-05-19T12:00' WITH TIMEZONE 'America/Los_Angeles'
      ```

      Cela se résout comme `"beginTime": "2022-05-19T07:00:00Z"` et `"endTime": "2022-05-19T19:00:00Z"`.

    * Fuseau horaire dans la chaîne de date et d&apos;heure, sans utiliser la clause `WITH TIMEZONE` :

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500'
      ```

      Cela se résout comme `"beginTime": "2022-05-19T00:00:00Z"` et `"endTime": "2022-05-19T17:00:00Z"`.

    * Fuseau horaire dans la chaîne de date et d&apos;heure, en utilisant la clause `WITH TIMEZONE` America/Los Angeles, qui est -0700 pendant l&apos;heure d&apos;été :

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500' WITH TIMEZONE 'America/Los_Angeles'
      ```

      Cela se résout comme `"beginTime": "2022-05-19T07:00:00Z"` et `"endTime": "2022-05-19T19:00:00Z"`.

    Consultez la liste [des identifiants de zone](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/#timezones-ids) disponibles.

    Voir [Définir la plage horaire sur le dashboard et les graphiques](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets) pour obtenir des informations détaillées et des exemples.
  </Collapser>
</CollapserGroup>

## requête métrique de données [#query-metrics]

Les données métriques sont plus complexes que les autres types de données. Il existe des astuces spécifiques pour bien l&apos;interroger. Nous avons deux types de données métriques, chacune avec ses propres directives de requête :

* [requêtes dimensionnelles métriques](/docs/data-ingest-apis/get-data-new-relic/metric-api/view-query-you-metric-data), qui sont rapportées par notre API métrique et par certaines de nos solutions qui utilisent cette API (par exemple, notre [intégration Dropwizard](/docs/more-integrations/open-source-telemetry-integrations/dropwizard/dropwizard-reporter) ou [Micrometer](/docs/more-integrations/open-source-telemetry-integrations/micrometer/micrometer-metrics-registry)).
* [requête intervalle de temps métrique data](/docs/query-data/nrql-new-relic-query-language/nrql-query-tutorials/query-metric-timeslice-data-nrql), qui est notre type de données métriques d&apos;origine signalé par notre APM, monitoring des applications mobiles, et <InlinePopover type="browser" />.

Pour plus de détails sur la façon dont nous rapportons les données métriques, consultez [Types de données métriques](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics).

## Fonctions [#functions]

Dans cette section, nous expliquons les fonctions NRQL , à la fois [les fonctions agrégatrices](#aggregator-functions) et [les fonctions non agrégatrices](#non-aggregator-functions).

### fonctions d&apos;agrégateur [#aggregator-functions]

Vous pouvez utiliser les fonctions d&apos;agrégation pour filtrer et agréger des données. Quelques conseils pour les utiliser :

* Si vous utilisez une fonction d&apos;agrégation plusieurs fois dans la même requête (par exemple, `SELECT median(one_metric), median(another_metric)`), cela peut entraîner des problèmes d&apos;affichage des résultats. Pour résoudre ce problème, utilisez la [fonction`AS` ](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-as). Par exemple:
  ```sql
  SELECT median(one_metric) AS 'med-a', median(another_metric) AS 'med-b'
  ```
* Le type de données « coercition » n&apos;est pas pris en charge. En savoir plus sur [les fonctions de conversion de type disponibles](#type-conversion).
* Pour savoir comment afficher les résultats au fil du temps, voir [Grouper les résultats au fil du temps](/docs/insights/new-relic-insights/features/cohort-analysis).

Exemples :

```sql
SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
```

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="func-aggregationendtime"
    title={<InlineCode>aggregationendtime()</InlineCode>
    }
  >
    Utilisez la fonction `aggregationendtime()` pour renvoyer l’heure de l’agrégation concernée. Plus précisément, pour un agrégat donné, la fonction `aggregationendtime()` fournit l’horodatage de la fin de la période de cet agrégat. Par exemple, dans une requête de série chronologique, pour un point de données qui englobe une heure de données, la fonction renverrait l&apos;horodatage de la fin de cette période horaire.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-apdex"
    title={<InlineCode>apdex(attribute, t: )</InlineCode>
    }
  >
    Utilisez la fonction `apdex` pour renvoyer un [score Apdex](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#score) pour une seule transaction ou pour toutes vos transactions. Le score par défaut <DNT>Apdex</DNT> est de 0,5 seconde. L&apos;[attribut](/docs/insights/new-relic-insights/decorating-events/insights-attributes) peut être n&apos;importe quel attribut basé sur le temps de réponse, tel que [`duration`](/docs/insights/insights-data-sources/default-events-attributes/apm-default-event-attributes#txn-duration) ou [`backendDuration`](/docs/insights/insights-data-sources/default-events-attributes/browser-default-events-attributes-insights#backend-duration). L&apos;argument `t:` définit un seuil [`Apdex T`](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) dans la même unité de temps que l&apos;attribut choisi. Par instance, si l&apos;attribut est mesuré en secondes, `t` sera un seuil en secondes.

    Le score <DNT>Apdex</DNT> renvoyé par la fonction `apdex()` est basé uniquement sur le temps d&apos;exécution. Il ne tient pas compte des erreurs APM. Si une transaction contient une erreur mais se termine dans [Apdex T](/docs/apm/new-relic-apm/getting-started/glossary#apdex_t) ou moins, cette transaction sera considérée comme [satisfaisante](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#bullet-satisfied) par la fonction `apdex()` .

    <CollapserGroup>
      <Collapser id="apdex-cust-attributes" title="Obtenez Apdex pour des clients spécifiques">
        Si vous avez [défini des attributs personnalisés](/docs/insights/new-relic-insights/decorating-events/insights-custom-attributes), vous pouvez filtrer en fonction de ces attributs. Par exemple, vous pouvez monitorer l&apos;Apdex pour un client particulièrement important :

        ```sql
        SELECT apdex(duration, t: 0.4) FROM Transaction
        WHERE customerName = 'ReallyImportantCustomer' SINCE 1 day ago
        ```
      </Collapser>

      <Collapser id="apdex-transaction" title="Obtenir l'Apdex pour une transaction spécifique">
        Utilisez l&apos;attribut `name` pour renvoyer un score pour une transaction spécifique ou renvoyez un Apdex global en omettant `name`. Cette requête renvoie un score Apdex pour la transaction <DNT>**Controller/notes/index**</DNT> au cours de la dernière heure :

        <img title="crop-apdex-function" alt="crop-apdex-function" src="/images/queries-nrql_screenshot-full_apdex-NRQL-query-builder.webp" />

        <figcaption>
          La fonction `apdex` renvoie un [score Apdex](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) qui mesure la satisfaction des utilisateurs avec votre site. Les arguments sont un attribut de temps de réponse et un seuil Apdex T en secondes.
        </figcaption>

        ```sql
        SELECT apdex(duration, t: 0.5) from Transaction
        WHERE name = 'Controller/notes/index' SINCE 1 hour ago
        ```
      </Collapser>

      <Collapser title="Obtenez l'Apdex global de votre application">
        Cet exemple de requête renvoie un Apdex global pour l&apos;application au cours des trois dernières semaines :

        ```sql
        SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-average"
    title={<InlineCode>average(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `average()` pour renvoyer la valeur moyenne d&apos;un attribut. Il prend un seul nom d&apos;attribut comme argument. Si une valeur de l&apos;attribut n&apos;est pas numérique, elle sera ignorée lors de l&apos;agrégation. Si les données correspondant aux conditions de la requête ne sont pas trouvées ou si aucune valeur numérique n&apos;est renvoyée par la requête, elle renverra une valeur nulle.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-bucket-percentile"
    title={<InlineCode>bucketPercentile(attribute)</InlineCode>
    }
  >
    La fonction `bucketPercentile()` est l&apos;équivalent NRQL de la fonction [`histogram_quantile`](https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile) dans Prometheus. Il est destiné à être utilisé avec des données métriques dimensionnelles. Au lieu du quantile, New Relic renvoie le percentile, qui est le quantile \* 100.

    Utilisez la fonction `bucketPercentile()` pour calculer le quantile à partir des données d&apos;histogramme au format Prometheus.

    Il prend le nom du bucket comme argument et indique le centile le long des limites du bucket :

    ```sql
    SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago
    ```

    En option, vous pouvez ajouter des spécifications percentile comme argument :

    ```sql
    SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago
    ```

    Étant donné que plusieurs métriques sont utilisées pour constituer les données de l&apos;histogramme Prometheus , vous devez interroger des métriques Prometheus spécifiques en termes de `<basename>` associé.

    Par exemple, pour calculer le centile à partir d&apos;un histogramme Prometheus , avec `<basename>` `prometheus_http_request_duration_seconds` en utilisant NRQL, utilisez `bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)`. Notez comment `_bucket` est ajouté à la fin de `<basename>` comme suffixe.

    Consultez [la documentation Prometheus.io](https://prometheus.io/docs/concepts/metric_types/#histogram) pour plus d&apos;informations.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cardinality"
    title={<InlineCode>cardinality([metric_name, include:{`{attribute_list}`}, exclude:{`{attribute_list}`}])</InlineCode>
    }
  >
    Utilisez la fonction `cardinality()` pour obtenir le nombre de combinaisons de toutes les dimensions (attribut) sur une [métrique](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics).

    Il faut trois arguments, tous facultatifs :

    * nom de la métrique : si présent, `cardinality()` calcule uniquement la métrique spécifiée.
    * Inclure : si elle est présente, la liste d&apos;inclusion restreint le calcul de cardinalité à ces attributs.
    * Exclure : si elle est présente, la liste d&apos;exclusion entraîne l&apos;ignorance de ces attributs dans le calcul de cardinalité.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cdfPercentage"
    title={<InlineCode>cdfPercentage(attribute, threshold [, threshold [, ...]])</InlineCode>
    }
  >
    `cdfPercentage()` est une implémentation de la [fonction de distribution cumulative](https://en.wikipedia.org/wiki/Cumulative_distribution_function), renvoyant des pourcentages de valeurs `attribute` dont la valeur est inférieure ou égale à un ou plusieurs `thresholds`.

    `cdfPercentage()` agrégats sur son argument `attribute` , qui peut être soit un attribut numérique, soit un attribut de métrique de distribution. Les types mixtes dans une requête sont acceptés. Les autres types (tels que les chaînes) sont ignorés. Jusqu&apos;à 10 seuils peuvent être spécifiés.

    <CollapserGroup>
      <Collapser title="Obtenez le pourcentage de premières peintures plus rapidement qu'un certain seuil">
        Cette requête renvoie le pourcentage d&apos;événement où `firstPaint` est inférieur ou égal à 0,5 seconde, et le pourcentage d&apos;événement où `firstPaint` est inférieur ou égal à 1 seconde.

        ```sql
        FROM PageView SELECT cdfPercentage(firstPaint, 0.5, 1.0)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-count"
    title={<InlineCode>compter(*)</InlineCode>
    }
  >
    Utilisez la fonction `count()` pour renvoyer le nombre d’enregistrements disponibles. Il prend un seul argument ; soit `*`, un attribut ou une valeur constante. Actuellement, il suit le comportement SQL typique et compte tous les enregistrements qui ont des valeurs pour son argument.

    Étant donné que `count(*)` ne nomme pas d&apos;attribut spécifique, les résultats seront formatés dans le format [« humaniser »](/docs/insights/new-relic-insights/managing-dashboards-data/data-formatter-setting-default-formats-numeric-values#format) par défaut.
  </Collapser>

  <Collapser
    className="freq-link"
    id="derivative"
    title={<InlineCode>derivative(attribute [,time interval])</InlineCode>
    }
  >
    `derivative()` trouve le taux de changement pour un ensemble de données donné. Le taux de variation est calculé à l’aide d’une régression linéaire des moindres carrés pour approximer la dérivée. Étant donné que ce calcul nécessite la comparaison de plusieurs points de données, si un seul point de données est inclus dans la plage d&apos;évaluation, le calcul est indéterminé et ne fonctionnera pas, ce qui donnera une valeur `null` .

    Le `time interval` est la période pour laquelle le taux de variation est calculé. Par exemple, `derivative(attributeName, 1 minute)` renverra le taux de variation par minute.
  </Collapser>

  <Collapser
    className="freq-link"
    id="earliest-func"
    title={<InlineCode>earliest(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `earliest()` pour renvoyer la valeur la plus ancienne d’un attribut sur la plage de temps spécifiée.

    Il faut un seul argument.

    S&apos;il est utilisé conjointement avec un `FACET` , il renverra la valeur la plus ancienne d&apos;un attribut pour chacune des facettes résultantes.

    <Callout variant="tip">
      Si plusieurs événements ou métriques partagent le même horodatage le plus ancien, le résultat renvoyé est aléatoire et peut varier selon les différentes exécutions de requête. Pour obtenir des résultats plus cohérents, facettez par un attribut avec des valeurs différentes pour ces événements ou métriques.
    </Callout>

    <CollapserGroup>
      <Collapser title="Obtenir le premier pays par agent utilisateur à partir de PageView">
        Cette requête renvoie le code de pays le plus ancien pour chaque agent utilisateur à partir de l&apos;événement `PageView` .

        ```sql
        SELECT earliest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-filter"
    title={<InlineCode>filter(function(attribute), WHERE condition)</InlineCode>
    }
  >
    Utilisez la fonction `filter()` pour limiter les résultats de l&apos;une des fonctions d&apos;agrégation dans votre instruction `SELECT` . Vous pouvez utiliser `filter()` en conjonction avec `FACET` ou `TIMESERIES`. Le filtre n&apos;est utile que lors de la sélection de plusieurs agrégations différentes telles que :

    ```sql
    SELECT filter(sum(x), WHERE attribute = 'a') AS 'A',
      filter(sum(x), WHERE attribute = 'b') AS 'B' ...
    ```

    Sinon, il est préférable d’utiliser simplement la clause standard `WHERE` .

    <CollapserGroup>
      <Collapser title="Analyser les achats qui ont utilisé des codes promotionnels">
        Vous pouvez utiliser `filter()` pour comparer les articles achetés dans un ensemble de transactions pour ceux qui utilisent un code d&apos;offre par rapport à ceux qui ne l&apos;utilisent pas :

        <img title="screenshot insights filter" alt="screenshot insights filter" src="/images/queries-nrql_screenshot-full_filter-NRQL-query-builder.webp" />

        <figcaption>
          Utilisez la fonction `filter()` pour limiter les résultats de l&apos;une des fonctions d&apos;agrégation dans votre instruction `SELECT` .
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-funnel"
    title={<InlineCode>funnel(attribute, steps)</InlineCode>
    }
  >
    Utilisez la fonction `funnel()` pour générer un graphique entonnoirs. Il prend un attribut comme premier argument. Vous spécifiez ensuite les étapes sous forme de clauses [`WHERE`](#sel-where) (avec des clauses [`AS`](#sel-as) facultatives pour les étiquettes) séparées par des virgules.

    Pour plus de détails et d&apos;exemples, consultez la [documentation des entonnoirs](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/funnels-evaluate-data-series-events).
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-histogram"
    title={<InlineCode>histogram(attribute[, width: n][, buckets: n][, start: n])</InlineCode>
    }
  >
    Utilisez la fonction `histogram()` pour générer un histogramme, utile pour visualiser la distribution d&apos;un ensemble de données. Il divise l&apos;ensemble de données en un nombre spécifié de compartiments et compte le nombre de points de données qui tombent dans chaque compartiment.

    Arguments:

    * `attribute` Le premier argument est obligatoire et spécifie l’attribut pour lequel compter les valeurs qui se situent dans chaque plage de compartiments d’histogramme.

    * `width:` Indique la largeur de la plage d&apos;échantillons. La valeur maximale de la plage est la valeur de l&apos;argument `start` plus cette valeur `width` .

      * Lors de l&apos;utilisation d&apos;arguments positionnels (non étiquetés), `width` est le deuxième argument.
      * *Défaut:* `10`

    * `buckets:` Nombre total de buckets (entre `1` et `500`, inclus).

      * Lors de l&apos;utilisation d&apos;arguments positionnels (non étiquetés), `buckets` est le troisième argument.
      * *Défaut:* `40`

    * `start:` Le début de la plage de l&apos;histogramme.

      * Lors de l&apos;utilisation d&apos;arguments positionnels (non étiquetés), `start` est le quatrième argument.
      * *Défaut:* `0`

    <Callout variant="tip" title="Note">
      Les valeurs qui se situent en dehors de la plage d’histogramme définie sont incluses dans le premier ou le dernier compartiment. Le premier décompte comprendra les éléments qui sont plus petits que la plage de l&apos;histogramme, et le dernier décompte comprendra les éléments qui sont plus grands que la plage de l&apos;histogramme. Pour exclure ces valeurs des résultats de l&apos;histogramme, incluez un filtre dans la clause where de la requête. (Exemple : `WHERE attribute >= [start] AND attribute <= [start + width]`)
    </Callout>

    <CollapserGroup>
      <Collapser id="histogram-response-times-defaults" title="Histogramme du temps de réponse des événements PageView">
        Cette requête génère un histogramme de temps de réponse allant jusqu&apos;à 10 secondes sur 40 buckets. Cela signifie que chaque bucket couvre une plage de valeurs de 0,25 seconde. (10 / 40 = 0,25). Toutes les valeurs de durée supérieures à 10 secondes sont incluses dans le dernier compartiment. Si la durée pouvait être inférieure à zéro, ces valeurs seraient incluses dans le premier compartiment.

        ```sql
        SELECT histogram(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-response-times" title="Histogramme avec une largeur : 5, buckets : 10">
        Ces requêtes équivalentes aboutissent à un histogramme de temps de réponse allant jusqu&apos;à 5 secondes sur 10 buckets.

        ```sql
        SELECT histogram(duration, 5, 10) FROM PageView SINCE 1 week ago
        ```

        ```sql
        SELECT histogram(duration, width: 5, buckets: 10) FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-response-times-1to4" title="Histogramme avec largeur : 3, compartiments : 3, début : 1">
        Ces requêtes équivalentes aboutissent à un histogramme de temps de réponse allant de 1 à 4 secondes sur 3 buckets.

        Voici une répartition des buckets :

        <table>
          <thead>
            <tr>
              <th />

              <th>
                Seau 1
              </th>

              <th>
                Seau 2
              </th>

              <th>
                Seau 3
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                Gamme de buckets
              </td>

              <td>
                1 à 2
              </td>

              <td>
                2 à 3
              </td>

              <td>
                3 à 4
              </td>
            </tr>

            <tr>
              <td>
                Valeurs comptées
              </td>

              <td>
                &lt; 2
              </td>

              <td>
                ≥ 2 et &lt; 3
              </td>

              <td>
                ≥ 3
              </td>
            </tr>
          </tbody>
        </table>

        ```sql
        SELECT histogram(duration, 3, 3, 1) 
        FROM PageView SINCE 1 week ago
        ```

        ```sql
        SELECT histogram(duration, width: 3, buckets: 3, start: 1) 
        FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-prometheus" title="Compartiments d'histogramme Prometheus">
        `histogram()` accepte les compartiments d&apos;histogramme Prometheus :

        ```sql
        SELECT histogram(duration_bucket, 10, 20) 
        FROM Metric SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="distribution-metric" title="Nétrique de distribution de New Relic">
        `histogram()` accepte [la métrique de distribution](/docs/data-ingest-apis/get-data-new-relic/metric-api/events-metrics-service-create-metrics#limits-rules) comme entrée :

        ```sql
        SELECT histogram(myDistributionMetric, 10, 20) 
        FROM Metric SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-facet-heatmap" title="Histogramme avec une clause FACET">
        Utilisez `histogram()` avec une clause `FACET` pour générer un graphique de carte thermique :

        ```sql
        SELECT histogram(duration) 
        FROM PageView FACET appName SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="keyset"
    title={<InlineCode>keyset()</InlineCode>
    }
  >
    L&apos;utilisation de `keyset()` vous permettra de voir tous les attributs d&apos;un type de données donné sur une plage de temps donnée. Il n&apos;y a pas d&apos;arguments à cela. Il renvoie une structure JSON contenant des groupes de clés de type chaîne, de clés de type numérique, de clés de type booléen et toutes les clés.

    <CollapserGroup>
      <Collapser title="Voir tous les attributs pour un type de données">
        Cette requête renvoie l&apos;attribut trouvé pour `PageView` événement du dernier jour :

        ```sql
        SELECT keyset() FROM PageView SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latest"
    title={<InlineCode>latest(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `latest()` pour renvoyer la valeur la plus récente d’un attribut sur une plage de temps spécifiée.

    Il faut un seul argument.

    Si utilisé conjointement avec un `FACET` , il renverra la valeur la plus récente d&apos;un attribut pour chacune des facettes résultantes.

    <Callout variant="tip">
      Si plusieurs événements ou métriques ont le même dernier horodatage, le résultat renvoyé est aléatoire et peut varier selon les exécutions de requête. Pour obtenir des résultats plus cohérents, facettez par un attribut avec des valeurs différentes pour ces événements ou métriques.
    </Callout>

    <CollapserGroup>
      <Collapser title="Obtenez le pays le plus récent par agent utilisateur à partir de PageView">
        Cette requête renvoie le code de pays le plus récent pour chaque agent utilisateur de l&apos;événement `PageView` .

        ```sql
        SELECT latest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latestrate"
    title={<InlineCode>latestrate(attribute, time interval)</InlineCode>
    }
  >
    Utilisez la fonction `latestrate()` pour renvoyer le taux de variation d’une valeur en fonction des 2 derniers points de données. Il prend l&apos;attribut en question comme premier argument et l&apos;unité de temps pour le taux résultant comme deuxième argument. La fonction renvoie un résultat en unités de `change in attribute/time interval`.

    Cette fonction peut être utile pour fournir le taux de changement le plus récent d&apos;un attribut afin de voir les tendances de pointe.

    <CollapserGroup>
      <Collapser title="Obtenez le taux de changement le plus récent de la durée de la page vue">
        Cette requête renvoie le taux de changement de durée en fonction des 2 derniers points de données. Il sera renvoyé en unités de `duration/second` en raison de l&apos;argument `1 SECOND` .

        ```sql
        SELECT latestrate(duration, 1 SECOND) FROM PageView
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-max"
    title={<InlineCode>max(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `max()` pour renvoyer la valeur maximale enregistrée d’un attribut numérique sur la plage de temps spécifiée. Il prend un seul nom d&apos;attribut comme argument. Si une valeur de l&apos;attribut n&apos;est pas numérique, elle sera ignorée lors de l&apos;agrégation. Si les données correspondant aux conditions de la requête ne sont pas trouvées ou si aucune valeur numérique n&apos;est renvoyée par la requête, elle renverra une valeur nulle.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-median"
    title={<InlineCode>median(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `median()` pour renvoyer la médiane ou le 50e percentile d&apos;un attribut. Pour plus d&apos;informations sur la requête percentile , voir [`percentile()`](#func-percentile).

    <CollapserGroup>
      <Collapser title="Requête médiane">
        Cette requête générera un graphique linéaire pour la valeur médiane.

        ```sql
        SELECT median(duration) FROM PageView TIMESERIES AUTO
        ```
      </Collapser>
    </CollapserGroup>

    Médiane dans une clause [`JOIN`](#sel-join) :

    * Étant donné que la médiane est simplement un raccourci pour `percentile(attribute, 50)`, un résultat `median()` issu d&apos;une sous-requête jointe est un type de données composé, qui mappe le 50e percentile à sa valeur calculée.

      Pour référencer la valeur médiane réelle dans la requête externe, vous pouvez utiliser la fonction [`getField()`](#func-getfield) . Notez que la clé mappée est une représentation sous forme de chaîne d&apos;une valeur double, donc pour `median()` c&apos;est `'50.0'`.

      <CollapserGroup>
        <Collapser title="Requête médiane jointe">
          ```sql
          FROM PageView
          JOIN (FROM PageAction SELECT median(timeSinceLoad) FACET session, currentUrl) ON session
          SELECT latest(getField(median, '50.0')) AS median
          FACET browserTransactionName, currentUrl
          ```

          <img title="screenshot joined median" alt="screenshot joined median" src="/images/nrql_screenshot-crop_example-joined-median.webp" />
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-min"
    title={<InlineCode>min(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `min()` pour renvoyer la valeur minimale enregistrée d’un attribut numérique sur la plage de temps spécifiée. Il prend un seul nom d&apos;attribut comme argument. Si une valeur de l&apos;attribut n&apos;est pas numérique, elle sera ignorée lors de l&apos;agrégation. Si les données correspondant aux conditions de la requête ne sont pas trouvées ou si aucune valeur numérique n&apos;est renvoyée par la requête, elle renverra une valeur nulle.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentage"
    title={<InlineCode>percentage(function(attribute), WHERE condition)</InlineCode>
    }
  >
    Utilisez la fonction `percentage()` pour renvoyer le pourcentage d&apos;un ensemble de données cible qui correspond à une condition.

    Cette fonction attend exactement deux arguments (les arguments après les deux premiers sont ignorés). Le premier argument nécessite une [fonction agrégateur](#functions) contre l&apos;attribut souhaité. Si l&apos;attribut n&apos;est pas numérique, cette fonction renvoie une valeur de 100 %. Le deuxième argument nécessite une clause `WHERE` .

    ```sql
    FROM Transaction 
    SELECT percentage(count(*), WHERE error is true ) AS 'Error Percent' 
    WHERE host LIKE '%west%' EXTRAPOLATE
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentile"
    title={<InlineCode>percentile(attribute [, percentile [, ...]])</InlineCode>
    }
  >
    Utilisez la fonction `percentile()` pour renvoyer la valeur approximative d&apos;un attribut à un percentile donné. Il nécessite un attribut et peut prendre n’importe quel nombre d’arguments représentant des points percentile . La fonction `percentile()` permet d&apos;afficher le centile avec jusqu&apos;à trois chiffres après la virgule décimale, offrant ainsi une plus grande précision. le seuil de centile peut être spécifié sous forme de valeurs décimales, mais sachez que pour la plupart des ensembles de données, les centiles plus proches de 0,1 l&apos;un de l&apos;autre ne seront pas résolus.

    <img title="percentile.png" alt="percentile.png" src="/images/queries-nrql_screenshot-full_percentile-NRQL-query-builder.webp" />

    <figcaption>
      exemples d&apos;affichage de centiles
    </figcaption>

    Utilisez `TIMESERIES` pour générer un graphique linéaire avec un centile mappé au fil du temps.

    * Omettez `TIMESERIES` pour générer un panneau d’affichage et une feuille d’attributs affichant les valeurs agrégées pour le centile.

      Si aucun percentile n&apos;est répertorié, la valeur par défaut est le 95e percentile. Pour renvoyer uniquement la valeur du 50e percentile, la médiane, vous pouvez également utiliser [`median()`](#func-median).

      <CollapserGroup>
        <Collapser title="Requête percentile de base">
          Cette requête générera un graphique linéaire avec des lignes pour les 5e, 50e et 95e percentile.

          ```sql
          SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO
          ```
        </Collapser>
      </CollapserGroup>

    percentile dans une clause [`JOIN`](#sel-join) :

    * Lorsque vous utilisez un centile dans une sous-requête jointe, veuillez noter que les résultats de la sous-requête sont un type de données composé, qui mappe chaque percentile à sa valeur calculée.

      Pour référencer l’une des valeurs percentile individuelles dans la requête externe, vous pouvez utiliser la fonction [`getField()`](#func-getfield) . Notez que la clé mappée est une représentation sous forme de chaîne d&apos;une valeur double, vous devez donc ajouter `.0` aux entiers. Par exemple, la clé du 95e percentile est `'95.0'`.

      <CollapserGroup>
        <Collapser title="Requête percentile joint">
          ```sql
          FROM PageView
          JOIN 
          (
            FROM PageAction 
            SELECT percentile(timeSinceLoad, 95, 99.5) AS pctl
            FACET session, currentUrl
          ) 
          ON session
          SELECT latest(getField(pctl, '95.0')) AS `95th`, 
            latest(getField(pctl, '99.5')) AS `99.5th`
          FACET browserTransactionName, currentUrl
          ```

          <img title="screenshot joined percentile" alt="screenshot joined percentile" src="/images/nrql_screenshot-crop_example-joined-percentile.webp" />
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="predictLinear"
    title={<InlineCode>predictLinear(attribute, [,time interval])</InlineCode>
    }
  >
    `predictLinear()` est une extension de la fonction `derivative()` . Il utilise une méthode similaire à la régression linéaire des moindres carrés pour prédire les valeurs futures d&apos;un ensemble de données.

    * Le `time interval` indique jusqu&apos;où la requête regardera dans le futur. Par exemple, `predictLinear(attributeName, 1 hour)` est une prédiction linéaire d&apos;une heure dans le futur de la fenêtre temporelle de la requête.
    * En général, `predictLinear()` est utile pour les valeurs en croissance continue comme l&apos;espace disque ou les prévisions sur les grandes tendances.
    * Étant donné que `predictLinear()` est une régression linéaire, la familiarité avec l’ensemble de données interrogé permet de garantir des prévisions précises à long terme.
    * Tout ensemble de données qui croît de manière exponentielle, logarithmique ou par d’autres moyens non linéaires ne sera probablement efficace que dans les prédictions à très court terme.
    * New Relic recommande de ne pas utiliser `predictLinear` dans la requête `TIMESERIES` . Cela est dû au fait que chaque bucket effectuera une prédiction individuelle en fonction de sa période relative dans la requête, ce qui signifie qu&apos;une telle requête n&apos;affichera pas les prédictions à partir de la fin de la série chronologique.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-rate"
    title={<InlineCode>rate(function(attribute) [,time interval])</InlineCode>
    }
  >
    Utilisez la fonction `rate()` pour visualiser la fréquence ou le taux d’une requête donnée par intervalle de temps. Par exemple, vous souhaiterez peut-être connaître le nombre de pages vues par minute sur une période d&apos;une heure ou le nombre de sessions uniques sur votre site par heure sur une période d&apos;une journée.

    * Utilisez [`TIMESERIES`](#sel-timeseries) pour générer un graphique linéaire avec les taux cartographiés au fil du temps.

    * Omettez [`TIMESERIES`](#sel-timeseries) pour générer un panneau d&apos;affichage affichant une valeur de taux unique moyennée au fil du temps.

      Voici une requête de base qui générera un graphique linéaire indiquant le taux de débit des transactions APM par 10 minutes au cours des 6 dernières heures :

      ```sql
      SELECT rate(count(*), 10 minute) FROM Transaction 
      SINCE 6 hours ago TIMESERIES
      ```

      Voici une courte vidéo (3:21 minutes) expliquant comment utiliser `rate` pour comparer des données sur différentes fenêtres temporelles :

      <Video id="9UArmB4QiVM" type="youtube" />
  </Collapser>

  <Collapser
    className="freq-link"
    id="stdvar"
    title={<InlineCode>stdvar(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `stdvar()` pour renvoyer la [variance standard](https://en.wikipedia.org/wiki/Variance) d’un attribut numérique sur la plage de temps spécifiée.

    Il faut un seul argument. Si l&apos;attribut n&apos;est pas numérique, il renverra une valeur de zéro.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-sum"
    title={<InlineCode>sum(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `sum()` pour renvoyer la somme des valeurs enregistrées d’un attribut numérique sur la plage de temps spécifiée.

    Il faut un seul argument. Si l&apos;attribut n&apos;est pas numérique, il renverra une valeur de zéro.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniqueCount"
    title={<InlineCode>uniqueCount(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `uniqueCount()` pour renvoyer le nombre de valeurs uniques enregistrées pour un attribut sur la plage de temps spécifiée.

    <Callout variant="tip">
      Pour optimiser les performances des requêtes, cette fonction renvoie des résultats approximatifs pour les requêtes qui inspectent 256 valeurs uniques ou plus.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniques"
    title={<><InlineCode>
      uniques(attribute [,limit]
    </InlineCode><InlineCode>
      )
    </InlineCode></>
    }
  >
    Utilisez la fonction `uniques()` pour renvoyer une liste de valeurs uniques enregistrées pour un attribut sur la plage de temps spécifiée. Lorsqu&apos;il est utilisé avec la clause `facet` , une liste de valeurs d&apos;attribut uniques sera renvoyée pour chaque valeur de facette.

    Le paramètre `limit` est facultatif. Lorsque cette valeur n&apos;est pas fournie, la limite par défaut de 1 000 valeurs d&apos;attribut uniques par facette est appliquée. Vous pouvez spécifier une valeur `limit` différente, jusqu&apos;à un maximum de 10 000. La fonction `uniques()` renverra le premier ensemble de valeurs d&apos;attribut uniques découvertes, jusqu&apos;à ce que la limite soit atteinte. Par conséquent, si vous avez 5 000 valeurs d&apos;attribut uniques dans votre ensemble de données et que la limite est définie sur 1 000, l&apos;opérateur renverra les 1 000 premières valeurs uniques qu&apos;il découvre, quelle que soit leur fréquence.

    Le nombre maximal de valeurs pouvant être renvoyées dans un résultat de requête est le produit de la limite `uniques()` multiplié par la limite `facet` . Dans la requête suivante, le nombre maximal théorique de valeurs pouvant être renvoyées est de 5 millions (5 000 x 1 000).

    En fonction de l&apos;ensemble de données interrogé et de la complexité de la requête, les limites de protection de la mémoire peuvent empêcher l&apos;exécution d&apos;une requête très volumineuse.

    ```sql
    From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000
    ```

    <CollapserGroup>
      <Collapser
        title={<>En utilisant <InlineCode>
          tuple
        </InlineCode></>
        }
      >
        Si vous souhaitez connaître les combinaisons uniques d&apos;une poignée d&apos;attributs, vous pouvez structurer une requête au format `SELECT uniques(tuple(x, y, ... z)) ...` pour obtenir tous les tuples uniques de valeurs, afin de maintenir leur relation. Dans la requête suivante, `tuple` est utilisé sur `index` et `cellName` ensemble pour trouver des éléments uniques où ces deux valeurs apparaissent en combinaison.

        ```sql
        FROM NodeStatus SELECT uniques(tuple(index, cellName), 5)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### Fonctions non-agrégatrices [#non-aggregator-functions]

Utilisez des fonctions non-agrégateur pour les données non numériques dans la requête NRQL .

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="acct-type"
    title={<InlineCode>accountId()</InlineCode>
    }
  >
    Utilisez la fonction `accountId()` pour renvoyer l’ [ID de compte](/docs/accounts/accounts-billing/account-structure/account-id) associé aux données de requête. Cette fonction ne prend aucun argument. Voici quelques exemples de requêtes :

    <CollapserGroup>
      <Collapser title="Obtenir l'ID de compte pour chaque événement de transaction">
        Cette requête renvoie l&apos;ID de compte associé à chaque événement `Transaction` renvoyé :

        ```sql
        SELECT accountId() FROM Transaction SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="Obtenez le nombre d'événements de transaction pour chaque compte">
        Cette requête renvoie le nombre d&apos;événements `Transaction` du dernier jour associés à chaque ID de compte :

        ```sql
        SELECT count(*) FROM Transaction FACET accountId() SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="Obtenir le nombre d'événements de transaction pour chaque compte spécifié dans la clause WHERE">
        Cette requête renvoie le nombre d&apos;événements `Transaction` au cours de la dernière journée où l&apos;ID de compte est spécifiquement l&apos;un des `1`, `2` ou `3`:

        ```sql
        SELECT count(*) FROM Transaction WHERE accountId() IN (1,2,3) SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-aparse"
    title={<><InlineCode>
      aparse(attribute, pattern)
    </InlineCode></>
    }
  >
    Utilisez la fonction d&apos;analyse d&apos;ancrage, `aparse()` pour extraire des valeurs spécifiques d&apos;une chaîne. Il s&apos;agit d&apos;une alternative à `capture()`.

    `aparse()` prend deux arguments :

    * Un attribut de chaîne
    * Une chaîne de modèle avec des chaînes d&apos;ancrage et des caractères d&apos;extraction. Par exemple, vous pouvez utiliser `www.*.com` pour extraire le domaine d’une URL.

    Lors de l&apos;utilisation de `aparse()`, la chaîne de modèle doit contenir des ancres, comme `www.` et `.com` ci-dessus, pour identifier l&apos;emplacement de la chaîne extraite prévue, notée par `*`.

    `aparse()` utilise les caractères suivants dans les chaînes de modèle :

    * `%`: Caractère générique non capturant, comme vous le verrez dans la clause `LIKE`
    * `*`: Capture de caractères génériques, similaire à l&apos;utilisation de la capture d&apos;expressions régulières

    En pratique, les chaînes d&apos;ancrage apparaissent souvent au milieu d&apos;un attribut de chaîne, et non au début ou à la fin.

    Dans ce cas, utilisez le caractère générique `%` pour ignorer les valeurs indésirables : par exemple, `%www.*.com%`.

    Comme `capture()`, tous les résultats de `aparse()` sont des chaînes. Pour utiliser ces résultats dans des fonctions mathématiques, ils doivent être convertis avec la fonction `numeric()` .

    Remarque : `aparse()` n&apos;est pas sensible à la casse.

    <CollapserGroup>
      <Collapser title="Utilisation de base" id="aparse-basic" className="freq-link">
        ```sql
        FROM PageView
        SELECT aparse(browserTransactionName, 'website.com/*')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>
          aparse()
        </InlineCode> valeurs spécifiques</>
        }
        id="aparse-specific-values"
        className="freq-link"
      >
        Pour extraire une valeur du milieu d&apos;une chaîne, utilisez le caractère générique non capturant, `%`, au début et à la fin de la chaîne de modèle. Par exemple:

        ```sql
        FROM Log
        SELECT count(*)
        FACET aparse(string, '%"itemId":"*"%')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>
          aparse()
        </InlineCode> valeurs multiples</>
        }
        id="aparse-multiple-values"
        className="freq-link"
      >
        Lors de l’extraction de plusieurs valeurs en tant que variables, notez que l’ordre est important. Par exemple:

        ```sql
        FROM Log
        WITH aparse(string, 'POST: * body: {"itemId":"*","unitPrice":*}\n') AS (url, itemId, unitPrice)
        SELECT url, itemId, unitPrice
        ```

        Pour en savoir plus sur les variables, consultez [Variables NRQL](#with-as-nrql-var).
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-blob"
    title={<InlineCode>blob(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `blob()` sur un attribut de type blob pour renvoyer une chaîne codée en base 64 de cet attribut.

    Cette fonction présente les restrictions suivantes :

    * la requête contenant des appels à `blob()` a une valeur maximale de `LIMIT` de 20

    * `blob()` ne peut pas être appelé dans la clause `WHERE` d&apos;une requête

    * `blob()` ne peut pas être utilisé dans une requête à facettes ou une requête de séries chronologiques

      Pour plus d&apos;informations sur la manière dont cela est utilisé dans le logging, voir [Rechercher des données dans les logs longs (blobs)](/docs/logs/log-management/ui-data/long-logs-blobs).

      Pour décoder un blob codé en base 64, consultez la [fonction`decode()` ](#func-decode).

      <CollapserGroup>
        <Collapser
          title={<>Utilisation <InlineCode>
            blob()
          </InlineCode> sur un log étendu</>
          }
        >
          ```sql
          SELECT message, blob(`newrelic.ext.message`) 
          FROM Log WHERE newrelic.ext.message IS NOT NULL
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-buckets"
    title={<InlineCode>buckets(attribute, ceiling [,number of buckets])</InlineCode>
    }
  >
    Utilisez la fonction `buckets()` pour regrouper les données divisées par une clause `FACET` dans des compartiments basés sur des plages. Vous pouvez effectuer un regroupement en fonction de n&apos;importe quel attribut stocké sous forme de valeur numérique dans la base de données New Relic.

    Il faut trois arguments :

    * Nom de l&apos;attribut

    * Valeur maximale de la plage d&apos;échantillons (toute valeur hors norme apparaîtra dans le compartiment final)

    * Nombre total de seaux

      Pour plus d’informations et d’exemples, voir [Diviser vos données en compartiments](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/segment-your-insights-data-buckets).
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-concat"
    title={<InlineCode>concat(attribute, [, attribute [, ...]] [, precision: ]))</InlineCode>
    }
  >
    Utilisez la fonction `concat()` pour renvoyer la chaîne résultant de la concaténation de ses arguments.

    Jusqu&apos;à 20 arguments de types numériques, booléens, uplet ou éventail peuvent être fournis. Les arguments nuls et les arguments de types non pris en charge sont ignorés. Si aucun argument n&apos;est fourni, le résultat est une chaîne vide.

    L&apos;argument de précision facultatif peut être fourni afin de limiter le nombre de décimales incluses lors de la concaténation de valeurs numériques à virgule flottante.

    La chaîne résultante peut avoir une longueur maximale de 4096 caractères.

    <CollapserGroup>
      <Collapser title="Obtenir plusieurs valeurs de durée à partir de « PageView » sous forme de chaîne formatée">
        Cette requête renvoie les durées du backend et du réseau à partir de l&apos;événement `PageView` , formatées avec deux décimales et des étiquettes, sous la forme d&apos;une seule chaîne.

        ```sql
        FROM PageView 
        SELECT concat('Backend Duration: ', backendDuration, ', Network Duration: ', networkDuration, precision: 2)
        ```

        Cela renverrait des réponses dans un format comme :

        `Backend Duration: 0.69, Network Duration: 0`
      </Collapser>

      <Collapser title="Résultats de la requête à facettes par une chaîne formatée">
        Cette requête renvoie la durée moyenne de configuration de la connexion à partir de l&apos;événement `PageView` , facettée par une chaîne composée de la ville, de la région et du pays de l&apos;utilisateur.

        ```sql
        FROM PageView SELECT average(connectionSetupDuration) 
        FACET concat(city, ', ', regionCode, ' ', countryCode) 
        WHERE countryCode IN ('US', 'CA')
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-convert"
    title={<InlineCode>convert(attribute, fromUnits, toUnits)</InlineCode>
    }
  >
    Utilisez la fonction `convert()` pour effectuer une conversion d’unité entre les unités fournies sur la valeur d’entrée donnée.

    Les unités et abréviations courantes pour le temps, la longueur, le poids, le volume et les données sont prises en charge à l&apos;aide des [normes UCUM](https://ucum.org/ucum) pour s&apos;aligner sur les spécifications OpenTelemetry. Pour plus de commodité, les abréviations standardisées sont complétées par quelques alternatives en langage naturel comme `ft` en plus de `ft_us`, `kilobytes` et `µs`.

    Les unités *sont* sensibles à la casse. Toutes les unités sont en minuscules, sauf si leur spécification exige qu&apos;elles soient en majuscules. Par exemple, les unités de données `'bits'` sont valides pour les bits et `'By'` doivent avoir une majuscule `B` pour les octets.

    La plus grande unité de temps est le `year` julien, qui vaut toujours 365,25 jours.

    <CollapserGroup>
      <Collapser title="Convertir un attribut de millisecondes en minutes">
        ```sql
        FROM Transaction SELECT convert(duration, 'ms', 'min') AS durationMin
        ```
      </Collapser>

      <Collapser title="Convertir la somme des poids de grammes en livres">
        ```sql
        FROM Product SELECT convert(sum(itemWeight), 'grams', 'lbs')
        ```
      </Collapser>

      <Collapser title="Convertir entre l'unité de temps enregistrée et les secondes">
        Cette requête suppose que vous disposez des informations d&apos;unité stockées sous forme d&apos;attribut de chaîne dans l&apos;événement lui-même et que vous souhaitez standardiser les valeurs en secondes.

        ```sql
        FROM Metric 
        SELECT average(convert(apm.mobile.external.duration, unit, 's')) 
        WHERE appName = 'my-application'
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-capture"
    title={<InlineCode>capture(attribute, regular expression)</InlineCode>
    }
  >
    Utilisez `capture()` pour extraire des valeurs d&apos;un attribut à l&apos;aide d&apos;expressions régulières avec [la syntaxe RE2](https://github.com/google/re2/wiki/Syntax).

    Il faut deux arguments :

    * Nom de l&apos;attribut

    * Expression régulière avec syntaxe de capture (les expressions régulières dans NRQL utilisent une syntaxe de type Python, `r'...'`)

      Lors de la capture, utilisez la syntaxe de capture nommée RE2 `...(?P<name> pattern )...` pour capturer le modèle contenu, étant donné le nom spécifié.

      Plusieurs valeurs peuvent être capturées en spécifiant des groupes de capture supplémentaires dans des expressions régulières. Par exemple: `...(?P<name1> pattern1)...(?P<name2> pattern2)...`

      Remarque : lors de la capture de plusieurs valeurs, chaque instruction de capture peut comporter jusqu&apos;à 16 groupes de capture et chaque requête NRQL peut comporter jusqu&apos;à 5 instructions de capture.

      Découvrez comment [utiliser la capture regex pour améliorer les résultats de votre requête](https://newrelic.com/blog/how-to-relic/using-regex-capture).

      <Callout variant="tip">
        Les expressions régulières doivent correspondre à l&apos;intégralité de son entrée. Si une expression de capture n&apos;extrait pas les résultats attendus, vérifiez si elle a besoin `.*` au début ou à la fin, ce qui est le modèle pour une expression régulière de correspondance partielle. Cependant, la correspondance partielle de l&apos;expression régulière peut entraîner l&apos;exécution d&apos;une requête lente.
      </Callout>

      Voici une courte vidéo (3:05 minutes) montrant comment utiliser `capture()` pour améliorer la lisibilité dashboard :

      <Video id="hOPrTWYgPHg" type="youtube" />

      Pour plus d&apos;informations, voir les exemples ci-dessous :

      <CollapserGroup>
        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> dans une condition de clause <InlineCode>
            SELECT
          </InlineCode></>
          }
        >
          Ce qui suit sélectionnera le nom de domaine du site Web, en supprimant `https://` et tous les chemins suivant le `.com`

          ```sql
          SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') 
          FROM PageView SINCE 1 day ago
          ```

          Ce qui suit ne capturera que le premier mot du message d’erreur.

          ```sql
          SELECT capture(errorMessage, r'(?P<firstWord>\S+)\s.+') 
          FROM Transaction 
          WHERE errorMessage IS NOT NULL
          SINCE 1 hour ago 
          ```
        </Collapser>

        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> dans une condition de clause <InlineCode>
            FACET
          </InlineCode></>
          }
        >
          Ce qui suit sera facetté par la méthode HTTP capturée.

          ```sql
          SELECT count(*) FROM Log 
          WHERE message LIKE '%HTTP%' 
          FACET capture(message, r'.* "(?P<httpMethod>[A-Z]+) .*')
          ```
        </Collapser>

        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> dans une condition de clause <InlineCode>
            WHERE
          </InlineCode></>
          }
        >
          Ce qui suit filtrera les résultats en fonction de l&apos;événement de log avec l&apos;attribut `message` qui correspond aux expressions régulières où le nom du travail capturé est `ExampleJob`.

          ```sql
          SELECT message FROM Log 
          WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' 
          SINCE 10 minutes ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> avec une distribution numérique</>
          }
        >
          Ce qui suit capturera la somme du temps CPU à partir des lignes log . Vous devez explicitement convertir en numérique pour effectuer des opérations mathématiques.

          ```sql
          SELECT sum(numeric(capture(message, r'.*CpuTime:\s(?P<cpuTime>\d+)'))) 
          FROM Log 
          WHERE message LIKE '%CpuTime:%' SINCE 1 hour ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> valeurs multiples avec des variables NRQL</>
          }
        >
          Dans cet exemple, les variables NRQL sont utilisées pour stocker plusieurs valeurs capturées à partir d&apos;un message de log.

          ```sql
          FROM Log
          WITH capture(message, r'POST to carts: (?P<URL>.*) body: {"itemId":"(?P<UUID>.*)","unitPrice":(?P<unitPrice>.*)}.*')
            AS (URL, UUID, unitPrice)
          SELECT URL, UUID, unitPrice
          WHERE URL IS NOT NULL
          ```

          En savoir plus sur les variables NRQL [ici](#with-as-nrql-var).
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-decode"
    title={<InlineCode>decode(input, encoding)</InlineCode>
    }
  >
    Utilisez `decode()` pour effectuer des conversions en base 64 sur des chaînes et des blobs. La valeur d&apos;entrée (le premier argument) sera décodée à l&apos;aide de la norme base-64 spécifiée par l&apos;encodage (le deuxième argument).

    Les valeurs de chaîne suivantes sont des paramètres d’encodage pris en charge :

    * &apos;base64&apos; : utilise la [norme RFC4648 base-64](https://datatracker.ietf.org/doc/html/rfc4648#section-4)

    * &apos;base64mime&apos; : utilise la [norme RFC2045 base-64 (MIME)](https://datatracker.ietf.org/doc/html/rfc2045)

    * &apos;base64url&apos; : utilise la [norme RFC4648 base-64 avec un alphabet sécurisé pour les URL et les noms de fichiers](https://datatracker.ietf.org/doc/html/rfc4648#section-5)

      Comme `blob()` n&apos;est pas autorisé dans les clauses `WHERE` ou `FACET` , `decode()` avec les types blob n&apos;est pas pris en charge dans la clause `WHERE` ou pour les requêtes à facettes.

      Pour encoder des chaînes, voir la [fonction`encode()` ](#func-encode).

      <CollapserGroup>
        <Collapser
          title={<>Utilisation <InlineCode>
            decode()
          </InlineCode> sur un attribut de chaîne</>
          }
        >
          ```sql
          FROM Span SELECT entity.guid, decode(entity.guid, 'base64') 
          WHERE entity.guid IS NOT NULL
          ```
        </Collapser>

        <Collapser
          title={<>Utilisation de <InlineCode>
            decode()
          </InlineCode> dans un <InlineCode>
            FACET
          </InlineCode></>
          }
        >
          ```sql
          FROM Span SELECT count(*) 
          WHERE entity.guid IS NOT NULL 
          FACET entity.guid, decode(entity.guid, 'base64')
          ```
        </Collapser>

        <Collapser
          title={<>Utilisation <InlineCode>
            decode()
          </InlineCode> dans une clause <InlineCode>
            WHERE
          </InlineCode></>
          }
        >
          ```sql
          FROM Span SELECT count(*) 
          WHERE entity.guid IS NOT NULL 
          AND decode(entity.guid, 'base64') NOT LIKE '%APM%'
          ```
        </Collapser>

        <Collapser
          title={<>Utilisation <InlineCode>
            decode()
          </InlineCode> avec un attribut de type blob</>
          }
        >
          ```sql
          FROM Log
          WITH blob(`newrelic.ext.message`) AS encodedBlob,
          decode(encodedBlob, 'base64') AS decodedBlob
          SELECT encodedBlob, decodedBlob
          WHERE newrelic.ext.message IS NOT NULL
          LIMIT 10
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-dimensions"
    title={<InlineCode>{`dimensions(include: {attributes}, exclude: {attributes})`}</InlineCode>
    }
  >
    Utilisez la fonction `dimensions()` pour renvoyer toutes les valeurs dimensionnelles sur un type de données.

    Vous pouvez explicitement inclure ou exclure un attribut spécifique à l&apos;aide des arguments facultatifs :

    * `include`: si présent, la liste d&apos;inclusion limite `dimensions()` à ces attributs.

    * `exclude`: si présent, le calcul `dimensions()` ignore ces attributs.

      ```sql
      FROM Metric SELECT count(node_filesystem_size) 
      TIMESERIES FACET dimensions()
      ```

      Lorsqu&apos;il est utilisé avec une clause `FACET`, `dimensions()` produit une série temporelle unique pour toutes les facettes disponibles sur le type d&apos;événement, de la même manière que Prometheus se comporte avec une requête non agrégée.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-encode"
    title={<InlineCode>encode(input, encoding)</InlineCode>
    }
  >
    Utilisez `encode()` pour effectuer des conversions en base 64 sur des chaînes. La valeur d&apos;entrée (le premier argument) sera codée à l&apos;aide de la norme base-64 spécifiée par l&apos;encodage (le deuxième argument).

    Les valeurs de chaîne suivantes sont des paramètres d’encodage pris en charge :

    * &apos;base64&apos; : utilise la [norme RFC4648 base-64](https://datatracker.ietf.org/doc/html/rfc4648#section-4)

    * &apos;base64mime&apos; : utilise la [norme RFC2045 base-64 (MIME)](https://datatracker.ietf.org/doc/html/rfc2045)

    * &apos;base64url&apos; : utilise la [norme RFC4648 base-64 avec un alphabet sécurisé pour les URL et les noms de fichiers](https://datatracker.ietf.org/doc/html/rfc4648#section-5)

      Pour décoder des chaînes ou des blobs, consultez la [fonction`decode()` ](#func-decode). `encode()` n&apos;est pas pris en charge pour les blobs.

      <CollapserGroup>
        <Collapser
          title={<>Utilisation <InlineCode>
            encode()
          </InlineCode> sur un attribut</>
          }
        >
          ```sql
          FROM PageView SELECT session, encode(session, 'base64')
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cidraddress"
    title={<InlineCode>cidrAddress(attribute [, number [, cidrFormat])</InlineCode>
    }
  >
    Utilisez la fonction `cidrAddress()` pour obtenir l’adresse réseau de base à partir d’une adresse IP CIDR.

    `cidrAddress()` prend les arguments suivants :

    * `attribute` - Une valeur de chaîne qui contient soit une adresse IP seule, soit avec une longueur de préfixe en notation CIDR.

      * Il peut s&apos;agir d&apos;un attribut de chaîne ou d&apos;une chaîne littérale entre guillemets.
      * L&apos;adresse IP doit être une adresse IPv4.

    * `number` - Une valeur entière qui représente la longueur du préfixe.

      * Il peut s&apos;agir d&apos;un attribut entier ou d&apos;une valeur entière.
      * Si le paramètre d&apos;attribut est en notation CIDR, ce paramètre est facultatif et a priorité sur la longueur de préfixe fournie dans la chaîne CIDR.

    * `cidrFormat` - Une valeur booléenne facultative utilisée pour déterminer si la sortie de l&apos;adresse réseau doit être formatée en notation CIDR. La valeur par défaut sera vraie.

      La fonction `cidrAddress()` renverra une valeur tant que les paramètres d&apos;attribut et de numéro contiennent une adresse IP et une longueur de préfixe valides. Si le paramètre d&apos;entrée n&apos;est pas valide, `cidrAddress()` renverra `null`.

      <CollapserGroup>
        <Collapser title="Trouvez les sous-réseaux qui traitent le plus requests">
          La requête suivante renvoie les sous-réseaux qui traitent le plus requests du type d&apos;événement [SyntheticRequest](/attribute-dictionary/?event=SyntheticRequest) .

          ```sql
          FROM SyntheticRequest SELECT count(*) FACET cidrAddress(serverIPAddress, 24)
          ```

          Cela renverrait des réponses dans un format comme :

          <table>
            <thead>
              <tr>
                <th>
                  Adresse Cidr de l&apos;adresse IP du serveur
                </th>

                <th>
                  Compter
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  10.0.0.0/24
                </td>

                <td>
                  6 000
                </td>
              </tr>

              <tr>
                <td>
                  10.10.1.0/24
                </td>

                <td>
                  4k
                </td>
              </tr>

              <tr>
                <td>
                  10.0.14.0/24
                </td>

                <td>
                  1 000
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser title="Interroger toutes les adresses IP qui existent dans une plage CIDR">
          Cette requête renvoie toutes les adresses IP de l&apos;attribut [`serverIPAddress`](/attribute-dictionary/?event=SyntheticRequest&attribute=serverIPAddress) qui existent dans la plage CIDR de 10.0.0.0 à 10.0.0.255.

          ```sql
          FROM SyntheticRequest SELECT uniques(serverIPAddress) 
          WHERE cidrAddress(serverIPAddress, 24) = '10.0.0.0/24'
          ```
        </Collapser>

        <Collapser title="Filtrer les adresses IP qui existent dans une plage CIDR spécifique à partir des résultats de la requête">
          Cette requête renvoie un nombre de tous les enregistrements tout en excluant les enregistrements qui contiennent une valeur [`serverIPAddress`](/attribute-dictionary/?event=SyntheticRequest&attribute=serverIPAddress) comprise dans la plage CIDR de 10.0.0.0/24 ou 10.10.1.0/24.

          ```sql
          FROM SyntheticRequest SELECT count(*) 
          WHERE cidrAddress(serverIPAddress, 24) NOT IN ('10.0.0.0/24', '10.10.1.0/24')
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="event-type"
    title={<InlineCode>eventType()</InlineCode>
    }
  >
    ```sql
    ...WHERE eventType() = 'EventNameHere'...
    ...FACET eventType()...
    ```

    Utilisez la fonction `eventType()` dans une clause [`FACET`](#sel-facet) pour décomposer les résultats selon le type de données sélectionné ou dans une clause [`WHERE`](#sel-where) pour filtrer les résultats selon un type de données spécifique. Ceci est particulièrement utile pour cibler des types de données spécifiques avec les fonctions [`filter()`](#func-filter) et [`percentage()`](#func-percentage) .

    <Callout variant="important">
      Dans ce contexte, « type d’événement » fait référence aux types de données auxquelles vous pouvez accéder avec une requête NRQL.
    </Callout>

    <CollapserGroup>
      <Collapser
        id="filter-eventtype"
        title={<>Utiliser <InlineCode>
          eventType()
        </InlineCode> dans la fonction <InlineCode>
          filter()
        </InlineCode></>
        }
      >
        Cette requête renvoie le pourcentage du total de `TransactionError` résultats sur le total de `Transaction` résultats. Vous pouvez utiliser la fonction `eventType()` pour cibler des types de données spécifiques avec la fonction `filter()` .

        ```sql
        SELECT 100 * filter(count(*), WHERE eventType() = 'TransactionError') / filter(count(*), WHERE eventType() = 'Transaction') 
        FROM Transaction, TransactionError 
        WHERE appName = 'App.Prod' 
        TIMESERIES 2 Minutes SINCE 6 hours ago
        ```
      </Collapser>

      <Collapser
        id="facet-eventtype"
        title={<>Utilisez <InlineCode>
          eventType()
        </InlineCode> avec <InlineCode>
          FACET
        </InlineCode></>
        }
      >
        Cette requête affiche le nombre d&apos;enregistrements renvoyés par chaque type de données (`Transaction` et `TransactionError`).

        ```sql
        SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getfield"
    title={<InlineCode>getField(attribute, field)</InlineCode>
    }
  >
    Utilisez la fonction `getField()` pour extraire un élément d&apos;un éventail ou un champ à partir de types de données composés, tels que [des données métriques dimensionnelles](/docs/data-apis/understand-data/metric-data/metric-data-type).

    `getField()` prend les arguments suivants :

    * `attribute` - Un éventail ou un type de données composé.
    * `field` - L&apos;index de l&apos;élément éventail ou le nom du champ du type de données composé.

    <CollapserGroup>
      <Collapser title="Extraire un élément d'un éventail">
        <Callout variant="important">
          L&apos;indexation de l&apos;éventail commence par `0`.
        </Callout>

        **Exemples**\
        Considérez l’éventail `[100, 110, 90, 100, 105]` stocké dans l’attribut `durations`. La requête ci-dessous renverra `90`:

        ```sql
        SELECT getField(durations, 2) FROM Foo
        ```

        Vous pouvez utiliser les crochets `[ ]` comme raccourci pour `getField()`. La requête suivante renverra également `90`:

        ```sql
        SELECT durations[2] FROM Foo
        ```
      </Collapser>

      <Collapser title="Extraction d'un champ d'un type de données composé">
        Les types de données composés pris en charge et leurs champs sont :

        <table>
          <thead>
            <tr>
              <th style={{ width: "500px" }}>
                Type métrique
              </th>

              <th>
                Champs pris en charge
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `summary`
              </td>

              <td>
                `count`, `total`, `max`, `min`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `gauge`
              </td>

              <td>
                `count`, `total`, `max`, `min`, `latest`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `distribution`
              </td>

              <td>
                `count`, `total`, `max`, `min`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `count`
              </td>

              <td>
                `count`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `cumulativeCount`
              </td>

              <td>
                `count`, `cumulative`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `timeslice`
              </td>

              <td>
                `count`, `total`, `totalExclusive`, `min`, `max`, `sumOfSquares`
              </td>
            </tr>
          </tbody>
        </table>

        **Exemples**

        ```sql
        SELECT max(getField(mySummary, count)) FROM Metric
        ```

        ```sql
        SELECT sum(mySummary) FROM Metric where getField(mySummary, count) > 10
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getCdfCount"
    title={<InlineCode>getCdfCount(attribute, threshold)</InlineCode>
    }
  >
    `getCdfCount()` est une implémentation de la [fonction de distribution cumulative](https://en.wikipedia.org/wiki/Cumulative_distribution_function), renvoyant le nombre de valeurs dans `attribute` égal ou inférieur à `threshold`.

    Un seul seuil est autorisé. `Attribute` peut être soit un attribut numérique, soit un attribut de métrique de distribution. Les types mixtes dans une requête sont acceptés.

    Pour un type numérique, il renvoie 1 si l&apos;attribut est inférieur ou égal au seuil, sinon il renvoie 0. Pour une distribution, il renvoie le nombre dans l&apos;ensemble de données représenté par la distribution. Pour tous les autres types, elle renvoie 0.

    <CollapserGroup>
      <Collapser title="Obtenez le nombre de premières peintures plus rapidement qu'un seuil">
        Cette requête renvoie le nombre d&apos;événements où `firstPaint` est inférieur ou égal à 1 seconde.

        ```sql
        FROM PageView SELECT sum(getCdfCount(firstPaint, 1.0))
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-if"
    title={<><InlineCode>
      if(condition, trueValue [, falseValue])
    </InlineCode></>
    }
  >
    Utilisez `if()` pour effectuer des opérations de contrôle de flux if-then-else dans une requête.

    `if()` prend 3 arguments :

    * `condition` - une expression qui peut être évaluée à `true` ou `false`
    * `trueValue` - cette valeur est renvoyée si l&apos;expression booléenne est `true`
    * `falseValue` - cette valeur facultative est renvoyée si l&apos;expression booléenne est `false`, ou si elle n&apos;est pas fournie, `NULL` est renvoyée

    <CollapserGroup>
      <Collapser title="Utilisation de base">
        ```sql
        FROM Log
        SELECT count(*)
        FACET if(level_name = 'ERROR', 'ERROR', 'NOT_ERROR')
        ```
      </Collapser>

      <Collapser
        title={<>Utiliser avec <InlineCode>
          AND
        </InlineCode> et <InlineCode>
          OR
        </InlineCode></>
        }
      >
        ```sql
        FROM Log
        SELECT count(*)
        FACET if(level_name = 'INFO' OR level_name = 'WARNING', 'NOT_ERROR', 'ERROR')
        ```
      </Collapser>

      <Collapser
        title={<>Imbriqué <InlineCode>
          If()
        </InlineCode></>
        }
      >
        Utilisez une fonction `if()` imbriquée pour ajouter une logique conditionnelle supplémentaire.

        ```sql
        FROM Transaction SELECT count(*)
        FACET if(appName LIKE '%java%', 'Java',
            if(appName LIKE '%kafka%', 'Kafka', 'Other'))
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-jparse"
    title={<InlineCode>jparse(attribute [, path])</InlineCode>
    }
  >
    Utilisez la fonction d&apos;analyse JSON, `jparse()`, pour analyser une valeur de chaîne et produire une carte/liste de valeurs (ou de structures imbriquées) qui peuvent être traitées comme tout autre type de valeur de première classe dans NRQL.

    `jparse()` prend deux arguments :

    * `attribute` - Une valeur de chaîne JSON.
    * `path` - Une valeur de chaîne facultative utilisée pour référencer directement une partie particulière du JSON dans le paramètre `attribute` . Consultez la section [Référence de la syntaxe du chemin d’analyse JSON](#json-parse-path-syntax-reference) ci-dessous.

    La fonction `jparse()` suit le [format RFC 8259](https://datatracker.ietf.org/doc/html/rfc8259#section-2) pour analyser les valeurs JSON. Lorsque la fonction `jparse()` est utilisée sans le paramètre `path` , elle renverra la valeur JSON désérialisée.

    Vous pouvez utiliser des crochets pour extraire des valeurs individuelles d&apos;un résultat `jparse()` via une clé/un index et mapper les clés JSON directement à l&apos;attribut à l&apos;aide de la clause `WITH` .

    <CollapserGroup>
      <Collapser id="jparse-square-bracket-syntax" title="Référencement d'une clé/index à l'aide de la syntaxe entre crochets">
        <DNT>
          **Referencing a key**
        </DNT>

        La requête suivante fait référence à la clé `userNames` dans l&apos;attribut `jsonString` et renverra `['abc', 'xyz']`.

        ```sql
        WITH '{"userNames": ["abc", "xyz"]}' AS jsonString SELECT jparse(jsonString)[userNames]
        ```

        <DNT>
          **Referencing an index**
        </DNT>

        La requête suivante fait référence à l&apos;index `0` dans l&apos;attribut `jsonString` et renverra `'abc'`.

        ```sql
        WITH '["abc", "xyz"]' AS jsonString SELECT jparse(jsonString)[0]
        ```
      </Collapser>

      <Collapser id="mapping-json-keys-to-attributes" title="modélisation des clés JSON à attribuer">
        La requête suivante utilise `jparse()` dans la clause `WITH` pour mapper les clés JSON `userName` et `id` dans des variables NRQL afin qu&apos;elles puissent être utilisées dans le reste de la requête.

        ```sql
        WITH '{"userName": "test", "unused": null, "id": 100}' AS jsonString, jparse(jsonString) AS (userName, id) SELECT userName, id
        ```
      </Collapser>
    </CollapserGroup>

    Pour analyser des valeurs spécifiques de la chaîne JSON, vous pouvez utiliser le paramètre `path` .

    <Collapser id="json-parse-path-syntax-reference" title="Référence de la syntaxe du chemin d'analyse JSON">
      Il est courant que les données JSON soient imbriquées dans plusieurs couches sous des formes non triviales. La syntaxe du chemin vous permet de référencer directement un élément particulier des données JSON.

      Exemple de données :

      ```json
      {
        "valueA": "test",
        "valueB": {
          "nestedValue1": [1, 2, 3],
          "nestedValue2": 100
        },
        "valueC": [
          { "id": 1, "label": "A", "other": 7 },
          { "id": 2, "label": "B", "other": 9 },
          { "id": 3, "label": "C", "other": 13 }
        ]
      }
      ```

      Exemples de syntaxe de chemin utilisant les données ci-dessus :

      <table id="join-types">
        <thead>
          <tr>
            <th>
              <DNT>
                **Path Syntax Example**
              </DNT>
            </th>

            <th>
              <DNT>
                **Result Description**
              </DNT>
            </th>

            <th>
              <DNT>
                **Result**
              </DNT>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              `valueA`
            </td>

            <td>
              Renvoie la valeur à la clé
            </td>

            <td>
              `"test"`
            </td>
          </tr>

          <tr>
            <td>
              `["valueA"]`
            </td>

            <td>
              Renvoie la valeur à la clé
            </td>

            <td>
              `"test"`
            </td>
          </tr>

          <tr>
            <td>
              `[valueA, valueC]`
            </td>

            <td>
              Renvoie la liste des valeurs clés
            </td>

            <td>
              `["test", [{"id": 1…}, {"id": 2…}], {"id": 3…}]]`
            </td>
          </tr>

          <tr>
            <td>
              `valueB.nestedValue2`
            </td>

            <td>
              Renvoie la valeur à la clé
            </td>

            <td>
              `100`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[0]`
            </td>

            <td>
              Renvoie la valeur de la liste à l&apos;index `0`
            </td>

            <td>
              `{"id": 1…}`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[0,2]`
            </td>

            <td>
              Renvoie les valeurs de la liste à l&apos;index `0` et `2`
            </td>

            <td>
              `[{"id": 1…}, {"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[0:2]`
            </td>

            <td>
              Renvoie la plage de valeurs de liste du premier index au deuxième, à l&apos;exclusion de la valeur du deuxième index. Dans ce cas, les valeurs de liste aux index `0` et `1` sont renvoyées.
            </td>

            <td>
              `[{"id": 1…}, {"id": 2…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[:2]`
            </td>

            <td>
              Renvoie la plage de valeurs de la liste du début au deuxième index, à l&apos;exclusion de la valeur du deuxième index. Dans ce cas, les valeurs de liste aux index `0` et `1` sont renvoyées.
            </td>

            <td>
              `[{"id": 1…}, {"id": 2…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[:-2]`
            </td>

            <td>
              Renvoie toutes les valeurs de la liste à l&apos;exception du dernier *n*, où *n* est un nombre négatif après les deux points (c&apos;est-à-dire `[:-n]`). Dans ce cas, la valeur de la liste à l’index `0` sera renvoyée.
            </td>

            <td>
              `[{"id": 1…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[1:]`
            </td>

            <td>
              Renvoie la plage de valeurs de liste depuis l&apos;index spécifié jusqu&apos;à la fin de la liste. Dans ce cas, les valeurs de liste aux index `1` et `2` sont renvoyées.
            </td>

            <td>
              `[{"id": 2…}, {"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[-1:]`
            </td>

            <td>
              Renvoie les *n* dernières valeurs de la liste, où *n* est un nombre négatif avant les deux points (par exemple, `[-n:]`). Dans ce cas, la valeur de la liste à l&apos;index `2` sera renvoyée.
            </td>

            <td>
              `[{"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[*]`
            </td>

            <td>
              Renvoie toutes les valeurs de la liste
            </td>

            <td>
              `[{"id": 1…}, {"id": 2…}, {"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[*].id`
            </td>

            <td>
              Renvoie la valeur clé spécifiée de tous les membres de la liste. Dans ce cas, la valeur clé `id` .
            </td>

            <td>
              `[1, 2, 3]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[*]["label", "other"]`
            </td>

            <td>
              Renvoie les clés spécifiées de tous les membres de la liste. Dans ce cas, les valeurs `label` et `other` sont clés.
            </td>

            <td>
              `[["A", 7],…]`
            </td>
          </tr>
        </tbody>
      </table>
    </Collapser>

    Exemples :

    <CollapserGroup>
      <Collapser id="basic-jparse-example" title="Exemple de base">
        La requête suivante analyse la chaîne JSON dans l’attribut `jsonString` .

        ```sql
        WITH '{"user": {"name": "John", "id": 5}}' AS jsonString SELECT jparse(jsonString)
        ```

        Cette requête renverra la chaîne JSON désérialisée :

        ```json
        {"user":{"name":"John","id":5}}
        ```
      </Collapser>

      <Collapser id="parse-specific-value-from-log-message" title="Analyser une valeur spécifique d'un message de log">
        Un problème courant est d&apos;avoir des données riches et structurées cachées dans un message de log. Vous pouvez utiliser [`aparse()`](#func-aparse) et `jparse()` pour éliminer le bruit et trouver des valeurs spécifiques.

        La requête suivante :

        1. Appelle `aparse()` pour extraire les données JSON de l&apos;attribut `logMessage`
        2. Analyse le champ `user.name` des données JSON extraites à l&apos;aide `jparse()` et du paramètre de chemin `user.name` .

        ```sql
        WITH '1693242121842: value=\'{"user": {"name": "John", "id": 5}}\', useless=stuff' AS logMessage, aparse(logMessage, '%: value=\'*\'%') AS jsonString SELECT jparse(jsonString, 'user.name')
        ```
      </Collapser>

      <Collapser id="parse-multiple-values-from-json" title="Analyser plusieurs valeurs imbriquées à partir d'une chaîne JSON">
        La requête suivante analyse chaque champ `id` de la liste des objets dans l&apos;attribut `jsonString` et génère ces valeurs sous forme d&apos;éventail.

        ```sql
        WITH '{"users": [{"name": "A", "id": 5}, {"name": "B", "id": 10}]}' AS jsonString, jparse(jsonString, 'users[*].id') AS ids SELECT ids
        ```

        La requête ci-dessus renverra `[5, 10]`.
      </Collapser>
    </CollapserGroup>

    *Fonctions associées :* [`mapKeys()`](#func-mapKeys), [`mapValues()`](#func-mapValues)
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-length"
    title={<InlineCode>length(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `length()` pour renvoyer la longueur d&apos;une valeur de chaîne ou le nombre d&apos;éléments dans une valeur d&apos;éventail.

    Il faut un seul argument.

    <CollapserGroup>
      <Collapser title="Obtenir la longueur de l'URL à partir de PageView">
        Cette requête renvoie la longueur de chaque chaîne d&apos;URL de l&apos;événement `PageView` .

        ```sql
        SELECT length(pageUrl) FROM PageView
        ```
      </Collapser>

      <Collapser title="Obtenir la longueur d'un éventail">
        Considérez l’éventail `["US", "CA", "UK"]` stocké dans l’attribut `countries` .

        ```sql
        SELECT length(countries) FROM Foo
        ```

        length(countries) dans la requête ci-dessus renverra `3`.
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-contains"
    title={<InlineCode>contains(attribute, element)</InlineCode>
    }
  >
    Utilisez la fonction `contains()` pour vérifier si un élément existe dans un éventail.

    `contains()` prend les arguments suivants :

    * `attribute` - Un éventail
    * `element` - L&apos;élément pour vérifier l&apos;éventail pour

    <CollapserGroup>
      <Collapser title="Vérifier si un éventail contient un élément">
        Considérez l’éventail `["9999-1234-9999", "3333-7890-3333", "5555-3456-555"]` stocké dans l’attribut `guids` .

        ```sql
        SELECT contains(guids, '5555-3456-555') FROM Foo
        ```

        `contains(guids, '5555-3456-555')` dans la requête ci-dessus renverra `TRUE`.
      </Collapser>

      <Collapser title="Filtrer les éléments dans count(*) en utilisant contient">
        Considérez l&apos;éventail `["9999-1234-9999", "3333-7890-3333", "5555-3456-555"]` stocké dans l&apos;attribut `guids` au sein du type d&apos;événement `Transaction` .

        ```sql
        SELECT count(*) FROM Transaction WHERE contains(guids, '9999-1234-9999')
        ```

        La requête ci-dessus renverra un nombre de transactions qui incluent le GUID `"9999-1234-9999"` .
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-lookup"
    title={<InlineCode>tableau de recherche)</InlineCode>
    }
  >
    Si vous avez [téléchargé une table de recherche](/docs/logs/ui-data/lookup-tables-ui), vous pouvez utiliser cette fonction avec un nom de table pour accéder aux données de cette table dans une requête. Voici un exemple de requête :

    ```sql
    FROM Log
    SELECT count(*)
    WHERE hostname IN (FROM lookup(myHosts) SELECT uniques(myHost))
    ```

    Pour plus d&apos;informations, consultez [Comment interroger les données d&apos;une table de recherche](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/lookups).
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-lower"
    title={<InlineCode>lower(str)</InlineCode>
    }
  >
    Utilisez la fonction `lower()` pour changer tous les caractères alphabétiques d’une valeur de chaîne en minuscules.

    Arguments:

    * `str` - La valeur de la chaîne doit être en minuscules

      * Cela peut être tout ce qui est évalué comme une chaîne, y compris une chaîne littérale entre guillemets, un attribut de chaîne interrogé, une fonction qui renvoie une chaîne ou même une sous-requête qui renvoie une valeur de chaîne unique.
      * Si cet argument est évalué à null, la fonction `lower()` renverra null.

      <CollapserGroup>
        <Collapser title="Mettre une chaîne en minuscules">
          Cette requête illustre l&apos;utilisation de la fonction `lower()` dans différentes parties d&apos;une requête.

          ```sql
          FROM PageAction
          SELECT latest(lower(actionName))
          WHERE lower(actionName) = lower('acmePageRenderedEvent') OR lower(actionName) = lower('SubmitLogin')
          FACET concat(actionName, ':', lower(actionName))
          ```

          <img title="screenshot lower()" alt="screenshot lower()" src="/images/lowerExample.webp" />

          <figcaption>
            <InlineCode>
              lower(str)
            </InlineCode> exemple
          </figcaption>
        </Collapser>
      </CollapserGroup>

      *Fonction associée : [<InlineCode>
        upper()
      </InlineCode>](#func-upper)*
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mapKeys"
    title={<InlineCode>mapKeys(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `mapKeys()` pour renvoyer une liste de clés lorsqu&apos;une carte est fournie en entrée dans le paramètre `attribute` .

    <CollapserGroup>
      <Collapser id="extract-list-of-keys" title="Extraire une liste de clés dans une chaîne JSON">
        ```sql
        WITH '{"userResult1": 100, "userResult2": 200, "userResult3": 4}' AS jsonString SELECT mapKeys(jparse(jsonString)) AS keys
        ```

        La requête ci-dessus :

        1. Désérialise la chaîne JSON dans l&apos;attribut `jsonString` dans une carte à l&apos;aide de la fonction `jparse()`
        2. Appelle la fonction `mapKeys()` pour extraire une liste de toutes les clés de cette carte
        3. Lie cette liste de clés à l&apos;attribut `keys`

        Après avoir exécuté la requête ci-dessus, `keys` contiendra la liste `['userResult1', 'userResult2', 'userResult3']`.
      </Collapser>

      <Collapser id="extract-list-of-keys-with-nested-keys" title="Extraire une liste de clés d'une chaîne JSON avec des clés imbriquées">
        ```sql
        WITH '{"value1": "test", "value2": {"nestedValue1": [1, 2, 3], "nestedValue2": 100}}' AS jsonString SELECT mapKeys(jparse(jsonString)) AS keys
        ```

        La requête ci-dessus extraira uniquement les clés les plus externes de la chaîne JSON dans l&apos;attribut `jsonString` . Après avoir exécuté la requête, `keys` contiendra la liste `['value1', 'value2']`.
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mapValues"
    title={<InlineCode>mapValues(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `mapValues()` pour renvoyer une liste de valeurs lorsqu&apos;une carte est fournie en entrée dans le paramètre `attribute` .

    <CollapserGroup>
      <Collapser id="extract-list-of-values" title="Extraire une liste de valeurs dans une chaîne JSON">
        ```sql
        WITH '{"userResult1": 100, "userResult2": 200, "userResult3": 4}' AS jsonString SELECT mapValues(jparse(jsonString)) AS values
        ```

        La requête ci-dessus :

        1. Désérialise la chaîne JSON dans l&apos;attribut `jsonString` dans une carte à l&apos;aide de la fonction `jparse()`
        2. Appelle la fonction `mapValues()` pour extraire une liste de toutes les valeurs de cette carte
        3. Lie cette liste de valeurs à l&apos;attribut `values`

        Après avoir exécuté la requête ci-dessus, `values` contiendra la liste `[100, 200, 4]`.
      </Collapser>

      <Collapser id="extract-list-of-values-with-nested-values" title="Extraire une liste de valeurs d'une chaîne JSON avec des valeurs imbriquées">
        ```sql
        WITH '{"value1": "test", "value2": {"nestedValue1": [1, 2, 3], "nestedValue2": 100}}' AS jsonString SELECT mapValues(jparse(jsonString)) AS values
        ```

        La requête ci-dessus extrait les valeurs les plus externes de la chaîne JSON dans l&apos;attribut `jsonString` . Après avoir exécuté la requête, `values` contiendra une liste de la chaîne `"test"` et de l&apos;objet imbriqué.

        Ceci peut être vu dans la vue JSON :

        ```json
        "contents": [
          {
            "function": "alias",
            "alias": "values",
            "contents": {
              "constant": [
                "test",
                {
                  "nestedValue1": [
                    1,
                    2,
                    3
                  ],
                  "nestedValue2": 100
                }
              ]
            }
          }
        ],
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-minOf"
    title={<InlineCode>minuteOf(attribute), hourOf(attribute), etc.</InlineCode>
    }
  >
    Utilisez la fonction `minuteOf()` pour extraire uniquement la partie minute (c&apos;est-à-dire les minutes 0 à 59) d&apos;un attribut contenant une valeur d&apos;horodatage valide. Cela fonctionne également pour des fonctions telles que `hourOf()`, `weekOf()`, etc. Pour une liste complète des fonctions basées sur le temps, consultez le tableau dans notre [document sur les résultats de groupe dans le temps](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-group-results-across-time/#cohorts)
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mod"
    title={<InlineCode>mod(attribute, divisor)</InlineCode>
    }
  >
    Utilisez la fonction `mod()` pour renvoyer le module plancher après avoir divisé la valeur de l&apos;attribut numérique fourni (le premier argument ou dividende) par une valeur numérique (le deuxième argument ou diviseur). Cette opération modulo peut être utilisée dans une condition de clause `WHERE` pour filtrer un sous-ensemble arbitraire de résultats ou dans une clause `FACET` comme moyen de subdiviser l&apos;ensemble de résultats.

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          mod()
        </InlineCode> dans une condition de clause <InlineCode>
          WHERE
        </InlineCode></>
        }
      >
        ```sql
        FROM Transaction SELECT * WHERE mod(port, 2) = 1
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          mod()
        </InlineCode> dans une clause <InlineCode>
          FACET
        </InlineCode></>
        }
      >
        ```sql
        FROM NrConsumption SELECT uniques(hostId, 10000) 
        SINCE 1 day AGO FACET mod(hostId, 10)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-position"
    title={<InlineCode>position(str, substr [, occurrence])</InlineCode>
    }
  >
    Utilisez la fonction `position()` pour trouver l’emplacement d’une sous-chaîne dans une chaîne. La correspondance est sensible à la casse.

    Arguments:

    * `str` - la chaîne dans laquelle trouver la sous-chaîne.

      * Cela peut être tout ce qui est évalué comme une chaîne, y compris une chaîne littérale entre guillemets, un attribut de chaîne interrogé, une fonction qui renvoie une chaîne ou même une sous-requête qui renvoie une valeur de chaîne unique.

    * `substr` - la chaîne à rechercher dans str.

    * `occurrence` - indique à quelle occurrence de substr doit être renvoyée la position.

      * *Défaut*: `0`
      * Si positif, recherchez la n-ième occurrence du substr à partir du début de str, en commençant par zéro
      * Si négatif, recherchez la nième occurrence du substr à partir de la fin de str. La dernière occurrence de substr serait l&apos;occurrence -1.

      Alias : <InlineCode>
        indexOf(str, substr \[, occurrence])
      </InlineCode> - `indexOf()` est un nom alternatif pour la fonction `position()`

      Retours :

      * L&apos;index de base 0 du caractère de départ de la sous-chaîne dans str
      * Null est renvoyé si str est nul, substr est nul ou si l&apos;occurrence référencée de substr n&apos;est pas trouvée

    <CollapserGroup>
      <Collapser title="Trouver l'index de position d'une sous-chaîne dans une URL">
        Cette requête démontre l&apos;utilisation de la fonction <InlineCode>
          position()
        </InlineCode> pour trouver l&apos;index de position de diverses sous-chaînes dans une chaîne. L&apos;utilisation de la fonction <InlineCode>
          position()
        </InlineCode> dans les arguments de la fonction [<InlineCode>
          substring()
        </InlineCode>](#func-substring) est également démontrée ici.

        ```sql
        FROM PageView
        WITH position(pageUrl, ':') AS FirstColon,
          position(pageUrl, '/', 1) + 1 AS DomainBegin, 
          position(pageUrl, '/', 2) AS DomainEnd, 
          DomainEnd - DomainBegin AS DomainLength
        SELECT pageUrl, FirstColon, substring(pageUrl, 0, FirstColon) AS Protocol,
          DomainBegin, DomainEnd, DomainLength, substring(pageUrl, DomainBegin, DomainLength) AS Domain,
          position(pageUrl, '/', -1) AS LastSlash, 
          substring(pageUrl, position(pageUrl, '/', -1)) AS PathEnd
        ```

        <img title="screenshot position()" alt="screenshot position()" src="/images/positionExample.webp" />

        <figcaption>
          <InlineCode>
            position(str, substr \[, occurrence])
          </InlineCode> exemple
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="round"
    title={<InlineCode>round(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `round()` pour renvoyer la valeur arrondie d&apos;un attribut.

    En option, `round()` peut prendre un deuxième argument, `to_nearest`, pour arrondir le premier argument au multiple le plus proche du deuxième. `to_nearest` peut être fractionnaire.

    ```sql
    SELECT round(n [, to_nearest])
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="stddev"
    title={<InlineCode>stddev(attribute)</InlineCode>
    }
  >
    Utilisez la fonction `stddev()` pour renvoyer un [écart type](https://en.wikipedia.org/wiki/Standard_deviation) pour un attribut numérique sur la plage de temps spécifiée. Il faut un seul argument. Si l&apos;attribut n&apos;est pas numérique, il renverra une valeur de zéro.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-string"
    title={<InlineCode>string(attribute [, precision: ])</InlineCode>
    }
  >
    Utilisez la fonction `string()` pour convertir une valeur numérique, booléenne, uplet ou éventail en une valeur de chaîne.

    Il faut deux arguments, dont un facultatif :

    * Nom de l&apos;attribut
    * Précision : si présente, impose une limite au nombre de décimales incluses lors de la conversion de valeurs numériques à virgule flottante.

    <CollapserGroup>
      <Collapser title="Obtenir des résultats de requête non-chaîne sous forme de valeur de chaîne">
        Cette requête renvoie la durée de PageView sous forme de chaîne, avec deux décimales.

        ```sql
        FROM PageView SELECT string(duration, precision: 2)
        ```
      </Collapser>

      <Collapser title="Obtenir les résultats de la fonction d'agrégation non-chaîne sous forme de valeur de chaîne">
        Cette requête renvoie la durée moyenne de PageView sous forme de chaîne, avec deux décimales.

        ```sql
        FROM PageView SELECT string(average(duration), precision: 2)
        ```
      </Collapser>

      <Collapser title="Résultats de la requête à facettes par un nombre à virgule flottante sans troncature">
        Utilisez `string()` pour facetter par une valeur à virgule flottante sans perdre de décimales.

        ```sql
        FROM PageView SELECT count(*) 
        FACET string(tuple(asnLatitude, asnLongitude), precision: 2)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-substring"
    title={<InlineCode>substring(str, start [, length])</InlineCode>
    }
  >
    Utilisez la fonction `substring()` pour extraire une partie d&apos;une chaîne.

    Arguments:

    * `str` - la chaîne à partir de laquelle extraire une sous-chaîne.

      * Cela peut être tout ce qui est évalué comme une chaîne, y compris une chaîne littérale entre guillemets, un attribut de chaîne interrogé, une fonction qui renvoie une chaîne ou même une sous-requête qui renvoie une valeur de chaîne unique.
      * Si cet argument est évalué à null, la fonction `substring()` renverra null.

    * `start` - la position dans str à partir de laquelle commencer l&apos;extraction.

      * Le premier caractère de str est la position 0.
      * Une valeur négative trouvera la position par rapport à la fin de str, le dernier caractère de la chaîne étant la position -1.
      * Si start est supérieur ou égal à la longueur de str, la fonction `substring()` renverra une chaîne vide.
      * Si start est négatif et que sa valeur absolue est supérieure à la longueur de str, la sous-chaîne extraite commencera à la position 0.

    * `length` - la longueur, ou le nombre de caractères, de la sous-chaîne à extraire de str.

      * *Facultatif* - si la longueur n&apos;est pas fournie, tous les caractères de str après la position de départ résolue seront inclus.

      <CollapserGroup>
        <Collapser title="Extraire différentes parties d'une chaîne">
          Cette requête renvoie des parties de la valeur de session.

          ```sql
          FROM PageView
          SELECT session, substring(session, 0, 3) AS First3,
            substring(session, 3) AS After3rd,
            substring(session, -3) AS Last3
          ```

          <img title="screenshot substring()" alt="screenshot substring()" src="/images/substringExample.webp" />

          <figcaption>
            <InlineCode>
              substring(str, start \[, length])
            </InlineCode> exemple
          </figcaption>
        </Collapser>
      </CollapserGroup>

      *Voir la fonction [<InlineCode>
        position()
      </InlineCode>](#func-position) pour des exemples d’utilisation <InlineCode>
        substring()
      </InlineCode> et <InlineCode>
        position()
      </InlineCode> ensemble.*
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-toDatetime"
    title={<InlineCode>toDatetime(timestamp[, pattern [, timezone]])</InlineCode>
    }
  >
    Utilisez la fonction `toDatetime()` pour traduire un horodatage en une chaîne de date/heure formatée.

    `toDatetime()` prend les arguments suivants :

    * `timestamp` - Un horodatage numérique à traduire en une chaîne de date et d&apos;heure. Il peut s&apos;agir d&apos;une valeur numérique ou d&apos;un attribut, et sera converti en `long` en interne.
    * `pattern` - Un modèle de date/heure facultatif utilisé pour formater le résultat. Consultez la section *Modèles de formatage et d&apos;analyse* dans la [documentation DatetimeFormatter](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html) pour savoir comment construire une chaîne de modèle.
      * Il doit s&apos;agir d&apos;une valeur de chaîne constante et la valeur par défaut sera `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` si aucun modèle n&apos;est fourni.
    * `timezone` - Une valeur de fuseau horaire facultative utilisée pour interpréter la chaîne datetime (ex. UTC).
      * Il doit s&apos;agir d&apos;une valeur de chaîne constante et la valeur par défaut sera UTC ou la valeur fournie dans `WITH TIMEZONE` si disponible.

    Tant que l&apos;entrée est un nombre valide, la fonction `toDatetime()` renverra toujours une valeur.

    Alias : `fromTimestamp()` est un nom alternatif pour la fonction `toDatetime()` .

    Exemples :

    <CollapserGroup>
      <Collapser title="Traduire un horodatage en utilisant le modèle par défaut">
        La requête suivante traduit l&apos;attribut `timestampValue` en utilisant le modèle par défaut de `yyyy-MM-dd'T'HH:mm:ss.SSSXXX`. Cela renverra la chaîne datetime `1970-01-01T00:20:34.567Z`.

        ```sql
        WITH 1234567 AS timestampValue SELECT toDatetime(timestampValue)
        ```
      </Collapser>

      <Collapser title="Traduire un horodatage à l'aide du paramètre de fuseau horaire">
        La requête suivante traduit l&apos;attribut `timestampValue` à l&apos;aide de la chaîne de modèle `yyyy-MM-dd` avec le fuseau horaire défini sur « America/Los\_Angeles ». Cela renverra la chaîne datetime `1969-12-31`.

        ```sql
        WITH 1234567 AS timestampValue SELECT toDatetime(timestampValue, 'yyyy-MM-dd', timezone:'America/Los_Angeles')
        ```
      </Collapser>

      <Collapser
        title={<>Traduire un horodatage en utilisant le fuseau horaire dans la clause <InlineCode>
          WITH TIMEZONE
        </InlineCode></>
        }
      >
        La requête suivante traduit l&apos;attribut `timestampValue` en utilisant le fuseau horaire fourni dans la clause `WITH TIMEZONE` . Cela renverra la chaîne datetime `1969-12-31`.

        ```sql
        WITH 1234567 AS timestampValue SELECT toDatetime(timestampValue, 'yyyy-MM-dd') FROM Event WITH TIMEZONE 'America/Los_Angeles'
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-toTimestamp"
    title={<InlineCode>toTimestamp(datestring[, pattern [, timezone]])</InlineCode>
    }
  >
    Utilisez la fonction `toTimestamp()` pour analyser un horodatage en millisecondes d&apos;époque à partir d&apos;une chaîne datetime.

    `toTimestamp()` prend les arguments suivants :

    * `datestring` - Une chaîne de date et d&apos;heure à traduire en un horodatage (millisecondes d&apos;époque). Il peut s&apos;agir d&apos;un attribut de chaîne ou d&apos;une chaîne littérale entre guillemets.
    * `pattern` - Un modèle de date/heure facultatif utilisé pour analyser le paramètre de chaîne de date. Consultez la section *Modèles de formatage et d&apos;analyse* dans la [documentation DatetimeFormatter](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html) pour savoir comment construire une chaîne de modèle.
      * Il doit s&apos;agir d&apos;une valeur de chaîne constante et la valeur par défaut sera `yyyy-MM-dd'T'HH:mm:ss[.SSS][XXX]` si aucun modèle n&apos;est fourni.
    * `timezone` - Une valeur de fuseau horaire facultative utilisée pour interpréter le paramètre de chaîne de date (ex. TVP).
      * Il doit s&apos;agir d&apos;une valeur de chaîne constante et la valeur par défaut sera UTC ou la valeur fournie dans `WITH TIMEZONE` si disponible.

    Alias : `fromDatetime()` est un nom alternatif pour la fonction `toTimestamp()` .

    <Callout variant="tip">
      Si la chaîne trouvée ne correspond pas au modèle donné, elle renverra `null`. Si vous avez des chaînes de date/heure dans une variété de modèles, vous pouvez fusionner les résultats en utilisant `OR` pour les mettre en cascade jusqu&apos;à ce que l&apos;une des valeurs soit non nulle. Vous pouvez également utiliser des segments de motif facultatifs. Le modèle par défaut utilise des crochets pour rendre les millisecondes et les parties de décalage de zone facultatives.
    </Callout>

    <CollapserGroup>
      <Collapser id="partial-datetime-interpretation" title="Interprétation partielle de la date et de l'heure lors de l'analyse des chaînes de date et d'heure">
        <table>
          <thead>
            <tr>
              <th>
                Scénario
              </th>

              <th>
                Détail
              </th>

              <th>
                Modèle d&apos;échantillon
              </th>

              <th>
                Exemple de date et d&apos;heure
              </th>

              <th>
                Décide de
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                Fuseau horaire manquant
              </td>

              <td>
                Utilisera l&apos;argument de fuseau horaire ou la valeur `WITH TIMEZONE` . La valeur par défaut est `UTC`.
              </td>

              <td>
                aaaa-MM-jj HH:mm:ss.SSS
              </td>

              <td>
                18/10/2023 15:27:03.123
              </td>

              <td>
                18/10/2023 à 15:27:03.123Z
              </td>
            </tr>

            <tr>
              <td rowspan="8">
                Champ datetime manquant
              </td>

              <td rowspan="8">
                Tout champ d&apos;heure manquant sera remplacé par 0. Tout champ de date manquant sera remplacé par 1. Si un champ est présent, tous les champs de priorité supérieure doivent également être présents.<br /> Remarque : les modèles de jour de l’année et de trimestre de l’année sont pris en charge.
              </td>

              <td>
                aaaa-MM-jj HH:mm:ss
              </td>

              <td>
                18/10/2023 15:27:03
              </td>

              <td>
                18/10/2023 à 15:27:03.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-jj HH:mm
              </td>

              <td>
                18/10/2023 15:27
              </td>

              <td>
                18/10/2023 à 15:27:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-jj HH
              </td>

              <td>
                18/10/2023 15
              </td>

              <td>
                18/10/2023 à 15:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-jj
              </td>

              <td>
                18/10/2023
              </td>

              <td>
                18/10/2023 à 00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                yyyy &apos;jour&apos; D
              </td>

              <td>
                2023 jour 291
              </td>

              <td>
                18/10/2023 à 00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM
              </td>

              <td>
                2023-10
              </td>

              <td>
                01/10/2023 à 00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa qqq
              </td>

              <td>
                4e trimestre 2023
              </td>

              <td>
                01/10/2023 à 00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                yyyy
              </td>

              <td>
                2023
              </td>

              <td>
                01/01/2023 à 00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td rowspan="3">
                Temps seulement
              </td>

              <td rowspan="3">
                Si un modèle horaire est utilisé sans date, l&apos;horodatage Unix en millisecondes sera calculé.<br /> Remarque : le réglage du fuseau horaire est toujours respecté.
              </td>

              <td>
                HH:mm
              </td>

              <td>
                00:30
              </td>

              <td>
                1971-01-01T00:30:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                HH:mm O
              </td>

              <td>
                00:30 GMT-1
              </td>

              <td>
                1971-01-01T01:30:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                HH:mm O
              </td>

              <td>
                00h30 GMT+1
              </td>

              <td>
                1969-12-31T23:30:00.000Z
              </td>
            </tr>

            <tr>
              <td rowspan="3">
                12 heures
              </td>

              <td rowspan="3">
                Si un modèle de 12 heures (h minuscule) est utilisé, le modèle am-pm-of-day (a) doit également être utilisé.<br /> Remarque : dans la chaîne datetime, AM/PM doit être en majuscules.
              </td>

              <td>
                aaaa-MM-jj h:mm a
              </td>

              <td>
                18/10/2023 15:27
              </td>

              <td>
                18/10/2023 à 15:27:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-jj h:mm
              </td>

              <td>
                18/10/2023 15:27
              </td>

              <td>
                Modèle non pris en charge
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-jj h:mm a
              </td>

              <td>
                18/10/2023 15:27
              </td>

              <td>
                null (en raison de la minuscule pm)
              </td>
            </tr>

            <tr>
              <td>
                Priorité des champs
              </td>

              <td>
                Si un champ est présent, tous les champs de priorité supérieure doivent également être présents.
              </td>

              <td>
                aaaa jj
              </td>

              <td>
                2023 18
              </td>

              <td>
                Modèle non pris en charge (dd est le jour du mois et le mois est manquant)
              </td>
            </tr>
          </tbody>
        </table>
      </Collapser>
    </CollapserGroup>

    Exemples :

    <CollapserGroup>
      <Collapser title="Analyser une chaîne de date et d'heure à l'aide du modèle par défaut">
        La requête suivante analyse la chaîne datetime &apos;2023-10-18T15:27:03.123Z&apos; en utilisant le modèle par défaut de `yyyy-MM-dd'T'HH:mm:ss[.SSS][XXX]`. Cela renvoie la valeur d&apos;horodatage `1697642823123`.

        ```sql
        SELECT toTimestamp('2023-10-18T15:27:03.123Z') 
        FROM Event
        ```
      </Collapser>

      <Collapser title="Analyser une chaîne de date et d'heure à l'aide du paramètre timezone">
        La requête suivante analyse la chaîne datetime « 2023-11-03 11:00:32 » avec le fuseau horaire défini sur « America/Los\_Angeles ». Cela renvoie la valeur d&apos;horodatage `1699034432000`.

        ```sql
        SELECT toTimestamp('2023-11-03 11:00:32', 'yyyy-MM-dd HH:mm:ss', timezone:'America/Los_Angeles') 
        FROM Event
        ```
      </Collapser>

      <Collapser
        title={<>Analyser une chaîne de date et d'heure à l'aide du fuseau horaire dans la clause <InlineCode>
          WITH TIMEZONE
        </InlineCode></>
        }
      >
        La requête suivante analyse la chaîne datetime « 2023-11-03 11:00:32 » avec le fuseau horaire fourni dans la clause `WITH TIMEZONE` . Cela renvoie la valeur d&apos;horodatage `1699034432000`.

        ```sql
        SELECT toTimestamp('2023-11-03 11:00:32', 'yyyy-MM-dd HH:mm:ss') 
        FROM Event WITH TIMEZONE 'America/Los_Angeles'
        ```
      </Collapser>
    </CollapserGroup>

    <Callout variant="important">
      L&apos;UI détectera automatiquement la valeur `toTimestamp()` comme un horaire et la formatera comme une valeur de date/heure. Pour afficher l&apos;horodatage numérique réel, encapsulez la fonction `toTimestamp()` dans une fonction `string()` .
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-upper"
    title={<InlineCode>upper(str)</InlineCode>
    }
  >
    Utilisez la fonction `upper()` pour changer tous les caractères alphabétiques d’une valeur de chaîne en majuscules.

    Arguments:

    * `str` - La valeur de la chaîne doit être en majuscules

    * Cela peut être tout ce qui est évalué comme une chaîne, y compris une chaîne littérale entre guillemets, un attribut de chaîne interrogé, une fonction qui renvoie une chaîne ou même une sous-requête qui renvoie une valeur de chaîne unique.

    * Si cet argument est évalué à null, la fonction `upper()` renverra null.

      <CollapserGroup>
        <Collapser title="Mettre une chaîne en majuscules">
          Cette requête illustre l&apos;utilisation de la fonction `upper()` dans différentes parties d&apos;une requête.

          ```sql
          FROM PageAction
          SELECT latest(upper(actionName))
          WHERE upper(actionName) = upper('acmePageRenderedEvent') OR upper(actionName) = upper('SubmitLogin')
          FACET concat(actionName, ':', upper(actionName))
          ```

          <img title="screenshot upper()" alt="screenshot upper()" src="/images/upperExample.webp" />

          <figcaption>
            <InlineCode>
              upper(str)
            </InlineCode> exemple
          </figcaption>
        </Collapser>
      </CollapserGroup>

      *Fonction associée : [<InlineCode>
        lower()
      </InlineCode>](#func-lower)*
  </Collapser>
</CollapserGroup>

## Conversion de type [#type-conversion]

NRQL ne prend pas en charge la « coercition ». Cela signifie qu&apos;un float stocké sous forme de chaîne est traité comme une chaîne et ne peut pas être exploité par des fonctions attendant des valeurs float.

Vous pouvez convertir une chaîne avec une valeur numérique ou un booléen avec une valeur de chaîne en leurs équivalents numériques et booléens, ou convertir une valeur non-chaîne en une valeur de chaîne, avec ces fonctions :

* Utilisez la fonction `numeric()` pour convertir un nombre au format chaîne en une valeur numérique. La fonction peut être intégrée dans une requête qui utilise des fonctions mathématiques sur les résultats de la requête ou des fonctions d&apos;agrégation NRQL , telles que `average()`. Veuillez noter que si la valeur NRQL est au [format de jauge](/docs/data-apis/understand-data/metric-data/metric-data-type/), alors `numeric()` ne fonctionnera pas dessus. Au lieu de cela, vous devez utiliser l’une de ces fonctions de requête compatibles :
* `latest()`
* `min()`
* `max()`
* `sum()`
* `count()`
* `average()`
* Utilisez la fonction `boolean()` pour convertir une valeur de chaîne de `"true"` ou `"false"` en valeur booléenne correspondante.
* Utilisez la fonction `string()` pour convertir une valeur numérique, booléenne, uplet ou éventail en une valeur de chaîne. Voir [`string()`](#func-string) ci-dessus pour plus d&apos;informations.

## Commentaires [#comments]

Lorsque vous écrivez une requête NRQL, vous pouvez ajouter des commentaires, ce qui peut aider les membres de votre équipe à mieux comprendre et utiliser la requête.

Voici les détails de la syntaxe :

* `--` Deux tirets placeront en commentaire tout le texte à droite de cet indicateur sur la même ligne.
* `//` Deux barres obliques placeront en commentaire tout le texte à droite de cet indicateur sur la même ligne.
* `/* */` Tout texte compris entre ces jeux de caractères sera placé en commentaire. Cet indicateur peut s&apos;appliquer à plusieurs lignes.

Notez que les commentaires ne sont pas affichés partout. Certaines vues, comme « requête récente » et « requête de vue », n&apos;afficheront pas de commentaires.

Quelques exemples de requêtes incluant des commentaires :

```sql
FROM Transaction SELECT uniqueCount(appId) -- This will return the number of unique App IDs
```

```sql
FROM TransactionError
SELECT count(*) SINCE 1 day ago // Transaction Error for the past day
```

```sql
FROM TransactionTrace /* This data may be incomplete;
If so, run a query of Transaction */
SELECT count(*)
```

## Documents associés [#related-docs]

D&apos;autres ressources populaires pour comprendre la syntaxe et les règles NRQL incluent :

* [Cours d&apos;instruction NRQL](https://learn.newrelic.com/writing-nrql-queries) de New Relic University
* [Découvrez comment interroger le type de données `Metric`](/docs/telemetry-data-platform/get-data/apis/query-metric-data-type)
* [Utiliser des sous-requêtes](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql)
* [Utiliser des entonnoirs pour évaluer une série de données connexes](/docs/insights/new-relic-insights/features/funnels)