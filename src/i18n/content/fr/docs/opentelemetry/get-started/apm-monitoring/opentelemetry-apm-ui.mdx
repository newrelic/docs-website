---
title: Interface utilisateur OpenTelemetry APM
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: The OpenTelemetry APM UI provides tools for identifying and diagnosing problems with services monitoring with OpenTelemetry.
freshnessValidatedDate: '2024-05-17T00:00:00.000Z'
translationType: machine
---

L&apos;interface utilisateur OpenTelemetry APM offre une expérience monitoring complète pour les services instrumentés avec OpenTelemetry, offrant les mêmes puissantes capacités APM que vous attendez des agents de langage traditionnels de New Relic.

## Prérequis

Avant d&apos;utiliser l&apos;interface utilisateur OpenTelemetry APM, assurez-vous d&apos;avoir :

* Configurez votre service avec l&apos;instrumentation OpenTelemetry
* Configurez votre service pour envoyer des données à New Relic
* [Entité de serviceOpenTelemetry ](/docs/opentelemetry/best-practices/opentelemetry-best-practices-resources/#services)créée

Si vous n’avez pas effectué ces étapes, consultez [le monitoring OpenTelemetry APM](/docs/opentelemetry/get-started/apm-monitoring/opentelemetry-apm-intro/) pour obtenir des instructions de configuration.

## Trouvez vos services OpenTelemetry [#find-apm-services]

Pour localiser vos services instrumentés OpenTelemetry :

1. Dans l&apos;interface utilisateur de New Relic, accédez à **All entities &gt; Services - OpenTelemetry** ou **APM &amp; Services**
2. Sélectionnez un service pour ouvrir sa [page Summary](#summary-page)

<Callout variant="tip">
  Utilisez [la balise entité](/docs/new-relic-solutions/new-relic-one/core-concepts/use-tags-help-organize-find-your-data/) dans l’explorateur d’entités pour filtrer les services. Apprenez-en plus sur la façon dont les balises d&apos;entité sont calculées dans [les ressources OpenTelemetry dans New Relic](/docs/opentelemetry/best-practices/opentelemetry-best-practices-resources).
</Callout>

## Comment OpenTelemetry fonctionne avec New Relic APM

Les services instrumentés par OpenTelemetryoffrent la même expérience APM organisée que les services utilisant les agents de langage de New Relic. Voici comment cela fonctionne :

### Processus de modélisation des données

New Relic mappe automatiquement vos données OpenTelemetry à nos conventions APM en :

1. **Génération de métriques APM**: Nous créons les métriques nécessaires à l&apos;expérience APM directement à partir de vos données OpenTelemetry
2. **Préservation des données originales**: Vos données OpenTelemetry originales restent disponibles pour la personnalisation du tableau de bord et les alertes
3. **Conventions de normalisation**: nous gérons les conventions sémantiques évolutives d&apos;OpenTelemetry afin que vous n&apos;ayez pas à suivre les différences de version

### Avantages pour les utilisateurs New Relic existants

Si vous passez des agents New Relic à OpenTelemetry, vous pouvez continuer à utiliser des métriques et des requêtes familières tout en adoptant les normes OpenTelemetry.

<Callout variant="important">
  **Pourquoi nous normalisons les données OpenTelemetry**

  Les conventions sémantiques d&apos;OpenTelemetry sont encore en évolution, et beaucoup ne sont pas encore stables. En normalisant vos données selon les conventions New Relic, nous :

  * Réduisez la complexité du suivi des versions de convention OpenTelemetry utilisées par votre instrumentation
  * Offrez une expérience cohérente lors de votre transition des agents New Relic vers OpenTelemetry
  * Assurez-vous que votre expérience APM reste stable quelles que soient les modifications d&apos;OpenTelemetry
</Callout>

### Sources de données et priorisation

L&apos;expérience APM utilise trois types de données OpenTelemetry :

* **Métriques** (primaires) : fournit des statistiques de service précises telles que le débit, le temps de réponse et le taux d&apos;erreur
* **Spans** (supplémentaires) : utilisées lorsque les métriques ne sont pas disponibles ou pour des fonctionnalités spécifiques comme le suivi des transactions
* **Logs**: Intégré pour le dépannage et la corrélation

**Pourquoi les métriques sont préférées**: les métriques donnent une image complète des performances de votre service, tandis que les étendues sont généralement échantillonnées et peuvent ne pas représenter tout le trafic.

L&apos;expérience APM s&apos;appuie principalement sur ces conventions sémantiques OpenTelemetry :

* [HTTP](https://opentelemetry.io/docs/specs/semconv/http/) - transaction Web et appels externes
* [RPC](https://opentelemetry.io/docs/specs/semconv/rpc/) - Appels de procédure à distance
* [Messagerie](https://opentelemetry.io/docs/specs/semconv/messaging/) - fichier d&apos;attente des messages opérations
* [base de données](https://opentelemetry.io/docs/specs/semconv/database/) - base de données opérations

### Comment les transactions sont dérivées des données OpenTelemetry [#transaction-mapping]

L&apos;expérience APM de New Relic est centrée sur la notion de [transaction](https://docs.newrelic.com/docs/apm/transactions/intro-transactions/transactions-new-relic-apm/). Lors de l&apos;utilisation d&apos;un agent New Relic, il incombe à l&apos;instrumentation de l&apos;agent de définir la portée d&apos;une transaction (par exemple, une seule requête Web). L&apos;agent produit des données métriques qui pilotent la grande majorité de l&apos;expérience New Relic APM en enregistrant les métriques de transaction mesurant la durée des transactions et ses opérations individuelles (par exemple, les appels externes et les appels de base de données).

L&apos;instrumentation OpenTelemetry n&apos;a pas d&apos;analogue direct à une transaction New Relic, il est donc essentiel d&apos;adapter la notion de transactions aux données OpenTelemetry.

En exploitant [les conventions sémantiques](https://opentelemetry.io/docs/concepts/semantic-conventions/) d&apos;OpenTelemetry, nous pouvons tirer parti des moyens hautement structurés et standardisés d&apos;OpenTelemetry pour décrire la télémétrie afin de piloter l&apos;expérience APM d&apos;une manière très similaire à celle des agents de New Relic.

Les conventions sémantiques définissent des métriques standard pour mesurer des opérations courantes telles que la gestion requests [HTTP](https://opentelemetry.io/docs/specs/semconv/http/http-metrics/) ou [RPC](https://opentelemetry.io/docs/specs/semconv/rpc/rpc-metrics/). Ces métriques sont analogues aux métriques de transaction que les agents New Relic produisent pour décrire [le Web de transaction](https://docs.newrelic.com/docs/apm/transactions/intro-transactions/transactions-new-relic-apm/#types). Nous exploitons les métriques HTTP et RPC d&apos;OpenTelemetry pour synthétiser les métriques qui pilotent l&apos;interface utilisateur APM telles que la [métrique`apm.service.transaction.duration` ](#metric-apm-service-transaction-duration).

New Relic fournit également une notion de [transaction non Web](https://docs.newrelic.com/docs/apm/transactions/intro-transactions/monitor-background-processes-other-non-web-transactions/). Les transactions non Web sont couramment utilisées pour les systèmes qui effectuent le traitement des messages. L&apos;instrumentation qui exploite [les conventions de messagerie](https://github.com/open-telemetry/semantic-conventions/blob/main/docs/messaging/messaging-spans.md) d&apos; OpenTelemetrypermettra de synthétiser des métriques représentant des transactions non Web.

<Callout variant="important">
  **Opérations de messagerie et données étendues**

  Les conventions de messagerie d&apos;OpenTelemetry sont moins matures que les conventions HTTP et RPC. Actuellement, nous générons des métriques de transaction non Web pour les opérations de messagerie à partir de données span plutôt que de données métriques. Cette approche suit les conventions sémantiques de messagerie mais peut être affectée par votre stratégie d’échantillonnage.
</Callout>

#### Noms des transactions

Chaque transaction a un nom dérivé de l&apos;attribut requis par les conventions sémantiques d&apos; OpenTelemetry. Reportez-vous à la section [Métriques du service APM](#apm-service-metrics) pour savoir comment ce nom est dérivé.

##### Nom de transaction inconnu

Parfois, vous pouvez voir une transaction avec `unknown` dans le nom. Ceci indique que les données sources utilisées pour dériver la transaction ne suivent aucune des conventions sémantiques OpenTelemetry établies que nous prenons actuellement en charge.

Quelques exemples :

* Métriques HTTP manquantes : `http.request.method` ou `http.route`. Par exemple, si la métrique `http.server.request.duration` ne possède pas l&apos;attribut `http.route`, le nom de la transaction sera `WebTransaction/server/GET unknown`.
* Frameworks ou protocoles pour lesquels OpenTelemetry ne définit pas actuellement de conventions sémantiques (par exemple, les tâches d&apos;arrière-plan et le cadre CI).

## Naviguer dans l&apos;expérience APM

### Résumé [#summary-page]

La [page Summary](/docs/apm/agents/manage-apm-agents/agent-data/triage-run-diagnostics/) fournit un aperçu de l&apos;état de votre service et est centrée sur la notion de [transaction](/docs/apm/transactions/intro-transactions/transactions-new-relic-apm/) de New Relic. Consultez [Comment les transactions sont dérivées des données OpenTelemetry](#transaction-mapping) pour plus de détails.

Les métriques New Relic qui pilotent la page Summary sont les métriques [`apm.service.transaction.duration`](#metric-apmservicetransactionduration) et [`apm.service.error.count`](#metric-apmservicetransactionduration). Consultez-les pour plus de détails sur la manière dont ils sont dérivés de vos données OpenTelemetry.

#### Personnalisation de la cible Apdex [#customizing-apdex-target]

Dans l&apos;instrumentation New Relic, les cibles apdex personnalisées sont configurées à l&apos;aide de configuration de l&apos;agent. Pour OpenTelemetry, lorsque vous visualisez un service, accédez à **Settings &gt; Application** pour configurer votre cible Apdex.

### Tracing distribué [#distributed-tracing-page]

La page de tracing distribué fournit des informations détaillées sur les OpenTelemetry trace données . Voir [le tracing distribué](/docs/distributed-tracing/ui-data/understand-use-distributed-tracing-ui/) pour les informations sur l&apos;utilisation des pages. Consultez [OpenTelemetry la trace dans New Relic](/docs/opentelemetry/best-practices/opentelemetry-best-practices-traces) pour plus de détails sur la manière dont OpenTelemetry trace les données sont ingérées dans New Relic.

Comme pour [les signaux dorés](#golden-signals), les intervalles sont classés comme des erreurs si l&apos;état de l&apos;intervalle est défini sur `ERROR` (par exemple, `otel.status_code = ERROR`). Si l&apos;étendue est une erreur, la description de l&apos;état de l&apos;étendue (par exemple, `otel.status_description`) s&apos;affiche dans **error details**.

OpenTelemetry span événement attache des informations de contexte d&apos;événement supplémentaires à un span particulier. Ils sont le plus souvent utilisés pour capturer des informations sur les exceptions. Si disponible, vous pouvez afficher l&apos;événement d&apos;un span dans **les détails de trace**.

<Callout variant="tip">
  La présence d&apos;un événement d&apos;exception d&apos;étendue ne qualifie pas l&apos;étendue comme une erreur à elle seule. Seules les étendues dont le statut d&apos;étendue est défini sur `ERROR` sont classées comme des erreurs.
</Callout>

<img title="Screenshot showing the right pane showing the two links for span events" alt="Screenshot showing the right pane showing the two links for span events" src="/images/opentelemetry_screenshot-crop_view-span-events.webp" />

### Cartographie des services [#service-map-page]

La page de cartographie des services fournit une représentation visuelle de l’ensemble de votre architecture. Consultez [les cartes de service](/docs/new-relic-solutions/new-relic-one/ui-data/service-maps/service-maps/) pour plus d&apos;informations.

### Transactions [#transactions-page]

La [page des transactions](/docs/apm/apm-ui-pages/monitoring/transactions-page-find-specific-performance-problems/) fournit des outils permettant d&apos;identifier les problèmes et d&apos;analyser [les transactions](/docs/apm/transactions/intro-transactions/transactions-new-relic-apm/#txn-defined) d&apos;un service.

OpenTelemetry n&apos;a pas d&apos;analogue direct à la notion de transaction de New Relic. Consultez [Comment les transactions sont dérivées des données OpenTelemetry](#transaction-mapping) pour plus de détails.

Les métriques New Relic qui pilotent la page Transaction sont les métriques [`apm.service.transaction.duration`](#metric-apmservicetransactionduration) et [`apm.service.error.count`](#metric-apmservicetransactionduration). Consultez-les pour plus de détails sur la manière dont ils sont dérivés de vos données OpenTelemetry.

#### Trace de transaction

[les traces de transaction](/docs/apm/transactions/transaction-traces/introduction-transaction-traces/) pour OpenTelemetry sont dérivées de vos données span. Sur la page des transactions, vous pouvez trouver une liste des traces de transaction. Cette liste nécessite que les données d&apos;étendue et les données métriques pour une transaction donnée soient corrélées ensemble. Nous le faisons en ajoutant un attribut `transaction.name` à la portée racine d’une trace de transaction.

#### Répartition des segments [#segment-breakdown]

Cliquer sur une transaction ouvre une vue détaillée de la transaction révélant une répartition des segments. Contrairement aux agents New Relic, OpenTelemetry n&apos;émet pas de métriques pour des segments individuels. Par conséquent, les métriques New Relic requises pour piloter la répartition des segments sont dérivées des données d&apos;étendue.

L’inconvénient majeur du calcul de la répartition des segments à partir des données de portée est que les portées sont généralement échantillonnées. Cependant, même avec l&apos;échantillonnage, la répartition des segments peut toujours vous aider à identifier les méthodes ou opérations spécifiques qui consomment le plus de temps au sein d&apos;une transaction.

À partir des données d&apos;étendue, nous estimons un taux d&apos;échantillonnage en calculant un débit basé sur les données d&apos;étendue reçues et en le divisant par le débit réel tel que rapporté par vos données métriques. Le taux d’échantillonnage estimé nous permet d’extrapoler la répartition des segments d’une transaction.

Ce processus n’est pas parfait et peut être affecté par un certain nombre de facteurs, notamment votre stratégie d’échantillonnage. Cela fonctionne mieux lorsque vous échantillonnez strictement un pourcentage de vos données de portée. Toutefois, par exemple, si vous échantillonnez uniquement les intervalles représentant des erreurs, la répartition des segments peut être biaisée.

### base de données [#databases-page]

La page base de données fournit des outils permettant d&apos;identifier les problèmes et d&apos;analyser les opérations client de base de données d&apos;un service.

L&apos;instrumentation OpenTelemetry représente les appels à la base de données en utilisant les conventions sémantiques [de la base de données](https://opentelemetry.io/docs/specs/semconv/database/).

La métrique New Relic qui pilote la page de base de données est la métrique [`apm.service.datastore.operation.duration`](#metric-apmservicedatastoreoperationduration). Consultez-le pour plus de détails sur la manière dont il est dérivé de vos données OpenTelemetry.

#### Consommation de temps par appelant

Lorsque vous cliquez sur un appel de base de données spécifique, vous verrez le graphique « Consommation de temps par appelant ». Ce graphique est piloté par la métrique [`apm.service.transaction.overview`](#metric-apmservicetransactionoverview). Il s’agit de la même métrique qui pilote la vue [de répartition des segments](#segment-breakdown) de la page de transaction et elle est dérivée des données d’étendue.

<Callout variant="important">
  Les conventions sémantiques de la base de données d&apos;OpenTelemetry ont récemment été jugées stables. Il n&apos;existe pas encore beaucoup d&apos;instrumentations stables, et l&apos;instrumentation qui existe n&apos;émet souvent que des données d&apos;envergure et aucune donnée métrique.

  Ainsi, lors de l&apos;utilisation d&apos;une instrumentation qui n&apos;a pas encore adopté les conventions sémantiques stables, les métriques APM générées pilotant la page de base de données sont dérivées des données span.

  Au fur et à mesure que l&apos;instrumentation stable devient disponible et que vous l&apos;adoptez, la page de base de données commencera à exploiter les données métriques OpenTelemetry. Contactez la communauté OpenTelemetry concernant la disponibilité d&apos;une instrumentation de base de données stable dans votre langue.
</Callout>

### Services externes [#externals-page]

La [page des services externes](/docs/apm/apm-ui-pages/monitoring/external-services/external-services-ui/) fournit des outils permettant d&apos;identifier les problèmes et d&apos;analyser les appels externes d&apos;un service, notamment l&apos;entité appelante (services en amont) et l&apos;entité appelée (services en aval).

L&apos;instrumentation OpenTelemetry représente les appels vers des services externes à l&apos;aide des conventions sémantiques [HTTP](https://opentelemetry.io/docs/specs/semconv/http/) et [RPC](https://opentelemetry.io/docs/specs/semconv/rpc/).

La métrique New Relic qui pilote la page de base de données est la métrique [`apm.service.external.host.duration`](#metric-apmserviceexternalhostduration). Consultez-le pour plus de détails sur la manière dont il est dérivé de vos données OpenTelemetry.

#### Consommation de temps par appelant

Lorsque vous cliquez sur un appel externe spécifique, vous verrez le graphique « Consommation de temps par appelant ». Ce graphique est piloté par la métrique [`apm.service.transaction.overview`](#metric-apm-service-transaction-overview). Il s’agit de la même métrique qui pilote la vue [de répartition des segments](#segment-breakdown) de la page de transaction et elle est dérivée des données d’étendue.

### Environnement d&apos;exécution JVM [#jvm-runtime-page]

La page d&apos;exécution JVM fournit des outils permettant d&apos;identifier les problèmes et d&apos;analyser la JVM d&apos;un service Java. La page s&apos;affiche uniquement pour les services utilisant [OpenTelemetry Java](https://opentelemetry.io/docs/languages/java/). Afin de différencier les différentes instances de service, la page nécessite que l&apos;attribut de ressource `service.instance.id` soit défini (voir [Services](/docs/opentelemetry/best-practices/opentelemetry-best-practices-resources/#services) pour plus de détails).

La page d&apos;exécution JVM affiche les signaux dorés ainsi que les mesures d&apos;exécution JVM pour corréler les problèmes d&apos;exécution avec l&apos;utilisation du service.

La requête suppose que les données sont conformes aux conventions sémantiques [métriquesJVM ](https://opentelemetry.io/docs/specs/semconv/runtime/jvm-metrics/). Notez que ces conventions sont intégrées dans [la bibliothèque d&apos;instrumentation d&apos;exécution Java OpenTelemetry](https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/instrumentation/runtime-telemetry/runtime-telemetry-java8/library), qui est automatiquement incluse avec l&apos;agent Java OpenTelemetry.

### Exécution Go [#go-runtime-page]

La page d&apos;exécution Go fournit des outils permettant d&apos;identifier les problèmes et d&apos;analyser l&apos;exécution d&apos;un service Go. La page s&apos;affiche uniquement pour les services utilisant [OpenTelemetry Go](https://opentelemetry.io/docs/languages/go/). Afin de différencier les différentes instances de service, la page nécessite que l&apos;attribut de ressource `service.instance.id` soit défini (voir [Services](/docs/opentelemetry/best-practices/opentelemetry-best-practices-resources/#services) pour plus de détails).

La page d&apos;exécution Go affiche les signaux dorés ainsi que les métriques d&apos;exécution Go pour corréler les problèmes d&apos;exécution avec l&apos;utilisation du service.

La requête suppose que les données sont produites par la [bibliothèque d&apos;instrumentation d&apos;exécutionOpenTelemetry Go](https://opentelemetry.io/docs/specs/semconv/runtime/go-metrics/). Notez qu’il n’existe actuellement aucune convention sémantique pour les métriques d’exécution Go.

### Logs [#logs-page]

La page des logs fournit des outils permettant d&apos;identifier les problèmes et d&apos;analyser les logs d&apos;un service. Voir [Utiliser l&apos;interface utilisateur des logs](/docs/logs/ui-data/use-logs-ui/) pour plus d&apos;informations.

### Errors Inbox [#errors-inbox-page]

La page Boîte de réception des erreurs fournit des outils permettant de détecter et de trier les erreurs d&apos;un service. Pour plus de détails, consultez [Prise en main de la boîte de réception des erreurs](/docs/errors-inbox/getting-started/) .

La page Boîte de réception des erreurs est pilotée par des données trace. Comme pour [les signaux dorés](#golden-signals), les intervalles sont classés comme des erreurs si l&apos;état de l&apos;intervalle est défini sur `ERROR` (par exemple, `otel.status_code = ERROR`).

Les plages d&apos;erreur sont regroupées par leur empreinte d&apos;erreur, calculée en normalisant les valeurs d&apos;identification telles que les UUID, les valeurs hexadécimales, les adresses e-mail, etc. Chaque plage d’erreur distincte est une instance individuelle au sein du groupe d’erreurs. Le message du groupe d&apos;erreur est déterminé comme suit :

* Description de l&apos;état de l&apos;étendue (par exemple, `otel.status_description`)
* `rpc.grpc.status_code` à partir des conventions sémantiques [RPC span](https://opentelemetry.io/docs/specs/semconv/rpc/rpc-spans/)
* `http.status_code` à partir des conventions sémantiques [HTTP span](https://opentelemetry.io/docs/specs/semconv/http/http-spans/)
* `http.response.status_code` à partir des conventions sémantiques [HTTP span](https://opentelemetry.io/docs/specs/semconv/http/http-spans/)
* `undefined` si aucun des éléments ci-dessus n&apos;est présent

### Vue Span (héritage) [#span-view-legacy]

Dans le passé, les services instrumentés OpenTelemetry offraient une expérience utilisateur entièrement différente de celle des agents de langage de New Relic. Cette expérience plus ancienne a fourni des graphiques organisés à partir de données de portée. Les données Span sont généralement échantillonnées, elles peuvent donc être trompeuses, en particulier lorsqu&apos;elles représentent des éléments tels que le débit.

Pour l&apos;instant, l&apos;ancienne expérience utilisateur est toujours disponible via la page Span View (héritée). En haut, il contient quatre onglets : Résumé, Transactions, base de données et Services externes. Tous les graphiques de ces onglets sont générés à partir de données de portée.

<Callout variant="tip">
  **Vue héritée basée sur l&apos;étendue**

  Notre ancienne expérience OpenTelemetry APM permettait de visualiser les données à la fois sous l&apos;angle métrique et sous l&apos;angle de l&apos;étendue. Étant donné que les données de portée sont généralement échantillonnées, les métriques fournissent des mesures de débit et de temps de réponse plus précises. La vue basée sur l&apos;étendue est toujours disponible mais sera progressivement supprimée. Voir [Span View (Legacy)](#span-view-legacy) pour plus de détails.
</Callout>

## Métriques New Relic APM dérivées des données span [#apm-metrics-from-span-data]

Les métriques New Relic APM qui pilotent l&apos;expérience APM sont généralement dérivées de données métriques. Cependant, il existe quelques scénarios dans lesquels les métriques APM sont dérivées des données d&apos;étendue. Pour les scénarios suivants, notez que la stratégie d&apos;échantillonnage que vous utilisez influencera les métriques générées.

### Répartition des segments

La vue de répartition des segments de transaction est pilotée à partir des données de portée. Voir [la répartition des segments](#segment-breakdown) pour plus d&apos;informations.

### Appels de base de données

Les [conventions sémantiques de la base de données OpenTelemetry](https://opentelemetry.io/docs/specs/semconv/database/) ont récemment été déclarées stables. Cependant, la plupart des instruments de base de données n&apos;ont pas encore adopté les conventions stables et ne fournissent pas encore de données métriques. Par conséquent, lors de l&apos;utilisation d&apos;instruments plus anciens, les métriques qui pilotent la [page de base de données](#databases-page) sont générées à partir des données d&apos;étendue. Nous vous encourageons à effectuer une mise à niveau vers la dernière instrumentation de base de données stable dès qu&apos;elle sera disponible pour votre langue.

### Système de messagerie

Les [conventions sémantiques de messagerie OpenTelemetry](https://opentelemetry.io/docs/specs/semconv/messaging/) sont encore en développement. La plupart des instruments de messagerie n&apos;émettent pas encore de données métriques. New Relic représente les interactions avec le système de messagerie en tant que transaction non Web. Consultez [Comment les transactions sont dérivées des données OpenTelemetry](#transaction-mapping) pour plus d&apos;informations.

### OpenTelemetry Ruby

OpenTelemetry prend désormais en charge les métriques pour la plupart des langages, mais Ruby est une exception notable. Pour Ruby, nous effectuons un effort de toute urgence pour générer des métriques New Relic APM à partir de données span.

## Métriques de service APM

Les métriques `apm.service.*` pilotent l&apos;expérience APM de New Relic. Les sections suivantes décrivent les données OpenTelemetry source utilisées pour dériver `apm.service.*` métriques.

### Attributs de ressource métrique

Les attributs de ressource suivants sont copiés à partir des données sources vers les métriques APM :

* `container.id`
* `entity.guid`
* `host.name`
* `instrumentation.provider`
* `k8s.cluster.name`
* `k8s.container.name`
* `k8s.namespace.name`
* `k8s.pod.name`
* `service.instance.id`
* `service.name`

### Métrique: `apm.service.transaction.duration`

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Nom**
      </th>

      <th>
        **[Type d&apos;instrument](https://docs.newrelic.com/docs/data-apis/understand-data/metric-data/metric-data-type/)**
      </th>

      <th>
        **Unité ([UCUM](https://ucum.org/ucum))**
      </th>

      <th>
        **Description**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `apm.service.transaction.duration`
      </td>

      <td>
        Distribution
      </td>

      <td>
        `s`, `ms`, `ns` **\[1]**
      </td>

      <td>
        Durée des transactions. **\[2]**
      </td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Attribut**
      </th>

      <th>
        **Type**
      </th>

      <th>
        **Description**
      </th>

      <th>
        **Exemple**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `transactionName`
      </td>

      <td>
        `string`
      </td>

      <td>
        Le nom de la transaction.
      </td>

      <td>
        `WebTransaction/server/GET /users/:id`, `OtherTransaction/consumer/unknown`
      </td>
    </tr>

    <tr>
      <td>
        `transactionType`
      </td>

      <td>
        `string`
      </td>

      <td>
        Le type de transaction.
      </td>

      <td>
        `Web`, `Other`
      </td>
    </tr>

    <tr>
      <td>
        `error.type`
      </td>

      <td>
        `string`
      </td>

      <td>
        Décrit une classe d’erreur avec laquelle la transaction s’est terminée.
      </td>

      <td>
        `500`, `TimeoutException`
      </td>
    </tr>
  </tbody>
</table>

**\[1]**: L&apos;unité de la métrique source est copiée.

**\[2]**: Si `error.type` est résolu en non nul, `apm.service.error.count` est incrémenté avec le nombre respectif des données source.

#### Sources métriques

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Convention sémantique**
      </th>

      <th>
        **Nom métrique**
      </th>

      <th>
        **Conditions**
      </th>

      <th>
        **`transactionName`**
      </th>

      <th>
        **`transactionType`**
      </th>

      <th>
        **`error.type`**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        [`OtelHttpServer1_23`](https://github.com/open-telemetry/semantic-conventions/blob/v1.23.0/docs/http/http-metrics.md)
      </td>

      <td>
        `http.server.request.duration`
      </td>

      <td>
        `http.request.method IS NOT NULL`
      </td>

      <td>
        `WebTransaction/server/${http.request.method} ${http.route}`
      </td>

      <td>
        `Web`
      </td>

      <td>
        `${error.type}`
      </td>
    </tr>

    <tr>
      <td>
        [`OtelHttpServer1_20`](https://github.com/open-telemetry/opentelemetry-specification/blob/v1.20.0/specification/metrics/semantic_conventions/http-metrics.md)
      </td>

      <td>
        `http.server.duration`
      </td>

      <td>
        `http.method IS NOT NULL`
      </td>

      <td>
        `WebTransaction/server/${http.method} ${http.route}`
      </td>

      <td>
        `Web`
      </td>

      <td>
        `__http_error_status_code_or_null__`
      </td>
    </tr>

    <tr>
      <td>
        [`OtelRpcServer1_20`](https://github.com/open-telemetry/opentelemetry-specification/blob/v1.20.0/specification/trace/semantic_conventions/rpc.md)
      </td>

      <td>
        `rpc.server.duration`
      </td>

      <td>
        `rpc.system IS NOT NULL`
      </td>

      <td>
        `WebTransaction/server/${rpc.system}/${rpc.service:-unknown}.${rpc.method:-unknown}`
      </td>

      <td>
        `Web`
      </td>

      <td>
        `__rpc_error_status_code_or_null__`
      </td>
    </tr>
  </tbody>
</table>

### Métrique: `apm.service.transaction.overview`

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Nom**
      </th>

      <th>
        **[Type d&apos;instrument](https://docs.newrelic.com/docs/data-apis/understand-data/metric-data/metric-data-type/)**
      </th>

      <th>
        **Unité ([UCUM](https://ucum.org/ucum))**
      </th>

      <th>
        **Description**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `apm.service.transaction.overview`
      </td>

      <td>
        Résumé
      </td>

      <td>
        s
      </td>

      <td>
        Temps de décomposition du segment d&apos;une transaction.
      </td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Attribut**
      </th>

      <th>
        **Type**
      </th>

      <th>
        **Description**
      </th>

      <th>
        **Exemple**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `transactionName`
      </td>

      <td>
        `string`
      </td>

      <td>
        Le nom de la transaction.
      </td>

      <td>
        `WebTransaction/server/GET /users/:id`, `OtherTransaction/consumer/unknown`
      </td>
    </tr>

    <tr>
      <td>
        `transactionType`
      </td>

      <td>
        `string`
      </td>

      <td>
        Le type de transaction.
      </td>

      <td>
        `Web`, `Other`
      </td>
    </tr>

    <tr>
      <td>
        attribut de domaine
      </td>

      <td>
        divers
      </td>

      <td>
        attribut spécifique au domaine dépendant de la convention source, notamment : `db.system`, `db.sql.table`, `db.operation`, `external.host`
      </td>

      <td>
        Voir `apm.service.external.host.duration`, `apm.service.datastore.operation.duration`
      </td>
    </tr>
  </tbody>
</table>

#### Sources d&apos;envergure

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Convention sémantique**
      </th>

      <th>
        **Type d&apos;envergure**
      </th>

      <th>
        **Conditions**
      </th>

      <th>
        **`transactionName`**
      </th>

      <th>
        **`transactionType`**
      </th>

      <th>
        **attribut de domaine**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        [`OtelHttpServer1_23`](https://github.com/open-telemetry/semantic-conventions/blob/v1.23.0/docs/http/http-metrics.md)
      </td>

      <td>
        `server`
      </td>

      <td>
        `http.request.method IS NOT NULL`
      </td>

      <td>
        `WebTransaction/server/${http.request.method} ${http.route}`
      </td>

      <td>
        `Web`
      </td>

      <td />
    </tr>

    <tr>
      <td>
        [`OtelHttpServer1_20`](https://github.com/open-telemetry/opentelemetry-specification/blob/v1.20.0/specification/metrics/semantic_conventions/http-metrics.md)
      </td>

      <td>
        `server`
      </td>

      <td>
        `http.method IS NOT NULL`
      </td>

      <td>
        `WebTransaction/server/${http.method} ${http.route}`
      </td>

      <td>
        `Web`
      </td>

      <td />
    </tr>

    <tr>
      <td>
        [`OtelRpcServer1_20`](https://github.com/open-telemetry/opentelemetry-specification/blob/v1.20.0/specification/trace/semantic_conventions/rpc.md)
      </td>

      <td>
        `server`
      </td>

      <td>
        `rpc.system IS NOT NULL`
      </td>

      <td>
        `WebTransaction/server/${rpc.system}/${rpc.service:-unknown}.${rpc.method:-unknown}`
      </td>

      <td>
        `Web`
      </td>

      <td />
    </tr>

    <tr>
      <td>
        [`OtelMessagingConsumer1_24`](https://github.com/open-telemetry/semantic-conventions/blob/v1.24.0/docs/messaging/messaging-spans.md)
      </td>

      <td>
        `consumer`
      </td>

      <td>
        `messaging.operation IS NOT NULL`
      </td>

      <td>
        `OtherTransaction/consumer/${messaging.operation:-unknown}/${messaging.destination.template:-${messaging.destination.name:-unknown}}`
      </td>

      <td>
        `Other`
      </td>

      <td />
    </tr>

    <tr>
      <td>
        [`OtelDbClient1_33`](https://github.com/open-telemetry/semantic-conventions/blob/v1.33.0/docs/database/database-metrics.md)
      </td>

      <td>
        `internal`<br />`client`
      </td>

      <td>
        `db.system.name IS NOT NULL`
      </td>

      <td>
        `transactionName` de l&apos;envergure locale des racines
      </td>

      <td>
        `transactionType` de l&apos;envergure locale des racines
      </td>

      <td>
        `db.system`: `${db.system.name}`<br />`db.sql.table`: `${db.stored_procedure.name:-${db.collection.name:-${__db_summary_to_sql_table__}}}`<br />`db.operation`: `${db.operation.name:-${__db_summary_to_operation__:-unknown}}`
      </td>
    </tr>

    <tr>
      <td>
        [`OtelDbClientRedis1_24`](https://github.com/open-telemetry/semantic-conventions/blob/v1.24.0/docs/database/database-spans.md)
      </td>

      <td>
        `client`
      </td>

      <td>
        `db.system IS NOT NULL`<br />`db.system = 'redis'`
      </td>

      <td>
        `transactionName` de l&apos;envergure locale des racines
      </td>

      <td>
        `transactionType` de l&apos;envergure locale des racines
      </td>

      <td>
        `db.system`: `${db.system}`<br />`db.sql.table`: `${db.sql.table}`<br />`db.operation`: `${db.operation:-${name:-unknown}}`
      </td>
    </tr>

    <tr>
      <td>
        [`OtelDbClient1_24`](https://github.com/open-telemetry/semantic-conventions/blob/v1.24.0/docs/database/database-spans.md)
      </td>

      <td>
        `client`
      </td>

      <td>
        `db.system IS NOT NULL`
      </td>

      <td>
        `transactionName` de l&apos;envergure locale des racines
      </td>

      <td>
        `transactionType` de l&apos;envergure locale des racines
      </td>

      <td>
        `db.system`: `${db.system}`<br />`db.sql.table`: `${db.sql.table}`<br />`db.operation`: `${db.operation:-unknown}`
      </td>
    </tr>

    <tr>
      <td>
        [`OtelHttpClient1_23`](https://github.com/open-telemetry/semantic-conventions/blob/v1.23.1/docs/http/http-metrics.md)
      </td>

      <td>
        `client`
      </td>

      <td>
        `http.request.method IS NOT NULL`
      </td>

      <td>
        `transactionName` de l&apos;envergure locale des racines
      </td>

      <td>
        `transactionType` de l&apos;envergure locale des racines
      </td>

      <td>
        `external.host`: `${server.address:-unknown}`
      </td>
    </tr>

    <tr>
      <td>
        [`OtelHttpClient1_20`](https://github.com/open-telemetry/opentelemetry-specification/blob/v1.20.0/specification/metrics/semantic_conventions/http-metrics.md)
      </td>

      <td>
        `client`
      </td>

      <td>
        `http.method IS NOT NULL`
      </td>

      <td>
        `transactionName` de l&apos;envergure locale des racines
      </td>

      <td>
        `transactionType` de l&apos;envergure locale des racines
      </td>

      <td>
        `external.host`: `${net.peer.name:-unknown}`
      </td>
    </tr>

    <tr>
      <td>
        [`OtelRpcClient1_20`](https://github.com/open-telemetry/opentelemetry-specification/blob/v1.20.0/specification/metrics/semantic_conventions/rpc-metrics.md)
      </td>

      <td>
        `client`
      </td>

      <td>
        `rpc.system IS NOT NULL`
      </td>

      <td>
        `transactionName` de l&apos;envergure locale des racines
      </td>

      <td>
        `transactionType` de l&apos;envergure locale des racines
      </td>

      <td>
        `external.host`: `${net.peer.name:-unknown}`
      </td>
    </tr>
  </tbody>
</table>

### Métrique: `apm.service.external.host.duration`

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Nom**
      </th>

      <th>
        **[Type d&apos;instrument](https://docs.newrelic.com/docs/data-apis/understand-data/metric-data/metric-data-type/)**
      </th>

      <th>
        **Unité**
      </th>

      <th>
        **([UCUM](https://ucum.org/ucum))**
      </th>

      <th>
        **Description**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `apm.service.external.host.duration` | | |
      </td>

      <td>
        Distribution
      </td>

      <td>
        `s`, `ms`, `ns` **\[1]**
      </td>

      <td>
        Durée des appels externes.
      </td>

      <td />
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Attribut**
      </th>

      <th>
        **Type**
      </th>

      <th>
        **Description**
      </th>

      <th>
        Exemple
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `external.host`
      </td>

      <td>
        `string`
      </td>

      <td>
        Domaine du serveur si disponible sans recherche DNS inversée ; sinon, adresse IP ou nom de socket de domaine Unix
      </td>

      <td>
        `example.com`, `10.1.2.80`, `/tmp/my.sock`
      </td>
    </tr>
  </tbody>
</table>

**\[1]**: L&apos;unité de la métrique source est copiée.

#### Sources métriques

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Convention sémantique**
      </th>

      <th>
        **Nom métrique**
      </th>

      <th>
        **Conditions**
      </th>

      <th>
        **`external.host`**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        [`OtelHttpClient1_23`](https://github.com/open-telemetry/semantic-conventions/blob/v1.23.1/docs/http/http-metrics.md)
      </td>

      <td>
        `http.client.request.duration`
      </td>

      <td>
        `http.request.method IS NOT NULL`
      </td>

      <td>
        `${server.address:-unknown}`
      </td>
    </tr>

    <tr>
      <td>
        [`OtelHttpClient1_20`](https://github.com/open-telemetry/opentelemetry-specification/blob/v1.20.0/specification/metrics/semantic_conventions/http-metrics.md)
      </td>

      <td>
        `http.client.duration`
      </td>

      <td>
        `http.method IS NOT NULL`
      </td>

      <td>
        `${net.peer.name:-unknown}`
      </td>
    </tr>

    <tr>
      <td>
        [`OtelRpcClient1_20`](https://github.com/open-telemetry/opentelemetry-specification/blob/v1.20.0/specification/metrics/semantic_conventions/rpc-metrics.md)
      </td>

      <td>
        `rpc.client.duration`
      </td>

      <td>
        `rpc.system IS NOT NULL`
      </td>

      <td>
        `${net.peer.name:-unknown}`
      </td>
    </tr>
  </tbody>
</table>

### Métrique: `apm.service.datastore.operation.duration`

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Nom**
      </th>

      <th>
        **[Type d&apos;instrument](https://docs.newrelic.com/docs/data-apis/understand-data/metric-data/metric-data-type/)**
      </th>

      <th>
        **Unité ([UCUM](https://ucum.org/ucum))**
      </th>

      <th>
        **Description**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `apm.service.datastore.operation.duration`
      </td>

      <td>
        Distribution
      </td>

      <td>
        `s`, `ms`, `ns` **\[1]**
      </td>

      <td>
        Durée des appels datastore.
      </td>
    </tr>
  </tbody>
</table>

**\[1]**: L&apos;unité de la métrique source est copiée.

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Attribut**
      </th>

      <th>
        **Type**
      </th>

      <th>
        **Description**
      </th>

      <th>
        **Exemple**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `db.system`
      </td>

      <td>
        `string`
      </td>

      <td>
        Le produit du système de gestion de base de données (SGBD) tel qu&apos;identifié par l&apos;instrumentation client.
      </td>

      <td>
        `postgresql`, `mysql`, `mariadb`
      </td>
    </tr>

    <tr>
      <td>
        `db.sql.table`
      </td>

      <td>
        `string`
      </td>

      <td>
        Le nom d&apos;une collection (table, conteneur) dans la base de données.
      </td>

      <td>
        `public.users`, `customers`
      </td>
    </tr>

    <tr>
      <td>
        `db.operation`
      </td>

      <td>
        `string`
      </td>

      <td>
        Le nom de l&apos;opération ou de la commande en cours d&apos;exécution.
      </td>

      <td>
        `findAndModify`, `HMSET`, `SELECT`
      </td>
    </tr>

    <tr>
      <td>
        `db.query.summary`
      </td>

      <td>
        `string`
      </td>

      <td>
        Résumé de faible cardinalité d&apos;une requête de base de données.
      </td>

      <td>
        `SELECT wuser_table`, `INSERT shipping_details`, `SELECT order`
      </td>
    </tr>
  </tbody>
</table>

#### Sources métriques

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Convention sémantique**
      </th>

      <th>
        **Nom métrique**
      </th>

      <th>
        **Conditions**
      </th>

      <th>
        **`db.system`**
      </th>

      <th>
        **`db.sql.table`**
      </th>

      <th>
        **`db.operation`**
      </th>

      <th>
        **`db.query.summary`**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        [`OtelDbClient1_33`](https://github.com/open-telemetry/semantic-conventions/blob/v1.33.0/docs/database/database-metrics.md)
      </td>

      <td>
        `db.client.operation.duration`
      </td>

      <td>
        `db.system.name IS NOT NULL`
      </td>

      <td>
        `${db.system.name}`
      </td>

      <td>
        `${db.stored_procedure.name:-${db.collection.name:-${__db_summary_to_sql_table__}}}`
      </td>

      <td>
        `${db.operation.name:-${__db_summary_to_operation__:-unknown}}`
      </td>

      <td>
        `${db.query.summary}`
      </td>
    </tr>
  </tbody>
</table>

### Fonctions d&apos;assistance

Les fonctions d&apos;assistance sont des références à des éléments de logique de modélisation d&apos;attributs qui sont plus complexes que de simples références d&apos;attributs.

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        **Fonction**
      </th>

      <th>
        **Description**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `__http_error_status_code_or_null__`
      </td>

      <td>
        Renvoie la valeur de chaîne de `http.status_code if >= 500`
      </td>
    </tr>

    <tr>
      <td>
        `__rpc_error_status_code_or_null__`
      </td>

      <td>
        Renvoie la valeur de chaîne de rpc.grpc.status\_code si dans l&apos;ensemble : `[2,4,12,13,14,15]`
      </td>
    </tr>

    <tr>
      <td>
        `__db_summary_to_operation__`
      </td>

      <td>
        Renvoie le premier mot de `db.query.summary` dans l&apos;ensemble (insensible à la casse) : `[alter,call,create,delete,drop,exec,execute,insert,merge,select,set,update]`
      </td>
    </tr>

    <tr>
      <td>
        `__db_summary_to_sql_table__`
      </td>

      <td>
        Renvoie le premier mot de `db.query.summary` NON dans l&apos;ensemble (insensible à la casse) : `[alter,call,create,delete,drop,exec,execute,insert,merge,select,set,update]`
      </td>
    </tr>

    <tr>
      <td>
        `__null__`
      </td>

      <td>
        Espace réservé pour `null`
      </td>
    </tr>
  </tbody>
</table>

## Signaux dorés [#golden-signals]

Les signaux dorés de débit, de temps de réponse et de taux d&apos;erreur apparaissent à plusieurs endroits dans l&apos;interface utilisateur d&apos;OpenTelemetry APM. Lorsqu&apos;ils sont utilisés, ils sont calculés comme suit :

Pour les métriques, la requête suppose que les données sont conformes aux conventions sémantiques [HTTP métrique](https://opentelemetry.io/docs/specs/semconv/http/http-metrics/) ou [RPC métrique](https://opentelemetry.io/docs/specs/semconv/rpc/rpc-metrics/) .

Pour les étendues, les requêtes sont génériques et utilisent uniquement le modèle de données d&apos;étendue de niveau supérieur. Les spans sont comptabilisés dans le débit et le temps de réponse s&apos;ils sont des spans d&apos;entrée racine dans un service, calculés à l&apos;aide d&apos;une heuristique de `WHERE span.kind = server OR span.kind = consumer`. Les étendues sont des erreurs si elles ont un code d&apos;état de `ERROR` (par exemple, `otel.status_code = ERROR`).

## Affiner les données avec des filtres [#narrow-with-filters]

Plusieurs pages incluent une barre de filtre, avec des options telles que **Narrow data to...**. Cela vous permet de filtrer les requêtes sur la page pour correspondre aux critères. Par exemple, vous pouvez restreindre votre recherche à un déploiement Canary particulier en filtrant sur `service.version='1.2.3-canary'`. Les filtres sont conservés lors de la navigation entre les pages.

## métriques dorées

Les métriques dorées sont des versions à faible cardinalité des données de signaux dorés, telles que les métriques HTTP/RPC. Ils peuplent diverses expériences de plateforme, notamment l&apos;entité Explorer, la page d&apos;activité de la charge de travail et la page Détails du suivi des changements. Ces métriques utilisent des noms tels que `newrelic.goldenmetrics.ext.service.*`.

<Callout variant="important">
  Historiquement, les métriques dorées OpenTelemetry étaient calculées à partir des travées. Les portées sont généralement échantillonnées, elles ne fournissent donc qu&apos;une image partielle. Maintenant que les métriques sont largement disponibles, les métriques dorées sont calculées à l&apos;aide de données métriques plutôt que de données span.
</Callout>