---
title: Référence des métriques de conteneurs Docker
tags:
  - Integrations
  - OpenTelemetry
  - Docker
  - Metrics
metaDescription: 'Complete reference of Docker container metrics collected by OpenTelemetry, including descriptions, types, and alerting recommendations.'
freshnessValidatedDate: never
translationType: machine
---

Cette page fournit une référence complète de toutes les métriques de conteneurs Docker collectées par le [dockerstatsreceiver](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/dockerstatsreceiver) OpenTelemetry. Utilisez cette référence pour comprendre quelles données sont disponibles, créer des requêtes personnalisées et configurer des alertes efficaces pour vos applications conteneurisées.

## Référence complète des métriques [#metrics-reference]

Le [dockerstatsreceiver](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/dockerstatsreceiver) de l&apos;OpenTelemetry Collector Contrib collecte les métriques suivantes depuis l&apos;API Docker Stats :

<CollapserGroup>
  <Collapser id="docker-metrics" title="Métriques">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            métrique
          </th>

          <th>
            Description
          </th>

          <th>
            Type
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `container.blockio.io_merged_recursive`
          </td>

          <td>
            Nombre de bios/requêtes fusionnés dans des requêtes appartenant à ce cgroup et à ses cgroups descendants
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_queued_recursive`
          </td>

          <td>
            Nombre de requêtes en file d&apos;attente pour ce cgroup et ses cgroups descendants
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_service_bytes_recursive`
          </td>

          <td>
            Nombre d&apos;octets transférés vers/depuis le disque par le groupe et les groupes descendants
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_service_time_recursive`
          </td>

          <td>
            Temps total en nanosecondes entre l&apos;envoi de la requête et son achèvement pour les E/S effectuées par ce cgroup et les cgroups descendants
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_serviced_recursive`
          </td>

          <td>
            Nombre d&apos;E/S (bio) émises vers le disque par le groupe et les groupes descendants
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_time_recursive`
          </td>

          <td>
            Temps disque alloué au cgroup (et aux cgroups descendants) par périphérique en millisecondes
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_wait_time_recursive`
          </td>

          <td>
            Temps total passé par les E/S de ce cgroup (et des cgroups descendants) à attendre dans les files d&apos;attente de l&apos;ordonnanceur pour être traitées
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.kernelmode`
          </td>

          <td>
            Utilisation du CPU en mode noyau
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.percpu`
          </td>

          <td>
            Utilisation du CPU par cœur par le conteneur (désactivé par défaut)
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.system`
          </td>

          <td>
            Utilisation du CPU système
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.total`
          </td>

          <td>
            Temps CPU total consommé par le conteneur
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.usermode`
          </td>

          <td>
            Utilisation du CPU en mode utilisateur
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.percent`
          </td>

          <td>
            Pourcentage de CPU utilisé par le conteneur (obsolète, utilisez container.cpu.utilization à la place)
          </td>

          <td>
            Jauge
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.utilization`
          </td>

          <td>
            Pourcentage de CPU utilisé par le conteneur
          </td>

          <td>
            Jauge
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.throttling_data.periods`
          </td>

          <td>
            Nombre de périodes avec limitation active
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.throttling_data.throttled_periods`
          </td>

          <td>
            Nombre de périodes où le conteneur a atteint sa limite de régulation
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.throttling_data.throttled_time`
          </td>

          <td>
            Temps cumulé pendant lequel le conteneur a été limité
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.limit`
          </td>

          <td>
            Limite de CPU définie pour le conteneur
          </td>

          <td>
            Jauge
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.logical.count`
          </td>

          <td>
            Nombre de cœurs disponibles pour le conteneur
          </td>

          <td>
            Jauge
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.shares`
          </td>

          <td>
            Parts de CPU allouées au conteneur
          </td>

          <td>
            Jauge
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.cores.used`
          </td>

          <td>
            Nombre de cœurs de processeur utilisés par le conteneur
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.usage.limit`
          </td>

          <td>
            Limite d&apos;utilisation de la mémoire
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.usage.max`
          </td>

          <td>
            Utilisation maximale de la mémoire
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.usage.total`
          </td>

          <td>
            Utilisation de la mémoire du conteneur. Cela exclut le cache
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.percent`
          </td>

          <td>
            Pourcentage de mémoire utilisée
          </td>

          <td>
            Jauge
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.active_anon`
          </td>

          <td>
            Quantité de mémoire utilisée dans les mappages anonymes tels que brk(), sbrk() et mmap(MAP\_ANONYMOUS) qui sont activement utilisés
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.active_file`
          </td>

          <td>
            Quantité de mémoire cache utilisée par les fichiers activement utilisés
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.anon`
          </td>

          <td>
            Quantité de mémoire utilisée dans les mappages anonymes (pages non adossées à des fichiers)
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.cache`
          </td>

          <td>
            La quantité de mémoire utilisée par les processus de ce groupe de contrôle pouvant être associée à un bloc sur un périphérique bloc
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.dirty`
          </td>

          <td>
            Octets en attente d&apos;écriture sur le disque, provenant de ce cgroup
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.fails`
          </td>

          <td>
            Nombre de fois où la limite de mémoire a été atteinte
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.file`
          </td>

          <td>
            Quantité de mémoire utilisée par les fichiers (cache de fichiers)
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.hierarchical_memory_limit`
          </td>

          <td>
            La quantité maximale de mémoire physique que le cgroup peut utiliser
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.hierarchical_memsw_limit`
          </td>

          <td>
            La quantité maximale de RAM + swap que le cgroup peut utiliser
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.inactive_anon`
          </td>

          <td>
            Quantité de mémoire utilisée dans les mappages anonymes tels que brk(), sbrk() et mmap(MAP\_ANONYMOUS) qui ne sont pas activement utilisés
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.inactive_file`
          </td>

          <td>
            Quantité de mémoire cache utilisée par les fichiers qui ne sont pas activement utilisés
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.mapped_file`
          </td>

          <td>
            Indique la quantité de mémoire mappée par les processus du groupe de contrôle
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.pgfault`
          </td>

          <td>
            Indique le nombre de fois qu&apos;un processus du cgroup a déclenché un défaut de page
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.pgmajfault`
          </td>

          <td>
            Indique le nombre de fois qu&apos;un processus du cgroup a déclenché un défaut de page majeur
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.pgpgin`
          </td>

          <td>
            Nombre de pages lues sur le disque par le cgroup
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.pgpgout`
          </td>

          <td>
            Nombre de pages écrites sur le disque par le cgroup
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.rss`
          </td>

          <td>
            La quantité de mémoire qui ne correspond à rien sur le disque : piles, tas et mappages de mémoire anonymes
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.rss_huge`
          </td>

          <td>
            Nombre d&apos;octets de pages géantes transparentes anonymes dans ce cgroup
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.unevictable`
          </td>

          <td>
            La quantité de mémoire qui ne peut pas être récupérée
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.writeback`
          </td>

          <td>
            Nombre d&apos;octets de cache fichier/anonyme en file d&apos;attente pour la synchronisation sur disque dans ce cgroup
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.rx_bytes`
          </td>

          <td>
            Octets reçus par le conteneur via son interface réseau
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.rx_dropped`
          </td>

          <td>
            Nombre de paquets reçus rejetés par le conteneur
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.rx_errors`
          </td>

          <td>
            Erreurs reçues par le conteneur
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.rx_packets`
          </td>

          <td>
            Paquets reçus par le conteneur via son interface réseau
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.tx_bytes`
          </td>

          <td>
            Octets envoyés par le conteneur via son interface réseau
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.tx_dropped`
          </td>

          <td>
            Nombre de paquets envoyés rejetés par le conteneur
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.tx_errors`
          </td>

          <td>
            Erreurs de transmission par le conteneur
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.tx_packets`
          </td>

          <td>
            Paquets envoyés par le conteneur via son interface réseau
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.pids.count`
          </td>

          <td>
            Nombre de PID dans le cgroup du conteneur
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.pids.limit`
          </td>

          <td>
            Nombre maximum de PID dans le cgroup du conteneur
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.restarts`
          </td>

          <td>
            Nombre de fois que le conteneur a été redémarré
          </td>

          <td>
            Somme
          </td>
        </tr>

        <tr>
          <td>
            `container.uptime`
          </td>

          <td>
            Temps écoulé depuis le démarrage du conteneur
          </td>

          <td>
            Jauge
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="docker-attributes" title="Attributs">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Attribut
          </th>

          <th>
            Description
          </th>

          <th>
            Valeurs
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `collector.name`
          </td>

          <td>
            Attribut personnalisé pour l&apos;identification du collecteur (si configuré dans votre collecteur)
          </td>

          <td>
            Chaîne
          </td>
        </tr>

        <tr>
          <td>
            `container.hostname`
          </td>

          <td>
            Le nom d&apos;hôte du conteneur
          </td>

          <td>
            Chaîne
          </td>
        </tr>

        <tr>
          <td>
            `container.id`
          </td>

          <td>
            L&apos;ID complet du conteneur
          </td>

          <td>
            Chaîne (hexadécimale de 64 caractères)
          </td>
        </tr>

        <tr>
          <td>
            `container.image.name`
          </td>

          <td>
            Nom de l&apos;image de conteneur
          </td>

          <td>
            Chaîne
          </td>
        </tr>

        <tr>
          <td>
            `container.name`
          </td>

          <td>
            Nom du conteneur
          </td>

          <td>
            Chaîne
          </td>
        </tr>

        <tr>
          <td>
            `container.runtime`
          </td>

          <td>
            Exécution du conteneur
          </td>

          <td>
            `docker`
          </td>
        </tr>

        <tr>
          <td>
            `deployment.environment`
          </td>

          <td>
            Identifiant de l&apos;environnement de déploiement (si configuré dans votre collecteur)
          </td>

          <td>
            Chaîne
          </td>
        </tr>

        <tr>
          <td>
            `description`
          </td>

          <td>
            Description de la métrique
          </td>

          <td>
            Chaîne
          </td>
        </tr>

        <tr>
          <td>
            `device_major`
          </td>

          <td>
            Numéro majeur du périphérique (pour les métriques d&apos;E/S de bloc)
          </td>

          <td>
            Entier
          </td>
        </tr>

        <tr>
          <td>
            `device_minor`
          </td>

          <td>
            Numéro mineur de périphérique (pour les métriques d&apos;E/S par blocs)
          </td>

          <td>
            Entier
          </td>
        </tr>

        <tr>
          <td>
            `entity.guid`
          </td>

          <td>
            GUID d&apos;entité New Relic pour le conteneur
          </td>

          <td>
            Chaîne
          </td>
        </tr>

        <tr>
          <td>
            `entity.name`
          </td>

          <td>
            Nom de l&apos;entité New Relic (généralement le nom du conteneur)
          </td>

          <td>
            Chaîne
          </td>
        </tr>

        <tr>
          <td>
            `entity.type`
          </td>

          <td>
            Type d&apos;entité New Relic
          </td>

          <td>
            `CONTAINER`
          </td>
        </tr>

        <tr>
          <td>
            `instrumentation.provider`
          </td>

          <td>
            Identifiant du fournisseur d&apos;instrumentation
          </td>

          <td>
            `opentelemetry`
          </td>
        </tr>

        <tr>
          <td>
            `interface`
          </td>

          <td>
            Nom de l&apos;interface réseau (pour les métriques réseau)
          </td>

          <td>
            Chaîne
          </td>
        </tr>

        <tr>
          <td>
            `newrelic.source`
          </td>

          <td>
            Source de la métrique dans New Relic
          </td>

          <td>
            `api.metrics.otlp`
          </td>
        </tr>

        <tr>
          <td>
            `nr.entity_type`
          </td>

          <td>
            Type d&apos;entité New Relic pour la corrélation d&apos;entités
          </td>

          <td>
            `CONTAINER`
          </td>
        </tr>

        <tr>
          <td>
            `operation`
          </td>

          <td>
            Type d&apos;opération d&apos;E/S par bloc
          </td>

          <td>
            `read`, `write`
          </td>
        </tr>

        <tr>
          <td>
            `otel.library.name`
          </td>

          <td>
            Nom de la bibliothèque/du récepteur OpenTelemetry
          </td>

          <td>
            `github.com/open-telemetry/opentelemetry-collector-contrib/receiver/dockerstatsreceiver`
          </td>
        </tr>

        <tr>
          <td>
            `otel.library.version`
          </td>

          <td>
            Version de la bibliothèque OpenTelemetry
          </td>

          <td>
            Chaîne (par ex. `0.142.0`)
          </td>
        </tr>

        <tr>
          <td>
            `service.name`
          </td>

          <td>
            Nom du service configuré dans le collecteur
          </td>

          <td>
            Chaîne
          </td>
        </tr>

        <tr>
          <td>
            `telemetry.sdk.name`
          </td>

          <td>
            Identifiant du SDK de télémétrie
          </td>

          <td>
            `opentelemetry`
          </td>
        </tr>

        <tr>
          <td>
            `unit`
          </td>

          <td>
            Unité de mesure de la métrique
          </td>

          <td>
            Chaîne (par ex. `{cpus}`, `By`, `1`)
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

Pour plus de détails, consultez la [documentation du récepteur Docker Stats](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/dockerstatsreceiver/documentation.md)

## Prochaines étapes [#next-steps]

Maintenant que vous comprenez les métriques Docker :

* [Configurer le monitoring](/docs/opentelemetry/integrations/docker-monitoring/self-hosted) - Configurez le monitoring Docker si ce n&apos;est pas déjà fait
* **Créer des dashboards**: construisez des [visualisations personnalisées](/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/) à l&apos;aide des métriques de cette référence