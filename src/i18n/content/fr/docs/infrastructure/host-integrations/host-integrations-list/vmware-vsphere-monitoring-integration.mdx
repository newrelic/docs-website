---
title: Intégration monitoring VMware vSphere
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: An introduction to New Relic's open-source VMware vSphere / ESXi integration.
freshnessValidatedDate: never
translationType: machine
---

L&apos;intégration VMware vSphere de New Relic vous aide à comprendre l&apos;état de santé et les performances de votre environnement vSphere. Tu peux:

* Requêtez des données pour obtenir des informations détaillées sur les performances de vos hyperviseurs, machines virtuelles, etc.
* Passez des vues de haut niveau aux données les plus granulaires.

Notre intégration utilise l&apos;[API vSphere](https://code.vmware.com/apis/704/vsphere) pour collecter les métriques et événements générés par tous les composants de vSphere, et transmet les données à notre plateforme via l&apos;agent infrastructure .

<img title="" alt="" src="/images/infrastructure_screenshot-full_vmware-vsphere-ui.webp" />

## Pourquoi c&apos;est important [#features]

Avec notre intégration vSphere, vous pouvez :

* instrumenter et monitorer plusieurs instances vSphere en utilisant le même compte.
* Collectez des données sur les instantanés, les machines virtuelles, les hôtes, les pools de ressources, les clusters et les magasins de données, y compris les balises.
* Monitorer la santé de vos hyperviseurs et VM à l&apos;aide de nos graphiques et dashboards.
* Utilisez les données récupérées pour monitorer les indicateurs clés de performance et de mise à l’échelle des capacités.
* Définissez <InlinePopover type="alerts" />en fonction de toutes les métriques collectées à partir de vCenter.
* Créez [une charge de travail](/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-one-workloads-isolate-resolve-incidents-faster) pour regrouper les ressources et vous concentrer sur les données clés.

## Compatibilité et exigences [#requirements]

Notre intégration est compatible avec VMware vSphere 6.5 ou supérieur.

Avant d’installer l’intégration, assurez-vous que vous répondez aux exigences suivantes :

* [Agent d&apos;infrastructure installé sur un hôte](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic)
* Compte de service vCenter disposant au moins d&apos;autorisations globales en lecture seule avec l&apos;option `propagate to children` cochée

<Callout variant="important">
  <DNT>**Large environments:**</DNT> Dans les environnements comportant plus de 800 machines virtuelles, l’intégration ne peut pas signaler toutes les données et peut échouer. Nous proposons une solution de contournement qui préservera toutes les métriques et événements, mais elle désactivera l&apos;enregistrement des entités. Pour appliquer la solution de contournement, ajoutez la variable d’environnement suivante au fichier de configuration :

  ```yaml
  integrations:
  - name: nri-vsphere
    env:
      # Integration configuration parameters.

      EVENTS: true
      METRICS: true

  ```
</Callout>

## Installer l&apos;intégration [#install]

Le moyen le plus simple d&apos;installer l&apos;intégration est de suivre notre [installation guidée](https://onenr.io/0Bj3VYmGbRX):

1. connectez-vous à [one.newrelic.com](https://onenr.io/0Bj3VYmGbRX).
2. Cliquez sur <DNT>**Integrations &amp; Agents**</DNT>, recherchez « vSphere » et cliquez sur l’intégration.
3. Suivez les étapes de l&apos;UI.

Si vous devez effectuer l&apos;installation manuellement, consultez les sections ci-dessous.

<CollapserGroup>
  <Collapser id="linux-install" title="Installation de Linux">
    1. Installez [l’agent d’infrastructure](/docs/integrations/host-integrations/installation/install-infrastructure-host-integrations/#install) et remplacez `INTEGRATION_FILE_NAME` par `nri-vsphere` lors de l’exécution de la commande d’installation.

    2. Changez le répertoire vers le dossier d&apos;intégration :

       ```
       cd /etc/newrelic-infra/integrations.d
       ```

    3. Copie du fichier de configuration d&apos;exemple :

       ```
       sudo cp vsphere-config.yml.sample vsphere-config.yml
       ```

    4. Modifiez le fichier `vsphere-config.yml` comme décrit dans les [paramètres de configuration](#config).
  </Collapser>

  <Collapser id="windows-install" title="Installation de Windows">
    1. Téléchargez l&apos;image du programme d&apos;installation MSI `nri-vsphere` à partir de :

       [download.newrelic.com/infrastructure\_agent/windows/integrations/nri-vsphere/nri-vsphere-amd64.msi](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-vsphere/nri-vsphere-amd64.msi)

    2. Pour installer à partir de l’invite de commande Windows, exécutez :

       ```
       msiexec.exe /qn /i PATH\TO\nri-vsphere-amd64.msi
       ```

    3. Dans le répertoire d’intégration, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, créez une copie du fichier configuration d’exemple en exécutant :

       ```
       cp vsphere-config.yml.sample vsphere-config.yml
       ```

    4. Modifiez le fichier `vsphere-config.yml` comme décrit dans les [paramètres de configuration](#config).
  </Collapser>

  <Collapser id="tarball" title="Installation de tarball (avancé)">
    Vous pouvez également [installer l&apos;intégration à partir d&apos;un fichier tarball](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball). Cela vous donne un contrôle total sur le processus d&apos;installation et de configuration.
  </Collapser>
</CollapserGroup>

<InstallFeedback />

## Configurer l&apos;intégration [#config]

La configuration au format YAML d&apos;une intégration est l&apos;endroit où vous pouvez placer les informations de connexion requises et configurer la manière dont les données sont collectées. Les options que vous modifiez dépendent de votre configuration et de vos préférences.

Pour configurer l&apos;intégration vSphere, vous devez définir l&apos;URL des points de terminaison d&apos;API vSphere, ainsi que votre nom d&apos;utilisateur et votre mot de passe vSphere. Pour des exemples de configuration, consultez les [exemples de fichiers de configuration](#example-config). Certaines fonctionnalités d&apos;intégration vSphere sont facultatives et peuvent être activées via les paramètres configuration .

De plus, avec [la gestion des secrets](/docs/integrations/host-integrations/installation/secrets-management), vous pouvez configurer l&apos;intégration sur hôte avec l&apos;agent infrastructure de New Relic pour utiliser des données sensibles (telles que les mots de passe) sans avoir à les écrire en texte brut dans le fichier configuration de l&apos;intégration.

<CollapserGroup>
  <Collapser className="freq-link" id="vsphere-events" title="Collecter l'événement vSphere">
    Pour collecter l&apos;événement vSphere, utilisez la variable d&apos;environnement `ENABLE_VSPHERE_EVENTS` .

    L&apos;intégration collecte les événements entre l&apos;heure actuelle et le dernier événement récupéré pour chaque data center. Il stocke les informations concernant le dernier événement récupéré dans un cache qui est mis à jour après chaque exécution. événement ne sont disponibles que si l&apos;intégration est connectée à un vCenter et non directement à un hôte ESXi.

    Le nombre d&apos;événements collectés par requête peut être ajusté en modifiant `EVENTS_PAGE_SIZE`, qui est défini sur `100` par défaut.

    Les événements sont disponibles dans la page <DNT>**Events**</DNT> et peuvent être interrogés via [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) comme `InfrastructureEvent` sous `vSphereEvent`. Voici un exemple de données d’événement vSphere :

    ```
    "summary": "User dcui@127.0.0.1 logged out (login time: Tuesday, 14 July, 2020 08:32:09 AM, number of API invocations: 0, user agent: VMware-client/6.5.0)",
    "vSphereEvent.computeResource": "cluster1",
    "vSphereEvent.datacenter": "Prod Datacenter",
    "vSphereEvent.date": "Tue, 14 Jul 2020 09:03:51 UTC",
    "vSphereEvent.host": "192.168.0.230",
    "vSphereEvent.userName": "dcui"
    ```
  </Collapser>

  <Collapser className="freq-link" id="snapshot-data" title="Collecter des données instantanées">
    Pour collecter des données instantanées, utilisez la variable d’environnement `ENABLE_VSPHERE_SNAPSHOTS` .

    Les données instantanées peuvent être trouvées dans `VSphereSnapshotVmSample`. Les données collectées couvrent l&apos;espace total et unique occupé par les fichiers du disque et de la mémoire, l&apos;arborescence des instantanés et l&apos;heure de création.

    Vous pouvez utiliser ces informations pour créer des requêtes [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) , [des dashboards](/docs/dashboards/new-relic-one-dashboards/get-started/introduction-new-relic-one-dashboards) et [des alertes](/docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries), car elles sont liées à l&apos;entité de machine virtuelle correspondante.
  </Collapser>

  <Collapser className="freq-link" id="vsphere-tags" title="Collecter la balise vSphere">
    Pour collecter la balise vSphere, utilisez la variable d’environnement `ENABLE_VSPHERE_TAGS` .

    les balises sont disponibles en tant qu&apos;attribut dans l&apos;échantillon d&apos;entité correspondant sous la forme `label.tagCategory:tagName`.

    Si deux balises de la même catégorie sont attribuées à une ressource, elles sont ajoutées à un attribut unique séparé par un caractère pipe. Par exemple : `label.tagCategory:tagName|tagName`2.

    La balise peut être utilisée pour exécuter une requête [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) , filtrer l&apos;entité dans notre [explorateur d&apos;entités](/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-one-entity-explorer) et créer [un dashboard](/docs/dashboards/new-relic-one-dashboards/get-started/introduction-new-relic-one-dashboards) et [des alertes](/docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries).
  </Collapser>

  <Collapser className="freq-link" id="vsphere-filter" title="Filtrer les ressources par tag">
    Le filtrage des ressources vous permet de spécifier les ressources que vous souhaitez monitorer en déclarant un ensemble de balises que les ressources doivent avoir pour être monitorées.

    Les ressources nécessitent une correspondance sur une (ou plusieurs) balise de filtre pour être incluses. Si aucune balise de ressource ne correspond à aucune balise de filtre, aucune information sur cette ressource n&apos;est envoyée à New Relic.

    Pour utiliser le filtrage des ressources par tag , vous devez activer la variable d&apos;environnement `ENABLE_VSPHERE_TAGS`.

    Une expression de filtre tag est une liste de paires de chaînes séparées par des espaces au format `category=name`.

    Par exemple, pour récupérer uniquement les ressources avec une catégorie tag `region` et inclure les régions `us` et `eu`, utilisez une expression de filtre comme : `region=us region=eu`

    ```
    INCLUDE_TAGS: >
      region=us
      region=eu
    ```

    Pour activer le filtrage des ressources par tag, modifiez votre fichier configuration intégration et ajoutez l&apos;option `INCLUDE_TAGS` avec l&apos;expression de filtre souhaitée.

    <Callout variant="caution">
      Notez que les ressources data center agissant comme racine de l&apos;arborescence des ressources DOIVENT avoir une balise attachée ET correspondre à l&apos;expression de filtre pour que d&apos;autres ressources enfants soient récupérées.
    </Callout>
  </Collapser>

  <Collapser className="freq-link" id="perf-metrics" title="Activer et configurer les métriques de performances (préversion)">
    Les mesures de performances offrent une meilleure compréhension de l&apos;état actuel des ressources VMware et peuvent être collectées <DNT>**in addition**</DNT> selon les mesures collectées par défaut ; et incluses dans les exemples ; décrits au bas de la page.

    Toutes les métriques collectées sont incluses dans l’échantillon correspondant avec le préfixe `perf.` attaché au nom. Par exemple, `net.packetsRx.summation` est collecté et envoyé sous la forme `perf.net.packetsRx.summation`.

    Pour collecter les mesures de performances de vSphere, utilisez la variable d’environnement `ENABLE_VSPHERE_PERF_METRICS` .

    Les données sont collectées selon les paramètres du fichier de configuration [`vsphere-performance.metrics`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-performance.metrics) . Vous pouvez remplacer l&apos;emplacement du fichier de configuration des mesures de performances à l&apos;aide de la variable d&apos;environnement `PERF_METRIC_FILE` . Notez que l’intégration suit [les niveaux de collecte de données de VMware](https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.monitoring.doc/GUID-25800DE4-68E5-41CC-82D9-8811E27924BC.html) (1 à 4).

    Lorsque `ENABLE_VSPHERE_PERF_METRICS` est défini, toutes les métriques de niveau 1 sont collectées. Le niveau de collecte des données des mesures de performance collectées peut être modifié à l&apos;aide de `PERF_LEVEL`. Chaque métrique du fichier de configuration peut être placée en commentaire et de nouvelles peuvent être ajoutées si nécessaire.

    <Callout variant="caution">
      La collecte de données de performances peut augmenter la charge dans vCenter et le temps nécessaire à la collecte des données. Nous vous recommandons d&apos;inclure uniquement les métriques dont vous avez besoin dans le fichier de configuration.
    </Callout>

    Pour affiner la collecte de données, le nombre d&apos;entités et de métriques récupérées par requête peut être modifié à l&apos;aide `BATCH_SIZE_PERF_ENTITIES` et `BATCH_SIZE_PERF_METRICS`.

    <Callout variant="tip">
      Pour plus d&apos;informations sur les mesures de performances de vSphere, consultez la [documentation VMware](https://docs.vmware.com/en/VMware-vSphere/6.7/vsphere-esxi-vcenter-server-67-monitoring-performance-guide.pdf).
    </Callout>
  </Collapser>

  <Collapser className="freq-link" id="multi-instance" title="Instance multiple">
    Dans cette configuration nous monitoring plusieurs serveurs vSphere à partir de la même intégration. Pour la première instance (`FIRST_VSPHERE_API_URL`), nous collectons l&apos;événement et le tag tandis que pour la deuxième instance (`SECOND_VSPHERE_API_URL`), nous les avons désactivés.

    ```yaml
    integrations:
      - name: nri-vsphere
        env:
          # vSphere API connection data (vCenter or ESXi servers)
          URL: https://<FIRST_VSPHERE_API_URL>/sdk
          USER: <FIRST_VSPHERE_USER>
          PASS: <FIRST_PASSWORD>

          # Collect events data
          ENABLE_VSPHERE_EVENTS: true

          # Collect vSphere tags
          ENABLE_VSPHERE_TAGS: true

        # Execution interval. Set a value higher than 20s, as real-time vSphere samples are run every 20s.
        interval: 120s
      - name: nri-vsphere
        env:
          # vSphere API connection data (vCenter or ESXi servers)
          URL: https://<SECOND_VSPHERE_API_URL>/sdk
          USER: <SECOND_VSPHERE_USER>
          PASS: <SECOND_PASSWORD>

          # Collect events data
          ENABLE_VSPHERE_EVENTS: false

          # Collect vSphere tags
          ENABLE_VSPHERE_TAGS: false

        # Execution interval. Set a value higher than 20s, as real-time vSphere samples are run every 20s.
        interval: 300s
    ```
  </Collapser>
</CollapserGroup>

<Callout variant="important">
  Si vous connectez l&apos;intégration directement à l&apos;hôte ESXi, les données vCenter ne sont pas disponibles (par exemple, événement, tag ou métadonnées data center ).
</Callout>

### Exemple de configuration [#example-config]

Voici des exemples de configuration d&apos;intégration vSphere, y compris des mesures de performances :

* [`vsphere-config.yml.sample`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-config.yml.sample) (Linux)
* [`vsphere-win-config.yml.sample`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-win-config.yml.sample) (Windows)
* [`vsphere-performance.metrics`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-performance.metrics) (Mesures de performance)

Pour plus d&apos;informations, consultez notre documentation sur la [structure générale de l&apos;intégration sur configuration hôte](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview).

<Callout variant="important">
  L&apos;option de configuration [inventor\_source](/docs/integrations/integrations-sdk/file-specifications/host-integrations-newer-configuration-format#inventory_source) n&apos;est pas compatible avec cette intégration.
</Callout>

## Mettez à jour votre intégration [#update]

<DNT>
  **On-host integrations do not automatically update.**
</DNT>

Pour de meilleurs résultats, mettez régulièrement [à jour le package d&apos;intégration](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) et l&apos;[agent d&apos;infrastructure](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

## Afficher et utiliser les données [#data]

Les données de ce service sont signalées à un [dashboard d&apos;intégration](https://onenr.io/0qwyY4Bzpwn). Vous pouvez [interroger ces données](/docs/using-new-relic/data/understand-data/query-new-relic-data) à des fins de dépannage ou pour créer des graphiques et des dashboards.

Les données vSphere sont attachées à ces [types d’événements](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#event):

* `VSphereHostSample`
* `VSphereClusterSample`
* `VSphereVmSample`
* `VSphereDatastoreSample`
* `VSphereDatacenterSample`
* `VSphereResourcePoolSample`
* `VSphereSnapshotVmSample`

Les données de performances sont activées et configurées séparément (voir [Activer et configurer les métriques de performances](#perf-metrics)).

Pour en savoir plus sur la façon d&apos;afficher et d&apos;utiliser vos données, consultez [Comprendre les données d&apos;intégration](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## données métriques [#metrics]

L&apos;intégration vSphere fournit des données métriques attachées à l&apos;[événement](/docs/telemetry-data-platform/ingest-manage-data/understand-data/new-relic-data-types#events-new-relic) New Relic suivant :

* `VSphereHostSample`
* `VSphereVmSample`
* `VSphereDatastoreSample`
* `VSphereDatacenterSample`
* `VSphereResourcePoolSample`
* `VSphereClusterSample`
* `VSphereSnapshotVmSample`

### Exemple d&apos;hôte VSphere

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nom
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cpu.totalMHz`
      </td>

      <td>
        Somme des MHz pour tous les cœurs individuels de l&apos;hôte
      </td>
    </tr>

    <tr>
      <td>
        `cpu.coreMHz`
      </td>

      <td>
        Vitesse des cœurs du processeur
      </td>
    </tr>

    <tr>
      <td>
        `cpu.available`
      </td>

      <td>
        Quantité de MHz CPU libre dans l&apos;hôte
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Utilisation du processeur sur tous les cœurs de l&apos;hôte en MHz
      </td>
    </tr>

    <tr>
      <td>
        `cpu.percent`
      </td>

      <td>
        Pourcentage d&apos;utilisation du processeur dans l&apos;hôte
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Nombre de cœurs de processeur physiques sur l&apos;hôte. Les cœurs de processeur physiques sont les processeurs contenus dans un packagede processeur
      </td>
    </tr>

    <tr>
      <td>
        `cpu.threads`
      </td>

      <td>
        Nombre de threads CPU physiques sur l&apos;hôte
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalMiB`
      </td>

      <td>
        Capacité totale des disques montés sur l&apos;hôte, en Mio
      </td>
    </tr>

    <tr>
      <td>
        `mem.free`
      </td>

      <td>
        Quantité de mémoire disponible dans l&apos;hôte, en Mio
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Quantité de mémoire utilisée dans l&apos;hôte, en Mio
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Capacité totale de mémoire de l&apos;hôte, en Mio
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Nombre de machines virtuelles dans l&apos;hôte
      </td>
    </tr>

    <tr>
      <td>
        `hypervisorHostname`
      </td>

      <td>
        Nom de l&apos;hôte
      </td>
    </tr>

    <tr>
      <td>
        `uuid`
      </td>

      <td>
        L&apos;identification du BIOS matériel
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Nom du data center lié à l&apos;hébergeur
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Nom du cluster lié à l&apos;hôte
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolNameList`
      </td>

      <td>
        Liste des noms des pools de ressources liés à l&apos;hôte
      </td>
    </tr>

    <tr>
      <td>
        `datastoreNameList`
      </td>

      <td>
        Liste des noms des magasins de données liés à l&apos;hôte
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        emplacement du centre de données
      </td>
    </tr>

    <tr>
      <td>
        `networkNameList`
      </td>

      <td>
        Liste des noms de réseaux liés à l&apos;hôte
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Le statut est inconnu
        * `green`: L&apos;entité est OK
        * `yellow`: L&apos;entité pourrait avoir un problème
        * `red`: L&apos;entité a définitivement un problème
      </td>
    </tr>

    <tr>
      <td>
        `connectionState`
      </td>

      <td>
        L&apos;état de la connexion de l&apos;hôte :

        * `connected`:Connecté au serveur. Pour ESX Server, il s’agit du paramètre par défaut.
        * `disconnected`: L&apos;utilisateur a explicitement désactivé l&apos;hôte. VirtualCenter ne s&apos;attend pas à recevoir de pulsations de l&apos;hôte. La prochaine fois qu&apos;un battement de cœur est reçu, l&apos;hôte est à nouveau déplacé vers l&apos;état connecté et un événement est enregistré.
        * `notResponding`: VirtualCenter ne reçoit pas de pulsations du serveur. L&apos;état passe automatiquement à connecté une fois que les battements de cœur sont à nouveau reçus. Cet état est généralement utilisé pour déclencher une alarme sur l&apos;hôte.
      </td>
    </tr>

    <tr>
      <td>
        `inMaintenanceMode`
      </td>

      <td>
        L&apos;indicateur pour indiquer si l&apos;hôte est ou non en mode maintenance. Cet indicateur est défini lorsque l&apos;hôte est entré en mode maintenance. Il n&apos;est pas défini lors de la phase d&apos;entrée en mode maintenance.
      </td>
    </tr>

    <tr>
      <td>
        `inQuarantineMode`
      </td>

      <td>
        L&apos;indicateur pour indiquer si l&apos;hôte est ou non en mode quarantaine. `InfraUpdateHa` recommandera de définir cet indicateur en fonction du `HealthUpdates` reçu par le `HealthUpdateProviders` configuré pour le cluster.

        Il sera recommandé à un hôte signalé comme dégradé d&apos;entrer en mode quarantaine, tandis qu&apos;à un hôte signalé comme sain il sera recommandé de quitter le mode quarantaine. L&apos;exécution de ces actions recommandées définira cet indicateur.

        Les hôtes en mode quarantaine seront évités par vSphere DRS tant que la consolidation accrue dans le cluster n&apos;affecte pas négativement les performances de la VM.
      </td>
    </tr>

    <tr>
      <td>
        `powerState`
      </td>

      <td>
        L&apos;état d&apos;alimentation de l&apos;hôte :

        * `poweredOff`:L&apos;hôte a été spécifiquement mis hors tension par l&apos;utilisateur via VirtualCenter. Cet état n&apos;est pas un état certain, car après que VirtualCenter a émis la commande de mise hors tension de l&apos;hôte, l&apos;hôte peut planter ou tuer tous les processus mais ne pas parvenir à s&apos;éteindre.
        * `poweredOn`: L&apos;hôte est sous tension. Un hôte qui entre en mode veille est également dans cet état.
        * `standBy`:L&apos;hôte a été spécifiquement mis en mode veille, soit explicitement par l&apos;utilisateur, soit automatiquement par DPM. Cet état n&apos;est pas un état certain, car après que VirtualCenter a émis la commande pour mettre l&apos;hôte en état de veille, l&apos;hôte peut planter ou tuer tous les processus mais ne pas s&apos;éteindre. Un hôte qui quitte le mode veille est également dans cet état.
        * `unknown`: Si l&apos;hôte est déconnecté ou `notResponding`, nous connaissons son état d&apos;alimentation, donc l&apos;hôte est marqué comme `unknown`.
      </td>
    </tr>

    <tr>
      <td>
        `standbyMode`
      </td>

      <td>
        Le mode veille de l&apos;hôte. La propriété est uniquement renseignée par le serveur vCenter. Si la requête est effectuée directement depuis l&apos;hôte ESX, la propriété est `unset`.

        * `entering`: L&apos;hôte entre en mode veille.
        * `exiting`: L&apos;hôte quitte le mode veille.
        * `in`: L&apos;hôte est en mode veille.
        * `none`: L&apos;hôte n&apos;est pas en mode veille et n&apos;est pas en train d&apos;entrer ou de sortir du mode veille.
      </td>
    </tr>

    <tr>
      <td>
        `cryptoState`
      </td>

      <td>
        état chiffré de l&apos;hôte. Les valeurs valides sont énumérées par le type CryptoState :

        * `incapable`:L&apos;hôte n&apos;est pas sûr pour recevoir du matériel sensible.
        * `prepared`:L&apos;hôte est prêt à recevoir du matériel sensible mais ne dispose pas encore d&apos;une clé d&apos;hôte définie.
        * `safe`:L&apos;hôte est sécurisé en termes de cryptographie et dispose d&apos;un ensemble de clés d&apos;hôte.
      </td>
    </tr>

    <tr>
      <td>
        `bootTime`
      </td>

      <td>
        L&apos;heure à laquelle l&apos;hôte a été démarré.
      </td>
    </tr>
  </tbody>
</table>

### Exemple de VSphereVm [#vspherevirtualmachine]

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nom
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Taille de la mémoire de la machine virtuelle, en Mio
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Statistiques d&apos;utilisation de la mémoire invitée, en Mio. C&apos;est ce qu&apos;on appelle également la mémoire invité active. La valeur peut être comprise entre `0` et la taille de mémoire configurée de la machine virtuelle. Valable pendant que la machine virtuelle est en cours d&apos;exécution.
      </td>
    </tr>

    <tr>
      <td>
        `mem.free`
      </td>

      <td>
        Mémoire invité disponible, en MiB. La valeur peut être comprise entre `0` et la taille de mémoire configurée de la machine virtuelle. Valable pendant que la machine virtuelle est en cours d&apos;exécution.
      </td>
    </tr>

    <tr>
      <td>
        `mem.ballooned`
      </td>

      <td>
        La taille du pilote de ballon dans la machine virtuelle, en Mio. L&apos;hôte gonflera le pilote de ballon pour récupérer la mémoire physique de la machine virtuelle. C’est un signe qu’il y a une pression de mémoire sur l’hôte.
      </td>
    </tr>

    <tr>
      <td>
        `mem.swapped`
      </td>

      <td>
        La partie de mémoire, en Mio, accordée à cette machine virtuelle à partir de l&apos;espace de swap de l&apos;hôte. C’est un signe qu’il y a une pression de mémoire sur l’hôte.
      </td>
    </tr>

    <tr>
      <td>
        `mem.swappedSsd`
      </td>

      <td>
        La quantité de mémoire échangée avec un périphérique de disque rapide tel qu&apos;un SSD, en Mio
      </td>
    </tr>

    <tr>
      <td>
        `cpu.allocationLimit`
      </td>

      <td>
        Limites de ressources pour le processeur, en MHz. Si la valeur est `-1`, il n&apos;y a pas de limite d&apos;allocation fixe.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Statistiques de performances de base du processeur, en MHz. Valable pendant que la machine virtuelle est en cours d&apos;exécution.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.hostUsagePercent`
      </td>

      <td>
        Pourcentage du processeur hôte utilisé par la machine virtuelle. Dans le cas où une limite est configurée, le pourcentage est calculé en prenant la limite comme total.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Nombre de processeurs dans la machine virtuelle
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalMiB`
      </td>

      <td>
        Espace de stockage total, dédié à cette machine virtuelle dans tous les magasins de données, en Mio
      </td>
    </tr>

    <tr>
      <td>
        `ipAddress`
      </td>

      <td>
        Adresse IP principale de l&apos;invité, si disponible
      </td>
    </tr>

    <tr>
      <td>
        `ipAddresses`
      </td>

      <td>
        Liste des IP associées à la VM (sauf `ipAddress`). Un caractère de barre verticale ou de tuyau (`|`) est utilisé comme séparateur.
      </td>
    </tr>

    <tr>
      <td>
        `connectionState`
      </td>

      <td>
        Indique si la machine virtuelle est disponible ou non pour la gestion :

        * `connected`: Le serveur a accès à la machine virtuelle.
        * `disconnected`:Le serveur est actuellement déconnecté de la machine virtuelle, car son hôte est déconnecté.
        * `inaccessible`:Un ou plusieurs fichiers de configuration de la machine virtuelle sont inaccessibles.
        * `invalid`: Le format de configuration de la machine virtuelle n&apos;est pas valide.
        * `orphaned`: La machine virtuelle n&apos;est plus enregistrée sur son hôte associé.
      </td>
    </tr>

    <tr>
      <td>
        `powerState`
      </td>

      <td>
        L’état d’alimentation actuel de la machine virtuelle : `poweredOff`, `poweredOn` ou `suspended`.
      </td>
    </tr>

    <tr>
      <td>
        `guestHeartbeatStatus`
      </td>

      <td>
        * `gray`:Le statut est inconnu.
        * `green`: L&apos;entité est OK.
        * `yellow`: L&apos;entité pourrait avoir un problème.
        * `red`:L&apos;entité a définitivement un problème.
      </td>
    </tr>

    <tr>
      <td>
        `operatingSystem`
      </td>

      <td>
        système d&apos;exploitation de la machine virtuelle
      </td>
    </tr>

    <tr>
      <td>
        `guestFullName`
      </td>

      <td>
        Nom complet du système d&apos;exploitation invité, s&apos;il est disponible à partir des outils invités
      </td>
    </tr>

    <tr>
      <td>
        `hypervisorHostname`
      </td>

      <td>
        Nom de l&apos;hôte sur lequel la machine virtuelle est exécutée
      </td>
    </tr>

    <tr>
      <td>
        `instanceUuid`
      </td>

      <td>
        Identification unique de la machine virtuelle
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Nom du data center
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Nom du cluster
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolNameList`
      </td>

      <td>
        Liste des noms des pools de ressources
      </td>
    </tr>

    <tr>
      <td>
        `datastoreNameList`
      </td>

      <td>
        Liste des noms des magasins de données
      </td>
    </tr>

    <tr>
      <td>
        `networkNameList`
      </td>

      <td>
        Liste des noms de réseaux
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        emplacement du centre de données
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`:Le statut est inconnu.
        * `green`: L&apos;entité est OK.
        * `yellow`: L&apos;entité pourrait avoir un problème.
        * `red`:L&apos;entité a définitivement un problème.
      </td>
    </tr>

    <tr>
      <td>
        `disk.suspendMemory`
      </td>

      <td>
        Taille du fichier instantané (octets).
      </td>
    </tr>

    <tr>
      <td>
        `disk.suspendMemoryUnique`
      </td>

      <td>
        Taille du fichier instantané, blocs uniques (octets).
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalUncommittedMiB`
      </td>

      <td>
        Espace de stockage supplémentaire potentiellement utilisé par cette machine virtuelle sur tous les magasins de données. Il s’agit essentiellement d’un agrégat de propriétés non validées dans tous les magasins de données sur lesquels se trouve cette machine virtuelle (mébioctets).
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalUnsharedMiB`
      </td>

      <td>
        Espace de stockage total occupé par la machine virtuelle sur tous les magasins de données, qui n&apos;est partagé avec aucune autre machine virtuelle (mébioctets).
      </td>
    </tr>

    <tr>
      <td>
        `mem.hostUsage`
      </td>

      <td>
        Utilisation de la mémoire de l&apos;hôte (Mébioctets).
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolName`
      </td>

      <td>
        Nom du pool de ressources.
      </td>
    </tr>

    <tr>
      <td>
        `vmConfigName`
      </td>

      <td>
        Nom de configuration de la machine virtuelle.
      </td>
    </tr>

    <tr>
      <td>
        `vmHostname`
      </td>

      <td>
        Vm nom d&apos;hôte.
      </td>
    </tr>
  </tbody>
</table>

### VSphereDatastoreSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nom
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `capacity`
      </td>

      <td>
        La capacité maximale de ce datastore, en Gio, si accessible est `true`
      </td>
    </tr>

    <tr>
      <td>
        `freeSpace`
      </td>

      <td>
        L&apos;espace disponible de ce datastore, en Gio, s&apos;il est accessible est `true`
      </td>
    </tr>

    <tr>
      <td>
        `uncommitted`
      </td>

      <td>
        L&apos;espace de stockage supplémentaire total, potentiellement utilisé par toutes les machines virtuelles de cette datastore, en Gio, s&apos;il est accessible `true`
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Nombre de machines virtuelles attachées au datastore
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        emplacement du centre de données
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        nom du centre de données
      </td>
    </tr>

    <tr>
      <td>
        `hostCount`
      </td>

      <td>
        Nombre d&apos;hôtes attachés au datastore
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`:Le statut est inconnu.
        * `green`: L&apos;entité est OK.
        * `yellow`: L&apos;entité pourrait avoir un problème.
        * `red`:L&apos;entité a définitivement un problème.
      </td>
    </tr>

    <tr>
      <td>
        `accessible`
      </td>

      <td>
        État de connectivité du datastore. Si cette valeur est définie sur `false`, la datastore n&apos;est pas accessible.
      </td>
    </tr>

    <tr>
      <td>
        `url`
      </td>

      <td>
        Localisateur unique pour le datastore, s&apos;il est accessible `true`
      </td>
    </tr>

    <tr>
      <td>
        `fileSystemType`
      </td>

      <td>
        Type de volume du système de fichiers, tel que `VMFS` ou `NFS`
      </td>
    </tr>

    <tr>
      <td>
        `name`
      </td>

      <td>
        Nom du datastore
      </td>
    </tr>

    <tr>
      <td>
        `nas.remoteHost`
      </td>

      <td>
        Hôte qui exécute le serveur NFS/CIFS
      </td>
    </tr>

    <tr>
      <td>
        `nas.remotePath`
      </td>

      <td>
        Chemin distant du point de montage NFS/CIFS
      </td>
    </tr>
  </tbody>
</table>

### VSphereDatacenterSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nom
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `datastore.totalUsedGiB`
      </td>

      <td>
        Espace total utilisé dans les magasins de données, en Gio
      </td>
    </tr>

    <tr>
      <td>
        `datastore.totalFreeGiB`
      </td>

      <td>
        Espace libre total dans les magasins de données, en Gio
      </td>
    </tr>

    <tr>
      <td>
        `datastore.totalGiB`
      </td>

      <td>
        Taille totale des magasins de données, en Gio
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Nombre total de CPU par data center
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsagePercentage`
      </td>

      <td>
        Utilisation totale du processeur, en pourcentage
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Utilisation totale du processeur, en MHz
      </td>
    </tr>

    <tr>
      <td>
        `cpu.totalMHz`
      </td>

      <td>
        Capacité totale du processeur, en MHz
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Utilisation totale de la mémoire, en Mio
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Mémoire totale, en Mio
      </td>
    </tr>

    <tr>
      <td>
        `mem.usagePercentage`
      </td>

      <td>
        Utilisation totale de la mémoire en pourcentage
      </td>
    </tr>

    <tr>
      <td>
        `clusters`
      </td>

      <td>
        Nombre total cluster par data center
      </td>
    </tr>

    <tr>
      <td>
        `resourcePools`
      </td>

      <td>
        Nombre total de pools de ressources par data center
      </td>
    </tr>

    <tr>
      <td>
        `datastores`
      </td>

      <td>
        Nombre total de magasins de données par data center
      </td>
    </tr>

    <tr>
      <td>
        `networks`
      </td>

      <td>
        Nombre total d&apos;adaptateurs réseau par data center
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: Le statut est inconnu
        * `green`: L&apos;entité est OK
        * `yellow`: L&apos;entité pourrait avoir un problème
        * `red`: L&apos;entité a définitivement un problème
      </td>
    </tr>

    <tr>
      <td>
        `hostCount`
      </td>

      <td>
        Nombre total d&apos;hôtes système par data center
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Nombre total de machines virtuelles par data center
      </td>
    </tr>
  </tbody>
</table>

### Exemple de pool de ressources VSphere

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nom
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cpu.TotalMHz`
      </td>

      <td>
        Capacité totale du pool de ressources CPU, en MHz
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Utilisation du processeur du pool de ressources, en MHz
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Mémoire totale réservée au pool de ressources, en Mio
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Utilisation de la mémoire du pool de ressources, en Mio
      </td>
    </tr>

    <tr>
      <td>
        `mem.free`
      </td>

      <td>
        Pool de ressources mémoire disponible, en MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.ballooned`
      </td>

      <td>
        Taille du pilote de ballon dans le pool de ressources, en Mio
      </td>
    </tr>

    <tr>
      <td>
        `mem.swapped`
      </td>

      <td>
        Partie de mémoire, en Mio, accordée à ce pool de ressources à partir de l&apos;espace de swap de l&apos;hôte
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Nombre de machines virtuelles dans le pool de ressources
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`:Le statut est inconnu.
        * `green`: L&apos;entité est OK.
        * `yellow`: L&apos;entité pourrait avoir un problème.
        * `red`:L&apos;entité a définitivement un problème.
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolName`
      </td>

      <td>
        Nom du pool de ressources
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        emplacement du centre de données
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Nom du data center
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Nom du cluster
      </td>
    </tr>
  </tbody>
</table>

### Exemple de cluster VSphere

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nom
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cpu.totalEffectiveMHz`
      </td>

      <td>
        Ressources CPU effectives, en MHz, disponibles pour les machines virtuelles. Il s’agit du niveau de ressources effectives agrégées de tous les hôtes en cours d’exécution. Les hôtes en mode maintenance ou qui ne répondent pas ne sont pas comptabilisés. Les ressources utilisées par la console de service VMware ne sont pas incluses dans l’agrégat. Cette valeur représente la quantité de ressources disponibles pour le pool de ressources racine pour l&apos;exécution des machines virtuelles.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.totalMHz`
      </td>

      <td>
        Ressources CPU agrégées de tous les hôtes, en MHz. Il ne filtre pas le processeur utilisé par le système ou lié aux hôtes en cours de maintenance.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Nombre de cœurs de processeur physiques. Les cœurs de processeur physiques sont les processeurs contenus dans un package CPU.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.threads`
      </td>

      <td>
        Nombre agrégé de threads CPU.
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Ressources mémoire agrégées de tous les hôtes, en Mio. Il ne filtre pas la mémoire utilisée par le système ou liée aux hôtes en cours de maintenance.
      </td>
    </tr>

    <tr>
      <td>
        `mem.effectiveSize`
      </td>

      <td>
        Ressources de mémoire effectives, en Mio, disponibles pour exécuter des machines virtuelles. Il s’agit du niveau de ressources effectives agrégées de tous les hôtes en cours d’exécution. Les hôtes en mode maintenance ou qui ne répondent pas ne sont pas comptabilisés. Les ressources utilisées par la console de service VMware ne sont pas incluses dans l’agrégat. Cette valeur représente la quantité de ressources disponibles pour le pool de ressources racine pour l&apos;exécution des machines virtuelles.
      </td>
    </tr>

    <tr>
      <td>
        `effectiveHosts`
      </td>

      <td>
        Nombre total d&apos;hôtes effectifs. Ce nombre exclut les hôtes en maintenance.
      </td>
    </tr>

    <tr>
      <td>
        `hosts`
      </td>

      <td>
        Nombre total d&apos;hôtes
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`:Le statut est inconnu.
        * `green`: L&apos;entité est OK.
        * `yellow`: L&apos;entité pourrait avoir un problème.
        * `red`:L&apos;entité a définitivement un problème.
      </td>
    </tr>

    <tr>
      <td>
        `datastoreList`
      </td>

      <td>
        Liste des datastore utilisées par le cluster. Un caractère de barre verticale ou de tuyau (`|`) est utilisé comme séparateur.
      </td>
    </tr>

    <tr>
      <td>
        `hostList`
      </td>

      <td>
        Liste des hôtes appartenant au cluster. Un caractère de barre verticale ou de tuyau (`|`) est utilisé comme séparateur.
      </td>
    </tr>

    <tr>
      <td>
        `networkList`
      </td>

      <td>
        Liste des réseaux attachés au cluster. Un caractère de barre verticale ou de tuyau (`|`) est utilisé comme séparateur.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.vmotionRate`
      </td>

      <td>
        seuil pour les ClusterRecommendations générées. DRS génère uniquement les recommandations qui sont supérieures au vmotionRate spécifié. Les notes varient de 1 à 5. Ce paramètre s&apos;applique aux clusters DRS manuels, partiellement automatisés et entièrement automatisés.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.restartPriorityTimeout`
      </td>

      <td>
        Temps maximum pendant lequel les machines virtuelles de priorité inférieure doivent attendre que les machines virtuelles de priorité supérieure soient prêtes (secondes).
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        nom du centre de données.
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        emplacement du centre de données.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.enabled`
      </td>

      <td>
        Drapeau indiquant si le service est activé ou non.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.enableVmBehaviorOverrides`
      </td>

      <td>
        Indicateur qui indique si les remplacements de comportement DRS pour les machines virtuelles individuelles (ClusterDrsVmConfigInfo) sont activés.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.defaultVmBehavior`
      </td>

      <td>
        Spécifie le comportement DRS par défaut à l’échelle du cluster pour les machines virtuelles. Vous pouvez remplacer le comportement par défaut d’une machine virtuelle en utilisant l’objet ClusterDrsVmConfigInfo.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.enabled`
      </td>

      <td>
        Drapeau pour indiquer si la fonctionnalité vSphere HA est activée ou non.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.admissionControlEnabled`
      </td>

      <td>
        Drapeau qui détermine si le contrôle d&apos;admission strict est activé
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.isolationResponse`
      </td>

      <td>
        Indique si la machine virtuelle doit ou non être mise hors tension si un hôte détermine qu&apos;elle est isolée du reste de la ressource calculer.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.restartPriority`
      </td>

      <td>
        Priorité de redémarrage pour une machine virtuelle.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.hostMonitoring`
      </td>

      <td>
        Détermine si HA redémarre les machines virtuelles après la défaillance d&apos;un hôte.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.vmMonitoring`
      </td>

      <td>
        Niveau de service de monitoring de l&apos;état de la machine virtuelle HA.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.vmComponentProtecting`
      </td>

      <td>
        Cette propriété indique si le service de protection des composants de machine virtuelle vSphere HA est activé.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.hbDatastoreCandidatePolicy`
      </td>

      <td>
        La politique sur les magasins de données qui seront utilisés par vCenter Server pour choisir les magasins de données de pulsation : allFeasibleDs, allFeasibleDsWithUserPreference, userSelectedDs
      </td>
    </tr>
  </tbody>
</table>

### VSphereSnapshotVmSample [#vspheresnapshot]

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nom
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `snapshotTreeInfo`
      </td>

      <td>
        Informations sur l&apos;arbre pour l&apos;instantané. Es:cluster:VM:Snapshot1:Snapshot2
      </td>
    </tr>

    <tr>
      <td>
        `name`
      </td>

      <td>
        Nom de l&apos;instantané
      </td>
    </tr>

    <tr>
      <td>
        `creationTime`
      </td>

      <td>
        Heure de création de l&apos;instantané
      </td>
    </tr>

    <tr>
      <td>
        `powerState`
      </td>

      <td>
        L&apos;état d&apos;alimentation de la machine virtuelle lorsque cet instantané a été pris
      </td>
    </tr>

    <tr>
      <td>
        `snapshotId`
      </td>

      <td>
        L&apos;identifiant unique qui distingue cet instantané des autres instantanés de la machine virtuelle
      </td>
    </tr>

    <tr>
      <td>
        `quiesced`
      </td>

      <td>
        Drapeau pour indiquer si l&apos;instantané a été créé ou non avec l&apos;option « quiesce », garantissant un état cohérent du système de fichiers
      </td>
    </tr>

    <tr>
      <td>
        `backupManifest`
      </td>

      <td>
        Le chemin relatif du snapshotDirectory pointant vers le manifeste de sauvegarde. Disponible uniquement pour certains instantanés mis au repos
      </td>
    </tr>

    <tr>
      <td>
        `description`
      </td>

      <td>
        Description de l&apos;instantané
      </td>
    </tr>

    <tr>
      <td>
        `replaySupported`
      </td>

      <td>
        Drapeau pour indiquer si cet instantané est associé à une session d&apos;enregistrement sur la machine virtuelle qui peut être relue
      </td>
    </tr>

    <tr>
      <td>
        `totalMemoryInDisk`
      </td>

      <td>
        Taille totale de la mémoire sur le disque.
      </td>
    </tr>

    <tr>
      <td>
        `totalUniqueMemoryInDisk`
      </td>

      <td>
        Taille totale du fichier correspondant aux blocs de fichiers qui ont été alloués de manière unique pour stocker la mémoire. En d’autres termes, si le stockage sous-jacent prend en charge le partage de blocs de fichiers entre les fichiers de disque, la propriété correspond à la taille des blocs de fichiers qui ont été alloués uniquement dans le contexte de ce fichier. Il n&apos;inclut pas les blocs partagés qui ont été alloués dans d&apos;autres fichiers. Cette propriété sera désactivée si l&apos;implémentation sous-jacente n&apos;est pas en mesure de calculer ces informations.
      </td>
    </tr>

    <tr>
      <td>
        `totalDisk`
      </td>

      <td>
        Taille totale des fichiers instantanés sur le disque
      </td>
    </tr>

    <tr>
      <td>
        `totalUniqueDisk`
      </td>

      <td>
        Taille totale du fichier correspondant aux blocs de fichiers qui ont été alloués de manière unique pour stocker les données d&apos;instantané sur le disque. En d’autres termes, si le stockage sous-jacent prend en charge le partage de blocs de fichiers entre les fichiers de disque, la propriété correspond à la taille des blocs de fichiers qui ont été alloués uniquement dans le contexte de ce fichier. Il n&apos;inclut pas les blocs partagés qui ont été alloués dans d&apos;autres fichiers. Cette propriété sera désactivée si l&apos;implémentation sous-jacente n&apos;est pas en mesure de calculer ces informations.
      </td>
    </tr>

    <tr>
      <td>
        `datastorePathDisk`
      </td>

      <td>
        Chemin d&apos;accès au fichier disque dans le datastore
      </td>
    </tr>

    <tr>
      <td>
        `datastorePathMemory`
      </td>

      <td>
        chemin du fichier mémoire dans le datastore
      </td>
    </tr>
  </tbody>
</table>

## Dépannage [#troubleshooting]

<CollapserGroup>
  <Collapser id="data-gaps" title="Lacunes dans les données rapportées">
    L’une des raisons possibles des lacunes de données pourrait être que l’intégration prend trop de temps pour collecter et traiter les données de vCenter. Dans le cas où l&apos;intégration dépasse le [délai d&apos;attente](/docs/infrastructure/host-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/#timeout), qui par défaut est `120s`, l&apos;agent infrastructure arrêtera l&apos;intégration et un message de log comme le suivant sera imprimé :

    ```shell
    level=warn msg="HeartBeat timeout exceeded after 120000000000" integration_name=nri-vsphere
    ```

    Pour résoudre ce problème, vous pouvez étendre le paramètre [de délai d&apos;attente](/docs/infrastructure/host-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/#timeout) dans le fichier de configuration.

    ```yaml
    integrations:
    - name: nri-vsphere
      env:
        # Integration configuration parameters.

      interval: 120s

      timeout: 300s
    ```
  </Collapser>
</CollapserGroup>