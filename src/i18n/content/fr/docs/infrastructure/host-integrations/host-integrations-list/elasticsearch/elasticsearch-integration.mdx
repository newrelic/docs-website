---
title: Elasticsearch monitoring Intégration
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: 'New Relic''s Elasticsearch integration: what data it reports and how to configure it.'
freshnessValidatedDate: never
translationType: machine
---

Notre intégration Elasticsearch collecte et envoie l&apos;inventaire et les métriques de votre cluster [Elasticsearch](https://www.elastic.co/) à notre plateforme, où vous pouvez voir l&amp;apos;état de votre environnement Elasticsearch. Nous collectons des métriques au niveau du cluster, du nœud et de l&amp;apos;index afin que vous puissiez trouver plus facilement la source de tout problème.

Pour installer Elasticsearch monitoring l&apos;intégration , suivez les étapes suivantes :

1. [Installer et activer l&apos;intégration](#install).
2. [Configurer l&apos;intégration](#config).
3. [Rechercher et utiliser des données](#find-and-use).
4. En option, consultez [les paramètres de configuration d&apos;Elasticsearch](/docs/infrastructure/host-integrations/host-integrations-list/elasticsearch/elasticsearch-config).

## Compatibilité et exigences [#req]

### Versions d&apos;Elasticsearch [#elasticsearch-versions]

Notre intégration est compatible avec Elasticsearch 7.x à 8.X.

### Système d&apos;exploitation pris en charge [#supported-os]

* Windows<img style={{ width: '32px', height: '32px'}} class="inline" title="Windows" alt="Windows" src="/images/os_icon_windows.webp" />
* Linux<img style={{ width: '32px', height: '32px'}} class="inline" title="Linux" alt="Linux" src="/images/os_icon_linux.webp" />

Pour une liste complète des versions spécifiques Windows et Linux, consultez le tableau des [systèmes d&apos;exploitation compatibles](/docs/infrastructure/install-infrastructure-agent/get-started/requirements-infrastructure-agent/#operating-systems).

### exigences système [#system-reqs]

* Un compte New Relic. Vous n&apos;en avez pas ? [Inscrivez-vous gratuitement !](https://newrelic.com/signup) Aucune carte de crédit requise.

* Si Elasticsearch ne s&apos;exécute pas sur Kubernetes ou Amazon ECS, [installez l&apos;agent d&apos;infrastructure](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic) sur un hôte qui exécute Elasticsearch. Sinon:

  * Si vous exécutez sur<img style={{ width: '32px', height: '32px'}} class="inline" title="Kubernetes" alt="Kubernetes" src="/images/os_icon_k8.webp">Kubernetes, voir [ces exigences](/docs/monitor-service-running-kubernetes#requirements).</img>
  * Si vous exécutez sur<img style={{ width: '32px', height: '32px'}} class="inline" title="ECS" alt="ECS" src="/images/os_icon_ecs.webp">Amazon ECS, consultez [ces exigences](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).</img>

## Installer et activer l&apos;intégration [#install]

Pour installer l&apos;intégration Elasticsearch, suivez les instructions correspondant à votre environnement :

### Installation de Linux [#linux]

1. Suivez les instructions pour [installer une intégration](/docs/install-integrations-package) et remplacez la variable `INTEGRATION_FILE_NAME` par `nri-elasticsearch`.

2. Changez de répertoire pour accéder au dossier configuration de l&apos;intégration en exécutant :

   ```shell
   cd /etc/newrelic-infra/integrations.d
   ```

3. Copiez l’exemple de fichier de configuration en exécutant :

   ```shell
   sudo cp elasticsearch-config.yml.sample elasticsearch-config.yml
   ```

4. Modifiez le fichier de configuration `elasticsearch-config.yml` avec votre éditeur préféré. Découvrez quelques [exemples de fichiers de configuration](#examples).

5. Pour activer l&apos;analyse automatique des erreurs Elasticsearch et logtransfert, copiez (ou renommez) le fichier `elasticsearch-log.yml.example` en `elasticsearch-log.yml`. Pas besoin de redémarrer l&amp;apos;agent.

<DNT>
  **Example**
</DNT>

```shell
sudo cp /etc/newrelic-infra/logging.d/elasticsearch-log.yml.example /etc/newrelic-infra/logging.d/elasticsearch-log.yml
```

### Autres environnements [#other-env]

<CollapserGroup>
  <Collapser
    id="windows-install"
    title={<><img src="/images/os_icon_windows.webp" title="Windows installation" alt="Windows installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }} /></>
    }
  >
    1. Téléchargez l&apos;image du programme d&apos;installation `nri-elasticsearch` .MSI depuis :

       [https://download.newrelic.com/infrastructure\_agent/windows/integrations/nri-elasticsearch/nri-elasticsearch-amd64.msi](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-elasticsearch/nri-elasticsearch-amd64.msi)

    2. Pour installer à partir de l’invite de commande Windows, exécutez :

       ```
       msiexec.exe /qn /i PATH\TO\nri-elasticsearch-amd64.msi
       ```

    3. Dans le répertoire de l&apos;intégration, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, créez une copie de l&amp;apos;exemple de fichier de configuration en exécutant :

       ```
       cp elasticsearch-config.yml.sample elasticsearch-config.yml
       ```

    4. Modifiez le fichier `elasticsearch-config.yml`comme décrit dans [les fichiers d&apos;exemple elasticsearch-config.yml](#examples).
  </Collapser>

  <Collapser
    id="ecs-install"
    title={<>
      <img src="/images/os_icon_ecs.webp" title="Amazon ECS installation" alt="Amazon ECS installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }}>{' '} Installation d'Amazon ECS</img>
    </>
    }
  >
    Voir [le service de monitoring exécuté sur ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
  </Collapser>

  <Collapser
    id="k8s-install"
    title={<><img src="/images/os_icon_k8.webp" title="Kubernetes installation" alt="Kubernetes installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }} /></>
    }
  >
    Voir [le service de monitoring exécuté sur Kubernetes](/docs/monitor-service-running-kubernetes).
  </Collapser>
</CollapserGroup>

Notes supplémentaires :

* <DNT>**Advanced:**</DNT> les intégrations sont également disponibles au [formattarball ](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball)pour permettre une installation en dehors d&amp;apos;un gestionnaire de paquets.
* <DNT>**On-host integrations do not automatically update.**</DNT> Pour de meilleurs résultats, mettez régulièrement [à jour le package d&apos;intégration](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) et [l&apos;agent d&apos;infrastructure](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

<InstallFeedback />

## Configurer l&apos;intégration [#config]

Il existe plusieurs façons de configurer l&apos;intégration, selon la manière dont elle a été installée :

* Si activé via<img style={{ width: '32px', height: '32px'}} class="inline" title="Kubernetes" alt="Kubernetes" src="/images/os_icon_k8.webp" />Kubernetes, voir [services de monitoring exécutés sur Kubernetes](/docs/monitor-service-running-kubernetes).
* Si activé via<img style={{ width: '32px', height: '32px'}} class="inline" title="ECS" alt="ECS" src="/images/os_icon_ecs.webp" />Amazon ECS, voir [les services de monitoring exécutés sur ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
* Si installé sur l&apos;hôte, modifiez la configuration dans le fichier de configuration YAML de l&apos;intégration, `elasticsearch-config.yml`. La configuration au format YAML d&amp;apos;une intégration est l&amp;apos;endroit où vous pouvez placer les informations de connexion requises et configurer la manière dont les données sont collectées. Les options que vous modifiez dépendent de votre configuration et de vos préférences. Le fichier configuration contient des paramètres communs applicables à toutes les intégrations, tels que `interval`, `timeout`, `inventory_source`. Pour tout savoir sur ces paramètres courants, reportez-vous à notre document [sur les formats de configuration](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) .

<Callout variant="important">
  Si vous utilisez toujours nos legacy fichiers configuration ou de définition, vérifiez le [format configuration standard](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/).
</Callout>

## Fichiers d&apos;exemple elasticsearch-config.yml [#examples]

<CollapserGroup>
  <Collapser id="basic-config" title="Configuration de base">
    Il s&apos;agit de la configuration de base utilisée pour collecter les métriques et l&apos;inventaire à partir de votre hôte local :

    ```yaml
    integrations:
      - name: nri-elasticsearch
        env:
          HOSTNAME: localhost
          PORT: 9200
          USERNAME: elasticsearch_user
          PASSWORD: elasticsearch_password
          CONFIG_PATH: /etc/elasticsearch/elasticsearch.yml
        interval: 15s
        labels:
          environment: production
        inventory_source: config/elasticsearch
    ```
  </Collapser>

  <Collapser id="basic-intervals" title="configuration de base avec différents intervalles métriques et d'inventaire">
    Cette configuration collecte des métriques toutes les 15 secondes et un inventaire toutes les 60 secondes :

    ```yaml
    integrations:
      - name: nri-elasticsearch
        env:
          METRICS: true
          HOSTNAME: localhost
          PORT: 9200
          USERNAME: elasticsearch_user
          PASSWORD: elasticsearch_password
          REMOTE_MONITORING: true
        interval: 15s
        labels:
          environment: production

      - name: nri-elasticsearch
        env:
          INVENTORY: true
          HOSTNAME: localhost
          PORT: 9200
          USERNAME: elasticsearch_user
          PASSWORD: elasticsearch_password
          CONFIG_PATH: /etc/elasticsearch/elasticsearch.yml
        interval: 60s
        labels:
          environment: production
        inventory_source: config/elasticsearch
    ```
  </Collapser>

  <Collapser id="envvar-replacement" title="Remplacement des variables d'environnement">
    Dans cette configuration nous utilisons la variable d&apos;environnement `ELASTIC_HOST` pour renseigner le paramètre nom d&amp;apos;hôte de l&amp;apos;intégration :

    ```yaml
    integrations:
      - name: nri-elasticsearch
        env:
          METRICS: "true"
          HOSTNAME: {{ELASTIC_HOST}}
          PORT: 9200
          USERNAME: elasticsearch_user
          PASSWORD: elasticsearch_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
    ```
  </Collapser>

  <Collapser id="multi-instance" title="Cluster monitoring">
    L&apos;intégration est capable de collecter toutes les métriques du cluster en se connectant simplement à l&apos;un des nœuds, en utilisant une configuration de base affichée avant que toutes les métriques du cluster puissent être récupérées.

    Une autre façon de configurer l&apos;intégration est de configurer le scraping de toutes les instances mais en activant le paramètre `MASTER_ONLY` qui fait que l&amp;apos;intégration ne collecte les métriques que si l&amp;apos;nstance scrapée est maître. Cela permet de partager la même configuration pour tous les nœuds et d&amp;apos;éviter la duplication des données.\
    Voici à quoi devrait ressembler le fichier de configuration de chacun des nœuds :

    ```yaml
    integrations:
      - name: nri-elasticsearch
        env:
          HOSTNAME: localhost
          PORT: 9200
          USERNAME: elasticsearch_user
          PASSWORD: elasticsearch_password
          MASTER_ONLY: "true"
          CONFIG_PATH: /etc/elasticsearch/elasticsearch.yml
        interval: 15s
        labels:
          environment: production
        inventory_source: config/elasticsearch
    ```
  </Collapser>
</CollapserGroup>

## Options de configuration pour l&apos;intégration [#config-options]

Pour en savoir plus sur la recherche et l&apos;utilisation de vos données, consultez [les paramètres de configuration d&apos;Elasticsearch](/docs/infrastructure/host-integrations/host-integrations-list/elasticsearch/elasticsearch-config).

## Rechercher et utiliser des données [#find-and-use]

Les données de ce service sont signalées à un [dashboard d&apos;intégration](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts).

Les données Elasticsearch sont attachées aux [types d’événements](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic) suivants :

* [`ElasticsearchClusterSample`](#cluster-metrics)
* [`ElasticsearchNodeSample`](#node-metrics)
* [`ElasticsearchCommonSample`](#common-metrics)
* [`ElasticsearchIndexSample`](#index-metrics)

Vous pouvez [interroger ces données](/docs/using-new-relic/data/understand-data/query-new-relic-data) à des fins de dépannage ou pour créer des graphiques et des dashboards personnalisés.

Pour en savoir plus sur la recherche et l&apos;utilisation de vos données, consultez comment [comprendre les données d&apos;intégration](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Métriques collectées par l&apos;intégration [#metrics]

L&apos;intégration Elasticsearch collecte les métriques suivantes. Chaque nom de métrique est préfixé par un indicateur de catégorie et un point, tel que `cluster.` ou `shards.`.

<CollapserGroup>
  <Collapser id="cluster-metrics" title="Événement ElasticsearchClusterSample">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            métrique
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `cluster.dataNodes`
          </td>

          <td>
            Le nombre de nœuds de données dans le cluster.
          </td>
        </tr>

        <tr>
          <td>
            `cluster.nodes`
          </td>

          <td>
            Le nombre de nœuds dans le cluster.
          </td>
        </tr>

        <tr>
          <td>
            `cluster.status`
          </td>

          <td>
            L’état de santé du cluster Elasticsearch : `red`, `yellow` ou `green`.
          </td>
        </tr>

        <tr>
          <td>
            `shards.active`
          </td>

          <td>
            Le nombre de fragments actifs dans le cluster.
          </td>
        </tr>

        <tr>
          <td>
            `shards.initializing`
          </td>

          <td>
            Le nombre de fragments en cours d&apos;initialisation.
          </td>
        </tr>

        <tr>
          <td>
            `shards.primaryActive`
          </td>

          <td>
            Le nombre de fragments primaires actifs dans le cluster.
          </td>
        </tr>

        <tr>
          <td>
            `shards.relocating`
          </td>

          <td>
            Le nombre de fragments qui se déplacent d’un nœud à un autre.
          </td>
        </tr>

        <tr>
          <td>
            `shards.unassigned`
          </td>

          <td>
            Le nombre de fragments qui ne sont pas attribués à un nœud.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="node-metrics" title="Événement ElasticsearchNodeSample">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            métrique
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `activeSearches`
          </td>

          <td>
            Le nombre de recherches actives.
          </td>
        </tr>

        <tr>
          <td>
            `activeSearchesInMilliseconds`
          </td>

          <td>
            Le temps passé sur la recherche.
          </td>
        </tr>

        <tr>
          <td>
            `breakers.estimatedSizeFieldDataCircuitBreakerInBytes`
          </td>

          <td>
            La taille estimée du disjoncteur de données de terrain, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `breakers.estimatedSizeParentCircuitBreakerInBytes`
          </td>

          <td>
            La taille estimée du disjoncteur parent, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `breakers.estimatedSizeRequestCircuitBreakerInBytes`
          </td>

          <td>
            La taille estimée du disjoncteur de demande, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `breakers.fieldDataCircuitBreakerTripped`
          </td>

          <td>
            Le nombre de fois où le disjoncteur de données de terrain s&apos;est déclenché.
          </td>
        </tr>

        <tr>
          <td>
            `breakers.parentCircuitBreakerTripped`
          </td>

          <td>
            Le nombre de fois que le disjoncteur parent s&apos;est déclenché.
          </td>
        </tr>

        <tr>
          <td>
            `breakers.requestCircuitBreakerTripped`
          </td>

          <td>
            Le nombre de fois où le disjoncteur de demande s&apos;est déclenché.
          </td>
        </tr>

        <tr>
          <td>
            `cache.cacheSizeIDInBytes`
          </td>

          <td>
            La taille du cache d&apos;identification, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `flush.indexFlushDisk`
          </td>

          <td>
            Le nombre de vidages d&apos;index sur le disque depuis le début.
          </td>
        </tr>

        <tr>
          <td>
            `flush.timeFlushIndexDiskInSeconds`
          </td>

          <td>
            Le temps passé à vider l&apos;index sur le disque.
          </td>
        </tr>

        <tr>
          <td>
            `fs.bytesAvailableJVMInBytes`
          </td>

          <td>
            Octets disponibles pour cette machine virtuelle Java sur ce magasin de fichiers, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `fs.bytesReadsInBytes`
          </td>

          <td>
            Le nombre total d&apos;octets lus à partir du magasin de fichiers, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `fs.bytesUserIoOperationsInBytes`
          </td>

          <td>
            Le nombre total d&apos;octets utilisés pour toutes les opérations I/O sur le magasin de fichiers, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `fs.iOOperations`
          </td>

          <td>
            Le nombre total d&apos;opérations I/O sur le magasin de fichiers.
          </td>
        </tr>

        <tr>
          <td>
            `fs.reads`
          </td>

          <td>
            Le nombre total de lectures à partir du magasin de fichiers.
          </td>
        </tr>

        <tr>
          <td>
            `fs.totalSizeInBytes`
          </td>

          <td>
            La taille totale du magasin de fichiers, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `fs.unallocatedBytesInBytes`
          </td>

          <td>
            Le nombre total d&apos;octets non alloués dans le magasin de fichiers, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `fs.writes`
          </td>

          <td>
            Le nombre total d&apos;écritures dans le magasin de fichiers.
          </td>
        </tr>

        <tr>
          <td>
            `fs.writesInBytes`
          </td>

          <td>
            Le nombre total d&apos;octets écrits dans le magasin de fichiers, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `get.currentRequestsRunning`
          </td>

          <td>
            Le nombre de requêtes GET en cours d&apos;exécution.
          </td>
        </tr>

        <tr>
          <td>
            `get.requestsDocumentExists`
          </td>

          <td>
            Le numéro de requête GET où le document existait.
          </td>
        </tr>

        <tr>
          <td>
            `get.requestsDocumentExistsInMilliseconds`
          </td>

          <td>
            Le temps passé sur la requête GET où le document existait.
          </td>
        </tr>

        <tr>
          <td>
            `get.requestsDocumentMissing`
          </td>

          <td>
            Le numéro de requête GET où le document était manquant.
          </td>
        </tr>

        <tr>
          <td>
            `get.requestsDocumentMissingInMilliseconds`
          </td>

          <td>
            Le temps passé sur la requête GET où le document était manquant.
          </td>
        </tr>

        <tr>
          <td>
            `get.timeGetRequestsInMilliseconds`
          </td>

          <td>
            Le temps passé sur la requête GET.
          </td>
        </tr>

        <tr>
          <td>
            `get.totalGetRequests`
          </td>

          <td>
            Le nombre de requêtes GET.
          </td>
        </tr>

        <tr>
          <td>
            `http.currentOpenConnections`
          </td>

          <td>
            Le nombre de connexions HTTP actuellement ouvertes.
          </td>
        </tr>

        <tr>
          <td>
            `http.openedConnections`
          </td>

          <td>
            Le nombre de connexions HTTP ouvertes.
          </td>
        </tr>

        <tr>
          <td>
            `indexing.docsCurrentlyDeleted`
          </td>

          <td>
            Le nombre de documents actuellement supprimés d&apos;un index.
          </td>
        </tr>

        <tr>
          <td>
            `indexing.documentsCurrentlyIndexing`
          </td>

          <td>
            Le nombre de documents actuellement indexés dans un index.
          </td>
        </tr>

        <tr>
          <td>
            `indexing.documentsIndexed`
          </td>

          <td>
            Le nombre de documents indexés dans un index.
          </td>
        </tr>

        <tr>
          <td>
            `indexing.timeDeletingDocumentsInMilliseconds`
          </td>

          <td>
            Le temps passé à supprimer des documents d&apos;un index.
          </td>
        </tr>

        <tr>
          <td>
            `indexing.timeIndexingDocumentsInMilliseconds`
          </td>

          <td>
            Le temps passé à indexer les documents dans un index.
          </td>
        </tr>

        <tr>
          <td>
            `indexing.totalDocumentsDeleted`
          </td>

          <td>
            Le nombre de documents supprimés d&apos;un index.
          </td>
        </tr>

        <tr>
          <td>
            `indices.indexingOperationsFailed`
          </td>

          <td>
            Le nombre d’opérations d’indexation ayant échoué.
          </td>
        </tr>

        <tr>
          <td>
            `indices.indexingWaitedThrottlingInMilliseconds`
          </td>

          <td>
            L&apos;indexation du temps a été attendue en raison d&apos;une limitation.
          </td>
        </tr>

        <tr>
          <td>
            `indices.memoryQueryCacheInBytes`
          </td>

          <td>
            La mémoire utilisée par le cache de requête, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `indices.numberIndices`
          </td>

          <td>
            Le nombre de documents sur tous les fragments primaires attribués au nœud.
          </td>
        </tr>

        <tr>
          <td>
            `indices.queryCacheEvictions`
          </td>

          <td>
            Le nombre d&apos;expulsions du cache de requêtes.
          </td>
        </tr>

        <tr>
          <td>
            `indices.queryCacheHits`
          </td>

          <td>
            Le nombre de requêtes taux d&apos;accès au cache.
          </td>
        </tr>

        <tr>
          <td>
            `indices.queryCacheMisses`
          </td>

          <td>
            Le nombre de requêtes échouées dans le cache.
          </td>
        </tr>

        <tr>
          <td>
            `indices.recoveryOngoingShardSource`
          </td>

          <td>
            Le nombre de récupérations en cours pour lesquelles un fragment sert de source.
          </td>
        </tr>

        <tr>
          <td>
            `indices.recoveryOngoingShardTarget`
          </td>

          <td>
            Le nombre de récupérations en cours pour lesquelles un fragment sert de cible.
          </td>
        </tr>

        <tr>
          <td>
            `indices.recoveryWaitedThrottlingInMilliseconds`
          </td>

          <td>
            Le temps total de récupération attendu en raison de la limitation.
          </td>
        </tr>

        <tr>
          <td>
            `indices.requestCacheEvictions`
          </td>

          <td>
            Le nombre d&apos;expulsions du cache de requêtes.
          </td>
        </tr>

        <tr>
          <td>
            `indices.requestCacheHits`
          </td>

          <td>
            Le nombre de demandes de taux d&apos;accès au cache.
          </td>
        </tr>

        <tr>
          <td>
            `indices.requestCacheMemoryInBytes`
          </td>

          <td>
            La mémoire utilisée par le cache de requête, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `indices.requestCacheMisses`
          </td>

          <td>
            Le nombre de requêtes manquées dans le cache.
          </td>
        </tr>

        <tr>
          <td>
            `indices.segmentsIndexShard`
          </td>

          <td>
            Le nombre de segments dans un fragment d&apos;index.
          </td>
        </tr>

        <tr>
          <td>
            `indices.segmentsMaxMemoryIndexWriterInBytes`
          </td>

          <td>
            La mémoire maximale utilisée par le rédacteur d&apos;index, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `indices.segmentsMemoryUsedDocValuesInBytes`
          </td>

          <td>
            La mémoire utilisée par les valeurs du document, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `indices.segmentsMemoryUsedFixedBitSetInBytes`
          </td>

          <td>
            La mémoire utilisée par l&apos;ensemble de bits fixes, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `indices.segmentsMemoryUsedIndexSegmentsInBytes`
          </td>

          <td>
            La mémoire utilisée par les segments d&apos;index, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `indices.segmentsMemoryUsedIndexWriterInBytes`
          </td>

          <td>
            La mémoire utilisée par le rédacteur d&apos;index, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `indices.segmentsMemoryUsedNormsInBytes`
          </td>

          <td>
            La mémoire utilisée par la norme, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `indices.segmentsMemoryUsedSegmentVersionMapInBytes`
          </td>

          <td>
            La mémoire utilisée par la carte des versions de segment, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `indices.segmentsMemoryUsedStoredFieldsInBytes`
          </td>

          <td>
            La mémoire utilisée par les champs stockés, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `indices.segmentsMemoryUsedTermsInBytes`
          </td>

          <td>
            La mémoire utilisée par les termes, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `indices.segmentsMemoryUsedTermVectorsInBytes`
          </td>

          <td>
            La mémoire utilisée par les vecteurs de termes, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `indices.translogOperations`
          </td>

          <td>
            Le nombre d&apos;opérations dans le log des transactions.
          </td>
        </tr>

        <tr>
          <td>
            `indices.translogOperationsInBytes`
          </td>

          <td>
            La taille du log des transactions, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.gc.collections`
          </td>

          <td>
            Le nombre de récupérations de place exécutées par la JVM.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.gc.collectionsInMilliseconds`
          </td>

          <td>
            Le temps passé à la collecte des déchets dans la JVM.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.gc.concurrentMarkSweep`
          </td>

          <td>
            Le nombre de GC de marquage et de balayage simultanés dans la JVM.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.gc.concurrentMarkSweepInMilliseconds`
          </td>

          <td>
            Le temps passé sur les GC de marquage et de balayage simultanés dans la JVM.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.gc.majorCollectionsOldGenerationObjects`
          </td>

          <td>
            Le nombre de GC majeurs dans la JVM qui collectent des objets d&apos;ancienne génération.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.gc.majorCollectionsOldGenerationObjectsInMilliseconds`
          </td>

          <td>
            Le temps passé dans les principaux GC de la JVM qui collectent les objets d&apos;ancienne génération.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.gc.minorCollectionsYoungGenerationObjects`
          </td>

          <td>
            Le nombre de GC mineurs dans la JVM qui collecte les objets de jeune génération.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.gc.minorCollectionsYoungGenerationObjectsInMilliseconds`
          </td>

          <td>
            Le temps passé dans les GC mineurs de la JVM qui collectent les objets de jeune génération.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.gc.parallelNewCollections`
          </td>

          <td>
            Le nombre de nouveaux GC parallèles dans la JVM.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.gc.parallelNewCollectionsInMilliseconds`
          </td>

          <td>
            Le temps passé sur les nouveaux GC parallèles dans la JVM.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.mem.heapCommittedInBytes`
          </td>

          <td>
            La quantité de mémoire garantie comme étant disponible pour le tas JVM, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.mem.heapMaxInBytes`
          </td>

          <td>
            La quantité maximale de mémoire pouvant être utilisée par le tas JVM, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.mem.heapUsed`
          </td>

          <td>
            Le pourcentage de mémoire actuellement utilisé par le tas JVM sous forme de valeur comprise entre `0` et `1`.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.mem.heapUsedInBytes`
          </td>

          <td>
            La quantité de mémoire actuellement utilisée par le tas JVM, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.mem.maxOldGenerationHeapInBytes`
          </td>

          <td>
            La quantité maximale de mémoire pouvant être utilisée par le tas d&apos;ancienne génération, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.mem.maxSurvivorSpaceInBytes`
          </td>

          <td>
            La quantité maximale de mémoire pouvant être utilisée par l&apos;espace survivant, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.mem.maxYoungGenerationHeapInBytes`
          </td>

          <td>
            La quantité maximale de mémoire pouvant être utilisée par le tas de jeune génération, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.mem.nonHeapCommittedInBytes`
          </td>

          <td>
            La quantité de mémoire garantie comme étant disponible pour la JVM non-heap, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.mem.nonHeapUsedInBytes`
          </td>

          <td>
            La quantité de mémoire actuellement utilisée par la JVM non-heap, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.mem.usedOldGenerationHeapInBytes`
          </td>

          <td>
            La quantité de mémoire actuellement utilisée par le tas d&apos;ancienne génération, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.mem.usedSurvivorSpaceInBytes`
          </td>

          <td>
            La quantité de mémoire actuellement utilisée par l&apos;espace survivant, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.mem.usedYoungGenerationHeapInBytes`
          </td>

          <td>
            La quantité de mémoire actuellement utilisée par le tas de jeune génération, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.ThreadsActive`
          </td>

          <td>
            Le nombre de threads actifs dans la JVM.
          </td>
        </tr>

        <tr>
          <td>
            `jvm.ThreadsPeak`
          </td>

          <td>
            Le nombre maximal de threads utilisés par la JVM.
          </td>
        </tr>

        <tr>
          <td>
            `merges.currentActive`
          </td>

          <td>
            Le nombre de fusions de segments actuellement actives.
          </td>
        </tr>

        <tr>
          <td>
            `merges.docsSegmentsMerging`
          </td>

          <td>
            Le nombre de documents répartis sur les segments actuellement en cours de fusion.
          </td>
        </tr>

        <tr>
          <td>
            `merges.docsSegmentMerges`
          </td>

          <td>
            Le nombre de documents dans tous les segments fusionnés.
          </td>
        </tr>

        <tr>
          <td>
            `merges.mergedSegmentsInBytes`
          </td>

          <td>
            La taille de tous les segments fusionnés, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `merges.segmentMerges`
          </td>

          <td>
            Le nombre de fusions de segments.
          </td>
        </tr>

        <tr>
          <td>
            `merges.sizeSegmentsMergingInBytes`
          </td>

          <td>
            La taille des segments en cours de fusion, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `merges.totalSegmentMergingInMilliseconds`
          </td>

          <td>
            Le temps consacré à la fusion des segments.
          </td>
        </tr>

        <tr>
          <td>
            `openFD`
          </td>

          <td>
            Le nombre de descripteurs de fichiers ouverts associés au processus en cours, ou`-1` si non pris en charge.
          </td>
        </tr>

        <tr>
          <td>
            `queriesTotal`
          </td>

          <td>
            Le nombre de requêtes.
          </td>
        </tr>

        <tr>
          <td>
            `refresh.total`
          </td>

          <td>
            Le nombre d&apos;actualisations de l&apos;index.
          </td>
        </tr>

        <tr>
          <td>
            `refresh.totalInMilliseconds`
          </td>

          <td>
            Le temps passé à actualiser l&apos;index.
          </td>
        </tr>

        <tr>
          <td>
            `searchFetchCurrentlyRunning`
          </td>

          <td>
            Le nombre de recherches en cours d&apos;exécution.
          </td>
        </tr>

        <tr>
          <td>
            `searchFetches`
          </td>

          <td>
            Le nombre de recherches effectuées.
          </td>
        </tr>

        <tr>
          <td>
            `sizeStoreInBytes`
          </td>

          <td>
            La taille du magasin, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.bulk.Queue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente dans le pool en masse.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.bulkActive`
          </td>

          <td>
            Le nombre de threads actifs dans le pool en masse.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.bulkRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool en masse.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.bulkThreads`
          </td>

          <td>
            Le nombre de threads dans le pool en masse.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.fetchShardStartedQueue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente dans le pool de récupération de fragments démarré.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.fetchShardStartedRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool de fragments de récupération démarré.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.fetchShardStartedThreads`
          </td>

          <td>
            Le nombre de threads dans le pool de fragments de récupération démarré.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.fetchShardStoreActive`
          </td>

          <td>
            Le nombre de threads actifs dans le pool de stockage de fragments de récupération.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.fetchShardStoreQueue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente dans le pool de stockage de fragments de récupération.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.fetchShardStoreRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool de stockage de fragments de récupération.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.fetchShardStoreThreads`
          </td>

          <td>
            Le nombre de threads dans le pool de stockage de fragments de récupération.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.flushActive`
          </td>

          <td>
            Le nombre de threads actifs dans la file d&apos;attente de vidage.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.flushQueue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente dans le pool de vidage.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.flushRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool de vidage.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.flushThreads`
          </td>

          <td>
            Le nombre de threads dans le pool de vidage.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.forceMergeActive`
          </td>

          <td>
            Le nombre de threads actifs pour les opérations de fusion forcée.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.forceMergeQueue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente pour les opérations de fusion forcée.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.forceMergeRejected`
          </td>

          <td>
            Le nombre de threads rejetés pour les opérations de fusion forcée.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.forceMergeThreads`
          </td>

          <td>
            Le nombre de threads pour les opérations de fusion forcée.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.genericActive`
          </td>

          <td>
            Le nombre de threads actifs dans le pool générique.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.genericQueue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente dans le pool générique.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.genericRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool générique.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.genericThreads`
          </td>

          <td>
            Le nombre de threads dans le pool générique.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.getActive`
          </td>

          <td>
            Le nombre de threads actifs dans le pool d&apos;obtention.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.getQueue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente dans le pool d&apos;obtention.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.getRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool d&apos;obtention.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.getThreads`
          </td>

          <td>
            Le nombre de threads dans le pool d&apos;obtention.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.listenerActive`
          </td>

          <td>
            Le nombre de threads actifs dans le pool d&apos;écouteurs.<br />(Obsolète sur Elasticsearch 8)
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.listenerQueue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente dans le pool d&apos;écoute.<br />(Obsolète sur Elasticsearch 8)
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.listenerRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool d&apos;écouteurs.<br />(Obsolète sur Elasticsearch 8)
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.listenerThreads`
          </td>

          <td>
            Le nombre de threads dans le pool d&apos;écoute.<br />(Obsolète sur Elasticsearch 8)
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.managementActive`
          </td>

          <td>
            Le nombre de threads actifs dans le pool de gestion.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.managementQueue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente dans le pool de gestion.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.managementRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool de gestion.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.managementThreads`
          </td>

          <td>
            Le nombre de threads dans le pool de gestion.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.mergeActive`
          </td>

          <td>
            Le nombre de threads actifs dans le pool de fusion.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.mergeQueue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente dans le pool de fusion.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.mergeRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool de fusion.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.mergeThreads`
          </td>

          <td>
            Le nombre de threads dans le pool de fusion.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.percolateActive`
          </td>

          <td>
            Le nombre de threads actifs dans le pool de percolation.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.percolateQueue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente dans le pool de percolation.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.percolateRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool de percolation.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.percolateThreads`
          </td>

          <td>
            Le nombre de threads dans le pool de percolation.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.refreshActive`
          </td>

          <td>
            Le nombre de threads actifs dans le pool d&apos;actualisation.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.refreshQueue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente dans le pool d&apos;actualisation.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.refreshRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool d&apos;actualisation.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.refreshThreads`
          </td>

          <td>
            Le nombre de threads dans le pool d&apos;actualisation.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.searchActive`
          </td>

          <td>
            Le nombre de threads actifs dans le pool de recherche.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.searchQueue`
          </td>

          <td>
            Le nombre de threads en file d&apos;attente dans le pool de recherche.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.searchRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool de recherche.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.searchThreads`
          </td>

          <td>
            Le nombre de threads dans le pool de recherche.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.snapshotActive`
          </td>

          <td>
            Le nombre de threads actifs dans le pool de snapshots.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.snapshotQueue`
          </td>

          <td>
            Le nombre de threads en file d’attente dans le pool de snapshots.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.snapshotRejected`
          </td>

          <td>
            Le nombre de threads rejetés dans le pool de snapshots.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.snapshotThreads`
          </td>

          <td>
            Le nombre de threads dans le pool de snapshots.
          </td>
        </tr>

        <tr>
          <td>
            `threadpool.activeFetchShardStarted`
          </td>

          <td>
            Le nombre de threads actifs dans le pool de fragments de récupération démarré.
          </td>
        </tr>

        <tr>
          <td>
            `transport.connectionsOpened`
          </td>

          <td>
            Le nombre de connexions ouvertes pour la communication du cluster.
          </td>
        </tr>

        <tr>
          <td>
            `transport.packetsReceived`
          </td>

          <td>
            Le nombre de paquets reçus dans la communication du cluster.
          </td>
        </tr>

        <tr>
          <td>
            `transport.packetsReceivedInBytes`
          </td>

          <td>
            La taille des données reçues dans la communication du cluster, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `transport.packetsSent`
          </td>

          <td>
            Le nombre de paquets envoyés dans la communication du cluster.
          </td>
        </tr>

        <tr>
          <td>
            `transport.packetsSentInBytes`
          </td>

          <td>
            La taille des données envoyées dans la communication de cluster, en octets.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="common-metrics" title="Événement ElasticsearchCommonSample">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            métrique
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `primaries.docsDeleted`
          </td>

          <td>
            Le nombre de documents supprimés des fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.docsnumber`
          </td>

          <td>
            Le nombre de documents dans les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.flushesTotal`
          </td>

          <td>
            Le nombre de vidages d&apos;index sur le disque à partir des fragments primaires depuis le démarrage.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.flushTotalTimeInMilliseconds`
          </td>

          <td>
            Le temps passé à vider l’index sur le disque à partir des fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.get.documentsExist`
          </td>

          <td>
            Le nombre de requêtes GET sur les fragments primaires où le document existait.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.get.documentsExistInMilliseconds`
          </td>

          <td>
            Le temps passé sur la requête GET à partir des fragments primaires où le document existait.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.get.documentsMissing`
          </td>

          <td>
            Le nombre de requêtes GET provenant des fragments primaires où le document manquait.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.get.documentsMissingInMilliseconds`
          </td>

          <td>
            Le temps passé sur la requête GET à partir des fragments primaires où le document manquait.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.get.requests`
          </td>

          <td>
            Le nombre de requêtes GET provenant des fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.get.requestsCurrent`
          </td>

          <td>
            Le nombre de requêtes GET actuellement en cours d&apos;exécution sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.get.requestsInMilliseconds`
          </td>

          <td>
            Le temps passé sur la requête GET à partir des fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.index.docsCurrentlyDeleted`
          </td>

          <td>
            Le nombre de documents actuellement supprimés d&apos;un index sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.index.docsCurrentlyDeletedInMilliseconds`
          </td>

          <td>
            Le temps passé à supprimer des documents d’un index sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.index.docsCurrentlyIndexing`
          </td>

          <td>
            Le nombre de documents actuellement indexés sur un index sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.index.docsCurrentlyIndexingInMilliseconds`
          </td>

          <td>
            Le temps passé à indexer les documents dans un index sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.index.docsDeleted`
          </td>

          <td>
            Le nombre de documents supprimés d&apos;un index sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.index.docsTotal`
          </td>

          <td>
            Le nombre de documents indexés sur un index sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.indexRefreshesTotal`
          </td>

          <td>
            Le nombre d’actualisations d’index sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.indexRefreshesTotalInMilliseconds`
          </td>

          <td>
            Le temps passé à actualiser l&apos;index sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.merges.current`
          </td>

          <td>
            Le nombre de fusions de segments actuellement actives sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.merges.docsSegmentsCurrentlyMerged`
          </td>

          <td>
            Le nombre de documents répartis sur les segments actuellement en cours de fusion sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.merges.docsTotal`
          </td>

          <td>
            Le nombre de documents sur tous les segments fusionnés sur les fragments principaux.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.merges.SegmentsCurrentlyMergedInBytes`
          </td>

          <td>
            La taille des segments en cours de fusion sur les fragments primaires, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.merges.SegmentsTotal`
          </td>

          <td>
            Le nombre de fusions de segments sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.merges.segmentsTotalInBytes`
          </td>

          <td>
            La taille de tous les segments fusionnés sur les fragments primaires, en octets.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.merges.segmentsTotalInMilliseconds`
          </td>

          <td>
            Le temps passé à la fusion des segments sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.queriesInMilliseconds`
          </td>

          <td>
            Le temps passé à interroger les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.queriesTotal`
          </td>

          <td>
            Le nombre de requêtes adressées aux fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.queryActive`
          </td>

          <td>
            Le nombre de requêtes actuellement actives sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.queryFetches`
          </td>

          <td>
            Le nombre de requêtes récupérées actuellement en cours d&apos;exécution sur les fragments principaux.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.queryFetchesInMilliseconds`
          </td>

          <td>
            Le temps passé sur les requêtes de récupération sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.queryFetchesTotal`
          </td>

          <td>
            Le nombre de requêtes récupérées sur les fragments primaires.
          </td>
        </tr>

        <tr>
          <td>
            `primaries.sizeInBytes`
          </td>

          <td>
            La taille de tous les fragments primaires, en octets.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="index-metrics" title="Événement ElasticsearchIndexSample">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            métrique
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `index.docs`
          </td>

          <td>
            Le nombre de documents dans l&apos;index.
          </td>
        </tr>

        <tr>
          <td>
            `index.docsDeleted`
          </td>

          <td>
            Le nombre de documents supprimés dans l&apos;index.
          </td>
        </tr>

        <tr>
          <td>
            `index.health`
          </td>

          <td>
            L&apos;état de l&apos;index : `red`, `yellow` ou `green`.
          </td>
        </tr>

        <tr>
          <td>
            `index.primaryShards`
          </td>

          <td>
            Le nombre de fragments primaires dans l&apos;index.
          </td>
        </tr>

        <tr>
          <td>
            `index.primaryStoreSizeInBytes`
          </td>

          <td>
            La taille du magasin de fragments primaires dans l&apos;index.
          </td>
        </tr>

        <tr>
          <td>
            `index.replicaShards`
          </td>

          <td>
            Le nombre de fragments de réplique dans l&apos;index.
          </td>
        </tr>

        <tr>
          <td>
            `index.storeSizeInBytes`
          </td>

          <td>
            La taille du magasin des fragments primaires et réplicas dans l&apos;index, en octets.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

L&apos;intégration Elasticsearch est un logiciel open source. Cela signifie que vous pouvez [parcourir son code source](https://github.com/newrelic/nri-elasticsearch) et envoyer des améliorations, ou créer votre propre fork et le construire.

### Paramètres d&apos;instance Elasticsearch [#instance-settings]

Vous pouvez utiliser la section `env` du fichier `elasticsearch-config.yml` pour définir des paramètres spécifiques liés à Elasticsearch. Ces paramètres contrôlent la connexion à votre Elasticsearch instance, ainsi que d&amp;apos;autres paramètres et fonctionnalités de sécurité.

L&apos;intégration Elasticsearch collecte à la fois les informations Métriques et Inventaire. Dans le tableau, utilisez la colonne <DNT>**Applies to**</DNT> pour les paramètres disponibles pour chaque collection :

&apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos; &apos;

<table>
  <thead>
    <tr>
      <th style={{ width: '150px' }}>
        Paramètre
      </th>

      <th>
        Description
      </th>

      <th>
        Défaut
      </th>

      <th>
        S&apos;applique à
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <DNT>
          **HOSTNAME**
        </DNT>
      </td>

      <td>
        nom d&apos;hôte ou IP où Elasticsearch s&apos;exécute.
      </td>

      <td>
        hôte local
      </td>

      <td style={{ "text-align": "center" }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **LOCAL\_HOSTNAME**
        </DNT>
      </td>

      <td>
        nom d&apos;hôte ou IP du nœud Elasticsearch à partir duquel collecter les données d&apos;inventaire. Ne doit être défini que si vous ne souhaitez pas collecter de données d&apos;inventaire sur localhost.
      </td>

      <td>
        hôte local
      </td>

      <td style={{ 'text-align': 'center' }}>
        M
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **PORT**
        </DNT>
      </td>

      <td>
        Port sur lequel Elasticsearch écoute.
      </td>

      <td>
        9200
      </td>

      <td style={{ 'text-align': 'center' }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **USERNAME**
        </DNT>
      </td>

      <td>
        Nom d&apos;utilisateur pour accéder à Elasticsearch Node.
      </td>

      <td>
        N/A
      </td>

      <td style={{ 'text-align': 'center' }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **PASSWORD**
        </DNT>
      </td>

      <td>
        Mot de passe pour l&apos;utilisateur donné.
      </td>

      <td>
        N/A
      </td>

      <td style={{ 'text-align': 'center' }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **CLUSTER\_ENVIRONMENT**
        </DNT>
      </td>

      <td>
        Une façon de préciser davantage pour quel cluster nous collectons des données, par exemple : « simulation ».
      </td>

      <td>
        N/A
      </td>

      <td style={{ 'text-align': 'center' }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **USE\_SSL**
        </DNT>
      </td>

      <td>
        Utilisez SSL lors de la communication avec le nœud Elasticsearch.
      </td>

      <td>
        false
      </td>

      <td style={{ 'text-align': 'center' }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **CA\_BUNDLE\_FILE**
        </DNT>
      </td>

      <td>
        Emplacement du certificat SSL sur l&apos;hôte. Requis uniquement si `USE_SSL` est vrai.
      </td>

      <td>
        N/A
      </td>

      <td style={{ 'text-align': 'center' }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **CA\_BUNDLE\_DIR**
        </DNT>
      </td>

      <td>
        Répertoire de bundles d&apos;autorités de certification alternatives.
      </td>

      <td>
        N/A
      </td>

      <td style={{ 'text-align': 'center' }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **SSL\_ALTERNATIVE\_HOSTNAME**
        </DNT>
      </td>

      <td>
        Nom d&apos;hôte alternatif du serveur que l&apos;intégration acceptera comme valide aux fins de négociation SSL.
      </td>

      <td>
        N/A
      </td>

      <td style={{ 'text-align': 'center' }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **TLS\_INSECURE\_SKIP\_VERIFY**
        </DNT>
      </td>

      <td>
        Ignorer la vérification de la chaîne de certificat du serveur et du nom d&apos;hôte.
      </td>

      <td>
        false
      </td>

      <td style={{ 'text-align': 'center' }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **CONFIG\_PATH**
        </DNT>
      </td>

      <td>
        Chemin vers le fichier de configuration Elasticsearch.
      </td>

      <td>
        /etc/elasticsearch/

        <br />

        elasticsearch.yml
      </td>

      <td style={{ 'text-align': 'center' }}>
        je
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **TIMEOUT**
        </DNT>
      </td>

      <td>
        Délai d&apos;expiration requests API, en secondes.
      </td>

      <td>
        30
      </td>

      <td style={{ 'text-align': 'center' }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **COLLECT\_INDICES**
        </DNT>
      </td>

      <td>
        Indique s&apos;il faut collecter ou non les métriques d&apos;indices.
      </td>

      <td>
        vrai
      </td>

      <td style={{ 'text-align': 'center' }}>
        M
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **COLLECT\_PRIMARIES**
        </DNT>
      </td>

      <td>
        Indique s&apos;il faut collecter les métriques primaires ou non.
      </td>

      <td>
        vrai
      </td>

      <td style={{ 'text-align': 'center' }}>
        M
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **INDICES\_REGEX**
        </DNT>
      </td>

      <td>
        Filtrer les indices collectés.
      </td>

      <td>
        N/A
      </td>

      <td style={{ 'text-align': 'center' }}>
        M
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **MASTER\_ONLY**
        </DNT>
      </td>

      <td>
        Collectez les métriques de cluster sur le maître élu uniquement.
      </td>

      <td>
        false
      </td>

      <td style={{ 'text-align': 'center' }}>
        M
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **METRICS**
        </DNT>
      </td>

      <td>
        Définissez sur `true` pour activer la collecte de métriques uniquement.
      </td>

      <td>
        false
      </td>

      <td style={{ 'text-align': 'center' }} />
    </tr>

    <tr>
      <td>
        <DNT>
          **INVENTORY**
        </DNT>
      </td>

      <td>
        Définissez sur `true` pour activer la collecte d&amp;apos;inventaire uniquement.
      </td>

      <td>
        false
      </td>

      <td style={{ 'text-align': 'center' }} />
    </tr>
  </tbody>
</table>

Les valeurs de ces paramètres peuvent être définies de plusieurs manières :

* Ajout de la valeur directement dans le fichier de configuration. C&apos;est la manière la plus courante.

* Remplacement des valeurs des variables d’environnement à l’aide de la notation `{{ }}` . En savoir plus sur [l&apos;utilisation des passthroughs de variables d&apos;environnement avec l&apos;intégration sur hôte](/docs/infrastructure/install-infrastructure-agent/configuration/configure-infrastructure-agent/#passthrough) ou voir l&amp;apos;exemple de [remplacement des variables d&apos;environnement](/docs/infrastructure/host-integrations/host-integrations-list/elasticsearch/elasticsearch-integration#envvar-replacement). <Callout variant="important">Cela nécessite l&apos;agent d&apos;infrastructure v1.14.0+.</Callout>

* Utilisation de la gestion des secrets. Utilisez ceci pour protéger les informations sensibles, telles que les mots de passe qui seraient exposés en texte brut dans le fichier de configuration. Pour plus d&apos;informations, voir [gestion des secrets](/docs/integrations/host-integrations/installation/secrets-management).

### Libellés et attribut personnalisé [#labels]

Vous pouvez également décorer vos métriques à l’aide d’étiquettes. Les étiquettes vous permettent d&apos;ajouter une paire d&apos;attributs valeur clé à vos métriques, que vous pouvez ensuite utiliser pour interroger, filtrer ou regrouper vos métriques.<br /> Le [fichier d&apos;exemple de configuration de base elasticsearch-config.yml](/docs/infrastructure/host-integrations/host-integrations-list/elasticsearch/elasticsearch-integration#basic-config) inclut l&amp;apos;utilisation d&amp;apos;étiquettes. Cependant, comme ils ne sont pas obligatoires, vous pouvez supprimer, modifier ou en ajouter de nouveaux de votre choix.

```yaml
 labels:
   env: production
   role: load_balancer
```

## Données d&apos;inventaire [#inventory]

L&apos;intégration Elasticsearch capture les paramètres de configuration du nœud Elasticsearch, comme spécifié dans le [fichier de configuration YAML](/docs/infrastructure/host-integrations/host-integrations-list/elasticsearch/elasticsearch-integration/#basic-config). Il collecte également les informations de configuration du nœud à partir du point de terminaison `\_nodes/\_local` . Les données sont disponibles sur la [page Inventaire des infrastructures](/docs/infrastructure/new-relic-infrastructure/infrastructure-ui-pages/infrastructure-inventory-page-search-your-entire-infrastructure), sous la source `config/elasticsearch` .

Pour en savoir plus sur les données d&apos;inventaire, consultez comment [comprendre les données d&apos;intégration](/docs/infrastructure/integrations-getting-started/getting-started/understand-integration-data-data-types#inventory-data).