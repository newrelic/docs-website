---
title: Intégration monitoring PostgreSQL
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: 'New Relic''s PostgreSQL integration: how to install it and configure it, and what data it reports.'
freshnessValidatedDate: never
translationType: machine
---

L&apos;[intégration New Relic PostgreSQL sur hôte](/docs/integrations/host-integrations/getting-started/introduction-host-integrations) reçoit et envoie les métriques d&apos;inventaire de votre instance PostgreSQL à la plateforme New Relic, où vous pouvez agréger et visualiser les métriques de performance clés. Les données provenant de l&apos;instance, de la base de données et du cluster vous aident à trouver la source des problèmes.

Pour installer l&apos;intégration monitoring PostgreSQL, vous devez suivre les étapes suivantes :

1. [Installer et activer l&apos;intégration](#install).
2. [Configurer l&apos;intégration](#config).
3. [PostgreSQL utilisateur et autorisations](#create-user).
4. [Rechercher et utiliser des données](#find-and-use).
5. En option, consultez [les paramètres de configuration de PostgreSQL](/docs/infrastructure/host-integrations/host-integrations-list/postgresql/postgresql-config).

<Callout variant="important">
  Pour de meilleurs résultats, mettez régulièrement [à jour le package d&apos;intégration](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) et [l&apos;agent d&apos;infrastructure](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).
</Callout>

## Compatibilité et exigences [#req]

### Versions de PostgreSQL [#postgresql-versions]

Notre intégration est compatible avec PostgreSQL v17 et inférieur.

### Services gérés pris en charge [#supported-ms]

* Amazon RDS
* Azure flexible

### Système d&apos;exploitation pris en charge [#supported-os]

* Windows<img style={{ width: '32px', height: '32px'}} class="inline" title="Windows" alt="Windows" src="/images/os_icon_windows.webp" />
* Linux<img style={{ width: '32px', height: '32px'}} class="inline" title="Linux" alt="Linux" src="/images/os_icon_linux.webp" />

Pour une liste complète des versions spécifiques Windows et Linux, consultez le tableau des [systèmes d&apos;exploitation compatibles](/docs/infrastructure/install-infrastructure-agent/get-started/requirements-infrastructure-agent/#operating-systems).

### exigences système [#system-reqs]

* Un compte New Relic. Vous n&apos;en avez pas ? [Inscrivez-vous gratuitement !](https://newrelic.com/signup) Aucune carte de crédit requise.

* Si PostgreSQL ne s&apos;exécute pas sur Kubernetes ou Amazon ECS, vous pouvez [installer l&apos;agent d&apos;infrastructure](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic) sur un hôte Linux ou Windows OS ou sur un hôte capable d&apos;accéder à distance à l&apos;endroit où PostgreSQL est installé. Sinon:

  * Si vous exécutez sur<img style={{ width: '32px', height: '32px'}} class="inline" title="Kubernetes" alt="Kubernetes" src="/images/os_icon_k8.webp">Kubernetes, voir [ces exigences](/docs/monitor-service-running-kubernetes#requirements).</img>
  * Si vous exécutez sur<img style={{ width: '32px', height: '32px'}} class="inline" title="ECS" alt="ECS" src="/images/os_icon_ecs.webp">Amazon ECS, consultez [ces exigences](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).</img>

## Installer et activer l&apos;intégration [#install]

Pour installer l&apos;intégration PostgreSQL, suivez les instructions adaptées à votre environnement.

### Installation de Linux [#linux]

1. Installez [l&apos;agent d&apos;infrastructure](/docs/integrations/host-integrations/installation/install-infrastructure-host-integrations/#install) et remplacez la variable `INTEGRATION_FILE_NAME` par `nri-postgresql`.

2. Changez de répertoire pour accéder au dossier configuration de l&apos;intégration en exécutant :

   ```shell
   cd /etc/newrelic-infra/integrations.d
   ```

3. [Créez un utilisateur](#create-user) avec des autorisations `READ` sur les fonctions requises.

4. Copiez l’exemple de fichier de configuration en exécutant :

   ```shell
   sudo cp postgresql-config.yml.sample postgresql-config.yml
   ```

5. Modifiez le fichier de configuration `postgresql-config.yml` avec votre éditeur préféré. Découvrez quelques [exemples de fichiers de configuration.](#examples).

6. Pour activer l&apos;analyse et la transmission automatiques de Postgresql, copiez ou renommez le fichier `postgresql-log.yml.example` en `postgresql-log.yml`. Vous n&apos;avez pas besoin de redémarrer l&apos;agent mais vous devrez peut-être mettre à jour le fichier YML avec l&apos;emplacement de votre fichier de log postgresql, si vous n&apos;utilisez pas les emplacements par défaut.

   Par exemple:

   ````shell
   sudo cp /etc/newrelic-infra/logging.d/postgresql-log.yml.example /etc/newrelic-infra/logging.d/postgresql-log.yml
   ```  
   ````

### Autres environnements [#other-env]

<CollapserGroup>
  <Collapser
    id="windows-install"
    title={<><img src="/images/os_icon_windows.webp" title="Windows installation" alt="Windows installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }} /></>
    }
  >
    1. Téléchargez l&apos;image du programme d&apos;installation `nri-postgresql` .MSI depuis :

       [https://download.newrelic.com/infrastructure\_agent/windows/integrations/nri-postgresql/nri-postgresql-amd64.msi](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-postgresql/nri-postgresql-amd64.msi)

    2. Pour installer à partir de l’invite de commande Windows, exécutez :

       ```shell
       msiexec.exe /qn /i PATH\TO\nri-postgresql-amd64.msi
       ```

    3. Dans le répertoire d’intégration, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, créez une copie du fichier configuration d’exemple en exécutant :

       ```shell
       cp postgresql-config.yml.sample postgresql-config.yml
       ```

    4. Modifiez le fichier `postgresql-config.yml` comme décrit dans [les fichiers d&apos;exemple postgresql-config.yml](#examples).
  </Collapser>

  <Collapser
    id="ecs-install"
    title={<>
      <img src="/images/os_icon_ecs.webp" title="Amazon ECS installation" alt="Amazon ECS installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }}>{' '} Installation d'Amazon ECS</img>
    </>
    }
  >
    Voir [le service de monitoring exécuté sur ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
  </Collapser>

  <Collapser
    id="k8s-install"
    title={<><img src="/images/os_icon_k8.webp" title="Kubernetes installation" alt="Kubernetes installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }} /></>
    }
  >
    Voir [le service de monitoring exécuté sur Kubernetes](/docs/monitor-service-running-kubernetes).
  </Collapser>
</CollapserGroup>

Notes supplémentaires :

* <DNT>**Advanced:**</DNT> les intégrations sont également disponibles au [formattarball ](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball)pour permettre une installation en dehors d&apos;un gestionnaire de paquets.
* <DNT>**On-host integrations do not automatically update.**</DNT> Pour de meilleurs résultats, mettez régulièrement [à jour le package d&apos;intégration](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) et [l&apos;agent d&apos;infrastructure](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

<InstallFeedback />

## Configurer l&apos;intégration [#config]

Il existe plusieurs façons de configurer l&apos;intégration, selon la manière dont vous l&apos;avez installée :

* Si activé via<img style={{ width: '32px', height: '32px'}} class="inline" title="Kubernetes" alt="Kubernetes" src="/images/os_icon_k8.webp" />Kubernetes, voir [services de monitoring exécutés sur Kubernetes](/docs/monitor-service-running-kubernetes).
* Si activé via<img style={{ width: '32px', height: '32px'}} class="inline" title="ECS" alt="ECS" src="/images/os_icon_ecs.webp" />Amazon ECS, voir [les services de monitoring exécutés sur ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
* Si installé sur l&apos;hôte, modifiez la configuration dans le fichier de configuration YAML de l&apos;intégration, `postgresql-config.yml`. La configuration au format YAML d&apos;une intégration est l&apos;endroit où vous pouvez placer les informations de connexion requises et configurer la manière dont les données sont collectées. Les options que vous modifiez dépendent de votre configuration et de vos préférences. Le fichier configuration contient des paramètres communs applicables à toutes les intégrations, tels que `interval`, `timeout`, `inventory_source`. Pour tout savoir sur ces paramètres courants, reportez-vous à notre document [Format de configuration](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) .

<Callout variant="important">
  Si vous utilisez toujours nos legacy fichiers configuration ou de définition, vérifiez le [format configuration standard](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/).
</Callout>

Les paramètres spécifiques liés à PostgreSQL sont définis à l&apos;aide de la section `env` du fichier de configuration. Ces paramètres contrôlent la connexion à votre instance PostgreSQL ainsi que d&apos;autres paramètres et fonctionnalités de sécurité. La liste des paramètres valides est décrite dans la section suivante de ce document.

## PostgreSQL utilisateur et autorisations [#create-user]

Créez un utilisateur avec des autorisations `SELECT` sur :

* `pg_stat_database`
* `pg_stat_database_conflicts`
* `pg_stat_bgwriter`

Pour créer l’utilisateur pour l’intégration PostgreSQL :

```sql
CREATE USER new_relic WITH PASSWORD MY_PASSWORD;
GRANT SELECT ON pg_stat_database TO new_relic;
GRANT SELECT ON pg_stat_database_conflicts TO new_relic;
GRANT SELECT ON pg_stat_bgwriter TO new_relic;
```

Cela permettra à l&apos;intégration de collecter des métriques globales liées à l&apos;instance PostgreSQL.

Si vous souhaitez également obtenir des métriques liées aux tables et aux index (par exemple, la taille de la table et la taille de l&apos;index), le rôle PostgreSQL utilisé par l&apos;intégration (`new_relic`) a également besoin des autorisations `SELECT` sur les tables à partir desquelles il collectera les métriques. Par exemple, pour permettre à l&apos;intégration de collecter des métriques de toutes les tables et index présents dans la base de données (dans le `schema` public), utilisez ce qui suit :

```sql
GRANT SELECT ON ALL TABLES IN SCHEMA public TO new_relic;
```

Si vous souhaitez également obtenir des métriques au niveau de la requête à partir du fichier de configuration de requête personnalisée PostgreSQL, le rôle PostgreSQL utilisé par l&apos;intégration (`new_relic`) doit être ajouté au rôle (`pg_read_all_stats`). Cela est dû au fait que l&apos;utilisateur utilise l&apos;extension (`pg_stat_statements`).

```sql
GRANT pg_read_all_stats TO new_relic;
```

L&apos;activation de l&apos;extension `pg_stat_statements` peut nécessiter de la créer manuellement à partir d&apos;une prompt de requête :

```sql
CREATE EXTENSION pg_stat_statements;
```

### Fichiers d&apos;exemple postgresql-config.yml [#examples]

<CollapserGroup>
  <Collapser id="example-postgresSQL-collection-config" title="Fichier de collecte de configuration PostgreSQL">
    * Éventail JSON : interprété comme une liste de noms de bases de données à partir de laquelle collecter toutes les métriques pertinentes, y compris les tables et index appartenant à cette base de données.

      Par exemple:

      ```yml
      collection_list: '["postgres"]'
      ```

    * Objet JSON : seule l&apos;entité spécifiée dans l&apos;objet sera collectée, aucune découverte automatique ne sera effectuée. Les niveaux de JSON sont `database name -> schema name -> table name -> index name`.

      Par exemple:

      ```yml
      collection_list: '{"postgres":{"public":{"pg_table1":["pg_index1","pg_index2"],"pg_table2":[]}}}'
      ```

    * `ALL`: collectez des métriques pour toutes les bases de données, schémas, tables et index découverts.

      Par exemple:

      ```yml
      collection_list: 'ALL'
      ```

      ```yml
      integrations:
        - name: nri-postgresql
          env:
            USERNAME: postgres
            PASSWORD: pass
            HOSTNAME: psql-sample.localnet
            PORT: 6432
            DATABASE: postgres

            COLLECT_DB_LOCK_METRICS: false
            COLLECTION_LIST: '{"postgres":{"public":{"pg_table1":["pg_index1","pg_index2"],"pg_table2":[]}}}'
            TIMEOUT:  10
          interval: 15s
          labels:
            env: production
            role: postgresql
          inventory_source: config/postgresql
      ```
  </Collapser>

  <Collapser id="example-postgresSQL-managed-db-service-config" title="Fichier de configuration PostgreSQL Azure Flexible et AWS RDS/Aurora">
    * Options Azure/AWS SSL activées : les offres de base de données gérées Azure Flexible nécessitent SSL pour se connecter. AWS RDS/Aurora peut nécessiter SSL si votre version MySQL est 5.7+ et que require\_secure\_transport est défini sur ON dans votre groupe de paramètres Aurora. Pour répondre aux exigences SSL, ces paramètres dans postgresql-config.yml doivent être définis sur `true`.

      Par exemple:

      ```yml
      ENABLE_SSL: "true"
      TRUST_SERVER_CERTIFICATE: "true"
      ```

    * Options de désactivation SSL Azure/AWS : en plus des paramètres ci-dessus, les paramètres SSL suivants doivent être placés en commentaire ou supprimés de la configuration. Cela est dû au fait que la configuration fait confiance au certificat du serveur ci-dessus.

      Par exemple:

      ```yml
      # SSL_ROOT_CERT_LOCATION: /etc/newrelic-infra/root_cert.crt
      # SSL_CERT_LOCATION: /etc/newrelic-infra/postgresql.crt
      # SSL_KEY_LOCATION: /etc/newrelic-infra/postgresql.key
      ```

    * Résumé : Une fois ces paramètres définis, le fichier de configuration Azure/AWS complet doit ressembler à celui ci-dessous. Remarque : l&apos;agent d&apos;infrastructure et l&apos;intégration Postgresql doivent être installés sur un hôte avec accès réseau à l&apos;instance de base de données.

      Par exemple:

      ```yml
      integrations:
        - name: nri-postgresql
          env:
            USERNAME: newrelic
            PASSWORD: password
            HOSTNAME: AWS-or-Azure-instance-name
            PORT: 5432
            DATABASE: postgres
            COLLECT_DB_LOCK_METRICS: false
            COLLECTION_LIST: 'ALL'
            ENABLE_SSL: "true"
            TRUST_SERVER_CERTIFICATE: "true"
            # SSL_ROOT_CERT_LOCATION: /etc/newrelic-infra/root_cert.crt
            # SSL_CERT_LOCATION: /etc/newrelic-infra/postgresql.crt
            # SSL_KEY_LOCATION: /etc/newrelic-infra/postgresql.key
            TIMEOUT:  10
          interval: 15s
          labels:
            env: production
            role: postgresql
          inventory_source: config/postgresql
      ```
  </Collapser>

  <Collapser id="example-postgresSQL-SSL-config" title="Fichier de collecte de configuration SSL PostgreSQL">
    ```yml
    integrations:
      - name: nri-postgresql
        env:
          USERNAME: postgres
          PASSWORD: pass
          HOSTNAME: psql-sample.localnet
          PORT: 6432
          DATABASE: postgres

          COLLECT_DB_LOCK_METRICS: false
          COLLECTION_LIST: '["postgres"]'
          ENABLE_SSL: true
          TRUST_SERVER_CERTIFICATE: false
          SSL_ROOT_CERT_LOCATION: /etc/newrelic-infra/root_cert.crt
          SSL_CERT_LOCATION: /etc/newrelic-infra/postgresql.crt
          SSL_KEY_LOCATION: /etc/newrelic-infra/postgresql.key
          TIMEOUT:  10
        interval: 15s
        labels:
          env: production
          role: postgresql
        inventory_source: config/postgresql
    ```
  </Collapser>

  <Collapser id="example-postgresSQL-custom-query-config" title="Requête personnalisée PostgreSQL">
    ```yml
    integrations:
      - name: nri-postgresql
        env:
          USERNAME: postgres
          PASSWORD: pass
          HOSTNAME: psql-sample.localnet
          PORT: 6432
          DATABASE: postgres

          COLLECT_DB_LOCK_METRICS: false
          COLLECTION_LIST: ALL
          CUSTOM_METRICS_QUERY: >-
            select
              'rows_inserted' as "metric_name",
              'delta' as "metric_type",
              sd.tup_inserted as "metric_value",
              sd.datid as "database_id"
              from pg_stat_database sd;
          TIMEOUT:  10
        interval: 15s
        labels:
          env: production
          role: postgresql
        inventory_source: config/postgresql
    ```
  </Collapser>

  <Collapser id="example-postgresSQL-custom-query-config-file" title="Fichier de configuration de requête personnalisée PostgreSQL">
    Un fichier de configuration YAML supplémentaire avec un ou plusieurs SQL personnalisés peut être défini et l&apos;intégration aura besoin du chemin d&apos;accès au fichier dans le paramètre CUSTOM\_METRICS\_CONFIG.

    * postgresql-config.yml

      ```yml
      integrations:
        - name: nri-postgresql
          env:
            USERNAME: postgres
            PASSWORD: pass
            HOSTNAME: psql-sample.localnet
            PORT: 6432
            DATABASE: postgres

            COLLECT_DB_LOCK_METRICS: false
            COLLECTION_LIST: ALL
            CUSTOM_METRICS_CONFIG: "path/to/postgresql-custom-query.yml"
            TIMEOUT:  10
          interval: 15s
          labels:
            env: production
            role: postgresql
          inventory_source: config/postgresql
      ```

    * postgresql-custom-query.yml

      ```yml
      ---
      queries:

        # Metric names are set to the column names in the query results
        - query: >-
            SELECT
            BG.checkpoints_timed AS scheduled_checkpoints_performed,
            BG.checkpoints_req AS requested_checkpoints_performed,
            BG.buffers_checkpoint AS buffers_written_during_checkpoint,
            BG.buffers_clean AS buffers_written_by_background_writer,
            BG.maxwritten_clean AS background_writer_stops,
            BG.buffers_backend AS buffers_written_by_backend,
            BG.buffers_alloc AS buffers_allocated
            FROM pg_stat_bgwriter BG;

          # database defaults to the auth database in the main config
          database: new_frontier_config_dev

          # If not set explicitly here, metric type will default to
          # 'gauge' for numbers and 'attribute' for strings
          metric_types:
            buffers_allocated: rate

          # If unset, sample_name defaults to PostgresqlCustomSample
          sample_name: MyCustomSample
      ```
  </Collapser>
</CollapserGroup>

Pour en savoir plus sur la structure générale de l&apos;intégration sur hôte configuration, voir [configuration](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview).

## Options de configuration pour l&apos;intégration [#config-options]

Pour en savoir plus sur la recherche et l&apos;utilisation de vos données, consultez [les paramètres de configuration de PostgreSQL](/docs/infrastructure/host-integrations/host-integrations-list/postgresql/postgresql-config).

## Rechercher et utiliser des données [#find-and-use]

Les données de ce service sont signalées à un [dashboard d&apos;intégration](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts).

Les Métriques sont attachées à ces [types d&apos;événements](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic):

* [Exemples de métriques de la base de données Postgresql](#databaseSample)
* [PostgresqlIndexSample métriques](#indexSample)
* [PostgresqlInstanceSample métriques](#instanceSample)
* [PostgresqlTableSample métriques](#tableSample)
* [PgBouncerÉchantillons métriques](#pgBouncerSample)

Vous pouvez [interroger ces données](/docs/using-new-relic/data/understand-data/query-new-relic-data) à des fins de dépannage ou pour créer des graphiques et des dashboards personnalisés.

Pour en savoir plus sur la recherche et l&apos;utilisation de vos données, consultez comment [comprendre les données d&apos;intégration](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Métriques collectées par l&apos;intégration [#metrics]

L&apos;intégration PostgreSQL collecte les métriques suivantes. Certains noms métriques sont préfixés par un indicateur de catégorie et un point, tels que `db.` ou `index.`.

<CollapserGroup>
  <Collapser id="databaseSample" title="Exemples de métriques de la base de données Postgresql">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Attribut PostgreSQLDatabaseSample
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `db.connections`
          </td>

          <td>
            Nombre de backend actuellement connectés à cette base de données.
          </td>
        </tr>

        <tr>
          <td>
            `db.maxconnections`
          </td>

          <td>
            Le nombre maximal de connexions simultanées au serveur de base de données.
          </td>
        </tr>

        <tr>
          <td>
            `db.commitsPerSecond`
          </td>

          <td>
            Transactions validées par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `db.rollbacksPerSecond`
          </td>

          <td>
            Transactions annulées par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `db.readsPerSecond`
          </td>

          <td>
            Nombre de blocs de disque lus dans cette base de données par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `db.bufferHitsPerSecond`
          </td>

          <td>
            Nombre de fois où des blocs de disque ont déjà été trouvés dans le cache tampon, de sorte qu&apos;une lecture n&apos;était pas nécessaire. Cela inclut uniquement les hits dans le cache tampon PostgreSQL, pas dans le cache système de fichiers du système d&apos;exploitation.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsReturnedPerSecond`
          </td>

          <td>
            Lignes renvoyées par requête par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsFetchedPerSecond`
          </td>

          <td>
            Lignes récupérées par requête par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsInsertedPerSecond`
          </td>

          <td>
            Lignes insérées par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsUpdatedPerSecond`
          </td>

          <td>
            Lignes mises à jour par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsDeletedPerSecond`
          </td>

          <td>
            Lignes supprimées par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.tablespacePerSecond`
          </td>

          <td>
            Nombre de requêtes dans cette base de données qui ont été annulées en raison de tablespaces supprimés.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.locksPerSecond`
          </td>

          <td>
            Nombre de requêtes dans cette base de données qui ont été annulées en raison de délais de verrouillage.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.snapshotPerSecond`
          </td>

          <td>
            Nombre de requêtes dans cette base de données qui ont été annulées en raison d&apos;anciens snapshots.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.bufferpinPerSecond`
          </td>

          <td>
            Nombre de requêtes dans cette base de données qui ont été annulées en raison de tampons épinglés.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.deadlockPerSecond`
          </td>

          <td>
            Nombre de requêtes dans cette base de données qui ont été annulées en raison de blocages.
          </td>
        </tr>

        <tr>
          <td>
            `db.tempFilesCreatedPerSecond`
          </td>

          <td>
            Nombre de fichiers temporaires créés par requête dans cette base de données. Tous les fichiers temporaires sont comptés, quelle que soit la raison pour laquelle le fichier temporaire a été créé (par exemple, pour le tri ou le hachage) et quel que soit le paramètre `log_temp_files` .
          </td>
        </tr>

        <tr>
          <td>
            `db.tempWrittenInBytesPerSecond`
          </td>

          <td>
            Quantité totale de données écrites dans des fichiers temporaires par requête dans cette base de données. Tous les fichiers temporaires sont comptés, quelle que soit la raison pour laquelle le fichier temporaire a été créé et quel que soit le paramètre `log_temp_files` .
          </td>
        </tr>

        <tr>
          <td>
            `db.deadlocksPerSecond`
          </td>

          <td>
            Nombre de blocages détectés dans cette base de données.
          </td>
        </tr>

        <tr>
          <td>
            `db.readTimeInMillisecondsPerSecond`
          </td>

          <td>
            Temps passé à lire les blocs de fichiers de données par le backend dans cette base de données, en millisecondes.
          </td>
        </tr>

        <tr>
          <td>
            `db.writeTimeInMillisecondsPerSecond`
          </td>

          <td>
            Temps passé à écrire des blocs de fichiers de données par le backend dans cette base de données, en millisecondes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="indexSample" title="PostgresqlIndexSample métriques">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Attribut PostgreSQLIndexSample
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `index.sizeInBytes`
          </td>

          <td>
            La taille d&apos;un index.
          </td>
        </tr>

        <tr>
          <td>
            `index.rowsReadPerSecond`
          </td>

          <td>
            Le nombre d&apos;entrées d&apos;index renvoyées par les analyses sur cet index.
          </td>
        </tr>

        <tr>
          <td>
            `index.rowsFetchedPerSecond`
          </td>

          <td>
            Le nombre d&apos;entrées d&apos;index récupérées par les analyses sur cet index.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="instanceSample" title="PostgresqlInstanceSample métriques">
    <Callout variant="tip">
      Avec PostgreSQL v17, nous avons renommé certaines métriques pour mieux refléter leurs tables sources. Vous pouvez voir les noms mis à jour en retrait sous leurs versions antérieures.
    </Callout>

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Attribut PostgreSQLInstanceSample
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `bgwriter.checkpointsScheduledPerSecond`<br /> <span style={{ paddingLeft: "1em" }}>↳ `checkpointer.checkpointsScheduledPerSecond`</span>
          </td>

          <td>
            Nombre de points de contrôle planifiés qui ont été effectués.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.checkpointsRequestedPerSecond`<br /> <span style={{ paddingLeft: "1em" }}>↳ `checkpointer.checkpointsRequestedPerSecond`</span>
          </td>

          <td>
            Nombre de points de contrôle demandés qui ont été effectués.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersWrittenForCheckpointsPerSecond`<br /> <span style={{ paddingLeft: "1em" }}>↳ `checkpointer.buffersWrittenForCheckpointsPerSecond`</span>
          </td>

          <td>
            Nombre de tampons écrits pendant les points de contrôle.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersWrittenByBackgroundWriterPerSecond`
          </td>

          <td>
            Nombre de tampons écrits par le rédacteur en arrière-plan.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.backgroundWriterStopsPerSecond`
          </td>

          <td>
            Nombre de fois où le rédacteur en arrière-plan a arrêté une analyse de nettoyage car il avait écrit trop de tampons.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersWrittenByBackendPerSecond`<br /> <span style={{ paddingLeft: "1em" }}>↳ `io.buffersWrittenByBackendPerSecond`</span>
          </td>

          <td>
            Nombre de tampons écrits directement par un backend.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersAllocatedPerSecond`
          </td>

          <td>
            Nombre de tampons alloués.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.backendFsyncCallsPerSecond`<br /> <span style={{ paddingLeft: "1em" }}>↳ `io.backendFsyncCallsPerSecond`</span>
          </td>

          <td>
            Nombre de fois qu&apos;un backend a dû exécuter son propre appel `fsync` . Normalement, le rédacteur en arrière-plan les gère même lorsque le backend effectue sa propre écriture.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.checkpointWriteTimeInMillisecondsPerSecond`<br /> <span style={{ paddingLeft: "1em" }}>↳ `checkpointer.checkpointWriteTimeInMillisecondsPerSecond`</span>
          </td>

          <td>
            Durée totale passée dans la partie du traitement du point de contrôle où les fichiers sont écrits sur le disque, en millisecondes.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.checkpointSyncTimeInMillisecondsPerSecond`<br /> <span style={{ paddingLeft: "1em" }}>↳ `checkpointer.checkpointSyncTimeInMillisecondsPerSecond`</span>
          </td>

          <td>
            Durée totale passée dans la partie du traitement du point de contrôle où les fichiers sont synchronisés sur le disque, en millisecondes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="tableSample" title="PostgresqlTableSample métriques">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Attribut PostgreSQLTableSample
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `table.totalSizeInBytes`
          </td>

          <td>
            L&apos;espace disque total utilisé par la table, y compris les index et les données TOAST.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexSizeInBytes`
          </td>

          <td>
            L&apos;espace disque total utilisé par les index attachés à la table spécifiée.
          </td>
        </tr>

        <tr>
          <td>
            `table.liveRows`
          </td>

          <td>
            Nombre de lignes actives.
          </td>
        </tr>

        <tr>
          <td>
            `table.deadRows`
          </td>

          <td>
            Nombre de lignes mortes.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexBlocksReadPerSecond`
          </td>

          <td>
            Le nombre de blocs de disque lus à partir de tous les index de cette table.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexBlocksHitPerSecond`
          </td>

          <td>
            Le nombre de hits de tampon dans tous les index de cette table.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexToastBlocksReadPerSecond`
          </td>

          <td>
            Le nombre de blocs de disque lus à partir de l&apos;index de table TOAST de cette table.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexToastBlocksHitPerSecond`
          </td>

          <td>
            Le nombre de hits de mémoire tampon dans l&apos;index de table TOAST de cette table.
          </td>
        </tr>

        <tr>
          <td>
            `table.lastVacuum`
          </td>

          <td>
            Heure du dernier vide sur la table.
          </td>
        </tr>

        <tr>
          <td>
            `table.lastAutoVacuum`
          </td>

          <td>
            Heure du dernier vide automatique sur la table.
          </td>
        </tr>

        <tr>
          <td>
            `table.lastAnalyze`
          </td>

          <td>
            Heure de la dernière analyse sur la table.
          </td>
        </tr>

        <tr>
          <td>
            `table.lastAutoAnalyze`
          </td>

          <td>
            Heure de la dernière analyse automatique sur la table.
          </td>
        </tr>

        <tr>
          <td>
            `table.sequentialScansPerSecond`
          </td>

          <td>
            Nombre d&apos;analyses séquentielles lancées sur cette table par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `table.sequentialScanRowsFetchedPerSecond`
          </td>

          <td>
            Nombre de lignes actives récupérées par des analyses séquentielles par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexScansPerSecond`
          </td>

          <td>
            Nombre d&apos;analyses d&apos;index lancées sur cette table.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexScanRowsFetchedPerSecon`
          </td>

          <td>
            Nombre de lignes actives récupérées par les analyses d&apos;index.
          </td>
        </tr>

        <tr>
          <td>
            `table.rowsInsertedPerSecond`
          </td>

          <td>
            Lignes insérées par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `table.rowsUpdatedPerSecond`
          </td>

          <td>
            Lignes mises à jour par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `table.rowsDeletedPerSecond`
          </td>

          <td>
            Lignes supprimées par seconde.
          </td>
        </tr>

        <tr>
          <td>
            `table.bloatSizeInBytes`
          </td>

          <td>
            Taille du gonflement en octets.
          </td>
        </tr>

        <tr>
          <td>
            `table.dataSizeInBytes`
          </td>

          <td>
            Taille de l&apos;espace disque utilisé par la fourche principale de la table.
          </td>
        </tr>

        <tr>
          <td>
            `table.bloatRatio`
          </td>

          <td>
            Fraction de la taille des données du tableau qui est gonflée.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="pgBouncerSample" title="PgBouncerÉchantillons métriques">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Attribut PgBouncerSample
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `pgbouncer.stats.transactionsPerSecond`
          </td>

          <td>
            Le taux de transaction.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.queriesPerSecond`
          </td>

          <td>
            Le taux de requête.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.bytesInPerSecond`
          </td>

          <td>
            Le trafic réseau total reçu.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.bytesOutPerSecond`
          </td>

          <td>
            Le trafic réseau total envoyé.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.totalTransactionDurationInMillisecondsPerSecond`
          </td>

          <td>
            Temps passé par `pgbouncer` dans la transaction.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.totalQueryDurationInMillisecondsPerSecond`
          </td>

          <td>
            Temps passé par `pgbouncer` à interroger activement PostgreSQL.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgTransactionCount`
          </td>

          <td>
            Le nombre moyen de transactions par seconde au cours de la dernière période de statistiques.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgTransactionDurationInMilliseconds`
          </td>

          <td>
            La durée moyenne d&apos;une transaction.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgQueryCount`
          </td>

          <td>
            Le nombre moyen de requêtes par seconde au cours de la dernière période de statistiques.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgBytesIn`
          </td>

          <td>
            Le trafic réseau client reçu.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgBytesOut`
          </td>

          <td>
            Le trafic réseau client a été envoyé.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgQueryDurationInMilliseconds`
          </td>

          <td>
            La durée moyenne d&apos;une requête.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsActive`
          </td>

          <td>
            Connexions client liées à la connexion serveur et capables de traiter les requêtes.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsWaiting`
          </td>

          <td>
            Connexions client en attente d&apos;une connexion serveur.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsWaitingCancelReq`
          </td>

          <td>
            Connexions client qui n’ont pas encore transmis les annulations de requête au serveur.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsActiveCancelReq`
          </td>

          <td>
            Connexions client qui ont transmis des annulations de requête au serveur et attendent la réponse du serveur.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsActiveCancel`
          </td>

          <td>
            Connexions au serveur qui transmettent actuellement une demande d&apos;annulation.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsBeingCancel`
          </td>

          <td>
            Serveurs qui pourraient normalement devenir inactifs mais qui attendent de le faire jusqu&apos;à ce que toutes requests d&apos;annulation en cours qui ont été envoyées pour annuler une requête sur ce serveur soient terminées.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsActive`
          </td>

          <td>
            Connexions serveur liées à une connexion client.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsIdle`
          </td>

          <td>
            Les connexions au serveur sont inactives et prêtes pour une requête client.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsUsed`
          </td>

          <td>
            Les connexions au serveur sont inactives plus de `server_check_delay`, nécessitant `server_check_query`.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsTested`
          </td>

          <td>
            Les connexions au serveur s&apos;exécutent actuellement sur `server_reset_query` ou `server_check_query`.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsLogin`
          </td>

          <td>
            Connexions au serveur actuellement en cours de connexion.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.maxwaitInMilliseconds`
          </td>

          <td>
            Âge de la plus ancienne connexion client non desservie.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>