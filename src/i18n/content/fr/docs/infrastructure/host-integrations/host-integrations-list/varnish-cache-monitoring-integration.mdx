---
title: Varnish monitoring Intégration du cache
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: 'New Relic''s Varnish Cache integration: how to install it and configure it, and what data it reports.'
freshnessValidatedDate: never
translationType: machine
---

L&apos;intégration de Varnish Cache [sur hôte](/docs/integrations/host-integrations/getting-started/introduction-host-integrations) collecte et envoie l&apos;inventaire et les métriques de votre environnement Varnish Cache à New Relic afin que vous puissiez monitorer son état de santé. Nous collectons des métriques aux niveaux de l&apos;instance, du verrouillage, du pool de mémoire, du stockage et du backend.

Lisez la suite pour installer l’intégration et voir quelles données nous collectons.

## Compatibilité et exigences [#comp-req]

Notre intégration est compatible avec Varnish Cache 1.0 ou supérieur.

Avant d’installer l’intégration, assurez-vous que vous répondez aux exigences suivantes :

* [Installez l&apos;agent d&apos;infrastructure](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic).
* Distribution Linux ou version Windows [compatible avec notre agent d&apos;infrastructure](/docs/infrastructure/new-relic-infrastructure/getting-started/compatibility-requirements-new-relic-infrastructure).

## Démarrage rapide [#quick]

instrumentez votre environnement Varnish Cache rapidement et envoyez vos données télémétriques avec installation guidée. Notre installation guidée crée une commande CLI personnalisée pour votre environnement qui télécharge et installe la CLI New Relic et l&apos;agent d&apos;infrastructure.

Prêt à commencer ? Cliquez sur l&apos;un de ces boutons pour l&apos;essayer.

<ButtonGroup>
  <ButtonLink role="button" to="https://one.newrelic.com/marketplace/install-data-source?state=eda6d17b-58b5-5e7a-18ca-3b4ce777ecff" variant="primary">
    Installation guidée
  </ButtonLink>

  <ButtonLink role="button" to="https://one.eu.newrelic.com/marketplace/install-data-source?state=eda6d17b-58b5-5e7a-18ca-3b4ce777ecff" variant="primary">
    Guide d&apos;installation de l&apos;UE
  </ButtonLink>
</ButtonGroup>

Notre installation guidée utilise l&apos;agent d&apos;infrastructure pour configurer l&apos;intégration de Varnish Cache. De plus, il détecte d’autres applications et sources log exécutées dans votre environnement, puis recommande celles que vous devez intrumenter.

L&apos;installation guidée fonctionne avec la plupart des configurations. Mais si cela ne répond pas à vos besoins, vous pouvez trouver d&apos;autres méthodes ci-dessous pour commencer monitoring votre environnement Varnish Cache.

## Installer et activer [#install]

Pour installer l’intégration de Varnish Cache :

<CollapserGroup>
  <Collapser id="linux-install" title="Installation de Linux">
    1. Installez [l&apos;agent d&apos;infrastructure](/docs/integrations/host-integrations/installation/install-infrastructure-host-integrations/#install) et remplacez la variable `INTEGRATION_FILE_NAME` par `nri-varnish`.

    2. Changer de répertoire vers le dossier d&apos;intégration :

       ```
       cd /etc/newrelic-infra/integrations.d
       ```

    3. Copie du fichier de configuration d&apos;exemple :

       ```
       sudo cp varnish-config.yml.sample varnish-config.yml
       ```

    4. Modifiez le fichier `varnish-config.yml` comme décrit dans les [paramètres de configuration](#config).
  </Collapser>

  <Collapser id="windows-install" title="Installation de Windows">
    1. Téléchargez l&apos;image du programme d&apos;installation `nri-varnish` .MSI depuis :

       [https://download.newrelic.com/infrastructure\_agent/windows/integrations/nri-varnish/nri-varnish-amd64.msi](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-varnish/nri-varnish-amd64.msi)

    2. Pour installer à partir de l’invite de commande Windows, exécutez :

       ```shell
       msiexec.exe /qn /i PATH\TO\nri-varnish-amd64.msi
       ```

    3. Dans le répertoire d’intégration, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, créez une copie du fichier configuration d’exemple en exécutant :

       ```shell
       copy varnish-config.yml.sample varnish-config.yml
       ```

    4. Modifiez le fichier `varnish-config.yml` comme décrit dans les [paramètres de configuration](#config).
  </Collapser>
</CollapserGroup>

Notes supplémentaires :

* <DNT>**Advanced:**</DNT> Il est également possible d&apos;[installer l&apos;intégration à partir d&apos;un fichier tarball](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball). Cela vous donne un contrôle total sur le processus d&apos;installation et de configuration.
* <DNT>**On-host integrations do not automatically update.**</DNT> Pour de meilleurs résultats, mettez régulièrement [à jour le package d&apos;intégration](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) et [l&apos;agent d&apos;infrastructure](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

<InstallFeedback />

## Configurer l&apos;intégration [#config]

La configuration au format YAML d&apos;une intégration est l&apos;endroit où vous pouvez placer les informations de connexion requises et configurer la manière dont les données sont collectées. Les options que vous modifiez dépendent de votre configuration et de vos préférences.

Le fichier configuration contient des paramètres communs applicables à toutes les intégrations telles que `interval`, `timeout`, `inventory_source`. Pour tout savoir sur ces paramètres courants, reportez-vous à notre document [Format de configuration](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) .

<Callout variant="important">
  Si vous utilisez toujours nos legacy fichiers configuration/définition, veuillez vous référer à ce [document](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/) pour obtenir de l&apos;aide.
</Callout>

Les paramètres spécifiques liés à Varnish sont définis à l&apos;aide de la section `env` du fichier de configuration. Ces paramètres contrôlent la connexion à votre Varnish instance, ainsi que d&apos;autres paramètres et fonctionnalités de sécurité. La liste des paramètres valides est décrite dans la section suivante.

### Varnish instance Paramètres de cache de [#instance-settings]

L&apos;intégration de Varnish Cache collecte à la fois les informations de métriques (<strong>M</strong>) et d&apos;inventaire (<strong>I</strong>). Consultez la colonne <DNT>**Applies To**</DNT> ci-dessous pour savoir quels paramètres peuvent être utilisés pour chaque collection spécifique :

&apos; &apos;

<table>
  <thead>
    <tr>
      <th style={{ width: '150px' }}>
        Paramètre
      </th>

      <th>
        Description
      </th>

      <th>
        Défaut
      </th>

      <th>
        S&apos;applique à
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <DNT>
          **INSTANCE\_NAME**
        </DNT>
      </td>

      <td>
        Nom défini par l&apos;utilisateur pour identifier les données de cette instance dans New Relic. <DNT>**Required**</DNT>.
      </td>

      <td>
        N/A
      </td>

      <td style={{ "text-align": "center" }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **PARAMS\_CONFIG\_FILE**
        </DNT>
      </td>

      <td>
        L&apos;emplacement du fichier de configuration `varnish.params` . Si cet argument est omis, les emplacements suivants seront vérifiés :

        * `/etc/default/varnish/varnish.params`

        * `/etc/sysconfig/varnish/varnish.params`

          Remarque : l’emplacement et le nom du fichier de configuration Varnish peuvent varier. Pour plus de détails, voir [Différents emplacements du fichier de configuration Varnish](https://book.varnish-software.com/4.0/chapters/Getting_Started.html#different-locations-of-the-varnish-configuration-file). Pour Varnish 6 et versions ultérieures, ce paramètre n&apos;est pas obligatoire et l&apos;intégration doit être configurée pour la collecte de métriques uniquement. Voir [l&apos;exemple pour Varnish 6](#example6).
      </td>

      <td>
        N/A
      </td>

      <td style={{ "text-align": "center" }}>
        je
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **VARNISH\_NAME**
        </DNT>
      </td>

      <td>
        Nom utilisé lors de l&apos;exécution du daemon `varnishd` avec un indicateur `-n` personnalisé. <DNT>**Optional**</DNT>.
      </td>

      <td>
        N/A
      </td>

      <td style={{ "text-align": "center" }}>
        M
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **METRICS**
        </DNT>
      </td>

      <td>
        Définissez sur `true` pour activer la collecte de métriques uniquement.
      </td>

      <td>
        `false`
      </td>

      <td style={{ "text-align": "center" }} />
    </tr>

    <tr>
      <td>
        <DNT>
          **INVENTORY**
        </DNT>
      </td>

      <td>
        Définissez sur `true` pour activer la collecte d&apos;inventaire uniquement.
      </td>

      <td>
        `false`
      </td>

      <td style={{ "text-align": "center" }} />
    </tr>
  </tbody>
</table>

Les commandes `varnish-config.yml` acceptent les arguments suivants :

Les valeurs de ces paramètres peuvent être définies de plusieurs manières :

* Ajout de la valeur directement dans le fichier de configuration. C&apos;est la manière la plus courante.
* Remplacement des valeurs des variables d’environnement à l’aide de la notation `{{}}` . Cela nécessite l&apos;agent d&apos;infrastructure v1.14.0+. Lire la suite [ici](/docs/infrastructure/install-infrastructure-agent/configuration/configure-infrastructure-agent/#passthrough).
* Utilisation de la gestion des secrets. Utilisez ceci pour protéger les informations sensibles, telles que les mots de passe qui seraient exposés en texte brut dans le fichier de configuration. Pour plus d&apos;informations, voir [Gestion des secrets](/docs/integrations/host-integrations/installation/secrets-management).

### Étiquettes/attributs personnalisés [#labels]

Les variables d&apos;environnement peuvent être utilisées pour contrôler les paramètres de configuration, tels que votre <InlinePopover type="licenseKey" />, et sont ensuite transmises à l&apos;agent d&apos;infrastructure. Pour obtenir des instructions sur l’utilisation de cette fonctionnalité, consultez [Configurer l’agent d’infrastructure](/docs/infrastructure/new-relic-infrastructure/configuration/configure-infrastructure-agent#passthrough). Vous pouvez également décorer vos métriques à l’aide d’étiquettes. Les étiquettes vous permettent d&apos;ajouter des paires valeur-clé à vos métriques que vous pouvez ensuite utiliser pour interroger, filtrer ou regrouper vos métriques.<br /> Notre fichier de configuration d&apos;exemple par défaut inclut des exemples d&apos;étiquettes mais, comme ils ne sont pas obligatoires, vous pouvez supprimer, modifier ou ajouter de nouvelles étiquettes de votre choix.

```
 labels:
   env: production
   role: varnish
```

## Exemple de configuration [#example-config]

Exemple de configuration de fichier `varnish-config.yml` :

<CollapserGroup>
  <Collapser id="example" title="Exemple de configuration">
    Voici la configuration de base pour collecter des métriques et des inventaires :

    ```
    integrations:
      - name: nri-varnish
        env:
          INSTANCE_NAME: new_relic
          PARAMS_CONFIG_FILE: /etc/default/varnish/varnish.params
        interval: 15s
        labels:
          env: production
          role: varnish
        inventory_source: config/varnish
    ```
  </Collapser>

  <Collapser id="example6" title="configuration pour Varnish 6+">
    Il s&apos;agit d&apos;une configuration de base pour Varnish 6 ou supérieur. Seules les métriques seront collectées car, à partir de Varnish 6, le fichier de paramètres est obsolète.

    ```
    integrations:
      - name: nri-varnish
        env:
          INSTANCE_NAME: new_relic
          METRICS: true
        interval: 15s
        labels:
          env: production
          role: varnish
        inventory_source: config/varnish
    ```
  </Collapser>
</CollapserGroup>

Pour en savoir plus sur la structure générale de l&apos;intégration sur hôte configuration, voir [configuration](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview).

## Rechercher et utiliser des données [#find-and-use]

Pour trouver vos données d’intégration dans New Relic, accédez à <DNT>**[one.newrelic.com &gt; All capabilities](https://one.newrelic.com/all-capabilities) &gt; Infrastructure &gt; Third-party services**</DNT> et sélectionnez l’un des liens d’intégration Varnish Cache.

Dans New Relic, les données du cache Varnish sont attachées au type d&apos;événement suivant :

* `VarnishSample`
* `VarnishLockSample`
* `VarnishStorageSample`
* `VarnishMempoolSample`
* `VarnishBackendSample`

Pour en savoir plus sur la recherche et l’utilisation de vos données, consultez [Comprendre les données d’intégration](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## données métriques [#metrics]

L&apos;intégration Varnish Cache collecte l&apos;attribut de données métriques suivant. Chaque nom de métrique est préfixé par un indicateur de catégorie et un point, tel que `bans.` ou `main.`.

<Callout variant="tip">
  Un certain nombre de métriques sont calculées sous forme de taux (par seconde) au lieu de totaux comme les noms des métriques pourraient le suggérer. Pour plus de détails sur les métriques calculées en tant que taux, reportez-vous au [fichier spec.csv](https://github.com/newrelic/nri-varnish/blob/master/spec.csv).
</Callout>

### Échantillon de Varnish métriques [#varnish-sample]

Ces attributs peuvent être trouvés en interrogeant les types d&apos;événements VarnishSample.

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        métrique
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `backend.connectionBusy`
      </td>

      <td>
        Nombre de fois où la connexion maximale a été atteinte.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionFails`
      </td>

      <td>
        Nombre de connexions échouées au serveur sauvegardé.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionRecycles`
      </td>

      <td>
        Nombre de connexions backend qui ont été recyclées.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionRetries`
      </td>

      <td>
        Nombre de connexions backend qui ont été retentées.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionReuses`
      </td>

      <td>
        Nombre de réutilisations de connexions backend.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionSuccess`
      </td>

      <td>
        Nombre de connexions backend réussies,
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionUnHealthy`
      </td>

      <td>
        Nombre de connexions backend qui n&apos;ont pas été tentées en raison d&apos;un statut backend « malsain ».
      </td>
    </tr>

    <tr>
      <td>
        `backend.fetches`
      </td>

      <td>
        Nombre total de récupérations backend initiées.
      </td>
    </tr>

    <tr>
      <td>
        `backend.requests`
      </td>

      <td>
        Nombre total de de backend connexion requests effectuées.
      </td>
    </tr>

    <tr>
      <td>
        `bans.added`
      </td>

      <td>
        Compteur d&apos;interdictions ajouté à la liste des interdictions.
      </td>
    </tr>

    <tr>
      <td>
        `bans.completed`
      </td>

      <td>
        Nombre d&apos;interdictions marquées comme « terminées ».
      </td>
    </tr>

    <tr>
      <td>
        `bans.cutoffLurkerKilled`
      </td>

      <td>
        Nombre d&apos;objets tués par des interdictions pour coupure (lurker).
      </td>
    </tr>

    <tr>
      <td>
        `bans.deleted`
      </td>

      <td>
        Compteur d&apos;interdictions supprimées de la liste des interdictions.
      </td>
    </tr>

    <tr>
      <td>
        `bans.dups`
      </td>

      <td>
        Nombre d&apos;interdictions remplacées par des interdictions ultérieures identiques.
      </td>
    </tr>

    <tr>
      <td>
        `bans.fragmentationInBytes`
      </td>

      <td>
        Octets supplémentaires dans les listes d&apos;interdiction persistantes en raison de la fragmentation.
      </td>
    </tr>

    <tr>
      <td>
        `bans.lookupKilled`
      </td>

      <td>
        Nombre d&apos;objets tués par des interdictions lors de la recherche d&apos;objets.
      </td>
    </tr>

    <tr>
      <td>
        `bans.lookupTestsTested`
      </td>

      <td>
        Nombre de tests et d&apos;objets testés les uns par rapport aux autres pendant la recherche.
      </td>
    </tr>

    <tr>
      <td>
        `bans.lurkerCon`
      </td>

      <td>
        Nombre de fois où le ban-lurker a dû attendre des recherches.
      </td>
    </tr>

    <tr>
      <td>
        `bans.lurkerKilled`
      </td>

      <td>
        Nombre d&apos;objets tués par le ban-lurker.
      </td>
    </tr>

    <tr>
      <td>
        `bans.lurkerTested`
      </td>

      <td>
        Compte du nombre d&apos;interdictions et d&apos;objets testés les uns contre les autres par le ban-lurker.
      </td>
    </tr>

    <tr>
      <td>
        `bans.lurkerTestsTested`
      </td>

      <td>
        Compte du nombre de tests et d&apos;objets testés les uns contre les autres par le ban-lurker.
      </td>
    </tr>

    <tr>
      <td>
        `bans.obj`
      </td>

      <td>
        Nombre d&apos;interdictions utilisant `obj.*` variables. Ces interdictions peuvent éventuellement être effacées par le ban-lurker.
      </td>
    </tr>

    <tr>
      <td>
        `bans.persistedInBytes`
      </td>

      <td>
        Octets utilisés par les listes d&apos;interdiction persistantes.
      </td>
    </tr>

    <tr>
      <td>
        `bans.req`
      </td>

      <td>
        Nombre d&apos;interdictions qui utilisent `req.*` variables. Ces interdictions ne peuvent pas être effacées par le ban-lurker.
      </td>
    </tr>

    <tr>
      <td>
        `bans.tested`
      </td>

      <td>
        Nombre d&apos;interdictions et d&apos;objets testés les uns contre les autres lors de la recherche Hacher.
      </td>
    </tr>

    <tr>
      <td>
        `cache.graceHits`
      </td>

      <td>
        Compte de taux d&apos;accès au cache avec grâce. Un taux d&apos;accès au cache avec grâce est un taux d&apos;accès au cache où l&apos;objet est expiré. Ces hits sont également inclus dans le compteur `cache_hit` .
      </td>
    </tr>

    <tr>
      <td>
        `cache.hits`
      </td>

      <td>
        Nombre de fois qu&apos;un objet a été livré à un client sans être récupéré auprès d&apos;un serveur backend.
      </td>
    </tr>

    <tr>
      <td>
        `cache.misses`
      </td>

      <td>
        Nombre de fois où l&apos;objet a été récupéré depuis le backend avant de le livrer au client.
      </td>
    </tr>

    <tr>
      <td>
        `cache.missHits`
      </td>

      <td>
        Nombre de fois qu&apos;un objet touché a été renvoyé pour une réponse manquée.
      </td>
    </tr>

    <tr>
      <td>
        `cache.passHits`
      </td>

      <td>
        Nombre de fois qu&apos;un objet touché a été renvoyé pour une réponse de réussite.
      </td>
    </tr>

    <tr>
      <td>
        `esi.errors`
      </td>

      <td>
        Erreurs d&apos;analyse Edge Side Included (ESI) (déverrouillage).
      </td>
    </tr>

    <tr>
      <td>
        `esi.warnings`
      </td>

      <td>
        Avertissements d&apos;analyse Edge Side Included (ESI) (déverrouillage).
      </td>
    </tr>

    <tr>
      <td>
        `fetch.bad`
      </td>

      <td>
        La longueur/récupération `beresp.body` n&apos;a pas pu être déterminée.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.chuncked`
      </td>

      <td>
        Le `beresp.body` est fragmenté.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.contentLength`
      </td>

      <td>
        Le `beresp.body` avec la longueur du contenu.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.eof`
      </td>

      <td>
        Le `beresp.body` avec EOF.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.failed`
      </td>

      <td>
        Le `beresp` a échoué.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.head`
      </td>

      <td>
        Le `beresp` sans corps car la requête est HEAD.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.noBody`
      </td>

      <td>
        Le `beresp` sans corps.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.noBody1xx`
      </td>

      <td>
        Le `beresp` sans corps à cause de la réponse 1XX.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.noBody204`
      </td>

      <td>
        Le `beresp` sans corps à cause de la réponse 204.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.noBody304`
      </td>

      <td>
        Le `beresp` sans corps à cause de la réponse 304.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.noThreadFail`
      </td>

      <td>
        La récupération `beresp` a échoué, aucun thread disponible.
      </td>
    </tr>

    <tr>
      <td>
        `hcb.inserts`
      </td>

      <td>
        Nombre d&apos;inserts de hachage basés sur l&apos;arbre de bits critiques (HCB).
      </td>
    </tr>

    <tr>
      <td>
        `hcb.lock`
      </td>

      <td>
        Nombre de recherches HCB avec verrou.
      </td>
    </tr>

    <tr>
      <td>
        `hcb.noLock`
      </td>

      <td>
        Nombre de recherches HCB sans verrou.
      </td>
    </tr>

    <tr>
      <td>
        `lru.limited`
      </td>

      <td>
        Un nombre de fois plus d&apos;espace de stockage était nécessaire, mais la limite a été atteinte.
      </td>
    </tr>

    <tr>
      <td>
        `lru.moved`
      </td>

      <td>
        Nombre d&apos;opérations de déplacement effectuées sur la liste LRU.
      </td>
    </tr>

    <tr>
      <td>
        `lru.nuked`
      </td>

      <td>
        Nombre d&apos;objets les moins récemment utilisés (LRU) expulsés de force du stockage pour faire de la place à un nouvel objet.
      </td>
    </tr>

    <tr>
      <td>
        `main.backends`
      </td>

      <td>
        Nombre de backend.
      </td>
    </tr>

    <tr>
      <td>
        `main.bans`
      </td>

      <td>
        Nombre d&apos;interdictions.
      </td>
    </tr>

    <tr>
      <td>
        `main.busyKilled`
      </td>

      <td>
        Nombre de requests tuées après une mise en veille sur un objhdr occupé.
      </td>
    </tr>

    <tr>
      <td>
        `main.busySleep`
      </td>

      <td>
        Nombre de requests envoyées pour dormir sur un objhdr occupé.
      </td>
    </tr>

    <tr>
      <td>
        `main.busyWakeup`
      </td>

      <td>
        Nombre de requests réveillées après une mise en veille sur un objhdr occupé.
      </td>
    </tr>

    <tr>
      <td>
        `main.expired`
      </td>

      <td>
        Nombre d&apos;objets expirés.
      </td>
    </tr>

    <tr>
      <td>
        `main.expiredMailed`
      </td>

      <td>
        Nombre d&apos;objets envoyés au fil d&apos;expiration.
      </td>
    </tr>

    <tr>
      <td>
        `main.expiredReceived`
      </td>

      <td>
        Nombre d&apos;objets reçus par thread d&apos;expiration.
      </td>
    </tr>

    <tr>
      <td>
        `main.gunzip`
      </td>

      <td>
        Nombre d&apos;opérations gunzip.
      </td>
    </tr>

    <tr>
      <td>
        `main.gunzipTest`
      </td>

      <td>
        Nombre d&apos;opérations de test gunzip.
      </td>
    </tr>

    <tr>
      <td>
        `main.gzip`
      </td>

      <td>
        Nombre d&apos;opérations gzip.
      </td>
    </tr>

    <tr>
      <td>
        `main.objectcores`
      </td>

      <td>
        Nombre de structures objectcore créées.
      </td>
    </tr>

    <tr>
      <td>
        `main.objectheads`
      </td>

      <td>
        Nombre de structures objectées créées.
      </td>
    </tr>

    <tr>
      <td>
        `main.objects`
      </td>

      <td>
        Nombre de structures d&apos;objets créées.
      </td>
    </tr>

    <tr>
      <td>
        `main.passedRequests`
      </td>

      <td>
        Nombre total requests passées vues.
      </td>
    </tr>

    <tr>
      <td>
        `main.pipeSessions`
      </td>

      <td>
        Nombre total de séances de pipes observées.
      </td>
    </tr>

    <tr>
      <td>
        `main.pools`
      </td>

      <td>
        Nombre de pools de threads.
      </td>
    </tr>

    <tr>
      <td>
        `main.purgeObjects`
      </td>

      <td>
        Nombre d&apos;objets purgés.
      </td>
    </tr>

    <tr>
      <td>
        `main.purgeOperations`
      </td>

      <td>
        Nombre d&apos;opérations de purge exécutées.
      </td>
    </tr>

    <tr>
      <td>
        `main.reqDropped`
      </td>

      <td>
        Nombre de requests abandonnées.
      </td>
    </tr>

    <tr>
      <td>
        `main.sessions`
      </td>

      <td>
        Nombre total de séances vues.
      </td>
    </tr>

    <tr>
      <td>
        `main.sessQueueLength`
      </td>

      <td>
        Durée de la file d&apos;attente de session en attente de threads.
      </td>
    </tr>

    <tr>
      <td>
        `main.summs`
      </td>

      <td>
        Nombre de fois où les statistiques par thread ont été additionnées dans les compteurs globaux.
      </td>
    </tr>

    <tr>
      <td>
        `main.syntheticResponses`
      </td>

      <td>
        Réponses synthétiques totales réalisées.
      </td>
    </tr>

    <tr>
      <td>
        `main.threads`
      </td>

      <td>
        Nombre total de threads.
      </td>
    </tr>

    <tr>
      <td>
        `main.threadsCreated`
      </td>

      <td>
        Nombre total de threads créés dans tous les pools.
      </td>
    </tr>

    <tr>
      <td>
        `main.threadsDestroyed`
      </td>

      <td>
        Nombre total de threads détruits dans tous les pools.
      </td>
    </tr>

    <tr>
      <td>
        `main.threadsFailed`
      </td>

      <td>
        Nombre de fois où la création d&apos;un thread a échoué.
      </td>
    </tr>

    <tr>
      <td>
        `main.threadsLimited`
      </td>

      <td>
        Nombre de fois où davantage de threads ont été nécessaires, mais la limite a été atteinte dans un pool de threads.
      </td>
    </tr>

    <tr>
      <td>
        `main.unresurrectedObjects`
      </td>

      <td>
        Nombre d&apos;objets non ressuscités.
      </td>
    </tr>

    <tr>
      <td>
        `main.uptimeInMilliseconds`
      </td>

      <td>
        Le temps de disponibilité du processus enfant, en millisecondes.
      </td>
    </tr>

    <tr>
      <td>
        `main.vclAvailable`
      </td>

      <td>
        Nombre de langages de configuration Varnish (VCL) disponibles.
      </td>
    </tr>

    <tr>
      <td>
        `main.vclDiscarded`
      </td>

      <td>
        Nombre de VCL rejetés.
      </td>
    </tr>

    <tr>
      <td>
        `main.vclFails`
      </td>

      <td>
        Nombre d&apos;échecs VCL.
      </td>
    </tr>

    <tr>
      <td>
        `main.vclLoaded`
      </td>

      <td>
        Nombre total de VCL chargés.
      </td>
    </tr>

    <tr>
      <td>
        `main.vmodsLoaded`
      </td>

      <td>
        Nombre de modules Varnish chargés (VMOD).
      </td>
    </tr>

    <tr>
      <td>
        `mgt.childDied`
      </td>

      <td>
        Nombre de fois où le processus enfant est mort à cause de signaux.
      </td>
    </tr>

    <tr>
      <td>
        `mgt.childDump`
      </td>

      <td>
        Nombre de fois où le processus enfant a produit des vidages de mémoire.
      </td>
    </tr>

    <tr>
      <td>
        `mgt.childExit`
      </td>

      <td>
        Nombre de fois où le processus enfant a été arrêté proprement.
      </td>
    </tr>

    <tr>
      <td>
        `mgt.childPanic`
      </td>

      <td>
        Nombre de fois où le processus de gestion a pris un enfant en panique.
      </td>
    </tr>

    <tr>
      <td>
        `mgt.childStart`
      </td>

      <td>
        Nombre de fois que le processus enfant a été démarré.
      </td>
    </tr>

    <tr>
      <td>
        `mgt.childStop`
      </td>

      <td>
        Nombre de fois où le processus enfant a été arrêté proprement.
      </td>
    </tr>

    <tr>
      <td>
        `mgt.uptimeInMilliseconds`
      </td>

      <td>
        Le temps de disponibilité du processus de gestion, en millisecondes.
      </td>
    </tr>

    <tr>
      <td>
        `net.400Errors`
      </td>

      <td>
        Nombre de requests clients reçues, sujettes à 400 erreurs.
      </td>
    </tr>

    <tr>
      <td>
        `net.417Errors`
      </td>

      <td>
        Nombre de requests clients reçues, sujettes à des erreurs 417
      </td>
    </tr>

    <tr>
      <td>
        `net.httpOverflow`
      </td>

      <td>
        Nombre de débordements d&apos;en-tête HTTP.
      </td>
    </tr>

    <tr>
      <td>
        `net.pipe.inInBytes`
      </td>

      <td>
        Nombre total d&apos;octets transmis par les clients dans les sessions de pipeline.
      </td>
    </tr>

    <tr>
      <td>
        `net.pipe.outInBytes`
      </td>

      <td>
        Nombre total d&apos;octets transmis aux clients dans les sessions de pipeline.
      </td>
    </tr>

    <tr>
      <td>
        `net.pipereq.headerInBytes`
      </td>

      <td>
        Nombre total d&apos;octets de demande reçus pour les sessions canalisées.
      </td>
    </tr>

    <tr>
      <td>
        `net.request.bodyInBytes`
      </td>

      <td>
        Corps total de la requête transmis, en octets.
      </td>
    </tr>

    <tr>
      <td>
        `net.request.headerInBytes`
      </td>

      <td>
        Nombre total d&apos;en-têtes de requête transmis, en octets.
      </td>
    </tr>

    <tr>
      <td>
        `net.requests`
      </td>

      <td>
        Nombre de bonnes requests de clients reçues.
      </td>
    </tr>

    <tr>
      <td>
        `net.response.bodyInBytes`
      </td>

      <td>
        Corps total de la réponse transmis, en octets.
      </td>
    </tr>

    <tr>
      <td>
        `net.response.headerInBytes`
      </td>

      <td>
        Nombre total d&apos;en-têtes de réponse transmis, en octets.
      </td>
    </tr>

    <tr>
      <td>
        `sess.backendClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `RESP_CLOSE`, (backend/VCL a demandé la fermeture).
      </td>
    </tr>

    <tr>
      <td>
        `sess.badClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `Error RX_BAD`, (mauvaise demande/réponse reçue).
      </td>
    </tr>

    <tr>
      <td>
        `sess.bodyFailClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `Error RX_BODY`, (Échec de réception de req.body).
      </td>
    </tr>

    <tr>
      <td>
        `sess.clientClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `REM_CLOSE`, (Client fermé).
      </td>
    </tr>

    <tr>
      <td>
        `sess.clientReqClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `REQ_CLOSE`, (Client a demandé la fermeture).
      </td>
    </tr>

    <tr>
      <td>
        `sess.closed`
      </td>

      <td>
        Nombre total de sessions clôturées.
      </td>
    </tr>

    <tr>
      <td>
        `sess.closedError`
      </td>

      <td>
        Nombre total de sessions fermées avec des erreurs.
      </td>
    </tr>

    <tr>
      <td>
        `sess.dropped`
      </td>

      <td>
        Nombre de sessions abandonnées pour le thread.
      </td>
    </tr>

    <tr>
      <td>
        `sess.eofTxnClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `TX_EOF`, (transmission EOF).
      </td>
    </tr>

    <tr>
      <td>
        `sess.errorTxnClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `TX_ERROR`, (Erreur de transaction).
      </td>
    </tr>

    <tr>
      <td>
        `sess.herd`
      </td>

      <td>
        Nombre de fois que le `timeout_linger` a été déclenché.
      </td>
    </tr>

    <tr>
      <td>
        `sess.junkClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `RX_JUNK`, (Données indésirables reçues).
      </td>
    </tr>

    <tr>
      <td>
        `sess.overflowClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `RX_OVERFLOW`, (Dépassement de tampon reçu).
      </td>
    </tr>

    <tr>
      <td>
        `sess.overloadClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `OVERLOAD`, (Manque de ressources).
      </td>
    </tr>

    <tr>
      <td>
        `sess.pipeOverflowClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `PIPE_OVERFLOW`, (dépassement de capacité du canal de session).
      </td>
    </tr>

    <tr>
      <td>
        `sess.pipeTxnClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `TX_PIPE`, (Transaction canalisée).
      </td>
    </tr>

    <tr>
      <td>
        `sess.queued`
      </td>

      <td>
        Nombre de sessions en file d&apos;attente pour le thread.
      </td>
    </tr>

    <tr>
      <td>
        `sess.readAhead`
      </td>

      <td>
        Session à lire à l&apos;avance.
      </td>
    </tr>

    <tr>
      <td>
        `sess.requestHTTP10Close`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `REQ_HTTP10`, (Proto &lt; HTTP/1.1).
      </td>
    </tr>

    <tr>
      <td>
        `sess.requestHTTP20Close`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `REQ_HTTP20`, (HTTP2 non accepté).
      </td>
    </tr>

    <tr>
      <td>
        `sess.shortRangeClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `RANGE_SHORT`, (Données insuffisantes pour la plage).
      </td>
    </tr>

    <tr>
      <td>
        `sess.timeoutClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `RX_TIMEOUT`, (Délai de réception dépassé).
      </td>
    </tr>

    <tr>
      <td>
        `sess.vclFailClose`
      </td>

      <td>
        Nombre de sessions fermées avec l&apos;erreur `VCL_FAILURE`, (échec VCL).
      </td>
    </tr>

    <tr>
      <td>
        `session.connections`
      </td>

      <td>
        Nombre de sessions acceptées avec succès.
      </td>
    </tr>

    <tr>
      <td>
        `session.drops`
      </td>

      <td>
        Le nombre de sessions a été supprimé silencieusement en raison du manque de thread de travail.
      </td>
    </tr>

    <tr>
      <td>
        `session.fail`
      </td>

      <td>
        Nombre d&apos;échecs d&apos;acceptation de connexion TCP.
      </td>
    </tr>

    <tr>
      <td>
        `shm.contentions`
      </td>

      <td>
        Nombre de conflits de mémoire partagée (SHM) MTX.
      </td>
    </tr>

    <tr>
      <td>
        `shm.cycles`
      </td>

      <td>
        Nombre de cycles SHM dans la mémoire tampon.
      </td>
    </tr>

    <tr>
      <td>
        `shm.flushes`
      </td>

      <td>
        Nombre de chasses d&apos;eau SHM dues à un débordement.
      </td>
    </tr>

    <tr>
      <td>
        `shm.records`
      </td>

      <td>
        Nombre d&apos;enregistrements SHM.
      </td>
    </tr>

    <tr>
      <td>
        `shm.writes`
      </td>

      <td>
        Nombre d&apos;écritures SHM.
      </td>
    </tr>

    <tr>
      <td>
        `workspace.backendOverflow`
      </td>

      <td>
        Nombre de fois où nous avons manqué d&apos;espace dans `workspace_backend`.
      </td>
    </tr>

    <tr>
      <td>
        `workspace.clientOverflow`
      </td>

      <td>
        Nombre de fois où nous avons manqué d&apos;espace dans `workspace_client`.
      </td>
    </tr>

    <tr>
      <td>
        `workspace.deliveryFail`
      </td>

      <td>
        La livraison a échoué en raison d&apos;un espace de travail insuffisant.
      </td>
    </tr>

    <tr>
      <td>
        `workspace.sessionOverflow`
      </td>

      <td>
        Nombre de fois où nous avons manqué d&apos;espace dans `workspace_session`.
      </td>
    </tr>

    <tr>
      <td>
        `workspace.threadOverflow`
      </td>

      <td>
        Nombre de fois où nous avons manqué d&apos;espace dans `workspace_thread`.
      </td>
    </tr>
  </tbody>
</table>

### Échantillon de mèches de Varnish métriques [#varnish-lock-sample]

Ces attributs peuvent être trouvés en interrogeant le type d&apos;événement `VarnishLockSample` .

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        métrique
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `lock.created`
      </td>

      <td>
        Nombre de verrous créés.
      </td>
    </tr>

    <tr>
      <td>
        `lock.destroyed`
      </td>

      <td>
        Nombre de serrures détruites.
      </td>
    </tr>

    <tr>
      <td>
        `lock.locks`
      </td>

      <td>
        Nombre d&apos;opérations de verrouillage.
      </td>
    </tr>
  </tbody>
</table>

### Métriques d&apos;échantillons de stockage Varnish [#varnish-storage-sample]

Ces attributs peuvent être trouvés en interrogeant le type d&apos;événement `VarnishStorageSample` .

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        métrique
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `storage.allocFails`
      </td>

      <td>
        Nombre de fois où le stockage n&apos;a pas réussi à fournir un segment de stockage.
      </td>
    </tr>

    <tr>
      <td>
        `storage.allocInBytes`
      </td>

      <td>
        Nombre total d&apos;octets alloués par ce stockage.
      </td>
    </tr>

    <tr>
      <td>
        `storage.allocOustanding`
      </td>

      <td>
        Nombre d&apos;allocations de stockage en attente.
      </td>
    </tr>

    <tr>
      <td>
        `storage.allocReqs`
      </td>

      <td>
        Nombre de fois où le stockage a été invité à fournir un segment de stockage.
      </td>
    </tr>

    <tr>
      <td>
        `storage.availableInBytes`
      </td>

      <td>
        Nombre d&apos;octets restants dans le stockage.
      </td>
    </tr>

    <tr>
      <td>
        `storage.freeInBytes`
      </td>

      <td>
        Nombre total d&apos;octets renvoyés vers ce stockage.
      </td>
    </tr>

    <tr>
      <td>
        `storage.outstandingInBytes`
      </td>

      <td>
        Nombre d&apos;octets alloués à partir du stockage.
      </td>
    </tr>
  </tbody>
</table>

### Varnish mempool sample métriques [#varnish-mempool-sample]

Ces attributs peuvent être trouvés en interrogeant le type d&apos;événement `VarnishMempoolSample` .

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        métrique
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `mempool.allocatedSizeInBytes`
      </td>

      <td>
        Taille allouée du pool de mémoire, en octets.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.allocs`
      </td>

      <td>
        Allocations de pool de mémoire.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.frees`
      </td>

      <td>
        Nombre de pools de mémoire libres.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.live`
      </td>

      <td>
        Nombre de pools de mémoire utilisés.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.pool`
      </td>

      <td>
        Compter dans le pool de mémoire.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.ranDry`
      </td>

      <td>
        La piscine est à sec.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.recycles`
      </td>

      <td>
        Recyclé de la piscine.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.requestSizeInBytes`
      </td>

      <td>
        Taille de la demande du pool de mémoire, en octets.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.surplus`
      </td>

      <td>
        Trop nombreux pour la piscine.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.timeouts`
      </td>

      <td>
        Délai d&apos;attente pour la piscine.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.tooSmall`
      </td>

      <td>
        Trop petit pour être recyclé.
      </td>
    </tr>
  </tbody>
</table>

### Varnish backend Exemples de mesures [#varnish-backend-sample]

Ces attributs peuvent être trouvés en interrogeant le type d&apos;événement `VarnishBackendSample` .

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        métrique
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `backend.busyFetches`
      </td>

      <td>
        Les récupérations n&apos;ont pas été tentées car le backend est occupé.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connections`
      </td>

      <td>
        Nombre de connexions simultanées au backend.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionsFailed`
      </td>

      <td>
        Nombre de connexions backend ayant échoué.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionsNotAttempted`
      </td>

      <td>
        Nombre de connexions backend non tentées.
      </td>
    </tr>

    <tr>
      <td>
        `backend.happy`
      </td>

      <td>
        Bonnes sondes de santé.
      </td>
    </tr>

    <tr>
      <td>
        `backend.unhealtyFetches`
      </td>

      <td>
        Les récupérations n&apos;ont pas été tentées en raison d&apos;un backend défectueux
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.pipeHeaderInBytes`
      </td>

      <td>
        Nombre total d&apos;octets de demande envoyés pour les sessions canalisées.
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.pipeInInBytes`
      </td>

      <td>
        Nombre total d&apos;octets transférés depuis le backend dans les sessions de pipeline.
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.pipeOutInBytes`
      </td>

      <td>
        Nombre total d&apos;octets transmis au backend dans les sessions de pipeline.
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.requestBodyInBytes`
      </td>

      <td>
        Nombre total d&apos;octets envoyés dans le corps de la requête backend.
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.requestHeaderInBytes`
      </td>

      <td>
        Nombre total d&apos;octets d&apos;en-tête de requête backend envoyés.
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.requests`
      </td>

      <td>
        Nombre de backend requests envoyées,
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.responseBodyInBytes`
      </td>

      <td>
        Nombre total d&apos;octets du corps de réponse du backend reçus.
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.responseHeaderInBytes`
      </td>

      <td>
        Nombre total d&apos;octets d&apos;en-tête de réponse backend reçus.
      </td>
    </tr>
  </tbody>
</table>

## Données d&apos;inventaire [#inventory]

L&apos;intégration de Varnish Cache capture les paramètres de configuration. Il analyse le fichier de configuration `varnish.params` pour tous les paramètres actifs.

Les données sont disponibles sur la [page Inventaire](/docs/infrastructure/new-relic-infrastructure/infrastructure-ui-pages/infrastructure-inventory-page-search-your-entire-infrastructure), sous la source <DNT>**config/varnish**</DNT> . Pour en savoir plus sur les données d’inventaire, consultez [Comprendre les données d’intégration](/docs/infrastructure/integrations-getting-started/getting-started/understand-integration-data-data-types#inventory-data).

## Vérifiez le code source [#source-code]

Cette intégration est un logiciel open source. Cela signifie que vous pouvez [parcourir son code source](https://github.com/newrelic/nri-varnish) et envoyer des améliorations, ou créer votre propre fork et le construire.