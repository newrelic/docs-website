---
title: schéma de définition du workflow
tags:
  - workflow automation
  - workflow schemas
  - workflow automation API
metaDescription: Workflow definitions are written in YAML. Keys use a camelCase naming convention.
freshnessValidatedDate: never
translationType: machine
---

<Callout title="Aperçu">
  Nous travaillons toujours sur cette fonctionnalité, mais nous aimerions que vous l&apos;essayiez !

  Cette fonctionnalité est actuellement fournie dans le cadre d&apos;un programme d&apos;aperçu conformément à nos [politiques de pré-sortie](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy).
</Callout>

## Présentation

Une définition de workflow décrit le processus automatisé à exécuter. Les définitions de workflow sont écrites en YAML en utilisant une convention de nommage `camelCase`. Chaque workflow se compose de :

* **Propriétés du schéma**: Informations de base (nom, description, entrées)
* **Étapes**: La séquence d&apos;actions à effectuer
* **Expressions**: valeurs dynamiques utilisant la syntaxe jq
* **Secrets**: Références d&apos;informations d&apos;identification sécurisées

## Concepts fondamentaux

Avant de créer des workflows, comprenez ces concepts de base utilisés dans les définitions de workflow.

### chaînes d&apos;expression [#expression-strings]

Plusieurs propriétés acceptent des valeurs de chaîne avec des expressions intégrées qui sont évaluées lors de l&apos;exécution du workflow, ce qui permet d&apos;obtenir des valeurs dynamiques dans les définitions de workflow.

Les chaînes d&apos;expression peuvent contenir une ou plusieurs expressions, chacune étant placée entre des accolades doubles. Le contenu entre les accolades est évalué à l&apos;aide de [jq](https://jqlang.org/manual/), qui offre de puissantes capacités pour accéder aux valeurs et les utiliser.

**Exemple**:

Obtenir la longueur d&apos;une chaîne d&apos;entrée de workflow :

`${{ .workflowInputs.myString | length }}`

Pour valider et tester vos expressions, utilisez le [JQ Playground](https://play.jqlang.org/).

### propriétés d&apos;expression [#expression-properties]

Un certain nombre de propriétés sont accessibles avec des expressions. Ces propriétés se trouvent dans un objet `scope`, les expressions doivent donc commencer par un point `(.)` pour accéder à ces propriétés de l&apos;objet scope.

Les propriétés disponibles sont :

* `workflowInputs` - Objet contenant les entrées passées au workflow au démarrage.

**Exemple**:

`${{ .workflowInputs.myInput }}`

* `steps` - Objet contenant une propriété pour chaque étape du workflow
* `steps.<stepName>` - Objet contenant des propriétés pour une étape spécifique
* `steps.<stepName>.outputs` - Objet contenant les propriétés de résultat, spécifiques à l&apos;étape ou à l&apos;action.

**Exemple**: `${{ .steps.myStep.outputs.myResult }}`

### Résultats de l&apos;évaluation de l&apos;expression [#expression-evaluation-results]

Une seule expression jq peut être évaluée à n&apos;importe quel type JSON. Cependant, le résultat final d&apos;une chaîne d&apos;expression dépend de savoir si la chaîne contient uniquement l&apos;expression ou du contenu supplémentaire.

**Expression unique (conserve le type JSON)**:

Si une chaîne d&apos;expression se compose d&apos;une seule expression sans contenu environnant, elle est évaluée au résultat de l&apos;expression jq tout en conservant son type JSON d&apos;origine. Par exemple, `${{ .workflowInputs.myArray }}` est évalué en un tableau. Ceci est utile pour passer des structures de données complexes dans un workflow.

**Expressions multiples ou contenu mixte (convertit en chaîne)**:

Si une chaîne d&apos;expression contient autre chose qu&apos;une seule expression, elle est évaluée en un résultat de chaîne. Cela se produit lorsqu&apos;une expression contient du contenu avant ou après elle, ou lorsque la chaîne contient plusieurs expressions en son sein. Chaque expression dans la chaîne est évaluée et convertie en une représentation de chaîne.

<Callout variant="important">
  Lorsqu&apos;une expression jq est évaluée à null, un nœud null est renvoyé. Par exemple, l&apos;expression `${{ .workflowInputs.missingInput }}` renvoie null si `missingInput` n&apos;est pas donné en entrée de workflow.
</Callout>

**Exemple**:

Supposons que `myArray` ait une valeur de `[1, 2, 3]`.

<table>
  <thead>
    <tr>
      <th>
        chaîne d&apos;expression
      </th>

      <th>
        Données de résultats
      </th>

      <th>
        Type de résultat
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `${{ .workflowInputs.myArray }}`
      </td>

      <td>
        `[1, 2, 3]`
      </td>

      <td>
        Tableau de nombres
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        3
      </td>

      <td>
        Nombre
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        Vrai
      </td>

      <td>
        Booléen
      </td>
    </tr>

    <tr>
      <td>
        `Input is not empty: ${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        `"Input is not empty: true"`
      </td>

      <td>
        Chaîne
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray }} has length ${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        `"has length 3"`
      </td>

      <td>
        Chaîne
      </td>
    </tr>
  </tbody>
</table>

### Modèle sécurisé d&apos;expression [#expression-safe-pattern]

Les propriétés qui peuvent être utilisées dans les expressions doivent être conformes à : `^[A-Za-z_][A-Za-z0-9_]*$`

### Références secrètes [#secret-references]

Les valeurs secrètes peuvent être utilisées dans les actions via des chaînes de référence qui spécifient le nom d&apos;un secret à rechercher dans le service de secrets. Pour faire référence à un secret dans une définition workflow, utilisez la syntaxe suivante :

* `${{ :secrets:<SECRET_NAME> }}` pour un secret pas dans un `namespace`
* `${{ :secrets:<NAMESPACE>:<SECRET_NAME> }}` pour un secret dans un `namespace`
* `${{ :secrets:<SCOPE>:<NAMESPACE>:<SECRET_NAME> }}` pour un secret dans la portée et l&apos;espace de noms. scope n&apos;accepte que `ACCOUNT` ou `ORGANIZATION` pour le moment.

Une chaîne d&apos;expression peut contenir un mélange de références secrètes et d&apos;expressions JQ `and/or` plusieurs références secrètes.

**Exemples**:

```yaml
  steps:
  - name: mySecretStep
    type: action
    action: newrelic.instrumentation.log
    inputs:
      message: My message
      licenseKey: ${{ :secrets:<SECRET_NAME> }}
```

```yaml
  steps:
    - name: bearer_auth
      type: action
      action: utils.http.post
      inputs:
        headers:
          Authorization: Bearer ${{ :secrets:<SECRET_NAME> }}
```

## Structure du schéma

### Propriétés du schéma

<table>
  <thead>
    <tr>
      <th>
        Propriété
      </th>

      <th>
        Obligatoire ou facultatif
      </th>

      <th>
        Type
      </th>

      <th>
        Format
      </th>

      <th>
        Contraintes
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`name`**
      </td>

      <td>
        Requis
      </td>

      <td>
        Chaîne
      </td>

      <td>
        Doit être conforme à l&apos;expression régulière 

        `^[A-Za-z_][A-Za-z0-9_-]*$`
      </td>

      <td>
        **Longueur maximale**

        : 100
      </td>

      <td>
        Les valeurs 

        **`name`**

         ne respectent pas la casse. Par exemple, 

        `ExampleWorkflow`

        , 

        `exampleworkflow`

         et 

        `EXAMPLEWORKFLOW`

         sont tous considérés comme représentant la même définition de workflow.
      </td>
    </tr>

    <tr>
      <td>
        **`description`**
      </td>

      <td>
        Facultatif
      </td>

      <td>
        Chaîne
      </td>

      <td>
        Doit être conforme à l&apos;expression régulière 

        `^[A-Za-z0-9 _-]*$`
      </td>

      <td>
        **Longueur maximale**

        : 200
      </td>

      <td>
        Une 

        `description`

         du workflow décrivant le but du workflow.
      </td>
    </tr>

    <tr>
      <td>
        **`workflowInputs`**
      </td>

      <td>
        Facultatif
      </td>

      <td />

      <td>
        Carte de cartes
      </td>

      <td>
        **Taille maximale**

        : 100
      </td>

      <td>
        Une carte des entrées de workflow que le workflow accepte. Voir les propriétés détaillées ci-dessous.
      </td>
    </tr>
  </tbody>
</table>

### workflowInputs

**Exemple**:

```yaml
    workflowInputs:
  myInput1:
    type: String
  myInput2:
    type: Number
    defaultValue: 42
```

* **`workflowInputs.<inputName>`** (Obligatoire)

  * **Type**: Chaîne (conforme au [modèle sécurisé pour les expressions](#expression-safe-pattern))
  * **Longueur minimale**: 1
  * **Longueur maximale**: 50
  * **Description**: Nom de l&apos;entrée workflow.

* **`workflowInputs.<inputName>.type`** (Obligatoire)

  * **Type**: Enum (`Boolean, List, Map, String, Int, Float`)
  * **Description**: Type de données de l&apos;entrée workflow.

* **`workflowInputs.<inputName>.defaultValue`** (Facultatif)

  * **Type**: Tout ; doit être conforme à `type`.
  * **Description**: Valeur par défaut de l&apos;entrée workflow.

* **`workflowInputs.<inputName>.required`** (Facultatif)

  * **Type**: Booléen (`True`, `False`).
  * **Description**: La valeur par défaut de ce champ est « True ».

* **`workflowInputs.<inputName>.enumValues`** (Facultatif)

  * **Type**: Liste (`String`).
  * **Description**: La valeur par défaut de ce champ est une liste vide `{}`. Ceci est requis lorsque le type workflowInput est Enum.

* **`workflowInputs.<inputName>.validations`** (Facultatif)

  * **Type**: Tableau de cartes.
  * **Description**: Les validations à effectuer sur les entrées de workflow fournies par l&apos;utilisateur. Ceci est un champ facultatif. Les propriétés décrites ici sont présentes dans tous les types de validation. Les types de validation spécifiques prennent en charge des propriétés supplémentaires, comme indiqué dans la section [Types de validation](#validation-types).

* **`validations[*].type`** (Obligatoire)

  * **Type**: Chaîne de caractères
  * **Description**: Le type de validation indiquant quelle validation aura lieu sur ce champ. Consultez [Types de validation](#validation-types) pour plus d&apos;informations sur chaque type de validation.

* **`validations[*].errorMessage`** (Obligatoire)

  * **Type**: Chaîne de caractères
  * **Description**: Le message d&apos;erreur que l&apos;utilisateur souhaite obtenir lorsqu&apos;une validation particulière échoue.

#### Exemple YAML pour les validations

```yaml
  name: calendar_demo

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'
      validations:
        - type: regex
          errorMessage: "The provided timezone is not correct"
          pattern: "^[A-Za-z]+\/[A-Za-z_]+(?:\/[A-Za-z_]+)?$"

        - type: maxLength
          errorMessage: "Timezone length should be less than 100"
          length: 100

    accountId:
      type: Int
      validations:
        - type: minIntValue
          errorMessage: "Account id should be greater than 100000"
          minValue: 100000
        - type: maxIntValue
          errorMessage: "Account id should be less than 9999999"
          maxValue: 9999999

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'
        selectors:
          - name: timezone
            expression: '.responseBody | fromjson.abbreviation'
          - name: datetime
            expression: '.responseBody | fromjson.datetime'
```

### Types de validation [#validation-types]

<table>
  <thead>
    <tr>
      <th>
        Type de validation
      </th>

      <th>
        Propriété
      </th>

      <th>
        Obligatoire ou facultatif
      </th>

      <th>
        Type
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`regex`**
      </td>

      <td>
        `validations[*].pattern`
      </td>

      <td>
        Requis
      </td>

      <td>
        Chaîne
      </td>

      <td>
        Valide la valeur d&apos;entrée du workflow par rapport au modèle regex fourni.
      </td>
    </tr>

    <tr>
      <td>
        **`maxIntValue`**
      </td>

      <td>
        `validations[*].maxValue`
      </td>

      <td>
        Requis
      </td>

      <td>
        Entier
      </td>

      <td>
        Valide que la valeur d&apos;entrée du workflow doit être inférieure à la valeur maximale fournie.
      </td>
    </tr>

    <tr>
      <td>
        **`minIntValue`**
      </td>

      <td>
        `validations[*].minValue`
      </td>

      <td>
        Requis
      </td>

      <td>
        Entier
      </td>

      <td>
        Valide que la valeur d&apos;entrée du workflow doit être supérieure à la valeur minimale fournie.
      </td>
    </tr>

    <tr>
      <td>
        **`maxLength`**
      </td>

      <td>
        `validations[*].length`
      </td>

      <td>
        Requis
      </td>

      <td>
        Entier
      </td>

      <td>
        Valide la longueur maximale des chaînes d&apos;entrée de workflow et des collections (

        `Array, Set, Map, etc.`

        ).
      </td>
    </tr>
  </tbody>
</table>

## Étapes [#steps]

<table>
  <thead>
    <tr>
      <th>
        Propriété
      </th>

      <th>
        Obligatoire ou facultatif
      </th>

      <th>
        Type
      </th>

      <th>
        Contraintes
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`steps`**
      </td>

      <td>
        Requis
      </td>

      <td>
        tableau de cartes
      </td>

      <td />

      <td>
        Les étapes à effectuer lors de l&apos;exécution de la définition du workflow. Il doit y avoir au moins une étape. Les propriétés décrites ici sont présentes sur tous les types d&apos;étapes. Des types d&apos;étapes spécifiques prennent en charge des propriétés supplémentaires, comme décrit dans la section 

        [Types d&apos;étapes](#step-types)

        .
      </td>
    </tr>
  </tbody>
</table>

<Callout variant="important">
  Les étapes s&apos;exécutent dans l&apos;ordre dans lequel elles sont définies dans le tableau `steps`. Si un ordre différent est souhaité, un `jump` peut être effectué en définissant la propriété `steps[*].next` sur le nom de l&apos;étape souhaitée pour passer.
</Callout>

### Propriétés d&apos;étape courantes

<table>
  <thead>
    <tr>
      <th>
        Propriété
      </th>

      <th>
        Obligatoire ou facultatif
      </th>

      <th>
        Type
      </th>

      <th>
        Format
      </th>

      <th>
        Contraintes
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`steps[*].name`**
      </td>

      <td>
        Requis
      </td>

      <td>
        Chaîne
      </td>

      <td>
        Doit être conforme au 

        [modèle sécurisé pour les expressions](#expression-safe-pattern)

        , ne peut pas être 

        `end`

        .
      </td>

      <td>
        **Longueur maximale :**

         100
      </td>

      <td>
        Le nom de l&apos;étape à référencer par 

        `steps[*].next`

        . Ne peut pas être les mots-clés spéciaux 

        `end`

        , 

        `continue`

         ou 

        `break`

        , car ceux-ci sont utilisés pour indiquer une étape de terminaison, une continuation d&apos;une boucle ou pour sortir d&apos;une boucle.
      </td>
    </tr>

    <tr>
      <td>
        **`steps[*].type`**
      </td>

      <td>
        Requis
      </td>

      <td>
        Chaîne
      </td>

      <td />

      <td />

      <td>
        Le type de l&apos;étape, indiquant ce que l&apos;étape fait lors de l&apos;exécution. Reportez-vous à 

        [Types d&apos;étapes](#step-types)

         ci-dessous pour les options disponibles.
      </td>
    </tr>

    <tr>
      <td>
        **`steps[*].next`**
      </td>

      <td>
        Facultatif
      </td>

      <td>
        Chaîne
      </td>

      <td>
        Doit être conforme au modèle sécurisé d&apos;expression
      </td>

      <td />

      <td>
        Le nom de l&apos;étape suivante à exécuter lorsque cette étape se termine avec succès. Le mot-clé spécial end peut être utilisé pour indiquer que cette étape doit être la dernière à s&apos;exécuter. Si 

        `next`

         est omis, l&apos;entrée suivante dans le tableau de définition 

        `steps`

         sera utilisée comme étape suivante implicite. S&apos;il n&apos;y a pas d&apos;entrée suivante, le workflow sera terminé.
      </td>
    </tr>

    <tr>
      <td>
        **`steps[*].ignoreErrors`**
      </td>

      <td>
        Facultatif
      </td>

      <td>
        Booléen
      </td>

      <td />

      <td />

      <td>
        Le 

        `ignoreErrors`

         est une option de configuration au sein d&apos;une étape d&apos;un workflow. Par défaut, faux. En définissant 

        `ignoreErrors`

         sur 

        `true`

        , le workflow garantit que toute erreur rencontrée lors de l&apos;exécution de cette étape n&apos;entraînera pas l&apos;échec de l&apos;ensemble du workflow. Au lieu de cela, le workflow continuera d&apos;exécuter les étapes suivantes.
      </td>
    </tr>
  </tbody>
</table>

## Types d&apos;étapes [#step-types]

### Action [#action]

Une étape qui exécute une action spécifique. Reportez-vous au [Catalogue d&apos;actions](/docs/workflow-automation/setup-and-configuration/actions-catalog/actions-catalog) pour les options disponibles.

* **`steps[*].action`** (Obligatoire)

  * **Type**: Chaîne de caractères
  * **Description**: Nom complet de la fonction d&apos;action à exécuter. Elle devrait respecter la convention suivante : `<company domain>.<category of work>.<action name in camelCase>`

**Exemple**:

* Action utilisant les services New Relic (par exemple via NerdGraph) : `newrelic.dashboards.getDashboard`

* Action via Slack : `slack.chat.postMessage`

* **`steps[*].version`** (Obligatoire)

  * **Type**: Chaîne de caractères
  * **Description**: Version de la fonction d&apos;action à exécuter.

* **`steps[*].inputs`** (Facultatif)

  * **Type**: Carte de valeurs (inclut les expressions)

  * **Description**:

    * Les données d&apos;entrée à transmettre à la fonction d&apos;action. Les entrées spécifiques acceptées sont définies par chaque action.
    * Les entrées peuvent utiliser des expressions. Consultez la section Chaînes d&apos;expressions pour plus de détails.

  <Callout variant="important">
    Aucune donnée sensible (ni clé API ni secret, ni PII, ni PHI, ni aucune donnée permettant d&apos;identifier une personne) ne doit être transmise en tant qu&apos;arguments.
  </Callout>

* **`steps[*].inputs.selectors`** (Facultatif)

  * **Type**: liste de cartes sous la forme de `name` avec `expression`.

  * **Description**:

    * L&apos;entrée `selectors` vous permet de redéfinir la sortie pour ne renvoyer que les éléments spécifiés.
    * Les expressions peuvent être utilisées. Consultez la section [Chaînes d&apos;expression](#expression-strings) pour plus de détails.

**Exemple**:

* Dans l&apos;exemple donné, nous obtenons `timezone` et `datetime` comme réponse de l&apos;action http.get.

```yaml
  name: calendar_demo

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'
    accountId:
      type: Int

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'
        selectors:
          - name: timezone
            expression: '.responseBody | fromjson.abbreviation'
          - name: datetime
            expression: '.responseBody | fromjson.datetime'
```

### Boucle [#loop]

Une boucle itère sur les collections (listes, cartes, tableaux) et crée automatiquement les variables `index` et `element` pour chaque itération. Ces variables de boucle ne sont accessibles qu&apos;à l&apos;intérieur de la boucle à l&apos;aide de `${{ .steps.<loopStepName>.loop.element }}` ou `${{ .steps.<loopStepName>.loop.index }}`

**Propriétés :**

* **`steps[*].for`** (Obligatoire)

  * **Type**: Constant
  * **Description**: Signale le début d&apos;une boucle

* **`steps[*].in`** (Obligatoire)

  * **Type**: Chaîne (expression)
  * **Description**: Expression qui s&apos;évalue en une collection d&apos;éléments

* **`steps[*].steps`** (Obligatoire)

  * **Description**: Étapes exécutées à chaque itération. Peut inclure n&apos;importe quel type d&apos;étape, y compris les boucles imbriquées.

<Callout variant="important">
  * **for:** (obligatoire). Il s&apos;agit de l&apos;élément de niveau supérieur indiquant le début d&apos;une boucle for.
  * **in :** (obligatoire). Pour que la collection d&apos;entrée soit itérée, elle doit être convertible en Java Array.
  * **étapes :** (obligatoire). À chaque itération, les étapes seront exécutées.
  * **élément** et **index** sont automatiquement affectés dans le cadre de la boucle.
  * `index` est basé sur zéro, `element` peut être un type complexe si vous avez une collection d&apos;éléments complexes.
  * Les variables créées à l&apos;intérieur de la boucle (variables de boucle et sorties d&apos;étape) ne sont accessibles qu&apos;à l&apos;intérieur de la boucle.
  * Ces variables sont effacées à la sortie de la boucle et seront nulles si elles sont consultées en dehors de la boucle
  * Les boucles peuvent accéder aux variables définies en dehors de la boucle
</Callout>

**Exemple : boucle de base**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element : ${{ .steps.loopStep.loop.element }} , Index : ${{ .steps.loopStep.loop.index }}' # not exist outside of this loop
```

**Exemple : Boucle sur les entiers**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: ${{ [range(1; 6)] }}
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }} , Index : ${{ .steps.loopStep.loop.index }}'  # Element : [1, 2, 3, 4, 5] , Index : [0, 1, 2, 3, 4]
```

**Exemple : Boucle sur la carte**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element : ${{ .steps.loopStep.loop.element }} , Index : ${{ .steps.loopStep.loop.index }}'  # Element: [{ "key1": "val1" }, { "key2": "val2"}] , Index : [0, 1]
```

**Exemple : Sauter dans une boucle**

Il est permis de passer d&apos;une étape à l&apos;autre dans la même boucle. Il n&apos;est pas permis de sauter dans/hors des boucles, entre différentes boucles ou vers des boucles parent/enfant.

```yaml
  name: myWorkflow
  steps:
    - name: firstStep
      type: action
      action: example.messaging.sayHello
      version: '1.0.0'
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: step3                                 # Okay within the loop
          - name: step2
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.step1.outputs.greeting }}'
          - name: step3
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            next: firstStep                            # Not okay, first step is not in the loop context
```

**Exemple : Interrompre et continuer**

Utilisez `next: break` ou `next: continue` pour contrôler le flux de la boucle. Ce sont des mots-clés réservés dans les boucles. En dehors des boucles, ils sautent à la fin du workflow. Remarque : `end` se comporte comme `break` à l&apos;intérieur des boucles.

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [range(1; 6)] }}'
        steps:
          - name: insideLoopStep1
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: continue
          - name: insideLoopStep2
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
    - name: loopStepAgain
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: switchStep
            type: switch
            switch:
              - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                next: break
          - name: insideLoopStepAgain
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.loopStepAgain.loop.element }}'
```

**Exemple simple :**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: "${{ [range(1; 5)] }}"
        steps:
          - name: step1
            type: action
            action: newrelic.ingest.sendLogs
            version: 1
            inputs:
              logs:
                - message: "Loop: ${{ .steps.loopStep.loop.element }}"
```

### Switch [#switch]

* Une étape qui vérifie diverses conditions et emprunte la première branche qui s&apos;évalue à vrai.

* Un commutateur peut contenir un nombre quelconque d&apos;éléments `condition` dans une liste. Il vérifiera les conditions dans l&apos;ordre et traitera la première qui s&apos;évalue à vrai. Si aucune ne s&apos;évalue à vrai, il exécutera son étape `next` comme défini dans `steps[*].next`.

  * **`steps[*].switch`** (Obligatoire)

    * **Type**: Tableau
    * **Description**: Un éventail de cas de commutation, spécifiant la liste ordonnée des conditions à évaluer.

  * **`steps[*].switch[*].condition`** (Obligatoire)

    * **Type**: Chaîne ([expression](#expression-strings))
    * **Description**: La condition du cas de commutateur. Si elle est évaluée à true, l&apos;étape du cas `next` sera exécutée.
    * Consultez la section [Chaînes d&apos;expression](#expression-strings) pour plus de détails.

  * **`steps[*].switch[*].next`** (Obligatoire)

    * **Type**: Chaîne (conforme au [modèle sécurisé pour les expressions](#expression-safe-pattern))
    * **Description**: Le nom de l&apos;étape à exécuter si la condition du cas est évaluée à true. Le mot-clé spécial `end` peut être utilisé pour indiquer que cette étape doit être la dernière à s&apos;exécuter.

  ```yaml
    - name: hasCompleted
      type: switch
      switch:
        - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Failed" }}
          next: displayError
        - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Success" }}
          next: displaySuccess
      next: displayUnexpected
  ```

### Attendez [#wait]

Une étape qui met en pause l&apos;exécution du workflow pendant un nombre spécifié de secondes avant de continuer.

L&apos;étape d&apos;attente peut également écouter un ou plusieurs signaux. Chaque signal doit avoir une étape suivante correspondante définie dans une liste. Si un signal est reçu pendant la période d&apos;attente, le premier signal reçu sera traité et le workflow exécutera son étape suivante définie. Si aucun signal n&apos;est reçu, le workflow continue normalement une fois la période d&apos;attente terminée.

La valeur reçue d&apos;un signal est stockée dans la sortie de l&apos;étape d&apos;attente et peut être utilisée dans les étapes suivantes pour la logique ou le traitement.

**Exemple**:

```yaml
  name: waitSignalExample
  workflowInputs:
  steps:
    - name: waitStep
      type: wait
      seconds: 300
      signals: [{name: 'mySignalName', next: 'firstStep'}]
    - name: endStep
      type: action
      action: newrelic.instrumentation.log
      version: 1
      inputs:
        message: "didn't get signal"
      next: end
    - name: firstStep
      type: action
      action: newrelic.instrumentation.log
      version: 1
      inputs:
        message: ${{ .steps.waitStep.outputs.signalInputs.myString }}
```

* **`steps[*].seconds`** (Obligatoire)

  * **Type**: Nombre
  * **Description**: Nombre de secondes à attendre avant de poursuivre l&apos;exécution workflow.

* **`steps[*].signals`**

  * **Type**: Tableau
  * **Description**: Les signaux qui, lorsqu&apos;ils sont reçus, modifient le flux du programme.

* **`steps[*].signals[*].name`**

  * **Type**: Chaîne de caractères
  * **Description**: Le nom du signal à écouter.

* **`steps[*].signals[*].next`**

  * **Type**: Chaîne de caractères
  * **Description**: Étape à exécuter si le signal spécifié est reçu.

### Attribuer [#assign]

Une étape qui définit les variables à utiliser tout au long du workflow. Cette étape affecte des valeurs aux variables qui peuvent être référencées dans les étapes suivantes. En définissant toutes les variables au même endroit, ce type d&apos;étape rend les workflows plus lisibles et optimisés.

**Exemple de workflow**:

```yaml
  name: sampleWorkflowWithAssign
  description: WorkflowAssignDemo

  workflowInputs:
    initialValue:
      type: String
    anotherValue:
      type: Int

  steps:
    - name: runAction
      type: action
      action: internal.http.post
      version: 1
      inputs:
        url: 'http://localhost:8505/tasks/gc' # temporal-activity-worker-java service port
        selectors:
          - name: statusCode
            expression: '.statusCode'
          - name: responseBody
            expression: '.responseBody'
    - name: variableInitialization
      type: assign
      inputs:
        stringVar: "${{ .workflowInputs.initialValue }}"
        intVar: "${{ .workflowInputs.anotherValue }}"
        concatenationVar: "${{ .workflowInputs.initialValue }} - concatenated"
        booleanVar: true
        mapVar:
          key1: "value1"
          key2: "${{ .workflowInputs.initialValue }}"
        listVar:
          - "listItem1"
          - "${{ .workflowInputs.initialValue }}"
          - "${{ .workflowInputs.anotherValue }}"
        statusCode: ${{ .steps.runAction.outputs.statusCode }}

    - name: wait
      type: wait
      seconds: 2

    - name: logVariables
      type: action
      action: newrelic.ingest.sendLogs
      version: 1
      inputs:
        logs:
          - message: "stringVar: ${{ .steps.variableInitialization.outputs.stringVar }}"
          - message: "intVar: ${{ .steps.variableInitialization.outputs.intVar }}"
          - message: "concatenationVar: ${{ .steps.variableInitialization.outputs.concatenationVar }}"
          - message: "booleanVar: ${{ .steps.variableInitialization.outputs.booleanVar }}"
          - message: "mapVar: ${{ .steps.variableInitialization.outputs.mapVar | tojson }}"
          - message: "listVar: ${{ .steps.variableInitialization.outputs.listVar | tojson }}"
          - message: "statusCode: ${{ .steps.variableInitialization.outputs.statusCode }}"
```

* **`steps[*].inputs`** (Obligatoire)

  * **Type**: Carte de valeurs (inclut les [expressions](#expression-strings))
  * **Description**:
    * Les entrées sont une carte des noms de variables et de leurs valeurs attribuées. Lorsque des références secrètes sont affectées à des variables, elles restent des références secrètes et ne sont pas converties en leurs valeurs réelles. Cependant, d&apos;autres expressions (telles que les entrées de workflow) sont évaluées et converties en leurs valeurs réelles.
  * Types d&apos;entrée autorisés : `Integer`, `Double`, `Boolean`, `String`, `Array`, `Map`

## Exemple complet [#examples]

### Démo de calendrier

Un exemple complet de workflow qui démontre plusieurs fonctionnalités de workflow, notamment les entrées de workflow, les actions HTTP, les sélecteurs, les étapes d&apos;attente, les requêtes NRQL, les instructions switch et les notifications Slack.

```yaml
  name: calendar_demo

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'
    accountId:
      type: Int

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'
        selectors:
          - name: timezone
            expression: '.responseBody | fromjson.abbreviation'
          - name: datetime
            expression: '.responseBody | fromjson.datetime'

    - name: logTime
      type: action
      action: newrelic.instrumentation.log
      version: 1
      inputs:
        message: 'DEMO: In the ${{ .steps.getCurrentTime.outputs.timezone }} timezone, the current time is ${{ .steps.getCurrentTime.outputs.datetime }}'
        licenseKey: ${{ :secrets:STAGING_NEW_RELIC_LICENSE_KEY }}

    - name: wait
      type: wait
      seconds: 1

    - name: queryForLog
      type: action
      action: newrelic.nrql.query
      version: 1
      inputs:
        accountIds: ['${{ .workflowInputs.accountId }}']
        query: FROM Log SELECT * WHERE message LIKE 'DEMO:%${{ .steps.getCurrentTime.outputs.datetime }}'

    - name: checkQuery
      type: switch
      switch:
        - condition: ${{ .steps.queryForLog.outputs.results | length > 0 }}
          next: postResultsMessage

    - name: postWaitingMessage
      type: action
      action: slack.chat.postMessage
      version: 1
      inputs:
        channel: test-channel-workflow
        text: Waiting for log message...
        token: ${{ :secrets:dn_staging_slack_token }}
      next: wait

    - name: postResultsMessage
      type: action
      action: slack.chat.postMessage
      version: 1
      inputs:
        channel: test-channel-workflow
        text: 'Found log message! ${{ .steps.queryForLog.outputs.results[0].message }}'
        token: ${{ :secrets:dn_staging_slack_token }}
```