---
title: schéma de définition du workflow
tags:
  - workflow automation
  - workflow schems
  - workflow automation API
metaDescription: Workflow definitions are written in YAML. Keys use a camelCase naming convention.
freshnessValidatedDate: never
translationType: machine
---

<Callout title="Aperçu">
  Nous travaillons toujours sur cette fonctionnalité, mais nous aimerions que vous l&apos;essayiez !

  Cette fonctionnalité est actuellement fournie dans le cadre d&apos;un programme d&apos;aperçu conformément à nos [politiques de pré-sortie](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy).
</Callout>

## Schéma

Les définitions de workflow sont écrites en YAML. Les clés utilisent une convention de nommage `camelCase`.

### **nom** (obligatoire)

* **Type**: Chaîne de caractères
* **Format**: Doit être conforme à l&apos;expression régulière `^[A-Za-z_][A-Za-z0-9_-]*$`.
* **Longueur maximale**: 100
* **Description**: Les valeurs `name` ne sont pas sensibles à la casse. Par exemple, `ExampleWorkflow`, `exampleworkflow`, et `EXAMPLEWORKFLOW` sont tous considérés comme représentant la même définition workflow.

### **description** (facultatif)

* **Type**: Chaîne de caractères
* **Format**: Doit être conforme à l&apos;expression régulière `^[A-Za-z0-9 _-]*$`.
* **Longueur maximale**: 200
* **Description**: Un `description` du workflow qui explique son objectif.

### **workflowInputs** (facultatif)

* **Type**: Carte des cartes
* **Taille maximale**: 100
* **Description**: Une carte des entrées workflow acceptées par workflow.
* **Exemple**:

```java
  workflowInputs:
    myInput1:
      type: String
    myInput2:
      type: Number
      defaultValue: 42
```

* **`workflowInputs.<inputName>`** (Obligatoire)

  * **Type**: Chaîne de caractères (conforme au [modèle d&apos;expression sûre]())
  * **Longueur minimale**: 1
  * **Longueur maximale**: 50
  * **Description**: Nom de l&apos;entrée workflow.

* **`workflowInputs.<inputName>.type`** (Obligatoire)

  * **Type**: Enum (Boolean, List, Map, String, Int, Float)
  * **Description**: Type de données de l&apos;entrée workflow.

* **`workflowInputs.<inputName>.defaultValue`** (Facultatif)

  * **Type**: Tout ; doit être conforme à `type`.
  * **Description**: Valeur par défaut de l&apos;entrée workflow.

* **étapes** (obligatoires)

  * **Type**: éventail de cartes
  * **Description**: Étapes à effectuer lors de l&apos;exécution de la définition workflow. Il doit y avoir au moins une étape.

  <Callout variant="important">
    Les étapes s&apos;exécuteront dans l&apos;ordre où elles sont définies dans l&apos;éventail `steps`.

    Si un ordre différent est souhaité, un « saut » peut être effectué en définissant la propriété `steps[*].next` sur le nom de l&apos;étape souhaitée vers laquelle sauter.
  </Callout>

  * **`steps[*].name`** (Obligatoire)

    * **Type**: Chaîne (conforme au [modèle d&apos;expression sûre](); ne peut pas être `end`)
    * **Longueur maximale**: 100
    * **Description**: Le nom de l&apos;étape à référencer par `steps[*].next`. Il ne peut pas s&apos;agir des mots clés spéciaux `end`, `continue`, ou `break`, car ceux-ci sont utilisés pour indiquer une étape de terminaison, une continuation d&apos;une boucle ou pour sortir d&apos;une boucle.

  * **`steps[*].type`** (Obligatoire)

    * **Type**: Chaîne de caractères
    * **Description**: Le type d&apos;étape, indiquant ce que fait l&apos;étape lorsqu&apos;elle est exécutée. Consultez la [section « Types d&apos;étapes »]() pour connaître les options disponibles.

  * [**`steps[*].next`**](#steps-next) (Facultatif)

    * **Type**: Chaîne de caractères (conforme au [modèle d&apos;expression sûre]())

    * **Description**:

      * Nom de l&apos;étape suivante à exécuter une fois cette étape terminée avec succès. Le mot-clé spécial `end` peut être utilisé pour indiquer que cette étape doit être la dernière à être exécutée.
      * Si `next` est omis, l&apos;entrée suivante dans le éventail `steps` de la définition sera utilisée comme étape suivante implicite. S&apos;il n&apos;y a pas d&apos;entrée suivante, le workflow sera terminé.

## Types d&apos;étapes

### **action**

Une étape qui exécute une action spécifique. Consultez [le catalogue des actions](/docs/workflow-automation/setup-and-configuration/actions-catalog/actions-catalog) pour connaître les options disponibles.

* **`steps[*].action`** (Obligatoire)

  * **Type**: Chaîne de caractères

  * **Description**: Nom complet de la fonction d&apos;action à exécuter. Elle devrait respecter la convention suivante :

    `<company domain>.<category of work>.<action name in camelCase>`

  * **Exemple**:

    * Action utilisant les services New Relic (par exemple via NerdGraph) : `newrelic.dashboards.getDashboard`
    * Action via Slack : `slack.chat.postMessage`

* **`steps[*].version`** (Obligatoire)

  * **Type**: Chaîne de caractères
  * **Description**: Version de la fonction d&apos;action à exécuter.

* **`steps[*].inputs`** (Facultatif)

  * **Type**: Carte de valeurs (incluant [les expressions]())

  * **Description**:

    * Les données d&apos;entrée à transmettre à la fonction d&apos;action. Les entrées spécifiques acceptées sont définies par chaque action.
    * Les entrées peuvent utiliser des expressions. Consultez la section [« Chaînes d’expressions »]() pour plus de détails.

  <Callout variant="important">
    Aucune donnée sensible (ni clé API ni secret, ni PII, ni PHI, ni aucune donnée permettant d&apos;identifier une personne) ne doit être transmise en tant qu&apos;arguments.
  </Callout>

* **`steps[*].inputs.selectors`** (Facultatif)

  * **Type**: liste de maps sous la forme `name` avec `expression`.

  * **Description**:

    * L&apos;entrée `selectors` permet de redéfinir la sortie pour ne renvoyer que les éléments spécifiés.
    * L&apos;expression peut être utilisée. Consultez la section [« Chaînes d’expressions »]() pour plus de détails.

  * **Exemple**

    * Dans l&apos;exemple donné, nous obtenons `pageUrl` et `statusDescription` comme réponse de l&apos;action http.get.

    ```yaml
        name: status
        description: A workflow for checking the status of New Relic components

        steps:
          - name: query1
            type: action
            action: http.get
            version: 1
            inputs:
              url: "https://status.newrelic.com/api/v2/status.json"
              selectors:
                - name: statusCode
                  expression: '.statusCode'
                - name: pageUrl
                  expression: '.responseBody | fromjson | .page.url'
                - name: statusDescription
                  expression: '.responseBody | fromjson | .status.description'

          - name: logOutput1
            type: action
            action: newrelic.ingest.sendLogs
            version: 1
            inputs:
              logs:
                - message: "status is '${{ .steps.query1.outputs.statusDescription }}' details at ${{ .steps.query1.outputs.pageUrl }}"
    ```

### **boucle**

Une boucle parcourra une collection donnée définie par `in` et créera des variables de boucle `index` et `element` pour chacune de ses itérations. Ces variables de boucle ne sont accessibles à l&apos;intérieur de la boucle qu&apos;avec l&apos;expression `${{ .steps.<loopStepName>.loop.element }}` ou `${{ .steps.<loopStepName>.loop.index }`

Pour plus de détails, voir ci-dessous :

<CollapserGroup>
  <Collapser id="moreforloop" title="Boucle pour parcourir une liste, une carte ou une collection">
    Vous pouvez utiliser la boucle pour parcourir une liste, une carte ou une collection.

    * `for` (Requis)

      * **Type**: Constant
      * **Description**: Signal de début de boucle.

    * `in` (Requis)

      * **Type**: chaîne (expression)
      * **Description**: Une expression qui doit être évaluée en une collection d&apos;éléments.

    * `steps` (Requis)

      * **Description**: Étapes à exécuter à chaque itération de la boucle. Une étape peut être de tout type, y compris une autre boucle.

      * **Exemples**: Ce qui suit montre comment exécuter la boucle workflowInputs. Notez que le résultat doit être un type de collection.

        ```yaml
            name: myWorkflow
            steps:
              - name: loopStep
                type: loop
                for:
                  in: '${{ .workflowInputs.count }}'
                  steps:
                    - name: step1
                      type: action
                      action: example.messaging.sayHello
                      version: '1.0.0'
                      inputs:
                        name: '${{ .steps.loopStep.loop.element }}' # not exist outside of this loop
                        index: '${{ .steps.loopStep.loop.index }}' # not exist outside of this loop
        ```

    <Callout variant="important">
      * `element` et `index` sont automatiquement attribués dans le cadre de la boucle.
      * `Index` est une base zéro.
      * Le `element` peut être un type complexe si vous avez une collection d&apos;éléments complexes.
      * Toutes les variables de boucle et les sorties des étapes à l&apos;intérieur de la boucle ont une portée au niveau de la boucle. Ces variables sont effacées après la sortie de la boucle et y accéder en dehors de la boucle renverra une valeur nulle. La boucle peut accéder aux variables situées en dehors de la boucle si elles ont été préalablement définies.
    </Callout>

    **Boucle for simple sur les entiers**

    ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: ${{ [range(1; 6)] }}
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'  # [1, 2, 3, 4, 5]
                    index: '${{ .steps.loopStep.loop.index }}' # [0, 1, 2, 3, 4]
    ```

    **Boucle simple pour la carte**

    ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'  # [{ "key1": "val1" }, { "key2": "val2"}]
                    index: '${{ .steps.loopStep.loop.index }}' # [0, 1]
    ```

    **Sauter à l&apos;intérieur d&apos;une boucle**

    Seuls les sauts entre étapes nommées appartenant à la même boucle for sont autorisés. Il est interdit d&apos;entrer ou de sortir d&apos;une boucle for, de passer à une boucle interne/externe ou de naviguer entre deux boucles for différentes.

    ```yaml
        name: myWorkflow
        steps:
          - name: firstStep
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
          - name: loopStep
            type: loop
            for:
              in: '${{ .workflowInputs.count }}'
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'
                  next: step3                                 # Okay within the loop
                - name: step2
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.step1.outputs.greeting }}'
                - name: step3
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  next: firstStep                            # Not okay, first step is not in the loop context
    ```

    **Utilisez break/continue dans une boucle**

    Pour modifier le flux d&apos;une boucle for, vous pouvez utiliser `next: break` ou `next: continue`. Notez que `break` et `continue` sont des cibles de saut réservées définies implicitement dans une boucle. L&apos;utilisation de `next: break` ou `next: continue` en dehors d&apos;une boucle permettra de passer à la fin des étapes du workflow.

    * Le `end` est équivalent à `break` s&apos;il est utilisé à l&apos;intérieur d&apos;une boucle.
    * L&apos;étape suivante peut être utilisée aussi bien dans les phases de commutation que dans tout type d&apos;étape.

    ```yaml
      name: myWorkflow
      steps:
        - name: loopStep
          type: loop
          for:
            in: '${{ [range(1; 6)] }}'
            steps:
              - name: insideLoopStep1
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
                next: continue
              - name: insideLoopStep2
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
        - name: loopStepAgain
          type: loop
          for:
            in: '${{ .workflowInputs.count }}'
            steps:
              - name: switchStep
                type: switch
                switch:
                  - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                    next: break
              - name: insideLoopStepAgain
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStepAgain.loop.element }}'
    ```
  </Collapser>
</CollapserGroup>

* **`steps[*].for`** (Obligatoire)

  * **Type**: constante
  * **Description**: Signal de démarrage d&apos;une boucle

* **`steps[*].in`** (Obligatoire)

  * **Type**: chaîne (expression)

  * **Description**: Une expression qui doit être évaluée en une collection d&apos;éléments.

  * **`steps[*].steps`** (Facultatif)

    * **Description**: Étapes à exécuter à chaque itération de la boucle. Voir la définition des étapes ci-dessus.

    * **Exemple**:

      ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: "${{ [range(1; 5)] }}""
              steps:
                - name: step1
                  type: action
                  action: newrelic.ingest.sendLogs
                  version: 1
                  inputs:
                    logs:
                      - message: "Loop: ${{ .steps.loopStep.loop.element }}"
      ```

### **changer**

* Une étape qui vérifie diverses conditions et emprunte la première branche qui s&apos;évalue à vrai.

* Un commutateur peut contenir un nombre quelconque d&apos;éléments de condition dans une liste. Il vérifiera les conditions dans l&apos;ordre et traitera la première qui s&apos;avère vraie. Si aucune condition n&apos;est vraie, l&apos;étape suivante sera exécutée conformément à la définition de steps\[\*].next.

* **`steps[*].switch`** (Obligatoire)

  * **Type**: éventail
  * **Description**: Un éventail de cas de commutation, spécifiant la liste ordonnée des conditions à évaluer.

* **`steps[*].switch[*].condition`** (Obligatoire)

  * **Type**: chaîne (expression)
  * **Description**: État du boîtier de l&apos;interrupteur. Si la valeur est vraie, l&apos;étape suivante du cas sera exécutée.

* **`steps[*].switch[*].next`** (Obligatoire)

  * **Type**: chaîne de caractères (conforme au [modèle d&apos;expression sûre]())
  * **Description**: Nom de l&apos;étape à exécuter si la condition du cas est vraie. Le mot-clé spécial « end » peut être utilisé pour indiquer que cette étape doit être la dernière à être exécutée.

  ```yaml
  - name: hasCompleted
    type: switch
    switch:
      - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Failed" }}
        next: displayError
      - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Success" }}
        next: displaySuccess
    next: displayUnexpected
  ```

### attendez

Une étape qui suspend l&apos;exécution workflow pendant un certain nombre de secondes avant de se poursuivre. Il peut également capter un ou plusieurs signaux. Si aucun signal n&apos;est reçu pendant l&apos;attente, la procédure se déroulera normalement. Les signaux sont définis dans une liste. Chaque signal doit avoir une étape suivante correspondante définie. Le premier signal reçu est celui qui sera traité. La valeur reçue pour le signal sera stockée dans la sortie de l&apos;étape d&apos;attente et pourra être utilisée pour le traitement logique lors des étapes ultérieures.

* Exemple:

  ```yaml
    name: waitSignalExample
    workflowInputs:
    steps:
      - name: waitStep
        type: wait
        seconds: 300
        signals: [{name: 'mySignalName', next: 'firstStep'}]
      - name: endStep
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: "didn't get signal"
        next: end
      - name: firstStep
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: ${{ .steps.waitStep.outputs.signalInputs.myString }}
  ```

* **`steps[*].seconds`** (Obligatoire)

  * **Type**: nombre
  * **Description**: Nombre de secondes à attendre avant de poursuivre l&apos;exécution workflow.

* **`steps[*].signals`**

  * **Type**: éventail
  * **Description**: Les signaux qui, lorsqu&apos;ils sont reçus, modifient le flux du programme.

* **`steps[*].signals[*].name`**

  * **Type**: chaîne de caractères
  * **Description**: Le nom du signal à écouter.

* **`steps[*].signals[*].next`**

  * **Type**: chaîne de caractères
  * **Description**: Étape à exécuter si le signal spécifié est reçu.

## Types partagés

### chaînes d&apos;expression

Plusieurs propriétés acceptent des valeurs de type chaîne contenant des expressions intégrées qui sont évaluées lors de l&apos;exécution workflow, ce qui permet d&apos;utiliser des valeurs dynamiques dans les définitions workflow. Les chaînes d&apos;expression peuvent contenir une ou plusieurs expressions, chacune étant encadrée par des doubles accolades. Le contenu entre accolades est évalué à l&apos;aide de jq.

jq offre la possibilité d&apos;accéder aux valeurs et de les manipuler de multiples façons. Par exemple, la longueur d&apos;une chaîne d&apos;entrée workflow pourrait être obtenue comme suit : `${{ .workflowInputs.myString | length }}`

Cet outil permet de créer et [de tester des expressions JQ](https://play.jqlang.org/).

### propriétés d&apos;expression

Un certain nombre de propriétés sont accessibles via des expressions. Ces propriétés résident dans un objet « portée », les expressions doivent donc commencer par un point (.) pour accéder à ces propriétés de l&apos;objet portée.

Les propriétés disponibles sont :

* `workflowInputs` - objet contenant les entrées transmises au workflow au démarrage.
  * Exemple: `${{ .workflowInputs.myInput }}`
* `steps` - objet contenant une propriété pour chaque étape du workflow
  * `steps.<stepName>` - objet contenant les propriétés d&apos;une étape spécifique
    * `steps.<stepName>.outputs` - objet contenant les propriétés de résultat, spécifiques à l&apos;étape/action.
      * Exemple: `${{ .steps.myStep.outputs.myResult }}`

### Résultats de l&apos;évaluation de l&apos;expression

Une seule expression jq peut être évaluée à n&apos;importe quel type JSON, mais il est important de noter que le résultat final d&apos;une chaîne d&apos;expression complète dépendra du contenu de la chaîne (le cas échéant) entourant la ou les expressions.

Si l&apos;intégralité d&apos;une chaîne d&apos;expression se compose d&apos;une seule expression, celle-ci sera évaluée comme le résultat de l&apos;expression jq, en conservant le type JSON du résultat. Par exemple, si un workflow reçoit un éventail en entrée, la chaîne `${{ .workflowInputs.myArray }}` sera évaluée comme un éventail. Cela peut s&apos;avérer utile pour transmettre des données complexes au sein d&apos;un workflow.

Si la chaîne d&apos;expression contient un contenu autre qu&apos;une expression unique, elle sera évaluée comme un résultat de type chaîne de caractères. Par exemple, cela se produit lorsqu&apos;une expression est précédée ou suivie d&apos;un contenu, ou si la chaîne contient plusieurs expressions. Chaque expression contenue dans la chaîne est évaluée et convertie en une représentation sous forme de chaîne de caractères.

Exemple:

Pour les exemples suivants, supposons que myArray ait une valeur de \[1, 2, 3].

<table>
  <thead>
    <tr>
      <th>
        chaîne d&apos;expression
      </th>

      <th>
        Données de résultats
      </th>

      <th>
        Type de résultat
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `${{ .workflowInputs.myArray }}`
      </td>

      <td>
        \[1, 2, 3]
      </td>

      <td>
        éventail de nombres
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        3
      </td>

      <td>
        nombre
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        vrai
      </td>

      <td>
        booléen
      </td>
    </tr>

    <tr>
      <td>
        `Input is not empty: ${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        &quot;Le champ d&apos;entrée n&apos;est pas vide : vrai&quot;
      </td>

      <td>
        chaîne
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray }} has length ${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        &quot; a une longueur de 3&quot;
      </td>

      <td>
        chaîne
      </td>
    </tr>
  </tbody>
</table>

### Modèle sans danger pour les expressions [#expression-safe-pattern]

Les propriétés utilisables dans les expressions doivent respecter l&apos;expression régulière suivante : `^[A-Za-z_][A-Za-z0-9_]*$`

### Références secrètes

Les valeurs secrètes peuvent être utilisées dans les actions via des chaînes de référence qui spécifient le nom d&apos;un secret à rechercher dans le service de secrets. Pour faire référence à un secret dans une définition workflow, utilisez la syntaxe suivante :

* `${{ :secrets:<SECRET_NAME> }}` pour un secret pas dans un `namespace`
* `${{ :secrets:<NAMESPACE>:<SECRET_NAME> }}` pour un secret dans un `namespace`

Une chaîne d&apos;expression peut contenir un mélange de références secrètes et d&apos;expressions JQ et/ou plusieurs références secrètes.

Exemples :

```yaml
  steps:
  - name: bearer_auth
    type: action
    action: http.post
    inputs:
      headers:
        Authorization: Bearer ${{ :secrets:<SECRET_NAME> }}
```

## Exemples

* Bonjour le monde

```yaml
name: helloWorld
description: 'A hello world workflow'

workflowInputs:
  name:
    type: String
    defaultValue: World
    required: false
    validations:
      - type: maxLength
        errorMessage: "name must be at most 100 characters"
        length: 100
  slackTokenSecret:
    type: String
    defaultValue: "${{ :secrets:SLACK_TOKEN }}"
  slackChannel:
    type: String
    defaultValue: my-channel
    validations:
      - type: regex
        errorMessage: "A slack channel name must be lowercase and can only contain letters, numbers, and hyphens"
        pattern: "^[a-z0-9\\-]+$"
    required: true

steps:
  - name: init1
    type: assign
    inputs:
      greeting: Hello ${{ .workflowInputs.name }}

  - name: logName
    type: action
    action: newrelic.ingest.sendLogs
    version: 1
    inputs:
      logs:
        - message: ${{ .steps.init1.outputs.greeting }}

  - name: waiting1
    type: wait
    seconds: 1

  - name: queryForLog
    type: action
    action: newrelic.nrdb.query
    version: 1
    inputs:
      query: >-
        FROM Log SELECT * WHERE message LIKE '${{ .steps.init1.outputs.greeting
        }}'

  - name: checkResult
    type: switch
    switch:
      - condition: ${{ .steps.queryForLog.outputs.results | length > 0 }}
        next: FoundMessage

  - name: waitingMessage
    type: action
    action: slack.chat.postMessage
    version: 1
    inputs:
      channel: ${{ .workflowInputs.slackChannel }}
      text: Waiting for log message...
      token: ${{ .workflowInputs.slackTokenSecret }}
    next: waiting1

  - name: FoundMessage
    type: action
    action: slack.chat.postMessage
    version: 1
    inputs:
      channel: ${{ .workflowInputs.slackChannel }}
      text: Found message! ${{ .steps.queryForLog.outputs.results[0].message }}
      token: ${{ .workflowInputs.slackTokenSecret }}
```