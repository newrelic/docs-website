---
title: Exemples de workflow
tags:
  - workflow automation
  - workflow
  - automation
  - examples
metaDescription: 'Common workflow automation scenarios and examples for incident response, infrastructure management, and integrations.'
freshnessValidatedDate: never
translationType: machine
---

Cette page présente des scénarios d&apos;automatisation courants que vous pouvez créer avec l&apos;automatisation des workflows. Utilisez ces exemples comme points de départ pour votre propre workflow, ou explorez la [bibliothèque de modèles](/docs/workflow-automation/create-a-workflow-automation/use-a-template) pour trouver des solutions prêtes à être déployées.

## Restauration du gateway API

Rétablissez la configuration du Gateway API à un état antérieur afin de pouvoir corriger les erreurs et les mauvaises configurations.

**Ce que fait ce workflow :**

* Détecte les déploiements récents liés à un problème en utilisant New Relic suivi des changements
* Envoie des notifications Slack avec des boutons d&apos;approbation `(:+1: or :-1:)`
* Après approbation, un document AWS Systems Manager est créé pour automatiser la restauration.
* Rétablit la version précédente de l&apos;intégration API Gateway avec Lambda.
* Crée un nouveau déploiement pour appliquer la restauration.
* Envoie une notification de succès ou d&apos;échec à Slack
* Nettoie le document SSM après son achèvement

**Exigences:**

* Identifiants AWS avec autorisations pour API Gateway et système Manager
* Une application Slack configurée pour recevoir les notifications et les approbations
* monitoring de l&apos;entité New Relic avec suivi des changements

**Actions clés**: `newrelic.nerdgraph.execute`, `slack.chat.postMessage`, `slack.chat.getReactions`, `aws.systemsManager.writeDocument`, `aws.systemsManager.startAutomation`, `aws.systemsManager.waitForAutomationStatus`, `aws.systemsManager.deleteDocument`

## Gestion des instances EC2

Automatisez le provisionnement, la mise à l&apos;échelle et la suppression des instances EC2 pour des performances et des coûts optimaux.

**Ce que fait ce workflow :**

* Reçoit des alertes d&apos;utilisation élevée du processeur de New Relic.
* Récupère les détails des alertes et identifie l&apos;instance EC2 impactée.
* Envoie une notification Slack avec les détails de l&apos;instance et demande l&apos;approbation pour le redimensionnement.
* Après approbation, crée un document SSM pour automatiser le redimensionnement des instances.
* Arrête l&apos;instance, modifie le type d&apos;instance et la redémarre.
* Envoie des mises à jour de progression à Slack pendant le processus de redimensionnement.
* Attend l&apos;achèvement et envoie l&apos;état de réussite ou d&apos;échec.
* Nettoie le document SSM et envoie la confirmation finale.

**Exigences:**

* Identifiants AWS avec autorisations pour EC2 et système Manager
* Une condition d&apos;alerte New Relic active pour les métriques EC2
* Une application Slack configurée pour recevoir les notifications et les approbations

**Actions clés**: `newrelic.nerdgraph.execute`, `newrelic.nrdb.query`, `slack.chat.postMessage`, `slack.chat.getReactions`, `aws.systemsManager.writeDocument`, `aws.systemsManager.startAutomation`, `aws.systemsManager.waitForAutomationStatus`, `aws.systemsManager.deleteDocument`, `utils.datetime.fromEpoch`, `utils.uuid.generate`

## Restauration du déploiement

Annuler le déploiement si l&apos;entité devient défaillante et notifier par AWS SQS ou HTTP.

**Ce que fait ce workflow :**

* Monitorer la gravité des alertes d&apos;une entité pendant une durée spécifiée (30 minutes par défaut).
* Vérifie l&apos;état de l&apos;entité toutes les minutes
* Si l&apos;entité passe à l&apos;état CRITIQUE ou AVERTISSEMENT, consignez l&apos;état d&apos;anomalie.
* Envoie une notification de restauration via AWS SQS (si configuré) avec les détails de l&apos;entité.
* Envoie une notification de restauration via webhook HTTP (si configuré).
* Si l&apos;entité reste saine pendant toute la durée, consigner le succès
* monitoring s&apos;interrompt si l&apos;entité est introuvable.

**Exigences:**

* Entité New Relic avec monitoringde la gravité des alertes
* (Facultatif) File d&apos;attente AWS SQS et rôle pour recevoir les notifications de restauration
* (Facultatif) Point de terminaison HTTP pour recevoir notificationde restauration

**Actions clés**: `newrelic.nerdgraph.execute`, `newrelic.ingest.sendLogs`, `aws.execute.api`, `(sqs.send_message)`, `http.post`

## Messagerie AWS SQS

Envoyer des messages à une file d&apos;attente AWS SQS pour le traitement en aval ou les systèmes de notification.

**Ce que fait ce workflow :**

* Envoie un message à une file d&apos;attente SQS spécifiée
* Utilise l&apos;authentification du rôle IAM AWS pour un accès sécurisé
* Renvoie l&apos;ID du message et l&apos;état de réussite pour vérification

**Exigences:**

* Identifiants AWS avec la permission `sqs:SendMessage`
* URL de la file d&apos;attente SQS
* Rôle IAM configuré pour l&apos;automatisation du workflow (voir [Configurer les identifiants AWS](/docs/workflow-automation/setup-and-configuration/set-up-aws-credentials))

**Actions clés**: `aws.execute.api`, `(sqs.send_message)`

```yaml
  name: aws_execute_api_sqs_example

  workflowInputs:
    awsRoleArn:
      type: String
    awsRegion:
      type: String
      defaultValue: us-west-2
    awsQueueUrl:
      type: String

  steps:
    - name: sendSqsMessage
      type: action
      action: aws.execute.api
      version: 1
      inputs:
        awsRoleArn: ${{ .workflowInputs.awsRoleArn }}
        region: ${{ .workflowInputs.awsRegion }}
        service: sqs
        api: send_message
        parameters:
          QueueUrl: "${{ .workflowInputs.awsQueueUrl }}"
          MessageBody: |
            {
              "message": "deployment is bad",
              "status": "not good"
            }
        selectors:
          - name: success
            expression: '.success'
          - name: messageId
            expression: '.response.MessageId'
```

## Alertes NRQL complexes

Gérez les requêtes NRQL complexes que les alertes standard ne peuvent pas prendre en charge, telles que la comparaison de données sur plusieurs fenêtres temporelles ou l&apos;application d&apos;une logique personnalisée avant de déclencher des notifications.

**Ce que fait ce workflow :**

* Exécute deux requêtes NRQL comparant différentes fenêtres temporelles (il y a 10 minutes jusqu&apos;à il y a 5 minutes contre les 5 dernières minutes)
* Compare les résultats de la requête pour détecter si le nombre a augmenté
* Utilise une étape de commutateur pour envoyer conditionnellement des notifications uniquement lorsque de nouveaux événements sont détectés
* Envoie une notification par e-mail avec les résultats de la requête et une pièce jointe CSV
* Peut être planifié pour s&apos;exécuter toutes les 10 minutes pour un monitoring continu

**Exigences:**

* Compte New Relic avec des données à interroger
* Destination de messagerie configurée dans New Relic (voir [Envoyer des notifications à partir des workflows](/docs/workflow-automation/setup-and-configuration/create-destinations))
* Workflow planifié à l&apos;aide de l&apos;API [CreateSchedule](/docs/workflow-automation/workflow-automation-apis/create-schedule)

**Actions clés**: `newrelic.nrdb.query`, `newrelic.notification.sendEmail`

**Cas d&apos;utilisation**: Ce modèle est utile lorsque les alertes New Relic standard ne peuvent pas gérer vos exigences, telles que :

* Comparaison des métriques sur plusieurs fenêtres temporelles
* Application d&apos;opérations mathématiques personnalisées sur les résultats de requête
* Déclenchement uniquement lorsque des seuils ou des modèles spécifiques sont détectés
* Combinaison de données provenant de plusieurs requêtes avec une logique conditionnelle

```yaml
  name: Complex_Alert_Workflow
  description: 'Compares NRQL results across time windows and sends alerts when new events are detected'

  workflowInputs:
    destinationId:
      type: String
    query:
      type: String
      defaultValue: 'FROM Span SELECT count(*)'

  steps:
    - name: query1
      type: action
      action: newrelic.nrdb.query
      version: 1
      inputs:
        query: "${{ .workflowInputs.query }} SINCE 10 minutes ago UNTIL 5 minutes ago"
        accountIds:
          - 7401815
        selectors:
          - name: length
            expression: '[ .results[] | length ]'
          - name: count
            expression: '[ .results[0].count ]'

    - name: query2
      type: action
      action: newrelic.nrdb.query
      version: 1
      inputs:
        query: "${{ .workflowInputs.query }} SINCE 5 minutes ago"
        accountIds:
          - 7401815
        selectors:
          - name: length
            expression: '[ .results[] | length ]'
          - name: count
            expression: '[ .results[0].count ]'

    - name: CheckForNewEvents
      type: switch
      switch:
        - condition: >-
            ${{ (.steps.query2.outputs.count - .steps.query1.outputs.count) > 0 }}
          next: sendEmail
      next: end

    - name: sendEmail
      type: action
      action: newrelic.notification.sendEmail
      version: 1
      inputs:
        destinationId: ${{ .workflowInputs.destinationId }}
        subject: Hello there!
        message: >-
          More spans incoming!!!
          There are --- ${{ (.steps.query2.outputs.count - .steps.query1.outputs.count) }} ---
          new Spans that were ingested in the last 5 minutes
        attachments:
          - type: QUERY
            query: ${{ .workflowInputs.query }} SINCE 5 minutes ago
            format: CSV
            filename: span_count.csv
      next: end
```

**Pour planifier ce workflow**, utilisez l&apos;[API CreateSchedule](/docs/workflow-automation/create-a-workflow-automation/start-schedule#scheduled) avec une expression cron comme `*/10 * * * *` (toutes les 10 minutes). N&apos;oubliez pas que l&apos;intervalle de planification minimum est de 10 minutes. Consultez la section [Limites du workflow](/docs/workflow-automation/limitations-and-faq/workflow-limits) pour plus de détails.

## Envoyer un rapport à Slack

Envoyer le résultat d&apos;une requête NRQL sous forme de fichier CSV sur Slack.

**Ce que fait ce workflow :**

* Exécute une requête NRQL sur le compte New Relic spécifié
* Génère un fichier CSV à partir des résultats de la requête
* Publie le fichier CSV sur un canal Slack spécifié avec un message

**Exigences:**

* Une authentification New Relic et une requête NRQL fonctionnelle
* Une application Slack configurée avec un jeton et un canal cible

**Actions clés**: `newrelic.nrdb.query`, `utils.transform.toCSV`, `slack.chat.postMessage`

## Analyse JSON

Analyse l&apos;API d&apos;état public JSON (HTTP) de New Relic et enregistre éventuellement les composants opérationnels et non opérationnels.

**Ce que fait ce workflow :**

* Récupère des données JSON à partir de l&apos;API d&apos;état de New Relic
* Extrait et catégorise les composants selon leur état opérationnel
* Enregistrement conditionnel des composants opérationnels (si activée)
* Enregistrement conditionnel des composants non opérationnels (si activée)
* Gère les erreurs HTTP et consigne les messages d&apos;erreur.

**Exigences:**

* Accès à l&apos;API d&apos;état New Relic (`summary.json`)
* Autorisations pour envoyer des logs via newrelic.ingest.sendLogs

**Actions clés**: `http.get`, `newrelic.ingest.sendLogs`

## Interrogation et logging de l&apos;API REST

Interrogez un point de terminaison d&apos;API REST, parcourez les résultats et enregistrez les données dans New Relic.

<Callout variant="important">
  Vous n&apos;avez pas besoin d&apos;utiliser des sélecteurs si vous souhaitez la charge utile complète. La plupart des outils de workflow vous permettent de référencer directement l&apos;objet de réponse complet.
</Callout>

### GET simple et log

Pour un cas d&apos;utilisation de base de l&apos;interrogation d&apos;une API et de la loging de la réponse complète :

**Ce que fait ce workflow :**

* Déclencheur : Planification (par exemple, toutes les 5 minutes) ou vous pouvez utiliser Exécuter pour manuel

* Étape de requête HTTP :

  * Méthode : GET
  * URL : [https://pokeapi.co/api/v2/pokemon](https://pokeapi.co/api/v2/pokemon)
  * Enregistrez le corps complet de la réponse dans une variable (par exemple, `{{.http_response}}`)

* Étape d&apos;enregistrement/création d&apos;événement :

  * Envoyer l&apos;intégralité du `{{.http_response.body}}` comme charge utile
  * Aucun sélecteur requis - il suffit de transmettre le JSON brut

### API REST avec boucles et sélecteurs

Cet exemple collecte tous les résultats d&apos;une API, les parcourt en boucle, effectue des appels HTTP individuels et consigne les données extraites.

**Ce que fait ce workflow :**

* Récupère tous les résultats d&apos;un point de terminaison d&apos;API REST
* Parcourt chaque résultat de la réponse
* Effectue des appels d&apos;API individuels pour chaque élément à l&apos;aide des données de la boucle
* Extrait des champs spécifiques de chaque réponse à l&apos;aide de sélecteurs
* Enregistre les données extraites dans New Relic avec des attributs personnalisés

**Exigences:**

* Accès à un point de terminaison d&apos;API REST
* Autorisations pour envoyer des logs via `newrelic.ingest.sendLogs`

**Actions clés**: `http.get`, `newrelic.ingest.sendLogs`

```yaml
  name: pokemon_workflow
  description: ''
  steps:
    - name: get_all_pokemons
      type: action
      action: http.get
      version: '1'
      inputs:
        url: https://pokeapi.co/api/v2/pokemon
        selectors:
          - name: pokemons
            expression: .responseBody | fromjson.results
    - name: pokemon_loop
      type: loop
      for:
        in: ${{ .steps.get_all_pokemons.outputs.pokemons }}
        steps:
          - name: get_individual_pokemon
            type: action
            action: http.get
            version: '1'
            inputs:
              url: ${{ .steps.pokemon_loop.loop.element.url }}
              selectors:
                - name: pokemon_name
                  expression: .responseBody | fromjson.name
                - name: pokemon_id
                  expression: .responseBody | fromjson.id
                - name: pokemon_stats
                  expression: .responseBody | fromjson.stats
          - name: log_pokemon_info
            type: action
            action: newrelic.ingest.sendLogs
            version: '1'
            inputs:
              logs:
                - message: >-
                    Pokemon name is: ${{
                    .steps.get_individual_pokemon.outputs.pokemon_name}}, Id: ${{
                    .steps.get_individual_pokemon.outputs.pokemon_id}}
                  attributes:
                    pokemon_stats: ${{ .steps.get_individual_pokemon.outputs.pokemon_stats}}
            next: continue
      next: end
```

### Conversion API REST vers CSV

Cet exemple illustre l&apos;utilisation de la réponse complète sans sélecteurs, la conversion des données d&apos;API en CSV et leur partage via Slack.

**Ce que fait ce workflow :**

* Récupère les données de l&apos;heure actuelle de l&apos;API World Time en fonction de l&apos;entrée du fuseau horaire
* Convertit la réponse JSON complète au format CSV
* Enregistre les données CSV dans New Relic
* Publie le fichier CSV sur un canal Slack

**Exigences:**

* Accès à un point de terminaison d&apos;API REST
* Autorisations pour envoyer des logs via newrelic.ingest.sendLogs
* Une application Slack configurée avec un jeton et un canal cible

**Actions clés**: `http.get`, `utils.transform.toCSV`, `newrelic.ingest.sendLogs`, `slack.chat.postMessage`

```yaml
  name: jsontocsv

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'

    - name: csv1
      type: action
      action: utils.transform.toCSV
      version: 1
      inputs:
        json: ${{ .steps.getCurrentTime.outputs.responseBody }}

    - name: logOutput
      type: action
      action: newrelic.ingest.sendLogs
      version: 1
      inputs:
        logs:
          - message: 'CSV: ${{ .steps.csv1.outputs.csv }}'

    - name: postCsv
      type: action
      action: slack.chat.postMessage
      version: 1
      inputs:
        channel: test-channel-workflow
        text: "Current Date details"
        attachment:
          filename: 'file.csv'
          content: ${{ .steps.csv1.outputs.csv }}
        token: ${{ :secrets:dn_staging_slack_token }}
```

## Modèle de workflow disponible

Les modèles énumérés ci-dessus sont disponibles directement dans l&apos;interface utilisateur d&apos;automatisation des workflows de New Relic. Pour y accéder :

1. Accédez à **All Capabilities &gt; Workflow Automation**
2. Cliquez sur **Create workflow**
3. Sélectionnez **Use a template**
4. Parcourez la bibliothèque de modèles et choisissez un workflow qui correspond à votre cas d&apos;utilisation.

Chaque modèle comprend :

* Étapes et logique workflow préconfigurées
* Exemple de paramètres d&apos;entrée
* Identifiants et intégration requis
* Documentation des résultats attendus

Vous pouvez utiliser les modèles tels quels ou les personnaliser pour les adapter à vos besoins spécifiques.

## Transmission de données entre les étapes

Tous les workflows peuvent faire référence aux résultats des étapes précédentes en utilisant la syntaxe de modèle. Cela vous permet d&apos;enchaîner des actions et de construire une logique d&apos;automatisation complexe.

### Utilisation des entrées de workflow

Vous pouvez utiliser la syntaxe `${{ .workflowInputs.variableName }}` pour transmettre des valeurs dynamiques au moment de l&apos;exécution. Cette syntaxe fonctionne dans les URL de point de terminaison et d&apos;autres champs de saisie.

**Exemple:**

```json
  {
    "inputs": [
      {
        "key": "urlParams",
        "value": "{\"filter\": \"active\"}"
      },
      {
        "key": "headers",
        "value": "{\"Api-Key\": \"your-api-key\"}"
      }
    ]
  }
```

### Transmission de données de base

Cet exemple de requête signale les problèmes d&apos;alerte de New Relic et envoie une notification à Slack pour chaque problème actif.

```yaml
  name: alertSlack
  description: "query Alert Issues and send notifications to Slack"

  workflowInputs:
    accountId:
      type: Int

  steps:
    - name: getAlert
      type: action
      action: newrelic.nerdgraph.execute
      version: 1
      inputs:
        graphql: |
          query GetAlertIssues($accountId: Int!) {
            actor {
              account(id: $accountId) {
                aiIssues {
                  issues(filter: {states: ACTIVATED}) {
                    issues {
                      issueId
                      priority
                      state
                      title
                    }
                  }
                }
              }
            }
          }
        variables:
          accountId: ${{ .workflowInputs.accountId }}

    - name: loopStep
      type: loop
      for:
        in: ${{ .steps.getAlert.outputs.data.actor.account.aiIssues.issues.issues }}
        steps:
          - name: sendToSlack
            type: action
            action: slack.chat.postMessage
            version: 1
            inputs:
              token: ${{ :secrets:your_slack_token }}
              channel: incident-channel
              text: >
                issueId: ${{ .steps.loopStep.loop.element.issueId }}
                priority: ${{ .steps.loopStep.loop.element.priority }}
                state: ${{ .steps.loopStep.loop.element.state }}
                title: ${{ .steps.loopStep.loop.element.title | tostring }}
```

### Structure de boucle

Vous pouvez utiliser la boucle pour parcourir une liste, une carte ou une collection.

Une boucle itère sur une collection donnée définie par `in`. Elle crée automatiquement les variables de boucle `index` et `element` pour chacune de ses itérations. Ces variables de boucle sont accessibles dans la boucle avec l&apos;[expression JQ](https://play.jqlang.org/) `${{ .steps.<loopStepName>.loop.element }}` ou `${{ .steps.<loopStepName>.loop.index }}`.

**Paramètres:**

* **`for`** (Obligatoire) : Signalement du démarrage d&apos;une boucle
* **`in`** (Obligatoire, expression de chaîne) : une expression qui doit être évaluée en une collection d&apos;éléments
* **`steps`** (Obligatoire) : Étapes à exécuter à chaque itération de la boucle. Une étape peut être n&apos;importe quel type d&apos;étape, y compris une autre boucle

**Boucle avec les entrées de workflow :**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
```

**Remarques importantes :**

* `for`: requis. Il s&apos;agit de l&apos;élément de niveau supérieur indiquant le début d&apos;une boucle for
* `in`: requis. Pour que la collection d&apos;entrée soit itérée, elle doit être convertible en tableau Java
* `steps`: requis. À chaque itération, les étapes seront exécutées
* `element` et `index` sont automatiquement affectés dans le cadre de la boucle
* `index` est basé sur zéro
* Le `element` peut être un type complexe si vous avez une collection d&apos;éléments complexes
* Les variables créées à l&apos;intérieur de la boucle (variables de boucle et sorties d&apos;étape) ne sont accessibles qu&apos;à l&apos;intérieur de la boucle.
* Ces variables sont effacées à la sortie de la boucle et seront nulles si elles sont consultées en dehors de la boucle
* Les boucles peuvent accéder aux variables définies en dehors de la boucle

**Boucle simple sur les entiers :**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: ${{ [range(1; 6)] }}
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
```

**Boucle simple pour la carte :**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
```

**Sauter dans une boucle :**

Seuls les sauts entre étapes nommées appartenant à la même boucle for sont autorisés. Il est interdit d&apos;entrer ou de sortir d&apos;une boucle for, de passer à une boucle interne/externe ou de naviguer entre deux boucles for différentes.

```yaml
  name: myWorkflow
  steps:
    - name: firstStep
      type: action
      action: internal.example.sayHello
      version: '1'
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: step3  # Okay within the loop
          - name: step2
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.step1.outputs.greeting }}'
          - name: step3
            type: action
            action: internal.example.sayHello
            version: '1'
            next: firstStep  # Not okay, first step is not in the loop context
```

**Utiliser break/continue dans une boucle :**

Pour modifier le flux d&apos;une boucle for, vous pouvez utiliser `next: break` ou `next: continue`. Notez que `break` et `continue` sont des cibles de saut réservées définies implicitement dans une boucle. L&apos;utilisation de `next: break` ou `next: continue` en dehors d&apos;une boucle sautera à la fin des étapes du workflow.

Le `end` sert de même que `break` s&apos;il est utilisé à l&apos;intérieur d&apos;une boucle. Next peut être utilisé à la fois dans les étapes de commutation ou dans tout type d&apos;étape.

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [range(1; 6)] }}'
        steps:
          - name: insideLoopStep1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: continue
          - name: insideLoopStep2
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
    - name: loopStepAgain
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: switchStep
            type: switch
            switch:
              - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                next: break
          - name: insideLoopStepAgain
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStepAgain.loop.element }}'
```

### Logique conditionnelle avec données

```yaml
  steps:
    - name: checkCPU
      type: action
      action: newrelic.nerdgraph.execute
      version: 1
      # ... query configuration

    - name: decideAction
      type: switch
      switch:
        - condition: "${{ .steps.checkCPU.outputs.data.actor.account.nrql.results[0].average > 90 }}"
          next: resizeInstance
        - condition: "${{ .steps.checkCPU.outputs.data.actor.account.nrql.results[0].average > 70 }}"
          next: sendWarning
      next: normalOperation

    - name: resizeInstance
      type: action
      action: aws.ec2.modifyInstanceAttribute
      version: 1
      # ... resize configuration

    - name: sendWarning
      type: action
      action: slack.chat.postMessage
      version: 1
      # ... warning message

    - name: normalOperation
      type: action
      action: newrelic.ingest.sendLogs
      version: 1
      # ... log normal status
```

## Et ensuite ?

* **[Dépannage](/docs/workflow-automation/troubleshooting)** : Correction des erreurs d&apos;identification, des problèmes d&apos;intégration et des échecs workflow.
* **[Bonnes pratiques](/docs/workflow-automation/limitations-and-faq/workflow-best-practices)**: Gestion des erreurs, optimisation des performances, stratégies de tests.
* **[Limites du workflow](/docs/workflow-automation/limitations-and-faq/workflow-limits)** : Comprendre les délais d’expiration, les limites de débit et les contraintes.