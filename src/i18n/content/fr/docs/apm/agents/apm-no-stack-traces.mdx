---
title: Aucune trace d'appels
type: troubleshooting
tags:
  - Agents
  - Java agent
  - Troubleshooting
metaDescription: Troubleshooting steps for situations when stack traces are missing for error traces with your New Relic Java app.
freshnessValidatedDate: never
translationType: machine
---

## Problème

Selon la situation, vous pouvez trouver [des traces d'erreur](/docs/apm/applications-menu/error-analytics/error-analytics-manage-error-traces) dans l&amp;apos;UI APM qui n&amp;apos;incluent pas de trace d&amp;apos;appels pour votre application.

## Solution

Selon la situation, suivez ces procédures de dépannage.

<CollapserGroup>
  <Collapser id="Caps on error reporting" title="Limites des rapports d'erreurs">
    Pour des raisons de performances, nous limitons les rapports d'erreurs comme suit :

    * 100 événements par minute par agent instance
    * 20 détails de trace par minute par instance d'agent
  </Collapser>

  <Collapser id="Handled exceptions" title="Exceptions traitées">
    Notre agent APM signale automatiquement les erreurs pour les exceptions non gérées. Dans les situations où la logique application gère l'erreur, notre agent APM peut manquer l'erreur et ne signalera pas de trace d'appels.

    Vous pouvez utiliser l'[API spécifique à l'agent](/docs/apm/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/#error-collection) `notice_error()` pour enregistrer les exceptions traitées.
  </Collapser>

  <Collapser id="Ignored errors" title="Les erreurs sont ignorées">
    Si vous avez configuré les erreurs à [ignorer](/docs/apm/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/#ignore), la trace des appels ne sera pas disponible
  </Collapser>

  <Collapser id="500-errors" title="Aucune trace d'appels pour 500 erreurs">
    Le renvoi d'une erreur `500` signifie que le serveur d&amp;apos;application lui-même a détecté une erreur et défini le code d&amp;apos;état HTTPS `500` .

    * Si la condition d'erreur a été détectée et gérée par la logique application , il n'y avait aucun objet d'exception et donc aucune stack.

    * S'il y avait un objet d'exception à un moment donné, mais qu'il était géré en interne par le code d'application qui définissait le statut `500` sur la réponse, alors l&amp;apos;exception n&amp;apos;est jamais devenue visible pour l&amp;apos;agent. Il n&amp;apos;y a aucune stack disponible pour que l&amp;apos;agent puisse la signaler.

      Lorsque des traces d'appels sont signalées, l'erreur résulte d'une exception qui n'a pas été détectée et gérée dans la logique du serveur application . L'agent voit l'exception non gérée lors d'une transaction de monitoring, il signale donc la trace des appels.
  </Collapser>
</CollapserGroup>

## comportement spécifique de l'agent en cas de trace d'appels manquante

### agent Java

<CollapserGroup>
  <Collapser id="repeated-errors" title="Aucune trace d'appel pour les erreurs répétées rapidement">
    Lorsqu'une erreur est générée dans une séquence répétée rapidement, le compilateur Java peut optimiser la trace des appels pour améliorer les performances. Pour désactiver cette optimisation : Dans vos indicateurs JVM, incluez :

    ```
    -XX:-OmitStackTraceInFastThrow
    ```
  </Collapser>
</CollapserGroup>