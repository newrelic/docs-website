---
title: Aucune trace d'appels (Java)
type: troubleshooting
tags:
  - Agents
  - Java agent
  - Troubleshooting
metaDescription: Troubleshooting steps for situations when stack traces are missing for error traces with your New Relic Java app.
freshnessValidatedDate: never
translationType: machine
---

## Problème

Selon la situation, vous pouvez trouver [des traces d'erreur](/docs/apm/applications-menu/error-analytics/error-analytics-manage-error-traces) dans l&amp;apos;UI APM qui n&amp;apos;incluent pas de trace d&amp;apos;appels pour votre Java application .

## Solution

Selon la situation, suivez ces procédures de dépannage.

<CollapserGroup>
  <Collapser id="repeated-errors" title="Aucune trace d'appel pour les erreurs répétées rapidement">
    Lorsqu'une erreur est générée dans une séquence répétée rapidement, le compilateur Java peut optimiser la trace des appels pour améliorer les performances. Pour désactiver cette optimisation : Dans vos indicateurs JVM, incluez :

    ```
    -XX:-OmitStackTraceInFastThrow
    ```
  </Collapser>

  <Collapser id="500-errors" title="Aucune trace d'appels pour 500 erreurs">
    Il s’agit d’ [un comportement normal](#cause) de la manière dont l’agent Java gère les erreurs 500. Pour forcer le suivi des appels à être signalé, appelez New Relic Java API l&amp;apos; à partir de votre propre code. L&amp;apos;exécution de la méthode `NewRelic.noticeError (Throwable t)` entraînera le signalement d&amp;apos;une erreur ainsi que la trace stack représentée par `Throwable`. Pour plus d&amp;apos;informations sur cette méthode et ses surcharges, consultez [l'API de l'agent Java de New Relic sur GitHub.](https://newrelic.github.io/java-agent-api/javadoc/com/newrelic/api/agent/NewRelic.html#noticeError-java.lang.Throwable-)
  </Collapser>
</CollapserGroup>

## Cause

Le renvoi d'une erreur `500` signifie que le serveur d&amp;apos;application lui-même a détecté une erreur et défini le code d&amp;apos;état HTTPS `500` .

* Si la condition d'erreur a été détectée et gérée par la logique application , il n'y avait aucun objet d'exception et donc aucune stack.
* S'il y avait un objet d'exception à un moment donné, mais qu'il était géré en interne par le code d'application qui définissait le statut `500` sur la réponse, alors l&amp;apos;exception n&amp;apos;est jamais devenue visible pour l&amp;apos;agent Java. Il n&amp;apos;y a pas stack disponible pour que l&amp;apos;agent Java puisse effectuer un rapport.

Lorsque des traces d'appels sont signalées, l'erreur résulte d'une exception qui n'a pas été détectée et gérée dans la logique du serveur application . L'agent Java voit l'exception non gérée lors d'une transaction du moniteur, il signale donc la trace d'appels.

Cependant, aucune trace d'appel n'apparaît pour les erreurs `500` car le serveur application gère les erreurs et définit ensuite le code d&amp;apos;état. Le code application lui-même ne conserve aucune trace d&amp;apos;appels.