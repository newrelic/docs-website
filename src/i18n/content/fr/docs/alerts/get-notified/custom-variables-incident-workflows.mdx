---
title: variables de flux de travail
tags:
  - Alerts
  - workflows
  - Enrichments
  - Issues
metaDescription: 'For New Relic alerts, explanations of the variables used for workflows.'
freshnessValidatedDate: never
translationType: machine
---

Une explication des variables utilisées pour le New Relic [flux](/docs/alerts-applied-intelligence/applied-intelligence/incident-workflows/incident-workflows) de travail des alertes .

<img title="Alerts workflow variables" alt="Alerts workflow variables" src="/images/alerts_screenshot-crop_workflow-variables.webp" />

<figcaption>
  Lors de la création d'un workflow, vous pouvez utiliser des variables pour a) déterminer les types de problèmes qui généreront une notification et b) le contenu d'une charge utile de notification. Cette capture d'écran montre la section des frais notification .
</figcaption>

## Variables [#variables]

Voici les variables du workflow et leurs descriptions :

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        Clé (premier mot utilisé pour le regroupement)
      </th>

      <th>
        Nom d'affichage (premier mot utilisé pour le regroupement)
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `accumulations.conditionDescription`
      </td>

      <td>
        étatDescription
      </td>

      <td>
        Description de l'incident personnalisé de la condition.
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.conditionFamilyId`
      </td>

      <td>
        conditionFamilyId
      </td>

      <td>
        L'ID de la condition de détection d'incident qui a généré l'incident.
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.conditionName`
      </td>

      <td>
        noms des conditions d'alerte
      </td>

      <td>
        New Relic a rompu les conditions.
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.conditionProduct`
      </td>

      <td>
        produits à condition d'alerte
      </td>

      <td>
        New Relic .
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.deepLinkUrl`
      </td>

      <td>
        URL de rappel d'incident
      </td>

      <td>
        Un lien direct vers le rappel de l'incident concerné.
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.evaluation.metricValueFunction`
      </td>

      <td>
        métriques personnalisées fonction de valeur
      </td>

      <td>
        métriques personnalisées en fonction de la valeur.
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.evaluation.name`
      </td>

      <td>
        <InlinePopover type="apm" />nom de la métrique de condition
      </td>

      <td>
        <InlinePopover type="apm" />nom de la métrique de condition
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.nrqlQuery`
      </td>

      <td>
        Requête NRQL
      </td>

      <td>
        Requête NRQL de la condition.
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.origins`
      </td>

      <td>
        Origines du problème
      </td>

      <td>
        New Relic ou source(s) tierce(s) ayant créé l'incident(s).
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.policyName`
      </td>

      <td>
        noms de règles d'alerte
      </td>

      <td>
        nom de la politique de détection d'incident qui a généré l'incident.
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.runbookUrl`
      </td>

      <td>
        URL du cahier d'exécution
      </td>

      <td>
        Une liste d’URL runbook .
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.sources`
      </td>

      <td>
        Sources des problèmes
      </td>

      <td>
        Le(s) système(s) signalant l'incident(s).
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.tag.account`
      </td>

      <td>
        Comptes New Relic
      </td>

      <td>
        Comptes New Relic.
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.tag.affectedService`
      </td>

      <td>
        Service affecté
      </td>

      <td>
        Une liste des services concernés.
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.tag.assignmentGroup`
      </td>

      <td>
        Groupe d'affectation
      </td>

      <td>
        Une liste de groupes d’affectation.
      </td>
    </tr>

    <tr>
      <td>
        `accumulations.tag.causeService`
      </td>

      <td>
        Causer un service
      </td>

      <td>
        Une liste des services de cause.
      </td>
    </tr>

    <tr>
      <td>
        `acknowledgedBy`
      </td>

      <td>
        Reconnu par
      </td>

      <td>
        L'utilisateur qui a reconnu le problème.
      </td>
    </tr>

    <tr>
      <td>
        `activatedAt`
      </td>

      <td>
        Problème activé à
      </td>

      <td>
        Horaire d'activation de l'émission.
      </td>
    </tr>

    <tr>
      <td>
        `annotations.description`
      </td>

      <td>
        Description du problème
      </td>

      <td>
        Liste de toutes les descriptions incident .
      </td>
    </tr>

    <tr>
      <td>
        `annotations.title`
      </td>

      <td>
        Titre du numéro
      </td>

      <td>
        Liste de tous les titres incident .
      </td>
    </tr>

    <tr>
      <td>
        `annotations.wildcard`
      </td>

      <td>
        Facettes d'alerte
      </td>

      <td>
        Facettes d'alerte.
      </td>
    </tr>

    <tr>
      <td>
        `closedBy`
      </td>

      <td>
        Fermé par
      </td>

      <td>
        L'ID de l'utilisateur qui a fermé le problème.
      </td>
    </tr>

    <tr>
      <td>
        `closedAt`
      </td>

      <td>
        Problème ClosedAt
      </td>

      <td>
        Horaire de clôture de l'émission. Null si le problème n'est pas fermé.
      </td>
    </tr>

    <tr>
      <td>
        `closedIncidentsCount`
      </td>

      <td>
        Nombre d'incidents clos
      </td>

      <td>
        Le nombre total d'incidents fermés sur ce problème.
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        Problème CreatedAt
      </td>

      <td>
        Horaire de création de l'émission.
      </td>
    </tr>

    <tr>
      <td>
        `dataMLModules.components`
      </td>

      <td>
        Composants d'apprentissage automatique
      </td>

      <td>
        Une liste des composants d’apprentissage automatique des alertes New Relic.
      </td>
    </tr>

    <tr>
      <td>
        `dataMLModules.goldenSignals`
      </td>

      <td>
        Machine learning signaux dorés
      </td>

      <td>
        Une liste des alertes New Relic des signaux dorés d’apprentissage automatique.
      </td>
    </tr>

    <tr>
      <td>
        `dataMLModules.suggestedResponders`
      </td>

      <td>
        Répondeur suggéré par l'apprentissage automatique
      </td>

      <td>
        (Obsolète) Une liste d'alertes New Relic suggérées par l'apprentissage automatique des intervenants.
      </td>
    </tr>

    <tr>
      <td>
        `entitiesData.entities`
      </td>

      <td>
        Données d'entité impactées
      </td>

      <td>
        Une liste d'objets décrivant le nom, l'ID, le type et le genre de l'entité impactée.
      </td>
    </tr>

    <tr>
      <td>
        `entitiesData.ids`
      </td>

      <td>
        ID d'entité impactés
      </td>

      <td>
        Un ensemble de tous les identifiants d’entité impactés.
      </td>
    </tr>

    <tr>
      <td>
        `entitiesData.kinds`
      </td>

      <td>
        Types d'entités impactées
      </td>

      <td>
        Un ensemble de tous les types d’entités impactés.
      </td>
    </tr>

    <tr>
      <td>
        `entitiesData.names`
      </td>

      <td>
        Noms des entités impactées
      </td>

      <td>
        Un ensemble de tous les noms d’entités impactés.
      </td>
    </tr>

    <tr>
      <td>
        `entitiesData.types`
      </td>

      <td>
        Types d'entités impactées
      </td>

      <td>
        Un ensemble de tous les types d’entités impactés.
      </td>
    </tr>

    <tr>
      <td>
        `impactedEntitiesCount`
      </td>

      <td>
        Nombre d'entités impactées
      </td>

      <td>
        Le nombre d'entités impactées par ce problème.
      </td>
    </tr>

    <tr>
      <td>
        `incidentIds`
      </td>

      <td>
        Identifiants d'incident
      </td>

      <td>
        Une liste de tous les incidents agrégés du problème.
      </td>
    </tr>

    <tr>
      <td>
        `isCorrelated`
      </td>

      <td>
        Le problème est corrélé
      </td>

      <td>
        Si le problème est corrélé (`true`, `false`).
      </td>
    </tr>

    <tr>
      <td>
        `isAcknowledged`
      </td>

      <td>
        Le problème est reconnu
      </td>

      <td>
        Si le problème est reconnu (`true`, `false`).
      </td>
    </tr>

    <tr>
      <td>
        `issueAckUrl`
      </td>

      <td>
        URL de confirmation du problème
      </td>

      <td>
        Un lien direct pour reconnaître le problème.
      </td>
    </tr>

    <tr>
      <td>
        `issueCloseUrl`
      </td>

      <td>
        URL de fermeture du problème
      </td>

      <td>
        Un lien direct pour fermer le problème.
      </td>
    </tr>

    <tr>
      <td>
        `issuePageUrl`
      </td>

      <td>
        URL de la page de problème
      </td>

      <td>
        Un lien direct vers la page du problème concerné.
      </td>
    </tr>

    <tr>
      <td>
        `issueActivatedAtUtc`
      </td>

      <td>
        Chaîne du problème ActivatedAt UTC
      </td>

      <td>
        Format de chaîne d'activation du problème en UTC.
      </td>
    </tr>

    <tr>
      <td>
        `issueClosedAtUtc`
      </td>

      <td>
        Chaîne du problème ClosedAt UTC
      </td>

      <td>
        Format de chaîne de clôture du problème en UTC.
      </td>
    </tr>

    <tr>
      <td>
        `issueCreatedAtUtc`
      </td>

      <td>
        Chaîne du problème CreatedAt UTC
      </td>

      <td>
        Format de chaîne de création de problème en UTC.
      </td>
    </tr>

    <tr>
      <td>
        `issueAcknowledgedAt`
      </td>

      <td>
        Chaîne du problème AcknowledgedAt
      </td>

      <td>
        Format de chaîne du problème reconnu en UTC.
      </td>
    </tr>

    <tr>
      <td>
        `issueClosedAt`
      </td>

      <td>
        Chaîne du problème ClosedAt
      </td>

      <td>
        Format de chaîne de clôture du problème en UTC.
      </td>
    </tr>

    <tr>
      <td>
        `issueDurationMs`
      </td>

      <td>
        Durée de l'émission en millisecondes
      </td>

      <td>
        Le nombre de millisecondes depuis l'ouverture du problème.
      </td>
    </tr>

    <tr>
      <td>
        `issueDurationText`
      </td>

      <td>
        Durée de l'émission textuelle
      </td>

      <td>
        Une représentation conviviale de la durée du problème.
      </td>
    </tr>

    <tr>
      <td>
        `issueId`
      </td>

      <td>
        ID du problème
      </td>

      <td>
        L'ID unique du problème.
      </td>
    </tr>

    <tr>
      <td>
        `issueTitle`
      </td>

      <td>
        Titre du numéro
      </td>

      <td>
        Habituellement le titre du premier incident.
      </td>
    </tr>

    <tr>
      <td>
        `issueUpdatedAt`
      </td>

      <td>
        Chaîne du problème UpdatedAt UTC
      </td>

      <td>
        Horaire de mise à jour du problème en UTC.
      </td>
    </tr>

    <tr>
      <td>
        `labels.accountIds`
      </td>

      <td>
        ID de compte associé à l'environnement du problème
      </td>

      <td>
        New Relic alerte les environnements associés à l'ID de compte.
      </td>
    </tr>

    <tr>
      <td>
        `labels.aggregationKeys`
      </td>

      <td>
        Clé d'agrégation des alertes d'étiquettes
      </td>

      <td>
        ID d'incident d'origine de détection d'incident New Relic.
      </td>
    </tr>

    <tr>
      <td>
        `labels.originalAccountIds`
      </td>

      <td>
        Identifiants de compte d'étiquettes
      </td>

      <td>
        ID de compte de la politique de détection d’incident.
      </td>
    </tr>

    <tr>
      <td>
        `labels.policyIds`
      </td>

      <td>
        Étiquettes règle d'alerte ID
      </td>

      <td>
        ID de politique de détection d'incident ayant généré l'incident.
      </td>
    </tr>

    <tr>
      <td>
        `abels.targetId`
      </td>

      <td>
        ID cible
      </td>

      <td>
        ID cible.
      </td>
    </tr>

    <tr>
      <td>
        `mutingState`
      </td>

      <td>
        Problème d'état de mise en sourdine
      </td>

      <td>
        L'état de mise en sourdine calculé du problème (`MUTED`, `NOT_MUTED`).
      </td>
    </tr>

    <tr>
      <td>
        `nrAccountId`
      </td>

      <td>
        ID de compte
      </td>

      <td>
        ID de compte.
      </td>
    </tr>

    <tr>
      <td>
        `openIncidentsCount`
      </td>

      <td>
        Nombre d'incidents ouverts
      </td>

      <td>
        Le nombre total d'incidents ouverts sur ce problème.
      </td>
    </tr>

    <tr>
      <td>
        `owner`
      </td>

      <td>
        Propriétaire
      </td>

      <td>
        La personne qui a reconnu le problème.
      </td>
    </tr>

    <tr>
      <td>
        `policyUrl`
      </td>

      <td>
        URL de la règle d'alerte
      </td>

      <td>
        règle d'alerte URL.
      </td>
    </tr>

    <tr>
      <td>
        `priority`
      </td>

      <td>
        Priorité des questions
      </td>

      <td>
        Niveau de priorité du problème (`CRITICAL`, `HIGH`, `MEDIUM`, `LOW`).
      </td>
    </tr>

    <tr>
      <td>
        `priorityText`
      </td>

      <td>
        Texte prioritaire de la publication
      </td>

      <td>
        Émettez la priorité en minuscules (`Critical`, `High`, `Medium`, `Low`).
      </td>
    </tr>

    <tr>
      <td>
        `realIssueCount`
      </td>

      <td>
        Nombre de problèmes
      </td>

      <td>
        Nombre de problèmes.
      </td>
    </tr>

    <tr>
      <td>
        `state`
      </td>

      <td>
        État d'émission
      </td>

      <td>
        État du cycle de vie du problème (`CREATED`, `ACTIVATED`, `CLOSED`).
      </td>
    </tr>

    <tr>
      <td>
        `stateText`
      </td>

      <td>
        Texte sur l'état de l'émission
      </td>

      <td>
        État du cycle de vie du problème en minuscules (`active` (ouvert), `closed`).
      </td>
    </tr>

    <tr>
      <td>
        `status`
      </td>

      <td>
        Statut de corrélation des problèmes
      </td>

      <td>
        L'état de corrélation du problème.
      </td>
    </tr>

    <tr>
      <td>
        `totalIncidents`
      </td>

      <td>
        nombre d'incidents
      </td>

      <td>
        Le nombre d'incidents qui sont agrégés ou corrélés dans le problème.
      </td>
    </tr>

    <tr>
      <td>
        `triggeredAt`
      </td>

      <td>
        Problème déclenché à
      </td>

      <td>
        Horaire de déclenchement notification du problème.
      </td>
    </tr>

    <tr>
      <td>
        `triggerEvent`
      </td>

      <td>
        Événement déclencheur notification de problème
      </td>

      <td>
        L'événement déclencheur de notification (`STATE_CHANGE`, `INCIDENT_ADDED`, `INCIDENT_CLOSED`, `CLOSE_INACTIVE`, `CLOSE_TTL`, `USER_ACTION`, `PRIORITY_CHANGED`, `MERGE_REQUEST`).
      </td>
    </tr>

    <tr>
      <td>
        `updatedAt`
      </td>

      <td>
        Numéro mis à jour à
      </td>

      <td>
        Horaire d'émission mis à jour pour la dernière fois.
      </td>
    </tr>

    <tr>
      <td>
        `violationChartUrl`
      </td>

      <td>
        URL du tableau des incidents
      </td>

      <td>
        Lien vers l'image du tableau incident .
      </td>
    </tr>

    <tr>
      <td>
        `workflowName`
      </td>

      <td>
        nom du flux de travail
      </td>

      <td>
        Le nom du workflow qui a été déclenché.
      </td>
    </tr>
  </tbody>
</table>

## Exemples d'enrichissement des données de workflow [#enrichment-examples]

Pour obtenir des informations sur l'entité qui a enfreint une condition, vous pouvez utiliser des variables personnalisées dans le cadre de l'instruction `WHERE` de la requête. Par exemple, pour obtenir l&amp;apos;état de l&amp;apos;instanceEC2, utilisez :

```sql
SELECT latest(ec2State) FROM ComputeSample WHERE provider = 'Ec2Instance' AND entityName IN {{entitiesData.names}}
```

Cette requête renvoie une valeur unique (par exemple, `stopped`), car la requête n&amp;apos;utilise qu&amp;apos;un seul champ. La variable `entitiesData.names` est une liste d&amp;apos;identifiant pour l&amp;apos;entité. Vous pouvez utiliser n’importe quelle autre propriété d’entité de la même manière.

Vous pouvez utiliser des variables personnalisées pour enrichir votre requête de données workflow de différentes manières :

<CollapserGroup>
  <Collapser id="application-drop" title="requête pour savoir quand le trafic application diminue">
    Il y a des moments où vous souhaitez savoir quand le trafic vers votre application diminue. Vous pouvez utiliser la variable `{{entitiesData.names}}` à la place du nom de votre application.

    ```sql
    SELECT count(*) FROM Transaction WHERE appName IN {{entitiesData.names}} SINCE 10 minutes ago
    ```
  </Collapser>

  <Collapser id="non-web-transactions-time" title="transaction en temps non Web">
    Temps moyen consacré par l'entité impactée au traitement requests/transactions, réparti par type de processus

    ```sql
    SELECT average(apm.service.overview.other) * 1000 FROM Metric WHERE appName IN {{entitiesData.names}} FACET `segmentName` TIMESERIES
    ```
  </Collapser>

  <Collapser id="throughput" title="débit">
    Nombre de requests par minute traitées par les entités impactées

    ```sql
    SELECT rate(count(apm.service.transaction.duration), 1 minute) AS 'Non-web throughput' FROM Metric WHERE (appName IN {{entitiesData.names}}) AND (transactionType = 'Other') TIMESERIES
    ```
  </Collapser>

  <Collapser id="error-rate" title="taux d'erreur">
    Ratio des erreurs par rapport au nombre total de requests traitées par l'entité impactée

    ```sql
    SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) AS 'Non-web errors' FROM Metric WHERE (appName IN {{entitiesData.names}}) AND (transactionType = 'Other') TIMESERIES
    ```
  </Collapser>

  <Collapser id="transaction-failures" title="requête pour les échecs de transaction">
    Il y a des moments où vous souhaitez savoir quand vos transactions d'application ont échoué. Cette requête affiche les dernières réponses de code d'état HTTP filtrées par la variable `{{entitiesData.names}}` qui ont dépassé votre seuil de règle d&amp;apos;alerte.

    ```sql
    SELECT latest(http.statusCode), average(duration) FROM Transaction WHERE appName IN {{entitiesData.names}}
    ```
  </Collapser>

  <Collapser id="kubernetes-consumption" title="requête pour aperçu de la consommation Kubernetes">
    Utilisez une requête comme celle-ci pour obtenir le nombre d’entités et leurs temps d’ingestion dans un Kubernetes pod. En identifiant les entités qui ont des temps d’ingestion importants, vous pouvez commencer à résoudre ce problème et trouver une solution potentielle.

    ```sql
    SELECT uniqueCount(displayName), sum(nr.ingestTimeMs) FROM K8sServiceSample WHERE entityName IN {{entitiesData.names}} SINCE 1 hour ago
    ```
  </Collapser>

  <Collapser id="tags-from-facet" title="requête utilisant la valeur de facette déclenchante">
    Si la condition d'alerte de la requête est à facettes, vous pouvez utiliser la valeur `FACET` déclenchant l&amp;apos;incident dans une requête. Par exemple, si la condition d’alerte est la suivante :

    ```sql
    SELECT average(duration) FROM BrowserInteraction FACET appName
    ```

    Vous pouvez ensuite effectuer une requête en utilisant le `appName` spécifique comme ceci :

    ```sql
    SELECT uniques(host) FROM Transaction WHERE appName IN {{accumulations.tag.appName}}
    ```
  </Collapser>
</CollapserGroup>