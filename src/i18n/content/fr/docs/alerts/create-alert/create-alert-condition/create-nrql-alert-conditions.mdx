---
title: Créer une condition d'alerte NRQL
tags:
  - Alerts
  - Alert conditions
metaDescription: How to define thresholds that trigger alert notifications based on your NRQL queries.
freshnessValidatedDate: '2024-08-01T00:00:00.000Z'
translationType: machine
---

Nous vous recommandons de créer une alerte à l&apos;aide d&apos;une condition d&apos;alerte NRQL . Ce document vous guidera dans le formatage et la configuration de votre condition d&apos;alerte NRQL pour maximiser l&apos;efficacité et réduire le bruit. Si vous venez de commencer avec New Relic, ou si vous n&apos;avez pas encore créé de condition d&apos;alerte, nous vous recommandons de commencer par [la condition d&apos;alerte](/docs/alerts/create-alert/create-alert-condition/alert-conditions/).

Vous pouvez créer une condition d&apos;alerte à partir de :

* [Un graphique](/docs/tutorial-create-alerts/create-an-alert/)
* [Une page de politique](https://one.newrelic.com/nr1-core/condition-builder/policy-entity)
* [La page <DNT>**Alert coverage gaps**</DNT>](https://one.newrelic.com/alerts-ai/detection-gaps/)

Vous pouvez également utiliser l&apos;un de nos générateurs d&apos;alertes :

* Utilisez <DNT>**Write your own query**</DNT> pour créer des alertes à partir de zéro.
* <DNT>Use **Guided mode**</DNT>pour choisir parmi les options recommandées et faire créer votre requête NRQL pour vous.

Peu importe où vous commencez à créer une condition d&apos;alerte, que ce soit via un graphique ou en écrivant votre propre requête, NRQL est la pierre angulaire sur laquelle vous pouvez définir votre signal et définir votre seuil.

## Syntaxe d&apos;alerte NRQL [#syntax]

Voici la syntaxe de base pour créer toutes les conditions d&apos;alerte NRQL .

```sql
SELECT function(attribute)
FROM Event
WHERE attribute [comparison] [AND|OR ...]
```

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        <DNT>
          **Clause**
        </DNT>
      </th>

      <th>
        <DNT>
          **Notes**
        </DNT>
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `SELECT function(attribute)`

        <DNT>
          **Required**
        </DNT>
      </td>

      <td>
        [Les fonctions](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#functions) prises en charge qui renvoient des nombres incluent :

        * `apdex`

        * `average`

        * `count`

        * `latest`

        * `max`

        * `min`

        * `percentage`

        * `percentile`

        * `sum`

        * `uniqueCount`

          <Callout variant="tip">
            Si vous utilisez l&apos;agrégateur `percentile` dans une condition d&amp;apos;alerte à facettes avec plusieurs facettes, cela peut provoquer cette erreur :

            `An error occurred while fetching chart data.`

            Si vous voyez cette erreur, utilisez `average` à la place.
          </Callout>
      </td>
    </tr>

    <tr>
      <td>
        `FROM data type`

        <DNT>
          **Required**
        </DNT>
      </td>

      <td>
        Plusieurs [types de données](/docs/data-apis/understand-data/new-relic-data-types/) peuvent être ciblés.

        Types de données pris en charge :

        * Événements
        * `Metric` (Les points de données BRUTES seront renvoyés)
      </td>
    </tr>

    <tr>
      <td>
        `WHERE attribute [comparison] [AND|OR ...]`
      </td>

      <td>
        Utilisez la clause `WHERE` pour spécifier une série d’une ou plusieurs conditions. Tous les [opérateurs](/docs/insights/new-relic-insights/using-new-relic-query-language/nrql-reference#where-operators) sont pris en charge. Il est utilisé pour filtrer les données renvoyées dans la requête.
      </td>
    </tr>

    <tr>
      <td id="facet">
        `FACET` attribut
      </td>

      <td>
        Incluez une clause `FACET` facultative dans votre syntaxe NRQL en fonction du [type de seuil](#threshold-types) (statique ou anomalie).

        Utilisez la clause [`FACET`](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-facet) pour séparer vos résultats par attribut et alerter sur chaque attribut indépendamment. Aucune clause `LIMIT` n&amp;apos;est autorisée, mais toutes les requêtes recevront le nombre maximum de facettes possible.

        La requête à facettes peut renvoyer un maximum de 5000 valeurs pour les conditions [statiques et d&apos;anomalie](#threshold-types) .

        <Callout variant="important">
          Si la requête renvoie plus que le nombre maximum de valeurs, la condition d&apos;alerte ne peut pas être créée. Si vous créez la condition et que la requête renvoie plus que ce nombre plus tard, l&apos;alerte échouera. Modifiez votre requête afin qu’elle renvoie un nombre réduit de valeurs.
        </Callout>
      </td>
    </tr>
  </tbody>
</table>

## Reformatage NRQL incompatible [#reformatting]

Certains éléments de NRQL utilisés dans les graphiques n&apos;ont pas de sens dans le contexte des alertes en streaming. Voici une liste des éléments incompatibles les plus courants et des suggestions pour reformater une requête d&apos;alerte NRQL afin d&apos;obtenir le même effet.

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        <DNT>
          **Element**
        </DNT>
      </th>

      <th>
        <DNT>
          **Notes**
        </DNT>
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `SINCE` et `UNTIL`
      </td>

      <td>
        Exemple:

        ```sql
        SELECT percentile(largestContentfulPaint, 75)
        FROM PageViewTiming
        WHERE (appId = 837807) SINCE yesterday
        ```

        Les conditions NRQL produisent un flux sans fin de résultats de requête fenêtrés, de sorte que les mots-clés `SINCE` et `UNTIL` permettant de limiter la requête à un point dans le temps ne sont pas compatibles. Pour plus de commodité, nous supprimons automatiquement `SINCE` et `UNTIL` d&amp;apos;une requête lors de la création d&amp;apos;une condition à partir du contexte d&amp;apos;un graphique.
      </td>
    </tr>

    <tr>
      <td>
        `TIMESERIES`
      </td>

      <td>
        Dans une requête NRQL , la clause `TIMESERIES` est utilisée pour renvoyer des données sous forme de série chronologique répartie sur une période donnée.

        Pour les conditions NRQL et si l&apos;agrégation de fenêtre glissante n&apos;est pas utilisée, la propriété équivalente à `TIMESERIES` est la durée de la fenêtre d&amp;apos;agrégation de données. Si vous utilisez l’agrégation de fenêtre glissante, la propriété équivalente est la valeur de l’agrégation de fenêtre glissante.
      </td>
    </tr>

    <tr>
      <td>
        `histogram()`
      </td>

      <td>
        La fonction d&apos;agrégation `histogram()` est utilisée pour générer un histogramme.

        `histogram()` n&amp;apos;est pas compatible avec les alertes NRQL : les agrégations d&amp;apos;histogrammes ne peuvent pas être formatées sous forme de séries chronologiques. Pour créer une alerte à partir d&amp;apos;une partie d&amp;apos;un histogramme (par exemple, le 95e percentile), utilisez la fonction d&amp;apos;agrégation [`percentile()`](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#func-percentile) .
      </td>
    </tr>

    <tr>
      <td>
        `bytecountestimate()`, `cardinality()`
      </td>

      <td>
        Ces fonctions ne sont pas encore prises en charge pour les alertes NRQL.
      </td>
    </tr>

    <tr>
      <td>
        Fonctions d&apos;agrégation multiples
      </td>

      <td>
        Chaque condition ne peut cibler qu&apos;une seule valeur agrégée. Pour alerter sur plusieurs valeurs simultanément, vous devrez les décomposer en conditions individuelles au sein de la même politique.

        Requête originale :

        ```sql
        SELECT count(foo), average(bar), max(baz)
        FROM Transaction
        ```

        Décomposé:

        ```sql
        SELECT count(foo) FROM Transaction

        SELECT average(bar) FROM Transaction

        SELECT max(baz) FROM Transaction
        ```
      </td>
    </tr>

    <tr>
      <td>
        `COMPARE WITH`
      </td>

      <td>
        La clause `COMPARE WITH` est utilisée pour comparer les valeurs de deux plages horaires différentes. Ce type de requête est incompatible avec les alertes NRQL. Nous recommandons d&amp;apos;utiliser une [condition d&apos;alerte d&apos;anomalie](/docs/alerts-applied-intelligence/applied-intelligence/anomaly-detection/custom-anomalies/) pour détecter dynamiquement l&amp;apos;écart d&amp;apos;un signal particulier.
      </td>
    </tr>

    <tr>
      <td>
        `SLIDE BY`
      </td>

      <td>
        La clause `SLIDE BY` prend en charge une fonctionnalité connue sous le nom de [fenêtres coulissantes](#sliding-window-aggregation). Avec les fenêtres coulissantes, `SLIDE BY` les données sont collectées dans des « fenêtres » de temps qui se chevauchent les unes avec les autres. Ces fenêtres peuvent aider à lisser les graphiques linéaires avec beaucoup de variations dans les cas où l&amp;apos;agrégat mobile (comme une moyenne mobile) est plus important que les agrégats provenant de fenêtres temporelles étroites.

        Vous pouvez activer les fenêtres coulissantes dans l&apos;UI. Lors de la création ou de la modification d&apos;une condition, accédez à <DNT>**Adjust to signal behavior &gt; Data aggregation settings &gt; Use sliding window aggregation**</DNT>.

        Par exemple pour créer une condition d’alerte équivalente à

        ```sql
        SELECT count(*)
        FROM Transaction
        TIMESERIES 1 minute SLIDE BY 5 minutes
        ```

        Vous utiliseriez une durée de fenêtre d’agrégation de données de 5 minutes, avec une agrégation de fenêtre glissante de 1 minute.
      </td>
    </tr>

    <tr>
      <td>
        `LIMIT`
      </td>

      <td>
        Dans la requête NRQL , la clause `LIMIT` est utilisée pour contrôler la quantité de données renvoyées par une requête, soit le nombre maximal de valeurs de facettes renvoyées par la requête `FACET`, soit le nombre maximal d&amp;apos;éléments renvoyés par la requête `SELECT *`.

        `LIMIT` n&amp;apos;est pas compatible avec les alertes NRQL : l&amp;apos;évaluation est toujours effectuée sur l&amp;apos;ensemble des résultats.
      </td>
    </tr>

    <tr>
      <td>
        Subqueries
      </td>

      <td>
        [Les sous-requêtes](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql) ne sont pas compatibles avec le streaming <InlinePopover type="alerts" />car l&amp;apos;exécution des sous-requêtes nécessite plusieurs passages dans les données.
      </td>
    </tr>

    <tr>
      <td>
        Jointures de sous-requête
      </td>

      <td>
        [Les jointures de sous-requête](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/subquery-joins) ne sont pas compatibles avec les alertes en streaming, car l&amp;apos;exécution de sous-requête nécessite plusieurs passages dans les données.
      </td>
    </tr>
  </tbody>
</table>

## Exemples de seuil d&apos;alerte NRQL [#examples]

Voici quelques cas d’utilisation courants pour les conditions NRQL. Ces requêtes fonctionneront pour [les types de conditions](#threshold-types) statiques et d&amp;apos;anomalie.

<CollapserGroup>
  <Collapser id="constrained-alerts" title="alerte sur des segments spécifiques de vos données">
    Créez des alertes restreintes qui ciblent un segment spécifique de vos données, comme quelques clients clés ou une plage de données. Utilisez la clause `WHERE` pour définir ces conditions.

    ```sql
    SELECT average(duration)
    FROM Transaction
    WHERE account_id IN (91290, 102021, 20230)
    ```

    ```sql
    SELECT percentile(duration, 95)
    FROM Transaction
    WHERE name LIKE 'Controller/checkout/%'
    ```
  </Collapser>

  <Collapser id="nth-percentile" title="alerte sur le Nième percentile de vos données">
    Créez des alertes lorsqu&apos;un Nième percentile de vos données atteint un seuil spécifié ; par exemple, pour maintenir le niveau de service SLA . Étant donné que nous évaluons la requête NRQL en fonction de la durée de la fenêtre d’agrégation, le centile sera calculé pour chaque durée séparément.

    ```sql
    SELECT percentile(duration, 95)
    FROM Transaction
    ```

    ```sql
    SELECT percentile(databaseDuration, 75)
    FROM Transaction
    ```
  </Collapser>

  <Collapser id="max-min-avg" title="alerte sur max, min, moy de vos données">
    Créez des alertes lorsque vos données atteignent un certain maximum, minimum ou moyenne ; par exemple, en veillant à ce qu&apos;une durée ou un temps de réponse ne dépasse pas un certain seuil.

    ```sql
    SELECT max(duration)
    FROM Transaction
    ```

    ```sql
    SELECT min(duration)
    FROM Transaction
    ```

    ```sql
    SELECT average(duration)
    FROM Transaction
    ```
  </Collapser>

  <Collapser id="percentage" title="alerte sur un pourcentage de vos données">
    Créez des alertes lorsqu&apos;une proportion de vos données dépasse ou descend en dessous d&apos;un certain seuil.

    ```sql
    SELECT percentage(count(*), WHERE duration > 2)
    FROM Transaction
    ```

    ```sql
    SELECT percentage(count(*), WHERE http.statusCode = '500')
    FROM Transaction
    ```
  </Collapser>

  <Collapser id="apdex" title="alerte sur Apdex avec n'importe quelle valeur T">
    Créez des alertes sur [Apdex](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction), en appliquant votre propre valeur T pour certaines transactions. Par exemple, recevez une notification d&amp;apos;alerte lorsque votre Apdex pour une valeur T de 500 ms sur les transactions pour les applications de production passe en dessous de 0,8.

    ```sql
    SELECT apdex(duration, t:0.5)
    FROM Transaction
    WHERE appName LIKE '%prod%'
    ```
  </Collapser>
</CollapserGroup>

## Conditions NRQL et ordre des opérations de requête [#query-order]

Par défaut, la durée de la fenêtre d&apos;agrégation est de 1 minute, mais vous pouvez modifier la fenêtre en fonction de vos besoins. Quelle que soit la fenêtre d&apos;agrégation, New Relic collectera les données pour cette fenêtre à l&apos;aide de la fonction dans la requête de la condition NRQL. La requête est analysée et exécutée par notre système dans l&apos;ordre suivant :

1. `FROM` clause. Quel type d’événement doit être saisi ?
2. `WHERE` clause. Que peut-on filtrer ?
3. `SELECT` clause. Quelles informations doivent être renvoyées à partir de l’ensemble de données désormais filtré ?

### Exemple : valeur nulle renvoyée [#example-null]

Disons que c&apos;est votre requête de condition d&apos;alerte :

```sql
SELECT count(*)
FROM SyntheticCheck
WHERE monitorName = 'My Cool Monitor' AND result = 'FAILED'
```

S&apos;il n&apos;y a aucun échec pour la fenêtre d&apos;agrégation :

1. Le système exécutera la clause `FROM` en récupérant tous les `SyntheticCheck` événements sur votre compte.
2. Ensuite, il exécutera la clause `WHERE` pour filtrer ces événements en recherchant uniquement ceux qui correspondent au nom du moniteur et au résultat spécifié.
3. S&apos;il reste des événements à analyser après avoir terminé les opérations `FROM` et `WHERE` , la clause `SELECT` sera exécutée. S&amp;apos;il n&amp;apos;y a aucun événement restant, la clause `SELECT` ne sera pas exécutée.

Cela signifie que les agrégateurs comme `count()` et `uniqueCount()` ne renverront jamais une valeur nulle. Lorsqu&amp;apos;il y a un compte de 0, la clause `SELECT` est ignorée et aucune donnée n&amp;apos;est renvoyée, ce qui donne une valeur de `NULL`.

### Exemple : valeur zéro renvoyée [#example-zero]

Si vous disposez d&apos;une source de données fournissant des zéros numériques légitimes, la requête renverra des valeurs zéro et non des valeurs nulles.

Disons qu’il s’agit de votre requête de condition d’alerte et que `MyCoolEvent` est un attribut qui peut parfois renvoyer une valeur zéro.

```sql
SELECT average(MyCoolAttribute)
FROM MyCoolEvent
```

Si, dans la fenêtre d&apos;agrégation en cours d&apos;évaluation, il existe au moins une instance de `MyCoolEvent` et si la valeur moyenne de tous les attributs `MyCoolAttribute` de cette fenêtre est égale à zéro, alors une valeur `0` sera renvoyée. S&amp;apos;il n&amp;apos;y a aucun événement `MyCoolEvent` pendant cette minute, un `NULL` sera renvoyé en raison de l&amp;apos;ordre des opérations.

### Exemple : valeur nulle ou valeur zéro renvoyée [#example-null-zero]

Pour déterminer comment les valeurs nulles seront gérées, ajustez les paramètres de perte de signal et de remplissage d&apos;espace dans l&apos;[UI de condition d&apos;alerte](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/#signal-loss).

Vous pouvez éviter complètement les valeurs `NULL` avec un raccourci d&amp;apos;ordre d&amp;apos;opérations de requête. Pour ce faire, utilisez une sous-clause `filter` , puis incluez tous les éléments de filtre dans cette sous-clause. Le corps principal de la requête doit inclure une clause `WHERE` qui définit au moins une entité afin que, pour toute fenêtre d&amp;apos;agrégation où le moniteur effectue une vérification, le signal soit lié à cette entité. La clause `SELECT` s&amp;apos;exécutera ensuite et appliquera les éléments de filtre aux données renvoyées par le corps principal de la requête, ce qui renverra une valeur de `0` si les éléments de filtre ne génèrent aucune donnée correspondante.

Voici un exemple pour alerter sur `FAILED` résultats :

```sql
SELECT filter(count(*), WHERE result = 'FAILED')
FROM SyntheticCheck
WHERE monitorName = 'My Favorite Monitor'
```

Dans cet exemple, une fenêtre avec un résultat réussi renverrait un `0`, permettant au seuil de la condition de se résoudre de lui-même.

Pour plus d&apos;informations, consultez notre [article de blog](https://discuss.newrelic.com/t/relic-solution-how-can-i-figure-out-when-to-use-gap-filling-and-loss-of-signal/120401) sur le dépannage des valeurs zéro et nulles.

## Alertes NRQL d&apos;agrégation imbriquée [#h2-nested-aggregation-nrql-alerts]

[Les requêtes d&apos;agrégation imbriquées](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query) sont un moyen puissant d&amp;apos;interroger vos données. Cependant, ils comportent quelques restrictions qu’il est important de noter.

<CollapserGroup>
  <Collapser id="non-faceted_innermost_query" title="Les requêtes imbriquées avec une requête interne non facettée ne sont actuellement pas prises en charge">
    Sans `FACET`, la requête interne produit un seul résultat, ne donnant rien à agréger à la requête externe. Si vous utilisez une requête imbriquée, assurez-vous que votre requête interne est à facettes.

    ```sql
    SELECT max(cpu)
    FROM
      (
        SELECT min(cpuPercent) AS 'cpu'
        FROM SystemSample
        FACET hostname
      )
    ```
  </Collapser>

  <Collapser id="aggregation_window_size" title="la requête à tous les niveaux doit avoir la même taille de fenêtre d'agrégation">
    Avec une fenêtre d&apos;agrégation d&apos;alertes d&apos;une minute, la requête interne produirait deux fenêtres plus petites de 30 secondes. En théorie, ces deux fenêtres pourraient être agrégées par la requête externe. Cependant, cela n&apos;est actuellement pas pris en charge.

    ```sql
    SELECT max(cpu)
    FROM
      (
        SELECT min(cpuTime) AS cpu TIMESERIES 30 seconds
        FROM Event
      )
    ```
  </Collapser>

  <Collapser id="signal_loss" title="La perte de signal n'est pas encore prise en charge pour les requêtes imbriquées">
    Pour plus d&apos;informations sur la perte de signal, consultez [API NerdGraph : Perte de signal et remplissage d&apos;espace](/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-loss-signal-gap-filling).
  </Collapser>

  <Collapser id="with_metric_format" title="Les requêtes imbriquées sur les données d'intervalle de temps métrique ne sont actuellement pas prises en charge">
    La requête imbriquée pour [l&apos;intervalle de temps métrique](/docs/data-apis/understand-data/new-relic-data-types/#timeslice-data) n&amp;apos;est pas prise en charge. Plus précisément, ces termes ne sont pas autorisés dans la requête interne de la condition d&amp;apos;alerte NRQL :

    * `WITH METRIC_FORMAT`
    * `metricTimesliceName`
    * `keyset`, `uniques`, `nativesizeestimate`, ou `bytecountestimate` appelé sur le type `Metric`
    * `newrelic.timeslice.value`
    * `apm.service.*`, `apm.browser.*` , `apm.mobile.*`, `apm.key.transaction.*`
  </Collapser>
</CollapserGroup>

## Conseils de création de conditions NRQL [#condition-tips]

Voici quelques conseils pour créer et utiliser une condition NRQL :

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        Sujet
      </th>

      <th>
        Conseils
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        Types de conditions
      </td>

      <td>
        Les types de conditions NRQL incluent [les conditions statiques et anormales](#threshold-types).
      </td>
    </tr>

    <tr>
      <td>
        Créer une description
      </td>

      <td>
        Pour les conditions NRQL, vous pouvez créer une [description](/docs/alerts/new-relic-alerts/defining-conditions/alert-condition-descriptions) personnalisée à ajouter à chaque incident. Les descriptions peuvent être améliorées avec une substitution de variables basée sur les métadonnées de l&amp;apos;incident spécifique.
      </td>
    </tr>

    <tr>
      <td>
        Résultats de la requête
      </td>

      <td>
        la requête doit renvoyer un nombre. La condition évalue le nombre renvoyé par rapport au seuil que vous avez défini.
      </td>
    </tr>

    <tr>
      <td>
        Période de temps
      </td>

      <td>
        Les conditions NRQL évaluent les données en fonction de la manière dont elles sont agrégées, en utilisant des fenêtres d&apos;agrégation de 30 secondes à 120 minutes, par incréments de 15 secondes. Pour de meilleurs résultats, nous vous recommandons d&apos;utiliser les méthodes d&apos;agrégation de flux d&apos;événements ou de minuterie d&apos;événements.

        Pour la méthode d&apos;agrégation de cadence, la clause implicite `SINCE ... UNTIL` spécifiant la minute à évaluer est contrôlée par votre paramètre [de délai/minuterie](#delay-timer) . Étant donné que les données très récentes peuvent être incomplètes, vous souhaiterez peut-être interroger les données datant d&amp;apos;il y a 3 minutes ou plus, en particulier pour :

        * application qui s&apos;exécute sur plusieurs hôtes.
        * `SyntheticCheck` données : les délais d&amp;apos;attente peuvent prendre 3 minutes, donc 5 minutes ou plus sont recommandés.

        De plus, si une requête génère des données intermittentes, envisagez d’utiliser l’option de signal avancé [`slide by`](#sliding-window-aggregation) .
      </td>
    </tr>

    <tr>
      <td>
        Seuil de détection de perte de signal
      </td>

      <td>
        Vous pouvez utiliser la détection de perte de signal pour alerter sur le moment où vos données (un signal de télémétrie) doivent être considérées comme perdues. Une perte de signal peut indiquer qu&apos;un service ou une entité n&apos;est plus en ligne ou qu&apos;une tâche périodique n&apos;a pas pu être exécutée. Vous pouvez également l&apos;utiliser pour vous assurer que les incidents liés aux données sporadiques, telles que le nombre d&apos;erreurs, sont fermés lorsqu&apos;aucun signal n&apos;arrive.
      </td>
    </tr>

    <tr>
      <td>
        Paramètres avancés du signal
      </td>

      <td>
        Ces paramètres vous offrent des options pour mieux gérer les signaux de données en continu qui peuvent parfois manquer. Ces paramètres incluent la durée de la fenêtre d&apos;agrégation, le délai/minuterie et une option permettant de combler les lacunes de données. Pour en savoir plus sur leur utilisation, consultez [Paramètres de signal avancés](#advanced-signal).
      </td>
    </tr>

    <tr>
      <td>
        Paramètres des conditions
      </td>

      <td>
        Utilisez le <DNT>**Condition settings**</DNT> pour :

        * Créez un [nom de condition](/docs/alerts/create-alert/create-alert-condition/alert-conditions/#name-your-condition) concis et descriptif.
        * Fournissez une description incident personnalisée pour la condition sur la page <DNT>**Add details**</DNT> qui sera incluse dans l&amp;apos;incident et la notification.
        * Ajoutez l&apos;URL runbook pour inclure les procédures de votre organisation pour la gestion des incidents. Vous pouvez également ajouter ces informations à la description de l’incident personnalisé.
      </td>
    </tr>

    <tr>
      <td>
        Limites des conditions
      </td>

      <td>
        Voir les [valeurs maximales](/docs/alerts/new-relic-alerts/getting-started/minimum-maximum-values).
      </td>
    </tr>

    <tr>
      <td>
        état de santé
      </td>

      <td>
        Pour qu&apos;un NRQL affichage condition d&apos;alerte [état de santé](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/view-entity-health-status-find-entities-without-alert-conditions) fonctionne correctement, la requête doit être limitée à une seule entité. Pour ce faire, utilisez soit une clause `WHERE` (par exemple, `WHERE appName = 'MyFavoriteApp'`), soit une clause `FACET` pour limiter chaque signal à une seule entité (par exemple, `FACET hostname` ou `FACET appName`).
      </td>
    </tr>

    <tr>
      <td>
        Exemples
      </td>

      <td>
        Pour plus d&apos;informations, voir :

        * [Syntaxe NRQL attendue](#syntax)
        * [Exemples de requête de condition NRQL](#examples)
      </td>
    </tr>
  </tbody>
</table>

## Gestion des balises sur les conditions [#condition-edit]

Lorsque vous modifiez une condition NRQL existante, vous avez la possibilité d&apos;ajouter ou de supprimer une balise associée à l&apos;entité de condition. Pour ce faire, cliquez sur le bouton <DNT>**Manage tags**</DNT> sous le nom de la condition. Dans le menu qui apparaît, ajoutez ou supprimez une tag.

## Les modifications de condition peuvent réinitialiser l&apos;évaluation de la condition [#evaluation-resets]

Lorsque vous modifiez la condition d&apos;alerte NRQL de certaines manières spécifiques (détaillées ci-dessous), leurs évaluations sont réinitialisées, ce qui signifie que toute évaluation jusqu&apos;à ce point est perdue et l&apos;évaluation recommence à partir de ce point. Les deux façons dont cela vous affectera sont :

* Pour le seuil « pendant au moins x minutes » : la fenêtre d&apos;évaluation ayant été réinitialisée, il y aura un délai d&apos;au moins x minutes avant qu&apos;un incident puisse être signalé.
* Pour [les conditions d&apos;anomalie](/docs/alerts-applied-intelligence/applied-intelligence/anomaly-detection/custom-anomalies/): la condition recommence et tout apprentissage d&amp;apos;anomalie est perdu.

Les actions suivantes entraînent une réinitialisation de l&apos;évaluation des conditions NRQL :

* Modification de la requête
* Modification de la fenêtre d&apos;agrégation, de la méthode d&apos;agrégation ou du paramètre de délai/minuterie d&apos;agrégation
* Modification du paramètre « Fermer l&apos;incident en cas de perte de signal »
* Modification des paramètres de remplissage des espaces
* Modification de la direction de l&apos;anomalie (le cas échéant) - plus haut, plus bas ou plus haut/plus bas
* Modifier la valeur de seuil, la fenêtre de seuil ou l&apos;opérateur de seuil
* Modifier l&apos;intervalle de défilement (uniquement sur les conditions [d&apos;agrégation des fenêtres glissantes](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/#sliding-window-aggregation) )

Les actions suivantes (ainsi que toutes les autres actions non couvertes dans la liste ci-dessus) ne réinitialiseront **pas** l&amp;apos;évaluation :

* Modification de la fenêtre temporelle de perte de signal (durée d&apos;expiration)
* Modification de la fonction de temps (passage de « pendant au moins » à « au moins une fois dans » ou vice-versa)
* Activation/désactivation du paramètre « Ouvrir un incident en cas de perte de signal »

## types de conditions d&apos;alerte [#threshold-types]

Lorsque vous créez une alerte NRQL, vous pouvez choisir parmi différents types de conditions :

<table>
  <thead>
    <tr>
      <th style={{ width: "150px" }}>
        Types de conditions d&apos;alerte NRQL
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        Statique
      </td>

      <td>
        Il s’agit du type de condition NRQL le plus simple. Il vous permet de créer une condition basée sur une requête NRQL qui renvoie une valeur numérique.

        Facultatif : inclure une clause `FACET` .
      </td>
    </tr>

    <tr>
      <td>
        [anomalie](/docs/alerts-applied-intelligence/applied-intelligence/anomaly-detection/custom-anomalies/) (anomalie dynamique)
      </td>

      <td>
        Utilise une condition d’auto-ajustement basée sur le comportement passé des valeurs du moniteur. Utilise le même formulaire de requête NRQL que le type statique, y compris la clause `FACET` facultative.
      </td>
    </tr>
  </tbody>
</table>

## Définir le seuil de perte de signal [#signal-loss]

<Callout variant="important">
  La perte de fonctionnalité du signal nécessite qu&apos;un signal soit présent avant de pouvoir détecter que le signal est perdu. Si vous activez une condition alors qu&apos;un signal n&apos;est pas présent, aucune perte de signal ne sera détectée et la fonctionnalité de perte de signal ne s&apos;activera pas.
</Callout>

La perte de signal se produit lorsqu&apos;aucune donnée ne correspond à la condition NRQL sur une période de temps spécifique. Vous pouvez définir la durée de votre seuil de perte de signal ainsi que ce qui se passe lorsque le seuil est dépassé.

<img width="80%" title="signal loss options" alt="screenshot of signal loss options" src="/images/queriesnrqlSignalLossOptions.webp" />

<figcaption>
  Allez à <DNT>**[one.newrelic.com &gt; All capabilities](https://one.newrelic.com/all-capabilities) &amp;gt; Alerts &amp;gt; Alert conditions (Policies)**</DNT>, puis <DNT>**+ New alert condition**</DNT>. La perte de signal n&amp;apos;est disponible que pour les conditions NRQL.
</figcaption>

Vous pouvez également gérer ces paramètres à l&apos;aide de l&apos;API GraphQL (recommandé) ou de l&apos;API REST. Cliquez ici pour [des exemples spécifiques d&apos;API GraphQL](/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-loss-signal-gap-filling).

<DNT>
  **Loss of signal settings:**
</DNT>

Les paramètres de perte de signal incluent une durée et quelques actions.

* <DNT>
    **Signal loss expiration time**
  </DNT>

  * Étiquette UI : <DNT>**Signal is lost after:**</DNT>
  * Nœud GraphQL : [expiration.expirationDuration](/docs/apis/nerdgraph/examples/nerdgraph-api-loss-signal-gap-filling/#loss-of-signal)
  * La durée d’expiration est un minuteur qui démarre et se réinitialise lorsque nous recevons un point de données dans le pipeline d’alertes en streaming. Si nous ne recevons pas un autre point de données avant l’expiration de votre « délai d’expiration », nous considérons que ce signal est perdu. Cela peut être dû au fait qu&apos;aucune donnée n&apos;est envoyée à New Relic ou que la clause `WHERE` de votre requête NRQL filtre ces données avant qu&amp;apos;elles ne soient transmises au pipeline d&amp;apos;alertes. Notez que lorsque vous avez une requête à facettes, chaque facette est un signal. Ainsi, si l’un de ces signaux se termine pendant la durée spécifiée, cela sera considéré comme une perte de signal.
  * La perte du temps d&apos;expiration du signal est indépendante de la durée du seuil et se déclenche dès que le temporisateur expire.
  * La durée d&apos;expiration maximale est de 48 heures. Cela est utile lors de monitoring de l’exécution de tâches peu fréquentes. Le minimum est de 30 secondes, mais nous recommandons d&apos;utiliser au moins 3 à 5 minutes.

* <DNT>
    **Loss of signal actions**
  </DNT>

  Une fois qu&apos;un signal est considéré comme perdu, vous avez plusieurs options :

  * Fermer tous les incidents ouverts en cours : cela ferme tous les incidents ouverts liés à un signal spécifique. Cela ne fermera pas nécessairement tous les incidents pour une condition. Si vous alertez sur un service éphémère ou sur un signal sporadique, vous souhaiterez choisir cette action pour garantir que les incidents soient correctement clôturés. Le nom du nœud GraphQL pour ceci est [`closeViolationsOnExpiration`](/docs/apis/nerdgraph/examples/nerdgraph-api-loss-signal-gap-filling/#loss-of-signal).
  * Ouvrir un nouvel incident : cela ouvrira un nouvel incident lorsque le signal sera considéré comme perdu. Ces incidents indiqueront qu&apos;ils sont dus à une perte de signal. En fonction de vos préférences d’incident, cela devrait déclencher une notification. Le nom du nœud graphQL pour ceci est [`openViolationOnExpiration`](/docs/apis/nerdgraph/examples/nerdgraph-api-loss-signal-gap-filling/#loss-of-signal).
  * Lorsque vous activez les deux actions ci-dessus, nous fermerons d&apos;abord tous les incidents ouverts, puis ouvrirons un nouvel incident pour perte de signal.
  * N&apos;ouvrez pas l&apos;incident « signal perdu » à la fin prévue. Lorsqu&apos;un signal est censé se terminer, vous pouvez choisir de ne pas ouvrir un nouvel incident. Ceci est utile lorsque vous savez qu&apos;un signal sera perdu à un certain moment et que vous ne souhaitez pas ouvrir un nouvel incident pour cette perte de signal. Le nom du nœud GraphQL pour ceci est [`ignoreOnExpectedTermination`](/docs/apis/nerdgraph/examples/nerdgraph-api-loss-signal-gap-filling/#loss-of-signal).

<Callout variant="important">
  Pour éviter qu&apos;un incident de perte de signal ne s&apos;ouvre lorsque <DNT>**Do not open &quot;lost signal&quot; incident on expected termination**</DNT>, vous devez ajouter la tag `termination: expected` à l&amp;apos;entité. Cette tag nous indique que nous nous attendions à ce que le signal se termine. Découvrez [comment ajouter la tag directement à l&apos;entité](/docs/new-relic-solutions/new-relic-one/core-concepts/use-tags-help-organize-find-your-data/#add-tags). Notez que la tag `hostStatus: shutdown` empêchera également l&amp;apos;ouverture d&amp;apos;un incident de « perte de signal ». Pour plus d&amp;apos;informations, voir [Créer une condition « hôte ne signalant pas »](/docs/infrastructure/infrastructure-alerts/create-infrastructure-host-not-reporting-condition/#create-condition).
</Callout>

Pour créer une alerte NRQL configurée avec détection de perte de signal dans l&apos;UI:

1. Suivez les [instructions pour créer une condition d’alerte NRQL](/docs/alerts/create-alert/create-alert-condition/alert-conditions/#set-your-signal-behavior).
2. À l’ [étape<DNT>Set thresholds</DNT> ,](/docs/alerts/create-alert/create-alert-condition/alert-conditions/#thresholds) vous trouverez l’option <DNT>Add lost signal threshold</DNT>. Cliquez sur ce bouton.
3. Définissez la durée d’expiration du signal en minutes ou en secondes dans le champ <DNT>**Consider the signal lost after**</DNT> .
4. Choisissez ce que vous voulez qu&apos;il se passe lorsque le signal est perdu. Vous pouvez cocher une ou toutes les options suivantes : <DNT>**Close all current open incidents**</DNT>, <DNT>**Open new &quot;lost signal&quot; incident**</DNT>, <DNT>**Do not open &quot;lost signal&quot; incident on expected termination**</DNT>. Ils contrôlent la manière dont l&amp;apos;incident de perte de signal sera traité pour la condition.
5. Vous pouvez éventuellement ajouter ou supprimer un seuil numérique statique/anomalie. Une condition qui n&apos;a qu&apos;un seuil de perte de signal et aucun seuil numérique statique/anomalie est valide et est considérée comme une condition de perte de signal « autonome ».

<Callout variant="caution">
  Lors de la création d&apos;une condition de perte de signal autonome, tenez compte de la requête utilisée. L&apos;utilisation de requêtes complexes peut coûter plus cher que ce qui est nécessaire pour monitorer un signal.
</Callout>

6. Continuez à suivre les étapes pour sauvegarder votre état.
7. Si vous avez sélectionné <DNT>**Do not open &quot;lost signal&quot; incident on expected termination**</DNT>, vous devez ajouter la tag `termination: expected` à l&amp;apos;entité pour empêcher l&amp;apos;ouverture d&amp;apos;un incident de perte de signal. Découvrez [comment ajouter la tag directement à l&apos;entité](/docs/new-relic-solutions/new-relic-one/core-concepts/use-tags-help-organize-find-your-data/#add-tags).

<Callout variant="tip">
  Vous vous demandez peut-être pourquoi vous voudriez avoir à la fois <DNT>**Open new &quot;lost signal&quot; incident**</DNT> et <DNT>**Do not open &quot;lost signal&quot; incident on expected termination**</DNT> définis sur vrai. Pensez-y comme ceci : vous souhaitez recevoir une notification lorsque vous perdez un signal. Sauf que vous ne voulez pas recevoir de notification la seule fois où vous savez que le signal s&amp;apos;arrêtera parce que vous l&amp;apos;avez programmé. Dans ce cas, vous définiriez les deux sur vrai, et lorsque vous vous attendez à ce que le signal soit perdu, vous ajouteriez la tag `termination: expected` à l&amp;apos;entité concernée.
</Callout>

incident ouvert en raison d&apos;une perte de signal fermé lorsque :

* le signal revient. Un incident de perte de signal nouvellement ouvert sera fermé immédiatement lorsque de nouvelles données seront évaluées.
* l&apos;état auquel ils appartiennent expire. Par défaut, les conditions expirent après 3 jours.
* vous fermez manuellement l&apos;incident avec l&apos;option <DNT>**Close all current open incidents**</DNT> .

<Callout variant="tip">
  La détection de perte de signal ne fonctionne pas sur les requêtes NRQL qui utilisent une agrégation imbriquée ou une sous-requête.
</Callout>

## Paramètres avancés du signal [#advanced-signal]

<img width="80%" title="Screenshot showing advanced signal settings" alt="Screenshot showing advanced signal settings" src="/images/queries-nrql_screenshot-full_fine-tune-signals.webp" />

<figcaption>
  Lors de la création d&apos;une condition d&apos;alerte NRQL , utilisez les paramètres de signal avancés pour contrôler [les données d&apos;alerte en streaming](/docs/alerts-applied-intelligence/new-relic-alerts/get-started/streaming-alerts-key-terms-concepts) et éviter les fausses alarmes.
</figcaption>

Lors de la création d&apos;une condition NRQL, il existe plusieurs [paramètres de signal avancés](/docs/alerts-applied-intelligence/new-relic-alerts/get-started/your-first-nrql-condition/#advanced-signal-settings):

* Durée de la fenêtre d&apos;agrégation
* Agrégation de fenêtres coulissantes
* Méthode de diffusion en continu
* Retard/minuterie
* Combler les lacunes en matière de données
* Retard d&apos;évaluation

Pour lire une explication de ce que sont ces paramètres et de la manière dont ils sont liés les uns aux autres, consultez [Concepts des alertes en streaming](/docs/alerts-applied-intelligence/new-relic-alerts/get-started/streaming-alerts-key-terms-concepts). Vous trouverez ci-dessous des instructions et des conseils sur la façon de les configurer.

### Durée de la fenêtre d&apos;agrégation [#window-duration]

Vous pouvez définir la [durée de la fenêtre d&apos;agrégation](/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/streaming-alerts-key-terms-concepts/#window-duration) pour choisir la durée pendant laquelle les données sont accumulées dans une fenêtre de temps de streaming avant d&amp;apos;être agrégées. Vous pouvez le régler entre 30 secondes et 120 minutes. La valeur par défaut est d&amp;apos;une minute.

### Agrégation de fenêtres coulissantes [#sliding-window-aggregation]

Vous pouvez utiliser [des fenêtres coulissantes](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows) pour créer des graphiques plus fluides. Cela se fait en créant des fenêtres de données qui se chevauchent.

Apprenez à configurer des fenêtres coulissantes dans cette courte vidéo (2:30 minutes) :

<Video id="-5--8DZynFE" type="youtube" />

Une fois activé, définissez le « diaporama par intervalle » pour contrôler le temps de chevauchement de vos fenêtres agrégées. L&apos;intervalle doit être plus court que la fenêtre d&apos;agrégation tout en étant divisé uniformément dans celle-ci.

<Callout variant="important">
  Immédiatement après avoir créé une nouvelle condition d&apos;alerte de fenêtre glissante ou effectué une action pouvant entraîner une [réinitialisation de l&apos;évaluation](#evaluation-resets), votre condition aura besoin de temps pour constituer un « tampon agrégé » pendant la durée de la première fenêtre d&amp;apos;agrégation. Durant cette période, aucun incident ne se produira. Une fois cette fenêtre d&amp;apos;agrégation unique passée, un « tampon » complet aura été construit et la condition fonctionnera normalement.
</Callout>

### Méthode de diffusion en continu [#streaming]

Choisissez entre [trois méthodes d’agrégation de streaming](/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/streaming-alerts-key-terms-concepts/#aggregation-methods) pour obtenir les meilleurs résultats d’évaluation pour vos conditions.

### Retard/minuterie [#delay-timer]

Vous pouvez ajuster le [délai/la minuterie](/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/streaming-alerts-key-terms-concepts/#delay-timer) pour coordonner [notre algorithme d&apos;alerte en streaming](/docs/new-relic-solutions/get-started/glossary/#streaming-algorithm) avec le comportement de vos données. Si vos données sont rares ou incohérentes, vous pouvez utiliser la méthode d’agrégation du minuteur d’événement.

Pour la méthode de cadence, la latence totale prise en charge est la somme de la durée de la fenêtre d&apos;agrégation et du délai.

Si le type de données provient d&apos;un de [APM langage agent](/docs/apm/new-relic-apm/getting-started/introduction-apm) et est agrégé à partir de plusieurs instances d&amp;apos;application (par exemple,,, `Transaction` `TransactionError`etc.), nous vous recommandons d&amp;apos;utiliser la méthode de flux d&amp;apos;événement avec les paramètres par défaut.

<Callout variant="important">
  Lors de la création de conditions NRQL pour les données collectées à partir d&apos;[une intégration d&apos;infrastructure cloud](/docs/infrastructure/infrastructure-integrations/get-started/introduction-infrastructure-integrations/#cloud) telle AWS CloudWatch ou Azure, nous vous recommandons d&amp;apos;utiliser la méthode événement timer.
</Callout>

### Combler les lacunes en matière de données [#data-gaps]

Le remplissage des lacunes vous permet de personnaliser les valeurs à utiliser lorsque vos signaux ne contiennent aucune donnée. Vous pouvez combler les lacunes dans vos flux de données avec l’un de ces paramètres :

* <DNT>**None**</DNT>: (Par défaut) Choisissez cette option si vous ne souhaitez effectuer aucune action sur les fenêtres d&amp;apos;agrégation vides. Lors de l&amp;apos;évaluation, une fenêtre d&amp;apos;agrégation vide réinitialisera le minuteur de durée du seuil. Par exemple, si une condition indique que toutes les fenêtres d&amp;apos;agrégation doivent avoir des points de données au-dessus du seuil pendant 5 minutes et qu&amp;apos;une des 5 fenêtres d&amp;apos;agrégation est vide, alors la condition ne sera pas un incident.
* <DNT>**Custom static value**</DNT>: Choisissez cette option si vous souhaitez insérer une valeur statique personnalisée dans les fenêtres d’agrégation vides avant qu’elles ne soient évaluées. Cette option dispose d&amp;apos;un paramètre supplémentaire obligatoire de `fillValue` (comme nommé dans l&amp;apos;API) qui spécifie quelle valeur statique doit être utilisée. La valeur par défaut est `0`.
* <DNT>**Last known value**</DNT>:Cette option insère la dernière valeur vue avant que l&amp;apos;évaluation ne se produise. Nous maintenons l&amp;apos;état de la dernière valeur vue pendant un minimum de 2 heures. Si la durée du seuil configurée est supérieure à 2 heures, cette valeur est conservée pendant cette durée.

<Callout variant="tip">
  Le système d’alertes comble les lacunes dans les signaux signalés activement. Cet historique de signal est abandonné après une période d&apos;inactivité et, pour combler les lacunes, les points de données reçus après cette période d&apos;inactivité sont traités comme de nouveaux signaux. La durée d&apos;inactivité est soit de 2 heures, soit de la durée du seuil configuré, selon la durée la plus longue.

  Pour en savoir plus sur la perte de signal, le remplissage des espaces et comment demander l&apos;accès à ces fonctionnalités, consultez [cette publication du forum d&apos;assistance](https://discuss.newrelic.com/t/announcing-new-relic-one-streaming-alerts-for-nrql-conditions/115361).
</Callout>

Options de modification des paramètres d’écart de données :

* Dans l’ des NRQL conditions UI, accédez à <DNT>**Condition settings &gt; Advanced signal settings &gt; fill data gaps with**</DNT> et choisissez une option.
* Si vous utilisez notre [API Nerdgraph](/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-loss-signal-gap-filling) (préféré), ce nœud est situé à : `actor : account : alerts : nrqlCondition : signal : fillOption | fillValue`
* NerdGraph est notre recommandée API pour cela, mais si vous utilisez notre API REST, vous pouvez trouver ce paramètre dans API l&apos;explorateur REST sous la <DNT>**&quot;signal&quot;**</DNT> section de l&amp;apos;[des NRQL conditions d&apos;alerte .API](https://rpm.newrelic.com/api/explore/alerts_nrql_conditions/list)

### Retard d&apos;évaluation [#evaluation-delay]

Vous pouvez activer l&apos;indicateur `Use evaluation delay` et définir jusqu&amp;apos;à 120 minutes pour retarder l&amp;apos;évaluation des signaux entrants.

Lorsqu’une nouvelle entité est déployée pour la première fois, l’utilisation des ressources de l’entité est souvent inhabituellement élevée. Dans les environnements de mise à l&apos;échelle automatique, cela peut facilement créer de nombreuses fausses alertes. En retardant le démarrage de la détection des alertes sur les signaux émis par la nouvelle entité, vous pouvez réduire considérablement le nombre de fausses alarmes associées au déploiement dans des environnements orchestrés ou autoscale.

Options pour activer le délai d’évaluation :

* Dans l’ des NRQL conditions UI, accédez <DNT>**Adjust to signal behavior &gt; Use evaluation delay**</DNT> à.
* Si vous utilisez notre [API Nerdgraph](/docs/apis/nerdgraph/examples/nerdgraph-api-nrql-condition-alerts/#static-condition), ce nœud est situé à : `actor : account : alerts : nrqlCondition : signal : evaluationDelay`

## Conditions HNR NRQL en mode guidé [#hnr-nrql-guided]

Le mode guidé des conditions NRQL offre une expérience organisée pour [la création de conditions NRQL d&apos;infrastructure « hôte ne signalant pas » (HNR)](/docs/alerts/create-alert/create-alert-condition/create-nrql-host-not-reporting-conditions/). Il s&amp;apos;agit de l&amp;apos;alternative préférée à la création [de conditions d&apos;infrastructure « hôte sans rapport »](/docs/infrastructure/infrastructure-alerts/infrastructure-alert-conditions/create-infrastructure-host-not-reporting-condition/).