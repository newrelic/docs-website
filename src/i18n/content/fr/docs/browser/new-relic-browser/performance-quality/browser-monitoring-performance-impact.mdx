---
title: monitoring des navigateurs et impact sur les performances
tags:
  - Browser
  - Browser monitoring
  - Performance quality
metaDescription: The negligible amount of overhead required to load browser JavaScript into a webpage results in a significant return of actionable data.
freshnessValidatedDate: never
translationType: machine
---

Le snippet JavaScript de <InlinePopover type="browser" />introduit un impact presque invisible sur les performances du site Web et sur la perception par l&apos;utilisateur du temps nécessaire au chargement d&apos;une page. Le JavaScript est inclus dans un paquet de données de page Web qui est envoyé de toute façon. De plus, il commence immédiatement monitoring les erreurs et les événements pendant que le reste de la page Web s&apos;exécute. La quantité négligeable de surcharge requise pour charger le JavaScript génère un retour significatif de données exploitables.

## Impact global [#overall]

Le surcoût JavaScript prend en compte à la fois l&apos;impact sur l&apos;utilisateur et l&apos;impact sur les performances de votre système :

* <DNT>**User perception:**</DNT> En règle générale, l&apos;utilisateur ne peut pas détecter les dégradations de performances sur un site Web de moins de 200 ms. Le JavaScript du Browser ajoute moins de 15 ms au temps total de chargement de chaque page. Cela est réparti dans le temps, donc à aucun moment un utilisateur ne pourra percevoir un impact sur les performances dû au JavaScript.
* <DNT>**Webserver and systems:**</DNT> desBrowser applications se produit sur le navigateur de l&apos;utilisateur, et non sur le serveur.monitoring Le temps de traitement n&apos;a pas d&apos;impact sur votre consommation CPU.

De plus, nous prenons des mesures supplémentaires pour minimiser tout impact potentiel sur les applications et les pages Web monitorées. Par exemple, le script « loader » est chargé de manière synchrone dans le `<HEAD>` afin de garantir que monitoring est activée pendant tout le cycle de vie de la page. Ce script est inclus en ligne, ce qui élimine le besoin d&apos;une autre demande réseau aller-retour vers un [réseau de diffusion de contenu (CDN)](/docs/browser/new-relic-browser/performance-quality/security-new-relic-browser#cdn). Le « chargeur » est fourni avec le chargement initial de la page.

Plus tard dans le cycle de vie de la page, New Relic charge un script monitoring supplémentaire de manière asynchrone. Ces scripts ne devraient pas avoir d&apos;effet perceptible pour l&apos;utilisateur et sont inclus dans la surcharge globale de moins de 15 ms par page.

## Impact sur le réseau [#network]

monitoring des navigateurs minimise également le trafic réseau pour l&apos;utilisateur final en agrégeant les données localement (dans le client) et en les renvoyant à New Relic à intervalles réguliers et lors de l&apos;événement du cycle de vie de la page `load`, `unload`, `pageshow` et `pagehide`. (Pendant les périodes d&apos;inactivité de la session du navigateur, les transmissions peuvent ne pas être nécessaires.)

### script Browser d&apos;agent [#agent-scripts]

L&apos;agent se compose de plusieurs scripts pour réduire la taille initiale du « chargeur » et pour prendre en charge uniquement le chargement du JavaScript nécessaire pour prendre en charge les fonctionnalités de l&apos;agent qui sont activées. Le premier script, le « loader », est inséré en ligne dans le document HTML. Les scripts restants sont téléchargés à partir du réseau de diffusion de contenu (js-agent.newrelic.com) lorsque l&apos;événement du cycle de vie de la page `load` se produit. Le nombre de scripts chargés dépend du type d&apos;agent utilisé. Découvrez [ici les types d&apos;agents de navigateur](/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/#agent-types).

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        scénario
      </th>

      <th>
        Lite
      </th>

      <th>
        Pro
      </th>

      <th>
        Pro + SPA
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        Taille du script en ligne
      </td>

      <td>
        10,2 Ko
      </td>

      <td>
        15,5 Ko
      </td>

      <td>
        17,5 Ko
      </td>
    </tr>

    <tr>
      <td>
        Taille du script téléchargé
      </td>

      <td>
        15,3 Ko
      </td>

      <td>
        21 Ko
      </td>

      <td>
        25,4 Ko
      </td>
    </tr>
  </tbody>
</table>

<sup>
  Les tailles sont basées sur un script minifié utilisant la compression gzip.
</sup>

### Agent Browser récolte [#agent-harvests]

Browser events are first harvested after the PageView event is successfully collected, and then every 30 seconds thereafter. If any event type exceeds 16 kB of data before the next scheduled harvest, an early harvest is triggered for that event. Additionally, a final harvest occurs whenever the document transitions to `hidden` via a `visibilitychange` event (e.g. when a user navigates away, switches tabs, closes the tab, minimizes or closes the browser, or switches from the browser to another app if they&apos;re on a mobile device).

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        Type de données
      </th>

      <th>
        Lite
      </th>

      <th>
        Pro
      </th>

      <th>
        Pro + SPA
      </th>

      <th>
        Fréquence de récolte
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        [PageView](/attribute-dictionary/?event=PageView) événement
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td>
        `PageView` événement sont récoltés une fois immédiatement après l&apos;événement du cycle de vie de la page `load` . Ces données sont responsables de la génération des métriques de pages vues dans le UI New Browser dashboard Relic. Il s&apos;agit d&apos;un appel JSONP à `bam.nr-data.net` ou `bam-cell.nr-data.net`. Tous les agents doivent <DNT>**required**</DNT> collecter un événement `PageView` .
      </td>
    </tr>

    <tr>
      <td>
        Événement [PageViewTiming](/attribute-dictionary/?event=PageViewTiming)
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td>
        `PageViewTiming` events are harvested by all agents and includes timing data like core web vitals measurements. See the [PageViewTiming docs](/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/#interactivity-metrics) for a list of reported events.
      </td>
    </tr>

    <tr>
      <td>
        Métriques [d&apos;erreur JavaScript](/attribute-dictionary/?event=JavaScriptError)
      </td>

      <td>
        Non
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td>
        `JavaScriptError` metrics are sent together with Ajax metrics as timeslice data.
      </td>
    </tr>

    <tr>
      <td>
        Métriques Ajax
      </td>

      <td>
        Non
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td>
        Envoyé avec JavaScriptError métriques comme données d&apos;intervalle de temps.
      </td>
    </tr>

    <tr>
      <td>
        Événement [AjaxRequest](/attribute-dictionary/?event=AjaxRequest)
      </td>

      <td>
        Non
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td>
        `AjaxRequest` events follows the 30 seconds harvest cycle unless the `SPA` agent is in use. If using the `SPA` agent, the first harvest will happen after the `load` page lifecycle event and additional harvests will either happen every 30 seconds or when the `SPA` agent notices a route change.
      </td>
    </tr>

    <tr>
      <td>
        Trace de session
      </td>

      <td>
        Non
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td>
        Session traces can generate a large amount of data, but that can be controlled by sampling. By default, only about 90 page views per hour will be sampled to send session trace data. There is also an option to set a custom sampling rate.
      </td>
    </tr>

    <tr>
      <td>
        Session Replay
      </td>

      <td>
        Non
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td>
        In addition to the the general harvest cycles, session replay harvests that include snapshots and metadata payloads will be harvested immediately.

        Le point de terminaison peut différer selon les paramètres régionaux, mais un exemple pour les États-Unis serait `https://bam.nr-data.net/browser/blobs`.
      </td>
    </tr>

    <tr>
      <td>
        [PageAction](/attribute-dictionary/?event=PageAction) événement
      </td>

      <td>
        Non
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td />
    </tr>

    <tr>
      <td>
        [NavigateurInteraction](/attribute-dictionary/?event=BrowserInteraction) événement
      </td>

      <td>
        Non
      </td>

      <td>
        Non
      </td>

      <td>
        Oui
      </td>

      <td>
        `BrowserInteraction` events are harvested immediately after the interaction finishes. There will always be at least one interaction that represents the initial page load. Additional interactions are collected only if the URL changes (representing route change). `AjaxRequest` events are also harvested at the same time if they occur during an interaction.
      </td>
    </tr>

    <tr>
      <td>
        Browser logs
      </td>

      <td>
        Non
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td />
    </tr>

    <tr>
      <td>
        [UserAction](/attribute-dictionary/?event=UserAction) events
      </td>

      <td>
        Non
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td />
    </tr>

    <tr>
      <td>
        [BrowserPerformance](/attribute-dictionary/?event=BrowserPerformance) events
      </td>

      <td>
        Non
      </td>

      <td>
        Oui
      </td>

      <td>
        Oui
      </td>

      <td />
    </tr>
  </tbody>
</table>