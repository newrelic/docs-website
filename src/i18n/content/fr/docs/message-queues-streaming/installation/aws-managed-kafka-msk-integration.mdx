---
title: Intégration d'Amazon Managed Kafka (MSK)
tags:
  - Integrations
  - Amazon integrations
  - AWS integrations list
metaDescription: 'New Relic''s AWS Managed Streaming for Kafka (MSK) integration: what data it reports, and how to enable it.'
freshnessValidatedDate: never
translationType: machine
---

<Callout variant="important">
  Activez l&apos; [intégrationAWS CloudWatch Metric Streams ](/docs/infrastructure/amazon-integrations/aws-integrations-list/aws-metric-stream/)pour monitorer toutes les métriques CloudWatch de vos services AWS, y compris l&amp;apos;espace de nommage personnalisé. L’intégration individuelle n’est plus notre option recommandée.
</Callout>

New Relic propose une intégration pour collecter vos données [Amazon Web Services Managed Streaming pour Apache Kafka](https://aws.amazon.com/msk/) . Ce document explique comment activer cette intégration et décrit les données qui peuvent être signalées.

## Activer l&apos;intégration [#activate]

Pour activer cette intégration, suivez les procédures standard pour [connecter les services AWS à New Relic](/docs/infrastructure/infrastructure-integrations/getting-started/connect-aws-integrations-infrastructure).

## configuration et sondage [#polling]

Pour modifier la fréquence d&apos;interrogation et filtrer les données, utilisez [les options de configuration](/docs/integrations/new-relic-integrations/getting-started/configure-polling-frequency-data-collection-cloud-integrations).

Informations [d&apos;interrogation](/docs/infrastructure/amazon-integrations/aws-integrations-list/aws-polling-intervals-infrastructure-integrations) par défaut pour l&amp;apos;intégration d&amp;apos;Amazon Managed Kafka :

* Intervalle d&apos;interrogation de New Relic : 5 minutes
* Intervalle de données Amazon CloudWatch : 1 minute

## Afficher et utiliser les données [#find-data]

Pour afficher vos données d’intégration, accédez à <DNT>**[one.newrelic.com &gt; All capabilities](https://one.newrelic.com/all-capabilities) &amp;gt; Infrastructure &amp;gt; AWS**</DNT> et sélectionnez une intégration.

Vous pouvez [interroger et explorer vos données](/docs/using-new-relic/data/understand-data/query-new-relic-data) en utilisant le [type d&apos;événement](/docs/data-apis/understand-data/new-relic-data-types/#event-data) suivant :

<table>
  <thead>
    <tr>
      <th>
        entité
      </th>

      <th>
        Type d&apos;événement
      </th>

      <th>
        Fournisseur
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        Cluster
      </td>

      <td>
        `AwsMskClusterSample`
      </td>

      <td>
        `AwsMskCluster`
      </td>
    </tr>

    <tr>
      <td>
        Courtier
      </td>

      <td>
        `AwsMskBrokerSample`
      </td>

      <td>
        `AwsMskBroker`
      </td>
    </tr>

    <tr>
      <td>
        Sujet
      </td>

      <td>
        `AwsMskTopicSample`
      </td>

      <td>
        `AwsMskTopic`
      </td>
    </tr>
  </tbody>
</table>

Pour en savoir plus sur l’utilisation de vos données, consultez [Comprendre et utiliser les données d’intégration](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## données métriques [#metrics]

Cette intégration enregistre les données Amazon Managed Kafka pour cluster, le courtier et l&apos;entité de rubrique.

### Données Cluster Kafka gérées

<table>
  <thead>
    <tr>
      <th style={{ width: "275px" }}>
        métrique
      </th>

      <th style={{ width: "150px" }}>
        Unité
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `activeControllerCount`
      </td>

      <td>
        Compter
      </td>

      <td>
        Un seul contrôleur par cluster doit être actif à un moment donné.
      </td>
    </tr>

    <tr>
      <td>
        `globalPartitionCount`
      </td>

      <td>
        Compter
      </td>

      <td>
        Nombre total de partitions sur tous les courtiers du cluster.
      </td>
    </tr>

    <tr>
      <td>
        `globalTopicCount`
      </td>

      <td>
        Compter
      </td>

      <td>
        Nombre total de sujets sur tous les courtiers du cluster.
      </td>
    </tr>

    <tr>
      <td>
        `offlinePartitionsCount`
      </td>

      <td>
        Compter
      </td>

      <td>
        Nombre total de partitions hors ligne dans le cluster.
      </td>
    </tr>
  </tbody>
</table>

### Données gérées par Kafka Broker

<table>
  <thead>
    <tr>
      <th style={{ width: "275px" }}>
        métrique
      </th>

      <th style={{ width: "150px" }}>
        Unité
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `bytesInPerSec`
      </td>

      <td>
        Octets par seconde
      </td>

      <td>
        Le nombre d&apos;octets par seconde reçus des clients.
      </td>
    </tr>

    <tr>
      <td>
        `bytesOutPerSec`
      </td>

      <td>
        Octets par seconde
      </td>

      <td>
        Le nombre d&apos;octets par seconde envoyés aux clients.
      </td>
    </tr>

    <tr>
      <td>
        `cpuSystem`
      </td>

      <td>
        Pour cent
      </td>

      <td>
        Le pourcentage de CPU dans l&apos;espace noyau.
      </td>
    </tr>

    <tr>
      <td>
        `cpuUser`
      </td>

      <td>
        Pour cent
      </td>

      <td>
        Le pourcentage de CPU dans l&apos;espace utilisateur.
      </td>
    </tr>

    <tr>
      <td>
        `cpuIdle`
      </td>

      <td>
        Pour cent
      </td>

      <td>
        Le pourcentage de temps d&apos;inactivité du processeur.
      </td>
    </tr>

    <tr>
      <td>
        `fetchConsumerLocalTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes pendant lequel la demande du consommateur est traitée par le leader.
      </td>
    </tr>

    <tr>
      <td>
        `fetchConsumerRequestQueueTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes pendant lequel la demande du consommateur attend dans la file d&apos;attente des demandes.
      </td>
    </tr>

    <tr>
      <td>
        `fetchConsumerResponseQueueTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes pendant lequel la demande du consommateur attend dans la file d&apos;attente de réponse.
      </td>
    </tr>

    <tr>
      <td>
        `fetchConsumerResponseSendTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes nécessaire au consommateur pour envoyer une réponse.
      </td>
    </tr>

    <tr>
      <td>
        `fetchConsumerTotalTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps total moyen en millisecondes que le consommateur passe à récupérer des données auprès du courtier.
      </td>
    </tr>

    <tr>
      <td>
        `fetchFollowerLocalTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes pendant lequel la demande du suiveur est traitée par le leader.
      </td>
    </tr>

    <tr>
      <td>
        `fetchFollowerRequestQueueTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes pendant lequel la demande du suiveur attend dans la file d&apos;attente des demandes.
      </td>
    </tr>

    <tr>
      <td>
        `fetchFollowerResponseQueueTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes pendant lequel la demande du suiveur attend dans la file d&apos;attente de réponse.
      </td>
    </tr>

    <tr>
      <td>
        `fetchFollowerResponseSendTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes nécessaire à l&apos;abonné pour envoyer une réponse.
      </td>
    </tr>

    <tr>
      <td>
        `fetchFollowerTotalTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps total moyen en millisecondes que les abonnés passent à récupérer des données auprès du courtier.
      </td>
    </tr>

    <tr>
      <td>
        `fetchMessageConversionsPerSec`
      </td>

      <td>
        Compter par seconde
      </td>

      <td>
        Le nombre de conversions de messages de récupération par seconde pour le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `fetchThrottleTime`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen de limitation de la récupération en millisecondes.
      </td>
    </tr>

    <tr>
      <td>
        `fetchThrottleByteRate`
      </td>

      <td>
        Octets par seconde
      </td>

      <td>
        Le nombre d&apos;octets limités par seconde.
      </td>
    </tr>

    <tr>
      <td>
        `fetchThrottleQueueSize`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre de messages dans la file d&apos;attente.
      </td>
    </tr>

    <tr>
      <td>
        `kafkaAppLogsDiskUsed`
      </td>

      <td>
        Pour cent
      </td>

      <td>
        Le pourcentage d&apos;espace disque utilisé pour le log d&apos;application.
      </td>
    </tr>

    <tr>
      <td>
        `kafkaDataLogsDiskUsed`
      </td>

      <td>
        Pour cent
      </td>

      <td>
        Le pourcentage d&apos;espace disque utilisé pour le log de données.
      </td>
    </tr>

    <tr>
      <td>
        `leaderCount`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre de répliques du leader.
      </td>
    </tr>

    <tr>
      <td>
        `memoryBuffered`
      </td>

      <td>
        Octets
      </td>

      <td>
        La taille en octets de la mémoire tampon du courtier.
      </td>
    </tr>

    <tr>
      <td>
        `memoryCached`
      </td>

      <td>
        Octets
      </td>

      <td>
        La taille en octets de la mémoire cache pour le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `memoryFree`
      </td>

      <td>
        Octets
      </td>

      <td>
        La taille en octets de la mémoire libre et disponible pour le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `memoryUsed`
      </td>

      <td>
        Octets
      </td>

      <td>
        La taille en octets de la mémoire utilisée par le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `messagesInPerSec`
      </td>

      <td>
        Compter par seconde
      </td>

      <td>
        Le nombre de messages entrants par seconde pour le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `networkProcessorAvgIdlePercent`
      </td>

      <td>
        Pour cent
      </td>

      <td>
        Le pourcentage moyen de temps pendant lequel le processeur réseau est inactif.
      </td>
    </tr>

    <tr>
      <td>
        `networkRxDropped`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre de paquets reçus abandonnés.
      </td>
    </tr>

    <tr>
      <td>
        `networkRxErrors`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre d&apos;erreurs de réception du réseau pour le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `networkRxPackets`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre de paquets reçus par le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `networkTxDropped`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre de paquets de transmission abandonnés.
      </td>
    </tr>

    <tr>
      <td>
        `networkTxErrors`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre d&apos;erreurs de transmission réseau pour le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `networkTxPackets`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre de paquets transmis par le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `partitionCount`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre de partitions pour le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `produceLocalTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes nécessaire à l&apos;abonné pour envoyer une réponse.
      </td>
    </tr>

    <tr>
      <td>
        `produceMessageConversionsPerSec`
      </td>

      <td>
        Compter par seconde
      </td>

      <td>
        Le nombre de conversions de messages produits par seconde pour le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `produceMessageConversionsTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes consacré aux conversions de format de message.
      </td>
    </tr>

    <tr>
      <td>
        `produceRequestQueueTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes que les messages de demande passent dans la file d&apos;attente.
      </td>
    </tr>

    <tr>
      <td>
        `produceResponseQueueTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes que les messages de réponse passent dans la file d&apos;attente.
      </td>
    </tr>

    <tr>
      <td>
        `produceResponseSendTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen en millisecondes consacré à l&apos;envoi de messages de réponse.
      </td>
    </tr>

    <tr>
      <td>
        `produceTotalTimeMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen de production en millisecondes.
      </td>
    </tr>

    <tr>
      <td>
        `produceThrottleTime`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen de production en millisecondes.
      </td>
    </tr>

    <tr>
      <td>
        `produceThrottleByteRate`
      </td>

      <td>
        Octets par seconde
      </td>

      <td>
        Le nombre d&apos;octets limités par seconde.
      </td>
    </tr>

    <tr>
      <td>
        `produceThrottleQueueSize`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre de messages dans la file d&apos;attente.
      </td>
    </tr>

    <tr>
      <td>
        `requestBytesMean`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre moyen d&apos;octets de demande pour le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `requestExemptFromThrottleTime`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen passé dans le réseau du courtier et dans les threads d&apos;I/O pour traiter requests exemptées de limitation.
      </td>
    </tr>

    <tr>
      <td>
        `requestHandlerAvgIdlePercent`
      </td>

      <td>
        Pour cent
      </td>

      <td>
        Pourcentage moyen du temps pendant lequel les threads du gestionnaire de requêtes sont inactifs.
      </td>
    </tr>

    <tr>
      <td>
        `requestThrottleQueueSize`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre de messages dans la file d&apos;attente.
      </td>
    </tr>

    <tr>
      <td>
        `requestThrottleTime`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen de limitation des demandes en millisecondes.
      </td>
    </tr>

    <tr>
      <td>
        `requestTime`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Le temps moyen passé dans le réseau du courtier et les threads d&apos;I/O pour traiter requests.
      </td>
    </tr>

    <tr>
      <td>
        `rootDiskUsed`
      </td>

      <td>
        Pour cent
      </td>

      <td>
        Le pourcentage du disque racine utilisé par le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `swapUsed`
      </td>

      <td>
        Octets
      </td>

      <td>
        La taille en octets de la mémoire d&apos;échange utilisée par le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `swapFree`
      </td>

      <td>
        Octets
      </td>

      <td>
        La taille en octets de la mémoire d&apos;échange disponible pour le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `underMinIsrPartitionCount`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre de partitions sous minIsr pour le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `underReplicatedPartitions`
      </td>

      <td>
        Compter
      </td>

      <td>
        Le nombre de partitions sous-répliquées pour le courtier.
      </td>
    </tr>

    <tr>
      <td>
        `zooKeeperRequestLatencyMsMean`
      </td>

      <td>
        Millisecondes
      </td>

      <td>
        Latence moyenne en millisecondes pour requests ZooKeeper du courtier.
      </td>
    </tr>

    <tr>
      <td>
        `zooKeeperSessionState`
      </td>

      <td>
        Autre
      </td>

      <td>
        État de connexion de la session ZooKeeper du courtier qui peut être l&apos;un des suivants : NOT\_CONNECTED : « 0.0 », ASSOCIATING : « 0.1 », CONNECTING : « 0.5 », CONNECTEDREADONLY : « 0.8 », CONNECTED : « 1.0 », CLOSED : « 5.0 », AUTH\_FAILED : « 10.0 ».
      </td>
    </tr>
  </tbody>
</table>

### Données de sujet Kafka gérées

<table>
  <thead>
    <tr>
      <th style={{ width: "275px" }}>
        métrique
      </th>

      <th style={{ width: "150px" }}>
        Unité
      </th>

      <th>
        Description
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `bytesInPerSec`
      </td>

      <td>
        Octets par seconde
      </td>

      <td>
        Le nombre d&apos;octets reçus par seconde.
      </td>
    </tr>

    <tr>
      <td>
        `bytesOutPerSec`
      </td>

      <td>
        Octets par seconde
      </td>

      <td>
        Le nombre d&apos;octets envoyés par seconde.
      </td>
    </tr>

    <tr>
      <td>
        `fetchMessageConversionsPerSec`
      </td>

      <td>
        Compter par seconde
      </td>

      <td>
        Le nombre de messages récupérés convertis par seconde.
      </td>
    </tr>

    <tr>
      <td>
        `messagesInPerSec`
      </td>

      <td>
        Compter par seconde
      </td>

      <td>
        Le nombre de messages reçus par seconde.
      </td>
    </tr>

    <tr>
      <td>
        `produceMessageConversionsPerSec`
      </td>

      <td>
        Compter par seconde
      </td>

      <td>
        Le nombre de conversions par seconde pour les messages produits.
      </td>
    </tr>
  </tbody>
</table>

## Et ensuite ?

<DocTiles>
  <DocTile title="Data and UI" path="/docs/message-queues-streaming/ui-data/understand-ui">Découvrez comment utiliser New Relic pour monitorer votre cluster Kafka</DocTile>
</DocTiles>