---
title: configuration avancée pour monitoring du réseau
tags:
  - Integrations
  - Network monitoring
  - Advanced configuration
metaDescription: Advanced configuration options for network monitoring
freshnessValidatedDate: never
translationType: machine
---

Si vous souhaitez explorer toutes les options que vous pouvez utiliser lors de la configuration de la monitoring de votre réseau, consultez les sections suivantes.

## `snmp-base.yaml` [#snmp-base-yml-template]

Voici un exemple des différentes options de configuration disponibles dans le fichier `snmp-base.yaml` utilisé par l&apos;image Docker `ktranslate` pour interroger les périphériques de données SNMP et de flux. Vous pouvez également voir un exemple fortement commenté dans le [référentiel KTranslate sur GitHub](https://github.com/kentik/ktranslate/blob/main/config/snmp.yaml.sample).

```yaml
# Configuration of every device monitored by this container
devices:
  # Sample of SNMP v2c device
  ups_snmpv2c__10.10.0.201:
    device_name: ups_snmpv2c
    device_ip: 10.10.0.201
    snmp_comm: $YOUR_COMMUNITY_STRING
    oid: .1.3.6.1.4.1.318.1.3.27
    description: "APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: apc_ups.yml
    provider: kentik-ups
    poll_time_sec: 300
    retries: 1
    timeout_ms: 5000
    user_tags:
      owning_team: dc_ops
    discovered_mibs:
    - PowerNet-MIB_UPS
    - TCP-MIB
    - UDP-MIB
    purge_after_num: 1
  # Sample of SNMP v3 device
  router_snmpv3__10.10.0.202:
    device_name: router_snmpv3
    device_ip: 10.10.0.202
    snmp_v3:
      user_name: $YOUR_USER_NAME
      authentication_protocol: $YOUR_AUTH_PROTOCOL
      authentication_passphrase: $YOUR_AUTH_PASSPHRASE
      privacy_protocol: $YOUR_PRIVACY_PROTOCOL
      privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
    oid: .1.3.6.1.4.1.9.1.544
    description: "Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version
      15.1(3)T4, RELEASE SOFTWARE (fc1)\r\nTechnical Support: http://www.cisco.com/techsupport\r\nCopyright
      (c) 1986-2012 by Cisco Systems, Inc.\r\nCompiled Thu 24-May-12 04:27 by prod_rel_team"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: cisco-asr.yml
    provider: kentik-router
    user_tags:
      owning_team: core-networking
    discovered_mibs:
    - BGP4-MIB
    - CISCO-MEMORY-POOL-MIB
    - CISCO-PROCESS-MIB
    - IF-MIB
    - OSPF-MIB
    engine_id: "80:00:01:01:0a:14:1e:28"
    match_attributes:
      if_interface_name: "^Ten.*|^Gig.*"
      "!if_Alias": "[Uu]plink"
  # Sample of SNMP v1 device
  netbotz_snmpv1__10.10.0.203:
    device_name: netbotz_snmpv1
    device_ip: 10.10.0.201
    snmp_comm: $YOUR_COMMUNITY_STRING
    use_snmp_v1: true
    oid: .1.3.6.1.4.1.5528.100.20.10.2013
    description: "Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: apc-netbotz.yml
    provider: kentik-netbotz
    user_tags:
      owning_team: sys_ops
    discovered_mibs:
    - IF-MIB
    - IP-MIB
    - TCP-MIB
    - UDP-MIB
    no_use_bulkwalkall: true
  # Sample of "flow only" device
  flow_only__10.10.0.210:
    device_name: flow_only
    device_ip: 10.10.0.210
    user_tags:
      owning_team: net_eng
    flow_only: true
  # Sample of "ping only" device
  ping_only__10.10.0.220:
    device_name: ping_only
    device_ip: 10.10.0.220
    provider: kentik-ping
    user_tags:
      owning_team: load_balancing
    ping_only: true
    ping_interval_sec: 5
  # Sample of Arista eAPI device
  arista_eapi_10.10.0.230:
    device_name: arista_eapi
    device_ip: 10.10.0.230
    snmp_comm: public
    oid: .1.3.6.1.4.1.30065.1.3011.7020.3735.24.2878.2
    description: "Arista Networks EOS version 4.22.9M running on an Arista
      Networks DCS-7020SR-24C2"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: arista-switch.yml
    provider: kentik-switch
    discovered_mibs:
    - ARISTA-BGP4V2-MIB
    - ARISTA-QUEUE-MIB
    - BGP4-MIB
    - HOST-RESOURCES-MIB
    - IF-MIB
    ext:
      ext_only: false
      eapi_config:
        username: $YOUR_ARISTA_API_USERNAME
        password: $YOUR_ARISTA_API_PASSWORD
        transport: https
        port: 443
  # Sample of Meraki Dashboard API device
  meraki_dashboard_api:
    device_name: meraki_controller
    device_ip: snmp.meraki.com
    provider: meraki-cloud-controller
    ext:
      ext_only: true
      meraki_config:
        api_key: $YOUR_MERAKI_API_KEY
        monitor_devices: true
        monitor_org_changes: true
        monitor_uplinks: true
        monitor_vpn_status: true
        organizations:
          - "Top Org.*"
        networks:
          - "Production"
          - "Guest"
        product_types:
          - appliance
        preferences:
          device_status_only: true
          hide_uplink_usage: false
          show_vpn_peers: true
          show_network_attr: true
# Configuration for receipt of SNMP Traps
trap:
  listen: 0.0.0.0:1620
  community: public
  version: ""
  transport: ""
  v3_config: null
  trap_only: false
  drop_undefined: false
# Configuration for the SNMP discovery job
discovery:
  cidrs:
  - 10.0.0.0/24
  - 10.0.0.202/32
  ignore_list:
  - 10.0.0.98
  - 10.0.0.99
  debug: false
  ports:
  - 161
  - 1161
  default_communities:
  - $YOUR_COMMUNITY_STRING_1
  - $YOUR_COMMUNITY_STRING_2
  - $YOUR_COMMUNITY_STRING_3
  use_snmp_v1: false
  default_v3: null
  add_mibs: true
  threads: 4
  add_devices: true
  replace_devices: true
  no_dedup_engine_id: false
  check_all_ips: true
global:
  poll_time_sec: 60
  drop_if_outside_poll: false
  mib_profile_dir: /etc/ktranslate/profiles
  mibs_db: /etc/ktranslate/mibs.db
  mibs_enabled:
  - ARISTA-BGP4V2-MIB
  - ARISTA-QUEUE-MIB
  - BGP4-MIB
  - CISCO-MEMORY-POOL-MIB
  - CISCO-PROCESS-MIB
  - HOST-RESOURCES-MIB
  - IF-MIB
  - OSPF-MIB
  - PowerNet-MIB_UPS
  timeout_ms: 3000
  retries: 0
  global_v3: null
  response_time: false
  user_tags:
    environment: production
  match_attributes:
    if_Description: ".*WAN.*"
  purge_devices_after_num: 0
```

<CollapserGroup>
  <Collapser id="devices" title="Section Appareils">
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nom de la clé
          </th>

          <th>
            Requis
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            device\_name
          </td>

          <td>
            ✓
          </td>

          <td>
            Nom de l&apos;appareil. Il s&apos;agit de l&apos;identifiant unique de l&apos;appareil dans New Relic.
          </td>
        </tr>

        <tr>
          <td>
            device\_ip
          </td>

          <td>
            ✓
          </td>

          <td>
            IP cible de l&apos;appareil.
          </td>
        </tr>

        <tr>
          <td>
            snmp\_comm
          </td>

          <td>
            ✓ (Requis pour SNMPv1/2c)
          </td>

          <td>
            `SNMPv1/2c` chaîne communautaire à utiliser.
          </td>
        </tr>

        <tr>
          <td>
            use\_snmp\_v1
          </td>

          <td>
            ✓ (Requis pour SNMPv1)
          </td>

          <td>
            Indique s&apos;il faut utiliser SNMPv1. Par défaut, il est défini sur `false`.
          </td>
        </tr>

        <tr>
          <td>
            snmp\_v3
          </td>

          <td>
            ✓ (Requis pour SNMPv3)
          </td>

          <td>
            [Configuration SNMP v3](#snmpv3-config)
          </td>
        </tr>

        <tr>
          <td>
            debug
          </td>

          <td />

          <td>
            Indique s&apos;il faut activer le logging au niveau de débogage pendant l&apos;interrogation SNMP. Par défaut, il est défini sur `false`.
          </td>
        </tr>

        <tr>
          <td>
            port
          </td>

          <td />

          <td>
            Port vers lequel envoyer la requête SNMP. Par défaut, il est défini sur le port `161`.
          </td>
        </tr>

        <tr>
          <td>
            oïde
          </td>

          <td>
            ✓ (Requis pour l&apos;interrogation SNMP)
          </td>

          <td>
            Le `systemObjectID | sysObjectID | sysOID` découvert pour l&apos;appareil. Ceci est utilisé pour faire correspondre le périphérique à un profil SNMP connu et définir l&apos;attribut `provider` . Si aucune correspondance n&apos;est trouvée, cela définit le `provider` comme périphérique [par défaut de Kentik](/docs/network-performance-monitoring/troubleshooting/snmp-discovery-kentik-default) .
          </td>
        </tr>

        <tr>
          <td>
            description
          </td>

          <td />

          <td>
            Le `sysDescr` découvert de l&apos;appareil. Ce champ est informatif.
          </td>
        </tr>

        <tr>
          <td>
            last\_checked
          </td>

          <td />

          <td>
            Horodatage lorsque cet appareil a été découvert pour la dernière fois par l&apos;image Docker `ktranslate`. Ce champ est informatif.
          </td>
        </tr>

        <tr>
          <td>
            mib\_profile
          </td>

          <td>
            ✓ (Requis pour l&apos;interrogation SNMP)
          </td>

          <td>
            Fichier de profil SNMP associé à ce périphérique lors de l&apos;exécution de la découverte en fonction de son `sysOID`. <DNT>**If this starts with a bang (!) token, it will override the automatic matching from the `sysOID` and use a manual override.**</DNT> Ex : `"!cisco-asa.yml"` (les guillemets sont obligatoires).
          </td>
        </tr>

        <tr>
          <td>
            fournisseur
          </td>

          <td>
            ✓ (Requis pour New Relic)
          </td>

          <td>
            Valeur utilisée lors de la synthèse d&apos;entité pour New Relic. Ceci est automatiquement créé sur la base du `mib_profile` correspondant et doit correspondre à l&apos;une des règles du référentiel [de définitions d&apos;entité](https://github.com/search?q=repo%3Anewrelic/entity-definitions%20path%3Adefinition.yml&type=code) pour qu&apos;une entité soit créée. Si vous ajoutez manuellement des appareils, vous devrez veiller à ce que cette valeur soit valide.
          </td>
        </tr>

        <tr>
          <td>
            poll\_time\_sec
          </td>

          <td />

          <td>
            Indique la fréquence d&apos;interrogation SNMP en secondes. Ce paramètre est utilisé pour remplacer l&apos;attribut `global.poll_time_sec` .
          </td>
        </tr>

        <tr>
          <td>
            tentatives
          </td>

          <td />

          <td>
            Indique le nombre de tentatives de nouvelle interrogation des OID SNMP. Ce paramètre est utilisé pour remplacer l&apos;attribut `global.retries` .
          </td>
        </tr>

        <tr>
          <td>
            timeout\_ms
          </td>

          <td />

          <td>
            Indique le délai d&apos;expiration de l&apos;interrogation SNMP en millisecondes. Ce paramètre est utilisé pour remplacer l&apos;attribut `global.timeout_ms` .
          </td>
        </tr>

        <tr>
          <td>
            user\_tags
          </td>

          <td />

          <td>
            `key:value` attribut de paire pour donner plus de contexte à l&apos;appareil. la balise à ce niveau sera ajoutée à toute balise appliquée dans l&apos;attribut `global.user_tags` .
          </td>
        </tr>

        <tr>
          <td>
            discovered\_mibs
          </td>

          <td />

          <td>
            Liste des MIB extraits de `mib_profile` correspondants auxquels cet appareil peut répondre. Ce champ est informatif.
          </td>
        </tr>

        <tr>
          <td>
            engine\_id
          </td>

          <td />

          <td>
            L&apos;ID de moteur unique découvert pour l&apos;agent SNMP de cet appareil. Généralement trouvé lors de la découverte SNMP v3. Ce champ est informatif.
          </td>
        </tr>

        <tr>
          <td>
            match\_attributes
          </td>

          <td />

          <td>
            `attribute:regex` paires pour ajouter des métriques à la liste autorisée. Les paires à ce niveau seront ajoutées à toutes les paires appliquées dans l&apos;attribut `global.match_attributes` . Utilise la syntaxe [RE2](https://github.com/google/re2/wiki/Syntax) et possède un opérateur `OR` par défaut. Préfixez la clé avec `!` pour forcer les opérateurs `AND` .
          </td>
        </tr>

        <tr>
          <td>
            monitor\_admin\_shut
          </td>

          <td />

          <td>
            Indique s&apos;il faut monitorer les interfaces dans le statut `Administratively Shutdown` . Par défaut, il est défini sur `false`.
          </td>
        </tr>

        <tr>
          <td>
            no\_use\_bulkwalkall
          </td>

          <td />

          <td>
            Désactive l’action de demande SNMP `GETBULK` lorsque `true`. Par défaut, il est défini sur `false`.
          </td>
        </tr>

        <tr>
          <td>
            response\_time
          </td>

          <td />

          <td>
            Indique si l&apos;interrogation [du temps de réponse](#response_time-attribute) est activée pour ce périphérique. Par défaut, il est défini sur `false`.
          </td>
        </tr>

        <tr>
          <td>
            ping\_only
          </td>

          <td />

          <td>
            Désactive toutes les interrogations SNMP et active l&apos;interrogation [du temps de réponse](#response_time-attribute) pour ce périphérique lorsque `true`. Ce paramètre remplacera l&apos;attribut `global.response_time` . Par défaut, il est défini sur `false`. Vous devez vous assurer d’avoir inclus la ligne `provider: kentik_ping` pour chaque périphérique ping\_only.
          </td>
        </tr>

        <tr>
          <td>
            ping\_interval\_sec
          </td>

          <td />

          <td>
            Ce paramètre est utilisé pour remplacer le débit par défaut de 1 paquet/sec utilisé lors de l&apos;interrogation `ping_only` | `response_time` .
          </td>
        </tr>

        <tr>
          <td>
            flow\_only
          </td>

          <td />

          <td>
            Désactive toutes les interrogations SNMP lorsque `true`. Par défaut, il est défini sur `false`.
          </td>
        </tr>

        <tr>
          <td>
            purge\_after\_num
          </td>

          <td />

          <td>
            Supprime le périphérique du fichier de configuration après l&apos;échec de X tâches de découverte planifiées. <DNT>**This setting overrides the global `purge_devices_after_num` setting.**</DNT> Réglez ceci sur `-1` pour conserver l&apos;appareil pour toujours, ou sur n&apos;importe quel entier &gt;= `1` pour définir un seuil de purge. (Par défaut : `0`)
          </td>
        </tr>

        <tr>
          <td>
            poste
          </td>

          <td>
            ✓ (Requis pour l&apos;interrogation API)
          </td>

          <td>
            [Configuration de l&apos;interrogation API](#optional-api-polling-configurations)
          </td>
        </tr>

        <tr>
          <td>
            ext.ext\_only
          </td>

          <td />

          <td>
            Désactive toutes les interrogations SNMP pour cette configuration `device_name` . Par défaut : `false`.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="trap" title="Section piège">
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nom de la clé
          </th>

          <th>
            Requis
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            écouter
          </td>

          <td>
            ✓
          </td>

          <td>
            Port IP d&apos;écoute pour la réception des interruptions SNMP. Par défaut, il est défini sur `0.0.0.0:1620` et nous utilisons une redirection dans votre commande `docker run ...` pour rediriger l&apos;UDP 162 le plus courant sur l&apos;hôte vers l&apos;UDP 1620 dans le conteneur. La redirection est effectuée avec ce drapeau `-p 162:1620/udp`
          </td>
        </tr>

        <tr>
          <td>
            communauté
          </td>

          <td />

          <td>
            Chaîne de communauté SNMPv1/v2c pour la réception des interruptions SNMP. Par défaut, nous traitons toujours les pièges entrants même s&apos;ils ne correspondent pas à cette communauté.
          </td>
        </tr>

        <tr>
          <td>
            version
          </td>

          <td />

          <td>
            Version SNMP à utiliser. Les options sont `v1`, `v2c` et `v3`. Par défaut, il est défini sur `v2c`.
          </td>
        </tr>

        <tr>
          <td>
            transport
          </td>

          <td />

          <td>
            Protocole de transport SNMP à utiliser. Les options sont `TCP` et `UDP`. Par défaut, il est défini sur `UDP`
          </td>
        </tr>

        <tr>
          <td>
            v3\_config
          </td>

          <td />

          <td>
            [Configuration SNMP v3](#snmpv3-config) à utiliser. Utilisé uniquement si `version: v3`.
          </td>
        </tr>

        <tr>
          <td>
            trap\_only
          </td>

          <td />

          <td>
            La définition de cette valeur sur `true` empêchera le conteneur de tenter une interrogation SNMP ou ICMP, utilisée dans les cas où vous souhaitez un conteneur qui écoute uniquement les interruptions entrantes.
          </td>
        </tr>

        <tr>
          <td>
            drop\_undefined
          </td>

          <td />

          <td>
            La définition de cette valeur sur `true` empêchera le conteneur de transmettre les messages d&apos;interruption SNMP qui ne sont pas explicitement définis dans un profil SNMP existant. (Par défaut : `false`)
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="discovery" title="Rubrique Découverte">
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nom de la clé
          </th>

          <th>
            Requis
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            cidrs
          </td>

          <td>
            ✓
          </td>

          <td>
            éventail de plages d&apos;adresses IP cibles en [notation CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). Soyez attentif à la taille de ces plages pour [éviter un délai d&apos;attente](/docs/network-performance-monitoring/troubleshooting/snmp-discovery-no-devices).
          </td>
        </tr>

        <tr>
          <td>
            ignore\_list
          </td>

          <td />

          <td>
            éventail d&apos;adresses IP que vous souhaitez explicitement ignorer lors de toutes les tâches de découverte.
          </td>
        </tr>

        <tr>
          <td>
            debug
          </td>

          <td />

          <td>
            Indique s&apos;il faut activer le logging au niveau de débogage pendant la découverte. Par défaut, il est défini sur `false`
          </td>
        </tr>

        <tr>
          <td>
            ports
          </td>

          <td>
            ✓
          </td>

          <td>
            éventail de ports cibles à analyser lors de l&apos;interrogation SNMP.
          </td>
        </tr>

        <tr>
          <td>
            default\_communities
          </td>

          <td>
            ✓ (Requis pour SNMPv1/2c)
          </td>

          <td>
            éventail de chaînes de communauté SNMPv1/v2c à analyser pendant l&apos;interrogation SNMP. Cet éventail est évalué dans l&apos;ordre et la découverte accepte la première communauté passante.
          </td>
        </tr>

        <tr>
          <td>
            use\_snmp\_v1
          </td>

          <td>
            ✓ (Requis pour SNMPv1)
          </td>

          <td>
            Indique s&apos;il faut utiliser SNMPv1 lors de la découverte. Par défaut, il est défini sur `false`
          </td>
        </tr>

        <tr>
          <td>
            default\_v3
          </td>

          <td>
            ✓ (Requis pour SNMPv3)
          </td>

          <td>
            [Configuration SNMPv3](#snmpv3-config) unique à analyser pendant l&apos;interrogation SNMP.
          </td>
        </tr>

        <tr>
          <td>
            other\_v3s
          </td>

          <td>
            ✓ (Requis pour SNMPv3)
          </td>

          <td>
            Plusieurs [configurations SNMPv3](#snmpv3-config) à analyser pendant l&apos;interrogation SNMP. <DNT>**Use this option OR `default_v3`, not both**</DNT>
          </td>
        </tr>

        <tr>
          <td>
            add\_devices
          </td>

          <td>
            ✓
          </td>

          <td>
            Indique s&apos;il faut ajouter les périphériques découverts à la section `devices` du fichier `snmp-base.yaml` . Par défaut, il est défini sur `true`.
          </td>
        </tr>

        <tr>
          <td>
            add\_mibs
          </td>

          <td>
            ✓
          </td>

          <td>
            Indique s&apos;il faut ajouter les MIB découverts à la section `global.mibs_enabled` du fichier `snmp-base.yaml` . Par défaut, il est défini sur `true`.
          </td>
        </tr>

        <tr>
          <td>
            fils
          </td>

          <td>
            ✓
          </td>

          <td>
            Limite entière de threads à utiliser lors de la découverte. Il doit être inférieur au nombre de cœurs disponibles pour le conteneur. Par défaut, il est défini sur `4`.
          </td>
        </tr>

        <tr>
          <td>
            replace\_devices
          </td>

          <td>
            ✓
          </td>

          <td>
            Indique s&apos;il faut remplacer les périphériques découverts s&apos;ils existent déjà dans la section `devices` du fichier `snmp-base.yaml` . Par défaut, il est défini sur `true`.
          </td>
        </tr>

        <tr>
          <td>
            no\_dedup\_engine\_id
          </td>

          <td />

          <td>
            Lorsque défini sur `true`, désactive la déduplication des périphériques détectés s&apos;il semble qu&apos;il s&apos;agisse du même périphérique, en fonction de leur ID de moteur SNMP signalé. Par défaut, il est défini sur `false`
          </td>
        </tr>

        <tr>
          <td>
            check\_all\_ips
          </td>

          <td />

          <td>
            Lorsqu&apos;il est défini sur `true`, force la tâche de découverte à tenter une connectivité SNMP sur chaque adresse IP cible de l&apos;éventail `cidrs` , sans vérifier d&apos;abord la vivacité via l&apos;analyse du port TCP. Ce paramètre ralentit les tâches de découverte, mais peut aider à contourner les problèmes où la découverte échoue sur les périphériques qui ne sont pas répertoriés dans votre éventail `cidrs` avec des remplacements `/32` . Par défaut, il est défini sur `false`
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="global" title="Section mondiale">
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nom de la clé
          </th>

          <th>
            Requis
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            poll\_time\_sec
          </td>

          <td>
            ✓
          </td>

          <td>
            Temps en secondes pour interroger les appareils. Cela peut être remplacé par appareil à l&apos;aide de l&apos;attribut `devices.<deviceName>.poll_time_sec` . Par défaut, il est défini sur `60`.
          </td>
        </tr>

        <tr>
          <td>
            drop\_if\_outside\_poll
          </td>

          <td />

          <td>
            Indique s&apos;il faut supprimer toutes les valeurs de ce cycle si l&apos;interrogation prend plus de temps que la valeur définie dans `poll_time_sec`. Par défaut, il est défini sur `false`.
          </td>
        </tr>

        <tr>
          <td>
            mib\_profile\_dir
          </td>

          <td />

          <td>
            Répertoire pour trouver des profils MIB organisés. Ceux-ci sont automatiquement intégrés dans l&apos;image `ktranslate` à partir du référentiel [snmp-profiles](https://github.com/kentik/snmp-profiles) de Kentik et peuvent être remplacés lors de l&apos;exécution de Docker en créant un montage de volume de votre propre répertoire local de profils.
          </td>
        </tr>

        <tr>
          <td>
            mibs\_db
          </td>

          <td />

          <td />
        </tr>

        <tr>
          <td>
            mibs\_enabled
          </td>

          <td>
            ✓
          </td>

          <td>
            éventail de tous les MIB actifs que l&apos;image Docker `ktranslate` va interroger. Cette liste est générée automatiquement lors de la découverte si l&apos;attribut `discovery_add_mibs` est `true`. Les MIB non répertoriés ici ne seront interrogés sur aucun périphérique dans le fichier de configuration. Vous pouvez spécifier une table SNMP directement dans un fichier MIB en utilisant la syntaxe `MIB-NAME.tableName` . Ex : `HOST-RESOURCES-MIB.hrProcessorTable`.
          </td>
        </tr>

        <tr>
          <td>
            timeout\_ms
          </td>

          <td>
            ✓
          </td>

          <td>
            Délai d&apos;expiration de la requête SNMP en millisecondes. Cela peut être remplacé par appareil à l&apos;aide de l&apos;attribut `devices.<deviceName>.timeout_ms` . Par défaut, il est défini sur `3000`.
          </td>
        </tr>

        <tr>
          <td>
            tentatives
          </td>

          <td>
            ✓
          </td>

          <td>
            Nombre de tentatives de réexécution des interrogations SNMP ayant échoué. Cela peut être remplacé par appareil à l&apos;aide de l&apos;attribut `devices.<deviceName>.retries` . Par défaut, il est défini sur `0`.
          </td>
        </tr>

        <tr>
          <td>
            user\_tags
          </td>

          <td />

          <td>
            `key:value` attribut de paire pour donner plus de contexte à l&apos;appareil. La balise à ce niveau sera appliquée à tous les périphériques du fichier configuration .
          </td>
        </tr>

        <tr>
          <td>
            match\_attributes
          </td>

          <td />

          <td>
            `attribute:regex` paires pour ajouter des métriques à la liste autorisée. Les paires à ce niveau seront comparées à tous les périphériques du fichier de configuration. Utilise la syntaxe [RE2](https://github.com/google/re2/wiki/Syntax) et possède un opérateur `OR` par défaut. Préfixez la clé avec `!` pour forcer les opérateurs `AND` .
          </td>
        </tr>

        <tr>
          <td>
            response\_time
          </td>

          <td />

          <td>
            Indique si l&apos;interrogation [du temps de réponse](#response_time-attribute) est activée pour tous les périphériques du fichier de configuration. Par défaut, il est défini sur `false`.
          </td>
        </tr>

        <tr>
          <td>
            purge\_devices\_after\_num
          </td>

          <td />

          <td>
            Supprime les périphériques du fichier de configuration après l&apos;échec de X tâches de découverte planifiées. Définissez ceci sur `-1` pour conserver les appareils pour toujours, ou sur n&apos;importe quel entier &gt;= `1` pour définir un seuil de purge. Par défaut, il est défini sur `0`.
          </td>
        </tr>

        <tr>
          <td>
            [watch\_profile\_changes](#watch-profile-changes)
          </td>

          <td />

          <td>
            Configure un observateur pour [recharger les threads SNMP](#reload-snmp-threads) lors des modifications apportées aux profils dans le chemin `mib_profile_dir` . Par défaut, il est défini sur `false`.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## Les secrets des fournisseurs de cloud [#cloud-provider-secrets]

L&apos;agent monitoring réseau dispose d&apos;une prise en charge intégrée pour la récupération des clés d&apos;[AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/), [Azure Key Vault](https://learn.microsoft.com/en-us/azure/key-vault/general/) et [de GCP Secret Manager](https://cloud.google.com/secret-manager/docs).

<Callout variant="important">
  SNMPv1 et SNMPv2c ne prennent pas en charge l&apos;utilisation de secrets cloud car les protocoles eux-mêmes envoient leurs chaînes de communauté via du texte brut par défaut. Si vous êtes préoccupé par la sécurité de votre authentification SNMP, veuillez effectuer une mise à jour pour utiliser SNMPv3.
</Callout>

<Collapser id="cloud-secrets" title="Configuration des secrets du cloud">
  <Tabs>
    <TabsBar>
      <TabsBarItem id="aws-secrets-manager">
        Gestionnaire de secrets AWS
      </TabsBarItem>

      <TabsBarItem id="azure-key-vault">
        Coffre de clés Azure
      </TabsBarItem>

      <TabsBarItem id="gcp-secret-manager">
        Gestionnaire de secrets GCP
      </TabsBarItem>
    </TabsBar>

    <TabsPages>
      <TabsPageItem id="aws-secrets-manager">
        Pour utiliser AWS Secrets Manager, vous devez définir les trois [variables d’environnement](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html#envvars-list) suivantes et les fournir à Docker lors de l’exécution :

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                Nom
              </th>

              <th>
                Description
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `AWS_ACCESS_KEY_ID`
              </td>

              <td>
                Spécifie la clé d’accès AWS utilisée dans le cadre des informations d’identification pour authentifier l’utilisateur.
              </td>
            </tr>

            <tr>
              <td>
                `AWS_SECRET_ACCESS_KEY`
              </td>

              <td>
                Spécifie la clé secrète AWS utilisée dans le cadre des informations d’identification pour authentifier l’utilisateur.
              </td>
            </tr>

            <tr>
              <td>
                `AWS_REGION`
              </td>

              <td>
                Spécifie la région AWS à laquelle envoyer requests .
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \
        -e AWS_ACCESS_KEY_ID=$YOUR_AWS_ACCESS_KEY_ID \
        -e AWS_SECRET_ACCESS_KEY=$YOUR_AWS_SECRET_ACCESS_KEY \
        -e AWS_REGION=$YOUR_AWS_REGION \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>

      <TabsPageItem id="azure-key-vault">
        Pour utiliser Azure Key Vault, vous devez définir les cinq variables d’environnement suivantes et les fournir à Docker lors de l’exécution :

        <Callout variant="tip">
          Vous devez définir `KT_AZURE_KEY_VAULT_NAME` ou `KT_AZURE_KEY_VAULT_URL`, pas les deux. La valeur par défaut est d&apos;utiliser `KT_AZURE_KEY_VAULT_NAME` et l&apos;agent utilisera un modèle d&apos;URL commun : `https://$KT_AZURE_KEY_VAULT_NAME.vault.azure.net/`
        </Callout>

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                Nom
              </th>

              <th>
                Description
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `KT_AZURE_KEY_VAULT_NAME`
              </td>

              <td>
                Le nom du coffre-fort où le secret est stocké.
              </td>
            </tr>

            <tr>
              <td>
                `KT_AZURE_KEY_VAULT_URL`
              </td>

              <td>
                URL complète facultative pour l&apos;appel d&apos;API à la cible.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE\_CLIENT\_ID](https://learn.microsoft.com/en-us/entra/identity-platform/howto-create-service-principal-portal#sign-in-to-the-application)
              </td>

              <td>
                Parfois appelé `Application ID`, il s&apos;agit de l&apos;identifiant de votre principal de service utilisé pour accéder au secret.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE\_CLIENT\_SECRET](https://learn.microsoft.com/en-us/entra/identity-platform/howto-create-service-principal-portal#option-3-create-a-new-client-secret)
              </td>

              <td>
                Il s’agit du secret client (mot de passe) utilisé pour le principal du service lors de l’authentification. Notez que cet ID concerne le secret client <DNT>**value**</DNT> et non l&apos;ID du secret lui-même.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE\_SUBSCRIPTION\_ID](https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id#find-your-azure-subscription)
              </td>

              <td>
                Il s’agit du GUID à 32 chiffres associé à l’abonnement dans lequel votre secret est géré.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE\_TENANT\_ID](https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id#find-your-microsoft-entra-tenant)
              </td>

              <td>
                Parfois appelé `Directory ID`, il s’agit de l’identifiant du locataire dans Microsoft Entra où votre principe de service est stocké.
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -e KT_AZURE_KEY_VAULT_NAME=$YOUR_KEY_VAULT_NAME \
        #### Optional: Provide the full URL to target
        # -e KT_AZURE_KEY_VAULT_URL=$YOUR_KEY_VAULT_URL \
        -e AZURE_CLIENT_ID=$YOUR_CLIENT_ID \
        -e AZURE_CLIENT_SECRET=$YOUR_CLIENT_SECRET \
        -e AZURE_TENANT_ID=$YOUR_TENANT_ID \
        -e AZURE_SUBSCRIPTION_ID=$YOUR_SUBSCRIPTION_ID \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>

      <TabsPageItem id="gcp-secret-manager">
        Pour utiliser GCP Secret Manager, vous devez définir le montage de volume suivant pour un fichier JSON d&apos;informations d&apos;identification ainsi que deux variables d&apos;environnement et les fournir à Docker lors de l&apos;exécution :

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                Nom
              </th>

              <th>
                Description
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                [Clé de compte de service](https://cloud.google.com/iam/docs/keys-create-delete#creating)
              </td>

              <td>
                Spécifie le chemin d’accès au fichier local pour la clé de compte de service utilisée pour authentifier l’utilisateur. Ce fichier est monté en volume dans le conteneur Docker, puis référencé dans la variable d&apos;environnement `GOOGLE_APPLICATION_CREDENTIALS` .
              </td>
            </tr>

            <tr>
              <td>
                [GOOGLE\_APPLICATION\_CREDENTIALS](https://cloud.google.com/docs/authentication/provide-credentials-adc#local-key)
              </td>

              <td>
                Spécifie le chemin d&apos;accès au fichier dans le conteneur où vous avez mappé votre fichier de clé de compte de service.
              </td>
            </tr>

            <tr>
              <td>
                [GOOGLE\_CLOUD\_PROJECT](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
              </td>

              <td>
                Spécifie l&apos;ID de projet unique dans lequel le secret est stocké.
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -v $YOUR_LOCAL_SERVICE_ACCOUNT_KEY_FILE_PATH:/gcp_snmp_sa_key.json \
        -e GOOGLE_APPLICATION_CREDENTIALS='./gcp_snmp_sa_key.json' \
        -e GOOGLE_CLOUD_PROJECT=$YOUR_PROJECT_ID \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>
    </TabsPages>
  </Tabs>
</Collapser>

## Options SNMPv3 [#snmpv3-options]

<CollapserGroup>
  <Collapser id="snmpv3-config" title="Configuration SNMPv3">
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nom de la clé
          </th>

          <th>
            Requis
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            user\_name
          </td>

          <td>
            ✓
          </td>

          <td>
            Nom d&apos;utilisateur pour l&apos;authentification SNMPv3
          </td>
        </tr>

        <tr>
          <td>
            authentication\_protocol
          </td>

          <td>
            ✓
          </td>

          <td>
            Protocole d&apos;authentification SNMPv3. Les valeurs possibles sont `NoAuth`, `MD5` ou `SHA`
          </td>
        </tr>

        <tr>
          <td>
            authentication\_passphrase
          </td>

          <td />

          <td>
            Mot de passe d&apos;authentification SNMPv3
          </td>
        </tr>

        <tr>
          <td>
            privacy\_protocol
          </td>

          <td>
            ✓
          </td>

          <td>
            Protocole de confidentialité SNMPv3. Les valeurs possibles sont `NoPriv`, `DES`, `AES`, `AES192`, `AES256`, `AES192C` ou `AES256C`
          </td>
        </tr>

        <tr>
          <td>
            privacy\_passphrase
          </td>

          <td />

          <td>
            Mot de passe de confidentialité SNMPv3
          </td>
        </tr>

        <tr>
          <td>
            context\_engine\_id
          </td>

          <td />

          <td>
            ID du moteur de contexte SNMPv3
          </td>
        </tr>

        <tr>
          <td>
            context\_name
          </td>

          <td />

          <td>
            Nom du contexte SNMPv3
          </td>
        </tr>
      </tbody>
    </table>

    ### Exemples :

    <Callout variant="tip">
      L’utilisation de secrets d’AWS, Azure ou de GCP nécessitera également que vous [fournissiez les variables d’environnement appropriées](/docs/network-performance-monitoring/advanced/advanced-config/#cloud-secrets) et toute autre information d’authentification nécessaire pour que l’agent puisse interroger l’API cible.
    </Callout>

    <Tabs>
      <TabsBar>
        <TabsBarItem id="v3-plain-text">
          Texte brut
        </TabsBarItem>

        <TabsBarItem id="v3-aws-secret">
          AWS Secret
        </TabsBarItem>

        <TabsBarItem id="v3-azure-secret">
          Azure Secret
        </TabsBarItem>

        <TabsBarItem id="v3-gcp-secret">
          Secret GCP
        </TabsBarItem>
      </TabsBar>

      <TabsPages>
        <TabsPageItem id="v3-plain-text">
          ```yaml
          discovery:
            default_v3:
              user_name: $YOUR_SNMPV3_USER
              authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
              authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
              privacy_protocol: $YOUR_PRIVACY_PROTOCOL
              privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-aws-secret">
          ```yaml
          discovery:
            default_v3: aws.sm.$YOUR_SECRET_NAME
          ```

          Dans AWS, vous devez [stocker vos secrets dans une structure JSON](https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_secret_json_structure.html) avec toutes les paires `key:value` pertinentes. Voici un exemple :

          ```json
          {
          "user_name": "$YOUR_SNMPV3_USER",
          "authentication_protocol": "$YOUR_AUTHENTICATION_PROTOCOL",
          "authentication_passphrase": "$YOUR_AUTHENTICATION_PASSPHRASE",
          "privacy_protocol": "$YOUR_PRIVACY_PROTOCOL",
          "privacy_passphrase": "$YOUR_PRIVACY_PASSPHRASE"
          }
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-azure-secret">
          ```yaml
          discovery:
            default_v3: azure.kv.$YOUR_SECRET_NAME
          ```

          Dans Azure, vous devez [stocker vos secrets dans une structure multiligne](https://learn.microsoft.com/en-us/azure/key-vault/secrets/multiline-secrets) avec toutes les paires `key:value` pertinentes. Voici un exemple :

          ```
          user_name: $YOUR_SNMPV3_USER
          authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
          authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
          privacy_protocol: $YOUR_PRIVACY_PROTOCOL
          privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-gcp-secret">
          ```yaml
          discovery:
            default_v3: gcp.sm.$YOUR_SECRET_NAME
          ```

          Dans GCP, vous devez [stocker vos secrets dans une structure multiligne](https://cloud.google.com/secret-manager/docs/create-secret-quickstart) avec toutes les paires `key:value` pertinentes. Voici un exemple :

          ```
          user_name: $YOUR_SNMPV3_USER
          authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
          authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
          privacy_protocol: $YOUR_PRIVACY_PROTOCOL
          privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>
      </TabsPages>
    </Tabs>
  </Collapser>

  <Collapser id="multiple-v3-discovery" title="Exécution de la découverte avec plusieurs profils SNMP v3">
    Pour prendre en charge l&apos;exécution de tâches de découverte avec plusieurs profils SNMP v3, vous pouvez remplacer la clé `discovery.default_v3` par la clé `discovery.other_v3s` , qui contient un éventail de [configurations SNMPv3](#snmpv3-config).

    ```yaml
    discovery:
      other_v3s:
      - user_name: $YOUR_USER_NAME_1
        authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL_1
        authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE_1
        privacy_protocol: $YOUR_PRIVACY_PROTOCOL_1
        privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE_1
        context_engine_id: ""
        context_name: ""
      - user_name: $YOUR_USER_NAME_2
        authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL_2
        authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE_2
        privacy_protocol: $YOUR_PRIVACY_PROTOCOL_1
        privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE_2
        context_engine_id: ""
        context_name: ""
    ```

    Cela peut également fonctionner à l&apos;aide d&apos;un gestionnaire de secrets de fournisseur cloud. Un exemple pour AWS :

    ```yaml
    discovery:
      other_v3s:
      - aws.sm.$YOUR_SECRET_NAME_1
      - aws.sm.$YOUR_SECRET_NAME_2
    ```
  </Collapser>
</CollapserGroup>

## Configuration de l&apos;interrogation API [#api-polling-configurations]

<Callout variant="tip">
  Vous pouvez également utiliser les secrets du fournisseur cloud dans votre configuration d’authentification API.
</Callout>

<CollapserGroup>
  <Collapser id="arista" title="Arista eAPI">
    L&apos;intégration [Arista eAPI](https://www.arista.com/assets/data/pdf/Whitepapers/Arista_eAPI_FINAL.pdf) collecte des données de télémétrie BGP et MLAG supplémentaires qui ne sont généralement pas disponibles via l&apos;interrogation SNMP.

    * Les détails BGP sont collectés à partir de cette commande : `show ip bgp summary vrf all`

      NRQL pour trouver la télémétrie BGP :

      ```sql
      FROM Metric SELECT
        max(kentik.eapi.bgp.InMsgQueue) AS 'InQ', // Messages Queued from the Neighbor
        max(kentik.eapi.bgp.MsgReceived) AS 'MsgSent', // Messages Received from the Neighbor
        max(kentik.eapi.bgp.MsgSent) AS 'MsgRcvd', // Messages Sent to the Neighbor
        latest(peer_state) AS 'State', // State of the BGP session
        latest(kentik.eapi.bgp.UpDownTime) AS 'Up/Down', // Period the BGP session has been in current state
        latest(kentik.eapi.bgp.Version) AS 'V' // BGP version number
      FACET
        entity.name AS 'Device',
        router_id AS 'Device IP',
        peer AS 'BGP Peer',
        peer_asn AS 'BGP Peer ASN',
        vrf AS 'VRF Name'
      ```

      <br />

    * Les détails MLAG sont collectés à partir de cette commande : `show mlag detail`

      NRQL pour trouver la télémétrie MLAG :

      ```sql
      FROM Metric SELECT
        latest(kentik.eapi.mlag.PortsConfigured) AS 'Ports Configured', // Count of MLAG ports currently configured
        latest(kentik.eapi.mlag.PortsDisabled) AS 'Ports Disabled', // Count of MLAG ports in 'Disabled' state
        latest(kentik.eapi.mlag.PortsActivePartial) AS 'Ports Active-partial', // Count of MLAG ports in 'Active-partial' state 
        latest(kentik.eapi.mlag.PortsInactive) AS 'Ports Inactive', // Count of MLAG ports in 'Inactive' state
        latest(kentik.eapi.mlag.PortsActiveFull) AS 'Ports Active-full', // Count of MLAG ports in 'Active-full' state
        latest(kentik.eapi.mlag.PortsErrdisabled) AS 'Ports Err-disabled', // Count of MLAG ports in 'Err-disabled' state
        latest(config_sanity) AS 'Config-Sanity', // Current result of 'config-sanity' check
        latest(state) AS 'State', // Current MLAG state
        latest(neg_status) AS 'Negotiation Status', // Current negotiation status between switches
        latest(peer_address) AS 'Peer Address', // Address of MLAG peer
        latest(peer_link) AS 'Peer Link', // Link name for MLAG peer
        latest(peer_link_status) AS 'Peer Link Status', // Status of MLAG peer
        latest(local_interface) AS 'Local Interface', // Local interface used for MLAG configuration
        latest(local_intf_status) AS 'Local Interface Status' // Status of local interface used for MLAG configuration
      FACET
        entity.name AS 'Device',
        domain_id AS 'MLAG Domain ID'
      ```

      ### Options de configuration

      <table>
        <thead>
          <tr>
            <th style={{ width: "200px" }}>
              Nom de la clé
            </th>

            <th>
              Requis
            </th>

            <th>
              Description
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              eapi\_config.username
            </td>

            <td>
              ✓
            </td>

            <td>
              Le nom d&apos;utilisateur à transmettre à l&apos;appareil pour authentifier l&apos;authentification eAPI.
            </td>
          </tr>

          <tr>
            <td>
              eapi\_config.password
            </td>

            <td>
              ✓
            </td>

            <td>
              Le mot de passe à transmettre à l&apos;appareil pour authentifier l&apos;authentification eAPI.
            </td>
          </tr>

          <tr>
            <td>
              eapi\_config.transport
            </td>

            <td />

            <td>
              Spécifie le type de transport de connexion à utiliser. Les valeurs possibles sont `https` et `http`. Par défaut : `https`.
            </td>
          </tr>

          <tr>
            <td>
              eapi\_config.port
            </td>

            <td>
              ✓
            </td>

            <td>
              Le port TCP du point de terminaison pour la connexion eAPI.
            </td>
          </tr>
        </tbody>
      </table>
  </Collapser>

  <Collapser id="meraki" title="API du tableau de bord Meraki">
    L&apos;intégration [de l&apos;API du tableau de bord Meraki](https://developer.cisco.com/meraki/api-v1/) extrait diverses mesures liées à la santé de votre environnement Meraki. La combinaison d&apos;options configuration vous permet de configurer différents scénarios monitoring en fonction de vos besoins et crée une entité dans votre compte New Relic.

    <CollapserGroup>
      <Collapser id="meraki-organization" title="Entité organisationnelle Meraki">
        les métriques d&apos;organisation sont collectées par défaut sous la métrique `kentik.meraki.organization.Count` qui est exclusivement utilisée pour générer l&apos;entité `Meraki Organization` . Il s’agit principalement de permettre la visualisation de la hiérarchie Meraki pour aligner les réseaux et les appareils sur leur organisation parent.

        * `meraki_config.monitor_org_changes: true`: Utilise le point de terminaison [Obtenir la configuration de l&apos;organisation](https://developer.cisco.com/meraki/api-v1/get-organization-configuration-changes/) pour afficher le log des modifications de l&apos;organisation.

          NRQL pour trouver la télémétrie des changements de configuration de l&apos;organisation :

          ```sql
          FROM KExtEvent SELECT *
          ```
      </Collapser>

      <Collapser id="meraki-network" title="Entité du réseau Meraki">
        * `meraki_config.preferences.show_network_attr: true`

          Les métriques réseau sont collectées sous la métrique `kentik.meraki.network.Count` qui est exclusivement utilisée pour générer l&apos;entité `Meraki Network` . Il s’agit principalement de permettre la visualisation de la hiérarchie Meraki et d’aligner les appareils sur le réseau dont ils sont membres.
      </Collapser>

      <Collapser id="meraki-device" title="Entité du dispositif Meraki">
        * `meraki_config.monitor_devices: true && meraki_config.preferences.device_status_only: true`:Utilise le point de terminaison [Obtenir l&apos;état des périphériques de l&apos;organisation](https://developer.cisco.com/meraki/api-v1/get-organization-devices-statuses/) pour répertorier l&apos;état de chaque périphérique Meraki de l&apos;organisation.

          NRQL pour trouver la télémétrie de l&apos;état de l&apos;appareil :

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Device Status' // Current status of this device
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            src_addr AS 'Device Public IP',
            mac AS 'Device MAC',
            model AS 'Device Model',
            serial AS 'Device Serial',
            address AS 'Device Address',
            lat AS 'Device Latitude',
            lng AS 'Device Longitude',
            notes AS 'Device Notes'
          WHERE instrumentation.name = 'meraki.device_status'
          ```

          <br />

        * `meraki_config.monitor_uplinks: true && meraki_config.preferences.hide_uplink_usage: false`:Utilise à la fois les [fonctions Obtenir les statuts des liaisons montantes de l&apos;organisation](https://developer.cisco.com/meraki/api-v1/get-organization-uplinks-statuses/) et [Obtenir l&apos;utilisation des liaisons montantes des appareils de l&apos;organisation par point de terminaison réseau](https://developer.cisco.com/meraki/api-v1/get-organization-appliance-uplinks-usage-by-network/) pour répertorier l&apos;état et les performances des liaisons montantes de chaque périphérique Meraki MX, MG et Z de l&apos;organisation.

          NRQL pour trouver la télémétrie de liaison montante de l&apos;appareil :

          ```sql
          FROM Metric SELECT
            max(kentik.meraki.uplinks.LatencyMS) AS 'Uplink Latency', // Uplink measured latency in milliseconds
            max(kentik.meraki.uplinks.LossPct) AS 'Uplink Loss %', // Uplink measured loss percentage
            max(kentik.meraki.uplinks.Recv) AS 'Uplink Receive Bytes', // Uplink bytes received
            max(kentik.meraki.uplinks.Sent) AS 'Uplink Transmit Bytes', // Uplink bytes sent
            latest(status) AS 'Uplink Status' // Latest status of the uplink
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            interface AS 'Device Uplink Interface',
            model AS 'Device Model',
            serial AS 'Device Serial'
          WHERE org_id IS NOT NULL
          ```

          <br />

        * `meraki_config.monitor_uplinks: true && meraki_config.preferences.hide_uplink_usage: true`:Utilise le point de terminaison [Obtenir les statuts des liaisons montantes de l&apos;organisation](https://developer.cisco.com/meraki/api-v1/get-organization-uplinks-statuses/) pour répertorier uniquement l&apos;état de la liaison montante de chaque périphérique des séries Meraki MX, MG et Z de l&apos;organisation.

          NRQL pour trouver la télémétrie de l&apos;état de la liaison montante de l&apos;appareil :

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Uplink Status' // Latest status of the uplink
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            interface AS 'Device Uplink Interface',
            model AS 'Device Model',
            serial AS 'Device Serial'
          WHERE org_id IS NOT NULL
          ```

          <br />

        * `meraki_config.monitor_vpn_status: true && meraki_config.preferences.show_vpn_peers: false`: Utilise le point de terminaison [Obtenir les statuts VPN de l&apos;appareil d&apos;organisation](https://developer.cisco.com/meraki/api-v1/get-organization-appliance-vpn-statuses/) pour afficher les statuts VPN sur les réseaux de l&apos;organisation.

          NRQL pour trouver la télémétrie de l&apos;état du VPN :

          ```sql
          FROM Metric SELECT
            latest(status) AS 'VPN Status' // Latest status of this VPN
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            serial AS 'Device Serial',
            vpn_mode AS 'VPN Mode',
            wan1 OR wan2 AS 'WAN Interface IP'
          WHERE instrumentation.name = 'meraki.vpn_status'
          AND org_id IS NOT NULL
          ```

          <br />

        * `meraki_config.monitor_vpn_status: true && meraki_config.preferences.show_vpn_peers: true`:Utilise le point de terminaison [Obtenir les statuts VPN de l&apos;appareil de l&apos;organisation](https://developer.cisco.com/meraki/api-v1/get-organization-appliance-vpn-statuses/) pour ajouter des informations sur les homologues VPN sur les réseaux de l&apos;organisation.

          NRQL pour trouver la télémétrie des homologues VPN :

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Peer Status' // Current status of this VPN peer
          FACET
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            serial AS 'Device Serial',
            vpn_mode AS 'VPN Mode',
            wan1 AS 'WAN 1 IP',
            wan2 AS 'WAN 2 IP',
            peer_name AS 'Peer Name', // Name of this peer
            peer_reachability AS 'Peer Reachability', // Latest results of reachability test for this peer
            peer_network_id AS 'Peer Network ID', // Network ID for this peer
            peer_type AS 'Peer Type' // Type of Peer (Meraki vs Third-party)
          WHERE metricName = 'kentik.meraki.vpn_status.PeerStatus'
          ```
      </Collapser>

      <Collapser id="meraki-config-options" title="Options de configuration Meraki">
        <Collapser id="meraki-primary-config" title="Options de configuration principales">
          <Callout variant="tip">
            Vous pouvez utiliser la variable d&apos;environnement [KENTIK\_MERAKI\_API\_KEY](/docs/network-performance-monitoring/advanced/ktranslate-container-management/#container-runtime-options) pour transmettre votre clé API à l&apos;intégration Meraki sans la stocker en texte brut dans votre fichier de configuration.
          </Callout>

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Nom de la clé
                </th>

                <th>
                  Requis
                </th>

                <th>
                  Saisir
                </th>

                <th>
                  Description
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki\_config.api\_key
                </td>

                <td>
                  ✓ (Non requis si vous utilisez la variable d&apos;environnement [KENTIK\_MERAKI\_API\_KEY](/docs/network-performance-monitoring/advanced/ktranslate-container-management) )
                </td>

                <td>
                  Clé API (chaîne)
                </td>

                <td>
                  [Clé API du tableau de bord Meraki](https://documentation.meraki.com/General_Administration/Other_Topics/Cisco_Meraki_Dashboard_API#Generate_API_Key) pour l&apos;authentification.
                </td>
              </tr>

              <tr>
                <td>
                  meraki\_config.max\_http\_retry
                </td>

                <td />

                <td>
                  Entier entre 1 et 10 (par défaut : 2)
                </td>

                <td>
                  Paramètre facultatif qui contrôle la fréquence à laquelle une nouvelle tentative est tentée sur requests API qui renvoient une erreur `HTTP 429`. L&apos;intervalle entre les tentatives est de 5 secondes.
                </td>
              </tr>

              <tr>
                <td>
                  meraki\_config.monitor\_devices
                </td>

                <td />

                <td>
                  vrai | faux (par défaut : faux)
                </td>

                <td>
                  Monitorer l&apos;état de chaque appareil Meraki de l&apos;organisation.
                </td>
              </tr>

              <tr>
                <td>
                  meraki\_config.monitor\_org\_changes
                </td>

                <td />

                <td>
                  vrai | faux (par défaut : faux)
                </td>

                <td>
                  Monitore le log des modifications de l&apos;organisation.
                </td>
              </tr>

              <tr>
                <td>
                  meraki\_config.monitor\_uplinks
                </td>

                <td />

                <td>
                  vrai | faux (par défaut : vrai)
                </td>

                <td>
                  Monitorez l&apos;état de la liaison montante et les performances de chaque appareil des séries Meraki MX, MG et Z de l&apos;organisation.
                </td>
              </tr>

              <tr>
                <td>
                  meraki\_config.monitor\_vpn\_status
                </td>

                <td />

                <td>
                  vrai | faux (par défaut : faux)
                </td>

                <td>
                  Monitore les statuts VPN sur les réseaux de l&apos;organisation.
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser id="meraki-filter-config" title="Options de filtrage">
          Ces options vous permettent de restreindre monitoring à des objets spécifiquement ciblés dans votre environnement Meraki.

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Nom de la clé
                </th>

                <th>
                  Requis
                </th>

                <th>
                  Saisir
                </th>

                <th>
                  Description
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki\_config.organizations
                </td>

                <td />

                <td>
                  Regex dans [la syntaxe RE2](https://github.com/google/re2/wiki/Syntax) (par défaut : null)
                </td>

                <td>
                  Filtre toute monitoring sur une liste spécifique d&apos;organisations.
                </td>
              </tr>

              <tr>
                <td>
                  meraki\_config.networks
                </td>

                <td />

                <td>
                  Regex dans [la syntaxe RE2](https://github.com/google/re2/wiki/Syntax) (par défaut : null)
                </td>

                <td>
                  Filtre toute monitoring sur une liste spécifique de réseaux.
                </td>
              </tr>

              <tr>
                <td>
                  meraki\_config.product\_types
                </td>

                <td />

                <td>
                  Les types valides sont : sans fil, appareil, commutateur, systemsManager, caméra, cellularGateway, capteur et cloudGateway. (Par défaut : null)
                </td>

                <td>
                  Ajoute des paramètres à la demande d&apos;API [monitor\_devices](https://developer.cisco.com/meraki/api-v1/get-organization-devices-statuses/) pour filtrer sur des types spécifiques d&apos;appareils.
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser id="meraki-additional-config" title="Préférences supplémentaires">
          Ces options vous permettent de définir plus précisément les données collectées à partir des principales options de configuration. Différentes combinaisons sont décrites dans la section exemples ci-dessus.

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Nom de la clé
                </th>

                <th>
                  Requis
                </th>

                <th>
                  Saisir
                </th>

                <th>
                  Description
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki\_config.preferences.device\_status\_only
                </td>

                <td />

                <td>
                  vrai | faux (par défaut : faux)
                </td>

                <td>
                  *Obligatoire* lors de l&apos;utilisation de `monitor_devices: true` pour restreindre l&apos;interrogation aux seules informations d&apos;état. <DNT>**(This is used to prevent timeout issues.)**</DNT>
                </td>
              </tr>

              <tr>
                <td>
                  meraki\_config.preferences.hide\_uplink\_usage
                </td>

                <td />

                <td>
                  vrai | faux (par défaut : faux)
                </td>

                <td>
                  Utilisé en combinaison avec `monitor_uplinks` pour supprimer les mesures de performances et renvoyer uniquement les informations d&apos;état pour les liaisons montantes.
                </td>
              </tr>

              <tr>
                <td>
                  meraki\_config.preferences.show\_vpn\_peers
                </td>

                <td />

                <td>
                  vrai | faux (par défaut : faux)
                </td>

                <td>
                  Utilisé en combinaison avec `monitor_vpn_status` pour ajouter de la télémétrie sur les homologues VPN.
                </td>
              </tr>

              <tr>
                <td>
                  meraki\_config.preferences.show\_network\_attr
                </td>

                <td />

                <td>
                  vrai | faux (par défaut : faux)
                </td>

                <td>
                  Utilisé pour ajouter de la télémétrie sur les réseaux. Nécessaire pour créer l&apos;entité `Meraki Network` .
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>
      </Collapser>

      ### Exemple de configuration minimale [#meraki-minimum-config]

      ```yaml
      # This represents the minimal configuration required for a container that only performs Meraki API polling.
      # By default we only monitor uplinks. All other items are optional.
      ---
       devices:
          meraki_cloud_controller:
            device_name: meraki_cloud_controller
            device_ip: snmp.meraki.com
            provider: meraki-cloud-controller
            ext:
              ext_only: true
              meraki_config:
                api_key: "$YOUR_API_KEY"
       trap: {}
       discovery: {}
       global:
         poll_time_sec: 300
         timeout_ms: 30000
      ```

      ### Exemples de configuration complète [#meraki-full-config]

      #### Toutes les options requises pour créer les entités `Meraki Organization`, `Meraki Network` et `Meraki Device` .

      ```yaml
      devices:
        meraki_dashboard_api:
          device_name: meraki_controller
          device_ip: snmp.meraki.com
          provider: meraki-cloud-controller
          ext:
            ext_only: true
            meraki_config:
              api_key: $YOUR_MERAKI_API_KEY
              monitor_devices: true
              monitor_org_changes: true
              monitor_uplinks: true
              monitor_vpn_status: true
              preferences:
                device_status_only: true
                hide_uplink_usage: false
                show_vpn_peers: true
                show_network_attr: true
      trap: {}
      discovery: {}
      global:
        poll_time_sec: 300
        timeout_ms: 30000
      ```

      #### Ciblage de plusieurs API clés du tableau de bord Meraki

      ```yaml
      devices:
         # Entity 1 - monitor everything this API key has access to
         meraki_all:
           device_name: meraki_all
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_1"
               max_http_retry: 8
               monitor_devices: true
               monitor_org_changes: true
               monitor_uplinks: true
               monitor_vpn_status: true
               preferences:
                 device_status_only: true
                 show_vpn_peers: true
                 hide_uplink_usage: false
         # Entity 2 - Monitor these specific organizations under this API key
         meraki_single_org:
           device_name: meraki_single_org
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_2"
               monitor_devices: true
               monitor_org_changes: true
               monitor_uplinks: true
               monitor_vpn_status: true
               preferences:
                 device_status_only: true
                 show_vpn_peers: true
                 hide_uplink_usage: false
               organizations:
                 - "Org 1 - Prod.*"
                 - "Org 2 - Staging"
         # Entity 3 - Monitor specific devices filtered by organization, network, and product types; using the same API key from Entity 2
         meraki_filtered:
           device_name: meraki_filtered
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_2"
               monitor_devices: true
               monitor_uplinks: false
               preferences:
                 device_status_only: true
               organizations:
                 - "Org 3 - Remote Sites"
               networks:
                 - "Corp.*99"
                 - "Retail.*"
               product_types:
                 - wireless
                 - appliance
      trap: {}
      discovery: {}
      global:
        poll_time_sec: 300
        timeout_ms: 30000
      ```
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

## Fichiers de configuration externes [#external-config-files]

Pour prendre en charge une grande variété de besoins de configuration et d&apos;automatisation, vous pouvez utiliser des fichiers externes que vous montez en volume dans votre conteneur Docker pour découpler certains éléments du fichier de configuration standard. Vous devrez inclure l&apos;argument de montage ci-dessous dans votre commande `docker run` , avec un argument par fichier de configuration externe.

```
-v `pwd`/fileName.yaml:/fileName.yaml \
```

La syntaxe de ces fichiers est `"@fileName.yaml"`, y compris les guillemets doubles.

<CollapserGroup>
  <Collapser id="discovery-cidrs-file" title="Découverte des CIDR">
    Exemple:

    ```yaml
    discovery:
      cidrs: "@cidrs.yaml"
    ```

    Le fichier CIDR doit utiliser une syntaxe de liste YAML comme celle-ci :

    ```yaml
    - 10.10.0.0/24
    - 10.20.0.0/24
    - 192.168.0.21/32
    ```
  </Collapser>

  <Collapser id="devices-file" title="Appareils">
    Exemple:

    ```yaml
    devices:
      "@neteng-devices.yaml"
    ```

    Les fichiers de périphérique doivent utiliser la même syntaxe que la section `devices` standard du fichier de configuration principal, en omettant les champs facultatifs générés lors de la découverte :

    ```yaml
    devices:
      # Sample of SNMP v2c device
      ups_snmpv2c__10.10.0.201:
        device_name: ups_snmpv2c
        device_ip: 10.10.0.201
        snmp_comm: $YOUR_COMMUNITY_STRING
        oid: .1.3.6.1.4.1.318.1.3.27
        mib_profile: apc_ups.yml
        provider: kentik-ups
        poll_time_sec: 300
        retries: 1
        timeout_ms: 5000
        user_tags:
          owning_team: dc_ops
    ```
  </Collapser>
</CollapserGroup>

## Le `match_attributes` [#match\_attributes-attribute][#match_attributes-attribute]

Pour prendre en charge le filtrage des données qui ne créent pas de valeur pour vos besoins d&apos;observabilité, vous pouvez définir la carte d&apos;attributs `global.match_attributes.{}` et/ou `devices.[].match_attributes.{}` .

Cela fournira un filtrage au niveau `ktranslate`, avant d&apos;envoyer des données à New Relic, vous donnant un contrôle précis sur monitoring d&apos;éléments tels que les interfaces.

Le comportement par défaut de cette carte est une condition `OR` , mais vous pouvez la remplacer et forcer un opérateur `AND` en préfixant votre nom de clé avec `!`. Ceci est également utile pour renvoyer uniquement les éléments correspondants et omettre tous les résultats `null` et `""` (vides).

<CollapserGroup>
  <Collapser id="default-or-null" title="« OR » par défaut avec des valeurs nulles et vides">
    Correspondance lorsque `if_Alias` commence par `Uplink` <DNT>**OR**</DNT> lorsque `if_interface_name` commence par `Gig`, conserver toutes les valeurs `null` et `""` :

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          if_Alias: "^Uplink.*"
          if_interface_name: "^Gig.*"
    ```
  </Collapser>

  <Collapser id="and-no-null" title="« ET », omettre les valeurs nulles et vides">
    Correspondance lorsque `if_Alias` commence par `Uplink` <DNT>**AND**</DNT> lorsque `if_interface_name` commence par `Gig`, supprimez toutes les valeurs `null` et `""` :

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          if_Alias: "^Uplink.*"
          "!if_interface_name": "^Gig.*"
    ```
  </Collapser>

  <Collapser id="single-no-null" title="Correspondance unique, omettre les valeurs nulles et vides">
    Correspondance lorsque `if_Alias` commence par `Uplink`, supprimez toutes les valeurs `null` et `""` :

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          "!if_Alias": "^Uplink.*"
    ```
  </Collapser>

  <Collapser id="negate-lookup" title="Créer une prévision négative">
    Le package regex de Golang ne prend pas en charge les modèles d&apos;anticipation négatifs (`q(?!u)`) par défaut. Pour contourner ce problème, vous pouvez ajouter le jeton `DOES_NOT_MATCH` à votre carte d&apos;attributs pour obtenir efficacement les résultats inverses de votre modèle de correspondance.

    Par exemple, pour effectuer une correspondance sur chaque interface qui **n&apos;inclut pas** la chaîne `Uplink`; vous pouvez utiliser une configuration comme celle-ci :

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          "!if_Alias": "^Uplink.*"
          DOES_NOT_MATCH: true
    ```
  </Collapser>
</CollapserGroup>

## Le `response_time` et `ping_only` [#response\_time-attribute][#response_time-attribute]

Pour prendre en charge monitoring des périphériques pour lesquels les statistiques de performances ne sont pas accessibles ou disponibles, ou dans les cas simples où monitoring du temps aller-retour (RTT) de base est requise, vous pouvez définir l&apos;attribut `global.response_time` ou `devices.[].ping_only` sur `true`.

Cette fonctionnalité utilise le package [go-ping](https://pkg.go.dev/github.com/sparrc/go-ping) pour envoyer des paquets ICMP (par défaut) ou UDP non privilégiés aux périphériques afin de collecter le temps aller-retour (RTT) moyen, minimum, maximum et écart type. Ce package affiche également le pourcentage de perte de paquets pour le point de terminaison en fonction de l&apos;envoi d&apos;un paquet/s de `ktranslate` à l&apos;adresse IP du périphérique, qui peut être remplacé en définissant l&apos;attribut `devices.[].ping_interval_sec` . Vous pouvez passer de l’utilisation par défaut des paquets ICMP privilégiés à UDP en définissant la variable d’environnement `KENTIK_PING_PRIV=false` pendant l’exécution de Docker.

La définition de l&apos;attribut `global.response_time` sur `true` ajoutera monitoring RTT en plus de l&apos;interrogation SNMP existante. Pour monitorer les périphériques avec uniquement les paquets UDP|ICMP pour RTT et aucune interrogation SNMP, utilisez `devices.[].ping_only: true`.

Dans New Relic, vous pouvez voir les résultats de ce sondage en examinant les paramètres suivants :

```sql
FROM Metric SELECT
  average(kentik.ping.AvgRttMs) AS 'Average',
  max(kentik.ping.MaxRttMs) AS 'Max',
  min(kentik.ping.MinRttMs) AS 'Min',
  average(kentik.ping.StdDevRtt) AS 'StdDev',
  latest(kentik.ping.PacketLossPct) AS 'Packet Loss %'
FACET device_name
```

<Callout variant="tip">
  Vous pouvez utiliser l&apos;attribut `ping_only` en remplacement de l&apos;attribut `flow_only` si vous souhaitez collecter des métriques RTT à partir d&apos;un périphérique de flux. Si `ping_only` et `flow_only` sont tous deux `true`, le périphérique sera traité comme un périphérique `flow_only` .
</Callout>

## Le `flow_only` [#flow\_only-attribute][#flow_only-attribute]

Pour prendre en charge monitoring des appareils sur lesquels vous souhaitez uniquement collecter des données de flux, vous pouvez définir l&apos;attribut `devices.<deviceName>.flow_only` sur `true`.

Cela générera une entité <DNT>**Flow Device**</DNT> qui n&apos;aura de télémétrie que dans le `KFlow` événement espace de nommage. Alternativement, la collecte de la télémétrie de flux à partir d&apos;un périphérique qui se trouve dans votre fichier de configuration en tant que périphérique SNMP ajoutera la décoration des données `KFlow` à l&apos;entité préexistante, telle qu&apos;un <DNT>**Router**</DNT> ou <DNT>**Firewall**</DNT>.

Dans New Relic, vous pouvez voir les résultats de ce sondage en examinant l&apos;événement suivant :

```sql
FROM KFlow SELECT *
WHERE instrumentation.name = 'netflow-events'
```

## Modélisation d&apos;application de données de flux

Par défaut, la télémétrie de flux est mappée aux applications connues en fonction de l’évaluation du port de couche 4 utilisé sur une conversation de flux spécifique. Si nécessaire, vous pouvez remplacer la modélisation par défaut en fournissant un fichier YAML pendant l&apos;exécution Docker à l&apos;indicateur `-application_map`. Cela vous permettra de spécifier les noms d&apos;application en fonction des ports que vous identifiez.

Exemple de syntaxe :

```yaml
applications:
  - ports: [9092, 9093]
    name: kafka
  - ports: [80, 8080]
    name: http
  - ports: [443, 8443]
    name: https
```

## Filtrage des données d&apos;entrée de flux

Par défaut, le conteneur de données de flux collecte et traite chaque paquet de flux qu&apos;il reçoit. Si nécessaire, vous pouvez ajouter un filtre d&apos;inclusion à l&apos;indicateur `-nf.source` qui ignorera tout le trafic ne correspondant pas au filtre que vous fournissez.

<CollapserGroup>
  <Collapser id="flow-filter-options" title="Options de filtrage de flux">
    Syntaxe: `--filters $TYPE,$FIELD,$FUNCTION,$MATCH`

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nom de l&apos;argument
          </th>

          <th>
            Requis
          </th>

          <th>
            Description
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            $TYPE
          </td>

          <td>
            ✓
          </td>

          <td>
            Le type de filtre à appliquer. Les valeurs possibles sont `string`, `int` et `addr`.
          </td>
        </tr>

        <tr>
          <td>
            $CHAMP
          </td>

          <td>
            ✓
          </td>

          <td>
            Le nom du champ par rapport auquel évaluer le modèle de correspondance.
          </td>
        </tr>

        <tr>
          <td>
            $FONCTION
          </td>

          <td>
            ✓
          </td>

          <td>
            Le type de fonction à utiliser lors de l&apos;évaluation. Les valeurs possibles sont `Equal: ==`, `NotEqual: !=`, `LessThan: <`, `GreaterThan: >`, `Contains: %`
          </td>
        </tr>

        <tr>
          <td>
            $ CORRESPONDANCE
          </td>

          <td>
            ✓
          </td>

          <td>
            La valeur à utiliser comme modèle de correspondance.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="example-flow-filters" title="Exemples de filtres">
    * Collecter uniquement les données de flux à partir d&apos;adresses sources dans la plage CIDR `10.0.0.0/24`

      ```
      -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24
      ```

    * Collecter uniquement les données de flux lorsque le port de destination n&apos;est pas égal à `8531`

      ```
      -nf.source netflow5 --filters int,l4_dst_port,!=,8531
      ```

    * Collecter uniquement les données de flux à partir d&apos;adresses sources dans la plage CIDR `10.0.0.0/24` ET où le port de destination n&apos;est pas égal à `8531` (opérateur `AND` implicite)

      ```
      --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531
      ```
  </Collapser>
</CollapserGroup>

## Rechargement automatique des profils SNMP personnalisés [#reload-snmp-threads]

Par défaut, le conteneur Docker `ktranslate` doit être détruit et reconstruit manuellement pour intégrer les modifications apportées aux profils SNMP dans le chemin [mib\_profile\_dir](#global) . Il s&apos;agit d&apos;un comportement normal dans la plupart des déploiements, car l&apos;image Docker récupère les derniers profils disponibles dans le [référentiel public snmp-profiles](https://github.com/kentik/snmp-profiles). Dans les situations où vous fournissez [des profils personnalisés](/docs/network-performance-monitoring/advanced/snmp-profiles/#private), vous pouvez utiliser le paramètre [watch\_profile\_changes](#global) pour permettre au conteneur d&apos;actualiser automatiquement la configuration sous-jacente et les profils SNMP du conteneur.

<Callout variant="important">
  Ce n&apos;est pas récursif en raison d&apos;une limitation dans la [bibliothèque watcher](https://github.com/fsnotify/fsnotify?tab=readme-ov-file#are-subdirectories-watched). Ainsi, si un profil change dans un sous-répertoire, vous devez également modifier un fichier de niveau supérieur pour déclencher la modification.
</Callout>

En supposant cette structure de répertoire :

```
.
└── /snmp-profiles/
    └── profiles/
        └── kentik-snmp/
            ├── 3com
            ├── _general
            ├── a10networks
            └── ...
```

Vous devrez placer un nouveau fichier à la racine du répertoire et le modifier manuellement pour déclencher ce cycle d&apos;actualisation. Un moyen simple de mettre en œuvre ceci est d’écrire simplement un horodatage dans un fichier tel que `last_updated.txt` lorsque votre modification est soumise.

```
.
└── /snmp-profiles/
    ├── last_updated.txt
    └── profiles/
        └── kentik-snmp/
            ├── 3com
            ├── _general
            ├── a10networks
            └── ...
```