---
title: Instalar la integración de Kubernetes
tags:
  - Integrations
  - Kubernetes integration
  - Installation
metaDescription: 'New Relic''s Kubernetes integration: How to install and activate the integration, and what data is reported.'
signupBanner: null
text: Monitor and improve your entire stack. 100GB free. Forever.
freshnessValidatedDate: never
translationType: machine
---

import kubernetesAks from 'images/kubernetes_logo_aks.webp'

import kubernetesOpenshift from 'images/kubernetes_logo_openshift.webp'

import kubernetesCke from 'images/kubernetes_logo_cke.webp'

import kubernetesEks from 'images/kubernetes_logo_eks.webp'

import pixieLiveDebugging from 'images/pixie_screenshot-full_live-debugging.webp'

import pixieServiceOtelMap from 'images/pixie_screenshot-full_service-otel-map.webp'

import kubernetesFargateOverview from 'images/kubernetes_diagram_fargate-overview.svg'

import kubernetesFargateWorkflow from 'images/kubernetes_diagram_fargate-workflow.svg'

import kubernetesFargateUi from 'images/kubernetes_screenshot-crop_fargate-ui.webp'

La integración New Relic Kubernetes le brinda total observabilidad de la salud y el rendimiento de su entorno al aprovechar el agente New Relic Infrastructure . Este agente recopila telemetry data de su clúster utilizando varias integraciones New Relic , como la [integración de eventosKubernetes ](/docs/integrations/kubernetes-integration/kubernetes-events/install-kubernetes-events-integration), el [agente Prometheus](/docs/infrastructure/prometheus-integrations/install-configure-prometheus-agent/install-prometheus-agent/) y el [complemento New Relic Logs Kubernetes ](/docs/logs).

## Opciones de instalación

Para instalar nuestra integración de Kubernetes, le recomendamos que siga las instrucciones aquí para nuestra experiencia de instalación guiada. Recomendamos esta herramienta de instalación interactiva para servidores, máquinas virtuales (VM) y entornos [sin privilegios](/docs/infrastructure/install-infrastructure-agent/linux-installation/linux-agent-running-modes) .

<Tabs>
  <TabsBar>
    <TabsBarItem id="guided-install">
      Instalación guiada (recomendado)
    </TabsBarItem>

    <TabsBarItem id="windows-install">
      En Windows
    </TabsBarItem>

    <TabsBarItem id="eks-fargate">
      En EKS Fargate
    </TabsBarItem>

    <TabsBarItem id="man-helm">
      Timón manual
    </TabsBarItem>

    <TabsBarItem id="gke-autopilot">
      En piloto automático de GKE
    </TabsBarItem>
  </TabsBar>

  <TabsPages>
    <TabsPageItem id="guided-install">
      La experiencia de instalación guiada simplifica el proceso de instalación para la integración de New Relic Kubernetes y le brinda control sobre qué características están habilitadas y qué datos se recopilan. También ofrece una opción de inicio rápido que incluye algunos recursos opcionales prediseñados, como panel de control y alertas, junto con la integración Kubernetes para que pueda obtener visibilidad instantánea de su clúster de Kubernetes.

      Puede elegir entre una de las siguientes tres opciones:

      1. New Relic
      2. Un comando de Helm con valores requeridos previamente completados
      3. Un manifiesto simple

      ## Navegando por la instalación guiada de integración de Kubernetes [#kubernetes-install-navigation]

      Una vez que comience la instalación guiada, utilice la siguiente información para ayudarle a tomar decisiones sobre la configuración.

      <Callout variant="tip">
        Los pasos siguientes omiten los pasos preliminares del inicio rápido. Si eligió la instalación guiada con inicio rápido, simplemente haga clic en las páginas <DoNotTranslate>**Confirm your Kubernetes quickstart installation**</DoNotTranslate> y <DoNotTranslate>**Installation plan**</DoNotTranslate> para llegar a las páginas principales de instalación guiada que se describen a continuación.
      </Callout>

      <Steps>
        <Step>
          ## Prepárese para instalar

          Prepare su sistema Kubernetes para la instalación guiada:

          * Si se han utilizado manifiestos personalizados en lugar de Helm, primero deberá eliminar la instalación anterior usando `kubectl delete -f previous-manifest-file.yml` y luego continuar con el instalador guiado nuevamente. Esto generará un conjunto actualizado de manifiestos que se pueden desplegar usando `kubectl apply -f manifest-file.yml`.

          * Asegúrese de estar utilizando las versiones compatibles Kubernetes y asegúrese de consultar las notas preliminares de su plataforma o servicios administrados en nuestra [página de compatibilidad y requisitos](/docs/kubernetes-pixie/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements).

          * Asegúrate de tener tu New Relic <InlinePopover type="licenseKey"/>. Puede configurar una cuenta gratuita, no se requiere tarjeta de crédito.

          * Asegúrese de que el dominio dockerhub de newrelic (`https://hub.docker.com/u/newrelic`) y el registro de Google (`registry.k8s.io`) estén agregados a su lista de 'permitidos'. Aquí es de donde la instalación extraerá las imágenes del contenedor. Tenga en cuenta que es posible que deba seguir los [comandos](https://kubernetes.io/blog/2023/03/10/image-registry-redirect/#how-can-i-check-if-i-am-impacted) para identificar el dominio de registro de Google adicional que se agregará a su lista blanca, porque `registry.k8s.io` generalmente redirige a su dominio de registro local (por ejemplo, `asia-northeast1-docker.pkg.dev`) según su región.

            Si está instalando nuestra integración en una nube administrada, consulte estas [notas preliminares](#cloud-platforms) antes de continuar:

            <CollapserGroup>
              <Collapser
                className="freq-link"
                id="install-amazon-eks"
                title={<><img src={kubernetesEks} alt="EKS" style={{ verticalAlign: 'middle' }}>Amazon EKS / EKS Anywhere / EKS Anywhere en metal desnudo</img></>}
              >
                La integración Kubernetes solo monitorea los nodos trabajadores en Amazon EKS, ya que Amazon abstrae la administración de los nodos maestros de la plataforma Kubernetes .

                Antes de utilizar nuestra instalación guiada para desplegar la integración Kubernetes en Amazon EKS, asegúrese de instalar `eksctl`, la [herramienta de línea de comando](https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html) para administrar clúster de Kubernetes en Amazon EKS.
              </Collapser>

              <Collapser
                className="freq-link"
                id="install-google-kubernetes-engine"
                title={<><img src={kubernetesCke} alt="CKE" style={{ verticalAlign: 'middle' }}>Motor Google Kubernetes (estándar GKE)</img></>}
              >
                La integración de Kubernetes solo monitorea los nodos trabajadores en GKE, ya que Google abstrae la gestión de los nodos maestros de la plataforma Kubernetes .

                Antes de comenzar nuestra instalación guiada para implementar la integración Kubernetes en GKE, asegúrese de tener permisos suficientes:

                1. Vaya a [console.cloud.google.com/iam-admin/iam](https://console.cloud.google.com/iam-admin/iam) y encuentra tu nombre de usuario.

                2. Haga clic en

                   <DoNotTranslate>**edit**</DoNotTranslate>

                   .

                3. Asegúrese de tener permisos para crear `Roles` y `ClusterRoles`: si no está seguro, agregue el rol

                   <DoNotTranslate>**Kubernetes Engine Cluster Admin**</DoNotTranslate>

                   . Si no puede editar su rol de usuario, solicite al propietario del proyecto GCP que le otorgue los permisos necesarios.
              </Collapser>

              <Collapser
                className="freq-link"
                id="install-openshift-container-platform"
                title={<><img src={kubernetesOpenshift} alt="OpenShift" style={{ verticalAlign: 'middle' }}>Plataforma de contenedores OpenShift</img></>}
              >
                Para implementar la integración Kubernetes con [OpenShift](https://learn.openshift.com):

                1. Agregue las cuentas de servicio utilizadas por la integración a sus [Restricciones de contexto de seguridad](https://docs.openshift.com/enterprise/3.0/admin_guide/manage_scc.html) privilegiadas:

                   ```
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-newrelic-infrastructure
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-nrk8s-controlplane
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-kube-state-metrics
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-newrelic-logging
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-nri-kube-events
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-nri-metadata-injection-admission
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-nrk8s-controlplane
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:default
                   ```

                   <Callout variant="tip">
                     El instalador proporciona `newrelic-bundle` como predeterminado `release_name` y `newrelic` como predeterminado `namespace`.
                   </Callout>

                2. Complete los pasos de nuestra [instalación guiada](https://one.newrelic.com/nr1-core?state=51fbbd48-c8ca-ead9-bb90-af96e18d82a7).

                3. Si utiliza certificados firmados, asegúrese de que estén configurados correctamente utilizando las siguientes variables en la parte `DaemonSet` de su manifiesto. Configure el archivo `.pem` :

                   ```yaml
                   env:
                     - name: NRIA_CA_BUNDLE_DIR
                       value: YOUR_CA_BUNDLE_DIR
                     - name: NRIA_CA_BUNDLE_FILE
                       value: YOUR_CA_BUNDLE_NAME
                   ```

                4. Establezca su ruta clave YAML en `spec.template.spec.containers.name.env`.

                5. Guarde sus cambios.
              </Collapser>

              <Collapser
                className="freq-link"
                id="install-azure-aks"
                title={<><img src={kubernetesAks} alt="AKS" style={{ verticalAlign: 'middle' }}>Servicio Azure Kubernetes (AKS)</img></>}
              >
                La integración Kubernetes solo monitorea los nodos trabajadores en el servicio Azure Kubernetes , ya que Azure abstrae la administración de los nodos maestros fuera de la plataforma Kubernetes .
              </Collapser>
            </CollapserGroup>
        </Step>

        <Step>
          ## Comience la instalación guiada

          Comience su instalación guiada haciendo clic en una de las siguientes opciones:

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Opción de instalación guiada
                </th>

                <th>
                  Descripción
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  [Instalación](https://onenr.io/0oR861DvMQG)
                </td>

                <td>
                  Úselo si su organización New Relic **no** utiliza el centro de datos [de la UE](/docs/using-new-relic/welcome-new-relic/get-started/our-eu-us-region-data-centers) y no necesita el panel de control adicional y las alertas del inicio rápido.
                </td>
              </tr>

              <tr>
                <td>
                  [Instalación guiada (UE)](https://onenr.io/0VwgOqNAZwJ)
                </td>

                <td>
                  Úselo si su organización New Relic usa el centro de datos [de la UE](/docs/using-new-relic/welcome-new-relic/get-started/our-eu-us-region-data-centers) y no necesita el panel adicional y la alerta del inicio rápido.
                </td>
              </tr>

              <tr>
                <td>
                  [Instalación guiada con inicio rápido](https://one.newrelic.com/launcher/catalog-pack-details.launcher/?pane=eyJuZXJkbGV0SWQiOiJjYXRhbG9nLXBhY2stZGV0YWlscy5jYXRhbG9nLXBhY2stY29udGVudHMiLCJxdWlja3N0YXJ0SWQiOiI4OGE3OWY1Mi04MWMxLTRmYTItOTlmOC0zY2I1YjAxMmYxNjAifQ==)
                </td>

                <td>
                  Utilice esta opción si su organización New Relic **no** utiliza el centro de datos [de la UE](/docs/using-new-relic/welcome-new-relic/get-started/our-eu-us-region-data-centers) y también desea instalar un panel adicional y una alerta desde el inicio rápido.
                </td>
              </tr>
            </tbody>
          </table>
        </Step>

        <Step>
          ## Configura tu instalación

          En la página <DoNotTranslate>**Configure the Kubernetes Integration**</DoNotTranslate> complete los siguientes campos:

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Campo
                </th>

                <th>
                  Descripción
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  Enviaremos tus datos a esta cuenta
                </td>

                <td>
                  Elija la cuenta de New Relic en la que desea que se escriban sus datos de Kubernetes.
                </td>
              </tr>

              <tr>
                <td>
                  Nombre del clúster
                </td>

                <td>
                  Nombre del clúster es el nombre que usaremos para etiquetar sus datos Kubernetes para que pueda filtrar los datos específicos del clúster en el que está instalando esta integración. Esto es importante si elige conectar varios clústeres a su cuenta New Relic , así que elija un nombre que reconozca.
                </td>
              </tr>

              <tr>
                <td>
                  Namespace para la integración
                </td>

                <td>
                  Namespace for the integración es el namespace que usaremos para albergar la integración Kubernetes en su clúster. Recomendamos utilizar el namespace predeterminado de `newrelic`.
                </td>
              </tr>
            </tbody>
          </table>
        </Step>

        <Step>
          ## Seleccionar datos adicionales

          En la página <DoNotTranslate>**Select the additional data you want to gather**</DoNotTranslate>, elija las opciones adecuadas para usted:

          ### Raspe Prometheus extremo [#scrape-endpoints]

          Al seleccionar esta opción, instalaremos Prometheus en modo agente para recolectar métrica del extremo de Prometheus expuesto en su clúster. Expanda los colapsos para ver detalles sobre cada opción:

          <CollapserGroup>
            <Collapser
              className="freq-link"
              id="scrape-all-except-ksm"
              title="Raspe todo el extremo de Prometheus excepto el núcleo del sistema Kubernetes métrico (recomendado)"
            >
              Recomendamos esta configuración porque varios otros componentes de la integración Kubernetes , como [`kube-state-metrics`, `newrelic-infrastructure` y `nri-prometheus`](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle#bundled-charts) ya recopilarán estas métricas y configurar Prometheus para excluir esas métricas le ahorrará costos de ingesta de datos al eliminar cualquier redundancia métrica. .

              Esta configuración filtrará cualquier métrica que tenga el prefijo [`kube_`, `container_`, `machine_` y `cadvisor_`](https://github.com/newrelic/newrelic-prometheus-configurator/blob/64af9453f4b20d4aab88a4d1afda55cf9a6e63c4/charts/newrelic-prometheus-agent/static/lowdatamodedefaults.yaml).

              A continuación se muestra un ejemplo de `newrelic-prometheus-configurator/charts/newrelic-prometheus-agent/static/lowdatamodedefaults.yaml`:

              ```yaml
              low_data_mode:
              - action: drop
                source_labels: [__name__]
                regex: "kube_.+|container_.+|machine_.+|cadvisor_.+"
              ```
            </Collapser>

            <Collapser
              className="freq-link"
              id="scrape-all-endpoints"
              title="Raspe todo el Prometheus extremo"
            >
              Seleccione <DoNotTranslate>**Scrape all Prometheus endpoints**</DoNotTranslate> si prefiere conservar las convenciones de nomenclatura métrica de Prometheus en todas las métricas de Prometheus, independientemente de cualquier redundancia métrica.
            </Collapser>

            <Collapser
              className="freq-link"
              id="scrape-with-quickstarts"
              title="Raspe solo Prometheus extremo con inicios rápidos"
            >
              New Relic proporciona [inicios rápidos](https://newrelic.com/instant-observability/?category=prometheus&search=), que son paneles, alertas y entidades prediseñados para varios servicios. Seleccione esta opción para que Prometheus solo busque [servicios que tengan un inicio rápido prediseñado](https://github.com/newrelic/newrelic-prometheus-configurator/blob/main/charts/newrelic-prometheus-agent/values.yaml#L214-L228) y estén listos para funcionar para una observabilidad instantánea.

              A continuación se muestra un ejemplo de `newrelic-prometheus-configurator/charts/newrelic-prometheus-agent/values.yaml` que muestra en el campo `app_values` qué servicios se eliminarán para la opción de inicio rápido de Prometheus:

              ```yaml
              kubernetes:
                  # NewRelic provides a list of Dashboards, alerts and entities for several Services. The integrations_filter configuration
                  # allows to scrape only the targets having this experience out of the box.
                  # If integrations_filter is enabled, then the jobs scrape merely the targets having one of the specified labels matching
                  # one of the values of app_values.
                  # Under the hood, a relabel_configs with 'action=keep' are generated, consider it in case any custom extra_relabel_config is needed.
                  integrations_filter:
                    # -- enabling the integration filters, merely the targets having one of the specified labels matching
                    #    one of the values of app_values are scraped. Each job configuration can override this default.
                    enabled: true
                    # -- source_labels used to fetch label values in the relabel config added by the integration filters configuration
                    source_labels: ["app.kubernetes.io/name", "app.newrelic.io/name", "k8s-app"]
                    # -- app_values used to create the regex used in the relabel config added by the integration filters configuration.
                    # Note that a single regex will be created from this list, example: '.*(?i)(app1|app2|app3).*'
                    app_values: ["redis", "traefik", "calico", "nginx", "coredns", "kube-dns", "etcd", "cockroachdb", "velero", "harbor", "argocd"]
              ```
            </Collapser>

            <Collapser
              className="freq-link"
              id="custom-app-labels"
              title="Raspe solo ciertas etiquetas"
            >
              Esta opción te resultará útil si eres un usuario avanzado que tiene una buena idea de qué servicios deseas ver Prometheus métrica. Ingrese una lista separada por comas de los servicios que desea que Prometheus elimine, y Prometheus realizará una coincidencia con comodines en el nombre del servicio para encontrar su métrica desde el extremo deseado.

              Esta opción _solo_ proporcionará métricas de los servicios que coincidan con la lista enviada, así que tenga cuidado de validar la corrección de la entrada. Para obtener más información sobre la aplicación de etiquetas personalizadas, consulte [Configuración avanzada del agente Prometheus](/docs/infrastructure/prometheus-integrations/install-configure-prometheus-agent/advanced-configuration/#enable-disable-integrations).

              Los servicios que agregue a la lista enviada sobrescribirán los datos en `app_values` a continuación y Prometheus <DoNotTranslate>**only**</DoNotTranslate> eliminará métrica de esos servicios.

              A continuación se muestra un ejemplo de `newrelic-prometheus-configurator/charts/newrelic-prometheus-agent/values.yaml`:

              ```yaml
              kubernetes:
                  # NewRelic provides a list of Dashboards, alerts and entities for several Services. The integrations_filter configuration
                  # allows to scrape only the targets having this experience out of the box.
                  # If integrations_filter is enabled, then the jobs scrape merely the targets having one of the specified labels matching
                  # one of the values of app_values.
                  # Under the hood, a relabel_configs with 'action=keep' are generated, consider it in case any custom extra_relabel_config is needed.
                  integrations_filter:
                    # -- enabling the integration filters, merely the targets having one of the specified labels matching
                    #    one of the values of app_values are scraped. Each job configuration can override this default.
                    enabled: true
                    # -- source_labels used to fetch label values in the relabel config added by the integration filters configuration
                    source_labels: ["app.kubernetes.io/name", "app.newrelic.io/name", "k8s-app"]
                    # -- app_values used to create the regex used in the relabel config added by the integration filters configuration.
                    # Note that a single regex will be created from this list, example: '.*(?i)(app1|app2|app3).*'
                    app_values: ["redis", "traefik", "calico", "nginx", "coredns", "kube-dns", "etcd", "cockroachdb", "velero", "harbor", "argocd"]
              ```
            </Collapser>
          </CollapserGroup>

          ### Recopilar datos log [#gather-logs]

          Puede personalizar los detalles de los datos log dentro de la UI usuario de instalación:

          <CollapserGroup>
            <Collapser
              className="freq-link"
              id="full-enrichment"
              title="Reenviar todos los registros con enriquecimiento completo"
            >
              Si prefiere datos más sólidos, seleccione esta opción para enriquecer completamente su registro agregando datos de etiquetas y anotaciones.

              A continuación se muestra un ejemplo de un log con enriquecimiento completo de datos:

              ```json
              [
                {
                  "cluster_name": "api-test",
                  "kubernetes": {
                    "annotations": {
                      "kubernetes.io/psp": "eks.privileged"
                    },
                    "container_hash": "fryckbos/test@sha256:5b098eaf3c7d5b3585eb10cebee63665b6208bea31ef31a3f0856c5ffdda644b",
                    "container_image": "fryckbos/test:latest",
                    "container_name": "newrelic-logging",
                    "docker_id": "134e1daf63761baa15e035b08b7aea04518a0f0e50af4215131a50c6a379a072",
                    "host": "ip-192-168-17-123.ec2.internal",
                    "labels": {
                      "app": "newrelic-logging",
                      "app.kubernetes.io/name": "newrelic-logging",
                      "controller-revision-hash": "84db95db86",
                      "pod-template-generation": "1",
                      "release": "nri-bundle"
                    },
                    "namespace_name": "nrlogs",
                    "pod_id": "54556e3e-719c-46b5-af69-020b75d69bf1",
                    "pod_name": "nri-bundle-newrelic-logging-jxnbj"
                  },
                  "message": "[2021/09/14 12:30:49] [ info] [engine] started (pid=1)\n",
                  "plugin": {
                    "source": "kubernetes",
                    "type": "fluent-bit",
                    "version": "1.8.1"
                  },
                  "stream": "stderr",
                  "time": "2021-09-14T12:30:49.138824971Z",
                  "timestamp": 1631622649138
                }
              ]
              ```
            </Collapser>

            <Collapser
              className="freq-link"
              id="min-enrichment"
              title="Reenviar todos los registros con enriquecimiento mínimo (modo de datos bajos)"
            >
              Si desea priorizar los costos de ingesta de datos, puede optar por recopilar datos log con un enriquecimiento mínimo, también conocido como modo de datos bajos. Esta opción elimina etiquetas y anotaciones de su registro y solo comparte Kubernetes log datos estándar , como el nombre del clúster, contenedor, namespace y pod, junto con el mensaje y timestamp.

              Al seleccionar el modo de enriquecimiento mínimo, solo se retiene el siguiente atributo log : `cluster_name`, `container_name`, `namespace_name`, `pod_name`, `stream`, `message` y `log`.

              A continuación se muestra un ejemplo de un log con un enriquecimiento mínimo de datos:

              ```json
              [
                {
                  "cluster_name": "api-test",
                  "container_name": "newrelic-logging",
                  "namespace_name": "nrlogs",
                  "pod_name": "nri-bundle-newrelic-logging-jxnbj",
                  "message": "[2021/09/14 12:30:49] [ info] [engine] started (pid=1)\n",
                  "stream": "stderr",
                  "timestamp": 1631622649138
                }
              ]
              ```
            </Collapser>
          </CollapserGroup>

          ### Habilite información valiosa al nivel de servicio de, solicitudes de cuerpo completo y perfiles de aplicaciones a través de Pixie [#enable-pixie]

          [Pixie](https://docs.px.dev/about-pixie/what-is-pixie/) es una herramienta de observabilidad de código abierto para la aplicación Kubernetes que utiliza eBPF para recopilar automáticamente telemetry data. Si no tiene Pixie instalado en su clúster, pero desea aprovechar la poderosa recopilación y visualización telemetry data de Pixie en la [plataforma New Relic ](/docs/kubernetes-pixie/auto-telemetry-pixie/get-started-auto-telemetry-pixie/), consulte <DoNotTranslate>**Enable service-level insights, full-body requests, and application profiles through Pixie**</DoNotTranslate>.

          Si ya estás utilizando Community Cloud, selecciona <DoNotTranslate>**Community Cloud hosted Pixie is already running on this cluster**</DoNotTranslate>. Tenga en cuenta lo siguiente sobre las diferentes formas en que [se puede alojar Pixie](https://docs.px.dev/installing-pixie/install-guides/#title). New Relic proporciona un nivel diferente de soporte de integración para cada opción de alojamiento de Pixie.

          <CollapserGroup>
            <Collapser
              className="freq-link"
              id="community-cloud-pixie"
              title="Duendecillo de la nube comunitaria"
            >
              Si ya estás aprovechando la nube comunitaria de Pixie, puedes proporcionar una clave de API para conectar Pixie a New Relic. Este enfoque integrará en vivo de Pixie UI en su New Relic cuenta para un fácil acceso (a través de la herramienta de depuración en vivo de Pixie), además de escribir datos de Pixie en New Relic a través del New Relic OpenTelemetry extremo .

              <img
                title="service graph in live debugger"
                alt="service-graph"
                src={pixieLiveDebugging}
              />
            </Collapser>

            <Collapser
              className="freq-link"
              id="self-hosted-pixie"
              title="Pixie autohospedado"
            >
              Si estás usando Pixie con una Pixie Cloud autohospedada, también puedes conectar Pixie a New Relic. Este enfoque permitirá la exportación de telemetry data de Pixie a New Relic a través del extremo OpenTelemetry para la retención de datos y visibilidad a largo plazo. Desafortunadamente, si aloja usted mismo su Pixie Cloud, New Relic no admite la integración de UI en vivo de Pixie.

              Si aloja Pixie Cloud por su cuenta y desea habilitar la exportación de telemetry data de Pixie a New Relic, simplemente habilite Pixie en la integración Kubernetes sin marcar <DoNotTranslate>**Community Cloud hosted Pixie option**</DoNotTranslate>. La integración Kubernetes detectará que Pixie se está ejecutando en su clúster y permitirá la exportación de datos para visibilidad instantánea de datos e información valiosa.

              <img
                title="The OpenTelemetry <DoNotTranslate>**Service map**</DoNotTranslate> view shows helps visualize your application's dependencies."
                alt="The OpenTelemetry <DoNotTranslate>**Service map**</DoNotTranslate> view shows helps visualize your application's dependencies."
                src={pixieServiceOtelMap}
              />
            </Collapser>
          </CollapserGroup>
        </Step>

        <Step>
          ## Termina tu instalación

          Finalice la configuración de instalación de Kubernetes eligiendo uno de los siguientes métodos de instalación en el último paso de la instalación guiada:

          * <DoNotTranslate>**Guided Install (recommended)**</DoNotTranslate>: esta opción descargará y utilizará automáticamente la CLI [`newrelic-cli`](https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/) para instalar y configurar la integración de Kubernetes.

          * <DoNotTranslate>**Helm 3**</DoNotTranslate>: utilice esta opción si prefiere utilizar [Helm](https://helm.sh/) para instalar y configurar la integración de Kubernetes. Esta opción instala el [gráfico de Helm`nri-bundle` ](/docs/kubernetes-pixie/kubernetes-integration/installation/install-kubernetes-integration-using-helm/#install-k8-helm), que puede configurar aún más con las opciones que se describen [aquí](/docs/kubernetes-pixie/kubernetes-integration/installation/install-kubernetes-integration-using-helm/#configure).

          * <DoNotTranslate>**Manifest**</DoNotTranslate>: seleccione esta opción si prefiere generar un manifiesto de Kubernetes en formato YAML e instalarlo manualmente con [`kubectl`](https://kubernetes.io/docs/reference/kubectl/).

            <Callout variant="tip">
              ¿No ves datos? Si completó los pasos anteriores y aún no ve datos, consulte [esta página de resolución de problemas](/docs/kubernetes-pixie/kubernetes-integration/troubleshooting/kubernetes-integration-troubleshooting-not-seeing-data/).
            </Callout>
        </Step>
      </Steps>
    </TabsPageItem>

    <TabsPageItem id="windows-install">
      Utilice esta opción cuando tenga un sistema Kubernetes basado en Windows. Tenga en cuenta que existen [varias limitaciones](/docs/kubernetes-pixie/kubernetes-integration/installation/install-version2-kubernetes-integration-windows/#k8-windows-limitations) para la integración de Windows.

      <Callout title="avance">
        Esta característica se encuentra actualmente en versión preliminar.
      </Callout>

      ## Compatibilidad y requisitos [#k8-windows-req]

      Antes de instalar la [integración de Kubernetes](/docs/integrations/kubernetes-integration/get-started/introduction-kubernetes-integration), revise la [compatibilidad y los requisitos](/docs/integrations/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements).

      <Callout variant="important">
        Cuando se utiliza contenedor en Windows, la versión del host del contenedor y la versión de la imagen del contenedor deben ser las mismas. Nuestra integración de Kubernetes puede ejecutarse en las versiones de Windows LTSC 2019 (1809), 20H2 y LTSC 2022.
      </Callout>

      Para verificar su versión de Windows:

      1. Abra una ventana de comando.

      2. Ejecute el siguiente comando:

         ```shell
         Reg Query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v
         ReleaseIdcmd.exe
         ```

      ### Ejemplo: obtener Kubernetes para Windows desde un contenedor BusyBox [#example-k8s-windows-busybox]

      Ejecute este comando:

      ```shell
      kubectl exec -it busybox1-766bb4d6cc-rmsnj -- Reg Query
      "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v ReleaseId
      ```

      Debería ver algo como esto:

      ```shell
      HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion
      ReleaseId	REG_SZ	1809
      ```

      Para obtener un mapeo útil entre los ID de versión y las versiones del sistema operativo, consulte [aquí](https://hub.docker.com/_/microsoft-windows-servercore).

      ## Instalar [#k8-windows-install]

      Puede instalar la integración de Kubernetes para Windows usando Helm. Vea un ejemplo sobre cómo instalar la integración en un clúster con nodos que tienen diferentes versiones de compilación de Windows (1809 y 2004):

      1. Agregue el repositorio de gráficos de New Relic Helm:

         ```shell
         helm repo add newrelic https://helm-charts.newrelic.com
         ```

      2. Crea un namespace para newrelic:

         ```shell
         kubectl create namespace newrelic
         ```

      3. Instalar kube-state-métrica.

         ```shell
         helm repo add ksm https://kubernetes.github.io/kube-state-metrics
         helm install ksm ksm/kube-state-metrics --version 2.13.2
         ```

         <Callout variant="important">
           Este comando es para instalar kube-state-métrica, una dependencia obligatoria de la integración, en un nodo Linux. No admitimos la instalación de esto para nodos que no sean Linux y, si lo instala en un nodo que no sea Linux, la implementación podría fallar. Recomendamos utilizar `nodeSelector` para elegir un nodo de Linux. Esto se puede hacer editando kube-state-desplegable.
         </Callout>

      4. Cree un archivo `values-newrelic.yaml` con los siguientes datos para que Helm los utilice:

         ```yaml
         global:
           licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
           cluster: _K8S_CLUSTER_NAME_

         enableLinux: true        # Set to true if your cluster also has linux nodes
         enableWindows: true
         windowsOsList:
           - version: 2019            # Human-readable version identifier
             imageTag: 2-windows-1809-alpha  # Tag to be used for nodes running the windows version above
             buildNumber: 10.0.17763         # Build number for your nodes running the version above. Used as a selector.
           - version: 20h2
             imageTag: 2-windows-20H2-alpha
             buildNumber: 10.0.19042
           - version: 2022
             imageTag: 2-windows-ltsc2022-alpha
             buildNumber: 10.0.20348
         nodeSelector:
           kubernetes.io/os: linux         # Selector for Linux installation.
         windowsNodeSelector:
           kubernetes.io/os: windows       # Selector for Windows installation.
         ```

      5. Instale la integración con:

         ```shell
         helm upgrade --install newrelic newrelic/newrelic-infrastructure \
         --namespace newrelic --create-namespace \
         --version 2.7.2 \
         -f values-newrelic.yaml
         ```

      6. Verifique que los pods se estén desplegando y alcancen un estado estable:

         ```shell
         kubectl -n newrelic get pods -w
         ```

      El gráfico Helm creará un DaemonSet por cada versión de Windows que esté en la lista y usará NodeSelector para desplegar el pod correspondiente por nodo.

      ## Limitaciones [#k8-windows-limitations]

      Se aplican las siguientes limitaciones a la integración de Kubernetes para Windows:

      * El agente de Windows solo envía las [muestras de Kubernetes](/docs/integrations/kubernetes-integration/understand-use-data/understand-use-data#event-types) (`K8sNodeSample`, `K8sPodSample`, etc.)

        * `SystemSample`, `StorageSample`, `NetworkSample` y `ProcessSample` no se generan.
        * Faltan algunas [Kubernetes métricas](/docs/integrations/kubernetes-integration/understand-use-data/understand-use-data#metrics) porque el kubelet de Windows no las tiene:

      * Nodo:

        * `fsInodes`: no enviado
        * `fsInodesFree`: no enviado
        * `fsInodesUsed`: no enviado
        * `memoryMajorPageFaultsPerSecond`: siempre devuelve cero como valor
        * `memoryPageFaults`: siempre devuelve cero como valor
        * `memoryRssBytes`: siempre devuelve cero como valor
        * `runtimeInodes`: no enviado
        * `runtimeInodesFree`: no enviado
        * `runtimeInodesUsed`: no enviado

      * Pod:

        * `net.errorsPerSecond`: no enviado
        * `net.rxBytesPerSecond`: no enviado
        * `net.txBytesPerSecond`: no enviado

      * Contenedor:

        * `containerID`: no enviado
        * `containerImageID`: no enviado
        * `memoryUsedBytes`: en la UI, esto se muestra en la tarjeta pod que aparece cuando haces clic en un pod y no mostrará datos. Pronto solucionaremos este problema actualizando nuestros gráficos para utilizar `memoryWorkingSetBytes` en su lugar.

      * Volumen:

        * `fsUsedBytes`: cero, entonces `fsUsedPercent` es cero

      ## Problemas conocidos con Windows Kubelet [#k8-windows-limitations]

      Hay un par de problemas con la versión de Windows de Kubelet que pueden impedir que la integración obtenga datos:

      * [Problema 90554:](https://github.com/kubernetes/kubernetes/pull/90554) Este problema hace que Kubelet devuelva 500 errores cuando la integración realiza una solicitud al extremo `/stats/summary` . Se incluirá en la versión Kubernetes 1.19 y se ha compatible con las versiones 1.16.11. 1.17.7 y 1.18.4. No existe una solución para este problema en el lado de la integración; le recomendamos que actualice a una de las versiones del parche lo antes posible. Puedes ver si este problema te afecta [habilitando el registro detallado](/docs/integrations/kubernetes-integration/troubleshooting/get-logs-version#verbose) y buscando mensajes del tipo:

      ```shell
      error querying Kubelet. Get "https://<KUBELET_IP>/stats/summary": error calling kubelet endpoint. Got status code: 500
      ```

      * [Problema 87730:](https://github.com/kubernetes/kubernetes/pull/87730) Este problema hace que Kubelet métrica sea muy lento cuando se ejecuta con una carga mínima. Hace que la integración falle con un error de tiempo de espera. Se agregó un parche para este problema para Kubernetes 1.18 y se actualizó a 1.15.12. 1.16.9 y 1.17.5. Le recomendamos que actualice a una de las versiones del parche lo antes posible. Para mitigar este problema, puede aumentar el tiempo de espera de integración con la [opción de configuración`TIMEOUT` ](/docs/integrations/kubernetes-integration/installation/kubernetes-integration-install-configure#kube-state-metrics-timeout-change). Puedes ver si este problema te afecta [habilitando el registro detallado](/docs/integrations/kubernetes-integration/troubleshooting/get-logs-version#verbose) y buscando mensajes del tipo:

      ```shell
      error querying Kubelet. Get "https://<KUBELET_IP>/stats/summary": context deadline exceeded (Client.Timeout exceeded while awaiting headers)
      ```
    </TabsPageItem>

    <TabsPageItem id="eks-fargate">
      Utilice esta opción cuando monitoree la carga de trabajo Kubernetes en EKS Fargate. Esta integración inyecta automáticamente un sidecar que contiene el agente de infraestructura y la integración nri-Kubernetes en cada pod que necesita ser monitoreado.

      <Callout title="Avance">
        Esta característica se encuentra actualmente en versión preliminar.
      </Callout>

      New Relic admite el monitoreo de carga de trabajo Kubernetes en EKS Fargate al inyectar automáticamente un sidecar que contiene el agente de infraestructura y la integración `nri-kubernetes` en cada pod que necesita ser monitoreado.

      Si el mismo clúster de Kubernetes también contiene nodos EC2, nuestra solución también será desplegar como `DaemonSet` en todos ellos. No se inyectará ningún sidecar en el módulo programado en los nodos EC2 y no se desplegará ningún `DaemonSet` en los nodos Fargate. A continuación se muestra un ejemplo de una instancia híbrida con nodos Fargate y EC2:

      <img
        title="Diagram showing an EKS cluster with Fargate and EC2 nodes"
        alt="Diagram showing an EKS cluster with Fargate and EC2 nodes"
        src={kubernetesFargateOverview}
      />

      <figcaption>
        En un entorno mixto, la integración solo utiliza un sidecar para los nodos Fargate.
      </figcaption>

      New Relic recopila todas las métricas admitidas para todos los objetos Kubernetes independientemente de dónde estén programados, ya sean nodos Fargate o EC2. Tenga en cuenta que, debido a las limitaciones impuestas por Fargate, la integración de New Relic se limita a ejecutarse en modo [sin privilegios](/docs/integrations/kubernetes-integration/installation/kubernetes-integration-install-configure/#unprivileged) en los nodos de Fargate. Esto significa que las métricas que generalmente se obtienen directamente del host, como los procesos en ejecución, no estarán disponibles para los nodos Fargate.

      El agente en ambos escenarios extraerá datos de Kube State métrica (KSM), Kubelet y cAdvisor y los enviará en el mismo formato.

      <Callout variant="important">
        Al igual que con cualquier otro clúster de Kubernetes, nuestra solución aún requiere que despliegue y monitor una instancia de Kube State métrica (KSM). Nuestro Helm Chart y/o nuestro instalador lo harán automáticamente de forma predeterminada, aunque este comportamiento se puede desactivar si su clúster ya tiene una instancia funcional de KSM. Esta instancia de KSM se monitoreará como cualquier otra carga de trabajo: inyectando un sidecar si se programa en un nodo Fargate o con la instancia local del `DaemonSet` si se programa en un nodo EC2.
      </Callout>

      Otros componentes de la solución New Relic para Kubernetes, como `nri-prometheus`, `nri-metadata-injection` y `nri-kube-events`, no tienen ninguna particularidad y se desplegarán mediante nuestro Helm Chart normalmente como lo harían en entornos que no son de Fargate.

      ## Instalacion [#installation]

      Puede elegir entre dos alternativas para instalar la observabilidad total de New Relic en su clúster EKS Fargate:

      * [Inyección automática (recomendado)](#automatic)
      * [Inyección manual](#manual)

      Independientemente del enfoque que elija, la experiencia es exactamente la misma después de su instalación. La única diferencia es cómo se inyecta el contenedor. Recomendamos configurar la inyección automática con el operador de monitoreo de infraestructura New Relic porque eliminará la necesidad de editar manualmente cada despliegue que desee monitor.

      ### Inyección automática (recomendado) [#automatic]

      De forma predeterminada, cuando el soporte de Fargate está habilitado, New Relic desplegará un operador en el clúster (`newrelic-infra-operator`). Una vez implementado, este operador inyectará automáticamente el sidecar de monitoreo en los pods que están programados en los nodos de Fargate, mientras también administra la creación y actualización de `Secrets`, `ClusterRoleBindings` y cualquier otro recurso relacionado.

      Este operador acepta una variedad de opciones de configuración avanzadas que se pueden usar para limitar o ampliar el alcance de la inyección, mediante el uso de selectores de etiquetas tanto para el pod como para el espacio de nombres.

      #### Que hace el operador [#what-operator-does]

      Detrás de escena, el operador configura un `MutatingWebhookConfiguration`, que le permite modificar los objetos del pod que están a punto de crearse en el clúster. En este evento, y cuando el pod que se está creando coincida con la configuración del usuario, el operador:

      1. Agregue un contenedor sidecar al pod que contiene la integración de New Relic Kubernetes.

      2. Si no existe un secreto, cree uno en el mismo namespace que el pod que contiene la New Relic

         <InlinePopover type="licenseKey"/>

         , que es necesaria para que el sidecar informe datos.

      3. Agregue la cuenta de servicio del pod a un `ClusterRoleBinding` creado previamente por el gráfico del operador, lo que otorgará a este sidecar los permisos necesarios para alcanzar el extremo métrico Kubernetes .

      El `ClusterRoleBinding` otorga los siguientes permisos al pod que se inyecta:

      ```yml

      rules:
      - apiGroups: [""]
        resources:
        - "nodes"
        - "nodes/metrics"
        - "nodes/stats"
        - "nodes/proxy"
        - "pods"
        - "services"
        - "namespaces"
        verbs: ["get", "list"]
      - nonResourceURLs: ["/metrics"]
        verbs: ["get"]

      ```

      <Callout variant="tip">
        Para que el sidecar pueda inyectarse y, por tanto, obtener la métrica del pod desplegar antes de que se haya instalado el operador, es necesario realizar manualmente un despliegue (reinicio) del despliegue afectado. De esta manera, cuando se creen los pod, el operador podrá inyectar el sidecar de monitoreo. New Relic ha optado por no hacer esto automáticamente para evitar interrupciones inesperadas del servicio y picos de uso de recursos.
      </Callout>

      <Callout variant="important">
        Recuerda crear un perfil de Fargate con un selector que declare el namespace `newrelic` (o el namespace que elijas para la instalación).
      </Callout>

      Aquí está el flujo de trabajo de inyección:

      <img
        title="Diagram showing the workflow of sidecar injection"
        alt="Diagram showing the workflow of sidecar injection"
        src={kubernetesFargateWorkflow}
      />

      #### Instalación de inyección automática [#auto-injection-install]

      <Callout variant="tip">
        Los siguientes pasos son para una configuración predeterminada. Antes de completarlos, le sugerimos que eche un vistazo a la sección [de configuración](#config-auto) a continuación para ver si desea modificar algún aspecto de la inyección automática.
      </Callout>

      Primero, agregue el repositorio New Relic Helm si no lo ha hecho antes:

      ```shell
      helm repo add newrelic https://helm-charts.newrelic.com
      ```

      Luego, para instalar el operador encargado de inyectar el sidecar de infraestructura, cree un archivo llamado `values.yaml`, que se utilizará para definir su configuración:

      ```yaml
      ## Global values
      global:
        # -- The cluster name for the Kubernetes cluster.
        cluster: "_YOUR_K8S_CLUSTER_NAME_"

        # -- The license key for your New Relic Account. This will be preferred configuration option if both `licenseKey` and `customSecret` are specified.
        licenseKey: "_YOUR_NEW_RELIC_LICENSE_KEY_"

        # -- (bool) In each integration it has different behavior. Enables operating system metric collection on each EC2 K8s node. Not applicable to Fargate nodes.
        # @default -- false
        privileged: true

        # -- (bool) Must be set to `true` when deploying in an EKS Fargate environment
        # @default -- false
        fargate: true

      ## Enable nri-bundle sub-charts

      newrelic-infra-operator:
        # Deploys the infrastructure operator, which injects the monitoring sidecar into Fargate pods
        enabled: true
        tolerations: 
        - key: "eks.amazonaws.com/compute-type"
          operator: "Equal"
          value: "fargate"
          effect: "NoSchedule"
        config:
          ignoreMutationErrors: true
          infraAgentInjection:
            # Injection policies can be defined here.  See [values file](https://github.com/newrelic/newrelic-infra-operator/blob/main/charts/newrelic-infra-operator/values.yaml#L114-L125) for more detail.
            policies:
            - namespaceName: namespace-a
            - namespaceName: namespace-b

      newrelic-infrastructure:
        # Deploys the Infrastructure Daemonset to EC2 nodes.  Disable for Fargate-only clusters.
        enabled: true

      nri-metadata-injection:
        # Deploy our mutating admission webhook to link APM and Kubernetes entities
        enabled: true

      kube-state-metrics:
        # Deploys Kube State Metrics.  Disable if you are already running KSM in your cluster.
        enabled: true

      nri-kube-events:
        # Deploy the Kubernetes events integration.
        enabled: true

      newrelic-logging:
        # Deploys the New Relic's Fluent Bit daemonset to EC2 nodes.  Disable for Fargate-only clusters.
        enabled: true

      newrelic-prometheus-agent:
        # Deploys the Prometheus agent for scraping Prometheus endpoints.
        enabled: true
        config:
          kubernetes:
            integrations_filter:
              enabled: true
              source_labels: ["app.kubernetes.io/name", "app.newrelic.io/name", "k8s-app"]
              app_values: ["redis", "traefik", "calico", "nginx", "coredns", "kube-dns", "etcd", "cockroachdb", "velero", "harbor", "argocd", "istio"]
      ```

      Finalmente, después de crear y modificar el archivo, puede desplegar la solución usando el siguiente comando de Helm:

      ```shell
      helm upgrade --install newrelic-bundle newrelic/nri-bundle -n newrelic --create-namespace -f values.yaml
      ```

      <Callout variant="important">
        Cuando implemente la solución en un clúster híbrido (con nodos EC2 y Fargate), asegúrese de que la solución no esté seleccionada por ningún perfil de Fargate; de lo contrario, la instancia `DaemonSet` quedará bloqueada en un estado pendiente. Para entornos exclusivos de Fargate, esto no es una preocupación porque no se crea ninguna instancia `DaemonSet` .
      </Callout>

      #### Configuración [#config-auto]

      Puedes configurar diferentes aspectos de la inyección automática. De forma predeterminada, el operador inyectará el sidecar de monitoreo en todos los pods desplegar en los nodos de Fargate que no formen parte de un `Job` o un `BatchJob`.

      Este comportamiento se puede cambiar a través de las opciones de configuración. Por ejemplo, puede definir selectores para limitar o ampliar la selección de pods que se inyectan, asignar recursos al operador y ajustar el sidecar. Además, puedes agregar otros atributos, etiquetas y variables de entorno. Consulte el gráfico [README.md](https://github.com/newrelic/helm-charts/blob/master/charts/newrelic-infra-operator/README.md) y [values.yaml](https://github.com/newrelic/helm-charts/blob/master/charts/newrelic-infra-operator/values.yaml).

      <Callout variant="important">
        Al especificar sus propias reglas de inyección personalizadas, se descartará el conjunto de reglas predeterminado que impide la inyección de sidecar en pods que no están programados en Fargate. Asegúrese de que sus reglas personalizadas tengan el mismo efecto; de lo contrario, en el clúster híbrido que también tiene `DaemonSet` desplegar, el pod programado en EC2 se monitoreará dos veces, lo que generará datos incorrectos o duplicados.
      </Callout>

      #### Actualizar a la última versión o a una nueva configuración [#update-auto-install-version]

      Para actualizar a la última versión de la integración EKS Fargate, actualice el repositorio Helm usando `helm repo update newrelic` y reinstale el paquete simplemente ejecutando nuevamente el comando anterior.

      Para actualizar la configuración del agente de infraestructura inyectado o del propio operador, modifique `values-newrelic.yaml` y actualice la versión de Helm con la nueva configuración. El operador se actualiza inmediatamente y su carga de trabajo quedará instrumentada con la nueva versión en su próximo reinicio. Si deseas actualizarlos inmediatamente, puedes forzar un reinicio de tu carga de trabajo ejecutando:

      ```shell
      kubectl rollout restart deployment YOUR_APP
      ```

      #### Desinstalar la integración de Fargate [#uninstall-auto-injection]

      Para desinstalar el sidecar que realiza la inyección automática pero conservar el resto de la solución New Relic, usando Helm, desactive el infraoperador configurando `infra-operator.enabled` en `false`, ya sea en el archivo `values.yaml` o en la línea de comando (`--set`) y vuelva a ejecutar el comando de instalación anterior.

      Recomendamos encarecidamente mantener el indicador `--set global.fargate=true` , ya que no habilita la inyección automática pero hace que otros componentes de la instalación sean compatibles con Fargate, evitando comportamientos no deseados.

      Para desinstalar toda la solución:

      1. Desinstale completamente la versión Helm.

      2. Despliegue la cápsula para quitar el sidecar:

         ```shell
         kubectl rollout restart deployment YOUR_APP
         ```

      3. Basura recoge los secretos:

         ```shell
         kubectl delete secrets -n YOUR_NAMESPACE -l newrelic/infra-operator-created=true
         ```

      #### Limitaciones conocidas: inyección automática [#known-limitations]

      A continuación se detallan algunas cuestiones que debe tener en cuenta al utilizar la inyección automática:

      1. Actualmente no existe ningún controlador que vigile todo el clúster para asegurarse de que los secretos que ya no son necesarios se recopilen como basura. Sin embargo, todos los objetos comparten la misma etiqueta que puedes usar para eliminar todos los recursos, si es necesario. Inyectamos la etiqueta `newrelic/infra-operator-created: true`, que puedes usar para eliminar recursos con un solo comando.
      2. Por el momento, no es posible utilizar el sidecar inyectado para monitor los servicios que se ejecutan en el pod. El sidecar solo monitor el propio Kubernetes . Sin embargo, es posible que el usuario avanzado desee excluir estos pods de la inyección automática e inyectar manualmente una versión personalizada del sidecar con la integración en el host habilitada configurándolos y montando su configuración en el lugar adecuado. Para obtener ayuda, consulte este [tutorial](/docs/integrations/kubernetes-integration/link-apps-services/tutorial-monitor-redis-running-kubernetes/).

      ### Inyección manual [#manual]

      Si tiene alguna inquietud sobre la inyección automática, puede inyectar el sidecar manualmente directamente modificando los manifiestos de la carga de trabajo programada que se programarán en los nodos Fargate. Tenga en cuenta que agregar el sidecar al despliegue programado en los nodos EC2 puede generar datos incorrectos o duplicados, especialmente si esos nodos ya se están monitoreando con `DaemonSet`.

      Se requieren los siguientes objetos para que el sidecar informe datos correctamente:

      * El `ClusterRole` que proporciona el permiso necesario para la integración `nri-kubernetes`
      * Un `ClusterRoleBinding` que vincula el `ClusterRole` y la cuenta de servicio del pod
      * El secreto que almacena la New Relic `licenseKey` en cada namespacede Fargate
      * El contenedor sidecar en la plantilla de especificaciones del monitor carga de trabajo

      #### Instalación de inyección manual [#manual-injection-install]

      <Callout variant="tip">
        Estos pasos de configuración manual son para una instalación genérica. Antes de completarlos, eche un vistazo a la sección [de configuración](#config-manual) a continuación para ver si desea modificar algún aspecto de la inyección automática.
      </Callout>

      Complete lo siguiente para la inyección manual:

      1. Si `ClusterRole` no existe, créelo y otorgue los permisos necesarios para alcanzar la métrica extrema. Esto sólo necesita hacerse una vez, incluso para monitoreo de múltiples aplicaciones en el mismo clúster.

         <CollapserGroup>
           <Collapser
             id="cluster-role"
             title="Función del clúster"
           >
             Puede utilizar este fragmento tal como aparece a continuación, sin ningún cambio:

             ```yml
             apiVersion: rbac.authorization.k8s.io/v1
             kind: ClusterRole
             metadata:
               labels:
                 app: newrelic-infrastructure
               name: newrelic-newrelic-infrastructure-infra-agent
             rules:
             - apiGroups:
               - ""
               resources:
               - nodes
               - nodes/metrics
               - nodes/stats
               - nodes/proxy
               - pods
               - services
               verbs:
               - get
               - list
             - nonResourceURLs:
               - /metrics
               verbs:
               - get
             ```
           </Collapser>
         </CollapserGroup>

      2. Para cada carga de trabajo que desee monitor, agregue un contenedor adicional para la imagen `newrelic/infrastructure-k8s`. A continuación se muestra un ejemplo de un sidecar inyectado.

         <CollapserGroup>
           <Collapser
             id="container-to-inject"
             title="Contenedor para inyectar"
           >
             Toma el contenedor del siguiente fragmento e inyéctalo en la carga de trabajo que deseas monitor, especificando el nombre de tu `FargateProfile` en la variable `customAttributes`. Tenga en cuenta que los volúmenes se pueden definir como `emptyDir: {}`.

             <Callout variant="tip">
               En el caso especial de un KSM implementado, también debe eliminar la variable de entorno `DISABLE_KUBE_STATE_METRICS` y aumentar las solicitudes y límites de recursos.
             </Callout>

             ```yml
             apiVersion: apps/v1
             kind: Deployment
             spec:
             template:
             spec:
             containers:
             - name: newrelic-infrastructure
               env:
               - name: NRIA_LICENSE_KEY
                 valueFrom:
                   secretKeyRef:
                     key: license
                     name: newrelic-newrelic-infrastructure-config
               - name: NRIA_VERBOSE
                 value: "1"
               - name: DISABLE_KUBE_STATE_METRICS
                 value: "true"
               - name: CLUSTER_NAME
                 value: testing-injection
               - name: COMPUTE_TYPE
                 value: serverless
               - name: NRK8S_NODE_NAME
                 valueFrom:
                   fieldRef:
                     apiVersion: v1
                     fieldPath: spec.nodeName
               - name: NRIA_DISPLAY_NAME
                 valueFrom:
                   fieldRef:
                     apiVersion: v1
                     fieldPath: spec.nodeName
               - name: NRIA_CUSTOM_ATTRIBUTES
                 value: '{"clusterName":"$(CLUSTER_NAME)", "computeType":"$(COMPUTE_TYPE)", "fargateProfile":"[YOUR FARGATE PROFILE]"}'
               - name: NRIA_PASSTHROUGH_ENVIRONMENT
                 value: KUBERNETES_SERVICE_HOST,KUBERNETES_SERVICE_PORT,CLUSTER_NAME,CADVISOR_PORT,NRK8S_NODE_NAME,KUBE_STATE_METRICS_URL,KUBE_STATE_METRICS_POD_LABEL,TIMEOUT,ETCD_TLS_SECRET_NAME,ETCD_TLS_SECRET_NAMESPACE,API_SERVER_SECURE_PORT,KUBE_STATE_METRICS_SCHEME,KUBE_STATE_METRICS_PORT,SCHEDULER_ENDPOINT_URL,ETCD_ENDPOINT_URL,CONTROLLER_MANAGER_ENDPOINT_URL,API_SERVER_ENDPOINT_URL,DISABLE_KUBE_STATE_METRICS,DISCOVERY_CACHE_TTL
               image: newrelic/infrastructure-k8s:2.4.0-unprivileged
               imagePullPolicy: IfNotPresent
               resources:
                 limits:
                   memory: 100M
                   cpu: 200m
                 requests:
                   cpu: 100m
                   memory: 50M
               securityContext:
                 allowPrivilegeEscalation: false
                 readOnlyRootFilesystem: true
                 runAsUser: 1000
               terminationMessagePath: /dev/termination-log
               terminationMessagePolicy: File
               volumeMounts:
               - mountPath: /var/db/newrelic-infra/data
                 name: tmpfs-data
               - mountPath: /var/db/newrelic-infra/user_data
                 name: tmpfs-user-data
               - mountPath: /tmp
                 name: tmpfs-tmp
               - mountPath: /var/cache/nr-kubernetes
                 name: tmpfs-cache
             [...]
             ```
           </Collapser>
         </CollapserGroup>

      3. Cree un `ClusterRoleBinding`, o agregue a uno creado previamente el `ServiceAccount` de la aplicación que se va a monitorear. Todas las cargas de trabajo pueden compartir el mismo `ClusterRoleBinding`, pero a él se le deben sumar los `ServiceAccount` de cada una.

         <CollapserGroup>
           <Collapser
             id="cluster-role-binding"
             title="Enlace de roles de clúster"
           >
             Crea el siguiente `ClusterRoleBinding` que tenga como asunto la cuenta de servicio del pod que deseas monitor.

             <Callout variant="tip">
               No es necesario repetir la misma cuenta de servicio dos veces. Cada vez que desee monitor un pod con una cuenta de servicio que aún no está incluida, simplemente agréguelo a la lista.
             </Callout>

             ```yml
             apiVersion: rbac.authorization.k8s.io/v1
             kind: ClusterRoleBinding
             metadata:
               name: newrelic-newrelic-infrastructure-infra-agent
             roleRef:
               apiGroup: rbac.authorization.k8s.io
               kind: ClusterRole
               name: newrelic-newrelic-infrastructure-infra-agent
             subjects:
             - kind: ServiceAccount
               name: [INSERT_SERVICE_ACCOUNT_NAME_OF_WORKLOAD]
               namespace: [INSERT_SERVICE_ACCOUNT_NAMESPACE_OF_WORKLOAD]
             ```
           </Collapser>
         </CollapserGroup>

      4. Crea un secreto que contenga la New Relic <InlinePopover type="licenseKey"/>. Cada namespace necesita su propio secreto.

         <CollapserGroup>
           <Collapser
             id="secret"
             title="Secreto"
           >
             Cree el siguiente `Secret` que tenga una licencia con el valor codificado en Base64 de su <InlinePopover type="licenseKey"/>. Se necesita un secreto en cada namespace donde se ejecuta un pod que desea monitor .

             ```yml
             apiVersion: v1
             data:
               license: INSERT_YOUR_NEW_RELIC_LICENSE_ENCODED_IN_BASE64
               kind: Secret
             metadata:
               name: newrelic-newrelic-infrastructure-config
               namespace: [INSERT_NAMESPACE_OF_WORKLOAD]
               type: Opaque
             ```
           </Collapser>
         </CollapserGroup>

      #### Configuración [#config-manual]

      Al agregar manualmente el manifiesto del agente complementario, puede utilizar cualquier opción de configuración del agente para configurar el comportamiento del agente. Para obtener ayuda, consulte [Valores de configuración del agente de infraestructura](/docs/infrastructure/install-infrastructure-agent/configuration/infrastructure-agent-configuration-settings/).

      #### Actualizar a la última versión [#manual-update-version]

      Para actualizar cualquiera de los componentes, solo necesitas modificar desplegar yaml.

      La actualización de cualquiera de los campos del contenedor inyectado hará que se vuelva a crear el pod.

      <Callout variant="important">
        El agente no puede cargar en caliente la New Relic <InlinePopover type="licenseKey"/>. Después de actualizar el secreto, debes implementar el despliegue nuevamente.
      </Callout>

      #### Desinstalar la integración de Fargate [#manual-uninstall]

      Para eliminar el contenedor inyectado y los recursos relacionados, sólo tienes que eliminar lo siguiente:

      * El sidecar de la carga de trabajo que ya no debería ser monitoreado.
      * Todos los secretos que contiene la licencia newrelic.
      * `ClusterRole` y `ClusterRoleBinding` objetos.

      Tenga en cuenta que eliminar el contenedor sidecar hará que se vuelva a crear el pod .

      ## Inicio sesión [#fargate-logging]

      El registro de New Relic no está disponible en los nodos de Fargate debido a restricciones de seguridad impuestas por AWS, pero aquí hay algunas opciones de registro:

      * Si estás utilizando Fluentbit para iniciar sesión, consulta [el complementoKubernetes para reenvío de registros](/docs/logs/forward-logs/kubernetes-plugin-log-forwarding/).
      * Si FireLens log ya supervisa sus datos AWS , consulte [AWS el complemento FireLens para obtener información sobre el reenvío de](/docs/logs/forward-logs/aws-firelens-plugin-log-forwarding/) registros .
      * Si sus datos log ya están siendo monitoreados por el registro de Amazon CloudWatch, consulte [Transmitir registro mediante Kinesis Data Firehose](/docs/logs/forward-logs/stream-logs-using-kinesis-data-firehose/).
      * Consulte [AWS Lambda para enviar registros de CloudWatch](/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/).
      * Consulte [Tres formas de reenviar registros de Amazon ECS a New Relic](https://newrelic.com/blog/how-to-relic/forward-logs-from-amazon-ecs-to-new-relic).

      ## Resolución de problemas [#troubleshooting]

      ### Se están implementando réplicas de DaemonSet en nodos de Fargate

      Si observa que se están programando réplicas de Infra `DaemonSet` en nodos de Fargate, es posible que se deba a que las reglas `nodeAffinity` no están configuradas correctamente.

      Vuelva a verificar que la solución se instaló con la opción `global.fargate` para `true`, ya sea a través de la línea de comando (`--set global.fargate=true`) o en el archivo `values.yaml` . Si el método de instalación no fue Helm, deberá agregar manualmente `nodeAffinity` reglas para excluir los nodos de Fargate.

      ### Evento `FailedScheduling` debido a contaminación no tolerada

      Recuerda agregar en el archivo `values.yaml` el `tolerations` descrito en [Instalación de inyección automática](#auto-injection-install) si obtienes el siguiente evento al intentar crear un pod:

      ```
      LAST SEEN | TYPE | REASON | OBJECT | MESSAGE
      :--|:--|:--|:--|:--
      3m9s (x2 over 8m10s) | Warning | FailedScheduling | Pod/no-fargate-deploy-cbddd6ccf-8f9x4 | 0/2 nodes are available: 2 node(s) had untolerated taint {eks.amazonaws.com/compute-type: fargate}. preemption: 0/2 nodes are available: 2 Preemption is not helpful for scheduling..
      ```

      ### Evento `FailedScheduling` debido a demasiados pods

      Verifique si hay un perfil de Fargate con un selector que nombre el namespace donde se realiza la instalación si obtiene el siguiente evento al intentar crear un pod:

      ```
      LAST SEEN | TYPE | REASON | OBJECT | MESSAGE
      :--|:--|:--|:--|:--
      61s | Warning | FailedScheduling | Pod/newrelic-bundle-newrelic-infra-operator-admission-create-d8ggt | 0/2 nodes are available: 2 Too many pods. preemption: 0/2 nodes are available: 2 No preemption victims found for incoming pod..
      ```

      ## Ver sus datos EKS [#view-data]

      A continuación se muestra un ejemplo de cómo se ve un nodo Fargate en la New Relic UI:

      <img
        title="Screenshot showing the Kubernetes explorer with a Fargate node"
        alt="Screenshot showing the Kubernetes explorer with a Fargate node"
        src={kubernetesFargateUi}
      />

      Para ver sus datos de AWS:

      1. Vaya a

         <DoNotTranslate>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Infrastructure > Kubernetes**</DoNotTranslate>

         y realice una de las siguientes acciones:

         * Seleccione un nombre de integración para ver los datos.
         * Seleccione el icono Explorar datos para ver los datos de AWS.

      2. Filtra tus datos usando dos etiquetas Fargate:

         * `computeType=serverless`
         * `fargateProfile=[name of the Fargate profile to which the workload belongs]`
    </TabsPageItem>

    <TabsPageItem id="man-helm">
      Si desea utilizar Helm para instalar la integración, tiene dos opciones:

      1. Nuestra experiencia de instalación guiada, que proporcionará un comando Helm con los campos obligatorios completados previamente. Esta opción también permite instalar nuestra integración como manifiestos simples en lugar de una versión de Helm.
      2. Configuración manual a través del archivo `values.yaml` . Esta pestaña le guiará sobre cómo hacerlo.

      [Helm](https://helm.sh/) es un administrador de paquetes además de Kubernetes. Facilita la instalación, actualizaciones o seguimiento de revisiones, y gestiona la dependencia de los servicios que instalas en Kubernetes. Si aún no lo ha hecho, cree su cuenta New Relic gratuita a continuación para comenzar a monitorear sus datos hoy.

      <ButtonLink
        role="button"
        to="https://onenr.io/0Y8wpoYJJQO"
        variant="primary"
      >
        Iniciar el instalador
      </ButtonLink>

      ## Compatibilidad y requisitos [#compatibility]

      Asegúrese de que [Helm](https://github.com/helm/helm#install) esté instalado en su máquina. La versión 3 de la integración de Kubernetes requiere la versión 3 de Helm.

      Para instalar la integración de Kubernetes usando Helm, necesitará su New Relic <InlinePopover type="licenseKey"/>y el nombre de su clúster de Kubernetes:

      1. Busque y copie su <InlinePopover type="licenseKey"/>.

      2. Elija un nombre para mostrar para su clúster. Por ejemplo, podría utilizar la salida de:

         ```shell
         kubectl config current-context
         ```

      <Callout variant="important">
        Guarde estos valores en un lugar seguro, ya que los necesitará más adelante durante el proceso de instalación.
      </Callout>

      ## Instale la integración de Kubernetes con Helm [#install-k8-helm]

      New Relic tiene varios gráficos de Helm para los diferentes componentes que ofrecen diferentes características para la plataforma:

      * [`newrelic-infrastructure`](https://github.com/newrelic/nri-kubernetes/tree/main/charts/newrelic-infrastructure): contiene la integración principal de Kubernetes y el agente de infraestructura. Este es el componente central de la New Relic Kubernetes experiencia , responsable de informar la mayoría de los datos que aparecen en el Kubernetes dashboard y el clúster de Kubernetes Explorer.
      * [`newrelic-logging`](https://github.com/newrelic/helm-charts/tree/master/charts/newrelic-logging): proporciona un DaemonSet con el New Relic [complemento](https://github.com/newrelic/newrelic-fluent-bit-output) de salida [Fluent Bit](https://fluentbit.io/) de para reenviar fácilmente su registro a [New Relic](/docs/logs/new-relic-logs/get-started/introduction-new-relic-logs).
      * [`nri-kube-events`](https://github.com/newrelic/nri-kube-events/tree/main/charts/nri-kube-events): recopila y notifica el evento del clúster (como `kubectl get events`) a New Relic.
      * [`newrelic-prometheus-agent`](https://github.com/newrelic/newrelic-prometheus-configurator/tree/main/charts/newrelic-prometheus-agent): El Configurador Prometheus de New Relic configura un [Prometheus en modo agente](/docs/infrastructure/prometheus-integrations/install-configure-prometheus-agent/install-prometheus-agent) y utiliza nuestro extremo de escritura remota para [generar informes métricos a New Relic](/docs/infrastructure/prometheus-integrations/get-started/send-prometheus-metric-data-new-relic/#remote-write).
      * [`nri-metadata-injection`](https://github.com/newrelic/k8s-metadata-injection/tree/main/charts/nri-metadata-injection): configura un `MutatingAdmissionWebhook` mínimo que inyecta un par de variables de entorno en el contenedor. Estos contienen metadatos sobre el clúster y la instalación New Relic y serán posteriormente recogidos por la aplicación instrumentada usando APM, permitiendo [correlacionar datos APM e infraestructura](/docs/integrations/kubernetes-integration/link-your-applications/link-your-applications-kubernetes/).
      * [`nri-statsd`](https://github.com/newrelic/helm-charts/tree/master/charts/nri-statsd): New Relic StatsD.

      Aunque puede instalar estos componentes por separado, le recomendamos encarecidamente que utilice la tabla [`nri-bundle`](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle) . New Relic proporciona este gráfico, que actúa como un contenedor o metapaquete para los gráficos individuales mencionados anteriormente. El uso de este gráfico le permite estas ventajas:

      * Proporciona control total sobre qué componentes están instalados. Cada componente se instala como una [dependencia de Helm](https://helm.sh/docs/chart_template_guide/subcharts_and_globals/#overriding-values-from-a-parent-chart) independiente. Puede configurarlos individualmente usando el parámetro mencionado [aquí](#configure).
      * Garantiza que sus versiones instaladas sean compatibles entre sí.
      * Garantiza que sus valores de configuración sean consistentes en todos los gráficos instalados.

      El gráfico `nri-bundle` es el que instala y configura nuestra [instalación guiada de Kubernetes](/docs/kubernetes-pixie/kubernetes-integration/installation/kubernetes-integration-install-configure#guided-install).

      ### Instalación y configuración `nri-bundle` con Helm

      1. Asegúrese de utilizar el contexto adecuado en la máquina donde ejecutará Helm y `kubectl`:

         Puedes consultar los contextos disponibles con:

         ```shell
         kubectl config get-contexts
         ```

         Y cambie al contexto deseado usando:

         ```shell
         kubectl config use-context _CONTEXT_NAME_
         ```

      2. Agregue el repositorio de gráficos de New Relic Helm:

         ```shell
         helm repo add newrelic https://helm-charts.newrelic.com
         ```

      3. Cree un archivo llamado `values-newrelic.yaml`, que se utilizará para definir su configuración:

         ```yaml
         global:
           licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
           cluster: _K8S_CLUSTER_NAME_

         newrelic-prometheus-agent:
           # Automatically scrape prometheus metrics for annotated services in the cluster
           # Collecting prometheus metrics for large clusters might impact data usage significantly
           enabled: true
         nri-metadata-injection:
           # Deploy our webhook to link APM and Kubernetes entities
           enabled: true
         nri-kube-events:
           # Report Kubernetes events
           enabled: true
         newrelic-logging:
           # Report logs for containers running in the cluster
           enabled: true
         kube-state-metrics:
           # Deploy kube-state-metrics in the cluster.
           # Set this to true unless it is already deployed.
           enabled: true
         ```

      4. Asegúrese de que todo esté configurado correctamente en el gráfico ejecutando el siguiente comando. Tenga en cuenta que estamos especificando `--dry-run` y `--debug`, por lo que no se instalará nada en este paso:

         ```shell
         helm upgrade --install newrelic-bundle newrelic/nri-bundle \
         --namespace newrelic --create-namespace \
         -f values-newrelic.yaml \
         --dry-run \
         --debug
         ```

         Tenga en cuenta y ajuste las siguientes banderas:

         * `global.licenseKey=YOUR_NEW_RELIC_LICENSE_KEY`: Debe configurarse en un

           <InlinePopover type="licenseKey"/>

           válido para su cuenta.

         * `global.cluster=K8S_CLUSTER_NAME`: Se utiliza para identificar el clúster en la New Relic UI, por lo que debe ser un valor descriptivo no utilizado por ningún otro clúster de Kubernetes configurado en su New Relic cuenta .

         * `kube-state-metrics.enabled=true`: Establecer esto en `true` instalará automáticamente Kube State métrica (KSM), que es necesario para que se ejecute nuestra integración. Puede establecer esto en falso si KSM ya está presente en su clúster, incluso si está en un namespace diferente.

         * `newrelic-prometheus-agent.enabled=true`: desplegará nuestro agente Prometheus, que recopila automáticamente datos del extremo Prometheus presente en el clúster.

         * `nri-metadata-injection.enabled=true`: Instalaremos nuestro webhook mínimo, que agrega variables de entorno que, a su vez, permiten [vincular la aplicación instrumentada con New Relic APM a Kubernetes](/docs/kubernetes-pixie/kubernetes-integration/link-your-applications/link-your-applications-kubernetes).

         Nuestros gráficos de Kubernetes tienen un conjunto completo de indicadores y parámetros ajustables que se pueden editar para adaptarse mejor a sus necesidades particulares. Por favor, consulte la sección [Configurar la integración](#configure) a continuación para ver qué se puede cambiar.

      5. Instale la integración de Kubernetes ejecutando el comando sin `--debug` y `--dry-run`:

         ```shell
         helm upgrade --install newrelic-bundle newrelic/nri-bundle \
         --namespace newrelic --create-namespace \
         -f values-newrelic.yaml
         ```

         <Callout variant="important">
           Asegúrese de utilizar Kubernetes versión 1.27.x o [una versión inferior que admitamos](/docs/kubernetes-pixie/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements).
         </Callout>

      6. Verifique que los pods se estén desplegando y alcancen un estado estable:

         ```shell
         kubectl -n newrelic get pods -w
         ```

      Debería ver:

      * `newrelic-nrk8s-ksm` pod.
      * `newrelic-nrk8s-kubelet` pod para cada nodo de su clúster.
      * `newrelic-nrk8s-control-plane` pod para cada nodo maestro de su clúster, si lo hubiera.
      * `newrelic-kube-state-metrics` pod, si incluyó KSM con nuestra instalación.
      * `newrelic-nri-kube-events` pod, si habilitó los informes de eventos Kubernetes .
      * `prometheus-agent` pod, si habilitó la integración del [agente Prometheus](/docs/infrastructure/prometheus-integrations/install-configure-prometheus-agent/install-prometheus-agent) .
      * `newrelic-newrelic-logging` pod para cada nodo de su clúster, si habilitó la integración de registro.

      <InstallFeedback/>

      ## Configurar la integración [#configure]

      Nuestro gráfico `nri-bundle` . cuyas instrucciones de instalación se pueden encontrar arriba, actúa como un contenedor o un metapaquete para un par de gráficos más, que son los que contienen los componentes de nuestra solución. Al ofrecer un contenedor de este tipo, podemos proporcionar un conjunto controlado de nuestros componentes con versiones que sabemos que son compatibles entre sí, manteniendo los gráficos de los componentes relativamente simples.

      El gráfico [`nri-bundle`](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle) envuelve [varios gráficos individuales](#install-k8-helm) para recopilar diferentes telemetry data y enviarlos a New Relic. El paquete permite habilitar selectivamente los gráficos secundarios deseados según sus necesidades. Para configurar cada componente individual, debe utilizar [el sistema de dependencia de Helm](https://helm.sh/docs/chart_template_guide/subcharts_and_globals/#overriding-values-from-a-parent-chart), lo que en resumen significa que la configuración de cada gráfico secundario debe colocarse en una sección separada (que lleva el nombre de cada gráfico secundario) en el [archivo values-newrelic.yml](https://helm.sh/docs/chart_template_guide/values_files/). Por ejemplo, para configurar el gráfico `newrelic-infrastructure` , agregaría lo siguiente al `values-newrelic.yaml`:

      ```yaml
      # General settings that apply to all the child charts
      global:
        licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
        cluster: _K8S_CLUSTER_NAME_

      # ... Other settings as shown above

      # Specific configuration for the newrelic-infrastructure child chart
      newrelic-infrastructure:
        verboseLog: true  # Enable debug logs
        privileged: false  # Install with minimal privileges
        # Other options from https://github.com/newrelic/helm-charts/tree/master/charts/newrelic-infrastructure-v3

      # Specific configuration for the newrelic-logging child chart
      newrelic-logging:
        fluentBit:
        retryLimit: 10
      ```

      También puede pasar opciones de gráfico secundario a través de la línea de comando prefijándolas con el nombre del gráfico secundario y reemplazando el anidamiento por puntos:

      ```
      helm upgrade --install newrelic-bundle newrelic/nri-bundle \
      --namespace=newrelic \
      --set global.licenseKey=_YOUR_NEW_RELIC_LICENSE_KEY_ \
      --set global.cluster=_K8S_CLUSTER_NAME_ \
      --set newrelic-infrastructure.privileged=false \
      --set newrelic-infrastructure.verboseLog=true \
      --set newrelic-logging.fluentBit.retryLimit=10
      ```

      La lista completa de indicadores que puede modificar (como [scrape-interval](/docs/new-relic-solutions/observability-maturity/operational-efficiency/data-governance-optimize-ingest-guide#k8s-integration)) para cada gráfico secundario se puede encontrar en su respectivo repositorio:

      * [`newrelic-infrastructure`](https://github.com/newrelic/nri-kubernetes/tree/main/charts/newrelic-infrastructure)
      * Configurar log de depuración, modo de privilegios, monitoreo del plano de control, etc.
      * [`nri-kube-events`](https://github.com/newrelic/nri-kube-events/tree/main/charts/nri-kube-events)
      * [`nri-metadata-injection`](https://github.com/newrelic/k8s-metadata-injection/tree/main/charts/nri-metadata-injection)
      * Configurar cómo se desplegará el webhook para la vinculación APM .
      * Configure qué extremo de Prometheus se raspa.
      * [`newrelic-logging`](https://github.com/newrelic/helm-charts/tree/master/charts/newrelic-logging)
      * Configura qué registro o atributo log se envían a New Relic.

      <Callout variant="tip">
        Al especificar opciones de configuración para los gráficos secundarios, debe colocarlas en una sección que lleve el nombre del gráfico en su `values-newrelic.yaml`.
      </Callout>

      <Callout variant="tip">
        Para pasar opciones de gráficos secundarios a través de la línea de comando, debe anteponerles el nombre del gráfico secundario y reemplazar el anidamiento por puntos.
      </Callout>
    </TabsPageItem>

    <TabsPageItem id="gke-autopilot">
      Hay tres formas de instalar la integración de Kubernetes en tu clúster de GKE Autopilot:

      * La CLI de New Relic que se encuentra en nuestra instalación guiada
      * Un comando de Helm con valores requeridos previamente completados
      * Un manifiesto simple con valores requeridos precargados

      <CollapserGroup>
        <Collapser
          id="guided-gke"
          title="Instalación guiada (recomendado)"
        >
          Puedes instalar en el piloto automático de GKE usando el mismo flujo de instalación que nuestra pestaña [de instalación guiada](/docs/kubernetes-pixie/kubernetes-integration/installation/kubernetes-integration-install-configure/#guided-install) .
        </Collapser>

        <Collapser
          id="helm-gke"
          title="Timón manual"
        >
          Su comando Helm completo debería parecerse al siguiente:

          ```shell
          KSM_IMAGE_VERSION="v2.10.0" && \
          helm repo add newrelic https://helm-charts.newrelic.com && helm repo update && \
          kubectl create namespace newrelic ; helm upgrade --install newrelic-bundle newrelic/nri-bundle \
          --set global.licenseKey=<Your License Key> \
          --set global.cluster=<Your Cluster Name> \
          --namespace=newrelic \
          --set newrelic-infrastructure.privileged=false \
          --set newrelic-infrastructure.controlPlane.enabled=false \
          --set newrelic-infrastructure.kubelet.config.scheme=http \
          --set newrelic-infrastructure.kubelet.config.port=10255 \
          --set global.lowDataMode=true \
          --set kube-state-metrics.image.tag=${KSM_IMAGE_VERSION} \
          --set kube-state-metrics.enabled=true \
          --set kubeEvents.enabled=true \
          --set newrelic-prometheus-agent.enabled=true \
          --set newrelic-prometheus-agent.lowDataMode=true \
          --set newrelic-prometheus-agent.config.kubernetes.integrations_filter.enabled=false \
          --set newrelic-pixie.enabled=false
          --set logging.enabled=true 
          --set newrelic-logging.lowDataMode=true 
          --set newrelic-logging.fluentBit.linuxMountPath=/var/log  
          --set newrelic-logging.fluentBit.persistence.mode=persistentVolume 
          --set newrelic-logging.fluentBit.persistence.persistentVolume.storageClass=standard-rwx
          ```

          [Fluent Bit](https://fluentbit.io/) puede usar un volumen de FileStore para evitar la pérdida de datos o registros duplicados durante los reinicios o redespliegues pod de Fluent Bit. El uso de FileStore genera costos adicionales, según los cobra Google. Recomendamos consultar a su administrador de Google Cloud o visitar [los documentos de FileStore](https://cloud.google.com/filestore/pricing) para obtener más detalles. La API de Google FileStore debe estar habilitada en tu proyecto de GKE. Consulte este [documento](https://support.google.com/googleapi/answer/6158841) para saber más sobre cómo habilitar las API.

          Si no desea utilizar FileStore, agregue lo siguiente:

          * Establezca `"newrelic-logging.fluentBit.persistence.mode"` en `"none"`
          * Eliminar `"newrelic-logging.fluentBit.persistence.persistentVolume.storageClass"`

          Consulte nuestros [documentos del gráfico Helm](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle) para obtener más información.
        </Collapser>

        <Collapser
          id="manifest-gke"
          title="Manifiesto"
        >
          Actualice su comando de manifiesto con las siguientes banderas:

          * Establezca `"newrelic-infrastructure.privileged"`, `"newrelic-infrastructure.controlPlane.enabled"` en `false`.
          * Agregar `"newrelic-infrastructure.kubelet.config.scheme":"http"`
          * Agregar `"newrelic-infrastructure.kubelet.config.port":"10255"`
          * Agregar `"logging.enabled":"true"`
          * Agregar `"newrelic-logging.lowDataMode":"true"`
          * Agregar `"newrelic-logging.fluentBit.linuxMountPath":"/var/log"`
          * Agregar `"newrelic-logging.fluentBit.persistence.mode":"persistentVolume"`
          * Agregar `"newrelic-logging.fluentBit.persistence.persistentVolume.storageClass":"standard-rwx"`
          * Elimina la carga útil de Pixie del comando, ya que Pixie no es compatible actualmente con GKE Autopilot.

          [Fluent Bit](https://fluentbit.io/) puede usar un volumen de FileStore para evitar la pérdida de datos o registros duplicados durante los reinicios o redespliegues pod de Fluent Bit. El uso de FileStore genera costos adicionales, según los cobra Google. Recomendamos consultar a su administrador de Google Cloud o visitar [los documentos de FileStore](https://cloud.google.com/filestore/pricing) para obtener más detalles. La API de Google FileStore debe estar habilitada en tu proyecto de GKE. Consulte este [documento](https://support.google.com/googleapi/answer/6158841) para saber más sobre cómo habilitar las API.

          Si no desea utilizar FileStore, agregue lo siguiente:

          * Establezca `"newrelic-logging.fluentBit.persistence.mode"` en `"none"`
          * Eliminar `"newrelic-logging.fluentBit.persistence.persistentVolume.storageClass"`

          Aquí hay un comando que crea un archivo de manifiesto y luego lo aplica al clúster:

          ```shell
          KSM_IMAGE_VERSION="v2.10.0" && \
          curl -X POST https://k8s-config-generator.service.newrelic.com/generate -H 'Content-Type: application/json' -d '{"global.cluster":"<Your Cluster Name>","global.namespace":"newrelic","newrelic-infrastructure.privileged":"false","newrelic-infrastructure.controlPlane.enabled":"false","newrelic-infrastructure.kubelet.config.scheme":"http","newrelic-infrastructure.kubelet.config.port":"10255","global.lowDataMode":"true","kube-state-metrics.image.tag":"'${KSM_IMAGE_VERSION}'","kube-state-metrics.enabled":"true","kubeEvents.enabled":"true","newrelic-prometheus-agent.enabled":"true","newrelic-prometheus-agent.lowDataMode":"true","newrelic-prometheus-agent.config.kubernetes.integrations_filter.enabled":"false","logging.enabled":"true", "newrelic-logging.lowDataMode":"true", "newrelic-logging.fluentBit.linuxMountPath":"/var/log", "newrelic-logging.fluentBit.persistence.mode":"persistentVolume", "newrelic-logging.fluentBit.persistence.persistentVolume.storageClass":"standard-rwx","global.licenseKey":"<Your License Key"}'  > newrelic.yaml && (kubectl create namespace newrelic ; kubectl apply -f newrelic.yaml)
          ```
        </Collapser>
      </CollapserGroup>
    </TabsPageItem>
  </TabsPages>
</Tabs>

## Utilice sus datos de Kubernetes

Aprender más acerca de:

* [Modos privilegiados y sin privilegios](/docs/infrastructure/install-infrastructure-agent/linux-installation/linux-agent-running-modes)
* [Explorando sus datos Kubernetes en la UI](/docs/kubernetes-pixie/kubernetes-integration/understand-use-data/kubernetes-cluster-explorer)
* [Usar tus datos Kubernetes ](/docs/kubernetes-pixie/kubernetes-integration/understand-use-data/find-use-your-kubernetes-data)con consulta, en gráficos, para alertas, etc.

<InstallFeedback/>