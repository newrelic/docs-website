---
title: New Relic OTel K8s métrica mapeo
tags:
  - Kubernetes integration
  - OpenTelemetry
metaDescription: Learn how to monitor your Kubernetes Cluster using OpenTelemetry
freshnessValidatedDate: never
translationType: machine
---

<Callout title="avance">
  Todavía estamos trabajando en esta característica, ¡pero nos encantaría que la probaras!

  Esta característica se proporciona actualmente como parte de un programa de vista previa de conformidad con nuestras [políticas de prelanzamiento](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy).
</Callout>

Las Kubernetes OpenTelemetry métricas son recopiladas por OpenTelemetry Collector y enviadas a New Relic mediante la New Relic Kubernetes integración .

Este documento proporciona un mapeo de la métrica Kubernetes OpenTelemetry a la métrica New Relic Kubernetes . Este mapeo te ayuda a comprender las métricas y parámetros que están disponibles para monitorear tu clúster de Kubernetes.

<CollapserGroup>
  <Collapser id="for-api-server" title="Para el servidor API">
    La siguiente tabla asigna Kubernetes OpenTelemetry métrica a New Relic Kubernetes métrica. Estas métricas provienen del `API server` configurado con el `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nombre del evento de New Relic
          </th>

          <th>
            Tipo: Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `apiserver_storage_objects`
          </td>

          <td>
            `apiserverStorageObjects_resource_RESOURCE-KIND`
          </td>

          <td>
            `K8sApiServerSample`
          </td>

          <td>
            **Indicador:**

             Número de objetos almacenados en el servidor API .
          </td>
        </tr>

        <tr>
          <td>
            `go_goroutines`
          </td>

          <td>
            `goGoroutines`
          </td>

          <td>
            `K8sApiServerSample`
          </td>

          <td>
            **Indicador:**

             Número de 

            `goroutines`

             que existen actualmente.
          </td>
        </tr>

        <tr>
          <td>
            `go_threads`
          </td>

          <td>
            `goThreads`
          </td>

          <td>
            `K8sApiServerSample`

            , 

            `K8sControllerManagerSample`

            , 

            `K8sEtcdSample`

            , 

            `K8sSchedulerSample`
          </td>

          <td>
            **Indicador:**

             Número de subprocesos del sistema operativo creados.
          </td>
        </tr>

        <tr>
          <td>
            `process_resident_memory_bytes`
          </td>

          <td>
            `processResidentMemoryBytes`
          </td>

          <td>
            `K8sApiServerSample`
          </td>

          <td>
            **Indicador:**

             Tamaño de la memoria residente en bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-cAdvisor" title="Para cAdvisor">
    La siguiente tabla asigna Kubernetes OpenTelemetry métrica a New Relic Kubernetes métrica. Estas métricas provienen del `cAdvisor` configurado con el `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nombre del evento de New Relic
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `container_cpu_cfs_periods_total`
          </td>

          <td>
            `containerCpuCfsPeriodsTotal`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Contador:**

             Número total de intervalos de periodo de cumplimiento transcurridos.
          </td>
        </tr>

        <tr>
          <td>
            `container_cpu_cfs_throttled_periods_total`
          </td>

          <td>
            `containerCpuCfsThrottledPeriodsTotal`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Contador:**

             Número total de intervalos de periodo limitados.
          </td>
        </tr>

        <tr>
          <td>
            `container_cpu_usage_seconds_total`
          </td>

          <td>
            `cpuUsedCores`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Contador:**

             Tiempo total de CPU consumido.
          </td>
        </tr>

        <tr>
          <td>
            `container_memory_working_set_bytes`
          </td>

          <td>
            `memoryWorkingSetBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             Tamaño del conjunto de trabajo de memoria en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `container_network_receive_bytes_total`
          </td>

          <td>
            `net.rxBytesPerSecond`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Contador:**

             recuento acumulativo de bytes recibidos.
          </td>
        </tr>

        <tr>
          <td>
            `container_network_receive_errors_total`
          </td>

          <td>
            `net.txBytesPerSecond`
          </td>

          <td>
            `memoryRequestedBytes`
          </td>

          <td>
            **Contador:**

             recuento acumulativo de errores de recepción encontrados.
          </td>
        </tr>

        <tr>
          <td>
            `container_network_transmit_bytes_total`
          </td>

          <td>
            `net.errorsPerSecond`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Contador:**

             recuento acumulativo de bytes transmitidos.
          </td>
        </tr>

        <tr>
          <td>
            `container_network_transmit_errors_total`
          </td>

          <td>
            `net.errorsPerSecond`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Contador:**

             recuento acumulativo de errores de transmisión encontrados.
          </td>
        </tr>

        <tr>
          <td>
            `container_spec_memory_limit_bytes`
          </td>

          <td>
            `memoryLimitBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             límite de memoria del contenedor en bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-controller-manager" title="Para el administrador del controlador">
    La siguiente tabla asigna Kubernetes OpenTelemetry métrica a New Relic Kubernetes métrica. Estas métricas provienen del `controller manager` configurado con el `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nombre del evento de New Relic
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `go_goroutines`
          </td>

          <td>
            `goGoroutines`
          </td>

          <td>
            `K8sControllerManagerSample`
          </td>

          <td>
            **Indicador:**

             Número de 

            `goroutines`

             que existen actualmente.
          </td>
        </tr>

        <tr>
          <td>
            `process_resident_memory_bytes`
          </td>

          <td>
            `processResidentMemoryBytes`
          </td>

          <td>
            `K8sControllerManagerSample`
          </td>

          <td>
            **Indicador:**

             Tamaño de la memoria residente en bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-kubelet" title="Para kubelet">
    La siguiente tabla asigna Kubernetes OpenTelemetry métrica a New Relic Kubernetes métrica. Estas métricas provienen del `kubelet` configurado con el `KubeletStats Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "150px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nombre del evento de New Relic
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `container.cpu.utilization`
          </td>

          <td>
            `cpuCoresUtilization`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             porcentaje de utilización de CPU del contenedor.
          </td>
        </tr>

        <tr>
          <td>
            `container.filesystem.capacity`
          </td>

          <td>
            `fsCapacityBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             Capacidad total del sistema de archivos del contenedor.
          </td>
        </tr>

        <tr>
          <td>
            `container.filesystem.usage`
          </td>

          <td>
            `fsUsedBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             Espacio del sistema de archivos empleado para el contenedor.
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.usage`
          </td>

          <td>
            `memoryUsedBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             Uso total de memoria del contenedor.
          </td>
        </tr>

        <tr>
          <td>
            `go_goroutines`
          </td>

          <td>
            `goGoroutines`
          </td>

          <td>
            `K8sEtcdSample`
          </td>

          <td>
            **Indicador:**

             Número de 

            `goroutines`

             que existen actualmente.
          </td>
        </tr>

        <tr>
          <td>
            `go_threads`
          </td>

          <td>
            `goThreads`
          </td>

          <td>
            `K8sApiServerSample`

            , 

            `K8sControllerManagerSample`

            , 

            `K8sEtcdSample`

            , 

            `K8sSchedulerSample`
          </td>

          <td>
            **Indicador:**

             Número de subprocesos del sistema operativo creados.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.cpu.time`
          </td>

          <td>
            `cpuUsedCoreMilliseconds`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Indicador:**

             Tiempo total de CPU empleado por el nodo.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.cpu.utilization`
          </td>

          <td>
            `allocatableCpuCoresUtilization`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Indicador:**

             porcentaje de utilización de CPU del nodo.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.filesystem.capacity`
          </td>

          <td>
            `fsCapacityBytes`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Indicador:**

             Capacidad total del sistema de archivos para el nodo.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.filesystem.usage`
          </td>

          <td>
            `fsUsedBytes`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Indicador:**

             espacio del sistema de archivos empleado por el nodo.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.memory.available`
          </td>

          <td>
            `memoryAvailableBytes`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Indicador:**

             Memoria disponible para el nodo.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.memory.working_set`
          </td>

          <td>
            `memoryWorkingSetBytes`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Indicador:**

             Tamaño del conjunto de trabajo del nodo memoria.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.pod.filesystem.available`
          </td>

          <td>
            `fsAvailableBytes`
          </td>

          <td>
            `K8sVolumeSample`
          </td>

          <td>
            **Indicador:**

             Espacio disponible en el sistema de archivos para el pod.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.pod.filesystem.capacity`
          </td>

          <td>
            `fsCapacityBytes`
          </td>

          <td>
            `K8sVolumeSample`
          </td>

          <td>
            **Indicador:**

             Capacidad total del sistema de archivos para el pod.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.pod.filesystem.usage`
          </td>

          <td>
            `fsUsedBytes`
          </td>

          <td>
            `K8sVolumeSample`
          </td>

          <td>
            **Indicador:**

             Espacio del sistema de archivos empleado para el pod.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.pod.memory.working_set`
          </td>

          <td>
            `memoryWorkingSetBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             Tamaño del conjunto de trabajo del pod memoria.
          </td>
        </tr>
      </tbody>
    </table>

    La siguiente tabla asigna Kubernetes OpenTelemetry métrica a New Relic Kubernetes métrica. Estas métricas provienen del `kubelet` configurado con el `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nombre del evento de New Relic
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `process_resident_memory_bytes`
          </td>

          <td>
            `processResidentMemoryBytes`
          </td>

          <td>
            `K8sApiServerSample`
          </td>

          <td>
            **Indicador:**

             Tamaño de la memoria residente en bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-kube-state-metrics" title="Para la métrica del estado de kube">
    La siguiente tabla asigna Kubernetes OpenTelemetry métrica a New Relic Kubernetes métrica. Estas métricas provienen del `kubeStateMetrics` configurado con el `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nombre del evento de New Relic
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `kube_cronjob_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sCronjobSample`
          </td>

          <td>
            **Indicador:**

             timestamp de creación del CronJob.
          </td>
        </tr>

        <tr>
          <td>
            `kube_cronjob_spec_suspend`
          </td>

          <td>
            `isSuspended`
          </td>

          <td>
            `K8sCronjobSample`
          </td>

          <td>
            **Indicador:**

             Suspender la bandera del CronJob.
          </td>
        </tr>

        <tr>
          <td>
            `kube_cronjob_status_active`
          </td>

          <td>
            `isActive`
          </td>

          <td>
            `K8sCronjobSample`
          </td>

          <td>
            **Indicador:**

             Número de instancias de CronJob activas.
          </td>
        </tr>

        <tr>
          <td>
            `kube_cronjob_status_last_schedule_time`
          </td>

          <td>
            `lastScheduledTime`
          </td>

          <td>
            `K8sCronjobSample`
          </td>

          <td>
            **Indicador:**

             Última hora de programación del CronJob.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Indicador:**

             timestamp de creación del DaemonSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_desired_number_scheduled`
          </td>

          <td>
            `podsScheduled`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Indicador:**

             Número deseado de instancias de DaemonSet programadas.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_number_misscheduled`
          </td>

          <td>
            `podsMisscheduled`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Indicador:**

             Número de instancias de DaemonSet mal programadas.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_number_ready`
          </td>

          <td>
            `podsReady`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Indicador:**

             Número de instancias de DaemonSet listas.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_number_unavailable`
          </td>

          <td>
            `podsUnavailable`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Indicador:**

             Número de instancias de DaemonSet no disponibles.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_updated_number_scheduled`
          </td>

          <td>
            `podsUpdatedScheduled`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Indicador:**

             Número actualizado de instancias de DaemonSet programadas.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Indicador:**

             timestamp de creación del despliegue.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_metadata_generation`
          </td>

          <td>
            `metadataGeneration`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Indicador:**

             Número de generación de los metadatos desplegados.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_spec_replicas`
          </td>

          <td>
            `podsDesired`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Indicador:**

             Número de réplicas deseadas para el despliegue.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_spec_strategy_rollingupdate_max_surge`
          </td>

          <td>
            `rollingUpdateMaxPodsSurge`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Indicador:**

             Aumento máximo permitido durante la actualización continua.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_condition`
          </td>

          <td>
            `conditionAvailable`

            , 

            `conditionProgressing`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Indicador:**

             condiciones de estado de despliegue.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_observed_generation`
          </td>

          <td>
            `observedGeneration`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Indicador:**

             La generación más reciente observada para este despliegue.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas`
          </td>

          <td>
            `podsTotal`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Indicador:**

             Número de réplicas para el despliegue.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas_available`
          </td>

          <td>
            `podsAvailable`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Indicador:**

             Número de réplicas disponibles para el despliegue.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas_ready`
          </td>

          <td>
            `podsReady`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Indicador:**

             Número de réplicas listas para el despliegue.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas_unavailable`
          </td>

          <td>
            `podsUnavailable`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Indicador:**

             Número de réplicas no disponibles para el despliegue.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas_updated`
          </td>

          <td>
            `podsUpdated`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Indicador:**

             Número de réplicas actualizadas para el despliegue.
          </td>
        </tr>

        <tr>
          <td>
            `kube_horizontalpodautoscaler_spec_min_replicas`
          </td>

          <td>
            `minReplicas`
          </td>

          <td>
            `K8sHpaSample`
          </td>

          <td>
            **Indicador:**

             Número mínimo de réplicas para HorizontalPodAutoscaler.
          </td>
        </tr>

        <tr>
          <td>
            `kube_horizontalpodautoscaler_status_condition`
          </td>

          <td>
            `isActive`
          </td>

          <td>
            `K8sHpaSample`
          </td>

          <td>
            **Indicador:**

             Condiciones de estado del HorizontalPodAutoscaler.
          </td>
        </tr>

        <tr>
          <td>
            `kube_horizontalpodautoscaler_status_current_replicas`
          </td>

          <td>
            `currentReplicas`
          </td>

          <td>
            `K8sHpaSample`
          </td>

          <td>
            **Indicador:**

             Número actual de réplicas para HorizontalPodAutoscaler.
          </td>
        </tr>

        <tr>
          <td>
            `kube_horizontalpodautoscaler_status_desired_replicas`
          </td>

          <td>
            `desiredReplicas`
          </td>

          <td>
            `K8sHpaSample`
          </td>

          <td>
            **Indicador:**

             Número deseado de réplicas para HorizontalPodAutoscaler.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_complete`
          </td>

          <td>
            `isComplete`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Indicador:**

             Si el trabajo está completo 

            `(1)`

             o no 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Indicador:**

             timestamp de creación del trabajo.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_failed`
          </td>

          <td>
            `failed`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Indicador:**

             Si el trabajo falló 

            `(1)`

             o no 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_spec_active_deadline_seconds`
          </td>

          <td>
            `specActiveDeadlineSeconds`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Indicador:**

             Número de segundos que el trabajo puede ejecutar antes de finalizar.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_spec_completions`
          </td>

          <td>
            `specCompletions`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Indicador:**

             Número deseado de pods completados exitosamente para el trabajo.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_spec_parallelism`
          </td>

          <td>
            `specParallelism`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Indicador:**

             Número máximo deseado de pods ejecutar en paralelo para el trabajo.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_active`
          </td>

          <td>
            `activePods`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Indicador:**

             Número de pods activos para el trabajo.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_completion_time`
          </td>

          <td>
            `completedAt`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Indicador:**

             Tiempo de finalización del trabajo.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_failed`
          </td>

          <td>
            `failedPods`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Indicador:**

             Número de pods fallidos para el trabajo.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_start_time`
          </td>

          <td>
            `startedAt`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Indicador:**

             Hora de inicio del trabajo.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_succeeded`
          </td>

          <td>
            `succeededPods`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Indicador:**

             Número de pods exitosos para el trabajo.
          </td>
        </tr>

        <tr>
          <td>
            `kube_node_status_allocatable`
          </td>

          <td>
            `memoryWorkingSetUtilization`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             Recursos asignables del Nodo.
          </td>
        </tr>

        <tr>
          <td>
            `kube_node_status_condition`
          </td>

          <td>
            `condition.CONDITION_NAME=CONDITION_VALUE`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Indicador:**

             Condición del estado del Nodo.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolume_capacity_bytes`
          </td>

          <td>
            `capacityBytes`
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Indicador:**

             Capacidad del PersistentVolume en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolume_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Indicador:**

             timestamp de creación del PersistentVolume.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolume_info`
          </td>

          <td />

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Indicador:**

             Información sobre el PersistentVolume.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolume_status_phase`
          </td>

          <td>
            `statusPhase`
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Indicador:**

             Fase del Volumen Persistente.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolumeclaim_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Indicador:**

             timestamp de creación de PersistentVolumeClaim.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolumeclaim_info`
          </td>

          <td>
            Todos los atributos que describen el volumen
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Indicador:**

             Información sobre PersistentVolumeClaim.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolumeclaim_resource_requests_storage_bytes`
          </td>

          <td>
            `requestedStorageBytes`
          </td>

          <td>
            `K8sPersistentVolumeClaimSample`
          </td>

          <td>
            **Indicador:**

             requests de recursos de almacenamiento de PersistentVolumeClaim en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolumeclaim_status_phase`
          </td>

          <td>
            `statusPhase`
          </td>

          <td>
            `K8sPersistentVolumeClaimSample`
          </td>

          <td>
            **Indicador:**

             Fase del PersistentVolumeClaim.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_resource_limits`
          </td>

          <td>
            `cpuLimitCores`

            , 

            `memoryLimitBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             Límites de recursos del pod contenedor.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_resource_requests`
          </td>

          <td>
            `cpuRequestedCores`

            , 

            `memoryRequestedBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             requests de recursos del pod contenedor.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_status_phase`
          </td>

          <td>
            `status`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             Fase actual del pod contenedor.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_status_ready`
          </td>

          <td>
            `isReady`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             Si el contenedor de cápsulas está listo 

            `(1)`

             o no 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_status_restarts_total`
          </td>

          <td>
            `restartCount`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Contador:**

             Número total de reinicios del pod contenedor.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_status_waiting_reason`
          </td>

          <td>
            `reason`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Indicador:**

             Motivo del estado de espera del contenedor.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Indicador:**

             timestamp de creación del pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_info`
          </td>

          <td>
            Todos los atributos que describen el pod.
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Indicador:**

             Información sobre el pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_phase`
          </td>

          <td>
            `status`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Indicador:**

             Fase actual del estado del pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_ready`
          </td>

          <td>
            `isReady`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Indicador:**

             Si el pod está listo 

            `(1)`

             o no 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_ready_time`
          </td>

          <td>
            `startTime`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Indicador:**

             Hora en la que el estado del pod estuvo listo.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_scheduled`
          </td>

          <td>
            `isScheduled`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Indicador:**

             Si el pod está programado 

            `(1)`

             o no 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_scheduled_time`
          </td>

          <td />

          <td />

          <td>
            **Indicador:**

             Hora en la que se programó el pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_annotations`
          </td>

          <td>
            `selector.ANNOTATIONS`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Indicador:**

             Anotaciones aplicadas al Servicio.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Indicador:**

             timestamp de creación del Servicio.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_info`
          </td>

          <td>
            Todos los atributos que describen el Servicio
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Indicador:**

             Información sobre el Servicio.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_labels`
          </td>

          <td>
            `label.LABEL_NAME`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Indicador:**

             Etiquetas aplicadas al Servicio.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_spec_type`
          </td>

          <td>
            `specType`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Indicador:**

             Tipo de especificación del Servicio.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_status_load_balancer_ingress`
          </td>

          <td>
            filtro con 

            `WHERE specType = 'LoadBalancer'`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Indicador:**

             Estado del ingreso del balanceador de carga para el Servicio.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Indicador:**

             timestamp de creación del StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_persistentvolumeclaim_retention_policy`
          </td>

          <td>
            `filter with WHERE persistent = 'true'`
          </td>

          <td>
            `K8sVolumeSample`
          </td>

          <td>
            **Indicador:**

             Política de retención de PersistentVolumeClaims para StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_replicas`
          </td>

          <td>
            `podsDesired`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Indicador:**

             Número deseado de réplicas para el StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_current_revision`
          </td>

          <td>
            `currentRevision`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Indicador:**

             Revisión actual del StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas`
          </td>

          <td>
            `podsTotal`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Indicador:**

             Número de réplicas para el StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas_available`
          </td>

          <td>
            `podsTotal - podsCurrent`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Indicador:**

             Número de réplicas disponibles para el StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas_current`
          </td>

          <td>
            `podsCurrent`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Indicador:**

             Número de réplicas actuales para el StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas_ready`
          </td>

          <td>
            `podsReady`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Indicador:**

             Número de réplicas listas para el StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas_updated`
          </td>

          <td>
            `podsUpdated`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Indicador:**

             Número de réplicas actualizadas para el StatefulSet.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="k8s-otel" title="Para Nodo">
    La siguiente tabla asigna Kubernetes OpenTelemetry métrica a New Relic Kubernetes métrica. Estas métricas provienen del `node` configurado con el `HostMetric Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "100px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nombre del evento de New Relic
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `process.cpu.utilization`
          </td>

          <td>
            `cpuPercent`
          </td>

          <td>
            `ProcessSample`
          </td>

          <td>
            **Indicador:**

             utilización de CPU del proceso como porcentaje.
          </td>
        </tr>

        <tr>
          <td>
            `process.disk.io`
          </td>

          <td>
            `ioTotalReadCount+ioTotalWriteCount`
          </td>

          <td>
            `ProcessSample`
          </td>

          <td>
            **Contador:**

             Número de operaciones I/O de disco realizadas por el proceso.
          </td>
        </tr>

        <tr>
          <td>
            `process.memory.usage`
          </td>

          <td>
            `memoryResidentSizeBytes`
          </td>

          <td>
            `ProcessSample`
          </td>

          <td>
            **Indicador:**

             uso de memoria del proceso en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `process.memory.virtual`
          </td>

          <td>
            `memoryVirtualSizeBytes`
          </td>

          <td>
            `ProcessSample`
          </td>

          <td>
            **Indicador:**

             Uso de memoria virtual del proceso en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `system.cpu.load_average.15m`
          </td>

          <td>
            `loadAverageFifteenMinute`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Indicador:**

             Promedio de carga del sistema durante los últimos 15 minutos.
          </td>
        </tr>

        <tr>
          <td>
            `system.cpu.load_average.1m`
          </td>

          <td>
            `loadAverageOneMinute`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Indicador:**

             Promedio de carga del sistema durante el último minuto.
          </td>
        </tr>

        <tr>
          <td>
            `system.cpu.load_average.5m`
          </td>

          <td>
            `loadAverageFiveMinute`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Indicador:**

             Promedio de carga del sistema durante los últimos 5 minutos.
          </td>
        </tr>

        <tr>
          <td>
            `system.cpu.utilization`
          </td>

          <td>
            `cpuPercent`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Indicador:**

             Porcentaje total de utilización de la CPU.
          </td>
        </tr>

        <tr>
          <td>
            `system.disk.io`
          </td>

          <td>
            `readBytesPerSecond+writeBytesPerSecond`
          </td>

          <td>
            `StorageSample`
          </td>

          <td>
            **Contador:**

             Número de operaciones I/O de disco realizadas.
          </td>
        </tr>

        <tr>
          <td>
            `system.disk.io_time`
          </td>

          <td>
            `diskReadsPerSecond+diskWritesPerSecond`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Contador:**

             Tiempo empleado en operaciones de I/O de disco en segundos.
          </td>
        </tr>

        <tr>
          <td>
            `system.disk.operation_time`
          </td>

          <td>
            `diskWriteUtilizationPercent`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Contador:**

             Tiempo total empleado en operaciones de disco en segundos.
          </td>
        </tr>

        <tr>
          <td>
            `system.disk.operations`
          </td>

          <td>
            `readIoPerSecond`
          </td>

          <td>
            `StorageSample`
          </td>

          <td>
            **Contador:**

             Número de operaciones de disco realizadas.
          </td>
        </tr>

        <tr>
          <td>
            `system.filesystem.usage`
          </td>

          <td>
            `diskUsedBytes`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Indicador:**

             Uso del espacio del sistema de archivos en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `system.filesystem.utilization`
          </td>

          <td>
            `diskUsedPercent`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Indicador:**

             Utilización del sistema de archivos en porcentaje.
          </td>
        </tr>

        <tr>
          <td>
            `system.memory.usage`
          </td>

          <td>
            `memoryUsedBytes`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Indicador:**

             Uso total de memoria en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `system.memory.utilization`
          </td>

          <td>
            `memoryUsedPercent`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Indicador:**

             utilización de memoria como porcentaje.
          </td>
        </tr>

        <tr>
          <td>
            `system.network.errors`
          </td>

          <td>
            `transmitErrorsPerSecond`
          </td>

          <td>
            `NetworkSample`
          </td>

          <td>
            **Contador:**

             Número de errores de red.
          </td>
        </tr>

        <tr>
          <td>
            `system.network.io`
          </td>

          <td>
            `receiveBytesPerSecond`

            , 

            `transmitBytesPerSecond`
          </td>

          <td>
            `NetworkSample`
          </td>

          <td>
            **Contador:**

             Número de operaciones de I/O de red.
          </td>
        </tr>

        <tr>
          <td>
            `system.network.packets`
          </td>

          <td>
            `transmitPacketsPerSecond+receivePacketsPerSecond`
          </td>

          <td>
            `NetworkSample`
          </td>

          <td>
            **Contador:**

             Número de paquetes de red transmitidos y recibidos.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-scheduler" title="Para el programador">
    La siguiente tabla asigna Kubernetes OpenTelemetry métrica a New Relic Kubernetes métrica. Estas métricas provienen del `scheduler` configurado con el `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "100px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nombre del evento de New Relic
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `go_goroutines`
          </td>

          <td>
            `goGoroutines`
          </td>

          <td>
            `K8sSchedulerSample`
          </td>

          <td>
            **Indicador:**

             Número de 

            `goroutines`

             que existen actualmente.
          </td>
        </tr>

        <tr>
          <td>
            `process_resident_memory_bytes`
          </td>

          <td>
            `processResidentMemoryBytes`
          </td>

          <td>
            `K8sSchedulerSample`
          </td>

          <td>
            **Indicador:**

             Tamaño de la memoria residente en bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>