---
title: Esquema de definición del flujo de trabajo
tags:
  - workflow automation
  - workflow schems
  - workflow automation API
metaDescription: Workflow definitions are written in YAML. Keys use a camelCase naming convention.
freshnessValidatedDate: never
translationType: machine
---

<Callout title="avance">
  Todavía estamos trabajando en esta característica, ¡pero nos encantaría que la probaras!

  Esta característica se proporciona actualmente como parte de un programa de vista previa de conformidad con nuestras [políticas de prelanzamiento](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy).
</Callout>

## Esquema

Las definiciones de flujo de trabajo se escriben en YAML. Las claves emplean una convención de nomenclatura `camelCase`.

### **nombre** (Obligatorio)

* **Tipo**: Cadena
* **Formato**: Debe ajustar a la expresión regular `^[A-Za-z_][A-Za-z0-9_-]*$`.
* **Longitud máxima**: 100
* **Descripción**: Los valores `name` no distinguen entre mayúsculas y minúsculas. Por ejemplo, `ExampleWorkflow`, `exampleworkflow` y `EXAMPLEWORKFLOW` se consideran que representan la misma definición de flujo de trabajo.

### **Descripción** (opcional)

* **Tipo**: Cadena
* **Formato**: Debe ajustar a la expresión regular `^[A-Za-z0-9 _-]*$`.
* **Longitud máxima**: 200
* **Descripción**: Un `description` del flujo de trabajo que explica su propósito.

### **workflowInputs** (opcional)

* **Tipo**: Mapa de mapas
* **Tamaño máximo**: 100
* **Descripción**: Un mapa de las entradas del flujo de trabajo que acepta el flujo de trabajo.
* **Ejemplo**:

```java
  workflowInputs:
    myInput1:
      type: String
    myInput2:
      type: Number
      defaultValue: 42
```

* **`workflowInputs.<inputName>`** (Obligatorio)

  * **Tipo**: Cadena (que se ajusta al [patrón seguro para expresiones]())
  * **Longitud mínima**: 1
  * **Longitud máxima**: 50
  * **Descripción**: El nombre de la entrada del flujo de trabajo.

* **`workflowInputs.<inputName>.type`** (Obligatorio)

  * **Tipo**: Enumeración (Booleano, Lista, Mapa, Cadena, Entero, flotante)
  * **Descripción**: El tipo de datos de la entrada del flujo de trabajo.

* **`workflowInputs.<inputName>.defaultValue`** (Opcional)

  * **Tipo**: Cualquiera; debe ajustar a `type`.
  * **Descripción**: El valor predeterminado para la entrada del flujo de trabajo.

* **pasos** (Obligatorios)

  * **Tipo**: matriz de mapas
  * **Descripción**: Los pasos a realizar cuando se ejecuta la definición del flujo de trabajo. Debe haber al menos un paso.

  <Callout variant="important">
    Los pasos se ejecutarán en el orden en que están definidos en la matriz `steps`.

    Si se desea un orden diferente, se puede realizar un “salto” configurando la propiedad `steps[*].next` con el nombre del paso al que se desea saltar.
  </Callout>

  * **`steps[*].name`** (Obligatorio)

    * **Tipo**: Cadena (que se ajusta al [patrón seguro para expresiones](); no puede ser `end`)
    * **Longitud máxima**: 100
    * **Descripción**: El nombre del paso al que hará referencia `steps[*].next`. No pueden ser las palabras clave especiales `end`, `continue` o `break`, ya que estas se emplean para indicar un paso de terminación, una continuación de un bucle o para salir de un bucle.

  * **`steps[*].type`** (Obligatorio)

    * **Tipo**: Cadena
    * **Descripción**: El tipo de paso, que indica qué hace el paso cuando se ejecuta. Consulte la [sección Tipos de pasos]() para conocer las opciones disponibles.

  * [**`steps[*].next`**](#steps-next) (Opcional)

    * **Tipo**: Cadena (que se ajusta al [patrón seguro para expresiones]())

    * **Descripción**:

      * El nombre del siguiente paso a ejecutar cuando este paso se complete correctamente. La palabra clave especial `end` se puede emplear para indicar que este paso debe ser el último en ejecutar.
      * Si se omite `next`, se empleará la siguiente entrada en la matriz `steps` de la definición como el siguiente paso implícito. Si no hay ninguna entrada siguiente, el flujo de trabajo se completará.

## Tipos de pasos

### **acción**

Un paso que ejecuta una acción específica. Consulte [el Catálogo de Acciones](/docs/workflow-automation/setup-and-configuration/actions-catalog/actions-catalog) para conocer las opciones disponibles.

* **`steps[*].action`** (Obligatorio)

  * **Tipo**: Cadena

  * **Descripción**: El nombre completo de la función de acción que se va a ejecutar. Deberá seguir la siguiente convención:

    `<company domain>.<category of work>.<action name in camelCase>`

  * **Ejemplo**:

    * Acción que emplea los servicios de New Relic (por ejemplo, a través de NerdGraph): `newrelic.dashboards.getDashboard`
    * Acción mediante Slack: `slack.chat.postMessage`

* **`steps[*].version`** (Obligatorio)

  * **Tipo**: Cadena
  * **Descripción**: La versión de la función de acción que se va a ejecutar.

* **`steps[*].inputs`** (Opcional)

  * **Tipo**: Mapa de valores (incluye [expresiones]())

  * **Descripción**:

    * Los datos de entrada que se pasarán a la función de acción. Las entradas específicas aceptadas se definen para cada acción.
    * Las entradas pueden emplear expresiones. Consulte la sección [Cadenas de expresiones]() para obtener más detalles.

  <Callout variant="important">
    No se deben pasar datos sensibles (ni claves de API ni secretos, ni PII, PHI ni ningún dato de identificación personal) como argumentos.
  </Callout>

* **`steps[*].inputs.selectors`** (Opcional)

  * **Tipo**: lista de mapas en la forma `name` con `expression`.

  * **Descripción**:

    * La entrada `selectors` permite redefinir la salida para que solo devuelva los elementos especificados.
    * Se puede emplear la expresión. Consulte la sección [Cadenas de expresiones]() para obtener más detalles.

  * **Ejemplo**

    * En el ejemplo dado, estamos obteniendo `pageUrl` y `statusDescription` como respuesta de la acción http.get.

    ```yaml
        name: status
        description: A workflow for checking the status of New Relic components

        steps:
          - name: query1
            type: action
            action: http.get
            version: 1
            inputs:
              url: "https://status.newrelic.com/api/v2/status.json"
              selectors:
                - name: statusCode
                  expression: '.statusCode'
                - name: pageUrl
                  expression: '.responseBody | fromjson | .page.url'
                - name: statusDescription
                  expression: '.responseBody | fromjson | .status.description'

          - name: logOutput1
            type: action
            action: newrelic.ingest.sendLogs
            version: 1
            inputs:
              logs:
                - message: "status is '${{ .steps.query1.outputs.statusDescription }}' details at ${{ .steps.query1.outputs.pageUrl }}"
    ```

### **bucle**

Un bucle iterará sobre una colección dada definida por `in` y creará variables de bucle `index` y `element` para cada una de sus iteraciones. Estas variables de bucle son accesibles dentro del bucle solo con la expresión `${{ .steps.<loopStepName>.loop.element }}` o `${{ .steps.<loopStepName>.loop.index }`

Para más detalles, consulte a continuación:

<CollapserGroup>
  <Collapser id="moreforloop" title="Bucle para iterar a través de una lista, mapa o colección">
    Puedes usar el bucle para iterar a través de una lista, un mapa o una colección.

    * `for` (Requerido)

      * **Tipo**: Constante
      * **Descripción**: Señal de inicio de un bucle.

    * `in` (Requerido)

      * **Tipo**: cadena (expresión)
      * **Descripción**: Una expresión que debe evaluar como una colección de elementos.

    * `steps` (Requerido)

      * **Descripción**: Pasos a ejecutar en cada iteración del bucle. Un paso puede ser de cualquier tipo, incluyendo otro bucle.

      * **Ejemplos**: A continuación se muestra cómo ejecutar el flujo de trabajo de bucle Inputs. Tenga en cuenta que el resultado debe ser un tipo de colección.

        ```yaml
            name: myWorkflow
            steps:
              - name: loopStep
                type: loop
                for:
                  in: '${{ .workflowInputs.count }}'
                  steps:
                    - name: step1
                      type: action
                      action: example.messaging.sayHello
                      version: '1.0.0'
                      inputs:
                        name: '${{ .steps.loopStep.loop.element }}' # not exist outside of this loop
                        index: '${{ .steps.loopStep.loop.index }}' # not exist outside of this loop
        ```

    <Callout variant="important">
      * `element` y `index` se asignan automáticamente como parte del bucle.
      * `Index` es de base cero.
      * El `element` puede ser un tipo complejo si tienes una colección de elementos complejos.
      * Todas las variables de bucle y las salidas de los pasos dentro del bucle tienen un ámbito de nivel de bucle. Estas variables se borran luego de salir del bucle y acceder a ellas fuera del bucle dará como resultado un valor nulo. Un bucle puede acceder a variables que están fuera del bucle si se definió previamente.
    </Callout>

    **Bucle for simple con enteros**

    ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: ${{ [range(1; 6)] }}
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'  # [1, 2, 3, 4, 5]
                    index: '${{ .steps.loopStep.loop.index }}' # [0, 1, 2, 3, 4]
    ```

    **Bucle simple para el mapa**

    ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'  # [{ "key1": "val1" }, { "key2": "val2"}]
                    index: '${{ .steps.loopStep.loop.index }}' # [0, 1]
    ```

    **Saltar dentro de un bucle**

    Solo se permite saltar entre pasos con nombre que pertenezcan al mismo bucle for. No está permitido entrar o salir de un bucle for, acceder a un bucle interno/externo o alternar entre dos bucles for diferentes.

    ```yaml
        name: myWorkflow
        steps:
          - name: firstStep
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
          - name: loopStep
            type: loop
            for:
              in: '${{ .workflowInputs.count }}'
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'
                  next: step3                                 # Okay within the loop
                - name: step2
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.step1.outputs.greeting }}'
                - name: step3
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  next: firstStep                            # Not okay, first step is not in the loop context
    ```

    **Emplee break/continue en un bucle**

    Para cambiar el flujo de un bucle for, puede usar `next: break` o `next: continue`. Tenga en cuenta que `break` y `continue` son objetivos de salto reservados definidos implícitamente dentro de un bucle. El uso de `next: break` o `next: continue` fuera de un bucle saltará al final de los pasos del flujo de trabajo.

    * El `end` funciona igual que `break` si se usa dentro de un bucle.
    * Next se puede emplear tanto en pasos de conmutación como en cualquier tipo de paso.

    ```yaml
      name: myWorkflow
      steps:
        - name: loopStep
          type: loop
          for:
            in: '${{ [range(1; 6)] }}'
            steps:
              - name: insideLoopStep1
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
                next: continue
              - name: insideLoopStep2
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
        - name: loopStepAgain
          type: loop
          for:
            in: '${{ .workflowInputs.count }}'
            steps:
              - name: switchStep
                type: switch
                switch:
                  - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                    next: break
              - name: insideLoopStepAgain
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStepAgain.loop.element }}'
    ```
  </Collapser>
</CollapserGroup>

* **`steps[*].for`** (Obligatorio)

  * **Tipo**: constante
  * **Descripción**: Señal de inicio de un bucle

* **`steps[*].in`** (Obligatorio)

  * **Tipo**: cadena (expresión)

  * **Descripción**: Una expresión que debe evaluar como una colección de elementos.

  * **`steps[*].steps`** (Opcional)

    * **Descripción**: Pasos a ejecutar en cada iteración del bucle. Consulte la definición para ver los pasos anteriores.

    * **Ejemplo**:

      ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: "${{ [range(1; 5)] }}""
              steps:
                - name: step1
                  type: action
                  action: newrelic.ingest.sendLogs
                  version: 1
                  inputs:
                    logs:
                      - message: "Loop: ${{ .steps.loopStep.loop.element }}"
      ```

### **cambiar**

* Un paso que comprueba varias condiciones y toma la primera rama que se evalúa como verdadera.

* Un interruptor puede contener cualquier número de elementos de condición en una lista. Comprobará las condiciones en orden y procesará la primera que se evalúe como verdadera. Si ninguna se evalúa como verdadera, ejecutará su siguiente paso como se define en steps\[\*].next

* **`steps[*].switch`** (Obligatorio)

  * **Tipo**: matriz
  * **Descripción**: Una matriz de casos switch, que especifica la lista ordenada de condiciones a evaluar.

* **`steps[*].switch[*].condition`** (Obligatorio)

  * **Tipo**: cadena (expresión)
  * **Descripción**: Estado de la carcasa del interruptor. Si la evaluación es verdadera, se ejecutará el siguiente paso del caso.

* **`steps[*].switch[*].next`** (Obligatorio)

  * **Tipo**: cadena (que se ajusta al [patrón seguro para expresiones]())
  * **Descripción**: El nombre del paso a ejecutar si la condición del caso se evalúa como verdadera. La palabra clave especial &quot;end&quot; puede emplear para indicar que este paso debe ser el último en ejecutar.

  ```yaml
  - name: hasCompleted
    type: switch
    switch:
      - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Failed" }}
        next: displayError
      - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Success" }}
        next: displaySuccess
    next: displayUnexpected
  ```

### esperar

Un paso que hace que el flujo de trabajo espere un cierto número de segundos antes de continuar. También puede escuchar una o más señales. Si no se recibe ninguna señal durante la espera, continuará con normalidad. Las señales se definen en una lista. Cada señal debe tener definido un siguiente paso correspondiente. La primera señal que se reciba será la que se procese. El valor recibido para la señal se almacenará en la salida del paso de espera y podrá emplear para el procesamiento lógico en pasos posteriores.

* Ejemplo:

  ```yaml
    name: waitSignalExample
    workflowInputs:
    steps:
      - name: waitStep
        type: wait
        seconds: 300
        signals: [{name: 'mySignalName', next: 'firstStep'}]
      - name: endStep
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: "didn't get signal"
        next: end
      - name: firstStep
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: ${{ .steps.waitStep.outputs.signalInputs.myString }}
  ```

* **`steps[*].seconds`** (Obligatorio)

  * **Tipo**: número
  * **Descripción**: Número de segundos que se deben esperar antes de continuar con la ejecución del flujo de trabajo.

* **`steps[*].signals`**

  * **Tipo**: matriz
  * **Descripción**: Las señales que, al ser recibidas, desviarán el flujo del programa.

* **`steps[*].signals[*].name`**

  * **Tipo**: cadena
  * **Descripción**: El nombre de la señal que se debe escuchar.

* **`steps[*].signals[*].next`**

  * **Tipo**: cadena
  * **Descripción**: Paso a ejecutar si se recibe la señal especificada.

## Tipos compartidos

### Cadenas de expresión

Varias propiedades aceptan valores de cadena con expresiones incrustadas que se evalúan durante la ejecución del flujo de trabajo, lo que permite emplear valores dinámicos dentro de las definiciones del flujo de trabajo. Las cadenas de expresión pueden contener una o varias expresiones, cada una de las cuales está encerrada entre llaves dobles. El contenido dentro de las llaves se evalúa usando jq.

jq proporciona la capacidad de acceder y operar con valores de muchas maneras. Por ejemplo, la longitud de una cadena de entrada de flujo de trabajo podría lograr con lo siguiente: `${{ .workflowInputs.myString | length }}`

Esta herramienta se puede emplear para construir y [probar expresiones JQ](https://play.jqlang.org/).

### Propiedades de expresión

Se puede acceder a varias propiedades mediante expresiones. Estas propiedades residen en un objeto de “ámbito”, por lo que las expresiones deben comenzar con un punto (.) para acceder a esas propiedades del objeto de ámbito.

Las propiedades disponibles son:

* `workflowInputs` - Objeto que contiene las entradas pasadas al flujo de trabajo al inicio.
  * Ejemplo: `${{ .workflowInputs.myInput }}`
* `steps` - Objeto que contiene una propiedad para cada paso del flujo de trabajo
  * `steps.<stepName>` - Objeto que contiene propiedades para un paso específico
    * `steps.<stepName>.outputs` - Objeto que contiene propiedades de resultado, específicas del paso/acción.
      * Ejemplo: `${{ .steps.myStep.outputs.myResult }}`

### Resultados de la evaluación de la expresión

Una sola expresión jq puede evaluar como cualquier tipo JSON, pero es importante tener en cuenta que el resultado final de una cadena de expresión completa dependerá del contenido de la cadena (si la hay) que rodea a la(s) expresión(es).

Si la totalidad de una cadena de expresión consiste en una sola expresión, entonces se evaluará al resultado de la expresión jq, manteniendo el tipo JSON del resultado. Por ejemplo, si a un flujo de trabajo se le pasa una matriz como entrada, la cadena `${{ .workflowInputs.myArray }}` se evaluaría como una matriz. Esto puede resultar útil para transmitir datos complejos dentro de un flujo de trabajo.

Si la cadena de expresión contiene contenido distinto de una única expresión, se evaluará como un resultado de cadena. Por ejemplo, esto ocurre cuando una expresión tiene contenido antes o después, o si la cadena contiene varias expresiones. Cada expresión dentro de la cadena se evalúa y se convierte a una representación de cadena.

Ejemplo:

Para los siguientes ejemplos, suponga que myArray tiene un valor de \[1, 2, 3].

<table>
  <thead>
    <tr>
      <th>
        Cadena de expresión
      </th>

      <th>
        Datos de resultados
      </th>

      <th>
        Tipo de resultado
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `${{ .workflowInputs.myArray }}`
      </td>

      <td>
        \[1, 2, 3]
      </td>

      <td>
        matriz de números
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        3
      </td>

      <td>
        número
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        verdadero
      </td>

      <td>
        booleano
      </td>
    </tr>

    <tr>
      <td>
        `Input is not empty: ${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        &quot;La entrada no está vacía: verdadero&quot;
      </td>

      <td>
        cadena
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray }} has length ${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        &quot;tiene una longitud de 3&quot;
      </td>

      <td>
        cadena
      </td>
    </tr>
  </tbody>
</table>

### Patrón seguro para expresiones [#expression-safe-pattern]

Las propiedades que se pueden emplear en expresiones deben ajustar a la siguiente expresión regular: `^[A-Za-z_][A-Za-z0-9_]*$`

### Referencias secretas

Los valores secretos se pueden usar en acciones a través de cadenas de referencia que especifican el nombre de un secreto que se buscará en el Servicio de Secretos. Para hacer referencia a un secreto en una definición de flujo de trabajo, emplee la siguiente sintaxis:

* `${{ :secrets:<SECRET_NAME> }}` para un secreto que no está en un `namespace`
* `${{ :secrets:<NAMESPACE>:<SECRET_NAME> }}` para un secreto en un `namespace`

Una cadena de expresión puede contener una mezcla de referencias secretas y expresiones JQ y/o múltiples referencias secretas.

Ejemplos:

```yaml
  steps:
  - name: bearer_auth
    type: action
    action: http.post
    inputs:
      headers:
        Authorization: Bearer ${{ :secrets:<SECRET_NAME> }}
```

## Ejemplos

* Hola Mundo

```yaml
name: helloWorld
description: 'A hello world workflow'

workflowInputs:
  name:
    type: String
    defaultValue: World
    required: false
    validations:
      - type: maxLength
        errorMessage: "name must be at most 100 characters"
        length: 100
  slackTokenSecret:
    type: String
    defaultValue: "${{ :secrets:SLACK_TOKEN }}"
  slackChannel:
    type: String
    defaultValue: my-channel
    validations:
      - type: regex
        errorMessage: "A slack channel name must be lowercase and can only contain letters, numbers, and hyphens"
        pattern: "^[a-z0-9\\-]+$"
    required: true

steps:
  - name: init1
    type: assign
    inputs:
      greeting: Hello ${{ .workflowInputs.name }}

  - name: logName
    type: action
    action: newrelic.ingest.sendLogs
    version: 1
    inputs:
      logs:
        - message: ${{ .steps.init1.outputs.greeting }}

  - name: waiting1
    type: wait
    seconds: 1

  - name: queryForLog
    type: action
    action: newrelic.nrdb.query
    version: 1
    inputs:
      query: >-
        FROM Log SELECT * WHERE message LIKE '${{ .steps.init1.outputs.greeting
        }}'

  - name: checkResult
    type: switch
    switch:
      - condition: ${{ .steps.queryForLog.outputs.results | length > 0 }}
        next: FoundMessage

  - name: waitingMessage
    type: action
    action: slack.chat.postMessage
    version: 1
    inputs:
      channel: ${{ .workflowInputs.slackChannel }}
      text: Waiting for log message...
      token: ${{ .workflowInputs.slackTokenSecret }}
    next: waiting1

  - name: FoundMessage
    type: action
    action: slack.chat.postMessage
    version: 1
    inputs:
      channel: ${{ .workflowInputs.slackChannel }}
      text: Found message! ${{ .steps.queryForLog.outputs.results[0].message }}
      token: ${{ .workflowInputs.slackTokenSecret }}
```