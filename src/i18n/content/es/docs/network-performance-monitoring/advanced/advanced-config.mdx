---
title: Configuración avanzada para Monitoreo de red
tags:
  - Integrations
  - Network monitoring
  - Advanced configuration
metaDescription: Advanced configuration options for network monitoring
freshnessValidatedDate: never
translationType: machine
---

Si desea explorar todas las opciones que puede utilizar al configurar el monitoreo de su red, consulte las siguientes secciones.

## `snmp-base.yaml` archivo de muestra [#snmp-base-yml-template]

A continuación se muestra un ejemplo de las diversas opciones de configuración disponibles en el archivo `snmp-base.yaml` utilizado por la imagen Docker `ktranslate` para sondear dispositivos de datos de flujo y SNMP. También puede ver una muestra muy comentada en el [repositorio de KTranslate en GitHub](https://github.com/kentik/ktranslate/blob/main/config/snmp.yaml.sample).

```yaml
# Configuration of every device monitored by this container
devices:
  # Sample of SNMP v2c device
  ups_snmpv2c__10.10.0.201:
    device_name: ups_snmpv2c
    device_ip: 10.10.0.201
    snmp_comm: $YOUR_COMMUNITY_STRING
    oid: .1.3.6.1.4.1.318.1.3.27
    description: "APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: apc_ups.yml
    provider: kentik-ups
    poll_time_sec: 300
    retries: 1
    timeout_ms: 5000
    user_tags:
      owning_team: dc_ops
    discovered_mibs:
    - PowerNet-MIB_UPS
    - TCP-MIB
    - UDP-MIB
    purge_after_num: 1
  # Sample of SNMP v3 device
  router_snmpv3__10.10.0.202:
    device_name: router_snmpv3
    device_ip: 10.10.0.202
    snmp_v3:
      user_name: $YOUR_USER_NAME
      authentication_protocol: $YOUR_AUTH_PROTOCOL
      authentication_passphrase: $YOUR_AUTH_PASSPHRASE
      privacy_protocol: $YOUR_PRIVACY_PROTOCOL
      privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
    oid: .1.3.6.1.4.1.9.1.544
    description: "Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version
      15.1(3)T4, RELEASE SOFTWARE (fc1)\r\nTechnical Support: http://www.cisco.com/techsupport\r\nCopyright
      (c) 1986-2012 by Cisco Systems, Inc.\r\nCompiled Thu 24-May-12 04:27 by prod_rel_team"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: cisco-asr.yml
    provider: kentik-router
    user_tags:
      owning_team: core-networking
    discovered_mibs:
    - BGP4-MIB
    - CISCO-MEMORY-POOL-MIB
    - CISCO-PROCESS-MIB
    - IF-MIB
    - OSPF-MIB
    engine_id: "80:00:01:01:0a:14:1e:28"
    match_attributes:
      if_interface_name: "^Ten.*|^Gig.*"
      "!if_Alias": "[Uu]plink"
  # Sample of SNMP v1 device
  netbotz_snmpv1__10.10.0.203:
    device_name: netbotz_snmpv1
    device_ip: 10.10.0.201
    snmp_comm: $YOUR_COMMUNITY_STRING
    use_snmp_v1: true
    oid: .1.3.6.1.4.1.5528.100.20.10.2013
    description: "Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: apc-netbotz.yml
    provider: kentik-netbotz
    user_tags:
      owning_team: sys_ops
    discovered_mibs:
    - IF-MIB
    - IP-MIB
    - TCP-MIB
    - UDP-MIB
    no_use_bulkwalkall: true
  # Sample of "flow only" device
  flow_only__10.10.0.210:
    device_name: flow_only
    device_ip: 10.10.0.210
    user_tags:
      owning_team: net_eng
    flow_only: true
  # Sample of "ping only" device
  ping_only__10.10.0.220:
    device_name: ping_only
    device_ip: 10.10.0.220
    provider: kentik-ping
    user_tags:
      owning_team: load_balancing
    ping_only: true
    ping_interval_sec: 5
  # Sample of Arista eAPI device
  arista_eapi_10.10.0.230:
    device_name: arista_eapi
    device_ip: 10.10.0.230
    snmp_comm: public
    oid: .1.3.6.1.4.1.30065.1.3011.7020.3735.24.2878.2
    description: "Arista Networks EOS version 4.22.9M running on an Arista
      Networks DCS-7020SR-24C2"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: arista-switch.yml
    provider: kentik-switch
    discovered_mibs:
    - ARISTA-BGP4V2-MIB
    - ARISTA-QUEUE-MIB
    - BGP4-MIB
    - HOST-RESOURCES-MIB
    - IF-MIB
    ext:
      ext_only: false
      eapi_config:
        username: $YOUR_ARISTA_API_USERNAME
        password: $YOUR_ARISTA_API_PASSWORD
        transport: https
        port: 443
  # Sample of Meraki Dashboard API device
  meraki_dashboard_api:
    device_name: meraki_controller
    device_ip: snmp.meraki.com
    provider: meraki-cloud-controller
    ext:
      ext_only: true
      meraki_config:
        api_key: $YOUR_MERAKI_API_KEY
        monitor_devices: true
        monitor_org_changes: true
        monitor_uplinks: true
        monitor_vpn_status: true
        organizations:
          - "Top Org.*"
        networks:
          - "Production"
          - "Guest"
        product_types:
          - appliance
        preferences:
          device_status_only: true
          hide_uplink_usage: false
          show_vpn_peers: true
          show_network_attr: true
# Configuration for receipt of SNMP Traps
trap:
  listen: 0.0.0.0:1620
  community: public
  version: ""
  transport: ""
  v3_config: null
  trap_only: false
  drop_undefined: false
# Configuration for the SNMP discovery job
discovery:
  cidrs:
  - 10.0.0.0/24
  - 10.0.0.202/32
  ignore_list:
  - 10.0.0.98
  - 10.0.0.99
  debug: false
  ports:
  - 161
  - 1161
  default_communities:
  - $YOUR_COMMUNITY_STRING_1
  - $YOUR_COMMUNITY_STRING_2
  - $YOUR_COMMUNITY_STRING_3
  use_snmp_v1: false
  default_v3: null
  add_mibs: true
  threads: 4
  add_devices: true
  replace_devices: true
  no_dedup_engine_id: false
  check_all_ips: true
global:
  poll_time_sec: 60
  drop_if_outside_poll: false
  mib_profile_dir: /etc/ktranslate/profiles
  mibs_db: /etc/ktranslate/mibs.db
  mibs_enabled:
  - ARISTA-BGP4V2-MIB
  - ARISTA-QUEUE-MIB
  - BGP4-MIB
  - CISCO-MEMORY-POOL-MIB
  - CISCO-PROCESS-MIB
  - HOST-RESOURCES-MIB
  - IF-MIB
  - OSPF-MIB
  - PowerNet-MIB_UPS
  timeout_ms: 3000
  retries: 0
  global_v3: null
  response_time: false
  user_tags:
    environment: production
  match_attributes:
    if_Description: ".*WAN.*"
  purge_devices_after_num: 0
```

<CollapserGroup>
  <Collapser
    id="devices"
    title="Sección de dispositivos"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nombre clave
          </th>

          <th>
            Requerido
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            device_name
          </td>

          <td>
            ✓
          </td>

          <td>
            Nombre del dispositivo. Este es el identificador único del dispositivo en New Relic.
          </td>
        </tr>

        <tr>
          <td>
            device_ip
          </td>

          <td>
            ✓
          </td>

          <td>
            IP objetivo del dispositivo.
          </td>
        </tr>

        <tr>
          <td>
            snmp_comm
          </td>

          <td>
            ✓ (Requerido para SNMPv1/2c)
          </td>

          <td>
            `SNMPv1/2c` cadena comunitaria a utilizar.
          </td>
        </tr>

        <tr>
          <td>
            use_snmp_v1
          </td>

          <td>
            ✓ (Requerido para SNMPv1)
          </td>

          <td>
            Indica si se debe utilizar SNMPv1. De forma predeterminada, está configurado en `false`.
          </td>
        </tr>

        <tr>
          <td>
            snmp_v3
          </td>

          <td>
            ✓ (Requerido para SNMPv3)
          </td>

          <td>
            [Configuración SNMP v3](#snmpv3-config)
          </td>
        </tr>

        <tr>
          <td>
            depurar
          </td>

          <td/>

          <td>
            Indica si se debe habilitar el registro de nivel de depuración durante el sondeo SNMP. De forma predeterminada, está configurado en `false`.
          </td>
        </tr>

        <tr>
          <td>
            port
          </td>

          <td/>

          <td>
            Puerto al que enviar la consulta SNMP. De forma predeterminada, está configurado en el puerto `161`.
          </td>
        </tr>

        <tr>
          <td>
            oid
          </td>

          <td>
            ✓ (Requerido para el sondeo SNMP)
          </td>

          <td>
            El `systemObjectID | sysObjectID | sysOID` descubierto para el dispositivo. Esto se utiliza para hacer coincidir el dispositivo con un perfil SNMP conocido y establecer el atributo `provider` . Si no se encuentra ninguna coincidencia, esto establece el `provider` como un dispositivo [kentik predeterminado](/docs/network-performance-monitoring/troubleshooting/snmp-discovery-kentik-default) .
          </td>
        </tr>

        <tr>
          <td>
            descripción
          </td>

          <td/>

          <td>
            El `sysDescr` descubierto del dispositivo. Este campo es informativo.
          </td>
        </tr>

        <tr>
          <td>
            last_checked
          </td>

          <td/>

          <td>
            Timestamp cuando este dispositivo fue descubierto por última vez por la imagen de la Docker `ktranslate`. Este campo es informativo.
          </td>
        </tr>

        <tr>
          <td>
            mib_profile
          </td>

          <td>
            ✓ (Requerido para el sondeo SNMP)
          </td>

          <td>
            Archivo de perfil SNMP asociado con este dispositivo durante la ejecución de descubrimiento según su `sysOID`. <DNT>**If this starts with a bang (!) token, it will override the automatic matching from the `sysOID` and use a manual override.**</DNT> Ej: `"!cisco-asa.yml"` (se requieren comillas).
          </td>
        </tr>

        <tr>
          <td>
            provider
          </td>

          <td>
            ✓ (Requerido para New Relic)
          </td>

          <td>
            Valor utilizado durante la síntesis de entidades para New Relic. Esto se crea automáticamente en función del `mib_profile` coincidente y debe coincidir con una de las reglas en el repositorio [de definiciones de entidad](https://github.com/newrelic/entity-definitions/search?q=%22attribute%3A+provider%22+filename%3Adefinition.yml) para que se cree una entidad. Si agrega dispositivos manualmente, deberá tener cuidado para asegurarse de que este valor sea válido.
          </td>
        </tr>

        <tr>
          <td>
            poll_time_sec
          </td>

          <td/>

          <td>
            Indica la frecuencia de sondeo SNMP en segundos. Esta configuración se utiliza para anular el atributo `global.poll_time_sec` .
          </td>
        </tr>

        <tr>
          <td>
            reintentos
          </td>

          <td/>

          <td>
            Indica el número de intentos de volver a intentar sondear los OID de SNMP. Esta configuración se utiliza para anular el atributo `global.retries` .
          </td>
        </tr>

        <tr>
          <td>
            timeout_ms
          </td>

          <td/>

          <td>
            Indica el tiempo de espera del sondeo SNMP en milisegundos. Esta configuración se utiliza para anular el atributo `global.timeout_ms` .
          </td>
        </tr>

        <tr>
          <td>
            user_tags
          </td>

          <td/>

          <td>
            `key:value` atributo pair para darle más contexto al dispositivo. La etiqueta en este nivel se agregará a cualquier etiqueta aplicada en el atributo `global.user_tags` .
          </td>
        </tr>

        <tr>
          <td>
            discovered_mibs
          </td>

          <td/>

          <td>
            Lista de MIB extraídas de `mib_profile` coincidentes a las que este dispositivo puede responder. Este campo es informativo.
          </td>
        </tr>

        <tr>
          <td>
            engine_id
          </td>

          <td/>

          <td>
            El ID de motor único descubierto para el agente SNMP de este dispositivo. Generalmente se encuentra durante el descubrimiento de SNMP v3. Este campo es informativo.
          </td>
        </tr>

        <tr>
          <td>
            match_attributes
          </td>

          <td/>

          <td>
            `attribute:regex` pares para agregar métrica a la lista de permitidos. Los pares de este nivel se agregarán a cualquier par aplicado en el atributo `global.match_attributes` . Utiliza la sintaxis [RE2](https://github.com/google/re2/wiki/Syntax) y tiene un operador `OR` predeterminado. Tecla de prefijo con `!` para forzar a `AND` operadores.
          </td>
        </tr>

        <tr>
          <td>
            monitor_admin_shut
          </td>

          <td/>

          <td>
            Indica si se deben monitor las interfaces en estado `Administratively Shutdown`. De forma predeterminada, está configurado en `false`.
          </td>
        </tr>

        <tr>
          <td>
            no_use_bulkwalkall
          </td>

          <td/>

          <td>
            Deshabilita la acción de solicitud SNMP `GETBULK` cuando `true`. De forma predeterminada, está configurado en `false`.
          </td>
        </tr>

        <tr>
          <td>
            response_time
          </td>

          <td/>

          <td>
            Indica si el sondeo [de tiempo de respuesta](#response_time-attribute) está habilitado para este dispositivo. De forma predeterminada, está configurado en `false`.
          </td>
        </tr>

        <tr>
          <td>
            ping_only
          </td>

          <td/>

          <td>
            Deshabilita todos los sondeos SNMP y habilita el sondeo [de tiempo de respuesta](#response_time-attribute) para este dispositivo cuando `true`. Esta configuración anulará el atributo `global.response_time` . De forma predeterminada, está configurado en `false`. Querrá asegurarse de haber incluido la línea `provider: kentik_ping` para cada dispositivo ping_only.
          </td>
        </tr>

        <tr>
          <td>
            ping_interval_sec
          </td>

          <td/>

          <td>
            Esta configuración se utiliza para anular la velocidad predeterminada de 1 paquete/seg utilizada durante `ping_only` \| `response_time` encuesta.
          </td>
        </tr>

        <tr>
          <td>
            flow_only
          </td>

          <td/>

          <td>
            Deshabilita todos los sondeos SNMP cuando `true`. De forma predeterminada, está configurado en `false`.
          </td>
        </tr>

        <tr>
          <td>
            purge_after_num
          </td>

          <td/>

          <td>
            Elimina el dispositivo del archivo de configuración después de que X trabajos de descubrimiento programados hayan fallado. <DNT>**This setting overrides the global `purge_devices_after_num` setting.**</DNT> Establezca esto en `-1` para conservar el dispositivo para siempre, o cualquier número entero >= `1` para configurar un umbral de purga. (Predeterminado: `0`)
          </td>
        </tr>

        <tr>
          <td>
            ext
          </td>

          <td>
            ✓ (Requerido para el sondeo API)
          </td>

          <td>
            [Configuración de sondeo API](#optional-api-polling-configurations)
          </td>
        </tr>

        <tr>
          <td>
            ext.ext_only
          </td>

          <td/>

          <td>
            Deshabilita todos los sondeos SNMP para esta configuración `device_name` . Predeterminado: `false`.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="trap"
    title="Sección de trampa"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nombre clave
          </th>

          <th>
            Requerido
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            escuchar
          </td>

          <td>
            ✓
          </td>

          <td>
            Puerto IP de escucha para recibir capturas SNMP. De forma predeterminada, está configurado en `0.0.0.0:1620` y utilizamos una redirección en su comando `docker run ...` para redirigir el UDP 162 más común en el host al UDP 1620 en el contenedor. La redirección se realiza con esta bandera. `-p 162:1620/udp`
          </td>
        </tr>

        <tr>
          <td>
            comunidad
          </td>

          <td/>

          <td>
            Cadena de comunidad SNMPv1/v2c para recibir capturas SNMP. De forma predeterminada, seguimos procesando trampas entrantes incluso si no coinciden con esta comunidad.
          </td>
        </tr>

        <tr>
          <td>
            versión
          </td>

          <td/>

          <td>
            Versión SNMP a utilizar. Las opciones son `v1`, `v2c` y `v3`. De forma predeterminada, está configurado en `v2c`.
          </td>
        </tr>

        <tr>
          <td>
            transporte
          </td>

          <td/>

          <td>
            Protocolo de transporte SNMP a utilizar. Las opciones son `TCP` y `UDP`. De forma predeterminada, está configurado en `UDP`
          </td>
        </tr>

        <tr>
          <td>
            v3_config
          </td>

          <td/>

          <td>
            [Configuración SNMP v3](#snmpv3-config) a utilizar. Solo se usa si `version: v3`.
          </td>
        </tr>

        <tr>
          <td>
            trap_only
          </td>

          <td/>

          <td>
            Establecer esto en `true` evitará que el contenedor intente realizar cualquier sondeo SNMP o ICMP, que se utiliza en los casos en los que desea un contenedor que solo escuche las capturas entrantes.
          </td>
        </tr>

        <tr>
          <td>
            drop_undefined
          </td>

          <td/>

          <td>
            Establecer esto en `true` evitará que el contenedor reenvíe mensajes de captura SNMP que no estén definidos explícitamente en un perfil SNMP existente. (Predeterminado: `false`)
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="discovery"
    title="Sección de descubrimiento"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nombre clave
          </th>

          <th>
            Requerido
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            cidrs
          </td>

          <td>
            ✓
          </td>

          <td>
            Matriz de rangos de IP objetivo en [notación CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). Tenga cuidado con el tamaño de estos rangos para [evitar un tiempo de espera](/docs/network-performance-monitoring/troubleshooting/snmp-discovery-no-devices).
          </td>
        </tr>

        <tr>
          <td>
            ignore_list
          </td>

          <td/>

          <td>
            Matriz de direcciones IP que desea ignorar explícitamente durante todos los trabajos de descubrimiento.
          </td>
        </tr>

        <tr>
          <td>
            depurar
          </td>

          <td/>

          <td>
            Indica si se debe habilitar el registro de nivel de depuración durante el descubrimiento. De forma predeterminada, está configurado en `false`
          </td>
        </tr>

        <tr>
          <td>
            ports
          </td>

          <td>
            ✓
          </td>

          <td>
            Matriz de puertos de destino para escanear durante el sondeo SNMP.
          </td>
        </tr>

        <tr>
          <td>
            default_communities
          </td>

          <td>
            ✓ (Requerido para SNMPv1/2c)
          </td>

          <td>
            Matriz de cadenas de comunidad SNMPv1/v2c para escanear durante el sondeo SNMP. Esta matriz se evalúa en orden y el descubrimiento acepta la primera comunidad que pasa.
          </td>
        </tr>

        <tr>
          <td>
            use_snmp_v1
          </td>

          <td>
            ✓ (Requerido para SNMPv1)
          </td>

          <td>
            Indica si se debe utilizar SNMPv1 durante el descubrimiento. De forma predeterminada, está configurado en `false`
          </td>
        </tr>

        <tr>
          <td>
            default_v3
          </td>

          <td>
            ✓ (Requerido para SNMPv3)
          </td>

          <td>
            [Configuración SNMPv3](#snmpv3-config) única para escanear durante el sondeo SNMP.
          </td>
        </tr>

        <tr>
          <td>
            other_v3s
          </td>

          <td>
            ✓ (Requerido para SNMPv3)
          </td>

          <td>
            Múltiples [configuraciones SNMPv3](#snmpv3-config) para escanear durante el sondeo SNMP. <DNT>**Use this option OR `default_v3`, not both**</DNT>
          </td>
        </tr>

        <tr>
          <td>
            add_devices
          </td>

          <td>
            ✓
          </td>

          <td>
            Indica si se deben agregar dispositivos descubiertos a la sección `devices` del archivo `snmp-base.yaml` . De forma predeterminada, está configurado en `true`.
          </td>
        </tr>

        <tr>
          <td>
            add_mibs
          </td>

          <td>
            ✓
          </td>

          <td>
            Indica si se deben agregar MIB descubiertas a la sección `global.mibs_enabled` del archivo `snmp-base.yaml` . De forma predeterminada, está configurado en `true`.
          </td>
        </tr>

        <tr>
          <td>
            hilos
          </td>

          <td>
            ✓
          </td>

          <td>
            Límite entero de subprocesos que se utilizarán durante el descubrimiento. Debe ser menor que la cantidad de núcleos disponibles para el contenedor. De forma predeterminada está configurado en `4`.
          </td>
        </tr>

        <tr>
          <td>
            replace_devices
          </td>

          <td>
            ✓
          </td>

          <td>
            Indica si se deben reemplazar los dispositivos descubiertos si ya existen en la sección `devices` del archivo `snmp-base.yaml` . De forma predeterminada, está configurado en `true`.
          </td>
        </tr>

        <tr>
          <td>
            no_dedup_engine_id
          </td>

          <td/>

          <td>
            Cuando se establece en `true`, deshabilita la deduplicación de dispositivos descubiertos si parece que son el mismo dispositivo, según su ID de motor SNMP informado. De forma predeterminada, está configurado en `false`
          </td>
        </tr>

        <tr>
          <td>
            check_all_ips
          </td>

          <td/>

          <td>
            Cuando se establece en `true`, obliga al trabajo de descubrimiento a intentar la conectividad SNMP con cada dirección IP de destino de la matriz `cidrs` , sin verificar primero la vitalidad a través del escaneo del puerto TCP. Esta configuración ralentizará los trabajos de detección, pero puede ayudar a evitar problemas en los que la detección falla en dispositivos que no figuran en su `cidrs` matriz con `/32` anulaciones. De forma predeterminada, está configurado en `false`
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="global"
    title="Sección global"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nombre clave
          </th>

          <th>
            Requerido
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            poll_time_sec
          </td>

          <td>
            ✓
          </td>

          <td>
            Tiempo en segundos para sondear dispositivos. Esto se puede anular por dispositivo utilizando el atributo `devices.<deviceName>.poll_time_sec` . De forma predeterminada, está configurado en `60`.
          </td>
        </tr>

        <tr>
          <td>
            drop_if_outside_poll
          </td>

          <td/>

          <td>
            Indica si se deben eliminar todos los valores de este ciclo si el sondeo tarda más que el valor establecido en `poll_time_sec`. De forma predeterminada, está configurado en `false`.
          </td>
        </tr>

        <tr>
          <td>
            mib_profile_dir
          </td>

          <td/>

          <td>
            Directorio para encontrar perfiles MIB seleccionados. Estos se incorporan automáticamente a la imagen `ktranslate` desde el repositorio [de perfiles snmp](https://github.com/kentik/snmp-profiles) de Kentik y se pueden anular en el tiempo de ejecución Docker creando un montaje de volumen de su propio directorio local de perfiles.
          </td>
        </tr>

        <tr>
          <td>
            mibs_db
          </td>

          <td/>

          <td/>
        </tr>

        <tr>
          <td>
            mibs_enabled
          </td>

          <td>
            ✓
          </td>

          <td>
            Matriz de todas las MIB activas que sondeará la imagen Docker `ktranslate`. Esta lista se genera automáticamente durante el descubrimiento si el atributo `discovery_add_mibs` es `true`. Las MIB que no figuran aquí no serán sondeadas en ningún dispositivo en el archivo de configuración. Puede especificar una tabla SNMP directamente en un archivo MIB usando la sintaxis `MIB-NAME.tableName` . Ej: `HOST-RESOURCES-MIB.hrProcessorTable`.
          </td>
        </tr>

        <tr>
          <td>
            timeout_ms
          </td>

          <td>
            ✓
          </td>

          <td>
            Tiempo en milisegundos Tiempo de espera de consulta SNMP. Esto se puede anular por dispositivo utilizando el atributo `devices.<deviceName>.timeout_ms` . De forma predeterminada, está configurado en `3000`.
          </td>
        </tr>

        <tr>
          <td>
            reintentos
          </td>

          <td>
            ✓
          </td>

          <td>
            Número de intentos fallidos de reintentar sondeos SNMP. Esto se puede anular por dispositivo utilizando el atributo `devices.<deviceName>.retries` . De forma predeterminada, está configurado en `0`.
          </td>
        </tr>

        <tr>
          <td>
            user_tags
          </td>

          <td/>

          <td>
            `key:value` atributo pair para darle más contexto al dispositivo. La etiqueta en este nivel se aplicará a todos los dispositivos en el archivo de configuración.
          </td>
        </tr>

        <tr>
          <td>
            match_attributes
          </td>

          <td/>

          <td>
            `attribute:regex` pares para agregar métrica a la lista de permitidos. Los pares de este nivel se compararán con todos los dispositivos en el archivo de configuración. Utiliza la sintaxis [RE2](https://github.com/google/re2/wiki/Syntax) y tiene un operador `OR` predeterminado. Tecla de prefijo con `!` para forzar a `AND` operadores.
          </td>
        </tr>

        <tr>
          <td>
            response_time
          </td>

          <td/>

          <td>
            Indica si el sondeo [de tiempo de respuesta](#response_time-attribute) está habilitado para todos los dispositivos en el archivo de configuración. De forma predeterminada, está configurado en `false`.
          </td>
        </tr>

        <tr>
          <td>
            purge_devices_after_num
          </td>

          <td/>

          <td>
            Elimina dispositivos del archivo de configuración después de que X trabajos de descubrimiento programados hayan fallado. Establezca esto en `-1` para conservar los dispositivos para siempre, o cualquier número entero >= `1` para configurar un umbral de purga. De forma predeterminada, está configurado en `0`.
          </td>
        </tr>

        <tr>
          <td>
            [watch_profile_changes](#watch-profile-changes)
          </td>

          <td/>

          <td>
            Configura un observador para [recargar subprocesos SNMP](#reload-snmp-threads) sobre cambios en los perfiles en la ruta `mib_profile_dir`. De forma predeterminada, está configurado en `false`.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## Secretos del proveedor de la nube [#cloud-provider-secrets]

El Monitoreo de red agente tiene soporte integrado para recuperar claves de [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/), [Azure Key Vault](https://learn.microsoft.com/en-us/azure/key-vault/general/) y [GCP Secret Manager](https://cloud.google.com/secret-manager/docs).

<Callout variant="important">
  SNMPv1 y SNMPv2c no admiten el uso de secretos de la nube, ya que los propios protocolos envían sus cadenas comunitarias en texto sin formato de forma predeterminada. Si le preocupa la seguridad de su autenticación SNMP, actualice para utilizar SNMPv3.
</Callout>

<Collapser
  id="cloud-secrets"
  title="Configuración de secretos de la nube"
>
  <Tabs>
    <TabsBar>
      <TabsBarItem id="aws-secrets-manager">
        Administrador de secretos de AWS
      </TabsBarItem>

      <TabsBarItem id="azure-key-vault">
        Bóveda de claves de Azure
      </TabsBarItem>

      <TabsBarItem id="gcp-secret-manager">
        Administrador secreto de GCP
      </TabsBarItem>
    </TabsBar>

    <TabsPages>
      <TabsPageItem id="aws-secrets-manager">
        Para utilizar AWS Secrets Manager, deberá configurar las siguientes tres [variables ambientales](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html#envvars-list) y proporcionarlas a Docker en tiempo de ejecución:

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                Nombre
              </th>

              <th>
                Descripción
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `AWS_ACCESS_KEY_ID`
              </td>

              <td>
                Especifica la clave de acceso de AWS utilizada como parte de las credenciales para autenticar al usuario.
              </td>
            </tr>

            <tr>
              <td>
                `AWS_SECRET_ACCESS_KEY`
              </td>

              <td>
                Especifica la clave secreta de AWS utilizada como parte de las credenciales para autenticar al usuario.
              </td>
            </tr>

            <tr>
              <td>
                `AWS_REGION`
              </td>

              <td>
                Especifica la región de AWS a la que enviar solicitudes.
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \
        -e AWS_ACCESS_KEY_ID=$YOUR_AWS_ACCESS_KEY_ID \
        -e AWS_SECRET_ACCESS_KEY=$YOUR_AWS_SECRET_ACCESS_KEY \
        -e AWS_REGION=$YOUR_AWS_REGION \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>

      <TabsPageItem id="azure-key-vault">
        Para usar Azure Key Vault, deberá configurar las siguientes cinco variables ambientales y proporcionarlas a Docker en tiempo de ejecución:

        <Callout variant="tip">
          Debe configurar `KT_AZURE_KEY_VAULT_NAME` o `KT_AZURE_KEY_VAULT_URL`, no ambos. El valor predeterminado es usar `KT_AZURE_KEY_VAULT_NAME` y el agente usará un patrón de URL común: `https://$KT_AZURE_KEY_VAULT_NAME.vault.azure.net/`
        </Callout>

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                Nombre
              </th>

              <th>
                Descripción
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `KT_AZURE_KEY_VAULT_NAME`
              </td>

              <td>
                El nombre del almacén donde se almacena el secreto.
              </td>
            </tr>

            <tr>
              <td>
                `KT_AZURE_KEY_VAULT_URL`
              </td>

              <td>
                URL completa opcional para la API de llamada al objetivo.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_CLIENT_ID](https://learn.microsoft.com/en-us/entra/identity-platform/howto-create-service-principal-portal#sign-in-to-the-application)
              </td>

              <td>
                A veces denominado `Application ID`, este es el identificador de la entidad de servicio utilizado para acceder al secreto.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_CLIENT_SECRET](https://learn.microsoft.com/en-us/entra/identity-platform/howto-create-service-principal-portal#option-3-create-a-new-client-secret)
              </td>

              <td>
                Este es el secreto del cliente (contraseña) que se utiliza para la entidad de servicio durante la autenticación. Tenga en cuenta que este ID es para el <DNT>**value**</DNT> del secreto del cliente, no el ID del secreto en sí.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_SUBSCRIPTION_ID](https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id#find-your-azure-subscription)
              </td>

              <td>
                Este es el GUID de 32 dígitos asociado con la suscripción donde se administra su secreto.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_TENANT_ID](https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id#find-your-microsoft-entra-tenant)
              </td>

              <td>
                A veces llamado `Directory ID`, este es el identificador del inquilino en Microsoft Entra donde se almacena el principio de su servicio.
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -e KT_AZURE_KEY_VAULT_NAME=$YOUR_KEY_VAULT_NAME \
        #### Optional: Provide the full URL to target
        # -e KT_AZURE_KEY_VAULT_URL=$YOUR_KEY_VAULT_URL \
        -e AZURE_CLIENT_ID=$YOUR_CLIENT_ID \
        -e AZURE_CLIENT_SECRET=$YOUR_CLIENT_SECRET \
        -e AZURE_TENANT_ID=$YOUR_TENANT_ID \
        -e AZURE_SUBSCRIPTION_ID=$YOUR_SUBSCRIPTION_ID \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>

      <TabsPageItem id="gcp-secret-manager">
        Para usar GCP Secret Manager, deberá configurar el siguiente montaje de volumen para un archivo JSON de credenciales junto con dos variables ambientales y proporcionarlas a la Docker en tiempo de ejecución:

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                Nombre
              </th>

              <th>
                Descripción
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                [Clave de cuenta de servicio](https://cloud.google.com/iam/docs/keys-create-delete#creating)
              </td>

              <td>
                Especifica la ruta del archivo local para la clave de la cuenta de servicio utilizada para autenticar al usuario. Este archivo se monta en volumen en el contenedor de la Docker y luego se hace referencia a él en la variable de entorno `GOOGLE_APPLICATION_CREDENTIALS`.
              </td>
            </tr>

            <tr>
              <td>
                [GOOGLE_APPLICATION_CREDENTIALS](https://cloud.google.com/docs/authentication/provide-credentials-adc#local-key)
              </td>

              <td>
                Especifica la ruta del archivo en el contenedor donde asignó el archivo de clave de su cuenta de servicio.
              </td>
            </tr>

            <tr>
              <td>
                [GOOGLE_CLOUD_PROJECT](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
              </td>

              <td>
                Especifica el ID único del proyecto donde se almacena el secreto.
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -v $YOUR_LOCAL_SERVICE_ACCOUNT_KEY_FILE_PATH:/gcp_snmp_sa_key.json \
        -e GOOGLE_APPLICATION_CREDENTIALS='./gcp_snmp_sa_key.json' \
        -e GOOGLE_CLOUD_PROJECT=$YOUR_PROJECT_ID \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>
    </TabsPages>
  </Tabs>
</Collapser>

## Opciones SNMPv3 [#snmpv3-options]

<CollapserGroup>
  <Collapser
    id="snmpv3-config"
    title="Configuración SNMPv3"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nombre clave
          </th>

          <th>
            Requerido
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            user_name
          </td>

          <td>
            ✓
          </td>

          <td>
            Nombre de usuario para la autenticación SNMPv3
          </td>
        </tr>

        <tr>
          <td>
            authentication_protocol
          </td>

          <td>
            ✓
          </td>

          <td>
            Protocolo de autenticación SNMPv3. Los valores posibles son `NoAuth`, `MD5` o `SHA`
          </td>
        </tr>

        <tr>
          <td>
            authentication_passphrase
          </td>

          <td/>

          <td>
            Frase de contraseña de autenticación SNMPv3
          </td>
        </tr>

        <tr>
          <td>
            privacy_protocol
          </td>

          <td>
            ✓
          </td>

          <td>
            Protocolo de privacidad SNMPv3. Los valores posibles son `NoPriv`, `DES`, `AES`, `AES192`, `AES256`, `AES192C` o `AES256C`
          </td>
        </tr>

        <tr>
          <td>
            privacy_passphrase
          </td>

          <td/>

          <td>
            Frase de contraseña de privacidad SNMPv3
          </td>
        </tr>

        <tr>
          <td>
            context_engine_id
          </td>

          <td/>

          <td>
            ID del motor de contexto SNMPv3
          </td>
        </tr>

        <tr>
          <td>
            context_name
          </td>

          <td/>

          <td>
            Nombre del contexto SNMPv3
          </td>
        </tr>
      </tbody>
    </table>

    ### Ejemplos:

    <Callout variant="tip">
      El uso de secretos de AWS, Azure o GCP también requerirá que [proporcione las variables de entorno adecuadas](/docs/network-performance-monitoring/advanced/advanced-config/#cloud-secrets) y cualquier otra información de autenticación necesaria para que el agente consulte la API de destino.
    </Callout>

    <Tabs>
      <TabsBar>
        <TabsBarItem id="v3-plain-text">
          Texto sin formato
        </TabsBarItem>

        <TabsBarItem id="v3-aws-secret">
          Secreto de AWS
        </TabsBarItem>

        <TabsBarItem id="v3-azure-secret">
          Secreto azur
        </TabsBarItem>

        <TabsBarItem id="v3-gcp-secret">
          Secreto de GCP
        </TabsBarItem>
      </TabsBar>

      <TabsPages>
        <TabsPageItem id="v3-plain-text">
          ```yaml
          discovery:
            default_v3:
              user_name: $YOUR_SNMPV3_USER
              authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
              authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
              privacy_protocol: $YOUR_PRIVACY_PROTOCOL
              privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-aws-secret">
          ```yaml
          discovery:
            default_v3: aws.sm.$YOUR_SECRET_NAME
          ```

          En AWS, debe [almacenar sus secretos en una estructura JSON](https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_secret_json_structure.html) con todos los pares `key:value` relevantes. Esto es un ejemplo:

          ```json
          {
          "user_name": "$YOUR_SNMPV3_USER",
          "authentication_protocol": "$YOUR_AUTHENTICATION_PROTOCOL",
          "authentication_passphrase": "$YOUR_AUTHENTICATION_PASSPHRASE",
          "privacy_protocol": "$YOUR_PRIVACY_PROTOCOL",
          "privacy_passphrase": "$YOUR_PRIVACY_PASSPHRASE"
          }
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-azure-secret">
          ```yaml
          discovery:
            default_v3: azure.kv.$YOUR_SECRET_NAME
          ```

          En Azure, debe [almacenar sus secretos en una estructura de varias líneas](https://learn.microsoft.com/en-us/azure/key-vault/secrets/multiline-secrets) con todos los pares `key:value` relevantes. Esto es un ejemplo:

          ```
          user_name: $YOUR_SNMPV3_USER
          authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
          authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
          privacy_protocol: $YOUR_PRIVACY_PROTOCOL
          privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-gcp-secret">
          ```yaml
          discovery:
            default_v3: gcp.sm.$YOUR_SECRET_NAME
          ```

          En GCP, debes [almacenar tus secretos en una estructura de varias líneas](https://cloud.google.com/secret-manager/docs/create-secret-quickstart) con todos los pares `key:value` relevantes. Esto es un ejemplo:

          ```
          user_name: $YOUR_SNMPV3_USER
          authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
          authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
          privacy_protocol: $YOUR_PRIVACY_PROTOCOL
          privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>
      </TabsPages>
    </Tabs>
  </Collapser>

  <Collapser
    id="multiple-v3-discovery"
    title="Ejecución del descubrimiento con múltiples perfiles SNMP v3"
  >
    Para admitir la ejecución de trabajos de descubrimiento con múltiples perfiles SNMP v3, puede reemplazar la clave `discovery.default_v3` con la clave `discovery.other_v3s` , que contiene una matriz de [configuración SNMPv3](#snmpv3-config).

    ```yaml
    discovery:
      other_v3s:
      - user_name: $YOUR_USER_NAME_1
        authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL_1
        authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE_1
        privacy_protocol: $YOUR_PRIVACY_PROTOCOL_1
        privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE_1
        context_engine_id: ""
        context_name: ""
      - user_name: $YOUR_USER_NAME_2
        authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL_2
        authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE_2
        privacy_protocol: $YOUR_PRIVACY_PROTOCOL_1
        privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE_2
        context_engine_id: ""
        context_name: ""
    ```

    Esto también puede funcionar utilizando un administrador de secretos de un proveedor de la nube. Un ejemplo para AWS:

    ```yaml
    discovery:
      other_v3s:
      - aws.sm.$YOUR_SECRET_NAME_1
      - aws.sm.$YOUR_SECRET_NAME_2
    ```
  </Collapser>
</CollapserGroup>

## Configuración de sondeo API [#api-polling-configurations]

<Callout variant="tip">
  También puede utilizar secretos del proveedor de la nube en la configuración de autenticación de su API.
</Callout>

<CollapserGroup>
  <Collapser
    id="arista"
    title="Arista eAPI"
  >
    La integración [de Arista eAPI](https://www.arista.com/assets/data/pdf/Whitepapers/Arista_eAPI_FINAL.pdf) recopila telemetría BGP y MLAG adicional que normalmente no está disponible a través del sondeo SNMP.

    * Los detalles de BGP se recopilan de este comando: `show ip bgp summary vrf all`

      NRQL para encontrar telemetría BGP:

      ```sql
      FROM Metric SELECT
        max(kentik.eapi.bgp.InMsgQueue) AS 'InQ', // Messages Queued from the Neighbor
        max(kentik.eapi.bgp.MsgReceived) AS 'MsgSent', // Messages Received from the Neighbor
        max(kentik.eapi.bgp.MsgSent) AS 'MsgRcvd', // Messages Sent to the Neighbor
        latest(peer_state) AS 'State', // State of the BGP session
        latest(kentik.eapi.bgp.UpDownTime) AS 'Up/Down', // Period the BGP session has been in current state
        latest(kentik.eapi.bgp.Version) AS 'V' // BGP version number
      FACET
        entity.name AS 'Device',
        router_id AS 'Device IP',
        peer AS 'BGP Peer',
        peer_asn AS 'BGP Peer ASN',
        vrf AS 'VRF Name'
      ```

      <br/>

    * Los detalles de MLAG se recopilan de este comando: `show mlag detail`

      NRQL para encontrar telemetría MLAG:

      ```sql
      FROM Metric SELECT
        latest(kentik.eapi.mlag.PortsConfigured) AS 'Ports Configured', // Count of MLAG ports currently configured
        latest(kentik.eapi.mlag.PortsDisabled) AS 'Ports Disabled', // Count of MLAG ports in 'Disabled' state
        latest(kentik.eapi.mlag.PortsActivePartial) AS 'Ports Active-partial', // Count of MLAG ports in 'Active-partial' state 
        latest(kentik.eapi.mlag.PortsInactive) AS 'Ports Inactive', // Count of MLAG ports in 'Inactive' state
        latest(kentik.eapi.mlag.PortsActiveFull) AS 'Ports Active-full', // Count of MLAG ports in 'Active-full' state
        latest(kentik.eapi.mlag.PortsErrdisabled) AS 'Ports Err-disabled', // Count of MLAG ports in 'Err-disabled' state
        latest(config_sanity) AS 'Config-Sanity', // Current result of 'config-sanity' check
        latest(state) AS 'State', // Current MLAG state
        latest(neg_status) AS 'Negotiation Status', // Current negotiation status between switches
        latest(peer_address) AS 'Peer Address', // Address of MLAG peer
        latest(peer_link) AS 'Peer Link', // Link name for MLAG peer
        latest(peer_link_status) AS 'Peer Link Status', // Status of MLAG peer
        latest(local_interface) AS 'Local Interface', // Local interface used for MLAG configuration
        latest(local_intf_status) AS 'Local Interface Status' // Status of local interface used for MLAG configuration
      FACET
        entity.name AS 'Device',
        domain_id AS 'MLAG Domain ID'
      ```

      ### Opciones de configuración

      <table>
        <thead>
          <tr>
            <th style={{ width: "200px" }}>
              Nombre clave
            </th>

            <th>
              Requerido
            </th>

            <th>
              Descripción
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              eapi_config.username
            </td>

            <td>
              ✓
            </td>

            <td>
              El nombre de usuario que se pasará al dispositivo para autenticar la autenticación eAPI.
            </td>
          </tr>

          <tr>
            <td>
              eapi_config.password
            </td>

            <td>
              ✓
            </td>

            <td>
              La contraseña que se debe pasar al dispositivo para autenticar la autenticación eAPI.
            </td>
          </tr>

          <tr>
            <td>
              eapi_config.transport
            </td>

            <td/>

            <td>
              Especifica el tipo de transporte de conexión que se utilizará. Los valores posibles son `https` y `http`. Predeterminado: `https`.
            </td>
          </tr>

          <tr>
            <td>
              eapi_config.port
            </td>

            <td>
              ✓
            </td>

            <td>
              El puerto TCP del extremo para la conexión eAPI.
            </td>
          </tr>
        </tbody>
      </table>
  </Collapser>

  <Collapser
    id="meraki"
    title="De Meraki dashboard API"
  >
    La integración [de Meraki dashboard API](https://developer.cisco.com/meraki/api/) extrae varias métricas relacionadas con la salud de su entorno Meraki. La combinación de opciones de configuración le permite configurar diferentes escenarios de monitoreo para sus necesidades y crea entidad en su cuenta New Relic .

    <CollapserGroup>
      <Collapser
        id="meraki-organization"
        title="Meraki entidad organización"
      >
        Organización métrica se recopilan de forma predeterminada bajo la `kentik.meraki.organization.Count` métrica que se utiliza exclusivamente para generar la `Meraki Organization` entidad. Esto es principalmente para permitir la visualización de la jerarquía de Meraki para alinear redes y dispositivos con su organización principal.

        * `meraki_config.monitor_org_changes: true`: utiliza el extremo [Obtener cambios de configuración de la organización](https://developer.cisco.com/meraki/api/get-organization-configuration-changes/) para ver el log de cambios de la organización.

          NRQL para encontrar telemetría de cambios de configuración de la organización:

          ```sql
          FROM KExtEvent SELECT *
          ```
      </Collapser>

      <Collapser
        id="meraki-network"
        title="Meraki Network entidad"
      >
        * `meraki_config.preferences.show_network_attr: true`

          Las métricas de la red se recopilan bajo la `kentik.meraki.network.Count` métrica que se utiliza exclusivamente para generar la `Meraki Network` entidad. Esto es principalmente para permitir la visualización de la jerarquía de Meraki y alinear los dispositivos con la red a la que pertenecen.
      </Collapser>

      <Collapser
        id="meraki-device"
        title="Dispositivo Meraki entidad"
      >
        * `meraki_config.monitor_devices: true && meraki_config.preferences.device_status_only: true`: utiliza el extremo [Obtener estados del dispositivo de la organización](https://developer.cisco.com/meraki/api/get-organization-devices-statuses/) para enumerar el estado de cada dispositivo Meraki en la organización.

          NRQL para encontrar telemetría del estado del dispositivo:

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Device Status' // Current status of this device
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            src_addr AS 'Device Public IP',
            mac AS 'Device MAC',
            model AS 'Device Model',
            serial AS 'Device Serial',
            address AS 'Device Address',
            lat AS 'Device Latitude',
            lng AS 'Device Longitude',
            notes AS 'Device Notes'
          WHERE instrumentation.name = 'meraki.device_status'
          ```

          <br/>

        * `meraki_config.monitor_uplinks: true && meraki_config.preferences.hide_uplink_usage: false`: utiliza el extremo [Obtener estados de enlaces ascendentes de la organización](https://developer.cisco.com/meraki/api/get-organization-uplinks-statuses/) y [Obtener uso de enlaces ascendentes de dispositivos de la organización por red](https://developer.cisco.com/meraki/api/get-organization-appliance-uplinks-usage-by-network/) para enumerar el estado del enlace ascendente y el rendimiento de cada dispositivo Meraki de las series MX, MG y Z de la organización.

          NRQL para encontrar telemetría de enlace ascendente del dispositivo:

          ```sql
          FROM Metric SELECT
            max(kentik.meraki.uplinks.LatencyMS) AS 'Uplink Latency', // Uplink measured latency in milliseconds
            max(kentik.meraki.uplinks.LossPct) AS 'Uplink Loss %', // Uplink measured loss percentage
            max(kentik.meraki.uplinks.Recv) AS 'Uplink Receive Bytes', // Uplink bytes received
            max(kentik.meraki.uplinks.Sent) AS 'Uplink Transmit Bytes', // Uplink bytes sent
            latest(status) AS 'Uplink Status' // Latest status of the uplink
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            interface AS 'Device Uplink Interface',
            model AS 'Device Model',
            serial AS 'Device Serial'
          WHERE org_id IS NOT NULL
          ```

          <br/>

        * `meraki_config.monitor_uplinks: true && meraki_config.preferences.hide_uplink_usage: true`: utiliza el extremo [Obtener estados de enlaces ascendentes de la organización](https://developer.cisco.com/meraki/api/get-organization-uplinks-statuses/) para enumerar solo el estado del enlace ascendente de cada dispositivo Meraki de las series MX, MG y Z de la organización.

          NRQL para encontrar la telemetría del estado del enlace ascendente del dispositivo:

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Uplink Status' // Latest status of the uplink
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            interface AS 'Device Uplink Interface',
            model AS 'Device Model',
            serial AS 'Device Serial'
          WHERE org_id IS NOT NULL
          ```

          <br/>

        * `meraki_config.monitor_vpn_status: true && meraki_config.preferences.show_vpn_peers: false`: utiliza la [opción Obtener estados de VPN del dispositivo de la organización](https://developer.cisco.com/meraki/api/get-organization-appliance-vpn-statuses/) para mostrar estados de VPN en las redes de la organización.

          NRQL para encontrar la telemetría del estado de VPN:

          ```sql
          FROM Metric SELECT
            latest(status) AS 'VPN Status' // Latest status of this VPN
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            serial AS 'Device Serial',
            vpn_mode AS 'VPN Mode',
            wan1 OR wan2 AS 'WAN Interface IP'
          WHERE instrumentation.name = 'meraki.vpn_status'
          AND org_id IS NOT NULL
          ```

          <br/>

        * `meraki_config.monitor_vpn_status: true && meraki_config.preferences.show_vpn_peers: true`: utiliza el extremo [Obtener estados de VPN del dispositivo de la organización](https://developer.cisco.com/meraki/api/get-organization-appliance-vpn-statuses/) para agregar información sobre pares VPN en las redes de la organización.

          NRQL para encontrar telemetría de pares VPN:

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Peer Status' // Current status of this VPN peer
          FACET
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            serial AS 'Device Serial',
            vpn_mode AS 'VPN Mode',
            wan1 AS 'WAN 1 IP',
            wan2 AS 'WAN 2 IP',
            peer_name AS 'Peer Name', // Name of this peer
            peer_reachability AS 'Peer Reachability', // Latest results of reachability test for this peer
            peer_network_id AS 'Peer Network ID', // Network ID for this peer
            peer_type AS 'Peer Type' // Type of Peer (Meraki vs Third-party)
          WHERE metricName = 'kentik.meraki.vpn_status.PeerStatus'
          ```
      </Collapser>

      <Collapser
        id="meraki-config-options"
        title="Opciones de configuración de Meraki"
      >
        <Collapser
          id="meraki-primary-config"
          title="Opciones de configuración primaria"
        >
          <Callout variant="tip">
            Puede utilizar la variable de entorno [KENTIK_MERAKI_API_KEY](/docs/network-performance-monitoring/advanced/ktranslate-container-management/#container-runtime-options) para pasar su clave de API a la integración de Meraki sin almacenarla en texto sin formato en su archivo de configuración.
          </Callout>

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Nombre clave
                </th>

                <th>
                  Requerido
                </th>

                <th>
                  Aporte
                </th>

                <th>
                  Descripción
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki_config.api_key
                </td>

                <td>
                  ✓ (No es necesario si se utiliza la variable de entorno [KENTIK_MERAKI_API_KEY](/docs/network-performance-monitoring/advanced/ktranslate-container-management) )
                </td>

                <td>
                  Clave de API (cadena)
                </td>

                <td>
                  [Clave de API del dashboard de Meraki](https://documentation.meraki.com/General_Administration/Other_Topics/Cisco_Meraki_Dashboard_API#Enable_API_Access) para autenticación.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.max_http_retry
                </td>

                <td/>

                <td>
                  Entero entre 1 y 10 (predeterminado: 2)
                </td>

                <td>
                  Configuración opcional que controla la frecuencia con la que se intenta un reintento en solicitudes de API que devuelven un error `HTTP 429` . El intervalo entre reintentos es de 5 segundos.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_devices
                </td>

                <td/>

                <td>
                  verdadero | falso (predeterminado: falso)
                </td>

                <td>
                  Monitor el estado de cada dispositivo Meraki en la organización.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_org_changes
                </td>

                <td/>

                <td>
                  verdadero | falso (predeterminado: falso)
                </td>

                <td>
                  Monitorear el log de cambios de la organización.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_uplinks
                </td>

                <td/>

                <td>
                  verdadero | falso (predeterminado: verdadero)
                </td>

                <td>
                  Monitorear el estado del enlace ascendente y el rendimiento de cada dispositivo Meraki de las series MX, MG y Z de la organización.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_vpn_status
                </td>

                <td/>

                <td>
                  verdadero | falso (predeterminado: falso)
                </td>

                <td>
                  Monitorear los estados de VPN en las redes de la organización.
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser
          id="meraki-filter-config"
          title="Opciones de filtrado"
        >
          Estas opciones le permiten restringir el monitoreo a objetos específicamente objetivos en su entorno Meraki.

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Nombre clave
                </th>

                <th>
                  Requerido
                </th>

                <th>
                  Aporte
                </th>

                <th>
                  Descripción
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki_config.organizations
                </td>

                <td/>

                <td>
                  Regex en [sintaxis RE2](https://github.com/google/re2/wiki/Syntax) (predeterminado: nulo)
                </td>

                <td>
                  Filtra todo el monitoreo a una lista específica de organización.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.networks
                </td>

                <td/>

                <td>
                  Regex en [sintaxis RE2](https://github.com/google/re2/wiki/Syntax) (predeterminado: nulo)
                </td>

                <td>
                  Filtra todo el monitoreo a una lista específica de redes.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.product_types
                </td>

                <td/>

                <td>
                  Los tipos válidos son inalámbrico, dispositivo, switch, systemsManager, cámara, cellularGateway,, sensor y cloudGateway. (Predeterminado: nulo)
                </td>

                <td>
                  Agrega un parámetro a la [monitor_devices](https://developer.cisco.com/meraki/api/get-organization-devices-statuses/) API para filtrar en tipos específicos de dispositivos.
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser
          id="meraki-additional-config"
          title="Preferencias adicionales"
        >
          Estas opciones le permiten definir aún más los datos recopilados desde las opciones de configuración principales. En la sección de ejemplos anterior se describen varias combinaciones.

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Nombre clave
                </th>

                <th>
                  Requerido
                </th>

                <th>
                  Aporte
                </th>

                <th>
                  Descripción
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki_config.preferences.device_status_only
                </td>

                <td/>

                <td>
                  verdadero | falso (predeterminado: falso)
                </td>

                <td>
                  _Se requiere_ cuando se utiliza `monitor_devices: true` para restringir el sondeo solo a información de estado. <DNT>**(This is used to prevent timeout issues.)**</DNT>
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.preferences.hide_uplink_usage
                </td>

                <td/>

                <td>
                  verdadero | falso (predeterminado: falso)
                </td>

                <td>
                  Se utiliza en combinación con `monitor_uplinks` para eliminar el rendimiento métrico y devolver solo información de estado para los enlaces ascendentes.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.preferences.show_vpn_peers
                </td>

                <td/>

                <td>
                  verdadero | falso (predeterminado: falso)
                </td>

                <td>
                  Se utiliza en combinación con `monitor_vpn_status` para agregar telemetría en pares de VPN.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.preferences.show_network_attr
                </td>

                <td/>

                <td>
                  verdadero | falso (predeterminado: falso)
                </td>

                <td>
                  Se utiliza para agregar telemetría en redes. Requerido para crear `Meraki Network` entidad.
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>
      </Collapser>

      ### Ejemplo de configuración mínima [#meraki-minimum-config]

      ```yaml
      # This represents the minimal configuration required for a container that only performs Meraki API polling.
      # By default we only monitor uplinks. All other items are optional.
      ---
       devices:
          meraki_cloud_controller:
            device_name: meraki_cloud_controller
            device_ip: snmp.meraki.com
            provider: meraki-cloud-controller
            ext:
              ext_only: true
              meraki_config:
                api_key: "$YOUR_API_KEY"
       trap: {}
       discovery: {}
       global:
         poll_time_sec: 300
         timeout_ms: 30000
      ```

      ### Ejemplos de configuración completos [#meraki-full-config]

      #### Todas las opciones necesarias para crear la entidad `Meraki Organization`, `Meraki Network` y `Meraki Device` .

      ```yaml
      devices:
        meraki_dashboard_api:
          device_name: meraki_controller
          device_ip: snmp.meraki.com
          provider: meraki-cloud-controller
          ext:
            ext_only: true
            meraki_config:
              api_key: $YOUR_MERAKI_API_KEY
              monitor_devices: true
              monitor_org_changes: true
              monitor_uplinks: true
              monitor_vpn_status: true
              preferences:
                device_status_only: true
                hide_uplink_usage: false
                show_vpn_peers: true
                show_network_attr: true
      trap: {}
      discovery: {}
      global:
        poll_time_sec: 300
        timeout_ms: 30000
      ```

      #### Dirigirse a múltiples claves de API del dashboard de Meraki

      ```yaml
      devices:
         # Entity 1 - monitor everything this API key has access to
         meraki_all:
           device_name: meraki_all
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_1"
               max_http_retry: 8
               monitor_devices: true
               monitor_org_changes: true
               monitor_uplinks: true
               monitor_vpn_status: true
               preferences:
                 device_status_only: true
                 show_vpn_peers: true
                 hide_uplink_usage: false
         # Entity 2 - Monitor these specific organizations under this API key
         meraki_single_org:
           device_name: meraki_single_org
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_2"
               monitor_devices: true
               monitor_org_changes: true
               monitor_uplinks: true
               monitor_vpn_status: true
               preferences:
                 device_status_only: true
                 show_vpn_peers: true
                 hide_uplink_usage: false
               organizations:
                 - "Org 1 - Prod.*"
                 - "Org 2 - Staging"
         # Entity 3 - Monitor specific devices filtered by organization, network, and product types; using the same API key from Entity 2
         meraki_filtered:
           device_name: meraki_filtered
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_2"
               monitor_devices: true
               monitor_uplinks: false
               preferences:
                 device_status_only: true
               organizations:
                 - "Org 3 - Remote Sites"
               networks:
                 - "Corp.*99"
                 - "Retail.*"
               product_types:
                 - wireless
                 - appliance
      trap: {}
      discovery: {}
      global:
        poll_time_sec: 300
        timeout_ms: 30000
      ```
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

## Archivos de configuración externos [#external-config-files]

Para admitir una amplia variedad de necesidades de configuración y automatización, puede utilizar archivos externos que monte por volumen en su contenedor Docker para desacoplar ciertos elementos del archivo de configuración estándar. Deberá incluir el siguiente argumento de montaje en su comando `docker run` , con un argumento por archivo de configuración externo.

```
-v `pwd`/fileName.yaml:/fileName.yaml \
```

La sintaxis de estos archivos es `"@fileName.yaml"`, incluidas las comillas dobles.

<CollapserGroup>
  <Collapser
    id="discovery-cidrs-file"
    title="CIDR de descubrimiento"
  >
    Ejemplo:

    ```yaml
    discovery:
      cidrs: "@cidrs.yaml"
    ```

    El archivo CIDR debe usar una sintaxis de lista YAML como esta:

    ```yaml
    - 10.10.0.0/24
    - 10.20.0.0/24
    - 192.168.0.21/32
    ```
  </Collapser>

  <Collapser
    id="devices-file"
    title="Dispositivos"
  >
    Ejemplo:

    ```yaml
    devices:
      "@neteng-devices.yaml"
    ```

    Los archivos del dispositivo deben usar la misma sintaxis que la sección estándar `devices` del archivo de configuración principal, omitiendo los campos opcionales que se generan durante el descubrimiento:

    ```yaml
    devices:
      # Sample of SNMP v2c device
      ups_snmpv2c__10.10.0.201:
        device_name: ups_snmpv2c
        device_ip: 10.10.0.201
        snmp_comm: $YOUR_COMMUNITY_STRING
        oid: .1.3.6.1.4.1.318.1.3.27
        mib_profile: apc_ups.yml
        provider: kentik-ups
        poll_time_sec: 300
        retries: 1
        timeout_ms: 5000
        user_tags:
          owning_team: dc_ops
    ```
  </Collapser>
</CollapserGroup>

## El atributo `match_attributes` [#match_attributes-attribute]

Para admitir el filtrado de datos que no crean valor para sus necesidades de observabilidad, puede configurar el mapa de atributos `global.match_attributes.{}` y/o `devices.[].match_attributes.{}` .

Esto proporcionará filtrado en el nivel `ktranslate` , antes de enviar datos a New Relic, lo que le brindará un control granular sobre el monitoreo de aspectos como las interfaces.

El comportamiento predeterminado de este mapa es una condición `OR` , pero puede anularla y forzar un operador `AND` anteponiendo el nombre de su clave con el prefijo `!`. Esto también es útil para devolver solo elementos coincidentes y omitir todos los resultados `null` y `""` (vacíos).

<CollapserGroup>
  <Collapser
    id="default-or-null"
    title="'O' predeterminado con valores nulos y vacíos"
  >
    Haga coincidir cuando `if_Alias` comience con `Uplink` <DNT>**OR**</DNT> cuando `if_interface_name` comience con `Gig`, mantenga todos los valores de `null` y `""` :

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          if_Alias: "^Uplink.*"
          if_interface_name: "^Gig.*"
    ```
  </Collapser>

  <Collapser
    id="and-no-null"
    title="'Y', omite valores nulos y vacíos"
  >
    Haga coincidir cuando `if_Alias` comience con `Uplink` <DNT>**AND**</DNT> cuando `if_interface_name` comience con `Gig`, elimine todos los valores `null` y `""` :

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          if_Alias: "^Uplink.*"
          "!if_interface_name": "^Gig.*"
    ```
  </Collapser>

  <Collapser
    id="single-no-null"
    title="Coincidencia única, omitir valores nulos y vacíos"
  >
    Haga coincidir cuando `if_Alias` comience con `Uplink`, elimine todos los valores `null` y `""` :

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          "!if_Alias": "^Uplink.*"
    ```
  </Collapser>

  <Collapser
    id="negate-lookup"
    title="Crear una previsión negativa"
  >
    El paquete de expresiones regulares de Golang no admite patrones de anticipación negativos (`q(?!u)`) de forma predeterminada. Como solución alternativa, puede agregar el token `DOES_NOT_MATCH` a su mapa de atributos para obtener de manera efectiva los resultados inversos de su patrón coincidente.

    Por ejemplo, para hacer coincidir en cada interfaz que **no** incluya la cadena `Uplink`; puedes usar una configuración como esta:

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          "!if_Alias": "^Uplink.*"
          DOES_NOT_MATCH: true
    ```
  </Collapser>
</CollapserGroup>

## El atributo `response_time` y `ping_only` [#response_time-attribute]

Para admitir el monitoreo de dispositivos donde las estadísticas de rendimiento no son accesibles o no están disponibles, o en casos simples donde se requiere un monitoreo de tiempo de ida y vuelta básico (RTT), puede configurar el atributo `global.response_time` o `devices.[].ping_only` en `true`.

Esta característica utiliza el paquete [go-ping](https://pkg.go.dev/github.com/sparrc/go-ping) para enviar paquetes ICMP o UDP sin privilegios a dispositivos para recopilar el tiempo de ida y vuelta (RTT) promedio, mínimo, máximo y estándar. Este paquete también muestra el porcentaje de pérdida de paquetes para el extremo basado en el envío de un paquete por segundo desde `ktranslate` a la dirección IP del dispositivo, que se puede anular configurando el atributo `devices.[].ping_interval_sec` . Puede cambiar del uso predeterminado de paquetes ICMP privilegiados o UDP configurando la variable de entorno `KENTIK_PING_PRIV=false` durante el tiempo de ejecución Docker .

Establecer el atributo `global.response_time` en `true` agregará monitoreo RTT además del sondeo SNMP existente. Para monitor dispositivos solo con paquetes UDP|ICMP para RTT y sin sondeo SNMP, use `devices.[].ping_only: true`.

En New Relic, puedes ver los resultados de esta encuesta investigando la siguiente métrica:

```sql
FROM Metric SELECT
  average(kentik.ping.AvgRttMs) AS 'Average',
  max(kentik.ping.MaxRttMs) AS 'Max',
  min(kentik.ping.MinRttMs) AS 'Min',
  average(kentik.ping.StdDevRtt) AS 'StdDev',
  latest(kentik.ping.PacketLossPct) AS 'Packet Loss %'
FACET device_name
```

<Callout variant="tip">
  Puede utilizar el atributo `ping_only` en reemplazo del atributo `flow_only` si desea recopilar RTT métrico de un dispositivo de flujo. Si tanto `ping_only` como `flow_only` son `true`, el dispositivo se tratará como un dispositivo `flow_only` .
</Callout>

## El atributo `flow_only` [#flow_only-attribute]

Para admitir el monitoreo de dispositivos donde solo desea recopilar datos de flujo, puede configurar el atributo `devices.<deviceName>.flow_only` en `true`.

Esto generará una <DNT>**Flow Device**</DNT> entidad que solo tendrá telemetría en el namespace del evento `KFlow`. Alternativamente, recopilar telemetría de flujo de un dispositivo que está en su archivo de configuración como dispositivo SNMP agregará decoración de los datos `KFlow` a la entidad preexistente, como <DNT>**Router**</DNT> o <DNT>**Firewall**</DNT>.

En New Relic, puedes ver los resultados de esta encuesta investigando el siguiente evento:

```sql
FROM KFlow SELECT *
WHERE instrumentation.name = 'netflow-events'
```

## Aplicación de datos de flujo mapeo.

De forma predeterminada, la telemetría de flujo se asigna a una aplicación conocida según la evaluación del puerto de capa 4 en uso en una conversación de flujo específica. Si es necesario, puede anular el mapeo predeterminado proporcionando un archivo YAML durante el tiempo de ejecución Docker en el indicador `-application_map`. Esto le permitirá especificar nombres de aplicaciones según los puertos que identifique.

Sintaxis de ejemplo:

```yaml
applications:
  - ports: [9092, 9093]
    name: kafka
  - ports: [80, 8080]
    name: http
  - ports: [443, 8443]
    name: https
```

## Filtrado de entrada de datos de flujo

De forma predeterminada, el contenedor de datos de flujo recopilará y procesará cada paquete de flujo que reciba. Si es necesario, puede agregar un filtro de inclusión al indicador `-nf.source` que ignorará todo el tráfico que no coincida con el filtro que proporcione.

<CollapserGroup>
  <Collapser
    id="flow-filter-options"
    title="Opciones de filtro de flujo"
  >
    Sintaxis: `--filters $TYPE,$FIELD,$FUNCTION,$MATCH`

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nombre del argumento
          </th>

          <th>
            Requerido
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            $TIPO
          </td>

          <td>
            ✓
          </td>

          <td>
            El tipo de filtro a aplicar. Los valores posibles son `string`, `int` y `addr`.
          </td>
        </tr>

        <tr>
          <td>
            $CAMPO
          </td>

          <td>
            ✓
          </td>

          <td>
            El nombre del campo contra el que se evaluará el patrón de coincidencia.
          </td>
        </tr>

        <tr>
          <td>
            $FUNCIÓN
          </td>

          <td>
            ✓
          </td>

          <td>
            El tipo de función que se utilizará durante la evaluación. Los valores posibles son `Equal: ==`, `NotEqual: !=`, `LessThan: <`, `GreaterThan: >`, `Contains: %`
          </td>
        </tr>

        <tr>
          <td>
            $ PARTIDO
          </td>

          <td>
            ✓
          </td>

          <td>
            El valor que se utilizará como patrón de coincidencia.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="example-flow-filters"
    title="Filtros de ejemplo"
  >
    * Recopile datos de flujo únicamente de direcciones de origen en el rango CIDR `10.0.0.0/24`

      ```
      -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24
      ```

    * Solo recopile datos de flujo cuando el puerto de destino no sea igual a `8531`

      ```
      -nf.source netflow5 --filters int,l4_dst_port,!=,8531
      ```

    * Recopile datos de flujo únicamente de direcciones de origen en el rango CIDR `10.0.0.0/24` Y donde el puerto de destino no sea igual a `8531` (operador `AND` implícito)

      ```
      --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531
      ```
  </Collapser>
</CollapserGroup>

## Recarga automática de perfiles SNMP personalizados [#reload-snmp-threads]

De forma predeterminada, el contenedor Docker `ktranslate` debe destruir y reconstruir manualmente para incorporar cambios en los perfiles SNMP en la ruta [mib_profile_dir](#global). Este es un comportamiento normal en la mayoría de los casos, ya que la imagen Docker extrae los últimos perfiles disponibles en el [repositorio público snmp-profiles](https://github.com/kentik/snmp-profiles). En situaciones en las que proporciona [perfiles personalizados](/docs/network-performance-monitoring/advanced/snmp-profiles/#private), puede emplear la configuración [watch_profile_changes](#global) para permitir que el contenedor actualice automáticamente las configuraciones subyacentes y los perfiles SNMP del contenedor.

<Callout variant="important">
  Esto no es recursivo debido a una limitación en la [biblioteca del observador](https://github.com/fsnotify/fsnotify?tab=readme-ov-file#are-subdirectories-watched). Por lo tanto, si un perfil cambia en un subdirectorio, también debe editar un archivo de nivel superior para activar el cambio.
</Callout>

Suponiendo esta estructura de directorio:

```
.
└── /snmp-profiles/
    └── profiles/
        └── kentik-snmp/
            ├── 3com
            ├── _general
            ├── a10networks
            └── ...
```

Deberá colocar un archivo nuevo en la raíz del directorio y cambiarlo manualmente para activar este ciclo de actualización. Una forma sencilla de implementar esto es simplemente escribir una timestamp en un archivo como `last_updated.txt` cuando se envía el cambio.

```
.
└── /snmp-profiles/
    ├── last_updated.txt
    └── profiles/
        └── kentik-snmp/
            ├── 3com
            ├── _general
            ├── a10networks
            └── ...
```
