---
title: Referencia de métricas de contenedores Docker
tags:
  - Integrations
  - OpenTelemetry
  - Docker
  - Metrics
metaDescription: 'Complete reference of Docker container metrics collected by OpenTelemetry, including descriptions, types, and alerting recommendations.'
freshnessValidatedDate: never
translationType: machine
---

Esta página proporciona una referencia completa de todas las métricas de contenedores Docker recopiladas por el [dockerstatsreceiver](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/dockerstatsreceiver) de OpenTelemetry. Utilice esta referencia para comprender qué datos están disponibles, crear consultas personalizadas y configurar alertas efectivas para sus aplicaciones en contenedores.

## Referencia completa de métricas [#metrics-reference]

El [dockerstatsreceiver](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/dockerstatsreceiver) de OpenTelemetry Collector Contrib recopila las siguientes métricas de la API de Docker Stats:

<CollapserGroup>
  <Collapser id="docker-metrics" title="Métrica">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descripción
          </th>

          <th>
            Tipo
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `container.blockio.io_merged_recursive`
          </td>

          <td>
            Número de bios/solicitudes fusionadas en solicitudes pertenecientes a este cgroup y sus cgroups descendientes
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_queued_recursive`
          </td>

          <td>
            Número de solicitudes en cola para este cgroup y sus cgroups descendientes
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_service_bytes_recursive`
          </td>

          <td>
            Número de bytes transferidos hacia/desde el disco por el grupo y los grupos descendientes
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_service_time_recursive`
          </td>

          <td>
            Cantidad total de tiempo en nanosegundos entre el despacho de la solicitud y la finalización de la solicitud para las E/S realizadas por este cgroup y los cgroups descendientes
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_serviced_recursive`
          </td>

          <td>
            Número de E/S (bio) emitidas al disco por el grupo y los grupos descendientes
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_time_recursive`
          </td>

          <td>
            Tiempo de disco asignado al cgroup (y cgroups descendientes) por dispositivo en milisegundos
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_wait_time_recursive`
          </td>

          <td>
            Cantidad total de tiempo que las operaciones de E/S de este cgroup (y los cgroups descendientes) pasaron esperando en las colas del planificador para recibir servicio
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.kernelmode`
          </td>

          <td>
            Uso de CPU en modo kernel
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.percpu`
          </td>

          <td>
            Uso de CPU por núcleo del contenedor (deshabilitado por defecto)
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.system`
          </td>

          <td>
            Uso de CPU del sistema
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.total`
          </td>

          <td>
            Tiempo total de CPU consumido por el contenedor
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.usermode`
          </td>

          <td>
            Uso de CPU en modo usuario
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.percent`
          </td>

          <td>
            Porcentaje de CPU utilizado por el contenedor (obsoleto, use container.cpu.utilization en su lugar)
          </td>

          <td>
            Medidor
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.utilization`
          </td>

          <td>
            Porcentaje de CPU utilizado por el contenedor
          </td>

          <td>
            Medidor
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.throttling_data.periods`
          </td>

          <td>
            Número de períodos con limitación activa
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.throttling_data.throttled_periods`
          </td>

          <td>
            Número de períodos en los que el contenedor alcanzó su límite de limitación
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.throttling_data.throttled_time`
          </td>

          <td>
            Tiempo agregado que el contenedor fue limitado
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.limit`
          </td>

          <td>
            Límite de CPU establecido para el contenedor
          </td>

          <td>
            Medidor
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.logical.count`
          </td>

          <td>
            Número de núcleos disponibles para el contenedor
          </td>

          <td>
            Medidor
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.shares`
          </td>

          <td>
            Cuotas de CPU asignadas al contenedor
          </td>

          <td>
            Medidor
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.cores.used`
          </td>

          <td>
            Número de núcleos de CPU utilizados por el contenedor
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.usage.limit`
          </td>

          <td>
            Límite de uso de memoria
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.usage.max`
          </td>

          <td>
            Uso máximo de memoria
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.usage.total`
          </td>

          <td>
            Uso de memoria del contenedor. Esto excluye la caché
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.percent`
          </td>

          <td>
            Porcentaje de memoria utilizada
          </td>

          <td>
            Medidor
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.active_anon`
          </td>

          <td>
            Cantidad de memoria utilizada en mapeos anónimos como brk(), sbrk() y mmap(MAP\_ANONYMOUS) que se utilizan activamente
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.active_file`
          </td>

          <td>
            Cantidad de memoria caché utilizada por archivos que se utilizan activamente
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.anon`
          </td>

          <td>
            Cantidad de memoria utilizada en mapeos anónimos (páginas no respaldadas por archivos)
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.cache`
          </td>

          <td>
            La cantidad de memoria utilizada por los procesos de este grupo de control que puede asociarse a un bloque en un dispositivo de bloques
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.dirty`
          </td>

          <td>
            Bytes que esperan escribirse en el disco, desde este cgroup
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.fails`
          </td>

          <td>
            Número de veces que se alcanzó el límite de memoria
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.file`
          </td>

          <td>
            Cantidad de memoria utilizada por archivos (caché de archivos)
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.hierarchical_memory_limit`
          </td>

          <td>
            La cantidad máxima de memoria física que el cgroup puede usar
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.hierarchical_memsw_limit`
          </td>

          <td>
            La cantidad máxima de RAM + swap que el cgroup puede usar
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.inactive_anon`
          </td>

          <td>
            Cantidad de memoria utilizada en mapeos anónimos como brk(), sbrk() y mmap(MAP\_ANONYMOUS) que no se utilizan activamente
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.inactive_file`
          </td>

          <td>
            Cantidad de memoria caché utilizada por archivos que no se usan activamente
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.mapped_file`
          </td>

          <td>
            Indica la cantidad de memoria mapeada por los procesos en el grupo de control
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.pgfault`
          </td>

          <td>
            Indica el número de veces que un proceso del cgroup generó un fallo de página
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.pgmajfault`
          </td>

          <td>
            Indica el número de veces que un proceso del cgroup generó un fallo mayor
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.pgpgin`
          </td>

          <td>
            Número de páginas leídas del disco por el cgroup
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.pgpgout`
          </td>

          <td>
            Número de páginas escritas en disco por el cgroup
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.rss`
          </td>

          <td>
            La cantidad de memoria que no corresponde a nada en el disco: pilas, montículos y mapas de memoria anónima
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.rss_huge`
          </td>

          <td>
            Número de bytes de páginas gigantes transparentes anónimas en este cgroup
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.unevictable`
          </td>

          <td>
            La cantidad de memoria que no se puede recuperar
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.writeback`
          </td>

          <td>
            Número de bytes de caché de archivos/anónima que están en cola para sincronizarse con el disco en este cgroup
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.rx_bytes`
          </td>

          <td>
            Bytes recibidos por el contenedor a través de su interfaz de red
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.rx_dropped`
          </td>

          <td>
            Número de paquetes recibidos descartados por el contenedor
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.rx_errors`
          </td>

          <td>
            Errores recibidos por el contenedor
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.rx_packets`
          </td>

          <td>
            Paquetes recibidos por el contenedor a través de su interfaz de red
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.tx_bytes`
          </td>

          <td>
            Bytes enviados por el contenedor a través de su interfaz de red
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.tx_dropped`
          </td>

          <td>
            Número de paquetes enviados descartados por el contenedor
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.tx_errors`
          </td>

          <td>
            Errores de transmisión por el contenedor
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.tx_packets`
          </td>

          <td>
            Paquetes enviados por el contenedor a través de su interfaz de red
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.pids.count`
          </td>

          <td>
            Número de PIDs en el cgroup del contenedor
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.pids.limit`
          </td>

          <td>
            Número máximo de PIDs en el cgroup del contenedor
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.restarts`
          </td>

          <td>
            Número de veces que el contenedor se ha reiniciado
          </td>

          <td>
            Suma
          </td>
        </tr>

        <tr>
          <td>
            `container.uptime`
          </td>

          <td>
            Tiempo transcurrido desde que se inició el contenedor
          </td>

          <td>
            Medidor
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="docker-attributes" title="Atributo">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Atributo
          </th>

          <th>
            Descripción
          </th>

          <th>
            Valores
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `collector.name`
          </td>

          <td>
            Atributo personalizado para la identificación del recopilador (si está configurado en su recopilador)
          </td>

          <td>
            Cadena
          </td>
        </tr>

        <tr>
          <td>
            `container.hostname`
          </td>

          <td>
            El nombre de host del contenedor
          </td>

          <td>
            Cadena
          </td>
        </tr>

        <tr>
          <td>
            `container.id`
          </td>

          <td>
            El ID completo del contenedor
          </td>

          <td>
            Cadena (hexadecimal de 64 caracteres)
          </td>
        </tr>

        <tr>
          <td>
            `container.image.name`
          </td>

          <td>
            Nombre de la imagen del contenedor
          </td>

          <td>
            Cadena
          </td>
        </tr>

        <tr>
          <td>
            `container.name`
          </td>

          <td>
            Nombre del contenedor
          </td>

          <td>
            Cadena
          </td>
        </tr>

        <tr>
          <td>
            `container.runtime`
          </td>

          <td>
            Tiempo de ejecución del contenedor
          </td>

          <td>
            `docker`
          </td>
        </tr>

        <tr>
          <td>
            `deployment.environment`
          </td>

          <td>
            Identificador del ambiente de despliegue (si está configurado en su colector)
          </td>

          <td>
            Cadena
          </td>
        </tr>

        <tr>
          <td>
            `description`
          </td>

          <td>
            Descripción de la métrica
          </td>

          <td>
            Cadena
          </td>
        </tr>

        <tr>
          <td>
            `device_major`
          </td>

          <td>
            Número mayor del dispositivo (para métricas de E/S de bloques)
          </td>

          <td>
            Entero
          </td>
        </tr>

        <tr>
          <td>
            `device_minor`
          </td>

          <td>
            Número menor del dispositivo (para métricas de E/S de bloques)
          </td>

          <td>
            Entero
          </td>
        </tr>

        <tr>
          <td>
            `entity.guid`
          </td>

          <td>
            GUID de la entidad de New Relic para el contenedor
          </td>

          <td>
            Cadena
          </td>
        </tr>

        <tr>
          <td>
            `entity.name`
          </td>

          <td>
            Nombre de la entidad de New Relic (típicamente el nombre del contenedor)
          </td>

          <td>
            Cadena
          </td>
        </tr>

        <tr>
          <td>
            `entity.type`
          </td>

          <td>
            Tipo de entidad de New Relic
          </td>

          <td>
            `CONTAINER`
          </td>
        </tr>

        <tr>
          <td>
            `instrumentation.provider`
          </td>

          <td>
            Identificador del proveedor de instrumentación
          </td>

          <td>
            `opentelemetry`
          </td>
        </tr>

        <tr>
          <td>
            `interface`
          </td>

          <td>
            Nombre de la interfaz de red (para métricas de red)
          </td>

          <td>
            Cadena
          </td>
        </tr>

        <tr>
          <td>
            `newrelic.source`
          </td>

          <td>
            Fuente de la métrica en New Relic
          </td>

          <td>
            `api.metrics.otlp`
          </td>
        </tr>

        <tr>
          <td>
            `nr.entity_type`
          </td>

          <td>
            Tipo de entidad de New Relic para la correlación de entidades
          </td>

          <td>
            `CONTAINER`
          </td>
        </tr>

        <tr>
          <td>
            `operation`
          </td>

          <td>
            Tipo de operación de E/S de bloque
          </td>

          <td>
            `read`, `write`
          </td>
        </tr>

        <tr>
          <td>
            `otel.library.name`
          </td>

          <td>
            Nombre de la biblioteca/receptor de OpenTelemetry
          </td>

          <td>
            `github.com/open-telemetry/opentelemetry-collector-contrib/receiver/dockerstatsreceiver`
          </td>
        </tr>

        <tr>
          <td>
            `otel.library.version`
          </td>

          <td>
            Versión de la biblioteca OpenTelemetry
          </td>

          <td>
            Cadena (p. ej., `0.142.0`)
          </td>
        </tr>

        <tr>
          <td>
            `service.name`
          </td>

          <td>
            Nombre del servicio configurado en el colector
          </td>

          <td>
            Cadena
          </td>
        </tr>

        <tr>
          <td>
            `telemetry.sdk.name`
          </td>

          <td>
            Identificador del SDK de telemetría
          </td>

          <td>
            `opentelemetry`
          </td>
        </tr>

        <tr>
          <td>
            `unit`
          </td>

          <td>
            Unidad de medida para la métrica
          </td>

          <td>
            Cadena (p. ej., `{cpus}`, `By`, `1`)
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

Para más detalles, consulte la [documentación del receptor Docker Stats](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/dockerstatsreceiver/documentation.md)

## Próximos pasos [#next-steps]

Ahora que comprende las métricas de Docker:

* [Configurar el monitoreo](/docs/opentelemetry/integrations/docker-monitoring/self-hosted) - Configura el monitoreo de Docker si aún no lo has hecho
* **Crea dashboards**: Construye [visualizaciones personalizadas](/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/) usando las métricas de esta referencia