---
title: Referencia NRQL
tags:
  - Query your data
  - 'NRQL: New Relic Query Language'
  - Get started
metaDescription: 'A detailed reference list of clauses and functions in NRQL, the New Relic query language.'
freshnessValidatedDate: never
translationType: machine
---

Para redactar una buena consulta [NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language) , es útil comprender cómo funcionan nuestras diversas cláusulas y funciones NRQL . Este documento contiene definiciones de cláusulas y funciones NRQL y ofrece ejemplos de cómo utilizarlas.

¿Busca reglas de sintaxis básicas de NRQL? Consulte [Cómo utilizar NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-how-nrql-works). Para ver un tutorial, consulte [el tutorial introductorio de NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-tutorial).

## Componentes de consulta [#clauses]

Como se indica en nuestro [documento de sintaxis básica de NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-how-nrql-works/#syntax), cada consulta NRQL contendrá una cláusula `SELECT` y una cláusula `FROM` , siendo todas las demás cláusulas opcionales. Las definiciones de cláusulas siguientes también contienen ejemplos de consulta NRQL .

### Palabra clave DELETE [#delete]

La palabra clave `DELETE` en el lenguaje de consulta New Relic (NRQL) se emplea para eliminar datos y atributos específicos dentro del Control de pipelines. Esto ayuda a gestionar los datos que se ingresan en la base de datos New Relic (NRDB).

La palabra clave `DELETE` se aplica en NRQL consulta para especificar qué datos o atributos deben eliminar. A continuación se muestran algunos ejemplos:

A continuación se muestran algunos ejemplos:

* **Eliminar métrica específica:**

  ```sql
  DELETE FROM Metric 
  WHERE metricName = 'newrelic.goldenmetrics.infra.kubernetes_pod.podScheduled'
  ```

  * Elimina la métrica con el nombre especificado.

* **Eliminar intervalos específicos:**

  ```sql
  DELETE FROM Span WHERE appName = 'external-usage-consumer (test-odd-wire)'
  ```

  * Elimina los intervalos asociados con la aplicación especificada.

* **Eliminar actualizaciones de agentes específicos:**

  ```sql
  DELETE FROM AgentUpdate WHERE a = 'b'
  ```

  * Elimina las actualizaciones del agente donde el atributo `a` es igual `b`.

### Cláusulas requeridas [#required]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="state-select"
    title={<>Requerido: <InlineCode>
      SELECT
    </InlineCode> declaración</>
    }
  >
    ```sql
    SELECT attribute ...
    ```

    ```sql
    SELECT function(attribute) ...
    ```

    El `SELECT` especifica qué parte de un tipo de datos desea consultar especificando un [atributo](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#attribute) o una [función](#functions). Va seguido de uno o más argumentos separados por comas. En cada argumento puedes:

    * Obtenga los valores de todos los atributos disponibles utilizando `*` como comodín. Por ejemplo: `SELECT * FROM Transaction`.
    * Obtiene valores asociados con un atributo específico o múltiples atributos especificados en una lista separada por comas.
    * Obtenga valores agregados del atributo especificado seleccionando una [función agregadora](#functions).
    * Etiquete los resultados devueltos en cada argumento con [la cláusula `AS` ](#sel-as).

    También puedes [usar `SELECT` con funciones matemáticas básicas](/docs/query-data/nrql-new-relic-query-language/getting-started/nrql-math-using-select).

    <CollapserGroup>
      <Collapser id="avg-resp-time-query" title="Tiempo medio de respuesta desde la semana pasada">
        Esta consulta devuelve el tiempo de respuesta promedio desde la semana pasada.

        ```sql
        SELECT average(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>

    Puede incluir el comodín `*` y atributos individuales, [funciones](#non-aggregator-functions), expresiones matemáticas y [variablesNRQL ](#with-as-nrql-var)en la misma declaración `SELECT`. `*` puede aparecer al principio o al final de la lista `SELECT` , y las columnas adicionales seleccionadas aparecerán al principio o al final de la tabla de resultados, respectivamente:

    ```sql
    SELECT *, attribute, function(attribute), attribute1 + attribute2 FROM ...
    ```

    ```sql
    WITH attribute1 + attribute2 AS attrSum SELECT attrSum, attribute, function(attribute), * FROM ...
    ```

    <CollapserGroup>
      <Collapser
        id="select-star-with-columns-query"
        title={<><InlineCode>
          SELECT *
        </InlineCode> con columnas adicionales</>
        }
      >
        Esta consulta devuelve todos los atributos PageView disponibles con columnas adicionales al principio.

        ```sql
        WITH concat('(', asnLatitude, ', ', asnLongitude, ')') AS coordinates
        SELECT coordinates, city, connectionSetupDuration + pageRenderingDuration AS partialDuration, *
        FROM PageView
        ```

        <img title="select star with additional columns" alt="select star with additional columns" src="/images/nrql_screenshot-select-star-with-additional-columns.webp" />

        <figcaption>
          <InlineCode>
            SELECT \*
          </InlineCode> con ejemplo de columnas adicionales
        </figcaption>
      </Collapser>
    </CollapserGroup>

    <Callout variant="tip">
      Solo se admiten [funciones que no sean agregadoras](#non-aggregator-functions) en la lista `SELECT` junto con `*`.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-from"
    title={<>Requerido: cláusula <InlineCode>
      FROM
    </InlineCode></>
    }
  >
    ```sql
    SELECT ...
    FROM data type
    ...
    ```

    Utilice la cláusula `FROM` para especificar el [tipo de datos](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql#what-you-can-query) que desea consultar. Puede comenzar su consulta con `FROM` o con [`SELECT`](#state-select). Puede combinar valores para el mismo atributo en varios tipos de datos en una lista separada por comas.

    <CollapserGroup>
      <Collapser id="one-event" title="Consultar un tipo de datos">
        Esta consulta devuelve el recuento de todas [las transacciones APM ](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults)durante los últimos siete días:

        ```sql
        SELECT count(*) FROM Transaction SINCE 7 days ago
        ```
      </Collapser>

      <Collapser id="multiple-events" title="Consultar múltiples tipos de datos">
        Esta consulta devuelve el recuento de todas [las transacciones APM ](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults)y [eventosbrowser ](/docs/insights/new-relic-insights/decorating-events/browser-default-attributes-insights#browser-attributes-table)durante los últimos tres días:

        ```sql
        SELECT count(*) FROM Transaction, PageView SINCE 3 days ago
        ```
      </Collapser>

      <Collapser id="from-lookups" title="Consultar datos desde una tabla de búsquedas">
        Ver [`lookup()`](#func-lookup).
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### Cláusulas opcionales [#optional]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="sel-as"
    title={<><InlineCode>
      AS
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    AS 'label'
    ...
    ```

    Utilice la cláusula `AS` para etiquetar un atributo, agregador, paso en un embudo o el resultado de una función matemática con una cadena delimitada por comillas simples. La etiqueta se utiliza en el gráfico resultante. Tenga en cuenta que las etiquetas de la cláusula `AS` en los gráficos de series temporales no se mostrarán si se utiliza una cláusula `FACET` .

    <CollapserGroup>
      <Collapser
        id="math-as"
        title={<>Consulta usando funciones matemáticas y <InlineCode>
          AS
        </InlineCode></>
        }
      >
        Esta consulta devuelve el número de páginas vistas por sesión:

        ```sql
        SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session'
        FROM PageView
        ```
      </Collapser>

      <Collapser
        id="funnel-as"
        title={<>Consulta utilizando embudos y <InlineCode>
          AS
        </InlineCode></>
        }
      >
        Esta consulta devuelve un recuento de personas que visitaron tanto la página principal como la página de carreras de un sitio durante la semana pasada:

        ```sql
        SELECT funnel(SESSION,
          WHERE name = 'Controller/about/main' AS 'Step 1',
          WHERE name = 'Controller/about/careers' AS 'Step 2')
        FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-compare"
    title={<><InlineCode>
      COMPARE WITH
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ... 
    (SINCE or UNTIL) (integer units) AGO
    COMPARE WITH (integer units) AGO
    ...
    ```

    Utilice la cláusula `COMPARE WITH` para comparar los valores de dos intervalos de tiempo diferentes.

    `COMPARE WITH` requiere una declaración `SINCE` o `UNTIL` . El tiempo especificado por `COMPARE WITH` es relativo al tiempo especificado por `SINCE` o `UNTIL`. Por ejemplo, `SINCE 1 day ago COMPARE WITH 1 day ago` compara ayer con anteayer.

    El intervalo de tiempo para el valor`COMPARE WITH` es siempre el mismo que el especificado por `SINCE` o `UNTIL`. Por ejemplo, `SINCE 2 hours ago COMPARE WITH 4 hours ago` podría comparar de 3:00 p. m. a 5:00 p. m. con 11:00 a. m. a 1:00 p. m.

    `COMPARE WITH` Puede tener el formato de gráfico de líneas o cartelera:

    * Con `TIMESERIES`, `COMPARE WITH` crea un gráfico de líneas con la comparación asignada a lo largo del tiempo.
    * Sin `TIMESERIES`, `COMPARE WITH` genera un cartel con el valor actual y el cambio porcentual del valor `COMPARE WITH` .

    <DNT>**Example**</DNT>: esta consulta devuelve datos como un gráfico de líneas que muestra el percentil 95 de la semana pasada en comparación con el mismo rango hace una semana. Primero como un valor único, luego como un gráfico de líneas.

    ```sql
    SELECT percentile(duration, 95) FROM PageView
    SINCE 1 week ago COMPARE WITH 1 week AGO

    SELECT percentile(duration, 95) FROM PageView
    SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO
    ```

    <Callout variant="important">
      Para `FACET` consulta usando `COMPARE WITH`, las facetas en el resultado se seleccionan según el rango de tiempo especificado usando `SINCE` y `UNTIL` y no el rango de tiempo anterior que se compara. Los resultados de una consulta `FACET` solo para el intervalo de tiempo anterior pueden incluir un conjunto diferente de facetas.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="extrapolate"
    title={<><InlineCode>
      EXTRAPOLATE
    </InlineCode> cláusula</>
    }
  >
    Puede utilizar esta cláusula con estos tipos de datos:

    * `Transaction`

    * `TransactionError`

    * Evento personalizado reportado vía <InlinePopover type="apm" />API del agente

      El propósito de `EXTRAPOLATE` es compensar matemáticamente los efectos del [muestreo del agente APM de los datos del evento](/docs/agents/manage-apm-agents/agent-data/new-relic-events-limits-sampling) para que los resultados de la consulta representen más fielmente la actividad total en su sistema.

      Esta cláusula será útil cuando un agente APM reporte tantos [eventos](/docs/using-new-relic/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#event-data) que a menudo sobrepase sus límites de reporte del [ciclo de recolección](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#harvest-cycle) . Cuando eso ocurre, el agente comienza a muestrear el evento.

      Cuando se utiliza `EXTRAPOLATE` en una consulta NRQL que admite su uso, la relación entre <DNT>**reported events**</DNT> y <DNT>**total events**</DNT> se utiliza para extrapolar una aproximación cercana del total de datos no muestreados. Cuando se utiliza en una consulta NRQL que no admite su uso o que no ha utilizado datos de muestra, no tiene ningún efecto.

      <Callout variant="important">
        Tenga en cuenta que `EXTRAPOLATE` es más útil para datos homogéneos (como rendimiento o tasa de errores). No es efectivo cuando se intenta extrapolar un recuento de cosas distintas (como `uniqueCount()` o `uniques()`).
      </Callout>

      Esta cláusula funciona solo con consultas NRQL que utilizan una de las siguientes [funciones de agregador](/docs/insights/nrql-new-relic-query-language/nrql-reference/nrql-syntax-components-functions#functions):

    * `apdex`

    * `average`

    * `count`

    * `histogram`

    * `sum`

    * `percentage` (si la función que toma como argumento admite `EXTRAPOLATE`)

    * `rate` (si la función que toma como argumento admite `EXTRAPOLATE`)

    * `stddev`

      <CollapserGroup>
        <Collapser id="extrapolate-example-1" title="Ejemplo de extrapolación del rendimiento">
          Una consulta que mostrará el rendimiento extrapolado de un servicio denominado `interestingApplication`.

          ```sql
          SELECT count(*) FROM Transaction WHERE appName = 'interestingApplication' 
          SINCE 60 minutes ago EXTRAPOLATE
          ```
        </Collapser>

        <Collapser id="extrapolate-example-2" title="Ejemplo de extrapolación del rendimiento como serie temporal">
          Una consulta que mostrará el rendimiento extrapolado de un servicio denominado `interestingApplication` por nombre de transacción, mostrado como una serie de tiempo.

          ```sql
          SELECT count(*) FROM Transaction WHERE appName = 'interestingApplication'
          SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet"
    title={<><InlineCode>
      FACET
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    FACET attribute
    ...
    ```

    Utilice `FACET` para separar y agrupar sus resultados por valores de atributos. Por ejemplo, podría `FACET` sus `PageView` datos antes del `deviceType` para determinar qué porcentaje de su tráfico proviene de dispositivos móviles, tabletas y computadoras de escritorio.

    Utilice la cláusula `LIMIT` para especificar cuántas facetas aparecen (el valor predeterminado es 10). Para agrupaciones más complejas, utilice [`FACET CASES`](#sel-facet-cases). Las cláusulas `FACET` admiten hasta cinco atributos, separados por comas.

    Las facetas se ordenan en orden descendente según el primer campo que proporcione en la cláusula `SELECT` . Si está facetando un atributo con más de 5,000 valor único, se selecciona un subconjunto de valores de faceta y se clasifica según el tipo de consulta. Tenga en cuenta que si un gráfico de serie temporal no devuelve datos (NRQL no coincide con datos coincidentes, NRQL no válido, etc.), solo mostrará una línea plana con la etiqueta que coincide con la primera tabla en la cláusula `FROM` .

    Al seleccionar `min()`, `max()`, `percentile()`, `average()` o `count()`, `FACET` usa esas funciones para determinar cómo se seleccionan y ordenan las facetas. Al seleccionar cualquier otra [función](#functions), `FACET` utiliza la frecuencia del atributo en el que está facetando para determinar cómo se seleccionan y clasifican las facetas.

    <CollapserGroup>
      <Collapser
        id="faceted-query"
        title={<>Consulta facetada usando <InlineCode>
          count()
        </InlineCode></>
        }
      >
        Esta consulta muestra las ciudades con el mayor número de páginas vistas. Esta consulta utiliza el número total de páginas vistas por ciudad para determinar cómo se seleccionan y ordenan las facetas.

        ```sql
        SELECT count(*) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="uniquecount"
        title={<>Consulta facetada usando <InlineCode>
          uniqueCount()
        </InlineCode></>
        }
      >
        Esta consulta muestra las ciudades que acceden al mayor número de URL únicas. Esta consulta utiliza el número total de veces que aparece una ciudad en particular en los resultados para determinar cómo se seleccionan y ordenan las facetas.

        ```sql
        SELECT uniqueCount(pageUrl) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser id="cohort-analysis" title="Agrupar resultados a lo largo del tiempo">
        [La segmentación avanzada](/docs/insights/new-relic-insights/features/advanced-segmentation) y [el análisis de cohortes](/docs/insights/new-relic-insights/features/cohort-analysis-grouping-results-across-time) le permiten agrupar funciones de grupos para desglosar sus datos de manera más efectiva.

        El análisis de cohortes es una forma de agrupar resultados según la marca de tiempo. Puede separarlos en grupos que cubran un rango específico de fechas y horas.
      </Collapser>
    </CollapserGroup>

    <Callout variant="important">
      Cuando se utilizan funciones para agregar valores de atributos, es importante que el atributo que se agrega en la primera función de su consulta contenga valores no nulos. Las facetas solo se elegirán para filas que contengan un valor no nulo para el atributo en la primera función.

      Ejemplo:

      ```sql
      FROM Event SELECT average(attribute) FACET name
      ```

      Los nombres solo se elegirán de las filas donde el atributo no sea nulo.

      Para verificar si el atributo que está utilizando en su función contiene valores no nulos, ejecute la siguiente consulta:

      ```sql
      FROM Event SELECT attribute, name WHERE attribute IS NOT NULL
      ```
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="facet-as"
    title={<><InlineCode>
      FACET ... AS
    </InlineCode> cláusula</>
    }
  >
    Utilice `FACET ... AS` para nombrar facetas utilizando la palabra clave `AS` en consulta. Esta cláusula es útil para agregar nombres más claros o simplificados para las facetas en los resultados. También se puede utilizar para cambiar el nombre de facetas en una consulta [de agregación anidada](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query) .

    `FACET ... AS` consulta cambiará los nombres de las facetas en los resultados (cuando aparecen como encabezados en tablas, por ejemplo), pero no los nombres de las facetas en sí.

    ```sql
    FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type'
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-cases"
    title={<><InlineCode>
      FACET CASES
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    FACET CASES 
    (
      WHERE attribute operator value, 
      WHERE attribute operator value, 
      ...
    )
    ...
    ```

    Emplee `FACET CASES` para desglosar sus datos según condiciones más complejas que las posibles con [`FACET`](#sel-facet). Separe varias condiciones con una coma `,`. Por ejemplo, podrías consultar tus datos `PageView` y `FACET CASES` en categorías como menos de 1 segundo, de 1 a 10 segundos y más de 10 segundos. Puede combinar varios atributos dentro de sus casos y etiquetar los casos con el selector [`AS`](#sel-as). Los puntos de datos se agregarán como máximo a un caso facetario, el primer caso facetario con el que coincidan.

    También puede usar una [función de tiempo](/docs/query-data/nrql-new-relic-query-language/nrql-query-examples/group-results-across-time) con su atributo y puede usar el operador `OR` para facetar los resultados que no coinciden con ninguno de los casos especificados.

    <CollapserGroup>
      <Collapser
        id="facet-cases-basic"
        title={<>Uso básico con <InlineCode>
          WHERE
        </InlineCode></>
        }
      >
        ```sql
        SELECT count(*) FROM PageView 
        FACET CASES 
        (
          WHERE duration < 1, 
          WHERE duration > 1 AND duration < 10, 
          WHERE duration > 10
        )
        ```
      </Collapser>

      <Collapser id="facet-cases-mixnmatch" title="Grupo basado en múltiples atributos.">
        Este ejemplo agrupa los resultados en un depósito donde el nombre de la transacción contiene `login` y otro donde la URL contiene `login` y un atributo personalizado indica que el usuario era un usuario pago:

        ```sql
        SELECT count(*) FROM Transaction 
        FACET CASES 
        (
          WHERE name LIKE '%login%', 
          WHERE name LIKE '%feature%' AND customer_type = 'Paid'
        )
        ```
      </Collapser>

      <Collapser
        id="facet-cases-as-label"
        title={<>Etiquetar grupos con <InlineCode>
          AS
        </InlineCode></>
        }
      >
        Este ejemplo utiliza el selector [`AS`](#sel-as) para darle a sus resultados un nombre legible por humanos:

        ```sql
        SELECT count(*) FROM Transaction 
        FACET CASES 
        (
          WHERE name LIKE '%login%' AS 'Total Logins', 
          WHERE name LIKE '%feature%' AND customer_type = 'Paid' AS 'Feature Visits from Paid Users'
        )
        ```
      </Collapser>

      <Collapser
        id="facet-cases-with-or"
        title={<>Datos de faceta que no coinciden con <InlineCode>
          OR
        </InlineCode></>
        }
      >
        Este ejemplo utiliza el operador `OR` para facetar resultados que no coincidieron con ninguno de sus casos:

        ```sql
        SELECT count(*) FROM Transaction 
        FACET CASES 
        (
          WHERE name LIKE '%login%', 
          WHERE name LIKE '%feature%' AND customer_type = 'Paid'
        ) 
        OR name
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-order"
    title={<><InlineCode>
      FACET ... ORDER BY
    </InlineCode> cláusula</>
    }
  >
    En NRQL, el valor predeterminado es que la primera agregación en la cláusula `SELECT` guíe la selección de facetas en una consulta. `FACET ... ORDER BY` le permite anular este comportamiento predeterminado agregando una función agregada con el modificador `ORDER BY` para especificar cómo se seleccionan las facetas. Específicamente, la cláusula anulará la prioridad por la cual se eligen las facetas en el resultado final antes de ser limitadas por la cláusula `LIMIT`. Esta cláusula se puede emplear para consultas, pero no para alertas o transmisión.

    Este ejemplo muestra cómo usar `FACET ... ORDER BY` para encontrar las duraciones promedio de las transacciones de aplicaciones, mostrando las 10 duraciones más altas (límite predeterminado) de las aplicaciones que tienen el tamaño de respuesta más alto. En este caso, si no se utiliza `FACET ... ORDER BY` , los resultados de la consulta mostrarán los 10 primeros por duraciones más altas, y el tamaño de la respuesta será irrelevante para la selección de la aplicación.

    ```sql
    FROM Transaction SELECT average(duration) TIMESERIES 
    FACET appName ORDER BY max(responseSize)
    ```

    Tenga en cuenta que si utiliza la cláusula `FACET ... ORDER BY` , no puede cambiar el orden de clasificación agregando los modificadores `ASC` y `DESC` . De forma predeterminada, esta cláusula utiliza `DESC`.

    <Callout variant="tip">
      Debido a que las operaciones se realizan antes de que se aplique la cláusula `LIMIT` , `FACET ... ORDER BY` no afecta el tipo de resultados finales de la consulta, lo que será particularmente notable en los resultados de las consultas que no son de series temporales.
    </Callout>

    <Callout variant="important">
      El modificador `ORDER BY` en este caso funciona de manera diferente a la cláusula `ORDER BY` . Al analizar consultas que siguen el formato `FACET attribute1 ORDER BY attribute2`, New Relic las leerá como `FACET ... ORDER BY` consulta, pero solo si `ORDER BY` aparece inmediatamente después de `FACET`. De lo contrario, New Relic interpretará `ORDER BY` como una cláusula.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-join"
    title={<><InlineCode>
      JOIN
    </InlineCode> cláusula</>
    }
  >
    Utilice la cláusula `JOIN` para combinar datos de un tipo de evento con los resultados de una subconsulta basada en un atributo o clave común.

    ```sql
    FROM Event [INNER|LEFT] JOIN (SELECT... FROM...) ON [key =] key SELECT ...
    ```

    Existen algunas reglas simples para las uniones de subconsultas:

    * La cláusula `JOIN` siempre debe seguir inmediatamente a la cláusula [`FROM`](#sel-from) .
    * Prefijar un tipo de unión (`INNER` o `LEFT`) es opcional. Cuando se omite, el tipo de unión por defecto es `INNER`.
    * Los paréntesis que contienen una [subconsulta](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql) deben seguir inmediatamente `JOIN`.
    * La cláusula `ON` debe seguir inmediatamente a la subconsulta.

    <table id="join-types">
      <thead>
        <tr>
          <th colSpan={2}>
            <DNT>
              **Join types**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td style={{ width: "300px" }}>
            `INNER`
          </td>

          <td>
            El resultado solo incluirá valores de la consulta externa que tengan un valor coincidente en los resultados de la subconsulta unida. Este es el tipo de unión predeterminado.
          </td>
        </tr>

        <tr>
          <td>
            `LEFT`
          </td>

          <td>
            El resultado incluirá eventos de la consulta externa que no tengan una coincidencia de la subconsulta unida.
          </td>
        </tr>
      </tbody>
    </table>

    <table id="join-on">
      <thead>
        <tr>
          <th colSpan={2}>
            <DNT>
              **Join `ON` clause**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td style={{ width: "300px" }}>
            `ON parentKey = subqueryKey`
          </td>

          <td>
            Define el valor principal a comparar en la subconsulta y la consulta externa. El único operador de comparación permitido es la igualdad.

            * El lado izquierdo es siempre la clave utilizada en la consulta principal y puede ser un atributo o función.
            * El lado derecho se utiliza para el valor principal de la subconsulta y debe ser un identificador.
          </td>
        </tr>

        <tr>
          <td>
            `ON key`
          </td>

          <td>
            Esta es una sintaxis abreviada para cuando el identificador de clave es el mismo en ambos contextos. Es equivalente a `ON key = key`.
          </td>
        </tr>
      </tbody>
    </table>

    Restricciones y limitaciones a considerar:

    * La subconsulta unida seguirá teniendo un [`LIMIT`](#sel-limit) predeterminado de 10, con un máximo de `LIMIT` de 5000. Tenga en cuenta que el `LIMIT` de la consulta externa no afecta la consulta interna.
    * No se admite el uso de `TIMESERIES` en la subconsulta unida. Si su consulta externa utiliza `TIMESERIES`, tenga en cuenta que la subconsulta unida proporcionará un resultado único durante todo el período de la consulta.
    * Como todas las subconsultas, las subconsultas unidas no se pueden utilizar en condición de alerta.
    * Si bien `SELECT *` se admite en la consulta principal, no se admite en la subconsulta unida.
    * La cardinalidad de la combinación está limitada a 1:100, lo que significa que una única clave de combinación no puede asignarse a más de cien filas en el resultado de la subconsulta.

    Para conocer en profundidad la cláusula `JOIN` , consulte el tutorial [sobre uniones de subconsultas NRQL](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/subquery-joins).

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          INNER JOIN
        </InlineCode> con una subconsulta facetada</>
        }
        id="example-faceted-inner-join"
      >
        Esta consulta encuentra el recuento de eventos facetados por `browserTransactionName` del tipo de evento `PageView` y luego por `currentUrl` del tipo de evento `PageAction` . Esto une los dos tipos de eventos basados en valores de atributo `session` comunes.

        ```sql
        FROM PageView
        JOIN 
        (
          FROM PageAction 
          SELECT count(*) 
          FACET session, currentUrl
        ) 
        ON session
        SELECT count(*) FACET browserTransactionName, currentUrl
        ```

        <img title="screenshot faceted inner join" alt="screenshot faceted inner join" src="/images/nrql_screenshot-crop_example-faceted-inner-join.webp" />

        <figcaption>
          Ejemplo de <InlineCode>
            INNER JOIN
          </InlineCode> facetado
        </figcaption>
      </Collapser>

      <Collapser
        title={<><InlineCode>
          LEFT JOIN
        </InlineCode> con una subconsulta facetada</>
        }
      >
        Este ejemplo consulta los mismos datos que el [ejemplo `INNER JOIN` facetado](#example-faceted-inner-join), pero como consulta `LEFT JOIN` , los resultados incluyen elementos en la tabla `PageView` que no tienen valores `session` coincidentes en los resultados de la subconsulta `PageAction` . .

        ```sql
        FROM PageView
        LEFT JOIN 
        (
          FROM PageAction 
          SELECT count(*) 
          FACET session, currentUrl
        ) 
        ON session
        SELECT count(*) FACET browserTransactionName, currentUrl
        ```

        <img title="screenshot faceted left join" alt="screenshot faceted left join" src="/images/nrql_screenshot-crop_example-faceted-left-join.webp" />

        <figcaption>
          Ejemplo de <InlineCode>
            LEFT JOIN
          </InlineCode> facetado
        </figcaption>
      </Collapser>

      <Collapser
        title={<><InlineCode>
          INNER JOIN
        </InlineCode> con una subconsulta no agregada</>
        }
      >
        Aquí estamos realizando una subconsulta no agregada, por filas, en la que la consulta externa encuentra el recuento de eventos facetados por `currentUrl` del tipo de evento `PageAction` y luego por `browserTransactionNamed` del tipo de evento `PageView` . Esto une los dos tipos de eventos basados en valores de atributo `session` comunes.

        Tenga en cuenta que el valor `session` `34d5ce6acf4c60be` tiene dos valores `browserTransactionName` del tipo de evento `PageView` de la subconsulta, lo que agrega filas adicionales al resultado.

        ```sql
        FROM PageAction
        LEFT JOIN 
        (
          FROM PageView 
          SELECT session, browserTransactionName 
          LIMIT MAX
        ) 
        ON session
        SELECT count(*) FACET session, currentUrl, browserTransactionName LIMIT MAX
        ```

        <img title="screenshot columnar inner join" alt="screenshot columnar inner join" src="/images/nrql_screenshot-crop_example-columnar-inner-join.webp" />

        <figcaption>
          Ejemplo de <InlineCode>
            INNER JOIN
          </InlineCode> no agregado
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-limit"
    title={<><InlineCode>
      LIMIT
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    LIMIT count
    ...
    ```

    Utilice la cláusula `LIMIT` para controlar el número máximo de valores de faceta devueltos por `FACET` consulta o el número máximo de elementos devueltos por `SELECT *` consulta. Esta cláusula toma un único valor entero como argumento. Si no se especifica la cláusula `LIMIT` o no se proporciona ningún valor, el límite predeterminado es 10 para `FACET` consulta y 100 en el caso de `SELECT *` consulta.

    El valor máximo permitido para la cláusula `LIMIT` es 5000. consulta puede usar la cláusula `LIMIT MAX` en lugar de un valor específico, que automáticamente toma de forma predeterminada el valor máximo actual. Puede usar esto si siempre desea publicar la cantidad máxima de resultados, incluso si cambia en el futuro. Si desea que el comportamiento de su consulta permanezca sin cambios, especifique un valor explícito en lugar de usar `LIMIT MAX`.

    <CollapserGroup>
      <Collapser
        title={<>Consulta usando <InlineCode>
          LIMIT
        </InlineCode></>
        }
      >
        Esta consulta muestra los 20 países principales por recuento de sesiones y proporciona el percentil 95 del tiempo de respuesta para cada país solo para usuarios de Windows.

        ```sql
        SELECT uniqueCount(session), percentile(duration, 95)
        FROM PageView WHERE userAgentOS = 'Windows'
        FACET countryCode LIMIT 20 SINCE YESTERDAY
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-offset"
    title={<><InlineCode>
      OFFSET
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    LIMIT count OFFSET count
    ...
    ```

    Utilice la cláusula `OFFSET` con `LIMIT` para controlar la parte de filas devueltas por `SELECT *` o `SELECT column` consulta. Al igual que la cláusula `LIMIT` , `OFFSET` toma un valor entero único como argumento. `OFFSET` establece el número de filas que se omitirán antes de que se devuelvan las filas seleccionadas de su consulta. Esto está restringido por `LIMIT`.

    `OFFSET` las filas se omiten a partir del registro más reciente.

    Por ejemplo, la consulta `SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1` devuelve los últimos 5 valores de `Minute_Report` excepto el más reciente.
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-order-by"
    title={<><InlineCode>
      ORDER BY
    </InlineCode> cláusula</>
    }
  >
    La cláusula `ORDER BY` le permite especificar cómo desea ordenar los resultados de su consulta en la consulta que selecciona el evento atributo por fila.

    Esta consulta ordena dos atributos de transacción específicos por duración.

    ```sql
    FROM Transaction SELECT appName, duration ORDER BY duration
    ```

    El orden de clasificación predeterminado es ascendente, pero se puede cambiar agregando los modificadores `ASC` o `DESC` .

    Esta consulta ordena todos los atributos de transacción por duración en orden descendente.

    ```sql
    FROM Transaction SELECT * ORDER BY duration DESC
    ```

    <Callout variant="important">
      La cláusula `ORDER BY` no se aplica a `FACET` consulta. No debe confundirse con la cláusula `FACET ... ORDER BY` , que guía la selección de facetas. Para obtener más información, consulte [`FACET ... ORDER BY`](#sel-facet-order).
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="#sel-prediction"
    title={<><InlineCode>
      PREDICT
    </InlineCode> cláusula</>
    }
  >
    ```sql
    FROM Transaction SELECT count(*) WHERE error IS TRUE TIMESERIES PREDICT
    ...
    ```

    Con la cláusula `PREDICT` , puede agregar pronósticos de tendencias de datos futuras en gráficos de líneas basados en datos históricos. Tenga en cuenta los siguientes puntos al emplear esta cláusula:

    * Se aplica únicamente a consultas con cláusula `TIMESERIES` .
    * Emplea `TIMESERIES <time period>` como intervalo para los puntos de datos previstos.
    * No admite [datos de intervalo de tiempo de métrica](/docs/data-analysis/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#timeslice-data) mientras se encuentra en Vista previa pública.

    <Callout variant="important">
      La cláusula `PREDICT` no se puede emplear con la cláusula [`COMPARE WITH`](/docs/nrql/nrql-syntax-clauses-functions/#sel-compare) o [agregaciones anidadas](/docs/nrql/using-nrql/nested-aggregation-make-ordered-computations-single-query) dentro de [subconsultas](/docs/nrql/using-nrql/subqueries-in-nrql/).
    </Callout>

    Para obtener más información sobre cómo y cuándo puede emplear `PREDICT`, consulte [Predicciones NRQL](/docs/query-your-data/explore-query-data/use-charts/nrql-predictions/).
  </Collapser>

  <Collapser
    className="freq-link"
    id="show-event-types"
    title={<><InlineCode>
      SHOW EVENT TYPES
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SHOW EVENT TYPES...
    ```

    `SHOW EVENT TYPES` devolverá una lista de todos los tipos de datos presentes en su cuenta durante un rango de tiempo específico. Se utiliza como primera cláusula de una consulta en lugar de `SELECT`.

    <Callout variant="important">
      En este contexto, &quot;tipos de eventos&quot; se refiere a los tipos de datos a los que puede acceder con una consulta NRQL .
    </Callout>

    <CollapserGroup>
      <Collapser id="avg-resp-time-query" title="Tipos de datos en el último día">
        Esta consulta devolverá todos los tipos de datos presentes durante el último día:

        ```sql
        SHOW EVENT TYPES SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-since"
    title={<><InlineCode>
      SINCE
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    SINCE [numerical units AGO | phrase]
    ...
    ```

    El valor de <DNT>**default**</DNT> es <DNT>**1 hour ago**</DNT>.

    Utilice la cláusula `SINCE` para definir el comienzo inclusivo de un rango de tiempo para los datos devueltos. Puede especificar una zona horaria para la consulta pero no para los resultados. Los resultados de NRQL se basan en la hora de su sistema.

    Al emplear NRQL, puede establecer una timestamp UTC, una hora relativa o una cadena `DateTime`. Consulte [Especificación de una hora](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/#spec-time).

    Ver también:

    * [Establecer el rango de tiempo de una consulta](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/)
    * [HASTA](#sel-until)
  </Collapser>

  <Collapser
    className="freq-link"
    id="slide-by"
    title={<><InlineCode>
      SLIDE BY
    </InlineCode> cláusula</>
    }
  >
    La cláusula `SLIDE BY` admite una característica conocida como ventanas deslizantes. Con las ventanas deslizantes, los datos `SLIDE BY` se recopilan en &quot;ventanas&quot; de tiempo que se superponen entre sí. Estas ventanas pueden ayudar a suavizar los gráficos de líneas con mucha variación en los casos en que el agregado móvil (como una media móvil) es más importante que los agregados de ventanas de tiempo estrechas.

    Para utilizar `SLIDE BY`, colóquelo en una consulta después de la cláusula `TIMESERIES` . Por ejemplo, esta consulta extrae datos en ventanas de 5 minutos con un intervalo `SLIDE BY` 1 minuto, lo que significa que cada ventana dura 5 minutos, pero la ventana 1 comienza en 0 minutos, la ventana 2 comienza en 1 minuto, la ventana 3 comienza en 2 minutos, etcétera.

    ```sql
    SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute
    ```

    Para obtener más información sobre cómo y cuándo puede utilizar `SLIDE BY`, consulte [Crear gráficos más fluidos con ventanas deslizantes](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows). O mire este breve vídeo (aprox. 3:20 minutos).

    <Video id="b9WVyb1wU6w" type="youtube" />

    <CollapserGroup>
      <Collapser
        id="sliding-window-max-auto"
        title={<>Utilice <InlineCode>
          SLIDE BY
        </InlineCode> con intervalo <InlineCode>
          MAX
        </InlineCode> o <InlineCode>
          AUTO
        </InlineCode></>
        }
      >
        Puede utilizar ventanas deslizantes en combinación con `MAX` o `AUTO`. Sin embargo, `MAX` o `AUTO` no se pueden colocar entre `TIMESERIES` y `SLIDE BY`.

        Esta consulta decidirá automáticamente un intervalo de ventana `SLIDE BY` .

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO
        ```

        Esta consulta establecerá la ventana `SLIDE BY` con el detalle de intervalo máxima.

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX
        ```

        <Callout variant="important">
          El valor `SLIDE BY` determinado por `AUTO` o `MAX` puede producir un intervalo de paso mayor que el tamaño de la ventana, lo que puede provocar espacios vacíos y resultados inesperados.
        </Callout>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timeseries"
    title={<><InlineCode>
      TIMESERIES
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    TIMESERIES integer units
    ...
    ```

    Utilice la cláusula `TIMESERIES` para devolver datos como una serie temporal desglosada por un período de tiempo específico. Dado que `TIMESERIES` se utiliza para activar ciertos gráficos, no existe un valor predeterminado.

    Para indicar el rango de tiempo, utilice `integer units`. Por ejemplo:

    * `TIMESERIES 1 minute`
    * `TIMESERIES 30 minutes`
    * `TIMESERIES 1 hour`
    * `TIMESERIES 30 seconds`

    `TIMESERIES` se puede combinar con argumentos como `MAX`, `AUTO` y `SLIDE BY` para personalizar aún más los resultados de la consulta, como se muestra en los ejemplos siguientes.

    <Callout variant="important">
      Para funciones como `average()` o `percentile()`, una ventana de agregación grande puede tener un efecto de suavizado significativo en el valor atípico. Esto es cierto independientemente de que la consulta utilice ventanas deslizantes o no.
    </Callout>

    <CollapserGroup>
      <Collapser id="set-interval" title="Utilice un intervalo establecido">
        El valor proporcionado indica las unidades utilizadas para desglosar el gráfico. Por ejemplo, para presentar un gráfico de un día que muestre incrementos de 30 minutos:

        ```sql
        SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes
        ```
      </Collapser>

      <Collapser id="timeseries-auto" title="Utilice un intervalo establecido automáticamente">
        `TIMESERIES` También se puede configurar en `AUTO`, lo que dividirá su gráfico en un número razonable de divisiones. Por ejemplo, un gráfico diario se dividirá en intervalos de 30 minutos y un gráfico semanal se dividirá en intervalos de 6 horas.

        Esta consulta devuelve datos como un gráfico de líneas que muestra el percentil 50 y 90 del tiempo de transacción del lado del cliente durante una semana con un punto de datos cada 6 horas.

        ```sql
        SELECT average(duration), percentile(duration, 50, 90)
        FROM PageView SINCE 1 week AGO TIMESERIES AUTO
        ```
      </Collapser>

      <Collapser
        id="timeseries-max"
        title={<>Utilice el intervalo <InlineCode>
          MAX
        </InlineCode></>
        }
      >
        Puede configurar `TIMESERIES` en `MAX`, lo que ajustará automáticamente su ventana de tiempo al número máximo de intervalos permitidos para un período de tiempo determinado. Esto le permite actualizar sus ventanas de tiempo sin tener que actualizar manualmente sus `TIMESERIES` depósitos y garantiza que su ventana de tiempo se divida en la cantidad máxima de intervalos permitidos. El número máximo de `TIMESERIES` depósitos que se devolverán es 366.

        Por ejemplo, la siguiente consulta crea intervalos de 4 minutos, que es el límite para un gráfico diario.

        ```sql
        SELECT average(duration) FROM Transaction SINCE 1 day ago TIMESERIES MAX
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-until"
    title={<><InlineCode>
      UNTIL
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    UNTIL integer units AGO
    ...
    ```

    Utilice la cláusula `UNTIL` para definir el final del rango de tiempo para realizar la consulta. El valor es exclusivo, lo que significa que el rango de tiempo irá al instante especificado, pero no lo incluirá.

    El valor de <DNT>**default**</DNT> es <DNT>**NOW**</DNT>. Utilice únicamente `UNTIL` para especificar un punto final distinto del predeterminado.

    Ver también:

    * [Establecer el rango de tiempo de una consulta](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/)
    * [DESDE](#sel-since)
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-where"
    title={<><InlineCode>
      WHERE
    </InlineCode> cláusula</>
    }
  >
    Utilice la cláusula `WHERE` para filtrar los resultados. NRQL devuelve los resultados que cumplen las condiciones especificadas en la cláusula.

    ```sql
    SELECT function(attribute) ...
    WHERE attribute [operator 'value' | IN ('value' [, 'value']) | IS [NOT] NULL ]
    [AND|OR ...]
    ...
    ```

    * Si especifica más de una condición, separe las condiciones por los operadores `AND` o `OR`.

    <table id="where-operators">
      <thead>
        <tr>
          <th width={150}>
            <DNT>
              **Operators that the `WHERE` clause accepts**
            </DNT>
          </th>

          <th>
            <DNT>
              **Description**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `=`, `!=`, `<`, `<=`, `>`, `>=`
          </td>

          <td>
            NRQL acepta operadores de comparación estándar. Ejemplo: `state = 'WA'`

            Para atributo con valores booleanos, use `IS` y no `=`.
          </td>
        </tr>

        <tr>
          <td>
            `AND`
          </td>

          <td>
            Se utiliza para definir una intersección de dos condiciones.
          </td>
        </tr>

        <tr>
          <td>
            `OR`
          </td>

          <td>
            Se utiliza para definir una unión de dos condiciones.
          </td>
        </tr>

        <tr>
          <td>
            `IS NULL`
          </td>

          <td>
            Determina si un atributo tiene un valor nulo.
          </td>
        </tr>

        <tr>
          <td>
            `IS NOT NULL`
          </td>

          <td>
            Determina si un atributo no tiene un valor nulo.
          </td>
        </tr>

        <tr>
          <td>
            `IS TRUE`
          </td>

          <td>
            Determina si un atributo tiene un valor booleano de `true`.
          </td>
        </tr>

        <tr>
          <td>
            `IS FALSE`
          </td>

          <td>
            Determina si un atributo tiene un valor booleano de `false`.
          </td>
        </tr>

        <tr>
          <td>
            `IN`
          </td>

          <td>
            Determina si el valor de cadena de un atributo está en un conjunto específico. El uso de este método produce un mejor rendimiento que encadenar varias cláusulas `WHERE` .

            Ejemplo:

            ```sql
            animalType IN ('cat', 'dog', 'fish')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `NOT IN`
          </td>

          <td>
            Determina si el valor de cadena de un atributo no está en un conjunto específico. El uso de este método produce un mejor rendimiento que encadenar varias cláusulas `WHERE` .

            Los valores deben estar entre paréntesis, separados por comas. Por ejemplo:

            ```sql
            SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `LIKE`
          </td>

          <td>
            Determina si un atributo contiene una subcadena especificada.

            El argumento de cadena para el operador `LIKE` acepta el signo de porcentaje (`%`) como comodín en cualquier lugar de la cadena.

            Tenga en cuenta lo siguiente:

            * El operador `LIKE` no distingue entre mayúsculas y minúsculas.

            * Si no incluye ningún comodín, obtendrá coincidencias de mayúsculas y minúsculas para su cadena. Por ejemplo, esta consulta sin comodines coincidirá con `B` y `b`:

              ```sql
              FROM foo
              SELECT *
              WHERE bar LIKE 'B'
              ```

            <DNT>
              **Examples:**
            </DNT>

            `userAgentName LIKE 'IE%'`

            * ES DECIR

            * IE Mobile

              `userAgentName LIKE 'o%a%'`

            * Ópera

            * Mini Opera

              `userAgentName LIKE 'o%a'`

            * Ópera

              `userAgentName LIKE '%o%a%'`

            * Ópera

            * Mini Opera

            * Mozilla Gecko
          </td>
        </tr>

        <tr>
          <td>
            `NOT LIKE`
          </td>

          <td>
            Determina si un atributo no contiene una subcadena especificada.
          </td>
        </tr>

        <tr>
          <td>
            `RLIKE`
          </td>

          <td>
            Determina si un atributo contiene una subcadena Regex especificada. Utiliza [la sintaxis RE2](https://github.com/google/re2/wiki/Syntax).

            <DNT>
              **Examples:**
            </DNT>

            `appName RLIKE r'z.*|q.*'`

            * `z-app`

            * `q-app`

              `hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*'`

            * `ip-10-351-19-237`

            * `ip-10-351-2-41`

            * `ip-10-351-24-238`

            * `ip-10-351-14-15`

              <Callout variant="important">
                La expresión regular utiliza de forma predeterminada la coincidencia de cadena completa, por lo tanto, `^` y `$` están implícitos y no es necesario agregarlos.
              </Callout>
          </td>
        </tr>

        <tr>
          <td>
            `NOT RLIKE`
          </td>

          <td>
            Determina si un atributo no contiene una subcadena Regex especificada. Utiliza [la sintaxis RE2](https://github.com/google/re2/wiki/Syntax).
          </td>
        </tr>
      </tbody>
    </table>

    <CollapserGroup>
      <Collapser id="query-3-conditions" title="Ejemplo de consulta con tres condiciones.">
        Esta consulta devuelve el tiempo de respuesta del browser para las páginas con `checkout` en la URL para el usuario de Safari en los Estados Unidos y Canadá durante las últimas 24 horas.

        ```sql
        SELECT histogram(duration, 50, 20) FROM PageView
        WHERE countryCode IN ('CA', 'US') AND userAgentName = 'Safari' AND pageUrl LIKE '%checkout%'
        SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-metric-format"
    title={<><InlineCode>
      WITH METRIC_FORMAT
    </InlineCode> cláusula</>
    }
  >
    Para obtener información sobre cómo consultar datos métricos, consulte [consulta métrica](#query-metrics).
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-as-nrql-var"
    title={<><InlineCode>
      WITH ... AS
    </InlineCode> cláusula (variables NRQL)</>
    }
  >
    ```sql
    FROM ...
    WITH function(attribute) AS var
    SELECT var
    ...
    ```

    Utilice la cláusula `WITH ... AS` para definir variables NRQL para almacenar valores como variables a las que se puede hacer referencia en cualquier parte de la consulta. Algunas reglas y consejos:

    * La cláusula `WITH ... AS` puede ir antes, entre o directamente luego de la cláusula `FROM` o `SELECT`
    * Solo las funciones de fila (por ejemplo, `capture()`) se pueden configurar como variables. Las funciones de agregador, como `average()`, no son compatibles.
    * Solo se puede usar un `WITH` , pero puedes usar múltiples variables NRQL siempre que estén separadas por una coma.
    * Si una variable NRQL definida usa el mismo nombre que un atributo existente, la variable tendrá prioridad.
    * Los nombres de variables no pueden incluir el símbolo `%` .

    <Callout variant="important">
      Las reglas [de evento a métrica](/docs/data-apis/convert-to-metrics/analyze-monitor-data-trends-metrics/) no soportan la cláusula `WITH ... AS` en [NRQL consulta](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/).
    </Callout>

    A continuación se muestran algunos ejemplos de consultas:

    <CollapserGroup>
      <Collapser id="basic-nrql-var" title="Uso básico de una variable.">
        ```sql
        FROM Transaction
        WITH duration * 1000 AS millisec
        SELECT millisec
        ```
      </Collapser>

      <Collapser id="multiple-nrql-var" title="Usando múltiples variables">
        ```sql
        FROM Log
        WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice)
        SELECT itemId, unitPrice
        ```

        Obtenga más información sobre [el análisis de anclaje](#func-aparse) (`aparse()`).
      </Collapser>

      <Collapser id="nrql-var-other-clauses" title="Usar variable en otras cláusulas">
        En este ejemplo, se utiliza una variable NRQL, `unitPrice`, para crear otra variable, `unitPriceNum`, convirtiendo la cadena extraída en un número. Luego, las variables se utilizan en las cláusulas `SELECT`, `WHERE` y `FACET` .

        ```sql
        FROM Log
        WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice),
          numeric(unitPrice) AS unitPriceNum
        SELECT sum(unitPriceNum)
        FACET itemId
        WHERE unitPriceNum < 100
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timezone"
    title={<><InlineCode>
      WITH TIMEZONE
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ... WITH TIMEZONE (selected zone)
    ...
    ```

    Utilice la cláusula `WITH TIMEZONE` para seleccionar una zona horaria para una fecha u hora en la consulta que aún no tiene una zona horaria especificada.

    Si incluye la cláusula `WITH TIMEZONE` sin especificar una zona horaria en una fecha y hora, las cláusulas `since` y `until` se mantienen en la zona horaria proporcionada.

    Si no incluye la cláusula `WITH TIMEZONE` , pero incluye una zona horaria en una cadena de fecha y hora, la zona horaria de la cadena de fecha y hora se mantiene.

    <Callout variant="important">
      La zona horaria predeterminada siempre es UTC si no se especifica ninguna. Los valores de timestamp sin procesar (como se ven en la vista JSON) en los resultados son siempre UTC. La UI muestra los resultados en la zona horaria que haya especificado en la configuración de su cuenta. Una zona horaria en una cadena de marca de tiempo siempre funciona. Reemplaza la zona `WITH TIMEZONE` .
    </Callout>

    Por ejemplo, la cláusula de consulta `SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'` devuelve datos registrados desde la medianoche del lunes, hora de Estados Unidos/Nueva York, hasta la medianoche del martes, hora de Estados Unidos/Nueva York.

    A continuación se muestran algunos ejemplos de cláusulas de intervalo de tiempo de consulta:

    * No hay zona horaria en la cadena de fecha y hora usando la cláusula `WITH TIMEZONE` :

      ```sql
      SINCE today UNTIL '2022-05-19T12:00' WITH TIMEZONE 'America/Los_Angeles'
      ```

      Esto se resuelve como `"beginTime": "2022-05-19T07:00:00Z"` y `"endTime": "2022-05-19T19:00:00Z"`.

    * Zona horaria en la cadena de fecha y hora, sin utilizar la cláusula `WITH TIMEZONE` :

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500'
      ```

      Esto se resuelve como `"beginTime": "2022-05-19T00:00:00Z"` y `"endTime": "2022-05-19T17:00:00Z"`.

    * Zona horaria en la cadena de fecha y hora, utilizando la cláusula `WITH TIMEZONE` América/Los Ángeles, que es -0700 durante el horario de verano:

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500' WITH TIMEZONE 'America/Los_Angeles'
      ```

      Esto se resuelve como `"beginTime": "2022-05-19T07:00:00Z"` y `"endTime": "2022-05-19T19:00:00Z"`.

    Consulte la lista [de ID de zona](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/#timezones-ids) disponibles.

    Consulte [Establecer rango de tiempo en dashboards y gráficos](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets) para obtener información detallada y ejemplos.
  </Collapser>
</CollapserGroup>

## Consulta de datos metricos [#query-metrics]

Los datos métricos son más complejos que otros tipos de datos. Hay consejos específicos para consultarlo bien. Disponemos de dos tipos de datos métricos, cada uno con sus propias pautas de consulta:

* [consulta dimensional métrica](/docs/data-ingest-apis/get-data-new-relic/metric-api/view-query-you-metric-data), que son reportados por nuestra API métrica y por algunas de nuestras soluciones que utilizan esa API (por ejemplo, nuestra [integración Dropwizard](/docs/more-integrations/open-source-telemetry-integrations/dropwizard/dropwizard-reporter) o [integración Micrometer](/docs/more-integrations/open-source-telemetry-integrations/micrometer/micrometer-metrics-registry)).
* [consulta intervalo de tiempo de datos métricos](/docs/query-data/nrql-new-relic-query-language/nrql-query-tutorials/query-metric-timeslice-data-nrql), que es nuestro tipo de datos métricos original reportado por nuestro APM, monitoreo de móviles y <InlinePopover type="browser" />.

Para obtener más detalles sobre cómo reportamos datos métricos, consulte [tipos de datos métricos](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics).

## Funciones [#functions]

En esta sección explicamos las funciones NRQL , tanto [funciones agregadoras](#aggregator-functions) como [funciones no agregadoras](#non-aggregator-functions).

### Funciones agregadoras [#aggregator-functions]

Puede utilizar funciones de agregador para filtrar y agregar datos. Algunos consejos para utilizarlos:

* Si utiliza una función de agregador varias veces en la misma consulta (por ejemplo, `SELECT median(one_metric), median(another_metric)`), puede causar problemas al mostrar los resultados. Para solucionar esto, utilice la [función`AS` ](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-as). Por ejemplo:
  ```sql
  SELECT median(one_metric) AS 'med-a', median(another_metric) AS 'med-b'
  ```
* No se admite el tipo de datos &quot;coerción&quot;. Lea acerca de [las funciones de conversión de tipos disponibles](#type-conversion).
* Para saber cómo mostrar los resultados a lo largo del tiempo, consulte [Agrupar resultados a lo largo del tiempo](/docs/insights/new-relic-insights/features/cohort-analysis).

Ejemplos:

```sql
SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
```

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="func-aggregationendtime"
    title={<InlineCode>aggregationendtime()</InlineCode>
    }
  >
    Utilice la función `aggregationendtime()` para devolver la hora de la agregación relevante. Más específicamente, para un agregado determinado, la función `aggregationendtime()` proporciona la timestamp del final del período de tiempo de esa agregación. Por ejemplo, en una consulta de series de tiempo, para un punto de datos que abarca una hora de datos, la función devolvería la timestamp del final de ese período de hora.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-apdex"
    title={<InlineCode>apdex(attribute, t: )</InlineCode>
    }
  >
    Emplee la función `apdex` para obtener una [puntaje de Apdex](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#score) para una sola transacción o para todas sus transacciones. El puntaje <DNT>Apdex</DNT> predeterminada es 0,5 segundos. El [atributo](/docs/insights/new-relic-insights/decorating-events/insights-attributes) puede ser cualquier atributo basado en el tiempo de respuesta, como [`duration`](/docs/insights/insights-data-sources/default-events-attributes/apm-default-event-attributes#txn-duration) o [`backendDuration`](/docs/insights/insights-data-sources/default-events-attributes/browser-default-events-attributes-insights#backend-duration). El argumento `t:` define un umbral [`Apdex T`](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) en la misma unidad de tiempo que el atributo elegido. Por ejemplo, si el atributo se mide en segundos, `t` será un umbral en segundos.

    El puntaje <DNT>Apdex</DNT> devuelta por la función `apdex()` se basa únicamente en el tiempo de ejecución. No tiene en cuenta los errores de APM. Si una transacción incluye un error pero se completa en [Apdex T](/docs/apm/new-relic-apm/getting-started/glossary#apdex_t) o menos, la función `apdex()` calificará esa transacción como [satisfactoria](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#bullet-satisfied).

    <CollapserGroup>
      <Collapser id="apdex-cust-attributes" title="Obtenga Apdex para clientes específicos">
        Si ha [definido un atributo personalizado](/docs/insights/new-relic-insights/decorating-events/insights-custom-attributes), puede filtrar en función de esos atributos. Por ejemplo, podrías monitor el Apdex para clientes particularmente importantes:

        ```sql
        SELECT apdex(duration, t: 0.4) FROM Transaction
        WHERE customerName = 'ReallyImportantCustomer' SINCE 1 day ago
        ```
      </Collapser>

      <Collapser id="apdex-transaction" title="Obtenga Apdex para transacciones específicas">
        Utilice el atributo `name` para devolver una puntuación para una transacción específica o devolver un Apdex general omitiendo `name`. Esta consulta devuelve una puntuación de Apdex para la transacción <DNT>**Controller/notes/index**</DNT> durante la última hora:

        <img title="crop-apdex-function" alt="crop-apdex-function" src="/images/queries-nrql_screenshot-full_apdex-NRQL-query-builder.webp" />

        <figcaption>
          La función `apdex` devuelve una [puntuación de Apdex](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) que mide la satisfacción del usuario con su sitio. Los argumentos son un atributo de tiempo de respuesta y un umbral Apdex T en segundos.
        </figcaption>

        ```sql
        SELECT apdex(duration, t: 0.5) from Transaction
        WHERE name = 'Controller/notes/index' SINCE 1 hour ago
        ```
      </Collapser>

      <Collapser title="Obtenga Apdex general para su aplicación">
        Esta consulta de ejemplo devuelve un Apdex general para la aplicación durante las últimas tres semanas:

        ```sql
        SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-average"
    title={<InlineCode>average(attribute)</InlineCode>
    }
  >
    Utilice la función `average()` para devolver el valor medio de un atributo. Toma un único nombre de atributo como argumento. Si un valor del atributo no es numérico, se ignorará al agregar. Si no se encuentran datos que coincidan con las condiciones de la consulta, o la consulta no devuelve valores numéricos, devolverá un valor nulo.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-bucket-percentile"
    title={<InlineCode>bucketPercentile(attribute)</InlineCode>
    }
  >
    La función `bucketPercentile()` es el equivalente NRQL de la función [`histogram_quantile`](https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile) en Prometheus. Está pensado para ser utilizado con datos dimensionales métricos. En lugar del cuantil, New Relic devuelve el percentil, que es el cuantil \* 100.

    Utilice la función `bucketPercentile()` para calcular el cuantil a partir de los datos del histograma en formato Prometheus.

    Toma el nombre del depósito como argumento e informa el percentil a lo largo de los límites del depósito:

    ```sql
    SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago
    ```

    Opcionalmente, puedes agregar especificaciones percentiles como argumento:

    ```sql
    SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago
    ```

    Debido a que se utilizan múltiples métricas para componer los datos del histograma de Prometheus, debe consultar la métrica de Prometheus específica en términos del `<basename>` asociado.

    Por ejemplo, para calcular el percentil a partir de un histograma de Prometheus, con `<basename>` `prometheus_http_request_duration_seconds` usando NRQL, use `bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)`. Observe cómo se agrega `_bucket` al final de `<basename>` como sufijo.

    Consulte [la documentación de Prometheus.io](https://prometheus.io/docs/concepts/metric_types/#histogram) para obtener más información.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cardinality"
    title={<InlineCode>cardinalidad([métrica, incluir:[`[atributo]`], excluir:[`[atributo]`]])</InlineCode>
    }
  >
    Utilice la función `cardinality()` para obtener el número de combinaciones de todas las dimensiones (atributo) en una [métrica](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics).

    Se necesitan tres argumentos, todos opcionales:

    * Nombre métrica: si está presente, `cardinality()` solo calcula la métrica especificada.
    * Incluir: si está presente, la lista de inclusión restringe el cálculo de cardinalidad a esos atributos.
    * Excluir: si está presente, la lista de exclusión hace que esos atributos sean ignorados en el cálculo de cardinalidad.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cdfPercentage"
    title={<InlineCode>cdfPercentage(attribute, threshold [, threshold [, ...]])</InlineCode>
    }
  >
    `cdfPercentage()` es una implementación de la [función de distribución acumulativa](https://en.wikipedia.org/wiki/Cumulative_distribution_function), que devuelve porcentajes de `attribute` valores cuyo valor es menor o igual a uno o más `thresholds`.

    `cdfPercentage()` se agrega en su argumento `attribute` , que puede ser un atributo numérico o un atributo de métrica de distribución. Se aceptan tipos mixtos en una consulta. Otros tipos (como cadenas) se ignoran. Se pueden especificar hasta 10 umbrales.

    <CollapserGroup>
      <Collapser title="Obtenga el porcentaje de primeras pinturas más rápido que cierto umbral">
        Esta consulta devuelve el porcentaje de evento donde `firstPaint` es menor o igual a 0,5 segundos, y el porcentaje de evento donde `firstPaint` es menor o igual a 1 segundo.

        ```sql
        FROM PageView SELECT cdfPercentage(firstPaint, 0.5, 1.0)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-count"
    title={<InlineCode>count(*)</InlineCode>
    }
  >
    Utilice la función `count()` para devolver un recuento de registros disponibles. Se necesita un solo argumento; ya sea `*`, un atributo o un valor constante. Actualmente, sigue el comportamiento típico de SQL y cuenta todos los registros que tienen valores para su argumento.

    Dado que `count(*)` no nombra un atributo específico, los resultados tendrán el formato predeterminado [&quot;humanizar&quot;](/docs/insights/new-relic-insights/managing-dashboards-data/data-formatter-setting-default-formats-numeric-values#format) .
  </Collapser>

  <Collapser
    className="freq-link"
    id="derivative"
    title={<InlineCode>derivative(attribute [,time interval])</InlineCode>
    }
  >
    `derivative()` encuentra la tasa de cambio para un conjunto de datos determinado. La tasa de cambio se calcula utilizando una regresión lineal de mínimos cuadrados para aproximar la derivada. Dado que este cálculo requiere comparar más de un punto de datos, si solo se incluye un punto de datos en el rango de evaluación, el cálculo es indeterminado y no funcionará, lo que dará como resultado un valor `null` .

    El `time interval` es el período para el cual se calcula la tasa de cambio. Por ejemplo, `derivative(attributeName, 1 minute)` devolverá la tasa de cambio por minuto.
  </Collapser>

  <Collapser
    className="freq-link"
    id="earliest-func"
    title={<InlineCode>earliest(attribute)</InlineCode>
    }
  >
    Utilice la función `earliest()` para devolver el valor más antiguo de un atributo durante el intervalo de tiempo especificado.

    Se necesita un solo argumento.

    Si se emplea junto con un `FACET` , devolverá el valor más antiguo de un atributo para cada una de las facetas resultantes.

    <Callout variant="tip">
      Si varios eventos o métricas comparten la misma timestamp más temprana, el resultado devuelto es aleatorio y puede variar en diferentes ejecuciones de consulta. Para lograr resultados más consistentes, emplee un atributo con diferentes valores para estos eventos o métricas.
    </Callout>

    <CollapserGroup>
      <Collapser title="Obtenga el primer país por agente de usuario de PageView">
        Esta consulta devuelve el código de país más antiguo por cada agente de usuario del evento `PageView` .

        ```sql
        SELECT earliest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-filter"
    title={<InlineCode>filter(function(attribute), WHERE condition)</InlineCode>
    }
  >
    Emplee la función `filter()` para limitar los resultados de una de las funciones de agregador en su declaración `SELECT`. Puede emplear `filter()` junto con `FACET` o `TIMESERIES`. El filtro solo es útil cuando se seleccionan varias agregaciones diferentes, como por ejemplo:

    ```sql
    SELECT filter(sum(x), WHERE attribute = 'a') AS 'A',
      filter(sum(x), WHERE attribute = 'b') AS 'B' ...
    ```

    De lo contrario, es mejor utilizar la cláusula estándar `WHERE` .

    <CollapserGroup>
      <Collapser title="Analizar compras que utilizaron códigos de oferta">
        Podrías usar `filter()` para comparar los artículos comprados en un conjunto de transacciones para aquellos que usan un código de oferta versus aquellos que no lo hacen:

        <img title="screenshot insights filter" alt="screenshot insights filter" src="/images/queries-nrql_screenshot-full_filter-NRQL-query-builder.webp" />

        <figcaption>
          Utilice la función `filter()` para limitar los resultados de una de las funciones de agregador en su declaración `SELECT` .
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-funnel"
    title={<InlineCode>funnel(attribute, steps)</InlineCode>
    }
  >
    Utilice la función `funnel()` para generar un gráfico embudos. Toma un atributo como primer argumento. Luego, especifica los pasos como cláusulas [`WHERE`](#sel-where) (con cláusulas [`AS`](#sel-as) opcionales para las etiquetas) separadas por comas.

    Para obtener detalles y ejemplos, consulte la [documentación de embudos](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/funnels-evaluate-data-series-events).
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-histogram"
    title={<InlineCode>histogram(attribute[, width: n][, buckets: n][, start: n])</InlineCode>
    }
  >
    Emplee la función `histogram()` para generar histograma, que son útiles para visualizar la distribución de un conjunto de datos. Divide el conjunto de datos en una cantidad específica de depósitos y cuenta la cantidad de puntos de datos que se encuentran en cada depósito.

    Argumentos:

    * `attribute` El primer argumento es obligatorio y especifica el atributo para el cual se cuentan los valores que se encuentran dentro de cada rango de depósito de histograma.

    * `width:` Indica el ancho del rango de muestra. El valor máximo del rango es el valor del argumento `start` más este valor `width` .

      * Cuando se emplean argumentos posicionales (sin etiquetas), `width` es el segundo argumento.
      * *Por defecto:* `10`

    * `buckets:` Número total de depósitos (entre `1` y `500`, inclusive).

      * Cuando se emplean argumentos posicionales (sin etiquetas), `buckets` es el tercer argumento.
      * *Por defecto:* `40`

    * `start:` El comienzo del rango del histograma.

      * Cuando se emplean argumentos posicionales (sin etiquetas), `start` es el cuarto argumento.
      * *Por defecto:* `0`

    <Callout variant="tip" title="Nota">
      Los valores que quedan fuera del rango de histograma definido se incluyen en el primer o último segmento. El primer recuento de depósitos incluirá elementos que sean más pequeños que el rango del histograma y el último recuento de depósitos incluirá elementos que sean más grandes que el rango del histograma. Para excluir estos valores de los resultados del histograma, incluya un filtro en la cláusula donde de la consulta. (Ejemplo: `WHERE attribute >= [start] AND attribute <= [start + width]`)
    </Callout>

    <CollapserGroup>
      <Collapser id="histogram-response-times-defaults" title="Histograma de tiempo de respuesta del evento PageView">
        Esta consulta da como resultado un histograma de tiempo de respuesta que varía hasta 10 segundos en 40 periodos. Esto significa que cada segmento cubre un rango de valores de 0,25 segundos. (10/40 = 0,25). Cualquier valor de duración superior a 10 segundos se incluye en el último depósito. Si la duración pudiera ser menor que cero, esos valores se incluirían en el primer grupo.

        ```sql
        SELECT histogram(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-response-times" title="Histograma con un ancho: 5, cubos: 10">
        Estas consultas equivalentes dan como resultado un histograma de tiempo de respuesta que varía hasta 5 segundos en 10 periodos.

        ```sql
        SELECT histogram(duration, 5, 10) FROM PageView SINCE 1 week ago
        ```

        ```sql
        SELECT histogram(duration, width: 5, buckets: 10) FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-response-times-1to4" title="Histograma con ancho: 3, cubos: 3, inicio: 1">
        Estas consultas equivalentes dan como resultado un histograma de tiempo de respuesta que oscila entre 1 y 4 segundos en 3 periodos.

        Aquí hay un desglose de los cubos:

        <table>
          <thead>
            <tr>
              <th />

              <th>
                Cubo 1
              </th>

              <th>
                Cubo 2
              </th>

              <th>
                Cubo 3
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                Gama de cucharones
              </td>

              <td>
                1 a 2
              </td>

              <td>
                2 a 3
              </td>

              <td>
                3 a 4
              </td>
            </tr>

            <tr>
              <td>
                Valores contados
              </td>

              <td>
                &lt; 2
              </td>

              <td>
                ≥ 2 y &lt; 3
              </td>

              <td>
                ≥ 3
              </td>
            </tr>
          </tbody>
        </table>

        ```sql
        SELECT histogram(duration, 3, 3, 1) 
        FROM PageView SINCE 1 week ago
        ```

        ```sql
        SELECT histogram(duration, width: 3, buckets: 3, start: 1) 
        FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-prometheus" title="Cubos de histograma de Prometheus">
        `histogram()` Acepta cubos de histograma Prometheus:

        ```sql
        SELECT histogram(duration_bucket, 10, 20) 
        FROM Metric SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="distribution-metric" title="New Relic distribución métrica">
        `histogram()` acepta [la métrica de distribución](/docs/data-ingest-apis/get-data-new-relic/metric-api/events-metrics-service-create-metrics#limits-rules) como entrada:

        ```sql
        SELECT histogram(myDistributionMetric, 10, 20) 
        FROM Metric SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-facet-heatmap" title="Histograma con una cláusula FACET">
        Utilice `histogram()` con una cláusula `FACET` para generar un gráfico de mapa de calor:

        ```sql
        SELECT histogram(duration) 
        FROM PageView FACET appName SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="keyset"
    title={<InlineCode>keyset()</InlineCode>
    }
  >
    Usar `keyset()` le permitirá ver todos los atributos para un tipo de datos determinado durante un rango de tiempo determinado. No se necesitan argumentos. Devuelve una estructura JSON que contiene grupos de claves escritas en cadenas, claves numéricas, claves booleanas y todas las claves.

    <CollapserGroup>
      <Collapser title="Ver todos los atributos para un tipo de datos">
        Esta consulta devuelve el atributo encontrado para `PageView` evento del último día:

        ```sql
        SELECT keyset() FROM PageView SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latest"
    title={<InlineCode>latest(attribute)</InlineCode>
    }
  >
    Utilice la función `latest()` para devolver el valor más reciente de un atributo durante un rango de tiempo específico.

    Se necesita un solo argumento.

    Si se usa junto con un `FACET` , devolverá el valor más reciente de un atributo para cada una de las facetas resultantes.

    <Callout variant="tip">
      Si varios eventos o métricas tienen la misma timestamp más reciente, el resultado devuelto es aleatorio y puede variar entre ejecuciones de consulta. Para obtener resultados más consistentes, emplee un atributo con diferentes valores para estos eventos o métricas.
    </Callout>

    <CollapserGroup>
      <Collapser title="Obtenga el país más reciente por agente de usuario de PageView">
        Esta consulta devuelve el código de país más reciente por cada agente de usuario del evento `PageView` .

        ```sql
        SELECT latest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latestrate"
    title={<InlineCode>latestrate(attribute, time interval)</InlineCode>
    }
  >
    Utilice la función `latestrate()` para devolver la tasa de cambio de un valor en función de los 2 últimos puntos de datos. Toma el atributo en cuestión como primer argumento y la unidad de tiempo de la tasa resultante como segundo argumento. La función devuelve un resultado en unidades de `change in attribute/time interval`.

    Esta función puede resultar útil para proporcionar la tasa de cambio más reciente de un atributo a fin de ver las tendencias de vanguardia.

    <CollapserGroup>
      <Collapser title="Obtenga la tasa de cambio más reciente de la duración de PageView">
        Esta consulta devuelve la tasa de cambio de duración según los 2 últimos puntos de datos. Se devolverá en unidades de `duration/second` debido al argumento `1 SECOND` .

        ```sql
        SELECT latestrate(duration, 1 SECOND) FROM PageView
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-max"
    title={<InlineCode>max(attribute)</InlineCode>
    }
  >
    Utilice la función `max()` para devolver el valor máximo registrado de un atributo numérico durante el rango de tiempo especificado. Toma un único nombre de atributo como argumento. Si un valor del atributo no es numérico, se ignorará al agregar. Si no se encuentran datos que coincidan con las condiciones de la consulta, o la consulta no devuelve valores numéricos, devolverá un valor nulo.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-median"
    title={<InlineCode>median(attribute)</InlineCode>
    }
  >
    Emplee la función `median()` para devolver la mediana de un atributo o el percentil 50. Para obtener más información sobre percentil consulta, consulte [`percentile()`](#func-percentile).

    <CollapserGroup>
      <Collapser title="Consulta mediana">
        Esta consulta generará un gráfico de líneas para el valor mediano.

        ```sql
        SELECT median(duration) FROM PageView TIMESERIES AUTO
        ```
      </Collapser>
    </CollapserGroup>

    Mediana en una cláusula [`JOIN`](#sel-join) :

    * Dado que la mediana es simplemente un atajo para `percentile(attribute, 50)`, un resultado `median()` de una subconsulta unida es un tipo de datos compuesto, que asigna el percentil 50 a su valor calculado.

      Para hacer referencia al valor mediano real en la consulta externa, puede utilizar la función [`getField()`](#func-getfield) . Tenga en cuenta que la clave asignada es una representación de cadena de un valor doble, por lo que para `median()` es `'50.0'`.

      <CollapserGroup>
        <Collapser title="Consulta mediana unida">
          ```sql
          FROM PageView
          JOIN (FROM PageAction SELECT median(timeSinceLoad) FACET session, currentUrl) ON session
          SELECT latest(getField(median, '50.0')) AS median
          FACET browserTransactionName, currentUrl
          ```

          <img title="screenshot joined median" alt="screenshot joined median" src="/images/nrql_screenshot-crop_example-joined-median.webp" />
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-min"
    title={<InlineCode>min(attribute)</InlineCode>
    }
  >
    Utilice la función `min()` para devolver el valor mínimo registrado de un atributo numérico durante el rango de tiempo especificado. Toma un único nombre de atributo como argumento. Si un valor del atributo no es numérico, se ignorará al agregar. Si no se encuentran datos que coincidan con las condiciones de la consulta, o la consulta no devuelve valores numéricos, devolverá un valor nulo.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentage"
    title={<InlineCode>percentage(function(attribute), WHERE condition)</InlineCode>
    }
  >
    Utilice la función `percentage()` para devolver el porcentaje de un conjunto de datos objetivo que coincide con alguna condición.

    Esta función espera exactamente dos argumentos (los argumentos luego de los dos primeros se ignoran). El primer argumento requiere una [función agregadora](#functions) contra el atributo deseado. Si el atributo no es numérico, esta función devuelve un valor de 100%. El segundo argumento requiere una cláusula `WHERE` .

    ```sql
    FROM Transaction 
    SELECT percentage(count(*), WHERE error is true ) AS 'Error Percent' 
    WHERE host LIKE '%west%' EXTRAPOLATE
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentile"
    title={<InlineCode>percentile(attribute [, percentile [, ...]])</InlineCode>
    }
  >
    Utilice la función `percentile()` para devolver el valor aproximado de un atributo en un percentil determinado. Requiere un atributo y puede tomar cualquier número de argumentos que representen puntos percentiles. La función `percentile()` permite que el percentil se muestre con hasta tres dígitos después del punto decimal, lo que proporciona mayor precisión. El umbral de percentil se puede especificar como valores decimales, pero tenga en cuenta que, para la mayoría de los conjuntos de datos, no se resolverán los percentiles más cercanos a 0,1 entre sí.

    <img title="percentile.png" alt="percentile.png" src="/images/queries-nrql_screenshot-full_percentile-NRQL-query-builder.webp" />

    <figcaption>
      Ejemplos de visualización de percentiles
    </figcaption>

    Utilice `TIMESERIES` para generar un gráfico de líneas con percentiles asignados a lo largo del tiempo.

    * Omita `TIMESERIES` para generar un cartel y una hoja de atributos que muestre los valores agregados para el percentil.

      Si no aparece ningún percentil, el valor predeterminado es el percentil 95. Para devolver solo el valor del percentil 50, la mediana, también puede emplear [`median()`](#func-median).

      <CollapserGroup>
        <Collapser title="Consulta basica de percentil">
          Esta consulta generará un gráfico de líneas con líneas para los percentil 5, 50 y 95.

          ```sql
          SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO
          ```
        </Collapser>
      </CollapserGroup>

    percentil en una cláusula [`JOIN`](#sel-join) :

    * Cuando utilice percentil en una subconsulta unida, tenga en cuenta que los resultados de la subconsulta son un tipo de datos compuesto, que asigna cada percentil a su valor calculado.

      Para hacer referencia a cualquiera de los valores de percentil individuales en la consulta externa, puede emplear la función [`getField()`](#func-getfield). Tenga en cuenta que la clave asignada es una representación de cadena de un valor doble, por lo que debe sumar `.0` a los números enteros. Por ejemplo, la clave para el percentil 95 es `'95.0'`.

      <CollapserGroup>
        <Collapser title="Se unió a percentil consulta">
          ```sql
          FROM PageView
          JOIN 
          (
            FROM PageAction 
            SELECT percentile(timeSinceLoad, 95, 99.5) AS pctl
            FACET session, currentUrl
          ) 
          ON session
          SELECT latest(getField(pctl, '95.0')) AS `95th`, 
            latest(getField(pctl, '99.5')) AS `99.5th`
          FACET browserTransactionName, currentUrl
          ```

          <img title="screenshot joined percentile" alt="screenshot joined percentile" src="/images/nrql_screenshot-crop_example-joined-percentile.webp" />
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="predictLinear"
    title={<InlineCode>predictLinear(attribute, [,time interval])</InlineCode>
    }
  >
    `predictLinear()` es una extensión de la función `derivative()` . Utiliza un método similar de regresión lineal de mínimos cuadrados para predecir los valores futuros de un conjunto de datos.

    * El `time interval` es hasta dónde se verá la consulta en el futuro. Por ejemplo, `predictLinear(attributeName, 1 hour)` es una predicción lineal 1 hora en el futuro de la ventana de tiempo de consulta.
    * Generalmente, `predictLinear()` es útil para valores en continuo crecimiento, como el espacio en disco o predicciones sobre grandes tendencias.
    * Dado que `predictLinear()` es una regresión lineal, estar familiarizado con el conjunto de datos que se consulta ayuda a garantizar predicciones precisas a largo plazo.
    * Cualquier conjunto de datos que crezca exponencial, logarítmicamente o por otros medios no lineales probablemente sólo tendrá éxito en predicciones a muy corto plazo.
    * New Relic recomienda no usar `predictLinear` en `TIMESERIES` consulta. Esto se debe a que cada segmento hará una predicción individual basada en su período de tiempo relativo dentro de la consulta, lo que significa que dicha consulta no mostrará predicciones desde el final de la serie de tiempo en adelante.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-rate"
    title={<InlineCode>rate(function(attribute) [,time interval])</InlineCode>
    }
  >
    Utilice la función `rate()` para visualizar la frecuencia o tasa de una consulta determinada por intervalo de tiempo. Por ejemplo, es posible que desee saber la cantidad de páginas vistas por minuto durante un período de una hora o el recuento de sesiones únicas en su sitio por hora durante un período de un día.

    * Utilice [`TIMESERIES`](#sel-timeseries) para generar un gráfico de líneas con tarifas asignadas a lo largo del tiempo.

    * Omita [`TIMESERIES`](#sel-timeseries) para generar un cartel que muestre un valor de tarifa único promediado a lo largo del tiempo.

      Aquí hay una consulta básica que generará un gráfico de líneas que muestra la tasa de rendimiento de la transacción APM por 10 minutos durante las últimas 6 horas:

      ```sql
      SELECT rate(count(*), 10 minute) FROM Transaction 
      SINCE 6 hours ago TIMESERIES
      ```

      A continuación se muestra un vídeo breve (3:21 minutos) que explica cómo utilizar `rate` para comparar datos en diferentes períodos de tiempo:

      <Video id="9UArmB4QiVM" type="youtube" />
  </Collapser>

  <Collapser
    className="freq-link"
    id="stdvar"
    title={<InlineCode>stdvar(attribute)</InlineCode>
    }
  >
    Utilice la función `stdvar()` para devolver la [variación estándar](https://en.wikipedia.org/wiki/Variance) de un atributo numérico durante el rango de tiempo especificado.

    Se necesita un solo argumento. Si el atributo no es numérico, devolverá un valor de cero.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-sum"
    title={<InlineCode>sum(attribute)</InlineCode>
    }
  >
    Utilice la función `sum()` para devolver la suma de los valores registrados de un atributo numérico durante el rango de tiempo especificado.

    Se necesita un solo argumento. Si el atributo no es numérico, devolverá un valor de cero.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniqueCount"
    title={<InlineCode>uniqueCount(attribute, [, attribute [, ...]] [, precision: number])</InlineCode>
    }
  >
    Emplee la función `uniqueCount()` para obtener la cantidad de valor único registrado para un atributo durante un rango de tiempo específico. Para contar las combinaciones únicas de múltiples valores de atributos, especifique esos atributos con la función. Puede incluir hasta 32 atributos. Esta función proporciona un resultado exacto de hasta 256 valor único cuando la llama sin el argumento `precision`. Para más de 256 valor único, el resultado es aproximado. Puede especificar un valor `precision` dentro del rango de 256 a 50 000 para aumentar el umbral para obtener resultados exactos. Cuando el valor único excede el umbral establecido, la función emplea la [estructura de datos probabilística HyperLogLog](https://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf) para proporcionar un resultado aproximado.

    <Callout variant="tip" title="Nota">
      **Cómo funciona el conteo exacto con menos de 256 valores**: al contar menos de 256 valores de cadena únicos, `uniqueCount()` emplea un método de conteo basado en hash para determinar la unicidad. Este método genera un código hash entero de 32 bits a partir de los caracteres de cada cadena. Si bien este enfoque distribuye eficientemente los valores hash para la mayoría de las cadenas, ocasionalmente pueden ocurrir colisiones hash, lo que significa que dos cadenas diferentes pueden generar el mismo código hash. Es más probable que esto suceda cuando contamos cadenas que son extremadamente similares entre sí. En los raros casos en los que ocurre una colisión hash, la función puede subestimar ligeramente el número real de valor único.
    </Callout>

    Emplee la función `uniqueCount()` especificando el atributo y, opcionalmente, establezca el argumento de precisión de la siguiente manera:

    ```sql
    uniqueCount(attribute, [, attribute [, ...]] [, precision: number])
    ```

    * **Atributo(s)**: especifique un atributo para el cual desea contar valor único, o especifique múltiples atributos para contar combinaciones únicas de valores. Puede especificar hasta 32 atributos.
    * **Precisión**: especifica un número que establece el umbral para obtener resultados exactos. Puede establecer un valor de hasta 50.000.

    Ejemplo de consulta sin un argumento `precision` :

    ```sql
    SELECT uniqueCount(accountId) FROM Transaction SINCE 1 day ago
    ```

    Ejemplo de consulta con un argumento `precision` :

    ```sql
    SELECT uniqueCount(appName, name, clusterName, precision: 1000) FROM Transaction SINCE 1 day ago
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniques"
    title={<><InlineCode>
      uniques(attribute [,limit]
    </InlineCode><InlineCode>
      )
    </InlineCode></>
    }
  >
    Utilice la función `uniques()` para devolver una lista de valor único registrado para un atributo durante el rango de tiempo especificado. Cuando se usa junto con la cláusula `facet` , se devolverá una lista de valores de atributos únicos por cada valor de faceta.

    El parámetro `limit` es opcional. Cuando no se proporciona, se aplica el límite predeterminado de 1000 valores de atributos únicos por faceta. Puede especificar un valor `limit` diferente, hasta un máximo de 10 000. La función `uniques()` devolverá el primer conjunto de valores de atributos únicos descubiertos, hasta alcanzar el límite. Por lo tanto, si tiene 5000 valores de atributos únicos en su conjunto de datos y el límite está establecido en 1000, el operador devolverá los primeros 1000 valores únicos que descubra, independientemente de su frecuencia.

    El número máximo de valores que se pueden devolver en el resultado de una consulta es el producto del límite `uniques()` por el límite `facet` . En la siguiente consulta, el número máximo teórico de valores que se pueden devolver es 5 millones (5000 x 1000).

    Dependiendo del conjunto de datos que se consulte y de la complejidad de la consulta, los límites de protección de la memoria pueden impedir que se ejecute una consulta muy grande.

    ```sql
    From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000
    ```

    <CollapserGroup>
      <Collapser
        title={<>Usando <InlineCode>
          tuple
        </InlineCode></>
        }
      >
        Si desea conocer las combinaciones únicas de un puñado de atributos, puede estructurar una consulta en el formato `SELECT uniques(tuple(x, y, ... z)) ...` para obtener todas las tuplas únicas de valores, para mantener su relación. En la siguiente consulta, `tuple` se utiliza en `index` y `cellName` juntos para encontrar valores únicos donde esos dos valores aparecen en combinación.

        ```sql
        FROM NodeStatus SELECT uniques(tuple(index, cellName), 5)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### Funciones no agregadoras [#non-aggregator-functions]

Emplee funciones no agregadoras para devolver valores para cada punto de datos dentro de NRQL consulta.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="acct-type"
    title={<InlineCode>accountId()</InlineCode>
    }
  >
    Utilice la función `accountId()` para devolver el [ID de cuenta](/docs/accounts/accounts-billing/account-structure/account-id) asociado con los datos de la consulta. Esta función no acepta argumentos. A continuación se muestran algunos ejemplos de consultas:

    <CollapserGroup>
      <Collapser title="Obtenga el ID de cuenta para cada evento de transacción">
        Esta consulta devuelve el ID de cuenta asociado con cada evento `Transaction` devuelto:

        ```sql
        SELECT accountId() FROM Transaction SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="Obtenga el recuento de eventos de transacción para cada cuenta.">
        Esta consulta devuelve el número de `Transaction` eventos del último día asociados con cada ID de cuenta:

        ```sql
        SELECT count(*) FROM Transaction FACET accountId() SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="Obtenga el recuento de eventos de transacción para cada cuenta especificada en la cláusula WHERE">
        Esta consulta devuelve el número de `Transaction` evento del último día donde el ID de cuenta es específicamente uno de `1`, `2` o `3`:

        ```sql
        SELECT count(*) FROM Transaction WHERE accountId() IN (1,2,3) SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-aparse"
    title={<><InlineCode>
      aparse(attribute, pattern)
    </InlineCode></>
    }
  >
    Utilice la función de análisis de anclaje, `aparse()` para extraer valores específicos de una cadena. Esta es una alternativa a `capture()`.

    `aparse()` toma dos argumentos:

    * Un atributo de cadena
    * Una cadena de patrón con cadenas de anclaje y caracteres de extracción. Por ejemplo, podría utilizar `www.*.com` para extraer el dominio de una URL.

    Cuando se utiliza `aparse()`, la cadena de patrón debe contener anclajes, como `www.` y `.com` arriba, para identificar la ubicación de la cadena extraída deseada, indicada por `*`.

    `aparse()` utiliza los siguientes caracteres en cadenas de patrones:

    * `%`: comodín que no captura, como se ve en la cláusula `LIKE`
    * `*`: Captura de comodines, similar al uso de captura de expresiones regulares

    En la práctica, las cadenas de anclaje suelen aparecer en medio de un atributo de cadena, y no al principio ni al final.

    En este caso, utilice el comodín `%` para ignorar valores no deseados: por ejemplo, `%www.*.com%`.

    Al igual que `capture()`, todos los resultados de `aparse()` son cadenas. Para utilizar estos resultados en funciones matemáticas, deben convertirlos con la función `numeric()` .

    Nota: `aparse()` no distingue entre mayúsculas y minúsculas.

    <CollapserGroup>
      <Collapser title="Uso básico" id="aparse-basic" className="freq-link">
        ```sql
        FROM PageView
        SELECT aparse(browserTransactionName, 'website.com/*')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>
          aparse()
        </InlineCode> valores específicos</>
        }
        id="aparse-specific-values"
        className="freq-link"
      >
        Para extraer un valor del medio de una cadena, utilice el comodín que no captura, `%`, al principio y al final de la cadena del patrón. Por ejemplo:

        ```sql
        FROM Log
        SELECT count(*)
        FACET aparse(string, '%"itemId":"*"%')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>
          aparse()
        </InlineCode> múltiples valores</>
        }
        id="aparse-multiple-values"
        className="freq-link"
      >
        Al extraer varios valores como variables, tenga en cuenta que el orden es importante. Por ejemplo:

        ```sql
        FROM Log
        WITH aparse(string, 'POST: * body: {"itemId":"*","unitPrice":*}\n') AS (url, itemId, unitPrice)
        SELECT url, itemId, unitPrice
        ```

        Para obtener más información sobre las variables, consulte [Variables NRQL](#with-as-nrql-var).
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-blob"
    title={<InlineCode>blob(attribute)</InlineCode>
    }
  >
    Utilice la función `blob()` en un atributo de tipo blob para devolver una cadena codificada en base 64 de ese atributo.

    Esta función tiene las siguientes restricciones:

    * La consulta que contiene llamadas a `blob()` tiene un valor máximo de `LIMIT` de 20

    * `blob()` no se puede llamar en la cláusula `WHERE` de una consulta

    * `blob()` no se puede utilizar en consulta facetada o consulta de series temporales

      Para obtener más información sobre cómo se usa esto en el registro, consulte [Buscar datos en registros largos (blobs)](/docs/logs/log-management/ui-data/long-logs-blobs).

      Para decodificar un blob codificado en base 64, consulte la [función`decode()` ](#func-decode).

      <CollapserGroup>
        <Collapser
          title={<>Usando <InlineCode>
            blob()
          </InlineCode> en el registro extendido</>
          }
        >
          ```sql
          SELECT message, blob(`newrelic.ext.message`) 
          FROM Log WHERE newrelic.ext.message IS NOT NULL
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-buckets"
    title={<InlineCode>buckets(attribute, ceiling [,number of buckets])</InlineCode>
    }
  >
    Utilice la función `buckets()` para agregar datos divididos por una cláusula `FACET` en depósitos basados en rangos. Puede agrupar por cualquier atributo que esté almacenado como un valor numérico en la base de datos de New Relic.

    Se necesitan tres argumentos:

    * Nombre del atributo

    * Valor máximo del rango de muestra (cualquier valor atípico aparecerá en el grupo final)

    * Número total de cubos

      Para obtener más información y ejemplos, consulte [Divida sus datos en depósitos](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/segment-your-insights-data-buckets).
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-concat"
    title={<InlineCode>concat(atributo, [, atributo [, ...]] [, precisión: ]))</InlineCode>
    }
  >
    Utilice la función `concat()` para devolver la cadena resultante de concatenar sus argumentos.

    Se pueden proporcionar hasta 20 argumentos de tipo numérico, booleano, tupla o matriz. Se ignoran los argumentos nulos y los argumentos de tipos no admitidos. Si no se proporcionan argumentos, el resultado es una cadena vacía.

    Se puede proporcionar el argumento de precisión opcional para limitar el número de decimales incluidos al concatenar valores numéricos de punto flotante.

    La cadena resultante puede tener una longitud máxima de 4096 caracteres.

    <CollapserGroup>
      <Collapser title="Obtenga múltiples valores de duración de `PageView` como una cadena formateada">
        Esta consulta devuelve duraciones de backend y de red del evento `PageView` , formateadas con dos decimales y etiquetas, como una sola cadena.

        ```sql
        FROM PageView 
        SELECT concat('Backend Duration: ', backendDuration, ', Network Duration: ', networkDuration, precision: 2)
        ```

        Esto devolvería respuestas en un formato como:

        `Backend Duration: 0.69, Network Duration: 0`
      </Collapser>

      <Collapser title="Resultados de la consulta de facetas mediante una cadena formateada">
        Esta consulta devuelve la duración promedio de la configuración de la conexión desde el evento `PageView` , dividida por una cadena compuesta por la ciudad, la región y el país del usuario.

        ```sql
        FROM PageView SELECT average(connectionSetupDuration) 
        FACET concat(city, ', ', regionCode, ' ', countryCode) 
        WHERE countryCode IN ('US', 'CA')
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-convert"
    title={<InlineCode>convert(attribute, fromUnits, toUnits)</InlineCode>
    }
  >
    Utilice la función `convert()` para realizar la conversión de unidades entre las unidades proporcionadas en el valor de entrada dado.

    Las unidades comunes y abreviaturas de tiempo, longitud, peso, volumen y datos se admiten mediante los [estándares UCUM](https://ucum.org/ucum) para alinearse con las especificaciones de OpenTelemetry. Para mayor comodidad, las abreviaturas estandarizadas se complementan con algunas alternativas de lenguaje natural como `ft` además de `ft_us`, `kilobytes` y `µs`.

    Las unidades *distinguen entre* mayúsculas y minúsculas. Todas las unidades están en minúsculas, a menos que su especificación requiera que estén en mayúsculas. Por ejemplo, las unidades de datos `'bits'` son válidas para bits y `'By'` debe tener una `B` mayúscula para bytes.

    La unidad de tiempo más grande es el juliano `year`, que siempre es 365,25 días.

    <CollapserGroup>
      <Collapser title="Convertir un atributo de milisegundos a minutos">
        ```sql
        FROM Transaction SELECT convert(duration, 'ms', 'min') AS durationMin
        ```
      </Collapser>

      <Collapser title="Convertir la suma de pesos de gramos a libras.">
        ```sql
        FROM Product SELECT convert(sum(itemWeight), 'grams', 'lbs')
        ```
      </Collapser>

      <Collapser title="Convertir entre la unidad de tiempo almacenada y segundos">
        Esta consulta supone que tiene la información de la unidad almacenada como un atributo de cadena en el evento mismo y que desea estandarizar los valores a segundos.

        ```sql
        FROM Metric 
        SELECT average(convert(apm.mobile.external.duration, unit, 's')) 
        WHERE appName = 'my-application'
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-capture"
    title={<InlineCode>capture(attribute, regular expression)</InlineCode>
    }
  >
    Utilice `capture()` para extraer valores de un atributo mediante una expresión regular con [sintaxis RE2](https://github.com/google/re2/wiki/Syntax).

    Se necesitan dos argumentos:

    * Nombre del atributo

    * Expresión regular con sintaxis de captura (las expresiones regulares en NRQL usan una sintaxis similar a Python, `r'...'`)

      Al capturar, utilice la sintaxis de captura con nombre RE2 `...(?P<name> pattern )...` para capturar el patrón contenido, dado el nombre especificado.

      Se pueden capturar varios valores especificando grupos de captura adicionales en una expresión regular. Por ejemplo: `...(?P<name1> pattern1)...(?P<name2> pattern2)...`

      Nota: Al capturar varios valores, cada declaración de captura puede tener hasta 16 grupos de captura y cada consulta NRQL puede tener hasta 5 declaraciones de captura.

      Lea cómo [utilizar la captura de expresiones regulares para mejorar los resultados de su consulta](https://newrelic.com/blog/how-to-relic/using-regex-capture).

      <Callout variant="tip">
        La expresión regular debe coincidir con toda su entrada. Si una expresión de captura no extrae los resultados esperados, verifique si necesita `.*` al principio o al final, que es el patrón para una expresión regular de coincidencia parcial. Sin embargo, la expresión regular de coincidencia parcial puede provocar una ejecución de consulta lenta.
      </Callout>

      A continuación se muestra un vídeo breve (3:05 minutos) que muestra cómo utilizar `capture()` para mejorar la legibilidad dashboard :

      <Video id="hOPrTWYgPHg" type="youtube" />

      Para obtener más información, consulte los ejemplos siguientes:

      <CollapserGroup>
        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> dentro de una condición de cláusula <InlineCode>
            SELECT
          </InlineCode></>
          }
        >
          Lo siguiente seleccionará el nombre de dominio del sitio web, eliminando `https://` y cualquier ruta que siga el `.com`

          ```sql
          SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') 
          FROM PageView SINCE 1 day ago
          ```

          Lo siguiente capturará solo la primera palabra del mensaje de error.

          ```sql
          SELECT capture(errorMessage, r'(?P<firstWord>\S+)\s.+') 
          FROM Transaction 
          WHERE errorMessage IS NOT NULL
          SINCE 1 hour ago 
          ```
        </Collapser>

        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> dentro de una condición de cláusula <InlineCode>
            FACET
          </InlineCode></>
          }
        >
          Lo siguiente se facetará mediante el método HTTP capturado.

          ```sql
          SELECT count(*) FROM Log 
          WHERE message LIKE '%HTTP%' 
          FACET capture(message, r'.* "(?P<httpMethod>[A-Z]+) .*')
          ```
        </Collapser>

        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> dentro de una condición de cláusula <InlineCode>
            WHERE
          </InlineCode></>
          }
        >
          Lo siguiente filtrará los resultados según el registro de evento con el atributo `message` que coincide con la expresión regular donde el nombre del trabajo capturado es `ExampleJob`.

          ```sql
          SELECT message FROM Log 
          WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' 
          SINCE 10 minutes ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> con un reparto numérico</>
          }
        >
          Lo siguiente capturará la suma del tiempo de CPU de las líneas log . Debe convertir explícitamente a numérico para realizar operaciones matemáticas.

          ```sql
          SELECT sum(numeric(capture(message, r'.*CpuTime:\s(?P<cpuTime>\d+)'))) 
          FROM Log 
          WHERE message LIKE '%CpuTime:%' SINCE 1 hour ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> múltiples valores con variables NRQL</>
          }
        >
          En este ejemplo, las variables NRQL se utilizan para almacenar múltiples valores capturados de un mensaje de registro.

          ```sql
          FROM Log
          WITH capture(message, r'POST to carts: (?P<URL>.*) body: {"itemId":"(?P<UUID>.*)","unitPrice":(?P<unitPrice>.*)}.*')
            AS (URL, UUID, unitPrice)
          SELECT URL, UUID, unitPrice
          WHERE URL IS NOT NULL
          ```

          Vea más sobre las variables NRQL [aquí](#with-as-nrql-var).
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-decode"
    title={<InlineCode>decode(input, encoding)</InlineCode>
    }
  >
    Utilice `decode()` para realizar conversiones base 64 en cadenas y blobs. El valor de entrada (el primer argumento) se decodificará utilizando el estándar base-64 especificado por la codificación (el segundo argumento).

    Se admiten los siguientes valores de cadena en el parámetro de codificación:

    * &apos;base64&apos;: utiliza el [estándar RFC4648 base-64](https://datatracker.ietf.org/doc/html/rfc4648#section-4)

    * &apos;base64mime&apos;: Utiliza el [estándar RFC2045 base-64 (MIME)](https://datatracker.ietf.org/doc/html/rfc2045)

    * &apos;base64url&apos;: utiliza el [estándar RFC4648 base-64 con URL y alfabeto seguro para nombres de archivos](https://datatracker.ietf.org/doc/html/rfc4648#section-5)

      Como `blob()` no está permitido en las cláusulas `WHERE` o `FACET` , `decode()` con tipos de blob no se admite en la cláusula `WHERE` ni para consultas facetadas.

      Para codificar cadenas, consulte la [función`encode()` ](#func-encode).

      <CollapserGroup>
        <Collapser
          title={<>Usando <InlineCode>
            decode()
          </InlineCode> en un atributo de cadena</>
          }
        >
          ```sql
          FROM Span SELECT entity.guid, decode(entity.guid, 'base64') 
          WHERE entity.guid IS NOT NULL
          ```
        </Collapser>

        <Collapser
          title={<>Usando <InlineCode>
            decode()
          </InlineCode> en un <InlineCode>
            FACET
          </InlineCode></>
          }
        >
          ```sql
          FROM Span SELECT count(*) 
          WHERE entity.guid IS NOT NULL 
          FACET entity.guid, decode(entity.guid, 'base64')
          ```
        </Collapser>

        <Collapser
          title={<>Usar <InlineCode>
            decode()
          </InlineCode> en una cláusula <InlineCode>
            WHERE
          </InlineCode></>
          }
        >
          ```sql
          FROM Span SELECT count(*) 
          WHERE entity.guid IS NOT NULL 
          AND decode(entity.guid, 'base64') NOT LIKE '%APM%'
          ```
        </Collapser>

        <Collapser
          title={<>Usar <InlineCode>
            decode()
          </InlineCode> con un atributo de tipo blob</>
          }
        >
          ```sql
          FROM Log
          WITH blob(`newrelic.ext.message`) AS encodedBlob,
          decode(encodedBlob, 'base64') AS decodedBlob
          SELECT encodedBlob, decodedBlob
          WHERE newrelic.ext.message IS NOT NULL
          LIMIT 10
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-dimensions"
    title={<InlineCode>[`dimensiones(incluyen: [atributo], excluyen: [atributo])`]</InlineCode>
    }
  >
    Utilice la función `dimensions()` para devolver todos los valores dimensionales de un tipo de datos.

    Puede incluir o excluir explícitamente un atributo específico utilizando los argumentos opcionales:

    * `include`: si está presente, la lista de inclusión limita `dimensions()` a esos atributos.

    * `exclude`: si está presente, el cálculo `dimensions()` ignora esos atributos.

      ```sql
      FROM Metric SELECT count(node_filesystem_size) 
      TIMESERIES FACET dimensions()
      ```

      Cuando se usa con una cláusula `FACET` , `dimensions()` produce una serie de tiempo única para todas las facetas disponibles en el tipo de evento, similar a cómo se comporta Prometheus con consultas no agregadas.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-encode"
    title={<InlineCode>encode(input, encoding)</InlineCode>
    }
  >
    Utilice `encode()` para realizar conversiones base 64 en cadenas. El valor de entrada (el primer argumento) se codificará utilizando el estándar base-64 especificado por la codificación (el segundo argumento).

    Se admiten los siguientes valores de cadena en el parámetro de codificación:

    * &apos;base64&apos;: utiliza el [estándar RFC4648 base-64](https://datatracker.ietf.org/doc/html/rfc4648#section-4)

    * &apos;base64mime&apos;: Utiliza el [estándar RFC2045 base-64 (MIME)](https://datatracker.ietf.org/doc/html/rfc2045)

    * &apos;base64url&apos;: utiliza el [estándar RFC4648 base-64 con URL y alfabeto seguro para nombres de archivos](https://datatracker.ietf.org/doc/html/rfc4648#section-5)

      Para decodificar cadenas o blobs, consulte la [función`decode()` ](#func-decode). `encode()` no es compatible con blobs.

      <CollapserGroup>
        <Collapser
          title={<>Usar <InlineCode>
            encode()
          </InlineCode> en un atributo</>
          }
        >
          ```sql
          FROM PageView SELECT session, encode(session, 'base64')
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cidraddress"
    title={<InlineCode>cidrAddress(attribute [, number [, cidrFormat])</InlineCode>
    }
  >
    Utilice la función `cidrAddress()` para obtener la dirección de red base de una dirección IP CIDR.

    `cidrAddress()` toma los siguientes argumentos:

    * `attribute` - Un valor de cadena que contiene una dirección IP sola o con una longitud de prefijo en notación CIDR.

      * Puede ser un atributo de cadena o un literal de cadena entre comillas.
      * La dirección IP debe ser una dirección IPv4.

    * `number` - Un valor entero que representa la longitud del prefijo.

      * Puede ser un atributo entero o un valor entero.
      * Si el parámetro de atributo está en notación CIDR, este parámetro es opcional y tiene prioridad sobre la longitud del prefijo proporcionada en la cadena CIDR.

    * `cidrFormat` - Un valor booleano opcional que se emplea para determinar si la salida de la dirección de red debe formatear en notación CIDR. Este valor predeterminado será verdadero.

      La función `cidrAddress()` devolverá un valor siempre que el atributo y el parámetro number contengan una dirección IP válida y una longitud de prefijo. Si la entrada del parámetro no es válida, `cidrAddress()` devolverá `null`.

      <CollapserGroup>
        <Collapser title="Encuentre qué subredes están procesando la mayor cantidad de solicitudes">
          La siguiente consulta devuelve las subredes que procesan la mayoría de las solicitudes del tipo de evento [SyntheticRequest](/attribute-dictionary/?event=SyntheticRequest) .

          ```sql
          FROM SyntheticRequest SELECT count(*) FACET cidrAddress(serverIPAddress, 24)
          ```

          Esto devolvería respuestas en un formato como:

          <table>
            <thead>
              <tr>
                <th>
                  Dirección Cidr de la dirección IP del servidor
                </th>

                <th>
                  Contar
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  10.0.0.0/24
                </td>

                <td>
                  6k
                </td>
              </tr>

              <tr>
                <td>
                  10.10.1.0/24
                </td>

                <td>
                  4k
                </td>
              </tr>

              <tr>
                <td>
                  10.0.14.0/24
                </td>

                <td>
                  1k
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser title="Consultar todas las direcciones IP que existen en un rango CIDR">
          Esta consulta devuelve todas las direcciones IP en el atributo [`serverIPAddress`](/attribute-dictionary/?event=SyntheticRequest&attribute=serverIPAddress) que existen dentro del rango CIDR de 10.0.0.0 a 10.0.0.255.

          ```sql
          FROM SyntheticRequest SELECT uniques(serverIPAddress) 
          WHERE cidrAddress(serverIPAddress, 24) = '10.0.0.0/24'
          ```
        </Collapser>

        <Collapser title="Filtrar direcciones IP que existen en un rango CIDR específico a partir de los resultados de la consulta">
          Esta consulta devuelve un recuento de todos los registros y excluye los registros que contienen un valor [`serverIPAddress`](/attribute-dictionary/?event=SyntheticRequest&attribute=serverIPAddress) que se encuentra dentro del rango CIDR de 10.0.0.0/24 o 10.10.1.0/24.

          ```sql
          FROM SyntheticRequest SELECT count(*) 
          WHERE cidrAddress(serverIPAddress, 24) NOT IN ('10.0.0.0/24', '10.10.1.0/24')
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="event-type"
    title={<InlineCode>eventType()</InlineCode>
    }
  >
    ```sql
    ...WHERE eventType() = 'EventNameHere'...
    ...FACET eventType()...
    ```

    Emplee la función `eventType()` en una cláusula [`FACET`](#sel-facet) para desglosar los resultados por el tipo de datos seleccionado o en una cláusula [`WHERE`](#sel-where) para filtrar los resultados según un tipo de datos específico. Esto es particularmente útil para apuntar a tipos de datos específicos con las funciones [`filter()`](#func-filter) y [`percentage()`](#func-percentage) .

    <Callout variant="important">
      En este contexto, &quot;tipo de evento&quot; se refiere a los tipos de datos a los que puede acceder con una consulta NRQL.
    </Callout>

    <CollapserGroup>
      <Collapser
        id="filter-eventtype"
        title={<>Utilice <InlineCode>
          eventType()
        </InlineCode> en la función <InlineCode>
          filter()
        </InlineCode></>
        }
      >
        Esta consulta devuelve el porcentaje del total de `TransactionError` resultados del total `Transaction` resultados. Puede utilizar la función `eventType()` para orientar tipos de datos específicos con la función `filter()` .

        ```sql
        SELECT 100 * filter(count(*), WHERE eventType() = 'TransactionError') / filter(count(*), WHERE eventType() = 'Transaction') 
        FROM Transaction, TransactionError 
        WHERE appName = 'App.Prod' 
        TIMESERIES 2 Minutes SINCE 6 hours ago
        ```
      </Collapser>

      <Collapser
        id="facet-eventtype"
        title={<>Utilice <InlineCode>
          eventType()
        </InlineCode> con <InlineCode>
          FACET
        </InlineCode></>
        }
      >
        Esta consulta muestra un recuento de cuántos registros devuelve cada tipo de datos (`Transaction` y `TransactionError`).

        ```sql
        SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getfield"
    title={<InlineCode>getField(attribute, field)</InlineCode>
    }
  >
    Emplee la función `getField()` para extraer un elemento de una matriz o un campo de tipos de datos compuestos, como [datos métricos dimensionales](/docs/data-apis/understand-data/metric-data/metric-data-type).

    `getField()` toma los siguientes argumentos:

    * `attribute` - Una matriz o un tipo de datos compuesto.
    * `field` - El índice del elemento de la matriz o el nombre del campo del tipo de datos compuesto.

    También puedes emplear corchetes `[ ]` como abreviatura de `getField()`.

    <CollapserGroup>
      <Collapser title="Extraer un elemento de una matriz">
        <Callout variant="important">
          La indexación matricial comienza con `0`.
        </Callout>

        **Ejemplos**\
        Considere la matriz `[100, 110, 90, 100, 105]` almacenada en el atributo `durations`. La siguiente consulta devolverá `90`:

        ```sql
        SELECT getField(durations, 2) FROM Foo
        ```

        La siguiente consulta que emplea la notación abreviada `getField()` también devolverá `90`:

        ```sql
        SELECT durations[2] FROM Foo
        ```
      </Collapser>

      <Collapser title="Extraer un campo de un tipo de datos compuesto">
        Los tipos de datos compuestos admitidos y sus campos son:

        <table>
          <thead>
            <tr>
              <th style={{ width: "500px" }}>
                Tipo de métrica
              </th>

              <th>
                Campos admitidos
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `summary`
              </td>

              <td>
                `count`, `total`, `max`, `min`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `gauge`
              </td>

              <td>
                `count`, `total`, `max`, `min`, `latest`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `distribution`
              </td>

              <td>
                `count`, `total`, `max`, `min`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `count`
              </td>

              <td>
                `count`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `cumulativeCount`
              </td>

              <td>
                `count`, `cumulative`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `timeslice`
              </td>

              <td>
                `count`, `total`, `totalExclusive`, `min`, `max`, `sumOfSquares`
              </td>
            </tr>
          </tbody>
        </table>

        **Ejemplos**

        ```sql
        SELECT max(getField(mySummary, count)) FROM Metric
        ```

        ```sql
        SELECT sum(mySummary) FROM Metric where getField(mySummary, count) > 10
        ```

        consulta empleando la notación abreviada para `getField()`:

        ```sql
        SELECT max(mySummary[count]) FROM Metric
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getCdfCount"
    title={<InlineCode>getCdfCount(attribute, threshold)</InlineCode>
    }
  >
    `getCdfCount()` es una implementación de la [función de distribución acumulativa](https://en.wikipedia.org/wiki/Cumulative_distribution_function), que devuelve el número de valores en `attribute` en `threshold` o menos.

    Sólo se permite un umbral. `Attribute` puede ser un atributo numérico o un atributo de métrica de distribución. Se aceptan tipos mixtos en una consulta.

    Para un tipo numérico, devuelve 1 si el atributo es menor o igual que el umbral; de lo contrario, devuelve 0. Para una distribución, devuelve el recuento en el conjunto de datos representado por la distribución. Para todos los demás tipos, devuelve 0.

    <CollapserGroup>
      <Collapser title="Obtenga el número de primeras pinturas más rápido que un umbral">
        Esta consulta devuelve el número de eventos donde `firstPaint` es menor o igual a 1 segundo.

        ```sql
        FROM PageView SELECT sum(getCdfCount(firstPaint, 1.0))
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-if"
    title={<><InlineCode>
      if(condition, trueValue [, falseValue])
    </InlineCode></>
    }
  >
    Utilice `if()` para realizar operaciones de flujo de control if-then-else a lo largo de una consulta.

    `if()` toma 3 argumentos:

    * `condition` - una expresión que puede evaluar como `true` o `false`
    * `trueValue` - este valor se devuelve si la expresión booleana es `true`
    * `falseValue` - este valor opcional se devuelve si la expresión booleana es `false`, o si no se proporciona, se devuelve `NULL`

    <CollapserGroup>
      <Collapser title="Uso básico">
        ```sql
        FROM Log
        SELECT count(*)
        FACET if(level_name = 'ERROR', 'ERROR', 'NOT_ERROR')
        ```
      </Collapser>

      <Collapser
        title={<>Usar con <InlineCode>
          AND
        </InlineCode> y <InlineCode>
          OR
        </InlineCode></>
        }
      >
        ```sql
        FROM Log
        SELECT count(*)
        FACET if(level_name = 'INFO' OR level_name = 'WARNING', 'NOT_ERROR', 'ERROR')
        ```
      </Collapser>

      <Collapser
        title={<>Anidado <InlineCode>
          If()
        </InlineCode></>
        }
      >
        Emplee una función `if()` anidada para agregar lógica condicional adicional.

        ```sql
        FROM Transaction SELECT count(*)
        FACET if(appName LIKE '%java%', 'Java',
            if(appName LIKE '%kafka%', 'Kafka', 'Other'))
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-jparse"
    title={<InlineCode>jparse(attribute [, path])</InlineCode>
    }
  >
    Utilice la función de análisis JSON, `jparse()`, para analizar un valor de cadena y producir un mapa/lista de valores (o estructuras anidadas) que se pueden manejar como cualquier otro tipo de valor de primera clase en NRQL.

    `jparse()` toma dos argumentos:

    * `attribute` - Un valor de cadena JSON.
    * `path` - Un valor de cadena opcional que se emplea para hacer referencia directa a una parte particular del JSON dentro del parámetro `attribute` . Consulte la sección [Referencia de sintaxis de ruta de análisis JSON](#json-parse-path-syntax-reference) a continuación.

    La función `jparse()` sigue el [formato RFC 8259](https://datatracker.ietf.org/doc/html/rfc8259#section-2) para analizar valores JSON. Cuando la función `jparse()` se utiliza sin el parámetro `path` , devolverá el valor JSON deserializado.

    Puede usar corchetes para extraer valores individuales de un resultado `jparse()` a través de una clave/índice y asignar claves JSON directamente al atributo usando la cláusula `WITH` .

    <CollapserGroup>
      <Collapser id="jparse-square-bracket-syntax" title="Hacer referencia a una clave/índice usando la sintaxis de corchetes">
        <DNT>
          **Referencing a key**
        </DNT>

        La siguiente consulta hace referencia a la clave `userNames` dentro del atributo `jsonString` y devolverá `['abc', 'xyz']`.

        ```sql
        WITH '{"userNames": ["abc", "xyz"]}' AS jsonString SELECT jparse(jsonString)[userNames]
        ```

        <DNT>
          **Referencing an index**
        </DNT>

        La siguiente consulta hace referencia al índice `0` dentro del atributo `jsonString` y devolverá `'abc'`.

        ```sql
        WITH '["abc", "xyz"]' AS jsonString SELECT jparse(jsonString)[0]
        ```
      </Collapser>

      <Collapser id="mapping-json-keys-to-attributes" title="Mapeo claves JSON para atributo">
        La siguiente consulta utiliza `jparse()` en la cláusula `WITH` para asignar las claves JSON `userName` y `id` a variables NRQL para que puedan usarse en el resto de la consulta.

        ```sql
        WITH '{"userName": "test", "unused": null, "id": 100}' AS jsonString, jparse(jsonString) AS (userName, id) SELECT userName, id
        ```
      </Collapser>
    </CollapserGroup>

    Para analizar valores específicos de la cadena JSON, puede utilizar el parámetro `path` .

    <Collapser id="json-parse-path-syntax-reference" title="Referencia de sintaxis de ruta de análisis JSON">
      Es común que los datos JSON estén anidados en varias capas en formas no triviales. La sintaxis de la ruta le permite hacer referencia directamente a una parte particular de los datos JSON.

      Datos de ejemplo:

      ```json
      {
        "valueA": "test",
        "valueB": {
          "nestedValue1": [1, 2, 3],
          "nestedValue2": 100
        },
        "valueC": [
          { "id": 1, "label": "A", "other": 7 },
          { "id": 2, "label": "B", "other": 9 },
          { "id": 3, "label": "C", "other": 13 }
        ]
      }
      ```

      Ejemplos de sintaxis de ruta utilizando los datos anteriores:

      <table id="join-types">
        <thead>
          <tr>
            <th>
              <DNT>
                **Path Syntax Example**
              </DNT>
            </th>

            <th>
              <DNT>
                **Result Description**
              </DNT>
            </th>

            <th>
              <DNT>
                **Result**
              </DNT>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              `valueA`
            </td>

            <td>
              Devuelve el valor en la clave
            </td>

            <td>
              `"test"`
            </td>
          </tr>

          <tr>
            <td>
              `["valueA"]`
            </td>

            <td>
              Devuelve el valor en la clave
            </td>

            <td>
              `"test"`
            </td>
          </tr>

          <tr>
            <td>
              `[valueA, valueC]`
            </td>

            <td>
              Devuelve la lista de valor principal
            </td>

            <td>
              `["test", [{"id": 1…}, {"id": 2…}], {"id": 3…}]]`
            </td>
          </tr>

          <tr>
            <td>
              `valueB.nestedValue2`
            </td>

            <td>
              Devuelve el valor en la clave
            </td>

            <td>
              `100`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[0]`
            </td>

            <td>
              Devuelve el valor de la lista en el índice `0`
            </td>

            <td>
              `{"id": 1…}`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[0,2]`
            </td>

            <td>
              Devuelve los valores de la lista en el índice `0` y `2`
            </td>

            <td>
              `[{"id": 1…}, {"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[0:2]`
            </td>

            <td>
              Devuelve el rango de valores de la lista desde el primer índice al segundo, excluyendo el valor en el segundo índice. En este caso, se devuelven los valores de la lista en el índice `0` y `1` .
            </td>

            <td>
              `[{"id": 1…}, {"id": 2…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[:2]`
            </td>

            <td>
              Devuelve el rango de valores de la lista desde el principio hasta el segundo índice, excluyendo el valor en el segundo índice. En este caso, se devuelven los valores de la lista en el índice `0` y `1` .
            </td>

            <td>
              `[{"id": 1…}, {"id": 2…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[:-2]`
            </td>

            <td>
              Devuelve todos los valores de la lista excepto el último *n*, donde *n* es un número negativo luego de los dos puntos (es decir, `[:-n]`). En este caso, se devolverá el valor de la lista en el índice `0` .
            </td>

            <td>
              `[{"id": 1…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[1:]`
            </td>

            <td>
              Devuelve el rango de valores de la lista desde el índice especificado hasta el final de la lista. En este caso, se devuelven los valores de la lista en el índice `1` y `2` .
            </td>

            <td>
              `[{"id": 2…}, {"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[-1:]`
            </td>

            <td>
              Devuelve los últimos *n* valores de la lista, donde *n* es un número negativo antes de los dos puntos (por ejemplo, `[-n:]`). En este caso se devolverá el valor de la lista en el índice `2` .
            </td>

            <td>
              `[{"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[*]`
            </td>

            <td>
              Devuelve todos los valores de la lista
            </td>

            <td>
              `[{"id": 1…}, {"id": 2…}, {"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[*].id`
            </td>

            <td>
              Devuelve el valor principal especificado de todos los afiliados a la lista. En este caso, el valor principal es `id` .
            </td>

            <td>
              `[1, 2, 3]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[*]["label", "other"]`
            </td>

            <td>
              Devuelve las claves especificadas de todos los afiliados a la lista. En este caso, el valor principal es `label` y `other` .
            </td>

            <td>
              `[["A", 7],…]`
            </td>
          </tr>
        </tbody>
      </table>
    </Collapser>

    Ejemplos:

    <CollapserGroup>
      <Collapser id="basic-jparse-example" title="Ejemplo básico">
        La siguiente consulta analiza la cadena JSON dentro del atributo `jsonString` .

        ```sql
        WITH '{"user": {"name": "John", "id": 5}}' AS jsonString SELECT jparse(jsonString)
        ```

        Esta consulta devolverá la cadena JSON deserializada:

        ```json
        {"user":{"name":"John","id":5}}
        ```
      </Collapser>

      <Collapser id="parse-specific-value-from-log-message" title="Analizar un valor específico de un mensaje de log">
        Un problema común es tener datos ricos y estructurados escondidos dentro de un mensaje de registro. Puede aprovechar [`aparse()`](#func-aparse) y `jparse()` para eliminar el ruido y encontrar valores específicos.

        La siguiente consulta:

        1. Llama a `aparse()` para extraer datos JSON del atributo `logMessage`
        2. Analiza el campo `user.name` de los datos JSON extraídos utilizando `jparse()` y el parámetro de ruta `user.name` .

        ```sql
        WITH '1693242121842: value=\'{"user": {"name": "John", "id": 5}}\', useless=stuff' AS logMessage, aparse(logMessage, '%: value=\'*\'%') AS jsonString SELECT jparse(jsonString, 'user.name')
        ```
      </Collapser>

      <Collapser id="parse-multiple-values-from-json" title="Analizar múltiples valores anidados de una cadena JSON">
        La siguiente consulta analiza cada campo `id` de la lista de objetos dentro del atributo `jsonString` y genera estos valores como una matriz.

        ```sql
        WITH '{"users": [{"name": "A", "id": 5}, {"name": "B", "id": 10}]}' AS jsonString, jparse(jsonString, 'users[*].id') AS ids SELECT ids
        ```

        La consulta anterior devolverá `[5, 10]`.
      </Collapser>
    </CollapserGroup>

    *Funciones relacionadas:* [`mapKeys()`](#func-mapKeys), [`mapValues()`](#func-mapValues)
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-length"
    title={<InlineCode>longitud (atributo)</InlineCode>
    }
  >
    Utilice la función `length()` para devolver la longitud de un valor de cadena o el número de elementos en un valor de matriz.

    Se necesita un solo argumento.

    <CollapserGroup>
      <Collapser title="Obtener la longitud de la URL de PageView">
        Esta consulta devuelve la longitud de cada cadena de URL del evento `PageView` .

        ```sql
        SELECT length(pageUrl) FROM PageView
        ```
      </Collapser>

      <Collapser title="Obtener la longitud de una matriz">
        Considere la matriz `["US", "CA", "UK"]` almacenada en el atributo `countries` .

        ```sql
        SELECT length(countries) FROM Foo
        ```

        length(countries) en la consulta anterior devolverá `3`.
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-contains"
    title={<InlineCode>contiene (atributo, elemento)</InlineCode>
    }
  >
    Emplee la función `contains()` para comprobar si un elemento existe dentro de una matriz.

    `contains()` toma los siguientes argumentos:

    * `attribute` - Una matriz
    * `element` - El elemento que se va a comprobar en la matriz.

    <CollapserGroup>
      <Collapser title="Comprobar si una matriz contiene un elemento">
        Considere la matriz `["9999-1234-9999", "3333-7890-3333", "5555-3456-555"]` almacenada en el atributo `guids` .

        ```sql
        SELECT contains(guids, '5555-3456-555') FROM Foo
        ```

        `contains(guids, '5555-3456-555')` En la consulta anterior se devolverá `TRUE`.
      </Collapser>

      <Collapser title="Filtrar elementos en el recuento (*) usando contiene">
        Considere la matriz `["9999-1234-9999", "3333-7890-3333", "5555-3456-555"]` almacenada en el atributo `guids` dentro del tipo de evento `Transaction` .

        ```sql
        SELECT count(*) FROM Transaction WHERE contains(guids, '9999-1234-9999')
        ```

        La consulta anterior devolverá un recuento de transacciones que incluyen el guid `"9999-1234-9999"` .
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-lookup"
    title={<InlineCode>lookup(table)</InlineCode>
    }
  >
    Si has [subido una tabla de búsquedas](/docs/logs/ui-data/lookup-tables-ui), puedes usar esta función con un nombre de tabla para acceder a los datos de esa tabla en una consulta. Aquí hay una consulta de ejemplo:

    ```sql
    FROM Log
    SELECT count(*)
    WHERE hostname IN (FROM lookup(myHosts) SELECT uniques(myHost))
    ```

    Para obtener más información, consulte [Cómo consultar la tabla de búsquedas de datos](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/lookups).
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-lower"
    title={<InlineCode>lower(str)</InlineCode>
    }
  >
    Utilice la función `lower()` para cambiar todos los caracteres alfabéticos de un valor de cadena a minúsculas.

    Argumentos:

    * `str` - El valor de la cadena se escribirá en minúsculas.

      * Puede ser cualquier cosa que se evalúe como una cadena, incluida una cadena literal entre comillas, un atributo de cadena de consulta, una función que devuelve una cadena o incluso una subconsulta que devuelve un único valor de cadena.
      * Si este argumento se evalúa como nulo, la función `lower()` devolverá nulo.

      <CollapserGroup>
        <Collapser title="Minúscula una cadena">
          Esta consulta demuestra el uso de la función `lower()` en varias partes de una consulta.

          ```sql
          FROM PageAction
          SELECT latest(lower(actionName))
          WHERE lower(actionName) = lower('acmePageRenderedEvent') OR lower(actionName) = lower('SubmitLogin')
          FACET concat(actionName, ':', lower(actionName))
          ```

          <img title="screenshot lower()" alt="screenshot lower()" src="/images/lowerExample.webp" />

          <figcaption>
            <InlineCode>
              lower(str)
            </InlineCode> ejemplo
          </figcaption>
        </Collapser>
      </CollapserGroup>

      *Función relacionada: [<InlineCode>
        upper()
      </InlineCode>](#func-upper)*
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mapKeys"
    title={<InlineCode>mapKeys(attribute)</InlineCode>
    }
  >
    Utilice la función `mapKeys()` para devolver una lista de claves cuando se proporciona un mapa como entrada dentro del parámetro `attribute` .

    <CollapserGroup>
      <Collapser id="extract-list-of-keys" title="Extraiga una lista de claves dentro de una cadena JSON">
        ```sql
        WITH '{"userResult1": 100, "userResult2": 200, "userResult3": 4}' AS jsonString SELECT mapKeys(jparse(jsonString)) AS keys
        ```

        La consulta anterior:

        1. Deserializa la cadena JSON dentro del atributo `jsonString` en un mapa usando la función `jparse()`
        2. Llama a la función `mapKeys()` para extraer una lista de todas las claves dentro de este mapa.
        3. Vincula esta lista de claves al atributo `keys`

        Después de ejecutar la consulta anterior, `keys` contendrá la lista `['userResult1', 'userResult2', 'userResult3']`.
      </Collapser>

      <Collapser id="extract-list-of-keys-with-nested-keys" title="Extraiga una lista de claves de una cadena JSON con claves anidadas">
        ```sql
        WITH '{"value1": "test", "value2": {"nestedValue1": [1, 2, 3], "nestedValue2": 100}}' AS jsonString SELECT mapKeys(jparse(jsonString)) AS keys
        ```

        La consulta anterior extraerá solo las claves más externas de la cadena JSON dentro del atributo `jsonString` . Después de ejecutar la consulta, `keys` contendrá la lista `['value1', 'value2']`.
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mapValues"
    title={<InlineCode>mapValues(attribute)</InlineCode>
    }
  >
    Utilice la función `mapValues()` para devolver una lista de valores cuando se proporciona un mapa como entrada dentro del parámetro `attribute` .

    <CollapserGroup>
      <Collapser id="extract-list-of-values" title="Extraiga una lista de valores dentro de una cadena JSON">
        ```sql
        WITH '{"userResult1": 100, "userResult2": 200, "userResult3": 4}' AS jsonString SELECT mapValues(jparse(jsonString)) AS values
        ```

        La consulta anterior:

        1. Deserializa la cadena JSON dentro del atributo `jsonString` en un mapa usando la función `jparse()`
        2. Llama a la función `mapValues()` para extraer una lista de todos los valores dentro de este mapa.
        3. Vincula esta lista de valores al atributo `values`

        Después de ejecutar la consulta anterior, `values` contendrá la lista `[100, 200, 4]`.
      </Collapser>

      <Collapser id="extract-list-of-values-with-nested-values" title="Extraiga una lista de valores de una cadena JSON con valores anidados">
        ```sql
        WITH '{"value1": "test", "value2": {"nestedValue1": [1, 2, 3], "nestedValue2": 100}}' AS jsonString SELECT mapValues(jparse(jsonString)) AS values
        ```

        La consulta anterior extrae los valores más externos de la cadena JSON dentro del atributo `jsonString` . Después de ejecutar la consulta, `values` contendrá una lista de la cadena `"test"` y el objeto anidado.

        Esto se puede ver en la vista JSON:

        ```json
        "contents": [
          {
            "function": "alias",
            "alias": "values",
            "contents": {
              "constant": [
                "test",
                {
                  "nestedValue1": [
                    1,
                    2,
                    3
                  ],
                  "nestedValue2": 100
                }
              ]
            }
          }
        ],
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-minOf"
    title={<InlineCode>minuteOf(attribute), hourOf(attribute), etc.</InlineCode>
    }
  >
    Utilice la función `minuteOf()` para extraer solo la porción de minutos (es decir, los minutos 0 a 59) de un atributo que contiene un valor timestamp válido. Esto también funciona para funciones como `hourOf()`, `weekOf()`, etc. Para obtener una lista completa de funciones basadas en el tiempo, consulte la tabla en nuestro [documento de resultados de grupo a lo largo del tiempo.](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-group-results-across-time/#cohorts)
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mod"
    title={<InlineCode>mod(attribute, divisor)</InlineCode>
    }
  >
    Emplee la función `mod()` para devolver el módulo base luego de dividir el valor del atributo numérico proporcionado (el primer argumento o dividendo) por un valor numérico (el segundo argumento o divisor). Esta operación de módulo se puede emplear dentro de una condición de cláusula `WHERE` para filtrar un subconjunto arbitrario de resultados o dentro de una cláusula `FACET` como una forma de subdividir el conjunto de resultados.

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          mod()
        </InlineCode> dentro de una condición de cláusula <InlineCode>
          WHERE
        </InlineCode></>
        }
      >
        ```sql
        FROM Transaction SELECT * WHERE mod(port, 2) = 1
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          mod()
        </InlineCode> dentro de una cláusula <InlineCode>
          FACET
        </InlineCode></>
        }
      >
        ```sql
        FROM NrConsumption SELECT uniques(hostId, 10000) 
        SINCE 1 day AGO FACET mod(hostId, 10)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-position"
    title={<InlineCode>position(str, substr [, occurrence])</InlineCode>
    }
  >
    Utilice la función `position()` para encontrar la ubicación de una subcadena dentro de una cadena. La coincidencia distingue entre mayúsculas y minúsculas.

    Argumentos:

    * `str` - la cadena en la que se encontrará la subcadena.

      * Puede ser cualquier cosa que se evalúe como una cadena, incluida una cadena literal entre comillas, un atributo de cadena de consulta, una función que devuelve una cadena o incluso una subconsulta que devuelve un único valor de cadena.

    * `substr` - la cadena que se va a buscar dentro de str.

    * `occurrence` - indica qué ocurrencia de substr de la cual se devolverá la posición.

      * *Por defecto*: `0`
      * Si es positivo, encuentre la enésima aparición de substr desde el comienzo de str, basada en cero
      * Si es negativo, encuentre la enésima aparición de la substr desde el final de str. La última aparición de substr sería la aparición -1.

      Alias: <InlineCode>
        indexOf(str, substr \[, occurrence])
      </InlineCode> - `indexOf()` es un nombre alternativo para la función `position()`

      Devoluciones:

      * El índice basado en 0 del carácter inicial de la substr dentro de str
      * Se devuelve nulo si str es nulo, substr es nulo o no se encuentra la aparición de substr a la que se hace referencia

    <CollapserGroup>
      <Collapser title="Encuentre el índice posicional de una subcadena dentro de una URL">
        Esta consulta demuestra el uso de la función <InlineCode>
          position()
        </InlineCode> para encontrar el índice posicional de varias subcadenas dentro de una cadena. Aquí también se demuestra el uso de la función <InlineCode>
          position()
        </InlineCode> dentro de los argumentos de la función [<InlineCode>
          substring()
        </InlineCode>](#func-substring) .

        ```sql
        FROM PageView
        WITH position(pageUrl, ':') AS FirstColon,
          position(pageUrl, '/', 1) + 1 AS DomainBegin, 
          position(pageUrl, '/', 2) AS DomainEnd, 
          DomainEnd - DomainBegin AS DomainLength
        SELECT pageUrl, FirstColon, substring(pageUrl, 0, FirstColon) AS Protocol,
          DomainBegin, DomainEnd, DomainLength, substring(pageUrl, DomainBegin, DomainLength) AS Domain,
          position(pageUrl, '/', -1) AS LastSlash, 
          substring(pageUrl, position(pageUrl, '/', -1)) AS PathEnd
        ```

        <img title="screenshot position()" alt="screenshot position()" src="/images/positionExample.webp" />

        <figcaption>
          <InlineCode>
            position(str, substr \[, occurrence])
          </InlineCode> ejemplo
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="round"
    title={<InlineCode>round(attribute)</InlineCode>
    }
  >
    Utilice la función `round()` para devolver el valor redondeado de un atributo.

    Opcionalmente, `round()` puede tomar un segundo argumento, `to_nearest`, para redondear el primer argumento al múltiplo más cercano del segundo. `to_nearest` puede ser fraccionario.

    ```sql
    SELECT round(n [, to_nearest])
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="stddev"
    title={<InlineCode>stddev(attribute)</InlineCode>
    }
  >
    Utilice la función `stddev()` para devolver una [desviación estándar](https://en.wikipedia.org/wiki/Standard_deviation) para un atributo numérico durante el rango de tiempo especificado. Se necesita un solo argumento. Si el atributo no es numérico, devolverá un valor de cero.
  </Collapser>

  <Collapser
    className="freq-link"
    id="abs"
    title={<InlineCode>abs(atributo)</InlineCode>
    }
  >
    Emplee la función `abs()` para devolver el [valor absoluto](https://en.wikipedia.org/wiki/Absolute_value) de `attribute`.
  </Collapser>

  <Collapser
    className="freq-link"
    id="floor"
    title={<InlineCode>piso(atributo)</InlineCode>
    }
  >
    Emplee la función `floor()` para devolver el número entero más cercano a `attribute` redondeando hacia abajo.
  </Collapser>

  <Collapser
    className="freq-link"
    id="ceil"
    title={<InlineCode>ceil(atributo)</InlineCode>
    }
  >
    Emplee la función `ceil()` para devolver el número entero más cercano a `attribute` redondeando hacia arriba.
  </Collapser>

  <Collapser
    className="freq-link"
    id="clamp_max"
    title={<InlineCode>clamp_max(atributo, límite)</InlineCode>
    }
  >
    Emplee la función `clamp_max()` para imponer un límite superior al valor de `attribute`.

    `clamp_max()` toma los siguientes argumentos:

    * `attribute` - Un atributo numérico.
    * `limit` - El límite superior para el valor `attribute` .

    **Ejemplo**\
    Puedes usar `clamp_max()` para garantizar que el valor atípico no sesgue la escala de un gráfico de seriales temporales:

    ```sql
      SELECT clamp_max(average(duration), 10) FROM Transaction TIMESERIES
    ```

    La consulta anterior devuelve `duration` a menos que exceda 10, en cuyo caso devolverá 10.
  </Collapser>

  <Collapser
    className="freq-link"
    id="clamp_min"
    title={<InlineCode>clamp_min(atributo, límite)</InlineCode>
    }
  >
    Emplee la función `clamp_min()` para imponer un límite inferior al valor de `attribute`.

    `clamp_min()` toma los siguientes argumentos:

    * `attribute` - Un atributo numérico.
    * `limit` - El límite inferior para el valor `attribute` .

    **Ejemplo**\
    Puedes usar `clamp_min()` para garantizar que el valor atípico no sesgue la escala de un gráfico de seriales temporales:

    ```sql
      SELECT clamp_min(average(duration), 1) FROM Transaction TIMESERIES
    ```

    La consulta anterior devuelve `duration` a menos que sea menor que 1, en cuyo caso devolverá 1.
  </Collapser>

  <Collapser
    className="freq-link"
    id="pow"
    title={<InlineCode>pow(atributo, exponente)</InlineCode>
    }
  >
    Emplee la función `pow()` para elevar `attribute` a la potencia de `exponent`.

    `pow()` toma los siguientes argumentos:

    * `attribute` - Un atributo numérico.
    * `exponent` - Un atributo numérico para elevar `attribute` a la potencia de.

    **Ejemplo**\
    La siguiente consulta devolverá `duration` elevada a la potencia de 4:

    ```sql
      SELECT pow(duration, 4) FROM Transaction
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sqrt"
    title={<InlineCode>sqrt(atributo)</InlineCode>
    }
  >
    Emplee la función `sqrt()` para devolver la [raíz cuadrada](https://en.wikipedia.org/wiki/Square_root) de `attribute`.
  </Collapser>

  <Collapser
    className="freq-link"
    id="exp"
    title={<InlineCode>exp(atributo)</InlineCode>
    }
  >
    Emplee la función `exp()` para devolver la [función exponencial natural](https://en.wikipedia.org/wiki/Exponential_function) de `attribute`.
  </Collapser>

  <Collapser
    className="freq-link"
    id="ln"
    title={<InlineCode>ln(atributo)</InlineCode>
    }
  >
    Emplee la función `ln()` para devolver el [logaritmo natural](https://en.wikipedia.org/wiki/Natural_logarithm) de `attribute`.
  </Collapser>

  <Collapser
    className="freq-link"
    id="log2"
    title={<InlineCode>log2(attribute)</InlineCode>
    }
  >
    Emplee la función `log2()` para devolver el [logaritmo en base 2](https://en.wikipedia.org/wiki/Binary_logarithm) de `attribute`.
  </Collapser>

  <Collapser
    className="freq-link"
    id="log10"
    title={<InlineCode>log10(attribute)</InlineCode>
    }
  >
    Emplee la función `log10()` para devolver el [logaritmo en base 10](https://en.wikipedia.org/wiki/Common_logarithm) de `attribute`.
  </Collapser>

  <Collapser
    className="freq-link"
    id="log"
    title={<InlineCode>log(attribute, base)</InlineCode>
    }
  >
    Emplee la función `log()` para calcular el logaritmo de `attribute` con una base de `base`.

    `log()` toma los siguientes argumentos:

    * `attribute` - Un atributo numérico.
    * `base` - Un atributo numérico para emplear como base al calcular el logaritmo de `attribute`.

    **Ejemplo**\
    La siguiente consulta calculará el logaritmo de `duration` con una base de 4:

    ```sql
      SELECT log(duration, 4) FROM Transaction
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-string"
    title={<InlineCode>string(attribute [, precision: ])</InlineCode>
    }
  >
    Utilice la función `string()` para convertir un valor numérico, booleano, de tupla o de matriz en un valor de cadena.

    Se necesitan dos argumentos, uno opcional:

    * Nombre del atributo
    * Precisión: si está presente, impone un límite en el número de decimales incluidos al convertir valores numéricos de punto flotante.

    <CollapserGroup>
      <Collapser title="Obtenga resultados de consulta sin cadenas como un valor de cadena">
        Esta consulta devuelve la duración de PageView como una cadena, con dos decimales.

        ```sql
        FROM PageView SELECT string(duration, precision: 2)
        ```
      </Collapser>

      <Collapser title="Obtenga resultados de la función agregador que no sean cadenas como un valor de cadena">
        Esta consulta devuelve el promedio de la duración de PageView como una cadena, con dos decimales.

        ```sql
        FROM PageView SELECT string(average(duration), precision: 2)
        ```
      </Collapser>

      <Collapser title="Resultados de la consulta de facetas mediante un número de punto flotante sin truncamiento">
        Utilice `string()` para facetar por un valor de punto flotante sin perder decimales.

        ```sql
        FROM PageView SELECT count(*) 
        FACET string(tuple(asnLatitude, asnLongitude), precision: 2)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-substring"
    title={<InlineCode>substring(str, start [, length])</InlineCode>
    }
  >
    Utilice la función `substring()` para extraer una parte de una cadena.

    Argumentos:

    * `str` - la cadena de la que se extraerá una subcadena.

      * Puede ser cualquier cosa que se evalúe como una cadena, incluida una cadena literal entre comillas, un atributo de cadena de consulta, una función que devuelve una cadena o incluso una subconsulta que devuelve un único valor de cadena.
      * Si este argumento se evalúa como nulo, la función `substring()` devolverá nulo.

    * `start` - la posición dentro de str desde donde comenzar la extracción.

      * El primer carácter de str es la posición 0.
      * Un valor negativo encontrará la posición relativa al final de str, siendo el último carácter de la cadena la posición -1.
      * Si el inicio es mayor o igual a la longitud de str, la función `substring()` devolverá una cadena vacía.
      * Si el inicio es negativo y su valor absoluto es mayor que la longitud de str, la subcadena extraída comenzará en la posición 0.

    * `length` - la longitud, o número de caracteres, de la subcadena a extraer de str.

      * *Opcional* : si no se proporciona la longitud, se incluirán todos los caracteres de str después de la posición inicial resuelta.

      <CollapserGroup>
        <Collapser title="Extraer varias partes de una cadena.">
          Esta consulta devuelve partes del valor de la sesión.

          ```sql
          FROM PageView
          SELECT session, substring(session, 0, 3) AS First3,
            substring(session, 3) AS After3rd,
            substring(session, -3) AS Last3
          ```

          <img title="screenshot substring()" alt="screenshot substring()" src="/images/substringExample.webp" />

          <figcaption>
            <InlineCode>
              substring(str, start \[, length])
            </InlineCode> ejemplo
          </figcaption>
        </Collapser>
      </CollapserGroup>

      *Consulte la función [<InlineCode>
        position()
      </InlineCode>](#func-position) para ver ejemplos del uso de <InlineCode>
        substring()
      </InlineCode> y <InlineCode>
        position()
      </InlineCode> juntos.*
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-toDatetime"
    title={<InlineCode>toDatetime(timestamp[, pattern [, timezone]])</InlineCode>
    }
  >
    Utilice la función `toDatetime()` para traducir una timestamp a una cadena de fecha y hora formateada.

    `toDatetime()` toma los siguientes argumentos:

    * `timestamp` - Una timestamp numérica que se traducirá en una cadena de fecha y hora. Este puede ser un valor numérico o un atributo, y se convertirá a `long` internamente.
    * `pattern` - Un patrón de fecha y hora opcional empleado para formatear el resultado. Consulte la sección *Patrones para formatear y analizar* en la [documentación de DatetimeFormatter](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html) para saber cómo construir una cadena de patrón.
      * Debe ser un valor de cadena constante y su valor predeterminado será `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` si no se proporciona un patrón.
    * `timezone` - Un valor de zona horaria opcional que se emplea para interpretar la cadena de fecha y hora (por ejemplo, (hora UTC).
      * Debe ser un valor de cadena constante y su valor predeterminado será UTC o el valor proporcionado en `WITH TIMEZONE` si está disponible.

    Siempre que la entrada sea un número válido, la función `toDatetime()` siempre devolverá un valor.

    Alias: `fromTimestamp()` es un nombre alternativo para la función `toDatetime()` .

    Ejemplos:

    <CollapserGroup>
      <Collapser title="Traducir una timestamp usando el patrón predeterminado">
        La siguiente consulta traduce el atributo `timestampValue` utilizando el patrón predeterminado de `yyyy-MM-dd'T'HH:mm:ss.SSSXXX`. Esto devolverá la cadena de fecha y hora `1970-01-01T00:20:34.567Z`.

        ```sql
        WITH 1234567 AS timestampValue SELECT toDatetime(timestampValue)
        ```
      </Collapser>

      <Collapser title="Traducir una timestamp usando el parámetro de zona horaria">
        La siguiente consulta traduce el atributo `timestampValue` utilizando la cadena de patrón `yyyy-MM-dd` con la zona horaria establecida en &apos;América/Los\_Angeles&apos;. Esto devolverá la cadena de fecha y hora `1969-12-31`.

        ```sql
        WITH 1234567 AS timestampValue SELECT toDatetime(timestampValue, 'yyyy-MM-dd', timezone:'America/Los_Angeles')
        ```
      </Collapser>

      <Collapser
        title={<>Traducir una timestamp usando la zona horaria en la cláusula <InlineCode>
          WITH TIMEZONE
        </InlineCode></>
        }
      >
        La siguiente consulta traduce el atributo `timestampValue` utilizando la zona horaria proporcionada en la cláusula `WITH TIMEZONE` . Esto devolverá la cadena de fecha y hora `1969-12-31`.

        ```sql
        WITH 1234567 AS timestampValue SELECT toDatetime(timestampValue, 'yyyy-MM-dd') FROM Event WITH TIMEZONE 'America/Los_Angeles'
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-toTimestamp"
    title={<InlineCode>toTimestamp(datestring[, pattern [, timezone]])</InlineCode>
    }
  >
    Utilice la función `toTimestamp()` para analizar una timestamp en milisegundos de época a partir de una cadena de fecha y hora.

    `toTimestamp()` toma los siguientes argumentos:

    * `datestring` - Una cadena de fecha y hora que se traducirá a una timestamp (milisegundos de época). Esto puede ser un atributo de cadena o un literal de cadena entre comillas.
    * `pattern` - Un patrón de fecha y hora opcional empleado para analizar el parámetro de cadena de fecha. Consulte la sección *Patrones para formatear y analizar* en la [documentación de DatetimeFormatter](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html) para saber cómo construir una cadena de patrón.
      * Debe ser un valor de cadena constante y su valor predeterminado será `yyyy-MM-dd'T'HH:mm:ss[.SSS][XXX]` si no se proporciona un patrón.
    * `timezone` - Un valor de zona horaria opcional que se emplea para interpretar el parámetro de cadena de fecha (por ejemplo, (hora del Pacífico).
      * Debe ser un valor de cadena constante y su valor predeterminado será UTC o el valor proporcionado en `WITH TIMEZONE` si está disponible.

    Alias: `fromDatetime()` es un nombre alternativo para la función `toTimestamp()` .

    <Callout variant="tip">
      Si la cadena encontrada no coincide con el patrón dado, devolverá `null`. Si tiene cadenas de fecha y hora en una variedad de patrones, puede fusionar resultados usando `OR` para conectar en cascada hasta que uno de los valores no sea nulo. También puede utilizar segmentos de patrón opcionales. El patrón predeterminado utiliza corchetes para que las partes de milisegundos y desplazamiento de zona sean opcionales.
    </Callout>

    <CollapserGroup>
      <Collapser id="partial-datetime-interpretation" title="Interpretación parcial de fecha y hora al analizar cadenas de fecha y hora">
        <table>
          <thead>
            <tr>
              <th>
                Guión
              </th>

              <th>
                Detalle
              </th>

              <th>
                Patrón de muestra
              </th>

              <th>
                Fecha y hora de muestra
              </th>

              <th>
                Resuelve
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                Falta zona horaria
              </td>

              <td>
                Empleará el argumento de zona horaria o el valor `WITH TIMEZONE` . El valor predeterminado es `UTC`.
              </td>

              <td>
                aaaa-MM-dd HH:mm:ss.SSS
              </td>

              <td>
                2023-10-18 15:27:03.123
              </td>

              <td>
                2023-10-18T15:27:03.123Z
              </td>
            </tr>

            <tr>
              <td rowspan="8">
                Falta el campo de fecha y hora
              </td>

              <td rowspan="8">
                Cualquier campo de hora que falte se reemplazará con 0. Cualquier campo de fecha que falte se reemplazará con 1. Si un campo está presente, todos los campos de prioridad superior también deben estar presentes.<br /> Nota: Se admiten los patrones de día del año y trimestre del año.
              </td>

              <td>
                aaaa-MM-dd HH:mm:ss
              </td>

              <td>
                2023-10-18 15:27:03
              </td>

              <td>
                2023-10-18T15:27:03.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-dd HH:mm
              </td>

              <td>
                2023-10-18 15:27
              </td>

              <td>
                2023-10-18T15:27:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-dd HH
              </td>

              <td>
                2023-10-18 15
              </td>

              <td>
                2023-10-18T15:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-dd
              </td>

              <td>
                2023-10-18
              </td>

              <td>
                2023-10-18T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa &apos;día&apos; D
              </td>

              <td>
                2023 día 291
              </td>

              <td>
                2023-10-18T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM
              </td>

              <td>
                2023-10
              </td>

              <td>
                2023-10-01T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                yyyy qqq
              </td>

              <td>
                2023 Q4
              </td>

              <td>
                2023-10-01T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                yyyy
              </td>

              <td>
                2023
              </td>

              <td>
                2023-01-01T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td rowspan="3">
                Tiempo solo
              </td>

              <td rowspan="3">
                Si se utiliza un patrón de tiempo sin fecha, se calculará la timestamp de Unix en milisegundos.<br /> Nota: El ajuste de zona horaria aún se respeta.
              </td>

              <td>
                HH:mm
              </td>

              <td>
                00:30
              </td>

              <td>
                1971-01-01T00:30:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                HH: mmO
              </td>

              <td>
                00:30 GMT-1
              </td>

              <td>
                1971-01-01T01:30:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                HH: mmO
              </td>

              <td>
                00:30 GMT+1
              </td>

              <td>
                1969-12-31T23:30:00.000Z
              </td>
            </tr>

            <tr>
              <td rowspan="3">
                tiempo de 12 horas
              </td>

              <td rowspan="3">
                Si se utiliza un patrón de 12 horas (h minúscula), entonces también se debe utilizar el patrón am-pm-del día (a).<br /> Nota: Dentro de la cadena de fecha y hora AM/PM debe estar en mayúsculas.
              </td>

              <td>
                aaaa-MM-dd h:mm a
              </td>

              <td>
                2023-10-18 15:27
              </td>

              <td>
                2023-10-18T15:27:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-dd h:mm
              </td>

              <td>
                2023-10-18 3:27
              </td>

              <td>
                Patrón no admitido
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-dd h:mm a
              </td>

              <td>
                2023-10-18 15:27
              </td>

              <td>
                nulo (debido a pm minúscula)
              </td>
            </tr>

            <tr>
              <td>
                Prioridad de campo
              </td>

              <td>
                Si un campo está presente, todos los campos de prioridad superior también deben estar presentes.
              </td>

              <td>
                aaaa dd
              </td>

              <td>
                2023 18
              </td>

              <td>
                Patrón no admitido (dd es el día del mes y falta el mes)
              </td>
            </tr>
          </tbody>
        </table>
      </Collapser>
    </CollapserGroup>

    Ejemplos:

    <CollapserGroup>
      <Collapser title="Analizar una cadena de fecha y hora usando el patrón predeterminado">
        La siguiente consulta analiza la cadena de fecha y hora &apos;2023-10-18T15:27:03.123Z&apos; utilizando el patrón predeterminado de `yyyy-MM-dd'T'HH:mm:ss[.SSS][XXX]`. Esto devuelve el valor timestamp `1697642823123`.

        ```sql
        SELECT toTimestamp('2023-10-18T15:27:03.123Z') 
        FROM Event
        ```
      </Collapser>

      <Collapser title="Analizar una cadena de fecha y hora usando el parámetro de zona horaria">
        La siguiente consulta analiza la cadena de fecha y hora &apos;2023-11-03 11:00:32&apos; con la zona horaria establecida en &apos;América/Los\_Angeles&apos;. Esto devuelve el valor timestamp `1699034432000`.

        ```sql
        SELECT toTimestamp('2023-11-03 11:00:32', 'yyyy-MM-dd HH:mm:ss', timezone:'America/Los_Angeles') 
        FROM Event
        ```
      </Collapser>

      <Collapser
        title={<>Analizar una cadena de fecha y hora utilizando la zona horaria en la cláusula <InlineCode>
          WITH TIMEZONE
        </InlineCode></>
        }
      >
        La siguiente consulta analiza la cadena de fecha y hora &apos;2023-11-03 11:00:32&apos; con la zona horaria proporcionada en la cláusula `WITH TIMEZONE` . Esto devuelve el valor timestamp `1699034432000`.

        ```sql
        SELECT toTimestamp('2023-11-03 11:00:32', 'yyyy-MM-dd HH:mm:ss') 
        FROM Event WITH TIMEZONE 'America/Los_Angeles'
        ```
      </Collapser>
    </CollapserGroup>

    <Callout variant="important">
      La UI detectará automáticamente el valor `toTimestamp()` como timestamp y lo formateará como valor de fecha y hora. Para mostrar la timestamp numérica real, ajuste la función `toTimestamp()` en una función `string()`.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-upper"
    title={<InlineCode>upper(str)</InlineCode>
    }
  >
    Utilice la función `upper()` para cambiar todos los caracteres alfabéticos de un valor de cadena a mayúsculas.

    Argumentos:

    * `str` - El valor de la cadena debe estar en mayúsculas.

    * Puede ser cualquier cosa que se evalúe como una cadena, incluida una cadena literal entre comillas, un atributo de cadena de consulta, una función que devuelve una cadena o incluso una subconsulta que devuelve un único valor de cadena.

    * Si este argumento se evalúa como nulo, la función `upper()` devolverá nulo.

      <CollapserGroup>
        <Collapser title="Poner en mayúscula una cadena">
          Esta consulta demuestra el uso de la función `upper()` en varias partes de una consulta.

          ```sql
          FROM PageAction
          SELECT latest(upper(actionName))
          WHERE upper(actionName) = upper('acmePageRenderedEvent') OR upper(actionName) = upper('SubmitLogin')
          FACET concat(actionName, ':', upper(actionName))
          ```

          <img title="screenshot upper()" alt="screenshot upper()" src="/images/upperExample.webp" />

          <figcaption>
            <InlineCode>
              upper(str)
            </InlineCode> ejemplo
          </figcaption>
        </Collapser>
      </CollapserGroup>

      *Función relacionada: [<InlineCode>
        lower()
      </InlineCode>](#func-lower)*
  </Collapser>
</CollapserGroup>

## Conversión de tipo [#type-conversion]

NRQL no admite la &quot;coerción&quot;. Esto significa que un flotante almacenado como una cadena se trata como una cadena y no puede ser operado por funciones que esperan valores flotantes.

Puede convertir una cadena con un valor numérico o un valor booleano con un valor de cadena a sus equivalentes numéricos y booleanos, o convertir un valor que no sea una cadena en un valor de cadena, con estas funciones:

* Emplee la función `numeric()` para convertir un número con formato de cadena en un valor numérico. La función se puede integrar en una consulta que emplea funciones matemáticas en los resultados de la consulta o funciones de agregador NRQL, como `average()`. Tenga en cuenta que si el valor NRQL está en el [formato medidor](/docs/data-apis/understand-data/metric-data/metric-data-type/), entonces `numeric()` no funcionará en él. En su lugar, debe emplear una de estas funciones de consulta compatibles:
* `latest()`
* `min()`
* `max()`
* `sum()`
* `count()`
* `average()`
* Utilice la función `boolean()` para convertir un valor de cadena de `"true"` o `"false"` al valor booleano correspondiente.
* Utilice la función `string()` para convertir un valor numérico, booleano, de tupla o de matriz en un valor de cadena. Consulte [`string()`](#func-string) arriba para obtener más información.

## Comentarios [#comments]

Al escribir una consulta NRQL, puede agregar comentarios, que pueden ayudar a los miembros de su equipo a comprender y utilizar mejor la consulta.

Aquí hay detalles de sintaxis:

* `--` Dos guiones comentarán todo el texto a la derecha de este indicador en la misma línea.
* `//` Dos barras diagonales comentarán todo el texto a la derecha de este indicador en la misma línea.
* `/* */` Cualquier texto entre estos conjuntos de caracteres será comentado. Este indicador puede aplicarse a varias líneas.

Tenga en cuenta que los comentarios no se muestran en todas partes. Algunas vistas, como &quot;consulta reciente&quot; y &quot;ver consulta&quot;, no mostrarán comentarios.

Algunos ejemplos de consulta que incluyen comentarios:

```sql
FROM Transaction SELECT uniqueCount(appId) -- This will return the number of unique App IDs
```

```sql
FROM TransactionError
SELECT count(*) SINCE 1 day ago // Transaction Error for the past day
```

```sql
FROM TransactionTrace /* This data may be incomplete;
If so, run a query of Transaction */
SELECT count(*)
```

## Documentos relacionados [#related-docs]

Otros recursos populares para comprender la sintaxis y las reglas de NRQL incluyen:

* [Curso de instrucción NRQL](https://learn.newrelic.com/writing-nrql-queries) de New Relic University
* [Aprenda a consultar el tipo de datos `Metric`](/docs/telemetry-data-platform/get-data/apis/query-metric-data-type)
* [Usar subconsultas](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql)
* [Utilice embudos para evaluar una serie de datos relacionados](/docs/insights/new-relic-insights/features/funnels)