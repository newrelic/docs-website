---
title: Integración de monitoreo JMX
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: 'New Relic''s JMX integration: how to install and configure it, and what data it reports.'
freshnessValidatedDate: never
translationType: machine
---

Nuestra [integración](/docs/integrations/host-integrations/getting-started/introduction-host-integrations) JMX permite al usuario monitor cualquier aplicación que exponga métrica con JMX. La integración incluye un archivo de recopilación predeterminado que recopila automáticamente claves métricas de la JVM.

## Compatibilidad y requisitos [#comp-req]

Antes de instalar la integración, asegúrese de cumplir con los siguientes requisitos:

* Una cuenta New Relic . ¿No tienes uno? [¡Registrate gratis!](https://newrelic.com/signup) No se requiere tarjeta de crédito.
* Java versión 8 o superior.
* Si necesita utilizar una versión de Java diferente a la configurada en `PATH`, siga [la documentación de configuración de New Relic en GitHub](https://github.com/newrelic/nrjmx#configuring-java-version).
* Esta integración no es compatible con el protocolo IIOP.

## Inicio rápido [#quick]

Si no está ejecutando JMX en entornos Kubernetes o ECS, le recomendamos nuestra instalación guiada. Nuestra instalación guiada utiliza nuestro agente de infraestructura y nuestra CLI para configurar la integración JMX, descubre otras aplicaciones y fuentes log que se ejecutan en su entorno y luego recomienda cuáles debería utilizar.

La instalación guiada funciona con la mayoría de las configuraciones. Pero si no se adapta a sus necesidades, existen otras opciones de instalación a continuación.

¿Listo para comenzar? Haga clic en el botón correspondiente, según la [región del centro de datos](/docs/accounts/accounts-billing/account-setup/choose-your-data-center) que utilice. Cuando haya terminado con la instalación, regrese a esta documentación para revisar las opciones de configuración.

<ButtonGroup>
  <ButtonLink
    role="button"
    to="https://one.newrelic.com/launcher/nr1-core.explorer?pane=eyJuZXJkbGV0SWQiOiJucjEtY29yZS5saXN0aW5nIn0=&cards[0]=eyJuZXJkbGV0SWQiOiJucjEtaW5zdGFsbC1uZXdyZWxpYy5ucjEtaW5zdGFsbC1uZXdyZWxpYyIsInBhdGgiOiJvaGkiLCJyZWNpcGVOYW1lIjoiYXBhY2hlLW9wZW4tc291cmNlLWludGVncmF0aW9uIiwiYWN0aXZlQ29tcG9uZW50IjoiVlRTT0NvbW1hbmQiLCJhY3RpdmVFbnZpcm9ubWVudCI6ImFwYWNoZS1vcGVuLXNvdXJjZS1pbnRlZ3JhdGlvbiJ9"
    variant="primary"
  >
    Instalación guiada, región de EE. UU.
  </ButtonLink>

  <ButtonLink
    role="button"
    to="https://one.eu.newrelic.com/launcher/nr1-core.explorer?pane=eyJuZXJkbGV0SWQiOiJucjEtY29yZS5saXN0aW5nIn0=&cards[0]=eyJuZXJkbGV0SWQiOiJucjEtaW5zdGFsbC1uZXdyZWxpYy5ucjEtaW5zdGFsbC1uZXdyZWxpYyIsInBhdGgiOiJvaGkiLCJyZWNpcGVOYW1lIjoiYXBhY2hlLW9wZW4tc291cmNlLWludGVncmF0aW9uIiwiYWN0aXZlQ29tcG9uZW50IjoiVlRTT0NvbW1hbmQiLCJhY3RpdmVFbnZpcm9ubWVudCI6ImFwYWNoZS1vcGVuLXNvdXJjZS1pbnRlZ3JhdGlvbiJ9"
    variant="primary"
  >
    Instalación guiada, región de la UE
  </ButtonLink>
</ButtonGroup>

## Instalar [#install]

Si no está utilizando la instalación guiada, siga las instrucciones para su entorno:

<CollapserGroup>
  <Collapser
    id="ecs-install"
    title="ECS"
  >
    Consulte [Servicio de monitorización ejecutándose en ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
  </Collapser>

  ' '

  <Collapser
    id="k8s-install"
    title="Kubernetes"
  >
    Consulte [Supervisar el servicio que se ejecuta en Kubernetes](/docs/kubernetes-pixie/kubernetes-integration/advanced-configuration/monitor-services/monitor-services-running-kubernetes).
  </Collapser>

  <Collapser
    id="linux-install"
    title="Linux"
  >
    1. Instale [el agente de infraestructura](/docs/integrations/host-integrations/installation/install-infrastructure-host-integrations/#install) y reemplace la variable `INTEGRATION_FILE_NAME` con `nri-jmx`.

    2. Cambie el directorio a la carpeta de integración:

       ```
       cd /etc/newrelic-infra/integrations.d
       ```

    3. Copie el archivo de configuración de muestra:

       ```
       sudo cp jmx-config.yml.sample jmx-config.yml
       ```

    4. Copie el archivo de configuración de JVM:

       ```
       sudo cp jvm-metrics.yml.sample jvm-metrics.yml
       ```

    5. <DNT>**Optional**</DNT>: Si está interesado en monitorear Tomcat, use este archivo métrico de muestra:

       ```
       sudo cp tomcat-metrics.yml.sample tomcat-metrics.yml
       ```

    6. Edite el archivo `jmx-config.yml` como se describe en los [ajustes de configuración](#config).

    7. [Reinicie el agente de infraestructura](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).

       <Callout variant="important">
         Si los archivos de muestra no están presentes en su instalación, puede descargarlos directamente desde el [repositorio de GitHub](https://github.com/newrelic/nri-jmx).
       </Callout>
  </Collapser>

  <Collapser
    id="windows-install"
    title="Windows"
  >
    1. Descargue la imagen del instalador `nri-jmx` .MSI desde:

       [https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-jmx/nri-jmx-amd64-installer.exe](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-jmx/nri-jmx-amd64-installer.exe)

    2. Para instalar desde el símbolo del sistema de Windows, ejecute:

       ```
       PATH\TO\nri-jmx-amd64-installer.exe
       ```

    3. En el directorio de integración, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, cree una copia del archivo de configuración de muestra ejecutando:

       ```
       cp jmx-config.yml.sample jmx-config.yml
       ```

    4. Edite el archivo de configuración `jmx-config.yml` usando los [ajustes de configuración](#config).

    5. [Reinicie el agente de infraestructura](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).
  </Collapser>
</CollapserGroup>

## Actualiza tu integración [#update]

Esta integración no se actualiza automáticamente. Para obtener mejores resultados, [actualice periódicamente el paquete de integración](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) y [el agente de infraestructura](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

## Tareas posteriores a la instalación [#after-install]

Cuando haya terminado con la instalación, puede establecer las opciones de configuración. Se requieren algunas configuraciones para que la integración funcione, mientras que otras son opcionales.

### Configurar la integración [#config]

La configuración de formato YAML de una integración es donde puede colocar las credenciales de inicio de sesión requeridas y configurar cómo se recopilan los datos. Las opciones que cambie dependen de su configuración y preferencia.

Hay varias formas de configurar la integración, dependiendo de cómo se instaló:

* Si está habilitado a través de Kubernetes: consulte [Supervisar servicios que se ejecutan en Kubernetes](/docs/monitor-service-running-kubernetes).
* Si está habilitado a través de Amazon ECS: consulte [Servicios de monitorización que se ejecutan en ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
* Si está instalado en el host: edite la configuración en el archivo de configuración YAML de la integración, `jmx-config.yml`.

#### Archivos de configuración de integración [#host-connection]

El archivo de configuración tiene configuraciones comunes aplicables a todas las integraciones, como `interval`, `timeout` o `inventory_source`. Para leer todo sobre estas configuraciones comunes, consulte nuestro documento [de formato de configuración](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) .

Las configuraciones específicas relacionadas con JMX se definen usando la sección `env` del archivo de configuración. Estas configuraciones controlan la conexión a su instancia JMX, así como otras configuraciones y características de seguridad. La lista de configuraciones válidas se describe en la siguiente sección de este documento.

Las opciones de configuración se encuentran a continuación. Para ver una configuración de ejemplo, consulte el [archivo de configuración de ejemplo](#example-config).

<CollapserGroup>
  <Collapser
    id="jmx-instance"
    title="Configuración de instancia JMX"
  >
    La integración JMX recopila información métrica y de inventario. Esta tabla muestra a qué se aplica cada opción de configuración.

    ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '

    <table>
      <thead>
        <tr>
          <th style={{ width: '170px' }}>
            Configuración
          </th>

          <th style={{ width: '300px' }}>
            Descripción
          </th>

          <th>
            Por defecto
          </th>

          <th>
            Se aplica a
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            <DNT>
              **JMX_HOST**
            </DNT>
          </td>

          <td>
            El host JMX se está ejecutando.
          </td>

          <td>
            `localhost`
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **JMX_PORT**
            </DNT>
          </td>

          <td>
            El puerto en el que se ejecuta JMX.
          </td>

          <td>
            9999
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **JMX_URI_PATH**
            </DNT>
          </td>

          <td>
            La parte de la ruta del URI del servicio JMX. Esto es útil para uris de servicios no estándar.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **JMX_USER**
            </DNT>
          </td>

          <td>
            El nombre de usuario para la conexión JMX.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **JMX_PASS**
            </DNT>
          </td>

          <td>
            La contraseña para la conexión JMX.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **JMX_REMOTE**
            </DNT>
          </td>

          <td>
            (Específico de JBoss) Si se utiliza o no el formato de conexión URL remota JMX. La conexión se establece de forma predeterminada en el modo de dominio JBoss si es `true`.
          </td>

          <td>
            `false`
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **JMX_REMOTE_JBOSS_STANDLONE**
            </DNT>
          </td>

          <td>
            (Específico de JBoss) Si se utiliza o no el formato de conexión independiente de JBoss. Solo es relevante si se establece `jmx_remote` .
          </td>

          <td>
            `false`
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **CONNECTION_URL**
            </DNT>
          </td>

          <td>
            URL completa de JMX. Esto reemplaza todos los argumentos de conexión (arriba) al proporcionar todos los parámetros en una línea.

            Ejemplo: `"service:jmx:rmi:///jndi/rmi://localhost:7199/jmxrmi"`
          </td>

          <td>
            N/A
          </td>

          <td style={{ "text-align": "center" }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **COLLECTION_FILES**
            </DNT>
          </td>

          <td>
            Una lista separada por comas de rutas de archivo completas a los archivos de definición de la colección métrica. Para la instalación en el host, el archivo de colección métrica JVM predeterminado está en `/etc/newrelic-infra/integrations.d/jvm-metrics.yml`.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **COLLECTION_CONFIG**
            </DNT>
          </td>

          <td>
            Configuración de la colección métrica como JSON.

            Ejemplo de JVM:

            ```
            COLLECTION_CONFIG='{"collect":[{"domain":"java.lang","event_type":"JVMSample","beans":[{"query":"type=GarbageCollector,name=*","attributes":["CollectionCount","CollectionTime"]},{"query":"type=Memory","attributes":["HeapMemoryUsage.Committed","HeapMemoryUsage.Init","HeapMemoryUsage.Max","HeapMemoryUsage.Used","NonHeapMemoryUsage.Committed","NonHeapMemoryUsage.Init","NonHeapMemoryUsage.Max","NonHeapMemoryUsage.Used"]},{"query":"type=Threading","attributes":["ThreadCount","TotalStartedThreadCount"]},{"query":"type=ClassLoading","attributes":["LoadedClassCount"]},{"query":"type=Compilation","attributes":["TotalCompilationTime"]}]}]}'
            ```

            Ejemplo de Tomcat:

            ```
            COLLECTION_CONFIG={"collect":[{"domain":"Catalina","event_type":"TomcatSample","beans":[{"query":"type=UtilityExecutor","attributes":["completedTaskCount"]}]}]}
            ```

            `COLLECTION_CONFIG` Es útil para [configurar nri-jmx en Kubernetes usando anotaciones](#metrics-collection-kubernetes-annotations%5D).
          </td>

          <td>
            N/A
          </td>

          <td style={{ "text-align": "center" }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **KEY_STORE**
            </DNT>
          </td>

          <td>
            La ruta del archivo del almacén de claves que contiene el certificado SSL del cliente JMX.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **KEY_STORE_PASSWORD**
            </DNT>
          </td>

          <td>
            La contraseña para el almacén de claves SSL.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **LOCAL_ENTITY**
            </DNT>
          </td>

          <td>
            Recoger todas las métricas de la entidad local. Úselo únicamente cuando monitoree localhost.
          </td>

          <td>
            `false`
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **TIMEOUT**
            </DNT>
          </td>

          <td>
            El tiempo de espera de la consulta JMX individual, en milisegundos.
          </td>

          <td>
            10000
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **TRUST_STORE**
            </DNT>
          </td>

          <td>
            La ruta del archivo del almacén de claves que contiene el certificado SSL del servidor JMX.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **TRUST_STORE_PASSWORD**
            </DNT>
          </td>

          <td>
            La contraseña del almacén de confianza.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **METRIC_LIMIT**
            </DNT>
          </td>

          <td>
            Número de métricas que se pueden cobrar por entidad. Si se excede este límite la entidad no será reportada. Un límite de 0 implica que no hay límite.
          </td>

          <td>
            200
          </td>

          <td style={{ 'text-align': 'center' }}>
            M/I
          </td>
        </tr>

        <tr>
          <td>
            <DNT>
              **METRICS**
            </DNT>
          </td>

          <td>
            Establezca en `true` para habilitar la recopilación solo métrica.
          </td>

          <td>
            `false`
          </td>

          <td style={{ 'text-align': 'center' }}/>
        </tr>

        <tr>
          <td>
            <DNT>
              **INVENTORY**
            </DNT>
          </td>

          <td>
            Configúrelo en `true` para habilitar la recopilación solo de inventario.
          </td>

          <td>
            `false`
          </td>

          <td style={{ 'text-align': 'center' }}/>
        </tr>
      </tbody>
    </table>

    Los valores para estas configuraciones se pueden definir de varias maneras:

    * Agregando el valor directamente en el archivo de configuración. Esta es la forma más común.
    * Reemplazar los valores de las variables de entorno usando la notación `{{}}` . Esto requiere el agente de infraestructura v1.14.0 o superior. Lea más [aquí](/docs/infrastructure/install-infrastructure-agent/configuration/configure-infrastructure-agent/#passthrough) o vea el [ejemplo a continuación](#example4).
    * Utilizando la gestión de secretos. Utilícelo para proteger información sensible (como contraseñas) para que no quede expuesta en texto sin formato en el archivo de configuración. Para obtener más información, consulte [gestión de secretos](/docs/integrations/host-integrations/installation/secrets-management).
  </Collapser>

  <Collapser
    id="labels"
    title="Etiquetas y atributos personalizados"
  >
    También puedes personalizar tus etiquetas. Agregue valor principal par atributo a su métrica, que luego puede usar para consultar, filtrar o agrupar su métrica.

    Nuestro archivo de configuración de muestra predeterminado tiene ejemplos de etiquetas. Estos no son obligatorios y puede eliminar, modificar o agregar otros nuevos que desee.

    ```
    labels:
       env: production
       role: jmx
    ```
  </Collapser>
</CollapserGroup>

### limas de colección métricas [#metrics-collection]

Los archivos de definición de colección de métricas son archivos YAML estructurados que le indican a la integración qué métrica recopilar. Para ver un ejemplo de configuración, consulte el [ejemplo del archivo de colección métrica](#collection-example).

Archivo de colección métrica JVM predeterminado: `/etc/newrelic-infra/integrations.d/jvm-metrics.yml`

<Callout variant="tip">
  Puede escribir diferentes archivos de colección para facilitar la organización y el mantenimiento. Consulte [el archivo de configuración](#collection-example) para ver un ejemplo.
</Callout>

<CollapserGroup>
  <Collapser
    id="domains"
    title="Dominio"
  >
    La integración recoge y organiza métrica según dominio. Todas las métricas definidas por dominio se enviarán a New Relic y se podrán encontrar en el tipo de evento correspondiente. Este tipo de evento se genera automáticamente o puede ser configurado por el usuario. Cada archivo contiene un único bloque `collect:` que contiene una matriz de dominio. Para cada dominio, se definen las siguientes claves:

    * `domain`: El dominio JMX; por ejemplo, `java.lang`. Puede utilizar comodines para hacer coincidir múltiples dominios; por ejemplo, `java.*`. Si utiliza un comodín, se requiere `event_type` y debe ser único. Este campo es obligatorio.
    * `event_type`: el nombre [del tipo de evento](/docs/data-apis/understand-data/new-relic-data-types/#event-data) para una colección de este dominio. Si el dominio tiene un comodín, es obligatorio y debe ser único. Si el dominio no tiene comodines y el usuario no lo define, se generará automáticamente. Por ejemplo, el dominio `java.lang` tendrá el tipo de evento `JavaLangSample`. Para obtener más información, consulte [Consejos para nombrar](#data-naming).
    * `beans`: Una matriz de [frijoles](#metrics-collection) para recolectar en este dominio.

      <Callout variant="important">
        Hay un límite de 200 métricas por instancia en el archivo de configuración. Si excede el límite para una instancia en particular, no se enviará a New Relic. Si no ves tus datos en New Relic, revisa los [procedimientos de resolución de problemas](#troubleshoot) para identificar si has excedido el límite.
      </Callout>
  </Collapser>

  <Collapser
    id="beans"
    title="Frijoles"
  >
    Cada dominio contiene una matriz de [frijoles](https://pubs.vmware.com/vfabric5/index.jsp?topic=/com.vmware.vfabric.hyperic.4.6/JMX_MBean_Query_for_JVMs.html) que se deben recolectar. Para cada bean, se definen las siguientes claves:

    * `query`: El nombre del frijol a recolectar; por ejemplo,`type=GarbageCollector,name=YoungGen`. Puedes utilizar comodines; por ejemplo, `type=GarbageCollector,name=*`. Este campo es obligatorio.
    * `exclude_regex`: una lista opcional de patrones de expresiones regulares que coinciden con beans para excluir de la colección; por ejemplo, `type=GarbageCollector,name=.*`.
    * `attributes`: Una lista de [atributos](#attributes) para recopilar. Si no se especifica, recopila todos los atributos.

      <Callout variant="important">
        Los tipos de datos `HashMap` y `ArrayList` no son compatibles.
      </Callout>
  </Collapser>

  <Collapser
    id="attributes"
    title="Atributo"
  >
    Cada bean puede contener atributo, una lista opcional de beans que pueden excluirse de la colección. Para cada atributo, se definen las siguientes claves:

    <Callout variant="important">
      Para el atributo de mapa, debe definir una clave `attr` o `attr_regex` .
    </Callout>

    * `attr`: una coincidencia exacta del nombre del atributo. Los atributos compuestos se pueden recopilar añadiendo el nombre del miembro compuesto al nombre del atributo con un punto; por ejemplo, `HeapMemoryUsage.Max`.

    * `attr_regex`: un patrón de expresión regular que coincide con el atributo que se va a recopilar.

    * `metric_type`: El tipo de métrica New Relic para recopilar este atributo. Las opciones son:

      * `gauge`: los datos se recopilarán como una medición numérica instantánea.
      * `rate`: los datos se recopilarán como el cambio en esa métrica por segundo.
      * `delta`: los datos se recopilarán como el cambio en esa métrica desde la última medición.
      * `attribute`: los datos se recopilarán como una cadena literal.

      Si no se especifica, la integración JMX intentará inferir el tipo de métrica en función del valor devuelto. Por ejemplo, si la métrica es un número, lo recopilará como `gauge`. Si la métrica es una cadena, la recopilará como `attribute`.

      Si se recopilan métricas con un tipo de métrica incorrecto, puede especificar manualmente el tipo de métrica correcto en el archivo de recopilación.

    * `metric_name`: El nombre bajo el cual aparecerá la métrica en New Relic. Si no se especifica, el valor predeterminado será el nombre del atributo.

      Para obtener más información sobre la consulta JMX, consulte la documentación [de Oracle ObjectName](https://docs.oracle.com/javase/7/docs/api/javax/management/ObjectName.html) .
  </Collapser>
</CollapserGroup>

### Configuración de colección usando anotaciones de Kubernetes [#metrics-collection-kubernetes-annotations]

Puede utilizar anotaciones de Kubernetes para proporcionar la configuración de la colección. Para lograr esto, debe implementar un `configMap` en el clúster de Kubernetes que creará el archivo de configuración para la aplicación `nri-jmx` .

En este archivo de configuración, debe especificar el comando para [el descubrimiento automático de contenedores](/docs/integrations/host-integrations/installation/container-auto-discovery), que le permitirá usar el marcador de posición en la configuración de integración, incluidas las anotaciones de Kubernetes.

Ejemplo de un `configMap` para monitor JVM en una aplicación Tomcat:

<CollapserGroup>
  <Collapser
    id="jmx-configuration-configmap-example-using-helm"
    title="Ejemplo de configMap usando gráficos de timón (recomendado)"
  >
    ```yaml
    nri-bundle:
      newrelic-infrastructure:
        integrations_config:
          - name: jmx-config.yml
            data:
              discovery:
                command:
                  # Use the following optional arguments:
                  # --namespaces: Comma separated list of namespaces to discover pods on
                  # --tls: Use secure (TLS) connection
                  # --port: Port used to connect to the kubelet. Default is 10255
                  exec: /var/db/newrelic-infra/nri-discovery-kubernetes
                  match:
                    label.app: java
              integrations:
                - name: nri-jmx
                  env:
                    # Using the discovered IP as the host address
                    JMX_HOST: ${discovery.ip}
                    JMX_PORT: ${discovery.port}
                    COLLECTION_CONFIG: ${discovery.annotation.newrelic.config}
    ```

    Obtenga más información sobre cómo monitorear la integración en el host [aquí](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle#monitor-on-host-integrations)
  </Collapser>

  <Collapser
    id="jmx-configuration-configmap-example-plain-manifest"
    title="Ejemplo de configMap usando manifiesto simple"
  >
    ```yaml
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: nri-integration-cfg
    data:
      jmx-config.yml: |
        ---
        # Run auto discovery to find pods with label "app=java"
        discovery:
          command:
            # Use the following optional arguments:
            # --namespaces: Comma separated list of namespaces to discover pods on
            # --tls: Use secure (TLS) connection
            # --port: Port used to connect to the kubelet. Default is 10255
            exec: /var/db/newrelic-infra/nri-discovery-kubernetes
            match:
              label.app: java
        integrations:
          - name: nri-jmx
            env:
              # Using the discovered IP as the host address
              JMX_HOST: ${discovery.ip}
              JMX_PORT: ${discovery.port}
              COLLECTION_CONFIG: ${discovery.annotation.newrelic.config}
    ```
  </Collapser>
</CollapserGroup>

A continuación, utilice anotaciones para definir la configuración de la colección. Por ejemplo, aquí hay un despliegue de Tomcat con anotaciones:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tomcat-deployment
  labels:
    app: java
spec:
  replicas: 1
  selector:
    matchLabels:
      app: java
  template:
    metadata:
      annotations:
        newrelic.config: >-
          {
            "collect": [
              {
                "domain": "java.lang",
                "event_type": "JVMSample",
                "beans": [
                  {
                    "query": "type=GarbageCollector,name=*",
                    "attributes": [
                      "CollectionCount",
                      "CollectionTime"
                    ]
                  },
                  {
                    "query": "type=Memory",
                    "attributes": [
                      "HeapMemoryUsage.Committed",
                      "HeapMemoryUsage.Init",
                      "HeapMemoryUsage.Max",
                      "HeapMemoryUsage.Used",
                      "NonHeapMemoryUsage.Committed",
                      "NonHeapMemoryUsage.Init",
                      "NonHeapMemoryUsage.Max",
                      "NonHeapMemoryUsage.Used"
                    ]
                  },
                  {
                    "query": "type=Threading",
                    "attributes": [
                      "ThreadCount",
                      "TotalStartedThreadCount"
                    ]
                  },
                  {
                    "query": "type=ClassLoading",
                    "attributes": [
                      "LoadedClassCount"
                    ]
                  },
                  {
                    "query": "type=Compilation",
                    "attributes": [
                      "TotalCompilationTime"
                    ]
                  }
                ]
              }
            ]
          }
      labels:
        app: java
    spec:
      containers:
        - name: tomcat
          image: tomcat:10.0.12
          ports:
            - containerPort: 9999
          env:
            - name: CATALINA_OPTS
              value: '-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false'
```

### Conectores personalizados [#custom-connector]

JMX permite el uso de conectores personalizados para comunicarse con la aplicación. Para utilizar un conector personalizado, debe incluir los conectores personalizados en la ruta de clase nrjmx.

De forma predeterminada, la subcarpeta `connectors` está en la ruta de clase. Si esta carpeta no existe, créela en la carpeta donde está instalado nrjmx.

Por ejemplo, para agregar soporte para JBoss, cree una carpeta llamada `connectors` en la ruta de la biblioteca predeterminada (Linux) `/usr/lib/nrjmx/` (`/usr/lib/nrjmx/connectors/`) y copie el archivo jar del conector personalizado (`$JBOSS_HOME/bin/client/jboss-cli-client.jar`) en ella. Ahora puede ejecutar consulta JMX contra JBoss.

## Configuración de ejemplo [#example-config]

Configuración de archivo de ejemplo para una instalación en el host:

<CollapserGroup>
  <Collapser
    id="host-connection-example"
    title="Ejemplo de archivo de conexión de host"
  >
    ```
    integrations:
    - name: nri-jmx
      env:
        COLLECTION_FILES: "/etc/newrelic-infra/integrations.d/jvm-metrics.yml,/etc/newrelic-infra/integrations.d/tomcat-metrics.yml"
        JMX_HOST: jmx-host.localnet
        JMX_PASS: admin
        JMX_PORT: 9999
        JMX_USER: admin
      interval: 15s
      labels:
        env: production
    ```
  </Collapser>

  <Collapser
    id="collection-example"
    title="Ejemplo de archivo de colección métrica"
  >
    ```
    collect:
                # The event type for this domain will be JavaLangSample
              - domain: java.lang
                beans:
                    # Collect all beans of type Threading
                  - query: type=Threading
                    # Attributes can be either a string or a map
                    attribute:
                          # When unspecified, the metric_type is inferred
                          # and the metric name is just the attribute name
                        - ThreadCount
                          # If using a map attribute, a custom metric name can be set
                        - attr: TotalStartedThreadCount
                          metric_name: ThreadsStarted
                          # Attributes can be collected with regex matches and
                          # the metric type can be overridden if the integration
                          # can not correctly infer the type
                        - attr_regex: "ThreadCpu.*Enabled"
                          metric_type: attribute
                  - query: type=Memory
                    attributes:
                          # Composite attributes can be collected with this syntax
                        - HeapMemoryUsage.Max
                        - NonHeapMemoryUsage.Max
                    # Queries can be wildcarded where
                  - query: type=GarbageCollector,name=*
                    # If a specific bean is unwanted, it can be excluded
                    # with a regex match pattern. Useful if using a wildcard query
                    exclude_regex:
                          # This will match any bean where the name is YoungGen
                        - name=YoungGen
                    attributes:
                        - attr: LastGcInfo.GcThreadCount
                          metric_type: gauge
                          metric_name: GCThreadCount
                # Domains can be wildcarded
              - domain: java.util.*
                # If the domain is wildcarded, a custom event must be defined
                event_type: JavaUtilSample
                beans:
                      # If no attributes are defined, all are collected by default
                    - query: type=Logging
    ```
  </Collapser>
</CollapserGroup>

Para obtener más información sobre la estructura general de la configuración de integración en el host, consulte [Configuración](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview).

### Nombrando tus datos [#data-naming]

Métrica se envían y almacenan en forma de muestras. Esta es una lista de pares de valores principales que incluyen datos métricos y metadatos. Cada muestra se almacena como un [evento](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic) en nuestra base de datos.

Usted es responsable de crear y nombrar los datos JMX reportados a New Relic. Por esta razón, New Relic recomienda encarecidamente seguir estas convenciones al nombrar sus tipos de eventos. Para asegurarse de tener un esquema de nomenclatura coherente:

* Utilice estuche camello.
* Utilice un nombre que identifique claramente qué datos contiene.

Ejemplo: `MyorgApplicationSample`

<DNT>**Recommendation:**</DNT> Utilice el mismo esquema de nomenclatura para métricas similares en diferentes aplicaciones.

## Buscar y utilizar datos [#find-and-use]

Los datos de este servicio se informan a un [dashboard de integración](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts).

Los datos JMX se adjuntan al [tipo de evento](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic) definido por el usuario especificado en el [archivo de configuración](#metrics-collection). Por ejemplo, si está interesado en monitorear Tomcat usando la integración JMX, defina un `event_type` llamado `TomcatSample` y [consulte ese tipo de evento](/docs/using-new-relic/data/understand-data/query-new-relic-data).

Puede [consultar estos datos](/docs/using-new-relic/data/understand-data/query-new-relic-data) para fines de resolución de problemas o para crear gráficos y paneles personalizados.

Para obtener más información sobre cómo encontrar y utilizar sus datos, consulte [Comprender los datos de integración](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Datos métricos [#metrics]

Las métricas generadas por la integración incluyen metadatos asociados con el [MBean](https://pubs.vmware.com/vfabric5/index.jsp?topic=/com.vmware.vfabric.hyperic.4.6/JMX_MBean_Query_for_JVMs.html) del que están recopilando. Puede utilizar estos metadatos en [consultas NRQL](/docs/insights/nrql-new-relic-query-language/using-nrql/introduction-nrql) para filtrar y facetar los datos de modo que la consulta devuelva solo los datos de los beans deseados. También se puede utilizar para identificar de forma única las métricas, ya que el nombre de la métrica no es necesariamente único entre todos los beans.

Cada evento contiene los siguientes metadatos:

<table>
  <thead>
    <tr>
      <th style={{ width: "180px" }}>
        Nombre
      </th>

      <th>
        Descripción
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `displayName`
      </td>

      <td>
        El nombre de dominio JMX para estas métricas.
      </td>
    </tr>

    <tr>
      <td>
        `entityName`
      </td>

      <td>
        El nombre de dominio JMX para estas métricas con el tipo de entidad “dominio:” antepuesto.
      </td>
    </tr>

    <tr>
      <td>
        `host`
      </td>

      <td>
        El host JMX del que se están recopilando las métricas.
      </td>
    </tr>

    <tr>
      <td>
        `query`
      </td>

      <td>
        La consulta sirve para recoger estas métricas.
      </td>
    </tr>

    <tr>
      <td>
        `bean`
      </td>

      <td>
        El frijol de cuyo atributo se recolectaron estas métricas.
      </td>
    </tr>

    <tr>
      <td>
        `key:<mbean_key>`
      </td>

      <td>
        Para cada clave en el nombre del bean, se agrega un atributo al conjunto métrico llamado `“key:<mbean_key>` con el valor de la clave del bean.
      </td>
    </tr>
  </tbody>
</table>

### Ejemplo de consulta NRQL

Aquí hay un ejemplo de consulta [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) que aprovecha el monitor de metadatos de todo el recolector de basura JVM recolectado:

```
SELECT latest(CollectionTime)
FROM JVMSample
FACET `key:name`
WHERE `key:type` = 'GarbageCollector'
```

### Atributo de datos métricos [#metrics-attributes]

La integración JMX recopila los siguientes datos métricos del atributo:

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nombre
      </th>

      <th>
        Descripción
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `HeapMemoryUsage.Used`
      </td>

      <td>
        La memoria dinámica total de Java utilizada.
      </td>
    </tr>

    <tr>
      <td>
        `HeapMemoryUsage.Committed`
      </td>

      <td>
        La memoria dinámica total de Java comprometida para ser utilizada.
      </td>
    </tr>

    <tr>
      <td>
        `HeapMemoryUsage.Init`
      </td>

      <td>
        La memoria del montón de Java inicial asignada.
      </td>
    </tr>

    <tr>
      <td>
        `HeapMemoryUsage.Max`
      </td>

      <td>
        La memoria dinámica máxima de Java disponible.
      </td>
    </tr>

    <tr>
      <td>
        `NonHeapMemoryUsage.Used`
      </td>

      <td>
        La memoria total no dinámica de Java utilizada.
      </td>
    </tr>

    <tr>
      <td>
        `NonHeapMemoryUsage.Committed`
      </td>

      <td>
        La memoria total no dinámica de Java comprometida para ser utilizada.
      </td>
    </tr>

    <tr>
      <td>
        `NonHeapMemoryUsage.Init`
      </td>

      <td>
        La memoria inicial no dinámica de Java asignada.
      </td>
    </tr>

    <tr>
      <td>
        `NonHeapMemoryUsage.Max`
      </td>

      <td>
        La memoria máxima no dinámica de Java disponible.
      </td>
    </tr>

    <tr>
      <td>
        `ThreadCount`
      </td>

      <td>
        El número de hilos activos.
      </td>
    </tr>

    <tr>
      <td>
        `CollectionCount`
      </td>

      <td>
        El número total de recolecciones de basura que se han producido.
      </td>
    </tr>

    <tr>
      <td>
        `CollectionTime`
      </td>

      <td>
        Transcurrido el tiempo aproximado de recolección de basura acumulada.
      </td>
    </tr>
  </tbody>
</table>

## Datos de inventario [#inventory]

La integración JMX captura el parámetro de configuración de la integración JMX. Los datos están disponibles en la [página Inventario](/docs/infrastructure/new-relic-infrastructure/infrastructure-ui-pages/infrastructure-inventory-page-search-your-entire-infrastructure), en la fuente <DNT>**config/jmx**</DNT> . Para obtener más información sobre los datos de inventario, consulte [Comprender los datos de integración](/docs/infrastructure/integrations-getting-started/getting-started/understand-integration-data-data-types#inventory-data).

## Resolución de problemas [#troubleshoot]

Consejos para la resolución de problemas:

<CollapserGroup id="troubleshooting-list">
  <Collapser
    id="integration-errors"
    title="Registro de búsqueda de errores"
  >
    Si tiene problemas con la integración, primero [habilite y busque errores en el registro](/docs/infrastructure/new-relic-infrastructure/troubleshooting/generate-logs-troubleshooting-infrastructure) .
  </Collapser>

  <Collapser
    id="metrics-limit"
    title="límite métrico excedido"
  >
    Si sospecha que hay un dominio enviando más de 200 métricas, consulte el [archivo de registro](/docs/infrastructure/new-relic-infrastructure/troubleshooting/generate-logs-troubleshooting-infrastructure) para ver este mensaje:

    ```
    "Domain x has n metrics, the current limit is 200. This domain will not be reported."
    ```

    Si ve este mensaje de error, reduzca la cantidad de métricas que se envían para el dominio reportado.
  </Collapser>

  ' '

  <Collapser
    id="missing-metrics"
    title="Falta métrica"
  >
    Si le falta métrica, asegúrese de que la consulta MBean sea válida intentando ejecutarla con la [herramienta nrjmx](https://github.com/newrelic/nrjmx) o utilice su herramienta preferida para garantizar que la consulta sea válida en JMXConsole.
  </Collapser>

  ' '

  <Collapser
    id="missing-dashboard"
    title="Dashboard no aparece en UIde la infraestructura."
  >
    Confirme que el archivo de configuración `jvm-metrics.yml` se haya actualizado y que la ruta al archivo esté enumerada en el archivo `jmx-config.yml` .
  </Collapser>

  <Collapser
    id="jmxterm"
    title="Resolución de problemas vía JMXTerm"
  >
    [JMXTerm](https://docs.cyclopsgroup.org/jmxterm) es una herramienta interactiva CLI que se utiliza para la resolución de problemas. Encuentre documentación para JMXTerm en nuestra [`nrjmx` página de resolución de problemas](https://github.com/newrelic/nrjmx/blob/master/TROUBLESHOOT.md). A partir de `nrjmx` v1.7.0, JMXTerm ya no está incluido con `nrjmx` y debe descargarse de forma independiente. Consulta las \[`nrjmx` instrucciones de instalación] ([https://github.com/newrelic/nrjmx#instalación](https://github.com/newrelic/nrjmx#installation)).
  </Collapser>
</CollapserGroup>

## Comprueba el código fuente [#source-code]

Esta integración es software de código abierto. Eso significa que puedes [explorar su código fuente](https://github.com/newrelic/nri-jmx) y enviar mejoras, o crear tu propia bifurcación y compilarla.
