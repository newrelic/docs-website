---
title: MongoDB monitoreo integración (legacy)
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: 'The legacy New Relic MongoDB integration: how to install it and configure it, and what data it reports.'
freshnessValidatedDate: never
translationType: machine
---

<Callout title="¡IMPORTANTE!">
  Esta integración legacy llegará al final de su vida útil en 2024: agregaremos una fecha de EOL específica cuando la sepamos. Recomendamos utilizar nuestra nueva [integración MongoDB](/docs/infrastructure/host-integrations/host-integrations-list/mongodb/mongodb-monitoring-integration-new). Para obtener información sobre cómo cambiar de la integración legacy a la nueva, consulte nuestros [documentos de migración](/docs/infrastructure/host-integrations/host-integrations-list/mongodb/mongodb-migration-guide).
</Callout>

Nuestra integración MongoDB legacy recopila y envía inventario y métricas de su clúster MongoDB a nuestra plataforma, donde puede agregar y visualizar el rendimiento métrico clave. Recopilamos datos en `mongos` y `mongod` instancia, servidores de configuración, así como en base de datos y colecciones para ayudar a identificar el rendimiento de la botella.

## Compatibilidad y requisitos [#comp-req]

Esta integración legacy es compatible con MongoDB v3 y v4. Nuestra [nueva integración de MongoDB](/docs/infrastructure/host-integrations/host-integrations-list/mongodb/mongodb-monitoring-integration-new) admite versiones más nuevas.

Antes de instalar esta integración legacy, asegúrese de cumplir con los siguientes requisitos:

* Una cuenta New Relic . ¿No tienes uno? [¡Registrate gratis!](https://newrelic.com/signup) No se requiere tarjeta de crédito.

* Usuario de MongoDB con [roles`clusterMonitor` y `listCollections` ](#users-privileges).

* Si MongoDB **no** se ejecuta en Kubernetes o Amazon ECS, debe [instalar el agente de infraestructura](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic) en un host que ejecute MongoDB. De lo contrario:

  * Si se ejecuta en Kubernetes, consulte [estos requisitos](/docs/monitor-service-running-kubernetes#requirements).
  * Si se ejecuta en ECS, consulte [estos requisitos](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).

## Instalar y activar [#install]

Si desea instalar nuestra integración MongoDB legacy, siga las instrucciones para su entorno:

<CollapserGroup>
  <Collapser
    id="ecs-install"
    title="ECS"
  >
    Consulte [Servicio de monitorización ejecutándose en ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
  </Collapser>

  ' '

  <Collapser
    id="k8s-install"
    title="Kubernetes"
  >
    Consulte [Supervisar el servicio que se ejecuta en Kubernetes](/docs/monitor-service-running-kubernetes).
  </Collapser>

  <Collapser
    id="linux-install"
    title="Linux"
  >
    1. Instale [el agente de infraestructura](/docs/integrations/host-integrations/installation/install-infrastructure-host-integrations/#install) y reemplace la variable `INTEGRATION_FILE_NAME` con `nri-mongodb`.

    2. Cambiar directorio a la carpeta de integración:

       ```
       cd /etc/newrelic-infra/integrations.d
       ```

    3. Copia del archivo de configuración de muestra:

       ```
       sudo cp mongodb-config.yml.sample mongodb-config.yml
       ```

    4. Edite el archivo `mongodb-config.yml` como se describe en los [ajustes de configuración](#config).

    5. [Reinicie el agente de infraestructura](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).

    6. Para habilitar el análisis de errores de MongoDB automático y el reenvío, copie (o cambie el nombre) el archivo `mongodb-log.yml.example` a `mongodb-log.yml`. No es necesario reiniciar el agente.

       <DoNotTranslate>
         **Example:**
       </DoNotTranslate>

       ```
       sudo cp /etc/newrelic-infra/logging.d/mongodb-log.yml.example /etc/newrelic-infra/logging.d/mongodb-log.yml
       ```
  </Collapser>

  <Collapser
    id="windows-install"
    title="Windows"
  >
    1. Descargue la imagen del instalador `nri-mongodb` .MSI desde:

       [https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-mongodb/nri-mongodb-amd64.msi](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-mongodb/nri-mongodb-amd64.msi)

    2. Para instalar desde el símbolo del sistema de Windows, ejecute:

       ```
       msiexec.exe /qn /i PATH\TO\nri-mongodb-amd64.msi
       ```

    3. En el directorio de integración, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, cree una copia del archivo de configuración de muestra ejecutando:

       ```
       cp mongodb-config.yml.sample mongodb-config.yml
       ```

    4. Edite el archivo de configuración `mongodb-config.yml` usando los [ajustes de configuración](#config).

    5. [Reinicie el agente de infraestructura](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).
  </Collapser>
</CollapserGroup>

Notas adicionales:

* <DoNotTranslate>**Advanced:**</DoNotTranslate>

  integración también están disponibles en [formato tarball](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball) para permitir la instalación fuera de un administrador de paquetes.

* <DoNotTranslate>**On-host integrations do not automatically update.**</DoNotTranslate>

  Para obtener mejores resultados, [actualice periódicamente el paquete de integración](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) y [el agente de infraestructura](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

## Configuración [#configuration]

### Habilitando su servidor MongoDB [#enable-instance]

En el [shell de MongoDB](https://docs.mongodb.com/manual/mongo/), ejecute los siguientes comandos para crear un rol `listCollections` y un nuevo usuario. Luego, asigne los roles `clusterMonitor` y `listCollections` al nuevo usuario. Nota: Reemplace el nombre de usuario, la contraseña y valores específicos de usuario similares.

Consulte la documentación de MongoDB para obtener detalles sobre [la creación de usuarios](https://docs.mongodb.com/manual/reference/method/db.createUser/index.html) y [roles](https://docs.mongodb.com/manual/reference/method/db.createRole/index.html).

<Callout variant="tip">
  Complete estos pasos en los mongos a monitorear. Si se van a recopilar métricas a nivel de mongod, como estadísticas de host o conjunto de réplicas, cree también el rol y el usuario en cada mongod.
</Callout>

1. En el shell de MongoDB, ingrese `use admin`.

2. Utilice el siguiente comando para crear el rol `listCollections` .

   ```
   db.createRole({
       role: "listCollections",
       privileges: [{
           resource: {db:"",collection:""},
           actions: ["listCollections"]
       }],
       roles: []
   })
   ```

3. Utilice los siguientes comandos para crear un nuevo usuario y asignarle los roles `clusterMonitor` y `listCollections` .

   ```
   db.createUser({
       user: "username",
       pwd: "password",
       roles: [
           "clusterMonitor",
           "listCollections"
       ]
   })
   ```

<InstallFeedback/>

### Configurar la integración [#config]

Hay varias formas de configurar la integración, dependiendo de cómo se instaló:

* Si está habilitado a través de Kubernetes: consulte [Supervisar servicios que se ejecutan en Kubernetes](/docs/monitor-service-running-kubernetes).
* Si está habilitado a través de Amazon ECS: consulte [Servicios de monitorización que se ejecutan en ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
* Si está instalado en el host: edite la configuración en el archivo de configuración YAML de la integración, `mongodb-config.yml`.

La configuración de formato YAML de una integración es donde puede colocar las credenciales de inicio de sesión requeridas y configurar cómo se recopilan los datos. Las opciones que cambie dependen de su configuración y preferencia.

El archivo de configuración tiene configuraciones comunes aplicables a todas las integraciones, como `interval`, `timeout`, `inventory_source`. Para leer todo sobre estas configuraciones comunes, consulte nuestro documento [Formato de configuración](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) .

<Callout variant="important">
  Si todavía estás usando nuestros archivos de configuración/definición legacy, consulta [el formato de configuración estándar](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/) para obtener ayuda.
</Callout>

Las configuraciones específicas relacionadas con MongoDB se definen usando la sección `env` del archivo de configuración. Estas configuraciones controlan la conexión a su instancia de MongoDB, así como otras configuraciones y características de seguridad. La lista de configuraciones válidas se describe en la siguiente sección de este documento.

La integración de MongoDB se puede configurar para monitor un clúster de MongoDB completo o una instancia de MongoDB independiente. Para monitor un clúster, los [argumentos](#arguments) `host` y `port` deben apuntar a una de las `mongos` instancias en su clúster. Si desea monitor una instancia independiente, asegúrese de que `host` y `port` apunten al `mongod` que ejecuta la base de datos.

<Callout variant="tip">
  La autenticación SCRAM no es compatible.
</Callout>

### Configuración de la instancia de MongoDB [#instance-settings]

La integración MongoDB recopila información tanto métrica como de inventario. En la siguiente tabla, consulte la columna <DoNotTranslate>**Applies To**</DoNotTranslate> para conocer la configuración disponible para cada colección.

Los valores para estas configuraciones se pueden definir de varias maneras:

* Agregando el valor directamente en el archivo de configuración. Esta es la forma más común.
* Reemplazar los valores de las variables de entorno usando la notación `{{}}` . Esto requiere el agente de infraestructura v1.14.0 o superior. Para obtener más información, consulte nuestra documentación sobre [el paso a través](/docs/infrastructure/install-infrastructure-agent/configuration/configure-infrastructure-agent/#passthrough) o consulte el [ejemplo de reemplazo](#envvar-replacement).
* Utilizando la gestión de secretos. Utilícelo para proteger información confidencial, como contraseñas que quedarían expuestas en texto sin formato en el archivo de configuración. Para obtener más información, consulte [Gestión de secretos](/docs/integrations/host-integrations/installation/secrets-management).

' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '

<table>
  <thead>
    <tr>
      <th style={{ width: '150px' }}>
        Configuración
      </th>

      <th>
        Descripción
      </th>

      <th>
        Se aplica a
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <DoNotTranslate>
          **MONGODB_CLUSTER_NAME**
        </DoNotTranslate>
      </td>

      <td>
        Nombre definido por el usuario para identificar de forma única el clúster que se está monitoreando. <DoNotTranslate>**Required**</DoNotTranslate>.
      </td>

      <td>
        Métrica/Inventario
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **HOST**
        </DoNotTranslate>
      </td>

      <td>
        Nombre de host o IP donde se está ejecutando MongoDB. El valor predeterminado es `localhost`.
      </td>

      <td>
        Métrica/Inventario
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **PORT**
        </DoNotTranslate>
      </td>

      <td>
        Puerto en el que MongoDB está escuchando. El valor predeterminado es 27017.
      </td>

      <td>
        Métrica/Inventario
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **USERNAME**
        </DoNotTranslate>
      </td>

      <td>
        Nombre de usuario para acceder al servidor MongoDB.
      </td>

      <td>
        Métrica/Inventario
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **PASSWORD**
        </DoNotTranslate>
      </td>

      <td>
        Contraseña para el usuario dado.
      </td>

      <td>
        Métrica/Inventario
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **AUTH_SOURCE**
        </DoNotTranslate>
      </td>

      <td>
        La base de datos contra la que autenticarse. El valor predeterminado es `admin`.
      </td>

      <td>
        Métrica/Inventario
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **SSL**
        </DoNotTranslate>
      </td>

      <td>
        Utilice SSL cuando se comunique con el servidor MongoDB. El valor predeterminado es `false`.
      </td>

      <td>
        Métrica/Inventario
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **SSL_CA_CERTS**
        </DoNotTranslate>
      </td>

      <td>
        Ubicación del certificado SSL en el host. Solo es necesario si `SSL` es `true`.
      </td>

      <td>
        Métrica/Inventario
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **SSL_INSECURE_SKIP_VERIFY**
        </DoNotTranslate>
      </td>

      <td>
        Omita la verificación de la cadena de certificados y el nombre de host del servidor. El valor predeterminado es `false`.
      </td>

      <td>
        Métrica/Inventario
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **PEM_KEY_FILE**
        </DoNotTranslate>
      </td>

      <td>
        Ubicación del archivo PEM que contiene la clave privada y el certificado de cliente.
      </td>

      <td>
        Métrica/Inventario
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **PASSPHRASE**
        </DoNotTranslate>
      </td>

      <td>
        Frase de contraseña para descifrar el archivo `PEMKeyFile` .
      </td>

      <td>
        Métrica/Inventario
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **CONCURRENT_COLLECTIONS**
        </DoNotTranslate>
      </td>

      <td>
        Número de entidad para recolectar métrica simultáneamente. El valor predeterminado es 50.
      </td>

      <td>
        Métrica
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **FILTERS**
        </DoNotTranslate>
      </td>

      <td>
        Un mapa JSON de nombres de bases de datos a una matriz de nombres de colecciones. Si está vacío, el valor predeterminado es toda la base de datos y colecciones.
      </td>

      <td>
        Métrica
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **METRICS**
        </DoNotTranslate>
      </td>

      <td>
        Establezca en `true` para habilitar la recopilación solo métrica. El valor predeterminado es `false`.
      </td>

      <td/>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **INVENTORY**
        </DoNotTranslate>
      </td>

      <td>
        Configúrelo en `true` para habilitar la recopilación solo de inventario. El valor predeterminado es `false`.
      </td>

      <td/>
    </tr>
  </tbody>
</table>

### Etiquetas y atributos personalizados [#labels]

Puedes decorar aún más tu métrica usando etiquetas. Las etiquetas le permiten agregar valor par principal atributo a su métrica, que luego puede usar para consultar, filtrar o agrupar su métrica.

Nuestro archivo de configuración de muestra predeterminado incluye ejemplos de etiquetas; sin embargo, como no son obligatorios, puedes eliminar, modificar o agregar nuevos de tu elección.

```
 labels:
   env: production
   role: load_balancer
```

## Configuración de ejemplo [#examples]

<CollapserGroup>
  <Collapser
    id="basic-config"
    title="Configuración básica"
  >
    Esta es la configuración básica utilizada para recopilar métricas e inventario de su localhost:

    ```
    integrations:
      - name: nri-mongodb
        env:
          CLUSTER_NAME: my_cluster
          HOST: localhost
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          environment: production
        inventory_source: config/mongodb
    ```
  </Collapser>

  <Collapser
    id="basic-intervals"
    title="Configuración básica con diferentes intervalos métricos/de inventario."
  >
    Esta configuración recolecta métrica cada 15 segundos e inventario cada 60 segundos:

    ```
    integrations:
      - name: nri-mongodb
        env:
          METRICS: true
          CLUSTER_NAME: my_cluster
          HOST: localhost
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          environment: production

      - name: nri-mongodb
        env:
          INVENTORY: true
          CLUSTER_NAME: my_cluster
          HOST: localhost
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 60s
        labels:
          environment: production
        inventory_source: config/mongodb
    ```
  </Collapser>

  <Collapser
    id="envvar-replacement"
    title="Reemplazo de variables de entorno"
  >
    En esta configuración estamos usando la variable de entorno `MONGODB_HOST` para completar la configuración HOST de la integración:

    ```
    integrations:
      - name: nri-mongodb
        env:
          METRICS: "true"
          CLUSTER_NAME: my_cluster
          HOST: {{MONGODB_HOST}}
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
    ```
  </Collapser>

  <Collapser
    id="filters"
    title="Filtros"
  >
    En esta configuración utilizamos filtros para limitar la base de datos y las colecciones que monitor. Con este filtro de muestra la integración recogerá:

    * `db1` base de datos métrica y todas sus colecciones. Utilice `null` para recopilar todas las colecciones de una base de datos

    * `db2` base de datos métrica y métrica para `collection1` y `collection2`

    * `db3` base de datos métrica y no colección métrica. Utilice una matriz vacía `[]` si desea omitir la colección métrica

      ```
      integrations:
        - name: nri-mongodb
          env:
            METRICS: "true"
            CLUSTER_NAME: my_cluster
            HOST: localhost
            PORT: 27017
            USERNAME: mongodb_user
            PASSWORD: mongodb_password
            FILTERS: '{"db1":null,"db2":["collection1","collection2"],"db3:":[]}'
          interval: 15s
          labels:
            env: production
            role: load_balancer
      ```
  </Collapser>

  <Collapser
    id="multi-instance"
    title="Monitoreo multiinstancia"
  >
    En esta configuración estamos monitoreando múltiples servidores MongoDB desde la misma integración. Para la primera instancia (`HOST: 1st_mongodb_host`) recopilaremos métrica e inventario, mientras que para la segunda instancia (`HOST: 2nd_mongodb_host`) solo recopilaremos métrica.

    ```
    integrations:
      - name: nri-mongodb
        env:
          METRICS: "true"
          CLUSTER_NAME: my_cluster
          HOST: 1st_mongodb_host
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
      - name: nri-mongodb
        env:
          INVENTORY: "true"
          CLUSTER_NAME: my_cluster
          HOST: 1st_mongodb_host
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 60s
        labels:
          env: production
          role: load_balancer
        inventory_source: config/mongodb

      - name: nri-mongodb
        env:
          METRICS: "true"
          CLUSTER_NAME: my_2nd_cluster
          HOST: 2nd_mongodb_host
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
    ```
  </Collapser>
</CollapserGroup>

## Buscar y utilizar datos [#find-and-use]

Los datos de este servicio se informan a un [dashboard de integración](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts).

métricas se adjuntan a estos [tipos de eventos](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic):

* `MongoCollectionSample`
* `MongoConfigServerSample`
* `MongoDatabaseSample`
* `MongodTopSample`
* `MongoSample`
* `MongodSample`
* `MongosSample`

Puede [consultar estos datos](/docs/using-new-relic/data/understand-data/query-new-relic-data) para fines de resolución de problemas o para crear gráficos y paneles personalizados.

Para obtener más información sobre cómo encontrar y utilizar sus datos, consulte [Comprender los datos de integración](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Datos métricos [#metrics]

La integración MongoDB recopila el siguiente atributo de datos métricos. Algunos nombres de métricas tienen el prefijo de un indicador de categoría y un punto, como `asserts.` o `collection.`.

Se encuentran disponibles diferentes métricas dependiendo de si se está monitorizando un clúster o una instancia independiente. Para una instancia independiente, solo se recopilan [MongodSample](#mongod-clamshell), [MongoDatabaseSample](#mongo-database-clamshell), [MongodTopSample](#mongo-top-clamshell) y [MongoCollectionSample](#mongo-collection-clamshell) . Para un clúster, se recopilan todos los tipos de eventos.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="mongo-collection-clamshell"
    title="Muestra colección mongo métrica"
  >
    Estos atributos están adjuntos al tipo de evento `MongoCollectionSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `collection.avgObjSizeInBytes`
          </td>

          <td>
            El tamaño del objeto promedio de la colección, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `collection.capped`
          </td>

          <td>
            Si la colección está limitada o no.
          </td>
        </tr>

        <tr>
          <td>
            `collection.count`
          </td>

          <td>
            El número total de objetos de la colección.
          </td>
        </tr>

        <tr>
          <td>
            `collection.indexAccesses`
          </td>

          <td>
            El número de veces que se utilizó el índice.
          </td>
        </tr>

        <tr>
          <td>
            `collection.indexSizeInBytes`
          </td>

          <td>
            El tamaño del índice, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `collection.max`
          </td>

          <td>
            El número máximo de documentos en una colección limitada.
          </td>
        </tr>

        <tr>
          <td>
            `collection.maxSizeInBytes`
          </td>

          <td>
            El tamaño máximo de una colección limitada, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `collection.nindexes`
          </td>

          <td>
            El número total de índices de la colección.
          </td>
        </tr>

        <tr>
          <td>
            `collection.sizeInBytes`
          </td>

          <td>
            El tamaño total de los datos de la colección más el tamaño de cada índice de la colección, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `collection.storageSizeInBytes`
          </td>

          <td>
            El espacio de almacenamiento total asignado a esta colección para el almacenamiento de documentos, en bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongo-config-server-clamshell"
    title="Ejemplo de servidor de configuración Mongo métrica"
  >
    Estos atributos están adjuntos al tipo de evento `MongoConfigServerSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `asserts.messagesPerSecond`
          </td>

          <td>
            El número de afirmaciones de mensajes generadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.regularPerSecond`
          </td>

          <td>
            El número de afirmaciones regulares generadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.rolloversPerSecond`
          </td>

          <td>
            El número de veces que los contadores de rollover se dan vuelta. Los contadores se ponen a cero cada 2^30 afirmaciones por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.userPerSecond`
          </td>

          <td>
            El número de afirmaciones de usuario generadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.warningPerSecond`
          </td>

          <td>
            El número de advertencias generadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countFailedPerSecond`
          </td>

          <td>
            El número de veces que `count` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `count` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesFailedPerSecond`
          </td>

          <td>
            El número de veces que `createIndexes` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `createIndexe` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.deleteFailedPerSecond`
          </td>

          <td>
            El número de veces que `delete` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deletePerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `delete` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalFailedPerSecond`
          </td>

          <td>
            El número de veces que `eval` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `eval` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyFailedPerSecond`
          </td>

          <td>
            El número de veces que `findAndModify` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `findAndModify` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertFailedPerSecond`
          </td>

          <td>
            El número de veces que `insert` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `insert` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.updateFailedPerSecond`
          </td>

          <td>
            El número de veces que `update` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updatePerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `update` .
          </td>
        </tr>

        <tr>
          <td>
            `connections.available`
          </td>

          <td>
            La cantidad de conexiones entrantes disponibles no utilizadas que la base de datos puede proporcionar.
          </td>
        </tr>

        <tr>
          <td>
            `connections.current`
          </td>

          <td>
            El número de conexiones al servidor de la base de datos desde los clientes.
          </td>
        </tr>

        <tr>
          <td>
            `connections.totalCreated`
          </td>

          <td>
            El número total de conexiones creadas.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openNoTimeout`
          </td>

          <td>
            El número de cursores abiertos con la opción `DBQueryOptionnotimeout` configurada para evitar el tiempo de espera después de un período de inactividad.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openPinned`
          </td>

          <td>
            El número de cursores abiertos fijados.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openTotal`
          </td>

          <td>
            La cantidad de cursores que MongoDB mantiene para los clientes.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.timedOutPerSecond`
          </td>

          <td>
            El número total de cursores que han agotado el tiempo de espera desde que se inició el proceso del servidor.
          </td>
        </tr>

        <tr>
          <td>
            `document.deletedPerSecond`
          </td>

          <td>
            El número de documentos eliminados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.insertedPerSecond`
          </td>

          <td>
            El número de documentos insertados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.returnedPerSecond`
          </td>

          <td>
            El número de documentos devueltos por consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.updatedPerSecond`
          </td>

          <td>
            El número de documentos actualizados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commits`
          </td>

          <td>
            El número de transacciones escritas en el diario durante el último intervalo de confirmación del grupo de diarios.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a las confirmaciones, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLock`
          </td>

          <td>
            El recuento de confirmaciones que se produjeron mientras se mantenía un bloqueo de escritura.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLockInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a las confirmaciones que se produjeron mientras se mantenía un bloqueo de escritura, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.compression`
          </td>

          <td>
            La relación de compresión de los datos escritos en el diario.
          </td>
        </tr>

        <tr>
          <td>
            `dur.dataWrittenJournalDataFilesInBytes`
          </td>

          <td>
            La cantidad de datos escritos desde el diario en los archivos de datos durante el último intervalo de confirmación del grupo de diario, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.earlyCommits`
          </td>

          <td>
            La cantidad de veces que MongoDB ha solicitado una confirmación antes del intervalo de confirmación del grupo de diario programado.
          </td>
        </tr>

        <tr>
          <td>
            `dur.journaledInBytes`
          </td>

          <td>
            La cantidad de datos escritos en el diario durante el último intervalo de confirmación del grupo de diario, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.preparingInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a prepararse para escribir en la revista, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.remappingInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a reasignar vistas asignadas de memoria de copia en escritura, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.timeCollectedCommitsInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo durante el cual MongoDB recopiló los datos `durcommitsInMilliseconds`, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingDataFilesInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a escribir en archivos de datos después del registro en diario, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingJournalInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a escribir en la revista, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.averageInMilliseconds`
          </td>

          <td>
            El tiempo promedio de cada descarga al disco, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.flushesDisk`
          </td>

          <td>
            La cantidad de veces que la base de datos ha vaciado todas las escrituras en el disco.
          </td>
        </tr>

        <tr>
          <td>
            `flush.lastInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo que tardó en completarse la última operación de descarga, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.totalInMilliseconds`
          </td>

          <td>
            La cantidad total de tiempo que los procesos mongod han dedicado a escribir (es decir, vaciar) datos en el disco, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeMillisPerSecond`
          </td>

          <td>
            El número de `getLastError` operaciones con un problema de escritura específico (por ejemplo, `w`) que esperan a que uno o más miembros de un conjunto de réplicas reconozcan la operación de escritura por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeoutsPerSecond`
          </td>

          <td>
            El número de veces que se agotó el tiempo de espera de las operaciones de escritura como resultado del umbral de tiempo de espera de `getLastError` por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsReaders`
          </td>

          <td>
            El recuento de conexiones de clientes activas que realizan operaciones de lectura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsTotal`
          </td>

          <td>
            El número total de conexiones de clientes activas a la base de datos.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsWriters`
          </td>

          <td>
            El recuento de conexiones de clientes activas que realizan operaciones de escritura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueReaders`
          </td>

          <td>
            El número de operaciones que están actualmente en cola y esperando el bloqueo de lectura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueTotal`
          </td>

          <td>
            El número total de operaciones en cola esperando el bloqueo.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueWriters`
          </td>

          <td>
            El número de operaciones que están actualmente en cola y esperando el bloqueo de escritura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.totaltime`
          </td>

          <td>
            El tiempo desde que la base de datos se inició por última vez y creó el bloqueo global.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de candado de colección en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de colección en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de colección en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de colección en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de colección en el modo Exclusivo (X) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo de colección en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de colección en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de colección en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de la base de datos en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de la base de datos en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de la base de datos en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de la base de datos en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de la base de datos en el modo Exclusivo (X) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de la base de datos en el modo Intent Exclusive (IX) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentShared`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de la base de datos en el modo Intent Shared (IS) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitShared`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de la base de datos en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de la base de datos en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de la base de datos en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de la base de datos en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de la base de datos en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo global en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo global en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo global en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo global en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo global en el modo Exclusivo (X) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo global en el modo Intent Exclusive (IX) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo global en el modo Intent Shared (IS) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitShared`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo global en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo global en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo global en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo global en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo global en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de metadatos en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de metadatos en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitExclusive`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Exclusivo (X) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentExclusive`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Exclusive (IX) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Shared (IS) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de registro de operaciones en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de registro de operaciones en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del registro de operaciones en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de registro de operaciones en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitIntentExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo del registro de operaciones en el modo Intent Exclusive (IX) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del registro de operaciones en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de registro de operaciones en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de registro de operaciones en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `mem.bits`
          </td>

          <td>
            El tamaño del motor de almacenamiento en memoria.
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedInBytes`
          </td>

          <td>
            La cantidad de memoria asignada por la base de datos, en mebibytes (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedWithJournalInBytes`
          </td>

          <td>
            La cantidad de memoria asignada, incluida la memoria utilizada para el registro en diario, en mebibytes (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.residentInBytes`
          </td>

          <td>
            La cantidad de memoria utilizada actualmente por el proceso de la base de datos, en mebibytes (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.virtualInBytes`
          </td>

          <td>
            La cantidad de memoria virtual utilizada por el proceso mongod, en mebibytes (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesInPerSecond`
          </td>

          <td>
            La cantidad de bytes que refleja la cantidad de tráfico de red en esta base de datos.
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesOutPerSecond`
          </td>

          <td>
            La cantidad de bytes que refleja la cantidad de tráfico de red enviado desde esta base de datos.
          </td>
        </tr>

        <tr>
          <td>
            `network.requestsPerSecond`
          </td>

          <td>
            El número de solicitudes distintas que ha recibido el servidor.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.commandPerSecond`
          </td>

          <td>
            El número total de comandos emitidos a la base de datos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.deletePerSecond`
          </td>

          <td>
            El número de operaciones de eliminación por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.getmorePerSecond`
          </td>

          <td>
            El número de operaciones getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.insertPerSecond`
          </td>

          <td>
            El número de operaciones de inserción por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.queryPerSecond`
          </td>

          <td>
            El número total de consultas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.updatePerSecond`
          </td>

          <td>
            El número de operaciones de actualización por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.commandPerSecond`
          </td>

          <td>
            El número total de comandos replicados emitidos a la base de datos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.deletePerSecond`
          </td>

          <td>
            El número de operaciones de eliminación replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.getmorePerSecond`
          </td>

          <td>
            El número de operaciones getmore replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.insertPerSecond`
          </td>

          <td>
            El número de operaciones de inserción replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.queryPerSecond`
          </td>

          <td>
            El número total de consultas replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.updatePerSecond`
          </td>

          <td>
            El número de operaciones de actualización replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.fastmodPerSecond`
          </td>

          <td>
            El número de operaciones de actualización que no hacen que los documentos crezcan ni requieren actualizaciones del índice por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.idhackPerSecond`
          </td>

          <td>
            El número de consultas que contienen el campo `_id` por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.scanAndOrderPerSecond`
          </td>

          <td>
            El número de consultas que devuelven números ordenados que no pueden realizar la operación de clasificación utilizando un índice por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.writeConflictsPerSecond`
          </td>

          <td>
            El número de veces que las operaciones de escritura han encontrado un conflicto por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `pageFaultsPerSecond`
          </td>

          <td>
            La cantidad de errores de página que requieren operaciones de disco por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `queryexecutor.scannedPerSecond`
          </td>

          <td>
            El número de elementos de índice escaneados durante la consulta y la evaluación del plan de consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `record.movesPerSecond`
          </td>

          <td>
            La cantidad de veces que los documentos se mueven dentro de la representación en disco del conjunto de datos de MongoDB por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.batchesPerSecond`
          </td>

          <td>
            El número de lotes aplicados en toda la base de datos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.operationsPerSecond`
          </td>

          <td>
            El número de operaciones de registro de operaciones aplicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.count`
          </td>

          <td>
            El número de operaciones en el búfer de registro de operaciones.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.maxSizeInBytes`
          </td>

          <td>
            El tamaño máximo del búfer, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.sizeInBytes`
          </td>

          <td>
            El tamaño actual del contenido del búfer de registro de operaciones, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsLoadedPrefetch`
          </td>

          <td>
            La cantidad de documentos cargados durante la etapa de replicación de búsqueda previa.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsPreloadInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a cargar documentos como parte de la etapa de replicación de búsqueda previa, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexLoadedPrefetch`
          </td>

          <td>
            El número de entradas de índice cargadas por los miembros antes de actualizar los documentos como parte de la etapa de replicación de búsqueda previa.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexPreloadInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a cargar índices como parte de la etapa de replicación de búsqueda previa, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.bytesPerSecond`
          </td>

          <td>
            La cantidad de datos leídos desde el origen de sincronización de replicación por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.getmoresPerSecond`
          </td>

          <td>
            El número de operaciones getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.operationPerSecond`
          </td>

          <td>
            El número de operaciones leídas del origen de replicación por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.readersCreatedPerSecond`
          </td>

          <td>
            El número de procesos de consulta de registro de operaciones creados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `replset.health`
          </td>

          <td>
            El valor de estado del miembro del conjunto de réplicas: transmite si el miembro está arriba (`1`) o abajo (`0`).
          </td>
        </tr>

        <tr>
          <td>
            `replset.isArbiter`
          </td>

          <td>
            `1` si el mongod es un árbitro, `0` en caso contrario.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isHidden`
          </td>

          <td>
            `1` si el mongod está oculto, `0` en caso contrario.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isMaster`
          </td>

          <td>
            `1` si mongod es el maestro actual, `0` en caso contrario.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isSecondary`
          </td>

          <td>
            `1` si mongod es actualmente secundario, `0` en caso contrario.
          </td>
        </tr>

        <tr>
          <td>
            `replset.priority`
          </td>

          <td>
            La prioridad electoral del mongod.
          </td>
        </tr>

        <tr>
          <td>
            `replset.replicationLag`
          </td>

          <td>
            El retraso entre una operación de escritura en el primario y su copia en un secundario.
          </td>
        </tr>

        <tr>
          <td>
            `replset.state`
          </td>

          <td>
            El estado de una réplica que refleja su disposición dentro del conjunto.
          </td>
        </tr>

        <tr>
          <td>
            `replset.uptimeInMilliseconds`
          </td>

          <td>
            La cantidad de segundos que el proceso mongos o mongod ha estado activo, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `replset.voteFraction`
          </td>

          <td>
            La fracción de votos que emitirá un servidor en una elección de conjunto de réplicas.
          </td>
        </tr>

        <tr>
          <td>
            `replset.votes`
          </td>

          <td>
            El número de votos que emitirá un servidor en una elección de conjunto de réplicas.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.deleteDocumentsPerSecond`
          </td>

          <td>
            La cantidad de documentos eliminados de colecciones con un índice ttl por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.removeDocumentPerSecond`
          </td>

          <td>
            La cantidad de veces que el proceso en segundo plano elimina documentos de colecciones con un índice ttl por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheDirtyDataInBytes`
          </td>

          <td>
            El tamaño de los datos sucios en la memoria caché, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInBytes`
          </td>

          <td>
            El tamaño de los datos actualmente en caché, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInMemoryPageSplits`
          </td>

          <td>
            La página en memoria se divide.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxInBytes`
          </td>

          <td>
            El tamaño máximo de caché, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxPageSizeEvictionInBytes`
          </td>

          <td>
            El tamaño máximo de página en el momento del desalojo, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheModifiedPagesEvicted`
          </td>

          <td>
            El número de páginas que se han modificado y desalojadas de la memoria caché.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedApplicationThreadsPerSecond`
          </td>

          <td>
            El número de páginas desalojadas por subprocesos de la aplicación por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedInMemoryMaxPerSecond`
          </td>

          <td>
            El número de páginas desalojadas porque excedieron el máximo de caché en memoria, por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesHeld`
          </td>

          <td>
            El número de páginas que se encuentran actualmente en la caché.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheUnmodifiedPagesEvicted`
          </td>

          <td>
            El número de páginas, que no fueron modificadas, expulsadas de la memoria caché.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadAvailable`
          </td>

          <td>
            El número de tickets de lectura disponibles (transacciones concurrentes) restantes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadRemaining`
          </td>

          <td>
            El número de tickets leídos (transacciones concurrentes) en uso.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadTotal`
          </td>

          <td>
            El número total de tickets leídos (transacciones concurrentes) disponibles.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteAvailable`
          </td>

          <td>
            El número de tickets de escritura (transacciones concurrentes) disponibles restantes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteRemaining`
          </td>

          <td>
            El número de ticket de escritura (transacción concurrente) en uso.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteTotal`
          </td>

          <td>
            El número total de tickets de escritura (transacciones concurrentes) disponibles.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.failedEvictionsPagesPerSecond`
          </td>

          <td>
            El número de desalojos fallidos de páginas que excedieron el máximo en memoria, por segundo.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongo-database-clamshell"
    title="Mongo base de datos muestra métrica"
  >
    Estos atributos están adjuntos al tipo de evento `MongoDatabaseSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `stats.dataInBytes`
          </td>

          <td>
            El tamaño total de los datos contenidos en esta base de datos, incluido el factor de relleno, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `stats.indexes`
          </td>

          <td>
            El número total de índices en todas las colecciones de la base de datos.
          </td>
        </tr>

        <tr>
          <td>
            `stats.indexInBytes`
          </td>

          <td>
            El tamaño total de todos los índices creados en esta base de datos, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `stats.objects`
          </td>

          <td>
            El número de objetos (documentos) en la base de datos en todas las colecciones.
          </td>
        </tr>

        <tr>
          <td>
            `stats.storageInBytes`
          </td>

          <td>
            La cantidad total de espacio asignado a las colecciones de esta base de datos para el almacenamiento de documentos, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `totalDatabases`
          </td>

          <td>
            El número total de bases de datos existentes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongod-top-clamshell"
    title="Mongo top muestra métrica"
  >
    Estos atributos están adjuntos al tipo de evento `MongodTopSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `usage.commandsInMillisecondsPerSecond`
          </td>

          <td>
            El tiempo total dedicado a ejecutar comandos, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.commandsPerSecond`
          </td>

          <td>
            El número de comandos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.getmoreInMillisecondsPerSecond`
          </td>

          <td>
            El tiempo total dedicado a realizar getmore, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.getmorePerSecond`
          </td>

          <td>
            El número de getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.insertInMillisecondsPerSecond`
          </td>

          <td>
            El tiempo total dedicado a realizar inserciones, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.insertPerSecond`
          </td>

          <td>
            El número de inserciones por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.queriesInMillisecondsPerSecond`
          </td>

          <td>
            El tiempo total dedicado a realizar la consulta, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.queriesPerSecond`
          </td>

          <td>
            El número de consultas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.readLockInMillisecondsPerSecond`
          </td>

          <td>
            El tiempo total dedicado a realizar bloqueos de lectura, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.readLockPerSecond`
          </td>

          <td>
            El número de bloqueos de lectura por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.removeInMillisecondsPerSecond`
          </td>

          <td>
            El tiempo total dedicado a realizar eliminaciones, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.removePerSecond`
          </td>

          <td>
            El número de eliminaciones por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.totalInMillisecondsPerSecond`
          </td>

          <td>
            El tiempo total dedicado a realizar operaciones, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.totalPerSecond`
          </td>

          <td>
            El número de operaciones por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.updateInMillisecondsPerSecond`
          </td>

          <td>
            El tiempo total dedicado a realizar actualizaciones, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.updatePerSecond`
          </td>

          <td>
            El número de actualizaciones por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.writeLockInMillisecondsPerSecond`
          </td>

          <td>
            El tiempo total dedicado a realizar bloqueos de escritura, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.writeLockPerSecond`
          </td>

          <td>
            El número de bloqueos de escritura por segundo.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongo-clamshell"
    title="Mongo muestra métrica"
  >
    Estos atributos están adjuntos al tipo de evento `MongoSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `totalDatabases`
          </td>

          <td>
            El número de base de datos del clúster.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongod-clamshell"
    title="Mongod muestra métrica"
  >
    Estos atributos están adjuntos al tipo de evento `MongodSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `asserts.messagesPerSecond`
          </td>

          <td>
            El número de afirmaciones de mensajes generadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.regularPerSecond`
          </td>

          <td>
            El número de afirmaciones regulares generadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.rolloversPerSecond`
          </td>

          <td>
            El número de veces que los contadores de rollover se dan vuelta. Los contadores se ponen a cero cada 2^30 afirmaciones por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.userPerSecond`
          </td>

          <td>
            El número de afirmaciones de usuario generadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.warningPerSecond`
          </td>

          <td>
            El número de advertencias generadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countFailedPerSecond`
          </td>

          <td>
            El número de veces que `count` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `count` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesFailedPerSecond`
          </td>

          <td>
            El número de veces que `createIndexes` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `createIndexes` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.deleteFailedPerSecond`
          </td>

          <td>
            El número de veces que `delete` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deletePerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `delete` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalFailedPerSecond`
          </td>

          <td>
            El número de veces que `eval` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `eval` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyFailedPerSecond`
          </td>

          <td>
            El número de veces que `findAndModify` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `findAndModify` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertFailedPerSecond`
          </td>

          <td>
            El número de veces que `insert` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `insert` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.updateFailedPerSecond`
          </td>

          <td>
            El número de veces que `update` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updatePerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `update` .
          </td>
        </tr>

        <tr>
          <td>
            `connections.available`
          </td>

          <td>
            La cantidad de conexiones entrantes disponibles no utilizadas que la base de datos puede proporcionar.
          </td>
        </tr>

        <tr>
          <td>
            `connections.current`
          </td>

          <td>
            El número de conexiones al servidor de la base de datos desde los clientes.
          </td>
        </tr>

        <tr>
          <td>
            `connections.totalCreated`
          </td>

          <td>
            El número total de conexiones creadas.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openNoTimeout`
          </td>

          <td>
            El número de cursores abiertos con la opción `DBQueryOptionnotimeout` configurada para evitar el tiempo de espera después de un período de inactividad.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openPinned`
          </td>

          <td>
            El número de cursores abiertos fijados.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openTotal`
          </td>

          <td>
            La cantidad de cursores que MongoDB mantiene para los clientes.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.timedOutPerSecond`
          </td>

          <td>
            El número total de cursores que han agotado el tiempo de espera desde que se inició el proceso del servidor.
          </td>
        </tr>

        <tr>
          <td>
            `document.deletedPerSecond`
          </td>

          <td>
            El número de documentos eliminados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.insertedPerSecond`
          </td>

          <td>
            El número de documentos insertados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.returnedPerSecond`
          </td>

          <td>
            El número de documentos devueltos por consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.updatedPerSecond`
          </td>

          <td>
            El número de documentos actualizados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commits`
          </td>

          <td>
            El número de transacciones escritas en el diario durante el último intervalo de confirmación del grupo de diarios.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a las confirmaciones, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLock`
          </td>

          <td>
            El recuento de confirmaciones que se produjeron mientras se mantenía un bloqueo de escritura.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLockInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a las confirmaciones que se produjeron mientras se mantenía un bloqueo de escritura, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.compression`
          </td>

          <td>
            La relación de compresión de los datos escritos en el diario.
          </td>
        </tr>

        <tr>
          <td>
            `dur.dataWrittenJournalDataFilesInBytes`
          </td>

          <td>
            La cantidad de datos escritos desde el diario en los archivos de datos durante el último intervalo de confirmación del grupo de diario, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.earlyCommits`
          </td>

          <td>
            La cantidad de veces que MongoDB ha solicitado una confirmación antes del intervalo de confirmación del grupo de diario programado.
          </td>
        </tr>

        <tr>
          <td>
            `dur.journaledInBytes`
          </td>

          <td>
            La cantidad de datos escritos en el diario durante el último intervalo de confirmación del grupo de diario, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.preparingInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a prepararse para escribir en la revista, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.remappingInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a reasignar vistas asignadas de memoria de copia en escritura, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.timeCollectedCommitsInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo durante el cual MongoDB recopiló los datos `durcommitsInMilliseconds`, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingDataFilesInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a escribir en archivos de datos después del registro en diario, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingJournalInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a escribir en la revista, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.averageInMilliseconds`
          </td>

          <td>
            El tiempo promedio de cada descarga al disco, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.flushesDisk`
          </td>

          <td>
            La cantidad de veces que la base de datos ha vaciado todas las escrituras en el disco.
          </td>
        </tr>

        <tr>
          <td>
            `flush.lastInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo que tardó en completarse la última operación de descarga, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.totalInMilliseconds`
          </td>

          <td>
            La cantidad total de tiempo que los procesos mongod han dedicado a escribir (es decir, vaciar) datos en el disco, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeMillisPerSecond`
          </td>

          <td>
            El número de `getLastError` operaciones con un problema de escritura específico (por ejemplo, `w`) que esperan a que uno o más miembros de un conjunto de réplicas reconozcan la operación de escritura por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeoutsPerSecond`
          </td>

          <td>
            El número de veces que se agotó el tiempo de espera de las operaciones de escritura como resultado del umbral de tiempo de espera de `getLastError` por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsReaders`
          </td>

          <td>
            El recuento de conexiones de clientes activas que realizan operaciones de lectura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsTotal`
          </td>

          <td>
            El número total de conexiones de clientes activas a la base de datos.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsWriters`
          </td>

          <td>
            El recuento de conexiones de clientes activas que realizan operaciones de escritura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueReaders`
          </td>

          <td>
            El número de operaciones que están actualmente en cola y esperando el bloqueo de lectura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueTotal`
          </td>

          <td>
            El número total de operaciones en cola esperando el bloqueo.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueWriters`
          </td>

          <td>
            El número de operaciones que están actualmente en cola y esperando el bloqueo de escritura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.totaltime`
          </td>

          <td>
            El tiempo desde que la base de datos se inició por última vez y creó el bloqueo global.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de candado de colección en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de colección en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de colección en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de colección en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de colección en el modo Exclusivo (X) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo de colección en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de colección en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de colección en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de la base de datos en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de la base de datos en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de la base de datos en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de la base de datos en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de la base de datos en el modo Exclusivo (X) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de la base de datos en el modo Intent Exclusive (IX) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentShared`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de la base de datos en el modo Intent Shared (IS) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitShared`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de la base de datos en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de la base de datos en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de la base de datos en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de la base de datos en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de la base de datos en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo global en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo global en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo global en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo global en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo global en el modo Exclusivo (X) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo global en el modo Intent Exclusive (IX) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo global en el modo Intent Shared (IS) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitShared`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo global en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo global en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo global en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo global en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo global en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de metadatos en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de metadatos en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitExclusive`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Exclusivo (X) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentExclusive`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Exclusive (IX) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Shared (IS) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de registro de operaciones en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de registro de operaciones en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del registro de operaciones en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de registro de operaciones en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitIntentExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo del registro de operaciones en el modo Intent Exclusive (IX) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del registro de operaciones en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de registro de operaciones en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de registro de operaciones en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `mem.bits`
          </td>

          <td>
            El tamaño del motor de almacenamiento en memoria.
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedInBytes`
          </td>

          <td>
            La cantidad de memoria asignada por la base de datos, en mebibytes (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedWithJournalInBytes`
          </td>

          <td>
            La cantidad de memoria asignada, incluida la memoria utilizada para el registro en diario, en mebibytes (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.residentInBytes`
          </td>

          <td>
            La cantidad de memoria utilizada actualmente por el proceso de la base de datos, en mebibytes (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.virtualInBytes`
          </td>

          <td>
            La cantidad de memoria virtual utilizada por el proceso mongod, en mebibytes (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesInPerSecond`
          </td>

          <td>
            La cantidad de bytes que refleja la cantidad de tráfico de red en esta base de datos.
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesOutPerSecond`
          </td>

          <td>
            La cantidad de bytes que refleja la cantidad de tráfico de red enviado desde esta base de datos.
          </td>
        </tr>

        <tr>
          <td>
            `network.requestsPerSecond`
          </td>

          <td>
            El número de solicitudes distintas que ha recibido el servidor.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.commandPerSecond`
          </td>

          <td>
            El número total de comandos emitidos a la base de datos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.deletePerSecond`
          </td>

          <td>
            El número de operaciones de eliminación por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.getmorePerSecond`
          </td>

          <td>
            El número de operaciones getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.insertPerSecond`
          </td>

          <td>
            El número de operaciones de inserción por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.queryPerSecond`
          </td>

          <td>
            El número total de consultas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.updatePerSecond`
          </td>

          <td>
            El número de operaciones de actualización por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.commandPerSecond`
          </td>

          <td>
            El número total de comandos replicados emitidos a la base de datos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.deletePerSecond`
          </td>

          <td>
            El número de operaciones de eliminación replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.getmorePerSecond`
          </td>

          <td>
            El número de operaciones getmore replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.insertPerSecond`
          </td>

          <td>
            El número de operaciones de inserción replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.queryPerSecond`
          </td>

          <td>
            El número total de consultas replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.updatePerSecond`
          </td>

          <td>
            El número de operaciones de actualización replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.fastmodPerSecond`
          </td>

          <td>
            El número de operaciones de actualización que no hacen que los documentos crezcan ni requieren actualizaciones del índice por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.idhackPerSecond`
          </td>

          <td>
            El número de consultas que contienen el campo `_id` por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.scanAndOrderPerSecond`
          </td>

          <td>
            El número de consultas que devuelven números ordenados que no pueden realizar la operación de clasificación utilizando un índice por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.writeConflictsPerSecond`
          </td>

          <td>
            El número de veces que las operaciones de escritura han encontrado un conflicto por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `pageFaultsPerSecond`
          </td>

          <td>
            La cantidad de errores de página que requieren operaciones de disco por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `queryexecutor.scannedPerSecond`
          </td>

          <td>
            El número de elementos de índice escaneados durante la consulta y la evaluación del plan de consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `record.movesPerSecond`
          </td>

          <td>
            La cantidad de veces que los documentos se mueven dentro de la representación en disco del conjunto de datos de MongoDB por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.batchesPerSecond`
          </td>

          <td>
            El número de lotes aplicados en toda la base de datos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.operationsPerSecond`
          </td>

          <td>
            El número de operaciones de registro de operaciones aplicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.count`
          </td>

          <td>
            El número de operaciones en el búfer de registro de operaciones.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.maxSizeInBytes`
          </td>

          <td>
            El tamaño máximo del búfer, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.sizeInBytes`
          </td>

          <td>
            El tamaño actual del contenido del búfer de registro de operaciones, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsLoadedPrefetch`
          </td>

          <td>
            La cantidad de documentos cargados durante la etapa de replicación de búsqueda previa.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsPreloadInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a cargar documentos como parte de la etapa de replicación de búsqueda previa, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexLoadedPrefetch`
          </td>

          <td>
            El número de entradas de índice cargadas por los miembros antes de actualizar los documentos como parte de la etapa de replicación de búsqueda previa.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexPreloadInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a cargar índices como parte de la etapa de replicación de búsqueda previa, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.bytesPerSecond`
          </td>

          <td>
            La cantidad de datos leídos desde el origen de sincronización de replicación por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.getmoresPerSecond`
          </td>

          <td>
            El número de operaciones getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.operationPerSecond`
          </td>

          <td>
            El número de operaciones leídas del origen de replicación por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.readersCreatedPerSecond`
          </td>

          <td>
            El número de procesos de consulta de registro de operaciones creados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `replset.health`
          </td>

          <td>
            El valor de estado del miembro del conjunto de réplicas: transmite si el miembro está arriba (`1`) o abajo (`0`).
          </td>
        </tr>

        <tr>
          <td>
            `replset.isArbiter`
          </td>

          <td>
            `1` si el mongod es un árbitro, `0` en caso contrario.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isHidden`
          </td>

          <td>
            `1` si el mongod está oculto, `0` en caso contrario.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isMaster`
          </td>

          <td>
            `1` si mongod es el maestro actual, `0` en caso contrario.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isSecondary`
          </td>

          <td>
            `1` si mongod es actualmente secundario, `0` en caso contrario.
          </td>
        </tr>

        <tr>
          <td>
            `replset.priority`
          </td>

          <td>
            La prioridad electoral del mongod.
          </td>
        </tr>

        <tr>
          <td>
            `replset.replicationLag`
          </td>

          <td>
            El retraso entre una operación de escritura en el primario y su copia en un secundario.
          </td>
        </tr>

        <tr>
          <td>
            `replset.state`
          </td>

          <td>
            El estado de una réplica que refleja su disposición dentro del conjunto.
          </td>
        </tr>

        <tr>
          <td>
            `replset.uptimeInMilliseconds`
          </td>

          <td>
            La cantidad de segundos que el proceso mongos o mongod ha estado activo, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `replset.voteFraction`
          </td>

          <td>
            La fracción de votos que emitirá un servidor en una elección de conjunto de réplicas.
          </td>
        </tr>

        <tr>
          <td>
            `replset.votes`
          </td>

          <td>
            El número de votos que emitirá un servidor en una elección de conjunto de réplicas.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.deleteDocumentsPerSecond`
          </td>

          <td>
            La cantidad de documentos eliminados de colecciones con un índice ttl por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.removeDocumentPerSecond`
          </td>

          <td>
            La cantidad de veces que el proceso en segundo plano elimina documentos de colecciones con un índice ttl por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheDirtyDataInBytes`
          </td>

          <td>
            El tamaño de los datos sucios en la memoria caché, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInBytes`
          </td>

          <td>
            El tamaño de los datos actualmente en caché, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInMemoryPageSplits`
          </td>

          <td>
            La página en memoria se divide.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxInBytes`
          </td>

          <td>
            El tamaño máximo de caché, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxPageSizeEvictionInBytes`
          </td>

          <td>
            El tamaño máximo de página en el momento del desalojo, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheModifiedPagesEvicted`
          </td>

          <td>
            El número de páginas que se han modificado y desalojadas de la memoria caché.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedApplicationThreadsPerSecond`
          </td>

          <td>
            El número de páginas desalojadas por subprocesos de la aplicación por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedInMemoryMaxPerSecond`
          </td>

          <td>
            El número de páginas desalojadas porque excedieron el máximo de caché en memoria, por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesHeld`
          </td>

          <td>
            El número de páginas que se encuentran actualmente en la caché.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheUnmodifiedPagesEvicted`
          </td>

          <td>
            El número de páginas, que no fueron modificadas, expulsadas de la memoria caché.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadAvailable`
          </td>

          <td>
            El número de tickets de lectura disponibles (transacciones concurrentes) restantes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadRemaining`
          </td>

          <td>
            El número de tickets leídos (transacciones concurrentes) en uso.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadTotal`
          </td>

          <td>
            El número total de tickets leídos (transacciones concurrentes) disponibles.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteAvailable`
          </td>

          <td>
            El número de tickets de escritura (transacciones concurrentes) disponibles restantes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteRemaining`
          </td>

          <td>
            El número de ticket de escritura (transacción concurrente) en uso.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteTotal`
          </td>

          <td>
            El número total de tickets de escritura (transacciones concurrentes) disponibles.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.failedEvictionsPagesPerSecond`
          </td>

          <td>
            El número de desalojos fallidos de páginas que excedieron el máximo en memoria, por segundo.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongos-clamshell"
    title="Mongos muestra métrica"
  >
    Estos atributos están adjuntos al tipo de evento `MongosSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descripción
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `asserts.messagesPerSecond`
          </td>

          <td>
            El número de afirmaciones de mensajes generadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.regularPerSecond`
          </td>

          <td>
            El número de afirmaciones regulares generadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.rolloversPerSecond`
          </td>

          <td>
            El número de veces que los contadores de rollover se dan vuelta. Los contadores se ponen a cero cada 2^30 afirmaciones por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.userPerSecond`
          </td>

          <td>
            El número de afirmaciones de usuario generadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.warningPerSecond`
          </td>

          <td>
            El número de advertencias generadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countFailedPerSecond`
          </td>

          <td>
            El número de veces que `count` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `count` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesFailedPerSecond`
          </td>

          <td>
            El número de veces que `createIndexes` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `createIndexes` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.deleteFailedPerSecond`
          </td>

          <td>
            El número de veces que `delete` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deletePerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `delete` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalFailedPerSecond`
          </td>

          <td>
            El número de veces que `eval` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `eval` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyFailedPerSecond`
          </td>

          <td>
            El número de veces que `findAndModify` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `findAndModify` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertFailedPerSecond`
          </td>

          <td>
            El número de veces que `insert` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertPerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `insert` .
          </td>
        </tr>

        <tr>
          <td>
            `commands.updateFailedPerSecond`
          </td>

          <td>
            El número de veces que `update` falló.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updatePerSecond`
          </td>

          <td>
            El número de veces que se ejecutó `update` .
          </td>
        </tr>

        <tr>
          <td>
            `connections.available`
          </td>

          <td>
            La cantidad de conexiones entrantes disponibles no utilizadas que la base de datos puede proporcionar.
          </td>
        </tr>

        <tr>
          <td>
            `connections.current`
          </td>

          <td>
            El número de conexiones al servidor de la base de datos desde los clientes.
          </td>
        </tr>

        <tr>
          <td>
            `connections.totalCreated`
          </td>

          <td>
            El número total de conexiones creadas.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openNoTimeout`
          </td>

          <td>
            El número de cursores abiertos con la opción `DBQueryOptionnotimeout` configurada para evitar el tiempo de espera después de un período de inactividad.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openPinned`
          </td>

          <td>
            El número de cursores abiertos fijados.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openTotal`
          </td>

          <td>
            La cantidad de cursores que MongoDB mantiene para los clientes.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.timedOutPerSecond`
          </td>

          <td>
            El número total de cursores que han agotado el tiempo de espera desde que se inició el proceso del servidor.
          </td>
        </tr>

        <tr>
          <td>
            `document.deletedPerSecond`
          </td>

          <td>
            El número de documentos eliminados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.insertedPerSecond`
          </td>

          <td>
            El número de documentos insertados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.returnedPerSecond`
          </td>

          <td>
            El número de documentos devueltos por consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.updatedPerSecond`
          </td>

          <td>
            El número de documentos actualizados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commits`
          </td>

          <td>
            El número de transacciones escritas en el diario durante el último intervalo de confirmación del grupo de diarios.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a las confirmaciones, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLock`
          </td>

          <td>
            El recuento de confirmaciones que se produjeron mientras se mantenía un bloqueo de escritura.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLockInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a las confirmaciones que se produjeron mientras se mantenía un bloqueo de escritura, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.compression`
          </td>

          <td>
            La relación de compresión de los datos escritos en el diario.
          </td>
        </tr>

        <tr>
          <td>
            `dur.dataWrittenJournalDataFilesInBytes`
          </td>

          <td>
            La cantidad de datos escritos desde el diario en los archivos de datos durante el último intervalo de confirmación del grupo de diario, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.earlyCommits`
          </td>

          <td>
            La cantidad de veces que MongoDB ha solicitado una confirmación antes del intervalo de confirmación del grupo de diario programado.
          </td>
        </tr>

        <tr>
          <td>
            `dur.journaledInBytes`
          </td>

          <td>
            La cantidad de datos escritos en el diario durante el último intervalo de confirmación del grupo de diario, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.preparingInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a prepararse para escribir en la revista, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.remappingInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a reasignar vistas asignadas de memoria de copia en escritura, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.timeCollectedCommitsInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo durante el cual MongoDB recopiló los datos `durcommitsInMilliseconds`, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingDataFilesInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a escribir en archivos de datos después del registro en diario, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingJournalInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a escribir en la revista, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.averageInMilliseconds`
          </td>

          <td>
            El tiempo promedio de cada descarga al disco, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.flushesDisk`
          </td>

          <td>
            La cantidad de veces que la base de datos ha vaciado todas las escrituras en el disco.
          </td>
        </tr>

        <tr>
          <td>
            `flush.lastInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo que tardó en completarse la última operación de descarga, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.totalInMilliseconds`
          </td>

          <td>
            La cantidad total de tiempo que los procesos mongod han dedicado a escribir (es decir, vaciar) datos en el disco, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeMillisPerSecond`
          </td>

          <td>
            El número de `getLastError` operaciones con un problema de escritura específico (por ejemplo, `w`) que esperan a que uno o más miembros de un conjunto de réplicas reconozcan la operación de escritura por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeoutsPerSecond`
          </td>

          <td>
            El número de veces que se agotó el tiempo de espera de las operaciones de escritura como resultado del umbral de tiempo de espera de `getLastError` por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsReaders`
          </td>

          <td>
            El recuento de conexiones de clientes activas que realizan operaciones de lectura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsTotal`
          </td>

          <td>
            El número total de conexiones de clientes activas a la base de datos.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsWriters`
          </td>

          <td>
            El recuento de conexiones de clientes activas que realizan operaciones de escritura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueReaders`
          </td>

          <td>
            El número de operaciones que están actualmente en cola y esperando el bloqueo de lectura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueTotal`
          </td>

          <td>
            El número total de operaciones en cola esperando el bloqueo.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueWriters`
          </td>

          <td>
            El número de operaciones que están actualmente en cola y esperando el bloqueo de escritura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.totaltime`
          </td>

          <td>
            El tiempo desde que la base de datos se inició por última vez y creó el bloqueo global.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de candado de colección en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de colección en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de colección en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de colección en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de colección en el modo Exclusivo (X) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo de colección en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de colección en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de colección en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de la base de datos en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de la base de datos en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de la base de datos en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de la base de datos en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de la base de datos en el modo Exclusivo (X) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de la base de datos en el modo Intent Exclusive (IX) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentShared`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de la base de datos en el modo Intent Shared (IS) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitShared`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo de la base de datos en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de la base de datos en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de la base de datos en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de la base de datos en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de la base de datos en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo global en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo global en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo global en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo global en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo global en el modo Exclusivo (X) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo global en el modo Intent Exclusive (IX) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo global en el modo Intent Shared (IS) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitShared`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo global en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo global en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo global en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo global en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo global en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de metadatos en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de metadatos en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitExclusive`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Exclusivo (X) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentExclusive`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Exclusive (IX) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Shared (IS) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo del motor de almacenamiento MMAPv1 en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de registro de operaciones en el modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentExclusive`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de registro de operaciones en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo del registro de operaciones en el modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireShared`
          </td>

          <td>
            La cantidad de veces que se adquirió el tipo de bloqueo de registro de operaciones en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitIntentExclusive`
          </td>

          <td>
            El número de veces que la adquisición del tipo de bloqueo del registro de operaciones en el modo Intent Exclusive (IX) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitShared`
          </td>

          <td>
            La cantidad de veces que la adquisición del tipo de bloqueo del registro de operaciones en el modo Compartido (S) encontró esperas porque los bloqueos se mantuvieron en un modo conflictivo.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de registro de operaciones en el modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            El tiempo de espera para las adquisiciones del tipo de bloqueo de registro de operaciones en el modo Compartido (S).
          </td>
        </tr>

        <tr>
          <td>
            `mem.bits`
          </td>

          <td>
            El tamaño del motor de almacenamiento en memoria.
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedInBytes`
          </td>

          <td>
            La cantidad de memoria asignada por la base de datos, en mebibytes (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedWithJournalInBytes`
          </td>

          <td>
            La cantidad de memoria asignada, incluida la memoria utilizada para el registro en diario, en mebibytes (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.residentInBytes`
          </td>

          <td>
            La cantidad de memoria utilizada actualmente por el proceso de la base de datos, en mebibytes (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.virtualInBytes`
          </td>

          <td>
            La cantidad de memoria virtual utilizada por el proceso mongod, en mebibytes (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesInPerSecond`
          </td>

          <td>
            La cantidad de bytes que refleja la cantidad de tráfico de red en esta base de datos.
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesOutPerSecond`
          </td>

          <td>
            La cantidad de bytes que refleja la cantidad de tráfico de red enviado desde esta base de datos.
          </td>
        </tr>

        <tr>
          <td>
            `network.requestsPerSecond`
          </td>

          <td>
            El número de solicitudes distintas que ha recibido el servidor.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.commandPerSecond`
          </td>

          <td>
            El número total de comandos emitidos a la base de datos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.deletePerSecond`
          </td>

          <td>
            El número de operaciones de eliminación por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.getmorePerSecond`
          </td>

          <td>
            El número de operaciones getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.insertPerSecond`
          </td>

          <td>
            El número de operaciones de inserción por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.queryPerSecond`
          </td>

          <td>
            El número total de consultas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.updatePerSecond`
          </td>

          <td>
            El número de operaciones de actualización por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.commandPerSecond`
          </td>

          <td>
            El número total de comandos replicados emitidos a la base de datos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.deletePerSecond`
          </td>

          <td>
            El número de operaciones de eliminación replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.getmorePerSecond`
          </td>

          <td>
            El número de operaciones getmore replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.insertPerSecond`
          </td>

          <td>
            El número de operaciones de inserción replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.queryPerSecond`
          </td>

          <td>
            El número total de consultas replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.updatePerSecond`
          </td>

          <td>
            El número de operaciones de actualización replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.fastmodPerSecond`
          </td>

          <td>
            El número de operaciones de actualización que no hacen que los documentos crezcan ni requieren actualizaciones del índice por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.idhackPerSecond`
          </td>

          <td>
            El número de consultas que contienen el campo `_id` por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.scanAndOrderPerSecond`
          </td>

          <td>
            El número de consultas que devuelven números ordenados que no pueden realizar la operación de clasificación utilizando un índice por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.writeConflictsPerSecond`
          </td>

          <td>
            El número de veces que las operaciones de escritura han encontrado un conflicto por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `pageFaultsPerSecond`
          </td>

          <td>
            La cantidad de errores de página que requieren operaciones de disco por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `queryexecutor.scannedPerSecond`
          </td>

          <td>
            El número de elementos de índice escaneados durante la consulta y la evaluación del plan de consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `record.movesPerSecond`
          </td>

          <td>
            La cantidad de veces que los documentos se mueven dentro de la representación en disco del conjunto de datos de MongoDB por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.batchesPerSecond`
          </td>

          <td>
            El número de lotes aplicados en toda la base de datos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.operationsPerSecond`
          </td>

          <td>
            El número de operaciones de registro de operaciones aplicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.count`
          </td>

          <td>
            El número de operaciones en el búfer de registro de operaciones.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.maxSizeInBytes`
          </td>

          <td>
            El tamaño máximo del búfer, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.sizeInBytes`
          </td>

          <td>
            El tamaño actual del contenido del búfer de registro de operaciones, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsLoadedPrefetch`
          </td>

          <td>
            La cantidad de documentos cargados durante la etapa de replicación de búsqueda previa.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsPreloadInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a cargar documentos como parte de la etapa de replicación de búsqueda previa, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexLoadedPrefetch`
          </td>

          <td>
            El número de entradas de índice cargadas por los miembros antes de actualizar los documentos como parte de la etapa de replicación de búsqueda previa.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexPreloadInMilliseconds`
          </td>

          <td>
            La cantidad de tiempo dedicado a cargar índices como parte de la etapa de replicación de búsqueda previa, en milisegundos.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.bytesPerSecond`
          </td>

          <td>
            La cantidad de datos leídos desde el origen de sincronización de replicación por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.getmoresPerSecond`
          </td>

          <td>
            El número de operaciones getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.operationPerSecond`
          </td>

          <td>
            El número de operaciones leídas del origen de replicación por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.readersCreatedPerSecond`
          </td>

          <td>
            El número de procesos de consulta de registro de operaciones creados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.deleteDocumentsPerSecond`
          </td>

          <td>
            La cantidad de documentos eliminados de colecciones con un índice ttl por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.removeDocumentPerSecond`
          </td>

          <td>
            La cantidad de veces que el proceso en segundo plano elimina documentos de colecciones con un índice ttl por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheDirtyDataInBytes`
          </td>

          <td>
            El tamaño de los datos sucios en la memoria caché, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInBytes`
          </td>

          <td>
            El tamaño de los datos actualmente en caché, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInMemoryPageSplits`
          </td>

          <td>
            La página en memoria se divide.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxInBytes`
          </td>

          <td>
            El tamaño máximo de caché, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxPageSizeEvictionInBytes`
          </td>

          <td>
            El tamaño máximo de página en el momento del desalojo, en bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheModifiedPagesEvicted`
          </td>

          <td>
            El número de páginas que se han modificado y desalojadas de la memoria caché.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedApplicationThreadsPerSecond`
          </td>

          <td>
            El número de páginas desalojadas por subprocesos de la aplicación por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedInMemoryMaxPerSecond`
          </td>

          <td>
            El número de páginas desalojadas porque excedieron el máximo de caché en memoria, por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesHeld`
          </td>

          <td>
            El número de páginas que se encuentran actualmente en la caché.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheUnmodifiedPagesEvicted`
          </td>

          <td>
            El número de páginas, que no fueron modificadas, expulsadas de la memoria caché.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadAvailable`
          </td>

          <td>
            El número de tickets de lectura disponibles (transacciones concurrentes) restantes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadRemaining`
          </td>

          <td>
            El número de tickets leídos (transacciones concurrentes) en uso.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadTotal`
          </td>

          <td>
            El número total de tickets leídos (transacciones concurrentes) disponibles.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteAvailable`
          </td>

          <td>
            El número de tickets de escritura (transacciones concurrentes) disponibles restantes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteRemaining`
          </td>

          <td>
            El número de ticket de escritura (transacción concurrente) en uso.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteTotal`
          </td>

          <td>
            El número total de tickets de escritura (transacciones concurrentes) disponibles.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.failedEvictionsPagesPerSecond`
          </td>

          <td>
            El número de desalojos fallidos de páginas que excedieron el máximo en memoria, por segundo.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## Datos de inventario [#inventory]

La integración de MongoDB captura todas las opciones de línea de comando y parámetros configurados en tiempo de ejecución de cada host en el clúster.

Los datos están disponibles en la [página Inventario](/docs/infrastructure/new-relic-infrastructure/infrastructure-ui-pages/infrastructure-inventory-page-search-your-entire-infrastructure), en la fuente <DoNotTranslate>**config/mongodb**</DoNotTranslate> . Para obtener más información sobre los datos de inventario, consulte [Comprender los datos de integración](/docs/infrastructure/integrations-getting-started/getting-started/understand-integration-data-data-types#inventory-data).

## Comprueba el código fuente [#source-code]

Esta integración es software de código abierto. Eso significa que puedes [explorar su código fuente](https://github.com/newrelic/nri-mongodb) y enviar mejoras, o crear tu propia bifurcación y compilarla.