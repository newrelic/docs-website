---
title: 'Tutoriales de OpenTelemetry: instrumentación de una aplicación Java de muestra'
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: 'To test out OpenTelemetry on a sample app instead of your own app, consider these three tutorials.'
freshnessValidatedDate: never
translationType: machine
---

import opentelemetrySpringBootASCIIDisplay from 'images/opentelemetry_screenshot-crop_Spring-Boot-ASCII-display.webp'

import opentelemetryMainDistributedTracingPage from 'images/opentelemetry_screenshot-crop_main-distributed-tracing-page.webp'

import opentelemetryDistributedTracingError from 'images/opentelemetry_screenshot-crop_distributed-tracing-error.webp'

import opentelemetryInProcessSpans from 'images/opentelemetry_screenshot-crop_in-process-spans.webp'

import opentelemetryExceptiononSpanEvent from 'images/opentelemetry_screenshot-crop_exception-on-span-event.webp'

import opentelemetryAttributesTab from 'images/opentelemetry_screenshot-crop_attributes-tab.webp'

import opentelemetryMetricsExplorerMain from 'images/opentelemetry_screenshot-crop_metrics-explorer-main.webp'

import opentelemetryMetricsExplorerDimensions from 'images/opentelemetry_screenshot-crop_metrics-explorer-dimensions.webp'

import opentelemetryJvmsPageMain from 'images/opentelemetry_screenshot-crop_jvms-page-main.webp'

import opentelemetryCompareJvmInstances from 'images/opentelemetry_screenshot-full_compare-jvm-instances.webp'

import opentelemetryJvmColorCodedComparison from 'images/opentelemetry_screenshot-full_jvm-color-coded-comparison.webp'

import opentelemetryMainLogsPage from 'images/opentelemetry_screenshot-full_main-logs-page.webp'

import opentelemetryLogsinTerminal from 'images/opentelemetry_screenshot-full_logs-in-terminal.webp'

import opentelemetryLogDetailsWithTrace from 'images/opentelemetry_screenshot-full_log-details-with-trace.webp'

import opentelemetryTraceRelatedtoLog from 'images/opentelemetry_screenshot-full_trace-related-to-log.webp'

import opentelemetryTraceWaterfallFromLog from 'images/opentelemetry_screenshot-full_trace-waterfall-from-log.webp'

import opentelemetryLogCapturedinTraceSpan from 'images/opentelemetry_screenshot-full_log-captured-in-trace-span.webp'

import opentelemetryTraceDurationDemoChart from 'images/opentelemetry_screenshot-crop_jvm-metric-charts.webp'

Pruebe estos tutoriales de Java para ver qué puede hacer la plataforma New Relic con sus datos OTLP. Tenemos tres tutoriales entre los que puede elegir, cada uno de los cuales utiliza la misma aplicación de demostración Spring. La aplicación calculará el enésimo número de la secuencia de Fibonacci y generará traza, métrica y log.

Al seguir estos tutoriales, puede aprender habilidades que le ayudarán a configurar su propia aplicación con OpenTelemetry y New Relic.

<img
  title="Screenshot showing various JVM metric charts"
  alt="Screenshot showing various JVM metric charts"
  src={opentelemetryTraceDurationDemoChart}
/>

<figcaption>
  Después de terminar cualquiera de estos tutoriales, podrá ver JVM métrica en gráficos como estos.
</figcaption>

## Requisitos [#requirements]

Para comenzar, asegúrese de tener lo siguiente:

* Una cuenta New Relic: Regístrese para obtener una [cuenta gratuita](https://newrelic.com/signup) si aún no tiene una.
* Java 17 o superior: si aún no lo tienes, consulta [estas opciones de descarga](https://www.java.com/en/download/manual.jsp).

## Tutoriales [#tutorials]

Aunque cada tutorial utiliza la misma aplicación de demostración, tienen diferentes enfoques para ayudarlo a familiarizarse con OpenTelemetry y New Relic.

* [Aplicación pre-instrumentada](#pre-instrumented-tutorial): ejecute nuestra aplicación de demostración pre-instrumentada para ver rápidamente los datos en nuestra UI.
* [OpenTelemetry agente de Java](#java-agent-tutorial): monitor nuestra aplicación de demostración con el agente de Java OpenTelemetry.
* [Configuración manual](#manual-setup-tutorial): instrumente nuestra aplicación de demostración manualmente.

Haga clic en la pestaña a continuación para ver el tutorial que desea completar.

<Callout variant="tip">
  Cuando utilice OpenTelemetry, tendrá dos opciones para exportar datos desde su aplicación a New Relic a través de OTLP:

  * Directamente desde tu aplicación a New Relic
  * Su aplicación envía datos a un recopilador OpenTelemetry donde luego se exporta a New Relic

  Estos tutoriales cubren la primera opción. Si desea exportar sus datos a través de un recopilador, consulte esta [documentación del recopilador](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/collector/opentelemetry-collector-basic/) para obtener más detalles.
</Callout>

<Tabs>
  <TabsBar>
    <TabsBarItem id="pre-instrumented-tutorial">
      Aplicación pre-instrumentada
    </TabsBarItem>

    <TabsBarItem id="java-agent-tutorial">
      OpenTelemetry agente de Java
    </TabsBarItem>

    <TabsBarItem id="manual-setup-tutorial">
      Configuración manual
    </TabsBarItem>
  </TabsBar>

  <TabsPages>
    <TabsPageItem id="pre-instrumented-tutorial">
      ### Ejecute la aplicación de demostración pre-instrumentada [#pre-instrum]

      Esta es una excelente opción si desea que hagamos la instrumentación para que pueda ver rápidamente cómo es enviar datos a New Relic y verlos en nuestra UI.

      1. En su terminal, ejecute lo siguiente para clonar la aplicación de demostración y navegue hasta el directorio `java` de las Guías de introducción.

         ```bash
         git clone https://github.com/newrelic/newrelic-opentelemetry-examples.git
         cd newrelic-opentelemetry-examples/getting-started-guides/java
         ```

      2. Configure estas dos variables de entorno para enviar datos a su cuenta New Relic:

         * Asegúrate de utilizar tu <InlinePopover type="licenseKey"/>.

         * Si la región de su centro de datos New Relic es la UE y no los EE. UU., configure el extremo en: `https://otlp.eu01.nr-data.net`

           * `OTEL_EXPORTER_OTLP_HEADERS=api-key=INSERT_YOUR_NEW_RELIC_LICENSE_KEY`
           * `OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.nr-data.net`
           * `OTEL_EXPORTER_OTLP_PROTOCOL=http/protobuf`

      3. Configure la primera variable de entorno a continuación para nombrar el servicio, luego configure la segunda para el ID del servicio de la instancia, que activa cierta característica de la plataforma. Finalmente, habilite el registro ya que el registro está desactivado de forma predeterminada:

         * `OTEL_SERVICE_NAME=getting-started-java`

         * `OTEL_RESOURCE_ATTRIBUTES=service.instance.id=INSERT_YOUR_ID_HERE`

           * Reemplace `INSERT_YOUR_OWN_ID_HERE` con un ID único de la instancia. Por ejemplo, podrías usar 1234.

         * `OTEL_LOGS_EXPORTER=otlp`

      4. En el mismo directorio `getting-started-guides/java` , cree y ejecute la aplicación:

         * Mac OS:

           ```bash
           ./gradlew bootRun
           ```

         * Potencia Shell:

           ```bash
           .\gradlew.bat build
           ```

      5. Abra una nueva pestaña de terminal, cambie al directorio `getting-started-guides/java/Instrumented` y ejecute el siguiente comando para generar algo de tráfico a la aplicación:

         * Mac OS:

           ```bash
           ./load-generator.sh
           ```

         * Potencia Shell:

           ```bash
           .\load-generator.ps1
           ```

         <Callout variant="tip">
           Alternativamente, puede llegar al extremo en el browser en esta URL: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE`. Reemplace `INSERT_A_VALUE` con un valor de 1 a 90. Para generar un error, inserte un número entero fuera del rango válido.
         </Callout>

      6. Vaya a <DoNotTranslate>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > APM & services**</DoNotTranslate>.

      7. Haga clic en su nueva entidad (servicio) llamada `getting-started-java` y explore la UI. Para obtener más consejos sobre qué buscar en la UI, consulte [Ver sus datos en New Relic](#view-data).

      8. Cuando haya terminado de ver sus datos en la UI, cierre la aplicación presionando CONTROL+C en ambas sesiones de terminal.
    </TabsPageItem>

    <TabsPageItem id="java-agent-tutorial">
      ### monitor la aplicación de demostración con el agente de Java OpenTelemetry [#java-agent]

      Aquí hay un tutorial diferente que también utiliza la misma aplicación de demostración. En este caso, utilizará el agente de Java OpenTelemetry para monitor automáticamente la aplicación de demostración. No es necesario modificar el código fuente de Java. Al utilizar el agente, puede comenzar rápidamente a exportar datos de muestra a New Relic.

      El agente de instrumentación automática es un archivo JAR que inyecta dinámicamente código de bytes para capturar telemetría de bibliotecas y marcos populares. También puede usarlo para capturar datos como solicitudes entrantes, llamadas HTTP salientes y llamadas de base de datos. Se puede adjuntar a cualquier aplicación Java 8+.

      <Callout variant="tip">
        Consulte la [documentación oficial del agente de Java](https://opentelemetry.io/docs/instrumentation/java/automatic/) para obtener opciones de configuración adicionales.
      </Callout>

      Para monitor nuestra aplicación de demostración con el agente de Java OpenTelemetry:

      1. Descargue el [archivo JAR del agente](https://github.com/open-telemetry/opentelemetry-java-instrumentation/releases/latest/download/opentelemetry-javaagent.jar), que contiene la biblioteca del agente y la instrumentación. Colóquelo en su directorio preferido y anote la ruta que utilizará más adelante.

      2. Si aún no lo ha hecho, descargue el repositorio de la aplicación de demostración y cambie al siguiente directorio:

         ```bash
         git clone https://github.com/newrelic/newrelic-opentelemetry-examples.git
         cd newrelic-opentelemetry-examples/getting-started-guides/java
         ```

      3. Cree la aplicación de demostración con este comando:

         * Mac OS:

           ```bash
           ./gradlew build
           ```

         * Potencia Shell:

           ```bash
           .\gradlew.bat build
           ```

           <Callout variant="tip">
             Después de una compilación exitosa, encontrará el archivo JAR de la aplicación resultante en `Uninstrumented/build/libs`, llamado `uninstrumented.jar`.
           </Callout>

      4. Vaya a nuestra [sección de referencia de variables de entorno](#ref-env-vars) a continuación para ver qué variables necesita exportar y luego volver a estos pasos.

      5. Continúe en `getting-started-guides/java/Uninstrumented` para lanzar el agente con la aplicación:

         <Callout variant="important">
           Reemplace `path/to` con la ubicación del archivo JAR que descargó anteriormente.
         </Callout>

         ```bash
         java -javaagent:path/to/opentelemetry-javaagent.jar \
              -jar ./build/libs/uninstrumented.jar
         ```

      6. Genere tráfico a la aplicación abriendo una nueva terminal en el directorio `getting-started-guides/java/Uninstrumented` y ejecutando el generador de carga:

         * Mac OS:

           ```bash
           ./load-generator.sh
           ```

         * Potencia Shell:

           ```bash
           .\load-generator.ps1
           ```

         <Callout variant="tip">
           Alternativamente, puede llegar al extremo en el browser en esta URL: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE`. Reemplace `INSERT_A_VALUE` con un valor de 1 a 90. Para generar un error, inserte un número entero fuera del rango válido.
         </Callout>

      7. Ahora que ha enviado algunos datos a New Relic, consulte nuestras [instrucciones sobre cómo ver los datos en la UI](#view-data).

      8. Cuando haya terminado de ver sus datos en la UI, cierre la aplicación presionando CONTROL+C en ambas sesiones de terminal.
    </TabsPageItem>

    <TabsPageItem id="manual-setup-tutorial">
      ### Configure la aplicación de demostración manualmente [#manual-instrum]

      El tutorial anterior le ayudó a explorar la instrumentación automática con el agente de Java OpenTelemetry. Este tutorial le mostrará cómo utilizar instrumentación personalizada para tener más control sobre la telemetría que recopila. Insertará manualmente la instrumentación en nuestra aplicación de demostración para capturar la telemetría y luego configurará el SDK para exportar esos datos a New Relic.

      <Callout variant="tip">
        Si bien puede configurar manualmente el SDK, le mostraremos cómo configurar el SDK usando la [opción de configuración automática](https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions/autoconfigure), que simplifica el proceso mediante el uso de variables de entorno y propiedades del sistema.
      </Callout>

      <Steps>
        <Step>
          #### Descargue la aplicación de demostración [#download]

          Si aún no ha descargado nuestra aplicación de demostración, ejecute lo siguiente:

          ```bash
          git clone https://github.com/newrelic/newrelic-opentelemetry-examples.git
          ```
        </Step>

        <Step>
          #### Instalar dependencia [#dependencies]

          Para agregar dependencia:

          1. Vaya al directorio de la aplicación.

             ```bash
             cd newrelic-opentelemetry-examples/getting-started-guides/java/uninstrumented
             ```

          2. Abra `build.gradle`.

          3. Agregue los siguientes elementos resaltados al bloque `dependencies` (es posible que deba desplazarse hacia abajo dentro del bloque de código):

             ```gradle lineHighlight=29-42
             plugins {
                 id 'org.springframework.boot' version '2.7.5'
                 id 'io.spring.dependency-management' version '1.1.0'
                 id 'java'
             }

             java {
                 toolchain {
                     languageVersion = JavaLanguageVersion.of(17)
                 }
             }

             repositories {
                 mavenCentral()
             }

             bootRun {
                 mainClass.set 'com.example.demo.Application'
             }

             configurations.all {
                 exclude module: 'spring-boot-starter-logging'
             }

             dependencies {
                 implementation 'org.springframework.boot:spring-boot-starter-web'
                 implementation 'org.springframework.boot:spring-boot-starter-log4j2'

                 // OpenTelemetry core
                 implementation platform('io.opentelemetry:opentelemetry-bom:1.22.0')
                 implementation platform('io.opentelemetry:opentelemetry-bom-alpha:1.22.0-alpha')
                 implementation 'io.opentelemetry:opentelemetry-api'
                 implementation 'io.opentelemetry:opentelemetry-sdk'
                 implementation 'io.opentelemetry:opentelemetry-exporter-otlp'
                 implementation 'io.opentelemetry:opentelemetry-exporter-otlp-logs'
                 implementation 'io.opentelemetry:opentelemetry-sdk-extension-autoconfigure'

                 // OpenTelemetry instrumentation
                 implementation platform('io.opentelemetry.instrumentation:opentelemetry-instrumentation-bom-alpha:1.22.1-alpha')
                 implementation 'io.opentelemetry.instrumentation:opentelemetry-runtime-metrics'
                 implementation 'io.opentelemetry.instrumentation:opentelemetry-log4j-appender-2.17'
                 implementation 'io.opentelemetry.instrumentation:opentelemetry-spring-webmvc-6.0'
             }
             ```

          Notas:

          * La dependencia `bom` (lista de materiales) se utiliza para sincronizar versiones de dependencia para un ecosistema en particular. Dado que OpenTelemetry publica muchos componentes Java, estos ayudan a garantizar que todas las versiones estén sincronizadas, ya sea que use solo unas pocas o muchas.
          * Las dependencias restantes brindan acceso al SDK, API, exportador OTLP y biblioteca de instrumentación.
          * Hay una configuración adicional para excluir el módulo spring-boot-starter-logging. Esto evita un mensaje de error de compilación relacionado con `log4j-slf4j-impl cannot be present with log4j-to-slf4j`.
        </Step>

        <Step>
          #### Configure el SDK con la extensión de configuración automática [#auto-config-ext]

          Si bien puede configurar el SDK manualmente, le recomendamos utilizar la extensión de configuración automática, ya que agiliza el proceso.

          1. Vaya al directorio del código fuente de la aplicación:

             ```bash
             cd newrelic-opentelemetry-examples/getting-started-guides/java/uninstrumented/src/main/java/com/example/demo
             ```

          2. Abra `Application.java`.

          3. Inserte las líneas resaltadas:

             ```java lineHighlight=7-12,17-20
             @SpringBootApplication
             public class Application {

                 private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

                 public static void main(String[] args) {
                     // Build the SDK auto-configuration extension module
                     OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                             .setResultAsGlobal(false)
                             .build()
                             .getOpenTelemetrySdk();
                     Application.openTelemetry = openTelemetrySdk;

                     SpringApplication.run(Application.class, args);
                 }

                 @Bean
                 public OpenTelemetry openTelemetry() {
                     return openTelemetry;
                 }
             }
             ```

          4. Vaya a nuestra [sección de referencia de variables de entorno](#ref-env-vars) a continuación para ver qué variables necesita exportar y luego volver a estos pasos.
        </Step>

        <Step>
          #### Añadir instrumentación biblioteca: traza [#library-traces]

          En `Application.java`, agregue la instrumentación resaltada para Spring Web MVC registrando un filtro de seguimiento:

          ```java lineHighlight=22-26
          @SpringBootApplication
          public class Application {

              private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

              public static void main(String[] args) {
                  // Build the SDK auto-configuration extension module
                  OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                          .setResultAsGlobal(false)
                          .build()
                          .getOpenTelemetrySdk();
                  Application.openTelemetry = openTelemetrySdk;

                  SpringApplication.run(Application.class, args);
              }

              @Bean
              public OpenTelemetry openTelemetry() {
                  return openTelemetry;
              }

              // Add Spring WebMVC instrumentation by registering a tracing filter
              @Bean
              public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
                  return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
              }
          }
          ```
        </Step>

        <Step>
          #### Agregar biblioteca de instrumentación: métrica [#library-metrics]

          Genere y recopile métricas sobre su tiempo de ejecución de Java registrando lo siguiente en el archivo `Application.java` . Inserte las líneas resaltadas a continuación:

          ```java lineHighlight=14-20
          @SpringBootApplication
          public class Application {

              private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

              public static void main(String[] args) {
                  // Build the SDK auto-configuration extension module
                  OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                          .setResultAsGlobal(false)
                          .build()
                          .getOpenTelemetrySdk();
                  Application.openTelemetry = openTelemetrySdk;

                  // Register runtime metrics instrumentation
                  BufferPools.registerObservers(openTelemetrySdk);
                  Classes.registerObservers(openTelemetrySdk);
                  Cpu.registerObservers(openTelemetrySdk);
                  GarbageCollector.registerObservers(openTelemetrySdk);
                  MemoryPools.registerObservers(openTelemetrySdk);
                  Threads.registerObservers(openTelemetrySdk);

                  SpringApplication.run(Application.class, args);
              }

              @Bean
              public OpenTelemetry openTelemetry() {
                  return openTelemetry;
              }

              // Add Spring WebMVC instrumentation by registering a tracing filter
              @Bean
              public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
                  return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
              }
          }
          ```
        </Step>

        <Step>
          #### Agregar biblioteca de instrumentación: log [#library-logs]

          Esta aplicación de demostración está configurada para usar `OpenTelemetryAppender` (a través de `log4j.xml`), que usa `GlobalLoggerProvider`. La configuración de `GlobalLoggerProvider` conecta el `OpenTelemetryAppender` al SDK log que se configura mediante la configuración automática aquí:

          1. Abra `Application.java`.

          2. Inserte las siguientes líneas resaltadas.

             ```java lineHighlight=14-15
             @SpringBootApplication
             public class Application {

                 private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

                 public static void main(String[] args) {
                     // Build the SDK auto-configuration extension module
                     OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                             .setResultAsGlobal(false)
                             .build()
                             .getOpenTelemetrySdk();
                     Application.openTelemetry = openTelemetrySdk;

                     // Set GlobalLoggerProvider, which is used by Log4j2 appender
                     GlobalLoggerProvider.set(openTelemetrySdk.getSdkLoggerProvider());

                     // Register runtime metrics instrumentation
                     BufferPools.registerObservers(openTelemetrySdk);
                     Classes.registerObservers(openTelemetrySdk);
                     Cpu.registerObservers(openTelemetrySdk);
                     GarbageCollector.registerObservers(openTelemetrySdk);
                     MemoryPools.registerObservers(openTelemetrySdk);
                     Threads.registerObservers(openTelemetrySdk);

                     SpringApplication.run(Application.class, args);
                 }

                 @Bean
                 public OpenTelemetry openTelemetry() {
                     return openTelemetry;
                 }

                 // Add Spring WebMVC instrumentation by registering a tracing filter
                 @Bean
                 public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
                     return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
                 }
             }
             ```

          3. Cree un directorio llamado `resources` en `Uninstrumented/src/main`.

          4. En este nuevo directorio, cree un archivo llamado `log4j2.xml` con el siguiente contenido:

             ```xml
             <?xml version="1.0" encoding="UTF-8"?>
             <Configuration status="WARN" packages="io.opentelemetry.instrumentation.log4j.appender.v2_17">
               <Appenders>
                 <Console name="ConsoleAppender" target="SYSTEM_OUT" follow="true">
                   <PatternLayout pattern="%d{yyyy-mm-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
                 </Console>
                 <OpenTelemetry name="OpenTelemetryAppender" />
               </Appenders>
               <Loggers>
                 <Root level="info">
                   <AppenderRef ref="OpenTelemetryAppender" />
                   <AppenderRef ref="ConsoleAppender" />
                 </Root>
               </Loggers>
             </Configuration>
             ```

             <Callout variant="tip">
               La sección `packages=...` de esta línea permite a Log4J encontrar y configurar el `OpenTelemetryAppender`. El código fuente está [en el repositorio de OpenTelemetry](https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/instrumentation/log4j/log4j-appender-2.17/library) y se agregó como una dependencia a través de `io.opentelemetry.instrumentation:opentelemetry-log4j-appender-2.17`)
             </Callout>
        </Step>

        <Step>
          #### Instrumentación de traza personalizada: Crear constantes de atributo span [#custom-attribs]

          Cada traza se compone de tramos, que representan una unidad de trabajo lógica o una operación dentro de una solicitud particular. El siguiente código lo demuestra:

          * Constantes estáticas para contener claves de atributos que se pueden usar para proporcionar Insights a nivel de solicitud en sus intervalos.
          * Cómo inicializar un [rastreador](https://opentelemetry.io/docs/concepts/signals/traces/#tracer), que crea tramos

          Inserte las siguientes líneas resaltadas en `Controller.java`:

          ```java lineHighlight=4-14
          @RestController
          public class Controller {

              // Attribute constants
              private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
              private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");

              private final Tracer tracer;

              @Autowired
              Controller(OpenTelemetry openTelemetry) {
                  // Initialize tracer
                  tracer = openTelemetry.getTracer(Controller.class.getName());
              }

              @GetMapping(value = "/fibonacci")
              . . .
          }
          ```
        </Step>

        <Step>
          #### Traza instrumentación personalizada: Crear un tramo personalizado [#cust-span]

          Puede crear los intervalos que desee y depende de usted anotar sus intervalos con atributos en operaciones específicas. El atributo que establezca proporcionará contexto adicional sobre la operación específica que está rastreando, como resultados o propiedades de la operación.

          1. En `Controller.java`, inserte estas líneas resaltadas para iniciar un nuevo intervalo llamado `fibonacci` que hace lo siguiente:

             * Captura datos sobre la ejecución de este método.
             * Establece un atributo que almacena el valor de n de la solicitud del usuario.

             ```java lineHighlight=2-3
             private long fibonacci(long n) {
                 // Start a new span and set your first attribute
                 var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();
                 . . .
             }
             ```

          2. Agregue detalles granulares a su código agregando un atributo a su intervalo para almacenar información sobre solicitudes exitosas:

             ```java lineHighlight=20-21
             private long fibonacci(long n) {
                 // Start a new span and set your first attribute
                 var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();

                 try {
                     if (n < 1 || n > 90) {
                         throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                     }

                     long result = 1;
                     if (n > 2) {
                     long a = 0;
                     long b = 1;

                     for (long i = 1; i < n; i++) {
                         result = a + b;
                         a = b;
                         b = result;
                     }
                     // Set a span attribute to capture information about successful requests
                     span.setAttribute(ATTR_RESULT, last);
                     return last;
                 } catch (IllegalArgumentException e) {
                     throw e;
                 }
             }
             ```
        </Step>

        <Step>
          #### Instrumentación de traza personalizada: Registrar una excepción [#span-exception]

          Es posible que desee registrar las excepciones a medida que ocurren. Le recomendamos hacer esto junto con la configuración del estado del intervalo. Primero, establezca su intervalo como el intervalo actual, establezca el código de estado en error en caso de una excepción y luego finalice el intervalo:

          ```java lineHighlight=5-6,26-27,29-32
          private long fibonacci(long n) {
              // Start a new span and set your first attribute
              var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();

              // Set the span as the current span
              try (var scope = span.makeCurrent()) {
                  if (n < 1 || n > 90) {
                      throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                  }

                  long result = 1;
                  if (n > 2) {
                      long a = 0;
                      long b = 1;

                      for (long i = 1; i < n; i++) {
                          result = a + b;
                          a = b;
                          b = result;
                      }
                  }
                  // Set a span attribute to capture information about successful requests
                  span.setAttribute(ATTR_RESULT, result);
                  return result;
              } catch (IllegalArgumentException e) {
                  // Record the exception and set the span status
                  span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
                  throw e;
              } finally {
                  // End the span
                  span.end();
              }
          }
          ```

          Este método genera un `IllegalArgumentException` si un usuario proporciona una entrada no válida. Cuando esto sucede, la excepción se registra como un evento en el intervalo y el estado del intervalo se establecerá en `ERROR`. El mensaje de excepción se captura como descripción del estado. La excepción se registrará como un evento en el lapso donde ocurra.

          Finalmente, en `handleException()` en la clase `ErrorHandler` , establezca el estado del intervalo en `ERROR` con estas líneas resaltadas:

          ```java lineHighlight=10-11
          @ControllerAdvice
          private static class ErrorHandler {

              @ExceptionHandler({
                  IllegalArgumentException.class,
                  MissingServletRequestParameterException.class,
                  HttpRequestMethodNotSupportedException.class
              })
              public ResponseEntity<Object> handleException(Exception e) {
                  // Set the span status and description
                  Span.current().setStatus(StatusCode.ERROR, e.getMessage());
                  return new ResponseEntity<>(Map.of("message", e.getMessage()), HttpStatus.BAD_REQUEST);
              }
          }
          ```

          Como en el paso anterior, esto establece el código de estado del intervalo si el usuario ingresa un número no válido. Sin embargo, debido a que esto sucede en el controlador de excepciones, en lugar de en `fibonacci()`, el intervalo actual es el principal de intervalo de la solicitud. Este tramo principal proviene de la instrumentación Spring Web MVC agregada mediante el filtro en la clase de aplicación. Ahora, cuando el extremo de su aplicación genere una excepción, tanto el tramo principal como el tramo secundario tendrán un estado de tramo de `ERROR`.
        </Step>

        <Step>
          #### Instrumentación métrica personalizada: Añadir un contador métrica personalizada [#metrics-cust]

          Las métricas son un tipo telemetry data que son realmente útiles porque combinan mediciones individuales en agregaciones y producen datos que son constantes en función de la carga del sistema. Puede utilizar estos datos junto con intervalos para ayudar a detectar tendencias y proporcionar telemetría en tiempo de ejecución de la aplicación. También puede anotar cualquier métrica con un atributo para ayudar a describir qué subdivisión de las medidas representa la métrica.

          La API de OpenTelemetry métrica define una serie de instrumentados, que registran mediciones que son agregadas por el SDK de métrica y exportadas fuera de proceso. Hay dos tipos de instrumentado:

          * Síncrono: Estos instrumentados registran las mediciones a medida que ocurren.
          * Asincrónico: Estos instrumentados registran un callback, el cual se invoca solo una vez por colección y no tiene contexto asociado

          <Callout variant="tip">
            Si tiene alguna pregunta sobre el estado de la métrica en el proyecto OpenTelemetry, consulte los [estados de las señales](https://opentelemetry.io/docs/instrumentation/java/#status-and-releases).
          </Callout>

          Complete lo siguiente para agregar un contador personalizado:

          1. Cree una instancia de un atributo booleano para su métrica personalizada e inicialice una métrica instrumentada. <Callout variant="tip">En este caso, estamos usando un [LongCounter](https://opentelemetry.io/docs/instrumentation/java/manual/#metrics), que registra solo valores positivos y es útil para contar cosas, como la cantidad de bytes enviados a través de una red. De forma predeterminada, las medidas de los contadores se agregan a sumas monótonas (siempre crecientes).</Callout>

             ```java lineHighlight=7,10,16-21
             @RestController
             public class Controller {

                 // Attribute constants
                 private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
                 private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");
                 private static final AttributeKey<Boolean> ATTR_VALID_N = AttributeKey.booleanKey("fibonacci.valid.n");

                 private final Tracer tracer;
                 private final LongCounter fibonacciInvocations;

                 @Autowired
                 Controller(OpenTelemetry openTelemetry) {
                     // Initialize tracer
                     tracer = openTelemetry.getTracer(Controller.class.getName());
                     // Initialize instrument
                     Meter meter = openTelemetry.getMeter(Controller.class.getName());
                     fibonacciInvocations = meter
                         .counterBuilder("fibonacci.invocations")
                         .setDescription("Measures the number of times the fibonacci method is invoked.")
                         .build();
                 }
                 . . .
             }
             ```

          2. Inserte las siguientes líneas resaltadas para que su contador personalizado pueda capturar entradas válidas e inválidas, así como la cantidad de veces que ocurre cada una.

             ```java lineHighlight=24-25,30-31
             private long fibonacci(long n) {
                 // Start a new span and set your first attribute
                 var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();

                 // Set the span as the current span
                 try (var scope = span.makeCurrent()) {
                     if (n < 1 || n > 90) {
                         throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                     }

                     long result = 1;
                     if (n > 2) {
                         long a = 0;
                         long b = 1;

                         for (long i = 1; i < n; i++) {
                             result = a + b;
                             a = b;
                             b = result;
                         }
                     }
                     // Set a span attribute to capture information about successful requests
                     span.setAttribute(ATTR_RESULT, result);
                     // Counter to increment the number of times a valid input is recorded
                     fibonacciInvocations.add(1, Attributes.of(ATTR_VALID_N, true));
                     return result;
                 } catch (IllegalArgumentException e) {
                     // Record the exception and set the span status
                     span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
                     // Counter to increment the number of times an invalid input is recorded
                     fibonacciInvocations.add(1, Attributes.of(ATTR_VALID_N, false));
                     throw e;
                 } finally {
                     // End the span
                     span.end();
                 }
             }
             ```
        </Step>

        <Step>
          #### Instrumentación log personalizados [#cust-log]

          El estado de la señal de registro en OpenTelemetry Java es actualmente [experimental](https://opentelemetry.io/docs/instrumentation/java/#status-and-releases). Los mensajes de registro son administrados por el controlador raíz de su aplicación, que enviará registros de nivel `INFO` y superiores a la consola de forma predeterminada. Sin embargo, puede modificar el comportamiento logger cambiando el nivel de registro, incluso para clases específicas, o instalando un controlador o filtro personalizado.

          ##### Inicializar el logger [#initialize-logger]

          Como se indicó anteriormente, esto es de la biblioteca `java.util.logging` . El logger no es un componente de OpenTelemetry, pero la aplicación se ha configurado para enviar el registro de Log4j al SDK log OpenTelemetry:

          ```java lineHighlight=4-5
          @RestController
          public class Controller {

              // Logger (note that this is not an OTel component)
              private static final Logger LOGGER = LogManager.getLogger(Controller.class);

              // Attribute constants
              private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
              private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");
              private static final AttributeKey<Boolean> ATTR_VALID_N = AttributeKey.booleanKey("fibonacci.valid.n");
              . . .
          }
          ```

          ##### Agregar mensaje de registro personalizado [#cust-log-messages]

          Una vez que haya inicializado el logger, puede utilizarlo para logger :

          * El resultado de una entrada válida, junto con el valor de ese resultado.
          * Cuando no se registró ninguna salida

          Inserte las siguientes líneas resaltadas:

          ```java lineHighlight=26-27,34-35
          private long fibonacci(long n) {
              // Start a new span and set your first attribute
              var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();

              // Set the span as the current span
              try (var scope = span.makeCurrent()) {
                  if (n < 1 || n > 90) {
                      throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                  }

                  long result = 1;
                  if (n > 2) {
                      long a = 0;
                      long b = 1;

                      for (long i = 1; i < n; i++) {
                          result = a + b;
                          a = b;
                          b = result;
                      }
                  }
                  // Set a span attribute to capture information about successful requests
                  span.setAttribute(ATTR_RESULT, result);
                  // Counter to increment the number of times a valid input is recorded
                  fibonacciInvocations.add(1, Attributes.of(ATTR_VALID_N, true));
                  // Log the result of a valid input
                  LOGGER.info("Compute fibonacci(" + n + ") = " + result);
                  return result;
              } catch (IllegalArgumentException e) {
                  // Record the exception and set the span status
                  span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
                  // Counter to increment the number of times an invalid input is recorded
                  fibonacciInvocations.add(1, Attributes.of(ATTR_VALID_N, false));
                  // Log when no output was recorded
                  LOGGER.info("Failed to compute fibonacci(" + n + ")");
                  throw e;
              } finally {
                  // End the span
                  span.end();
              }
          }
          ```
        </Step>

        <Step>
          #### Ejercite la aplicación para generar algo de tráfico. [#exercise-app]

          ¡Estás listo para enviar algunos datos a New Relic!

          1. Vaya al directorio `getting-started-guides/java` y cree y ejecute la aplicación con este comando:

             * Mac OS:

               ```bash
               ./gradlew bootRun
               ```

             * Potencia Shell:

               ```bash
               .\gradlew.bat build
               ```

               <Callout variant="tip">
                 Si su terminal muestra Spring ASCII, significa que su aplicación se ha creado correctamente y se está ejecutando:

                 <img
                   alt="Screenshot showing Spring Boot ASCII logo"
                   title="Screenshot showing Spring Boot ASCII logo"
                   src={opentelemetrySpringBootASCIIDisplay}
                 />
               </Callout>

          2. Genere tráfico desde la aplicación abriendo una nueva terminal en el directorio `getting-started-guides/java/Uninstrumented` y ejecutando el generador de carga:

             * Mac OS:

               ```bash
               ./load-generator.sh
               ```

             * Potencia Shell:

               ```bash
               .\load-generator.ps1
               ```

             <Callout variant="tip">
               Alternativamente, puede llegar al extremo en el browser en esta URL: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE`. Reemplace `INSERT_A_VALUE` con un valor de 1 a 90. Para generar un error, inserte un número entero fuera del rango válido.
             </Callout>

          3. Ahora que ha enviado algunos datos a New Relic, consulte nuestras [instrucciones sobre cómo ver los datos en la UI](#view-data).
        </Step>
      </Steps>
    </TabsPageItem>
  </TabsPages>
</Tabs>

## Vea los datos de su demostración en New Relic [#view-data]

No importa qué tutorial haya completado, puede seguir los consejos a continuación para encontrar sus datos en la UI de New Relic.

1. Vaya a

   <DoNotTranslate>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > APM & services**</DoNotTranslate>

   .

2. Haga clic en su nueva entidad (servicio) llamada `getting-started-java` (o cualquier nombre que haya proporcionado).

3. Consulte los detalles en las secciones para cada tipo de datos.

<Callout variant="tip">
  Si está utilizando Windows y no ve datos en su cuenta de New Relic, verifique que haya permitido el tráfico a través del firewall.
</Callout>

### Traza [#traces]

Una vez que hayas llegado a la entidad `getting-started-java` en New Relic:

1. En la sección

   <DoNotTranslate>**Monitor**</DoNotTranslate>

   del panel izquierdo, haga clic en

   <DoNotTranslate>**Distributed tracing**</DoNotTranslate>

   y luego haga clic en el grupo de trazas

   <DoNotTranslate>**Fibonacci**</DoNotTranslate>

   .

   <img alt="Screenshot showing the main distributed tracing page" title="Screenshot showing the main distributed tracing page" src={opentelemetryMainDistributedTracingPage}/>

2. Desde allí, busca una traza con un error y haz clic para abrirla:

   <img alt="Screenshot showing an error in distributed tracing" title="Screenshot showing an error in distributed tracing" src={opentelemetryDistributedTracingError}/>

3. Una vez que tenga la traza abierta, haga clic en `Show in-process spans` y luego haga clic en el tramo resultante, lo que abrirá un panel de detalles a la derecha. Para ver la excepción que registró cuando la entrada de un usuario no es válida, haga clic en `View span events`:

   <img title="Screenshot of in-process spans" alt="Screenshot of in-process spans" src={opentelemetryInProcessSpans}/>

Si completó el tutorial de instrumentación manual, así es como se verá la excepción que registró como un lapso en New Relic:

<img
  title="Screenshot showing an exception as a span event"
  alt="Screenshot showing an exception as a span event"
  src={opentelemetryExceptiononSpanEvent}
/>

Para ver detalles adicionales que configuró, como el atributo de intervalo, el nombre del intervalo y el código de estado, haga clic en la pestaña <DoNotTranslate>**Attributes**</DoNotTranslate> . En este panel también puede ver metadatos adicionales que recopila automáticamente la biblioteca de instrumentación que utilizó en esta guía, así como los metadatos adjuntos de New Relic:

<img
  title="Screenshot of the attributes tab"
  alt="Screenshot of the attributes tab"
  src={opentelemetryAttributesTab}
/>

Para obtener más detalles sobre cómo ver sus datos, consulte [OpenTelemetry en la UIde New Relic](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page)

### Métrica [#metrics]

Una vez que haya llegado a la entidad `getting-started-java` en New Relic, podrá ver una lista de todas las métricas recopiladas, como las métricas de tiempo de ejecución (JVM) y su atributo de contador personalizado.

#### Explorador métrico [#metrics-explorer]

Esta es una herramienta que te permite ver una lista de tus métricas.

1. En el panel izquierdo, seleccione <DoNotTranslate>**Data > Metrics explorer**</DoNotTranslate> y luego seleccione `fibonacci.invocations`.

   <img
     title="Screenshot showing metrics explorer"
     alt="Screenshot showing metrics explorer"
     src={opentelemetryMetricsExplorerMain}
   />

2. En <DoNotTranslate>**Dimensions**</DoNotTranslate>, vea el atributo que recopiló junto con su métrica personalizada y luego haga clic en <DoNotTranslate>**fibonacci.valid.n**</DoNotTranslate>.

   <img
     title="Screenshot showing the total number of invocations of fibonacci function"
     alt="Screenshot showing the total number of invocations of fibonacci function"
     src={opentelemetryMetricsExplorerDimensions}
   />

Conozca más en nuestra documentación sobre la [vista del explorador métrica](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-metrics-explorer-page).

#### JVM [#jvms]

También puede ver visualizaciones de su métrica de tiempo de ejecución de Java, incluido el rendimiento, el uso de memoria y el tiempo de recolección de basura por minuto, dirigiéndose a la página de JVM:

<img
  title="Screenshot of the main JVMs page"
  alt="Screenshot of the main JVMs page"
  src={opentelemetryJvmsPageMain}
/>

Puede ver la métrica de una sola instancia o seleccionar varias instancias para compararlas:

<img
  title="Screenshot of how to compare JVM instances"
  alt="Screenshot of how to compare JVM instances"
  src={opentelemetryCompareJvmInstances}
/>

Esto es lo que verá después de seleccionar sus instancias y hacer clic en <DoNotTranslate>**Compare**</DoNotTranslate>, donde cada instancia está codificada por colores para una fácil identificación:

<img
  title="Screenshot showing the color-coded JVM comparison"
  alt="Screenshot showing the color-coded JVM comparison"
  src={opentelemetryJvmColorCodedComparison}
/>

Para obtener más información, consulte nuestra documentación sobre la [vista JVM](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-jvms-page/).

### Registro [#logs]

Aquí es donde acceder a su registro:

<img
  title="Screenshot showing the main logs page"
  alt="Screenshot showing the main logs page"
  src={opentelemetryMainLogsPage}
/>

También verás iniciar sesión en tu terminal:

<img
  title="Screenshot showing logs in a terminal"
  alt="Screenshot showing logs in a terminal"
  src={opentelemetryLogsinTerminal}
/>

De vuelta en su vista de registro, seleccione un log y verá un panel abierto con el mensaje de registro y los atributos adicionales que se recopilaron, como el intervalo asociado y los identificadores de traza, así como los metadatos inyectados por New Relic:

<img
  title="Screenshot showing log details with trace"
  alt="Screenshot showing log details with trace"
  src={opentelemetryLogDetailsWithTrace}
/>

Puedes navegar al rastreo distribuido correlacionado haciendo clic en este pequeño icono azul:

<img
  title="Screenshot showing how to find correlated trace"
  alt="Screenshot showing how to find correlated trace"
  src={opentelemetryTraceRelatedtoLog}
/>

Esto abrirá un panel que muestra la traza correlacionada, donde podrá ver más detalles sobre la traza. Para obtener más información sobre esta página, consulte [OpenTelemetry en la UI: página de rastreo distribuido](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page/) y [Comprender y utilizar la UIde rastreo distribuido](/docs/distributed-tracing/ui-data/understand-use-distributed-tracing-ui/):

<img
  title="Screenshot showing the trace waterfall from the logs section"
  alt="Screenshot showing the trace waterfall from the logs section"
  src={opentelemetryTraceWaterfallFromLog}
/>

También puede encontrar el log correlacionado desde la vista de rastreo distribuido. Cuando selecciones una traza que tenga su correspondiente log, lo verás indicado como una pestaña, y podrás visualizar el log directamente desde la traza sin tener que cambiar de vista:

<img
  title="Screenshot showing how to see log details from a trace span"
  alt="Screenshot showing how to see log details from a trace span"
  src={opentelemetryLogCapturedinTraceSpan}
/>

Obtenga más información sobre la vista de registro [aquí](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-logs-page).

## Referencia: variables de entorno [#ref-env-vars]

Esta es una lista de las variables de entorno que debes exportar si estás realizando el tutorial 2 o 3. Una vez que termine de exportar las variables, regrese a los tutoriales utilizando los enlaces que siguen a la lista de variables:

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="env-vars-table"
    title="Haga clic aquí para abrir la lista de variables de entorno."
  >
    <table>
      <tbody>
        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_HEADERS=api-key=YOUR_LICENSE_KEY`

            * Encabezados: Esto determina a qué cuenta de New Relic se enviarán sus datos. Reemplace `YOUR_LICENSE_KEY` con su

              <InlinePopover type="licenseKey"/>

              .
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.nr-data.net` (Para EE. UU.) `OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.eu01.nr-data.net` (Para la UE)

            * Este es el extremo al que se exportará la telemetría de su aplicación. Exportar datos al extremo OTLP de New Relic.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_PROTOCOL=http/protobuf`

            * Especifica que se debe utilizar OTLP `http/protobuf` , que es el preferido por New Relic.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_SERVICE_NAME=getting-started-java`

            * Este es el nombre que asocia la telemetría de su aplicación con una entidad en New Relic. En este tutorial lo llamamos `getting-started-java`, pero puedes llamarlo como quieras.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_RESOURCE_ATTRIBUTES=service.instance.id=INSERT_YOUR_OWN_ID_HERE`

            * Reemplace `INSERT_YOUR_OWN_ID_HERE` con un ID único de la instancia. Por ejemplo, podrías usar `1234`. Para obtener más detalles, consulte [Convenciones semánticas de recursos](https://github.com/open-telemetry/semantic-conventions/blob/main/docs/resource/README.md#service-experimental) de OpenTelemetry.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT=4095`

            * Establecer un límite en la longitud máxima del valor del atributo evitará que los datos de extensión se eliminen si exceden el [límite de New Relic](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/best-practices/opentelemetry-best-practices-attributes/).
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE=DELTA`

            * New Relic admite métrica en temporalidad delta en lugar del valor predeterminado de acumulativa.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_METRICS_DEFAULT_HISTOGRAM_AGGREGATION=BASE2_EXPONENTIAL_BUCKET_HISTOGRAM`

            * (Recomendado) Agregación de histogramas: utilice un histograma exponencial en lugar del histograma de depósito explícito predeterminado para una mejor compresión de datos.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_LOGS_EXPORTER=otlp`

            * Habilite la exportación log a través de OTLP. La exportación log está deshabilitada de forma predeterminada.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_COMPRESSION=gzip`

            * (Recomendado) Configurar la compresión gzip le permite maximizar la cantidad de datos que puede enviar por solicitud. Nuestro tamaño de carga útil máximo permitido es 1 MB (10^6 bytes). La compresión Gzip tiene un buen rendimiento y reduce la salida de datos.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPERIMENTAL_EXPORTER_OTLP_RETRY_ENABLED=true`

            * (Recomendado) Habilite el reintento de exportación experimental para ayudar a hacer frente a la falta de confiabilidad de Internet.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPERIMENTAL_RESOURCE_DISABLED_KEYS=process.command_line`

            * (Recomendado) Esto deshabilita el atributo de recurso `process.command_line` , que a menudo excede el límite de longitud máxima del atributo New Relic y puede contener información confidencial.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

Una vez que haya creado las variables de entorno enumeradas en el colapsador anterior, regrese al tutorial y complete la configuración:

* [Tutorial 2 (monitor la aplicación demo con el agente de Java OpenTelemetry)](#java-agent)
* [Tutorial 3 (Configurar la aplicación de demostración manualmente)](#auto-config-ext)

## ¿Que sigue? [#what-next]

Ahora que ha experimentado con la instrumentación de OpenTelemetry y la configuración del SDK, puede aplicar lo que ha aprendido para configurar su propia aplicación o servicio con OpenTelemetry y New Relic. Para obtener más información, consulte [Configure su propia aplicación o servicio con OpenTelemetry](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/get-started/opentelemetry-set-up-your-app).