---
title: NRQL 참조
tags:
  - Query your data
  - 'NRQL: New Relic Query Language'
  - Get started
metaDescription: 'A detailed reference list of clauses and functions in NRQL, the New Relic query language.'
freshnessValidatedDate: never
translationType: human
---

좋은 [NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language) 쿼리를 작성하려면 뉴렐릭의 다양한 NRQL 절과 함수가 작동하는 방식을 이해하는 것이 도움이 됩니다. 이 문서에는 NRQL 절 및 함수의 정의가 포함되어 있으며 사용 방법에 대한 예시가 제공됩니다.

기본 NRQL 구문 규칙을 찾고 계십니까? [NRQL 사용 방법](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-how-nrql-works)을 참조하십시오. 지침서가 필요하시면 [입문 NRQL 튜토리얼](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-tutorial)을 참조하십시오.

## 쿼리 구성 요소 [#clauses]

[기본 NRQL 구문 문서](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-how-nrql-works/#syntax)에 명시된 바와 같이 모든 NRQL 쿼리에는 `SELECT` 절과 `FROM` 절이 포함되며 다른 모든 절은 선택 사항입니다. 아래의 절 정의에는 예시 NRQL 쿼리도 포함되어 있습니다.

### 필수 조항 [#required]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="state-select"
    title={<>필수: <InlineCode>
      SELECT
    </InlineCode> 문</>}
  >
    ```sql
    SELECT attribute ...
    ```

    ```sql
    SELECT function(attribute) ...
    ```

    `SELECT`는 [속성](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#attribute) 또는 [함수](#functions)를 지정하여 데이터 유형의 쿼리할 부분을 지정합니다. 그 뒤에 쉼표로 구분된 하나 이상의 인수가 옵니다. 각 인수에서 다음을 수행할 수 있습니다.

    * `*`를 와일드카드로 사용하여 사용 가능한 모든 속성의 값을 가져옵니다. 예: `SELECT * from Transaction`.
    * 지정된 속성 또는 쉼표로 구분된 목록에 지정된 여러 속성과 연결된 값을 가져옵니다.
    * [집계 함수](#functions)를 선택하여 지정된 속성에서 집계된 값을 가져옵니다.
    * [`AS` 조항을 사용하여](#sel-as) 각 인수에 반환된 결과에 레이블을 지정합니다.

    [기본 수학 함수와 함께 `SELECT`를 사용할](/docs/query-data/nrql-new-relic-query-language/getting-started/nrql-math-using-select) 수도 있습니다.

    <CollapserGroup>
      <Collapser
        id="avg-resp-time-query"
        title="지난주 이후 평균 응답 시간"
      >
        이 쿼리는 지난주 이후의 평균 응답 시간을 반환합니다.

        ```sql
        SELECT average(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-from"
    title={<>필수: <InlineCode>
      FROM
    </InlineCode> 조항</>}
  >
    ```sql
    SELECT ...
      FROM data type
      ...
    ```

    쿼리할 [데이터 유형](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql#what-you-can-query)을 지정하려면 `FROM` 절을 사용합니다.`FROM` 또는 [`SELECT`](#state-select)로 쿼리를 시작할 수 있습니다. 쉼표로 구분된 목록의 여러 데이터 유형에서 동일한 속성의 값을 병합할 수 있습니다.

    <CollapserGroup>
      <Collapser
        id="one-event"
        title="하나의 데이터 유형 쿼리"
      >
        이 쿼리는 지난 7일 동안의 모든 [APM 트랜잭션](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) 수를 반환합니다.

        ```sql
        SELECT count(*) FROM Transaction SINCE 7 days ago
        ```
      </Collapser>

      <Collapser
        id="multiple-events"
        title="여러 데이터 유형 쿼리"
      >
        이 쿼리는 지난 3일 동안의 모든 [APM 트랜잭션](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) 및 [브라우저 이벤트](/docs/insights/new-relic-insights/decorating-events/browser-default-attributes-insights#browser-attributes-table) 수를 반환합니다.

        ```sql
        SELECT count(*) FROM Transaction, PageView SINCE 3 days ago
        ```
      </Collapser>

      <Collapser
        id="from-lookups"
        title="룩업 테이블에서 데이터 쿼리"
      >
        [`lookup()`](#func-lookup))을 참조하십시오.
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### 옵션 조항 [#optional]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="sel-as"
    title={<><InlineCode>
      AS
    </InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      AS 'label'
      ...
    ```

    `AS` 절을 사용해 작은 따옴표로 구분된 문자열로 속성, 집합자, 퍼널의 단계 또는 수학 함수 결과에 레이블을 지정합니다. 레이블은 결과 차트에 사용됩니다. `FACET` 절을 사용하는 경우, 시계열 차트의 `AS` 절 레이블이 표시되지 않는다는 점을 유의하시기 바랍니다.

    <CollapserGroup>
      <Collapser
        id="math-as"
        title={<>수학 함수를 사용한 쿼리 및 <InlineCode>
          AS
        </InlineCode></>}
      >
        이 쿼리는 세션당 페이지 뷰 수를 반환합니다.

        ```sql
        SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session'
          FROM PageView
        ```
      </Collapser>

      <Collapser
        id="funnel-as"
        title={<>퍼널을 사용한 쿼리 및 <InlineCode>
          AS
        </InlineCode></>}
      >
        이 쿼리는 지난 주에 사이트의 메인 페이지와 채용 정보 페이지를 모두 방문한 사람들의 수를 반환합니다.

        ```sql
        SELECT funnel(SESSION,
            WHERE name='Controller/about/main' AS 'Step 1',
            WHERE name = 'Controller/about/careers' AS 'Step 2')
            FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-compare"
    title={<><InlineCode>
      COMPARE WITH
    </InlineCode> 절</>}
  >
    ```sql
    SELECT ... (SINCE or UNTIL) (integer units) AGO
      COMPARE WITH (integer units) AGO
      ...
    ```

    `COMPARE WITH` 조항을 사용하여 서로 다른 두 시간 범위의 값을 비교합니다.

    `COMPARE WITH` `SINCE` 또는 `UNTIL` 문이 필요합니다. `COMPARE WITH`에 의해 지정된 시간은 `SINCE` 또는 `UNTIL`에 의해 지정된 시간에 상대적입니다. 예를 들어, `SINCE 1 day ago COMPARE WITH 1 day ago`는 어제와 전날을 비교합니다.

    `COMPARE WITH` 값의 시간 범위는 항상 `SINCE` 또는 `UNTIL`로 지정된 시간 범위와 동일합니다. 예를 들어 `SINCE 2 hours ago COMPARE WITH 4 hours ago`는 오후 3시부터 오후 5시까지를 오전 11시부터 오후 1시까지 비교할 수 있습니다.

    `COMPARE WITH` 라인 차트 또는 빌보드 형식을 지정할 수 있습니다.

    * `TIMESERIES`를 사용하여, `COMPARE WITH`는 비교가 시간에 따라 매핑된 라인 차트를 만듭니다.
    * `TIMESERIES`가 없으면 `COMPARE WITH`는 현재 값과 `COMPARE WITH` 값의 백분율 변경으로 빌보드를 생성합니다.

    <DNT>**Example**</DNT>이 쿼리는 1주일 전의 동일한 범위와 비교해 지난 주의 95번째 백분위수를 보여주는 선형 차트로 데이터를 반환합니다. 처음에는 단일 값으로, 그 다음에는 선형 차트로 보여줍니다.

    ```sql
    SELECT percentile(duration, 95) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO

    SELECT percentile(duration, 95) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO
    ```

    <Callout variant="important">
      `COMPARE WITH`을 사용하는 `FACET` 쿼리의 경우, 결과로 야기되는 패싯은 비교되는 이전 시간 범위가 아니라 `SINCE` 및 `UNTIL`을 사용하여 지정된 시간 범위를 기반으로 선택됩니다. 이전 시간 범위에 대한 `FACET` 쿼리의 결과에만 다른 패싯 세트가 포함될 수 있습니다.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="extrapolate"
    title={<><InlineCode>
      EXTRAPOLATE
    </InlineCode> 절</>}
  >
    다음 데이터 유형과 함께 이 조항을 사용할 수 있습니다.

    * `Transaction`

    * `TransactionError`

    * <InlinePopover type="apm"/>에이전트 API를 통해 보고되는 커스텀 이벤트

      `EXTRAPOLATE`의 목적은 쿼리 결과가 시스템의 총 활동을 더 가깝게 나타내도록 [이벤트 데이터의 APM 에이전트 샘플링](/docs/agents/manage-apm-agents/agent-data/new-relic-events-limits-sampling) 효과를 수학적으로 보정하는 것입니다.

      이 조항은 APM 에이전트가 너무 많은 [이벤트](/docs/using-new-relic/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#event-data)를 보고하여 종종 [하베스트 주기](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#harvest-cycle) 보고 한도를 넘어갈 때 유용합니다. 이 경우 에이전트는 이벤트를 샘플링하기 시작합니다.

      사용을 지원하는 NRQL 쿼리에서 `EXTRAPOLATE`가 사용되는 경우 <DNT>**reported events**</DNT> 와 <DNT>**total events**</DNT> 사이의 비율은 샘플링되지 않은 총 데이터의 가까운 근사치를 외삽합니다. 사용을 지원하지 않거나 샘플링된 데이터를 사용하지 않은 NRQL 쿼리에 사용하면 효과가 없습니다.

      <Callout variant="important">
        `EXTRAPOLATE`는 처리량이나 오류율과 같은 동종 데이터에 가장 유용합니다. 고유한 항목의 수(예: `uniqueCount()` 또는 `uniques()` )를 외삽하려고 시도할 때는 효과적이지 않습니다.
      </Callout>

      이 조항은 다음 [집계 기능](/docs/insights/nrql-new-relic-query-language/nrql-reference/nrql-syntax-components-functions#functions) 중 하나를 사용하는 NRQL 쿼리에서만 작동합니다.

    * `apdex`

    * `average`

    * `count`

    * `histogram`

    * `sum`

    * `percentage` (인수로 취하는 함수가 `EXTRAPOLATE`를 지원하는 경우)

    * `rate` (인수로 취하는 함수가 `EXTRAPOLATE`를 지원하는 경우)

    * `stddev`

      <CollapserGroup>
        <Collapser
          id="extrapolate-example-1"
          title="처리량 외삽의 예"
        >
          이름이 `interestingApplication`인 서비스의 외삽 처리량을 표시하는 쿼리입니다.

          ```sql
          SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE
          ```
        </Collapser>

        <Collapser
          id="extrapolate-example-2"
          title="처리량을 시계열로 외삽하는 예"
        >
          시계열로 표시되는 트랜잭션 이름별로 이름이 `interestingApplication`인 서비스의 외삽 처리량을 표시하는 쿼리입니다.

          ```sql
          SELECT count(*) FROM Transaction WHERE appName='interestingApplication'
          SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet"
    title={<><InlineCode>
      FACET
    </InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      FACET attribute
      ...
    ```

    `FACET`을 사용하여 속성 값으로 결과를 분리하고 그룹화합니다. 예를 들어 `deviceType`으로 `FACET` `PageView` 데이터를 사용하여 모바일, 태블릿 및 데스크톱 기기에서 발생하는 트래픽의 비율을 파악할 수 있습니다.

    `LIMIT` 조항을 사용하여 표시되는 패싯 수를 지정합니다(기본값은 10). 더 복잡한 그룹화의 경우 [`FACET CASES`](#sel-facet-cases)를 사용합니다. `FACET` 조항은 쉼표로 구분된 최대 5개의 속성을 지원합니다.

    패싯은 `SELECT` 절에 제공한 첫 번째 필드를 기준으로 내림차순으로 정렬됩니다. 고유값이 5,000개가 넘는 속성을 패싯하는 경우, 패싯 값의 하위 집합이 선택되어 쿼리 유형에 따라 정렬됩니다. 시계열 차트가 데이터를 반환하지 않는 경우(NRQL이 일치하는 데이터가 없거나 유효하지 않은 NRQL 등), `FROM` 절의 첫 번째 테이블과 매치하는 레이블이 있는 평평한 선만 표시됩니다.

    `min()` , `max()` , `percentile()` , `average()` 또는 `count()`를 선택할 때 `FACET`은 이러한 함수를 사용하여 패싯을 선택하고 정렬하는 방법을 결정합니다. 다른 [기능](#functions)을 선택할 때 `FACET`은 패싯 선택 및 정렬 방법을 결정하기 위해 패싯 대상 속성의 빈도를 사용합니다.

    <CollapserGroup>
      <Collapser
        id="faceted-query"
        title={<>다음을 사용하는 패싯 쿼리 <InlineCode>
          count()
        </InlineCode></>}
      >
        이 쿼리는 페이지뷰 수가 가장 높은 도시를 보여줍니다. 이 쿼리는 도시당 총 페이지뷰 수를 사용하여 패싯이 선택되고 정렬되는 방식을 결정합니다.

        ```sql
        SELECT count(*) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="uniquecount"
        title={<>다음을 사용하는 패싯 쿼리 <InlineCode>
          uniqueCount()
        </InlineCode></>}
      >
        이 쿼리는 가장 많은 수의 고유 URL에 액세스하는 도시를 보여줍니다. 이 쿼리는 결과에 특정 도시가 나타나는 총 횟수를 사용하여 패싯이 선택되고 정렬되는 방법을 결정합니다.

        ```sql
        SELECT uniqueCount(pageUrl) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="cohort-analysis"
        title="시간에 따른 결과 그룹화"
      >
        [고급 세분화](/docs/insights/new-relic-insights/features/advanced-segmentation) 및 [코호트 분석](/docs/insights/new-relic-insights/features/cohort-analysis-grouping-results-across-time)을 통해 버킷 기능을 패싯하여 데이터를 보다 효과적으로 분류할 수 있습니다.

        코호트 분석은 타임스탬프를 기반으로 결과를 그룹화하는 방법입니다. 지정된 날짜 및 시간 범위를 포함하는 버킷으로 분리할 수 있습니다.
      </Collapser>
    </CollapserGroup>

    <Callout variant="important">
      함수를 사용하여 속성 값을 집계할 때, 쿼리의 첫 번째 함수에서 집계되는 속성에 null이 아닌 값이 포함되어 있어야 합니다. 패싯은 첫 번째 함수의 속성에 대해 null이 아닌 값을 포함하는 행에 대해서만 선택됩니다.

      예:

      ```sql
      FROM Event SELECT average(attribute) FACET name
      ```

      속성이 null이 아닌 행에서만 이름이 선택됩니다.

      함수에서 사용 중인 속성에 null이 아닌 값이 포함되어 있는지 확인하려면 다음 쿼리를 실행합니다.

      ```sql
      FROM Event SELECT attribute, name WHERE attribute IS NOT NULL
      ```
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="facet-as"
    title={<><InlineCode>
      FACET ... AS
    </InlineCode> 절</>}
  >
    쿼리에서 `AS` 키워드를 사용하여 패싯의 이름을 지정하려면 `FACET ... AS`를 사용합니다. 이 조항은 결과에서 패싯에 대해 더 명확하거나 단순화된 이름을 추가하는 데 유용합니다. 또한 [중첩 집계](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query) 쿼리에서 패싯의 이름을 바꾸는 데 사용할 수도 있습니다.

    `FACET ... AS` 쿼리는 결과의 패싯 이름을 변경하지만(예: 테이블의 헤더로 나타날 때) 실제 패싯 이름 자체는 변경하지 않습니다.

    ```sql
    FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type'
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-cases"
    title={<><InlineCode>
      FACET CASES
    </InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      FACET CASES (
        WHERE attribute operator value, WHERE attribute operator value, ...
        )
      ...
    ```

    [`FACET`](#sel-facet) 보다 더 복잡한 조건으로 데이터를 세분화하려면 `FACET CASES`를 사용합니다. 여러 조건을 쉼표(`,`)로 구분합니다. 예를 들어, `PageView` 데이터와 `FACET CASES`를 1초 미만, 1-10초, 10초 초과 등의 카테고리로 쿼리할 수 있습니다. 케이스 내에서 여러 속성을 결합하고, [`AS`](#sel-as) 선택기로 케이스에 라벨을 지정할 수 있습니다. 데이터 포인트는 최대 하나, 즉 매치하는 첫 번째 패싯 케이스에 추가됩니다.

    속성과 함께 [시간 함수](/docs/query-data/nrql-new-relic-query-language/nrql-query-examples/group-results-across-time)를 사용할 수도 있고 `OR` 연산자를 사용하여 지정된 케이스와 일치하지 않는 결과를 패싯할 수 있습니다.

    <CollapserGroup>
      <Collapser
        id="facet-cases-basic"
        title={<>기본 사용법 <InlineCode>
          WHERE
        </InlineCode></>}
      >
        ```sql
        SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10)
        ```
      </Collapser>

      <Collapser
        id="facet-cases-mixnmatch"
        title="여러 속성을 기반으로 그룹화"
      >
        이 예에서는 트랜잭션 이름에 `login`이 포함된 버킷과 URL에 `login`이 포함되고 사용자 지정 속성이 사용자가 유료 사용자임을 나타내는 버킷으로 결과를 그룹화합니다.

        ```sql
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid')
        ```
      </Collapser>

      <Collapser
        id="facet-cases-as-label"
        title={<>다음으로 그룹에 레이블 지정 <InlineCode>
          AS
        </InlineCode></>}
      >
        이 예에서는 [`AS`](#sel-as) 선택기를 사용하여 결과에 사람이 읽을 수 있는 이름을 지정합니다.

        ```sql
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users')
        ```
      </Collapser>

      <Collapser
        id="facet-cases-with-or"
        title={<>패싯 일치하지 않는 데이터 <InlineCode>
          OR
        </InlineCode></>}
      >
        이 예에서는 `OR` 연산자를 사용하여 사례와 일치하지 않는 결과를 패싯합니다.

        ```sql
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') OR name
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-order"
    title={<><InlineCode>
      FACET ... ORDER BY
    </InlineCode> 절</>}
  >
    NRQL에서 기본값은 쿼리에서 패싯 선택을 안내하는 `SELECT` 절의 첫 번째 집계입니다. `FACET ... ORDER BY`를 사용하면 패싯 선택 방법을 지정하는`ORDER BY` 수정자와 함께 집계 함수를 추가하여 기본 동작을 재정의할 수 있습니다. 특히 이 절은 `LIMIT` 절에 의해 제한되기 전에 패싯이 최종 결과에 포함되도록 선택의 우선순위를 재정의합니다. 이 절은 쿼리에 사용할 수 있지만 알림 또는 스트리밍에는 사용할 수 없습니다.

    이 예에서는 `FACET ... ORDER BY`를 사용하여 앱 트랜잭션의 평균 기간을 찾는 방법을 보여주며 응답 크기가 가장 높은 앱별로 상위 10개(기본 제한)의 가장 높은 기간을 보여줍니다. 이 경우 `FACET ... ORDER BY`가 사용되지 않으면 쿼리 결과는 대신 가장 높은 기간별로 상위 10개를 표시하며 응답 크기는 앱 선택과 관련이 없습니다.

    ```sql
    FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize)
    ```

    `FACET ... ORDER BY` 절을 사용하는 경우 `ASC` 및 `DESC` 수정자를 추가하여 정렬 순서를 변경할 수 없습니다. 기본적으로 이 절은 `DESC`를 사용합니다.

    <Callout variant="tip">
      작업은 `LIMIT` 조항이 적용되기 전에 수행되기 때문에 `FACET ... ORDER BY`는 최종 쿼리 결과의 정렬에 영향을 미치지 않으며, 이는 시계열이 아닌 쿼리의 결과에서 특히 두드러집니다.
    </Callout>

    <Callout variant="important">
      이 경우 `ORDER BY` 수정자는 `ORDER BY` 조항과 다르게 작동합니다. `FACET attribute1 ORDER BY attribute2` 형식을 따르는 쿼리를 구문 분석할 때 뉴렐릭은 이러한 쿼리를 `FACET ... ORDER BY` 쿼리로 읽지만 `ORDER BY`가 `FACET` 바로 뒤에 나타나는 경우에만 가능합니다. 그렇지 않으면 `ORDER BY`는 뉴렐릭에 의해 조항로 해석됩니다.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-join"
    title={<><InlineCode>
      JOIN
    </InlineCode> 절</>}
  >
    `JOIN` 절을 사용하면, 한 이벤트 유형의 데이터를 공통 속성 또는 키를 기반으로 하위 쿼리의 결과와 결합할 수 있습니다.

    ```sql
    FROM Event [INNER|LEFT] JOIN (SELECT... FROM...) ON [key =] key SELECT ...
    ```

    하위 쿼리 결합에는 몇 가지 간단한 규칙이 존재합니다.

    * `JOIN` 절은 항상 [`FROM`](#sel-from) 절 바로 뒤에 와야 합니다.
    * 결합 유형(`INNER` 또는 `LEFT`) 접두사는 선택 사항입니다. 선택을 하지 않으면 결합 유형은 `INNER`로 기본 설정됩니다.
    * [하위 쿼리](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql)를 포함하는 괄호는 `JOIN` 바로 뒤에 와야 합니다.
    * `ON` 절은 하위 쿼리 바로 뒤에 와야 합니다.

    <table id="join-types">
      <thead>
        <tr>
          <th colSpan={2}>
            <DNT>
              **Join types**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td style={{ width: "300px" }}>
            `INNER`
          </td>

          <td>
            결과에는 결합된 하위 쿼리의 결과에 일치하는 값이 있는 외부 쿼리의 값만 포함됩니다. 이것이 기본 결합 유형입니다.
          </td>
        </tr>

        <tr>
          <td>
            `LEFT`
          </td>

          <td>
            결과에는 결합된 하위 쿼리와 일치하지 않는 외부 쿼리의 이벤트가 포함됩니다.
          </td>
        </tr>
      </tbody>
    </table>

    <table id="join-on">
      <thead>
        <tr>
          <th colSpan={2}>
            <DNT>
              **Join `ON` clause**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td style={{ width: "300px" }}>
            `ON parentKey = subqueryKey`
          </td>

          <td>
            하위 쿼리와 외부 쿼리에서 비교할 키 값을 정의합니다. 허용되는 유일한 비교 연산자는 같음입니다.

            * 왼쪽은 항상 상위 쿼리에서 사용되는 키이며, 속성 또는 함수일 수 있습니다.
            * 오른쪽은 하위 쿼리 키 값에 사용되며, 식별자여야 합니다.
          </td>
        </tr>

        <tr>
          <td>
            `ON key`
          </td>

          <td>
            이는 키 식별자가 두 컨텍스트에서 동일한 경우를 위해 축약된 구문입니다. `ON key = key`와 동일합니다.
          </td>
        </tr>
      </tbody>
    </table>

    고려해야 할 제한 사항:

    * 결합된 하위 쿼리는 계속해서 기본 [`LIMIT`](#sel-limit)은 10개이고 최대 `LIMIT`은 5,000개입니다. 외부 쿼리의 `LIMIT`은 내부 쿼리에 영향을 주지 않습니다.
    * 결합된 하위 쿼리에서 `TIMESERIES` 사용은 지원되지 않습니다. 외부 쿼리가 `TIMESERIES`를 사용하는 경우 결합된 하위 쿼리는 전체 쿼리 시간 범위에 대해 단일 결과를 제공한다는 점에 유의하십시오.
    * 모든 하위 쿼리와 마찬가지로 결합된 하위 쿼리는 알림 조건에서 사용할 수 없습니다.
    * `SELECT *`는 상위 쿼리에서 지원되지만 조인된 하위 쿼리에서는 지원되지 않습니다.
    * 결합의 카디널리티는 1:100으로 제한됩니다. 이는 단일 결합 키가 하위 쿼리 결과에서 100개 이상의 행에 매핑될 수 없음을 의미합니다.

    `JOIN` 절에 대한 자세한 내용은 [NRQL 하위 쿼리 조인](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/subquery-joins) 튜토리얼을 참조하십시오.

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          INNER JOIN
        </InlineCode> 패싯 하위 쿼리 포함</>}
        id="example-faceted-inner-join"
      >
        이 쿼리는 `PageView` 이벤트 유형에서 `browserTransactionName` 으로 패싯 처리된 이벤트 수를 찾은 다음 `PageAction` 이벤트 유형에서 `currentUrl` 로 패싯 처리된 이벤트 수를 찾습니다. 이는 공통 `session` 속성 값을 기반으로 두 이벤트 유형을 결합합니다.

        ```sql
        FROM PageView
        JOIN (FROM PageAction SELECT count(*) FACET session, currentUrl) ON session
        SELECT count(*) FACET browserTransactionName, currentUrl
        ```

        <img
          title="screenshot faceted inner join"
          alt="screenshot faceted inner join"
          src="/images/nrql_screenshot-crop_example-faceted-inner-join.webp"
        />

        <figcaption>
          패싯 <InlineCode>
          INNER JOIN
          </InlineCode> 예
        </figcaption>
      </Collapser>

      <Collapser title={<><InlineCode>
          LEFT JOIN
        </InlineCode> 패싯 하위 쿼리 포함</>}>
        이 예시는 [패싯 `INNER JOIN` 예시](#example-faceted-inner-join)와 동일한 데이터를 쿼리하지만, `LEFT JOIN` 쿼리이기 때문에 결과에는 `PageAction` 하위 쿼리의 결과에 일치하는 `session` 값이 없는 `PageView` 테이블의 항목이 포함됩니다.

        ```sql
        FROM PageView
        LEFT JOIN (FROM PageAction SELECT count(*) FACET session, currentUrl) ON session
        SELECT count(*) FACET browserTransactionName, currentUrl
        ```

        <img
          title="screenshot faceted left join"
          alt="screenshot faceted left join"
          src="/images/nrql_screenshot-crop_example-faceted-left-join.webp"
        />

        <figcaption>
          패싯 <InlineCode>
          LEFT JOIN
          </InlineCode> 예
        </figcaption>
      </Collapser>

      <Collapser title={<><InlineCode>
          INNER JOIN
        </InlineCode> 집계되지 않은 하위 쿼리 포함</>}>
        이 부분에서는 `PageAction` 이벤트 유형에서 `currentUrl`로 분류된 다음 `PageView` 이벤트 유형에서 `browserTransactionNamed` 로 분류된 이벤트 수를 찾는 외부 쿼리를 사용하여 집계되지 않은 행 방식 하위 쿼리를 수행합니다. 이는 공통 `session` 속성 값을 기반으로 두 이벤트 유형을 결합합니다.

        `session` 값 `34d5ce6acf4c60be`는 하위 쿼리의 `PageView` 이벤트 유형에서 두 개의 `browserTransactionName` 값을 가지며, 결과에 추가 행을 추가한다는 점에 주목하십시오.

        ```sql
        FROM PageAction
        left JOIN (FROM PageView SELECT session, browserTransactionName LIMIT MAX) ON session
        SELECT count(*) FACET session, currentUrl, browserTransactionName LIMIT MAX
        ```

        <img
          title="screenshot columnar inner join"
          alt="screenshot columnar inner join"
          src="/images/nrql_screenshot-crop_example-columnar-inner-join.webp"
        />

        <figcaption>
          집계되지 않은 <InlineCode>
          INNER JOIN
          </InlineCode> 예
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-limit"
    title={<><InlineCode>
      LIMIT
    </InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      LIMIT count
      ...
    ```

    `LIMIT` 조항을 사용하여 `FACET` 쿼리에서 반환된 패싯 값의 최대 수 또는 `SELECT *` 쿼리에서 반환된 최대 항목 수를 제어합니다. 이 조항은 단일 정수 값을 인수로 사용합니다. `LIMIT` 조항이 지정되지 않았거나 값이 제공되지 않은 경우 제한은 기본적으로 `FACET` 쿼리의 경우 10, `SELECT *` 쿼리의 경우 100으로 설정됩니다.

    `LIMIT` 절에 허용되는 최대 값은 5,000입니다. 쿼리는 특정 값 대신 `LIMIT MAX` 절을 사용해 자동으로 현재 최대값을 기본값으로 설정할 수 있습니다. 나중에 변경되더라도 항상 최대 개수의 결과를 표시하려는 경우 이 기능을 사용할 수 있습니다. 쿼리 동작을 변경하지 않고 유지하려면 `LIMIT MAX`를 사용하지 않고 원하는 값을 지정합니다.

    <CollapserGroup>
      <Collapser title={<>다음을 사용하여 쿼리 <InlineCode>
          LIMIT
        </InlineCode></>}>
        이 쿼리는 세션 수별로 상위 20개 국가를 표시하고 Windows 사용자에게만 각 국가에 대한 응답 시간의 95번째 백분위수를 제공합니다.

        ```sql
        SELECT uniqueCount(session), percentile(duration, 95)
          FROM PageView WHERE userAgentOS = 'Windows'
          FACET countryCode LIMIT 20 SINCE YESTERDAY
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-offset"
    title={<><InlineCode>
      OFFSET
    </InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      LIMIT count OFFSET count
      ...
    ```

    `LIMIT` 과 함께 `OFFSET` 조항을 사용하여 `SELECT *` 또는 `SELECT column` 쿼리에서 반환된 행 부분을 제어합니다. `LIMIT` 조항과 마찬가지로 `OFFSET` 는 단일 정수 값을 인수로 사용합니다. `OFFSET`은 쿼리에서 선택한 행이 반환되기 전에 건너뛸 행 수를 설정합니다. 이것은 `LIMIT`에 의해 제한됩니다.

    `OFFSET` 행은 가장 최근부터 건너뜁니다.

    예를 들어, `SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1` 쿼리는 가장 최근 값을 제외하고 `Minute_Report`에서 마지막 5개 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-order-by"
    title={<><InlineCode>
      ORDER BY
    </InlineCode> 절</>}
  >
    `ORDER BY` 조항을 사용하면 행별로 이벤트 속성을 선택하는 쿼리에서 쿼리 결과를 정렬하는 방법을 지정할 수 있습니다.

    이 쿼리는 두 개의 트랜잭션 속성을 기간별로 정렬합니다.

    ```sql
    FROM Transaction SELECT appName, duration ORDER BY duration
    ```

    기본 정렬 순서는 오름차순이지만 `ASC` 또는 `DESC` 수정자를 추가하여 변경할 수 있습니다.

    이 쿼리는 모든 트랜잭션 속성을 기간별로 내림차순으로 정렬합니다.

    ```sql
    FROM Transaction SELECT * ORDER BY duration DESC
    ```

    <Callout variant="important">
      `ORDER BY` 절은 `FACET` 쿼리에 적용되지 않습니다. 패싯 선택을 안내하는 `FACET ... ORDER BY` 절과 혼동해서는 안 됩니다. 자세한 내용은 [`FACET ... ORDER BY`](#sel-facet-order)를 참조하십시오.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="show-event-types"
    title={<><InlineCode>
      SHOW EVENT TYPES
    </InlineCode> 절</>}
  >
    ```sql
    SHOW EVENT TYPES...
    ```

    `SHOW EVENT TYPES` 특정 시간 범위 동안 계정에 있는 모든 데이터 유형의 목록을 반환합니다. `SELECT` 대신 쿼리의 첫 번째 조항로 사용됩니다.

    <Callout variant="important">
      이 컨텍스트에서 "이벤트 유형"은 NRQL 쿼리로 액세스할 수 있는 데이터 유형을 나타냅니다.
    </Callout>

    <CollapserGroup>
      <Collapser
        id="avg-resp-time-query"
        title="마지막 날의 데이터 유형"
      >
        이 쿼리는 지난 날의 모든 데이터 유형을 반환합니다.

        ```sql
        SHOW EVENT TYPES SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-since"
    title={<><InlineCode>
      SINCE
    </InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      SINCE [numerical units AGO | phrase]
      ...
    ```

    <DNT>**default**</DNT> 값은 <DNT>**1 hour ago**</DNT>입니다.

    `SINCE` 절을 사용해 반환된 데이터에 대한 시간 범위의 포괄적(inclusive) 시작을 정의합니다. 쿼리에 시간대를 지정할 수 있지만 결과는 지정할 수 없습니다. NRQL 결과는 시스템 시간을 기반으로 합니다.

    NRQL을 사용할 때 UTC 타임스탬프, 상대 시간 또는 `DateTime` 문자열을 설정할 수 있습니다. [시간 지정](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/#spec-time)을 참조하십시오.

    기타 참조:

    * [쿼리 시간 범위 설정](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/)
    * [UNTIL](#sel-until)
  </Collapser>

  <Collapser
    className="freq-link"
    id="slide-by"
    title={<><InlineCode>
      SLIDE BY
    </InlineCode> 절</>}
  >
    `SLIDE BY` 조항은 슬라이딩 창이라는 기능을 지원합니다. 슬라이딩 창을 사용하면 `SLIDE BY` 데이터가 서로 겹치는 시간의 &amp;quot;창&amp;quot;으로 수집됩니다. 이러한 기간은 롤링 집계(예: 롤링 평균)가 좁은 시간 창의 집계보다 더 중요한 경우에 다양한 변형이 있는 라인 그래프를 매끄럽게 만드는 데 도움이 될 수 있습니다.

    `SLIDE BY`를 사용하려면 쿼리에서 `TIMESERIES` 조항 뒤에 배치합니다. 예를 들어, 이 쿼리는 1분 `SLIDE BY` 간격으로 5분 창의 데이터를 가져옵니다. 즉, 각 창은 5분 동안 지속되지만, 창 1은 0분에 시작하고, 창 2는 1분에 시작하고, 창 3은 2분에서 시작하는 것입니다.

    ```sql
    SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute
    ```

    `SLIDE BY`를 사용하는 방법과 시기에 대한 자세한 내용은 [슬라이딩 창으로 더 보기 쉬운 차트 만들기](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows)를 참조하십시오. 또는 이 짧은 비디오(약 3분 20초)를 시청하십시오.

    <Video
      id="b9WVyb1wU6w"
      type="youtube"
    />

    <CollapserGroup>
      <Collapser
        id="sliding-window-max-auto"
        title={<><InlineCode>
          SLIDE BY
        </InlineCode> with <InlineCode>
          MAX
        </InlineCode> or <InlineCode>
          AUTO
        </InlineCode> interval 사용</>}
      >
        `MAX` 또는 `AUTO`와 함께 슬라이딩 창을 사용할 수 있습니다. 그러나 `MAX` 또는 `AUTO`는 `TIMESERIES`와 `SLIDE BY` 사이에 둘 수 없습니다.

        이 쿼리는 자동으로 `SLIDE BY` 창 간격을 결정합니다.

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO
        ```

        이 쿼리는 `SLIDE BY` 창을 최대 간격 단위로 설정합니다.

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX
        ```

        <Callout variant="important">
          `AUTO` 또는 `MAX`에 의해 결정된 `SLIDE BY` 값은 창 크기보다 큰 단계 간격을 생성할 수 있으며, 이로 인해 간격과 예기치 않은 결과가 발생할 수 있습니다.
        </Callout>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timeseries"
    title={<><InlineCode>
      TIMESERIES
    </InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      TIMESERIES integer units
      ...
    ```

    `TIMESERIES` 조항을 사용하여 데이터를 지정된 기간으로 분류된 시계열로 반환합니다. `TIMESERIES`는 특정 차트를 트리거하는 데 사용되므로 기본값이 없습니다.

    시간 범위를 나타내려면 `integer units`를 사용합니다. 예:

    * `TIMESERIES 1 minute`
    * `TIMESERIES 30 minutes`
    * `TIMESERIES 1 hour`
    * `TIMESERIES 30 seconds`

    `TIMESERIES` 아래 예와 같이 쿼리 결과를 추가로 맞춤화하기 위해 `MAX`, `AUTO` 및 `SLIDE BY` 같은 인수와 결합할 수 있습니다.

    <Callout variant="important">
      `average()` 또는 `percentile()` 같은 함수의 경우 집계 기간이 크면 이상값에 상당한 평활화 효과가 있을 수 있습니다. 이것은 쿼리가 슬라이딩 윈도우를 사용하는지 여부에 관계없이 해당됩니다.
    </Callout>

    <CollapserGroup>
      <Collapser
        id="set-interval"
        title="설정된 간격 사용"
      >
        제공된 값은 그래프를 구분하는 데 사용되는 단위를 나타냅니다. 예를 들어, 30분 증분을 보여주는 1일 그래프를 표시하려면:

        ```sql
        SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes
        ```
      </Collapser>

      <Collapser
        id="timeseries-auto"
        title="자동으로 설정된 간격 사용"
      >
        `TIMESERIES` 그래프를 합리적인 수의 분할로 나누는 `AUTO`로 설정할 수도 있습니다. 예를 들어 일일 차트는 30분 간격으로 분할되고 주간 차트는 6시간 간격으로 분할됩니다.

        이 쿼리는 6시간마다 데이터 포인트를 사용하여 1주일 동안 클라이언트 측 트랜잭션 시간의 50번째 및 90번째 백분위수를 보여주는 선 차트로 데이터를 반환합니다.

        ```sql
        SELECT average(duration), percentile(duration, 50, 90)
          FROM PageView SINCE 1 week AGO TIMESERIES AUTO
        ```
      </Collapser>

      <Collapser
        id="timeseries-max"
        title={<><InlineCode>
          MAX
        </InlineCode> interval 사용</>}
      >
        `TIMESERIES` 을 `MAX`로 설정할 수 있습니다. 그러면 지정된 기간에 허용되는 최대 간격 수로 기간이 자동으로 조정됩니다. 이렇게 하면 `TIMESERIES` 버킷을 수동으로 업데이트하지 않고도 기간을 업데이트할 수 있으며 기간이 허용되는 최대 간격 수로 분할되도록 할 수 있습니다. 반환될 최대 `TIMESERIES` 버킷 수는 366입니다.

        예를 들어 다음 쿼리는 일별 차트의 상한선인 4분 간격을 생성합니다.

        ```sql
        SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-until"
    title={<><InlineCode>
      UNTIL
    </InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      UNTIL integer units AGO
      ...
    ```

    `UNTIL` 절을 사용하여 쿼리할 시간 범위의 끝을 정의합니다. 값은 배타적입니다. 시간 범위가 지정된 순간으로 이동하지만 포함을 하지는 않는 다는 의미입니다.

    <DNT>**default**</DNT> 값은 <DNT>**NOW**</DNT>입니다. 기본값 이외의 엔드포인트를 지정하려면 `UNTIL`만 사용합니다.

    기타 참조:

    * [쿼리 시간 범위 설정](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/)
    * [SINCE](#sel-since)
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-where"
    title={<><InlineCode>
      WHERE
    </InlineCode> 절</>}
  >
    `WHERE` 조항을 사용하여 결과를 필터링합니다. NRQL은 조항에서 지정한 조건을 충족하는 결과를 반환합니다.

    ```sql
    SELECT function(attribute) ...
      WHERE attribute [operator 'value' | IN ('value' [, 'value']) | IS [NOT] NULL ]
      [AND|OR ...]
      ...
    ```

    * 둘 이상의 조건을 지정하는 경우 `AND` 또는 `OR` 연산자로 조건을 구분합니다.

    <table id="where-operators">
      <thead>
        <tr>
          <th width={150}>
            <DNT>
              **Operators that the `WHERE` clause accepts**
            </DNT>
          </th>

          <th>
            <DNT>
              **Description**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `=`, `!=`, `<`, `<=` , `>`, `>=`
          </td>

          <td>
            NRQL은 표준 비교 연산자를 허용합니다. 예시: `state = 'WA'`

            부울 값이 있는 속성의 경우 `=`이 아닌 `IS`를 사용합니다.
          </td>
        </tr>

        <tr>
          <td>
            `AND`
          </td>

          <td>
            두 조건의 교차를 정의하는 데 사용됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `OR`
          </td>

          <td>
            두 조건의 합집합을 정의하는 데 사용됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `IS NULL`
          </td>

          <td>
            속성에 null 값이 있는지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `IS NOT NULL`
          </td>

          <td>
            속성에 null 값이 없는지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `IS TRUE`
          </td>

          <td>
            속성의 부울 값이 `true`인지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `IS FALSE`
          </td>

          <td>
            속성의 부울 값이 `false`인지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `IN`
          </td>

          <td>
            속성의 문자열 값이 지정된 집합에 있는지 확인합니다. 이 방법을 사용하면 여러 `WHERE` 조항을 함께 묶는 것보다 더 나은 성능을 얻을 수 있습니다.

            예:

            ```sql
            animalType IN ('cat', 'dog', 'fish')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `NOT IN`
          </td>

          <td>
            속성의 문자열 값이 지정된 집합에 없는지 확인합니다. 이 방법을 사용하면 여러 `WHERE` 조항을 함께 묶는 것보다 더 나은 성능을 얻을 수 있습니다.

            값은 쉼표로 구분된 괄호 안에 있어야 합니다. 예를 들어:

            ```sql
            SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `LIKE`
          </td>

          <td>
            속성에 지정된 하위 문자열이 포함되어 있는지 확인합니다.

            `LIKE` 연산자의 문자열 인수는 문자열의 어디에서나 와일드카드로 퍼센트 기호(%)를 허용합니다.

            다음 사항에 유의하십시오.

            * `LIKE` 연산자는 대소문자를 구분하지 않습니다.

            * 와일드카드를 포함하지 않으면 문자열에 대소문자가 일치합니다. 예를 들어 와일드카드가 없는 이 쿼리는 `B`와 `b`가 일치합니다.

              ```sql
              FROM foo
              SELECT *
              WHERE bar LIKE 'B'
              ```

              <DNT>
                **Examples:**
              </DNT>

              `userAgentName LIKE 'IE%'`

            * IE

            * IE Mobile

              `userAgentName LIKE 'o%a%'`

            * Opera

            * Opera Mini

              `userAgentName LIKE 'o%a'`

            * Opera

              `userAgentName LIKE '%o%a%'`

            * Opera

            * Opera Mini

            * Mozilla Gecko
          </td>
        </tr>

        <tr>
          <td>
            `NOT LIKE`
          </td>

          <td>
            속성에 지정된 하위 문자열이 포함되어 있지 않은지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `RLIKE`
          </td>

          <td>
            속성에 지정된 Regex 하위 문자열이 포함되어 있는지 확인합니다. [RE2 구문](https://github.com/google/re2/wiki/Syntax)을 사용합니다.

            <DNT>
              **Examples:**
            </DNT>

            `appName RLIKE r'z.*|q.*'`

            * `z-app`

            * `q-app`

              `hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*'`

            * `ip-10-351-19-237`

            * `ip-10-351-2-41`

            * `ip-10-351-24-238`

            * `ip-10-351-14-15`

              <Callout variant="important">
                정규식은 기본적으로 전체 문자열 일치로 설정되므로 `^` 및 `$`는 암시적이며 추가할 필요가 없습니다.
              </Callout>
          </td>
        </tr>

        <tr>
          <td>
            `NOT RLIKE`
          </td>

          <td>
            속성에 지정된 Regex 하위 문자열이 포함되어 있지 않은지 확인합니다. [RE2 구문](https://github.com/google/re2/wiki/Syntax)을 사용합니다.
          </td>
        </tr>
      </tbody>
    </table>

    <CollapserGroup>
      <Collapser
        id="query-3-conditions"
        title="세 가지 조건이 있는 쿼리 예"
      >
        이 쿼리는 지난 24시간 동안 미국과 캐나다의 Safari 사용자에 대한 URL에 `checkout`이 있는 페이지의 브라우저 응답 시간을 반환합니다.

        ```sql
        SELECT histogram(duration, 50, 20) FROM PageView
        WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%'
        SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-metric-format"
    title={<><InlineCode>
      WITH METRIC_FORMAT
    </InlineCode> 절</>}
  >
    메트릭 데이터 쿼리에 대한 자세한 내용은 [쿼리 메트릭](#query-metrics)을 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-as-nrql-var"
    title={<><InlineCode>
      WITH ... AS
    </InlineCode> 절(NRQL 변수)</>}
  >
    ```sql
    FROM ...
      WITH function(attribute) AS var
      SELECT var
      ...
    ```

    쿼리의 어느 곳에서나 참조할 수 있는 변수로 값을 저장하려면 `WITH ... AS` 절을 사용하여 NRQL 변수를 정의합니다. 주요 규칙 및 팁:

    * `WITH ... AS` 절은 `FROM`/`SELECT` 절 앞, 중간 또는 바로 뒤에 올 수 있습니다.
    * 행 단위 함수(예: `capture()`)만 변수로 설정할 수 있습니다. `average()` 같은 집계 함수는 지원되지 않습니다.
    * 하나의 `WITH` 만 사용할 수 있지만, 쉼표로 구분되는 한 여러 NRQL 변수를 사용할 수 있습니다.
    * 정의된 NRQL 변수가 기존 속성과 이름이 동일한 경우, 해당 변수가 우선합니다.
    * 변수 이름에는 `%` 기호가 포함될 수 없습니다.

    <Callout variant="important">
      [메트릭에 대한 이벤트](/docs/data-apis/convert-to-metrics/analyze-monitor-data-trends-metrics/) 규칙은 [NRQL 쿼리](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/)에서 `WITH ... AS` 절을 지원하지 않습니다.
    </Callout>

    다음은 몇 가지 예시 쿼리입니다.

    <CollapserGroup>
      <Collapser
        id="basic-nrql-var"
        title="변수의 기본적인 사용"
      >
        ```sql
        FROM Transaction
          WITH duration*1000 AS millisec
          SELECT millisec
        ```
      </Collapser>

      <Collapser
        id="multiple-nrql-var"
        title="여러 변수 사용"
      >
        ```sql
        FROM Log
          WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice)
          SELECT itemId, unitPrice
        ```

        [앵커 구문 분석](#func-aparse) (`aparse()`)에 대해 보다 자세히 알아보십시오.
      </Collapser>

      <Collapser
        id="nrql-var-other-clauses"
        title="다른 절에서의 변수 사용"
      >
        이 예에서 NRQL 변수 `unitPrice`는 또 다른 변수 `unitPriceNum`을 사용하여 추출된 문자열을 숫자로 변환합니다. 그런 다음 변수는 `SELECT`, `WHERE` 및 `FACET` 절에서 사용됩니다.

        ```sql
        FROM Log
          WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice),
            numeric(unitPrice) AS unitPriceNum
          SELECT sum(unitPriceNum)
          FACET itemId
          WHERE unitPriceNum < 100
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timezone"
    title={<><InlineCode>
      WITH TIMEZONE
    </InlineCode> 절</>}
  >
    ```sql
    SELECT ... WITH TIMEZONE (selected zone)
      ...
    ```

    `WITH TIMEZONE` 조항을 사용하여 아직 지정된 시간대가 없는 쿼리의 날짜 또는 시간에 대한 시간대를 선택합니다.

    날짜 시간에 시간대를 지정하지 않고 `WITH TIMEZONE` 절을 포함하면 `since` 및 `until` 절은 제공된 시간대를 유지합니다.

    `WITH TIMEZONE` 절을 포함하지 않고 날짜 시간 문자열에 시간대를 포함하면 날짜 시간 문자열 시간대가 유지됩니다.

    <Callout variant="important">
      지정되지 않은 경우 기본 시간대는 항상 UTC입니다. 결과의 원시 타임스탬프 값(JSON 뷰에 표시)은 항상 UTC입니다. UI는 계정 설정에서 지정한 시간대로 결과를 표시합니다. 타임스탬프 문자열의 시간대는 항상 작동합니다. 이는 `WITH TIMEZONE` 시간대를 대체합니다.
    </Callout>

    예를 들어 쿼리 절 `SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'`은 미국/뉴욕 시간으로 월요일 자정부터 미국/뉴욕 시간으로 화요일 자정까지 기록된 데이터를 반환합니다.

    다음은 쿼리 타임스팬 절의 몇 가지 예입니다.

    * `WITH TIMEZONE` 절을 사용하는 날짜 시간 문자열에 시간대가 없습니다.

      ```sql
      SINCE today UNTIL '2022-05-19T12:00' WITH TIMEZONE 'America/Los_Angeles'
      ```

      이는 `"beginTime": "2022-05-19T07:00:00Z"` 및 `"endTime": "2022-05-19T19:00:00Z"`로 해결됩니다.

    * `WITH TIMEZONE` 절을 사용하지 않는 날짜 시간 문자열의 시간대:

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500'
      ```

      이는 `"beginTime": "2022-05-19T00:00:00Z"` 및 `"endTime": "2022-05-19T17:00:00Z"`로 해결됩니다.

    * 일광 절약 시간제 동안 -0700인 미국/로스앤젤레스 `WITH TIMEZONE` 절을 사용하는 날짜 시간 문자열의 시간대:

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500' WITH TIMEZONE 'America/Los_Angeles'
      ```

      이는 `"beginTime": "2022-05-19T07:00:00Z"` 및 `"endTime": "2022-05-19T19:00:00Z"`로 해결됩니다.

    사용 가능한 [영역 ID](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/#timezones-ids) 목록을 참조하십시오.

    자세한 정보와 예는 [대시보드 및 차트에서 시간 범위 설정](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets)을 참조하십시오.
  </Collapser>
</CollapserGroup>

## 메트릭 데이터 쿼리 [#query-metrics]

메트릭 데이터는 다른 유형의 데이터보다 복잡합니다. 이를 효과적으로 쿼리하기 위한 몇 가지 팁이 있습니다. 두 가지 유형의 메트릭 데이터가 있으며 각각 고유한 쿼리 지침이 존재합니다.

* Metric API 및 해당 API를 사용하는 일부 솔루션(예:[Dropwizard 통합](/docs/more-integrations/open-source-telemetry-integrations/dropwizard/dropwizard-reporter) 또는 [Micrometer 통합](/docs/more-integrations/open-source-telemetry-integrations/micrometer/micrometer-metrics-registry) )에서 보고하는 [차원 메트릭을 쿼리합니다.](/docs/data-ingest-apis/get-data-new-relic/metric-api/view-query-you-metric-data)
* [쿼리 메트릭 타임슬라이스 데이터](/docs/query-data/nrql-new-relic-query-language/nrql-query-tutorials/query-metric-timeslice-data-nrql)는 뉴렐릭 APM, 모바일 모니터링 및 <InlinePopover type="browser"/>에서 보고되는 기본 메트릭 데이터 유형입니다.

메트릭 데이터를 보고하는 방법에 대한 자세한 내용은 [메트릭 데이터 유형](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics)을 참조하십시오.

## 기능 [#functions]

이 섹션에서는 NRQL 함수, 즉 [집계 기능](#aggregator-functions)과 [비](#non-aggregator-functions) 집계 기능에 대해 설명합니다.

### 집합기 기능 [#aggregator-functions]

집계 함수를 사용하여 데이터를 필터링하고 집계할 수 있습니다. 사용을 위한 몇 가지 팁은 다음과 같습니다.

* [필터 쿼리](http://newrelic.wistia.com/medias/8k4xbxlfwj), [Apdex 쿼리](http://newrelic.wistia.com/medias/46dvx1mkm0) 및 [백분위수 쿼리](http://newrelic.wistia.com/medias/j3htrz66l0)에 대한 New Relic University 자습서를 참조하십시오. 또는 [NRQL 쿼리 작성](https://learn.newrelic.com/writing-nrql-queries)에 대한 전체 온라인 과정을 방문하십시오.
* 동일한 쿼리(예: `SELECT median(one_metric), median(another_metric)` )에서 집계 함수를 여러 번 사용하는 경우 결과 표시에 문제가 발생할 수 있습니다. 이 문제를 해결하려면 [`AS` 함수](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-as)를 사용합니다. 예:
  ```sql
   SELECT median(one_metric) as 'med-a', median(another_metric) as 'med-b'
  ```
* 데이터 유형 "강제"는 지원되지 않습니다. [사용 가능한 유형 변환 함수](#type-conversion)에 대해 알아보십시오.
* 시간 경과에 따른 결과를 표시하는 방법은 시간 경과에 [따른 결과 그룹화](/docs/insights/new-relic-insights/features/cohort-analysis)를 참조하십시오.

예:

```sql
SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
```

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="func-aggregationendtime"
    title={<InlineCode>aggregationendtime()</InlineCode>}
  >
    `aggregationendtime()` 함수를 사용하여 관련 집계 시간을 반환합니다. 더 구체적으로 말하면, 주어진 집계에 대해 `aggregationendtime()` 함수는 해당 집계 기간의 끝 타임스탬프를 제공합니다. 예를 들어, 시계열 쿼리에서 1시간 분량의 데이터를 포함하는 데이터 포인트의 경우 함수는 해당 시간 기간의 끝 타임스탬프를 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-apdex"
    title={<InlineCode>apdex(attribute, t: )</InlineCode>}
  >
    `apdex` 함수를 사용해 단일 트랜잭션 또는 모든 트랜잭션에 대한 [Apdex 점수](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#score)를 반환합니다. 기본 <DNT>Apdex</DNT> 점수는 0.5초입니다. [속성](/docs/insights/new-relic-insights/decorating-events/insights-attributes)은 [`duration`](/docs/insights/insights-data-sources/default-events-attributes/apm-default-event-attributes#txn-duration) 또는 [`backendDuration`](/docs/insights/insights-data-sources/default-events-attributes/browser-default-events-attributes-insights#backend-duration) 같이 응답 시간을 기반으로 하는 모든 속성이 될 수 있습니다. `t:` 인수는 선택한 속성과 동일한 시간 단위로 [`Apdex T`](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) 임계값을 정의합니다. 예를 들어, 속성이 초 단위로 측정되는 경우 `t:`는 초 단위 임계값이 됩니다.

    `apdex()` 함수에서 반환된 <DNT>Apdex</DNT> 점수는 실행 시간에만 기반하며, APM 오류는 고려하지 않습니다. 트랜잭션에 오류가 포함되어 있지만 [Apdex T](/docs/apm/new-relic-apm/getting-started/glossary#apdex_t) 이하에서 완료되는 경우 해당 트랜잭션은 `apdex ()` 함수에 의해 [충족](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#bullet-satisfied)된 것으로 평가됩니다.

    <CollapserGroup>
      <Collapser
        id="apdex-cust-attributes"
        title="특정 고객을 위한 Apdex 받기"
      >
        [사용자 정의 속성을 정의한](/docs/insights/new-relic-insights/decorating-events/insights-custom-attributes) 경우 해당 속성을 기반으로 필터링할 수 있습니다. 예를 들어, 특히 중요한 고객의 Apdex를 모니터링할 수 있습니다.

        ```sql
        SELECT apdex(duration, t: 0.4) FROM Transaction
          WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago
        ```
      </Collapser>

      <Collapser
        id="apdex-transaction"
        title="특정 트랜잭션에 대한 Apdex 가져오기"
      >
        특정 트랜잭션에 대한 점수를 반환하려면 `name` 속성을 사용하거나, `name`을 생략하여 전체 Apdex를 반환합니다. 이 쿼리는 지난 한 시간 동안의 <DNT>**Controller/notes/index**</DNT> 트랜잭션에 대한 Apdex 점수를 반환합니다.

        <img
          title="crop-apdex-function"
          alt="crop-apdex-function"
          src="/images/queries-nrql_screenshot-full_apdex-NRQL-query-builder.webp"
        />

        <figcaption>
          `apdex` 함수는 사이트에 대한 사용자 만족도를 측정하는 [Apdex 점수](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction)를 반환합니다. 인수는 응답 시간 속성 및 Apdex T 임계값(초)입니다.
        </figcaption>

        ```sql
        SELECT apdex(duration, t: 0.5) from Transaction
        WHERE name='Controller/notes/index' SINCE 1 hour ago
        ```
      </Collapser>

      <Collapser title="앱에 대한 전체 Apdex 가져오기">
        이 예제 쿼리는 지난 3주 동안 애플리케이션에 대한 전체 Apdex를 반환합니다.

        ```sql
        SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-average"
    title={<InlineCode>average(attribute)</InlineCode>}
  >
    `average()` 함수를 사용하여 속성의 평균 값을 반환합니다. 단일 속성 이름을 인수로 사용합니다. 속성 값이 숫자가 아니면 집계할 때 무시됩니다. 쿼리 조건과 일치하는 데이터를 찾을 수 없거나 쿼리에서 반환된 숫자 값이 없으면 null 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-bucket-percentile"
    title={<InlineCode>bucketPercentile(attribute)</InlineCode>}
  >
    `bucketPercentile()` 함수는 Prometheus의 [`histogram_quantile`](https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile) 함수에 해당하는 NRQL입니다. 차원 메트릭 데이터와 함께 사용하기 위한 것입니다. quantile 대신 뉴렐릭은 quantile \* 100인 백분위수를 반환합니다.

    `bucketPercentile()` 함수를 사용하여 Prometheus 형식의 히스토그램 데이터에서 분위수를 계산합니다.

    버킷 이름을 인수로 사용하고 버킷 경계를 따라 백분위수를 보고합니다.

    ```sql
    SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago
    ```

    선택적으로 백분위수 사양을 인수로 추가할 수 있습니다.

    ```sql
    SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago
    ```

    Prometheus 히스토그램 데이터를 구성하는 데 여러 측정항목이 사용되기 때문에 연결된 `<basename>` 측면에서 특정 Prometheus 메트릭을 쿼리해야 합니다.

    예를 들어, NRQL을 사용하는 `<basename>` `prometheus_http_request_duration_seconds`를 사용하여 Prometheus Histogram에서 컴퓨트 백분위수를 사용하려면 `bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)`을 사용합니다. `_bucket`이 `<basename>` 끝에 접미사로 추가되는 방식에 유의하십시오.

    자세한 내용은 [Prometheus.io 문서](https://prometheus.io/docs/concepts/metric_types/#histogram)를 참조하세요.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cardinality"
    title={<InlineCode>cardinality([metric_name, include:{`{attribute_list}`}, exclude:{`{attribute_list}`}])</InlineCode>}
  >
    `cardinality()` 함수를 사용하여 메트릭의 모든 [측정기준](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics)(속성) 조합 수를 가져옵니다.

    세 개의 인수가 필요하며 모두 선택 사항입니다.

    * 측정항목 이름: 있는 경우 `cardinality()`은 지정된 메트릭만 계산합니다.
    * Include(포함): 존재하는 경우, 포함 목록은 카디널리티 계산을 해당 속성으로 제한합니다.
    * Exclude(제외): 존재하는 경우 제외 목록으로 인해 카디널리티 계산에서 해당 속성이 무시됩니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cdfPercentage"
    title={<InlineCode>cdfPercentage(attribute, threshold [, threshold [, ...]])</InlineCode>}
  >
    `cdfPercentage()` 는 [누적 분포 함수](https://en.wikipedia.org/wiki/Cumulative_distribution_function)의 구현으로, `thresholds` 이하인 `attribute` 값의 백분율을 반환합니다.

    `cdfPercentage()` 는 `attribute` 인수를 집계하며, 숫자 속성 또는 분포 메트릭 속성이 될 수 있습니다. 하나의 쿼리에 혼합 유형이 허용됩니다. 다른 유형(예: 문자열)은 무시됩니다. 최대 10개의 임계값을 지정할 수 있습니다.

    <CollapserGroup>
      <Collapser title="특정 임계값보다 빠르게 첫 번째 페인트의 백분율을 얻습니다.">
        이 쿼리는 `firstPaint`가 0.5초 이하인 이벤트의 비율과 `firstPaint`가 1초 이하인 이벤트의 비율을 반환합니다.

        ```sql
        FROM PageView SELECT cdfPercentage(firstPaint, 0.5, 1.0)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-count"
    title={<InlineCode>count(*)</InlineCode>}
  >
    `count()` 함수를 사용하여 사용 가능한 레코드 수를 반환합니다. 단일 인수가 필요합니다. `*` , 속성 또는 상수 값입니다. 현재는 일반적인 SQL 동작을 따르고 해당 인수에 대한 값이 있는 모든 레코드를 계산합니다.

    `count(*)`는 특정 속성의 이름을 지정하지 않으므로 결과는 기본 ["humanize"](/docs/insights/new-relic-insights/managing-dashboards-data/data-formatter-setting-default-formats-numeric-values#format) 형식으로 지정됩니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="derivative"
    title={<InlineCode>derivative(attribute [,time interval])</InlineCode>}
  >
    `derivative()` 주어진 데이터 세트의 변화율을 찾습니다. 변화율은 도함수를 근사화하기 위해 선형 최소제곱 회귀를 사용하여 계산됩니다. 이 계산에는 둘 이상의 데이터 포인트를 비교해야 하므로 평가 범위에 하나의 데이터 포인트만 포함되는 경우 계산이 불확실하고 작동하지 않아 `null` 값이 생성됩니다.

    `time interval`은 변화율이 계산되는 기간입니다. 예를 들어, `derivative(attributeName, 1 minute)`는 분당 변경 비율을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="earliest-func"
    title={<InlineCode>earliest(attribute)</InlineCode>}
  >
    `earliest()` 함수를 사용하여 지정된 시간 범위 동안 속성에 대한 가장 이른 값을 반환합니다.

    단일 인수가 필요합니다.

    `FACET`과 함께 사용하는 경우 각 결과 패싯에 대한 속성의 가장 최근 값을 반환합니다.

    <CollapserGroup>
      <Collapser title="PageView에서 사용자 에이전트당 가장 빠른 국가 가져오기">
        이 쿼리는 `PageView` 이벤트에서 각 사용자 에이전트당 가장 빠른 국가 코드를 반환합니다.

        ```sql
        SELECT earliest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-filter"
    title={<InlineCode>filter(function(attribute), WHERE condition)</InlineCode>}
  >
    `filter()` 함수를 사용하여 `SELECT` 문의 집계 함수 중 하나에 대한 결과를 제한합니다. `FACET` 또는 `TIMESERIES`와 함께 `filter()`를 사용할 수 있습니다. 필터는 다음과 같은 여러 집계를 선택할 때만 유용합니다.

    ```sql
    SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' ...
    ```

    그렇지 않으면, 표준 `WHERE` 절을 사용하는 것이 좋습니다.

    <CollapserGroup>
      <Collapser title="오퍼 코드를 사용한 구매 분석">
        `filter()`를 사용하여 제안 코드를 사용하는 사람과 사용하지 않는 사람에 대해 일련의 트랜잭션에서 구입한 항목을 비교할 수 있습니다.

        <img
          title="screenshot insights filter"
          alt="screenshot insights filter"
          src="/images/queries-nrql_screenshot-full_filter-NRQL-query-builder.webp"
        />

        <figcaption>
          `filter()` 함수를 사용하여 `SELECT` 문의 집계 함수 중 하나에 대한 결과를 제한합니다.
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-funnel"
    title={<InlineCode>funnel(attribute, steps)</InlineCode>}
  >
    `funnel()` 함수를 사용하여 퍼널 차트를 생성합니다. 속성을 첫 번째 인수로 사용합니다. 그런 다음 단계를 쉼표로 구분된 [`WHERE`](#sel-where) 조항(레이블에 대한 선택적 [`AS`](#sel-as) 조항 포함)로 지정합니다.

    자세한 내용과 예는 [퍼널 문서](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/funnels-evaluate-data-series-events)를 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-histogram"
    title={<InlineCode>histogram(attribute[, width: n][, buckets: n][, start: n])</InlineCode>}
  >
    `histogram()` 함수를 사용하여 데이터 세트의 분포를 시각화하는 데 유용한 히스토그램을 생성합니다. 데이터 세트를 정해진 버킷 수로 나누고 각 버킷에 속하는 데이터 포인트의 수를 계산합니다.

    인수:

    * `attribute` 첫 번째 인수는 필수이며 각 히스토그램 버킷 범위에 속하는 값을 계산할 속성을 지정합니다.

    * `width:` 샘플 범위의 너비를 나타냅니다. 범위의 최대값은 `start` 인수 값에 이 `width` 값을 더한 값입니다.

      * 위치(라벨이 지정되지 않은) 인수를 사용하는 경우 `width`는 두 번째 인수입니다.
      * _기본값:_ 10

    * `buckets:` 총 버킷 수(1에서 500 사이, 포함)

      * 위치(라벨이 지정되지 않은) 인수를 사용하는 경우 `buckets`는 세 번째 인수입니다.
      * _기본값:_ 40

    * `start:` 히스토그램 범위의 시작을 의미합니다.

      * 위치(라벨이 지정되지 않은) 인수를 사용하는 경우 `start`는 네 번째 인수입니다.
      * _기본값:_ 0

      <Callout
        variant="tip"
        title="참고"
      >
        정의된 히스토그램 범위를 벗어나는 값은 첫 번째 또는 마지막 버킷에 포함됩니다. 첫 번째 버킷 수에는 히스토그램 범위보다 작은 항목이 포함되고, 마지막 버킷 수에는 히스토그램 범위보다 큰 항목이 포함됩니다. 히스토그램 결과에서 이러한 값을 제외하려면 쿼리의 where 절에 필터를 포함시킵니다. (예: `WHERE attribute >= [start] AND attribute <= [start + width]`)
      </Callout>

      <CollapserGroup>
        <Collapser
          id="histogram-response-times-defaults"
          title="PageView 이벤트의 응답 시간 히스토그램"
        >
          이 쿼리는 40개 버킷에 대해 최대 10초 범위의 응답 시간 히스토그램을 생성합니다. 이는 각 버킷이 0.25초의 값 범위를 포함한다는 것을 의미합니다. (10 / 40 = 0.25). 10초보다 큰 기간 값은 마지막 버킷에 포함됩니다. 기간이 0보다 작을 수 있는 경우 해당 값은 첫 번째 버킷에 포함됩니다.

          ```sql
          SELECT histogram(duration) FROM PageView SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="histogram-response-times"
          title="width: 5, buckets: 10인 히스토그램"
        >
          이와 동등한 쿼리는 10개 버킷에 대해 최대 5초 범위의 응답 시간 히스토그램을 생성합니다.

          ```sql
          SELECT histogram(duration, 5, 10) FROM PageView SINCE 1 week ago
          ```

          ```sql
          SELECT histogram(duration, width: 5, buckets: 10) FROM PageView SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="histogram-response-times-1to4"
          title="width: 3, buckets: 3, start: 1인 히스토그램"
        >
          이와 동등한 쿼리는 3개 버킷에 대해 1-4초 범위의 응답 시간 히스토그램을 생성합니다.

          세부 버킷 정보

          <table>
            <thead>
              <tr>
                <th/>

                <th>
                  버킷 1
                </th>

                <th>
                  버킷 2
                </th>

                <th>
                  버킷 3
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  버킷 범위
                </td>

                <td>
                  1- 2
                </td>

                <td>
                  2-3
                </td>

                <td>
                  3-4
                </td>
              </tr>

              <tr>
                <td>
                  계산된 값
                </td>

                <td>
                  &lt; 2
                </td>

                <td>
                  ≥ 2 및 &lt; 3
                </td>

                <td>
                  ≥ 3
                </td>
              </tr>
            </tbody>
          </table>

          ```sql
          SELECT histogram(duration, 3, 3, 1) FROM PageView SINCE 1 week ago
          ```

          ```sql
          SELECT histogram(duration, width: 3, buckets: 3, start: 1) FROM PageView SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="histogram-prometheus"
          title="Prometheus 히스토그램 버킷"
        >
          `histogram()` Prometheus 히스토그램 버킷 허용:

          ```sql
          SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="distribution-metric"
          title="뉴렐릭 분포 메트릭"
        >
          `histogram()` [분포 측정항목](/docs/data-ingest-apis/get-data-new-relic/metric-api/events-metrics-service-create-metrics#limits-rules)을 입력으로 수락합니다.

          ```sql
          SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="histogram-facet-heatmap"
          title="FACET 조항이 있는 히스토그램"
        >
          `FACET` 절과 함께 `histogram()`를 사용하여 히트맵 차트를 생성합니다.

          ```sql
          SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="keyset"
    title={<InlineCode>keyset()</InlineCode>}
  >
    `keyset()`를 사용하면 주어진 시간 범위 동안 주어진 데이터 유형에 대한 모든 속성을 볼 수 있습니다. 인수가 필요하지 않습니다. 문자열 유형 키, 숫자 유형 키, Boolean 유형 키 및 모든 키의 그룹을 포함하는 JSON 구조를 반환합니다.

    <CollapserGroup>
      <Collapser title="데이터 유형에 대한 모든 속성 보기">
        이 쿼리는 마지막 날의 `PageView` 이벤트에 대해 찾은 속성을 반환합니다.

        ```sql
        SELECT keyset() FROM PageView SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latest"
    title={<InlineCode>latest(attribute)</InlineCode>}
  >
    `latest()` 함수를 사용하여 지정된 시간 범위 동안 속성의 가장 최근 값을 반환합니다.

    단일 인수가 필요합니다.

    `FACET`과 함께 사용하는 경우 각 결과 패싯에 대한 속성의 가장 최근 값을 반환합니다.

    <CollapserGroup>
      <Collapser title="PageView에서 사용자 에이전트당 가장 최근 국가 가져오기">
        이 쿼리는 `PageView` 이벤트에서 각 사용자 에이전트당 가장 최근의 국가 코드를 반환합니다.

        ```sql
        SELECT latest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latestrate"
    title={<InlineCode>latestrate(attribute, time interval)</InlineCode>}
  >
    `latestrate()` 함수를 사용하여 마지막 2개의 데이터 포인트를 기반으로 한 값의 변화율을 반환합니다. 문제의 속성을 첫 번째 인수로 사용하고 결과 비율에 대한 시간 단위를 두 번째 인수로 사용합니다. 이 함수는 `change in attribute/time interval` 단위로 결과를 반환합니다.

    이 기능은 최첨단 추세를 보기 위해 속성에 대한 가장 최근의 변경 비율을 제공하는 데 유용할 수 있습니다.

    <CollapserGroup>
      <Collapser title="PageView Duration의 가장 최근 변화율을 가져오기">
        이 쿼리는 마지막 2개의 데이터 포인트를 기반으로 하는 기간의 변화율을 반환합니다. `1 SECOND` 인수때문에 `duration/second` 단위로 반환됩니다.

        ```sql
        SELECT latestrate(duration, 1 SECOND) FROM PageView
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-max"
    title={<InlineCode>max(attribute)</InlineCode>}
  >
    `max()` 함수를 사용하여 지정된 시간 범위 동안 숫자 속성의 최대 기록 값을 반환합니다. 단일 속성 이름을 인수로 사용합니다. 속성 값이 숫자가 아니면 집계할 때 무시됩니다. 쿼리 조건과 일치하는 데이터를 찾을 수 없거나 쿼리에서 반환된 숫자 값이 없으면 null 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-median"
    title={<InlineCode>median(attribute)</InlineCode>}
  >
    속성의 중앙값 또는 50번째 백분위수를 반환하려면 `median()` 함수를 사용합니다. 백분위수 쿼리에 대한 자세한 내용은 [`percentile()`](#func-percentile)을 참조하십시오.

    <Callout variant="tip">
      `median()` 쿼리는 [쿼리 빌더](/docs/chart-builder/use-chart-builder/get-started/introduction-chart-builder)를 사용할 때만 사용할 수 있습니다.
    </Callout>

    <CollapserGroup>
      <Collapser title="중앙값 쿼리">
        이 쿼리는 중앙값에 대한 라인 차트를 생성합니다.

        ```sql
        SELECT median(duration) FROM PageView TIMESERIES AUTO
        ```
      </Collapser>
    </CollapserGroup>

    [`JOIN`](#sel-join) 절의 중앙값:

    * 중앙값은 `percentile(attribute, 50)`의 지름길일 뿐이므로, 결합된 하위 쿼리의 `median()` 결과는 50번째 백분위수를 계산된 값에 매핑하는 복합 데이터 유형입니다.

      외부 쿼리에서 실제 중앙값을 참조하려면 [`getField()`](#func-getfield) 함수를 사용할 수 있습니다. 매핑된 키는 이중 값의 문자열 표현이므로 `median()`의 경우 `'50.0'`입니다.

      <CollapserGroup>
        <Collapser title="결합된 중간 쿼리">
          ```sql
          FROM PageView
          JOIN (FROM PageAction SELECT median(timeSinceLoad) FACET session, currentUrl) ON session
          SELECT latest(getField(median, '50.0')) as median
          FACET browserTransactionName, currentUrl
          ```

          <img
            title="screenshot joined median"
            alt="screenshot joined median"
            src="/images/nrql_screenshot-crop_example-joined-median.webp"
          />
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-min"
    title={<InlineCode>min(attribute)</InlineCode>}
  >
    `min()` 함수를 사용하여 지정된 시간 범위 동안 숫자 속성의 최소 기록 값을 반환합니다. 단일 속성 이름을 인수로 사용합니다. 속성 값이 숫자가 아니면 집계할 때 무시됩니다. 쿼리 조건과 일치하는 데이터를 찾을 수 없거나 쿼리에서 반환된 숫자 값이 없으면 null 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentage"
    title={<InlineCode>percentage(function(attribute), WHERE condition)</InlineCode>}
  >
    `percentage()` 함수를 사용하여 일부 조건과 일치하는 대상 데이터 세트의 백분율을 반환합니다.

    첫 번째 인수에는 원하는 속성에 대한 [집계 함수](#functions)가 필요합니다. 정확히 두 개의 인수를 사용하십시오. (처음 두 개 이후의 인수는 무시됨) 속성이 숫자가 아니면 이 함수는 100% 값을 반환합니다.

    ```sql
    FROM Transaction SELECT percentage(count(*), WHERE error is true ) AS 'Error Percent' Where host LIKE '%west%' EXTRAPOLATE
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentile"
    title={<InlineCode>percentile(attribute [, percentile [, ...]])</InlineCode>}
  >
    `percentile()` 함수를 사용하여 지정된 백분위수에서 속성의 대략적인 값을 반환합니다. 속성이 필요하며 백분위수를 나타내는 인수를 원하는 만큼 사용할 수 있습니다. `percentile()` 함수를 사용하면 백분위수를 소수점 이하 3자리까지 표시할 수 있어 정밀도가 향상됩니다. 백분위수 임계값은 십진수 값으로 지정할 수 있지만 대부분의 데이터 세트에서 서로 0.1보다 가까운 백분위수는 확인되지 않습니다.

    <img
      title="percentile.png"
      alt="percentile.png"
      src="/images/queries-nrql_screenshot-full_percentile-NRQL-query-builder.webp"
    />

    <figcaption>
      백분위수 표시 예
    </figcaption>

    `TIMESERIES`를 사용하여 시간 경과에 따라 매핑된 백분위수가 있는 라인 차트를 생성합니다.

    * 백분위수에 대한 집계 값을 표시하는 빌보드 및 속성 시트를 생성하려면 `TIMESERIES`를 생략합니다.

      나열된 백분위수가 없는 경우 기본값은 95번째 백분위수입니다. 50번째 백분위수 값인 중앙값만 반환하려면 [`median()`](#func-median)을 사용할 수도 있습니다.

      <CollapserGroup>
        <Collapser title="기본 백분위수 쿼리">
          이 쿼리는 5번째, 50번째, 95번째 백분위수에 대한 선이 있는 라인 차트를 생성합니다.

          ```sql
          SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO
          ```
        </Collapser>
      </CollapserGroup>

      [`JOIN`](#sel-join)절의 백분위수:

    * 결합된 하위 쿼리에서 백분위수를 사용하는 경우 하위 쿼리의 결과는 각 백분위수를 계산된 값에 매핑하는 복합 데이터 유형입니다.

      외부 쿼리의 개별 백분위수 값을 참조하려면 [`getField()`](#func-getfield) 함수를 사용할 수 있습니다. 매핑된 키는 이중 값의 문자열 표현이므로 정수에 `.0`을 추가해야 합니다. 예를 들어, 95번째 백분위수에 대한 키는 `'95.0'`입니다.

      <CollapserGroup>
        <Collapser title="결합된 백분위수 쿼리">
          ```sql
          FROM PageView
          JOIN (FROM PageAction SELECT percentile(timeSinceLoad, 95, 99.5) as pctl FACET session, currentUrl) ON session
          SELECT latest(getField(pctl, '95.0')) as `95th`, latest(getField(pctl, '99.5')) as `99.5th`
          FACET browserTransactionName, currentUrl
          ```

          <img
            title="screenshot joined percentile"
            alt="screenshot joined percentile"
            src="/images/nrql_screenshot-crop_example-joined-percentile.webp"
          />
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="predictLinear"
    title={<InlineCode>predictLinear(attribute, [,time interval])</InlineCode>}
  >
    `predictLinear()` `derivative()` 함수의 확장입니다. 데이터 세트의 미래 값을 예측하기 위해 유사한 최소 제곱 선형 회귀 방법을 사용합니다.

    * `time interval`은 쿼리가 앞으로 얼마나 멀리 볼 것인지입니다. 예를 들어, `predictLinear(attributeName, 1 hour)`는 쿼리 시간 창에서 1시간 후의 선형 예측입니다.
    * 일반적으로 `predictLinear()`는 디스크 공간과 같이 지속적으로 증가하는 값이나 큰 추세에 대한 예측에 유용합니다.
    * `predictLinear()` 선형 회귀이므로 쿼리되는 데이터세트에 익숙하면 정확한 장기 예측을 보장하는 데 도움이 됩니다.
    * 기하급수적으로, 대수적으로 또는 기타 비선형 수단에 의해 증가하는 데이터 세트는 단기 예측에서만 성공할 가능성이 높습니다.
    * 뉴렐릭은 `TIMESERIES` 쿼리에서 `predictLinear` 사용을 권장하지 않습니다. 이는 각 버킷이 쿼리 내 상대적인 시간 프레임을 기반으로 개별 예측을 수행하기 때문입니다. 즉, 이러한 쿼리는 시계열의 끝부터 예측을 표시하지 않습니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-rate"
    title={<InlineCode>rate(function(attribute) [,time interval])</InlineCode>}
  >
    `rate()` 함수를 사용하여 시간 간격당 주어진 쿼리의 빈도 또는 비율을 시각화합니다. 예를 들어, 한 시간 동안 분당 페이지뷰 수 또는 하루 동안 시간당 사이트의 고유 세션 수를 알고 싶을 수 있습니다.

    * [`TIMESERIES`](#sel-timeseries)를 사용하여 시간에 따라 매핑된 요율이 있는 라인 차트를 생성합니다.
    * 시간 경과에 따른 평균 단일 요율 값을 표시하는 빌보드를 생성하려면 [`TIMESERIES`](#sel-timeseries)를 생략합니다.

      다음은 지난 6시간 동안 10분당 APM 트랜잭션의 처리량 비율을 보여주는 라인 차트를 생성하는 기본 쿼리입니다.

      ```sql
      SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago
      TIMESERIES
      ```

      다음은 `rate`를 사용하여 여러 기간의 데이터를 비교하는 방법을 설명하는 짧은 동영상(3분 21분)입니다.

      <Video
        id="9UArmB4QiVM"
        type="youtube"
      />
  </Collapser>

  <Collapser
    className="freq-link"
    id="stdvar"
    title={<InlineCode>stdvar(attribute)</InlineCode>}
  >
    `stdvar()` 함수를 사용하여 지정된 시간 범위에 대한 숫자 속성의 [표준 분산](https://en.wikipedia.org/wiki/Variance)을 반환합니다.

    단일 인수가 필요합니다. 속성이 숫자가 아니면 0 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-sum"
    title={<InlineCode>sum(attribute)</InlineCode>}
  >
    `sum()` 함수를 사용하여 지정된 시간 범위 동안 숫자 속성의 기록된 값 합계를 반환합니다.

    단일 인수가 필요합니다. 속성이 숫자가 아니면 0 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniqueCount"
    title={<InlineCode>uniqueCount(attribute)</InlineCode>}
  >
    `uniqueCount()` 함수를 사용하여 지정된 시간 범위 동안 속성에 대해 기록된 고유 값의 수를 반환합니다.

    <Callout variant="tip">
      쿼리 성능을 최적화하기 위해 이 함수는 256개 이상의 고유 값을 검사하는 쿼리에 대해 대략적인 결과를 반환합니다.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniques"
    title={<><InlineCode>
      uniques(attribute [,limit]
    </InlineCode><InlineCode>
      )
    </InlineCode></>}
  >
    `uniques()` 함수를 사용하여 지정된 시간 범위 동안 속성에 대해 기록된 고유 값 목록을 반환합니다. `facet` 조항과 함께 사용하면 각 패싯 값마다 고유한 속성 값 목록이 반환됩니다.

    `limit` 매개변수는 선택사항입니다. 제공되지 않으면 패싯당 고유 속성 값 1,000개의 기본 제한이 적용됩니다. 최대 10,000까지 다른 `limit` 값을 지정할 수 있습니다. `uniques()` 함수는 한계에 도달할 때까지 발견된 고유 속성 값의 첫 번째 세트를 반환합니다. 따라서 데이터 세트에 5,000개의 고유 속성 값이 있고 한도가 1,000으로 설정된 경우 연산자는 빈도에 관계없이 발견한 처음 1,000개의 고유 값을 반환합니다.

    쿼리 결과에서 반환될 수 있는 값의 최대 수는 `uniques()` 한도 `facet` 한도의 곱입니다. 다음 쿼리에서 반환될 수 있는 이론적 최대 값 수는 5백만(5,000 x 1,000)입니다.

    쿼리되는 데이터 세트와 쿼리의 복잡성에 따라 메모리 보호 제한으로 인해 매우 큰 쿼리가 실행되지 않을 수 있습니다.

    ```sql
    From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000
    ```

    <CollapserGroup>
      <Collapser title={<>사용 <InlineCode>
          tuple
        </InlineCode></>}>
        몇 가지 속성의 고유한 조합을 알고 싶다면 `SELECT uniques(tuple(x, y, ... z)) ...` 형식으로 쿼리를 구성하여 고유한 값에 대한 튜플을 모두 가져와서 관계를 유지할 수 있습니다. 다음 쿼리에서 `tuple`은 `index` 및 `cellName`에서 함께 사용되어 두 값이 조합되어 발생하는 고유 항목을 찾습니다.

        ```sql
        FROM NodeStatus SELECT uniques(tuple(index, cellName), 5)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### 비 집계 함수 [#non-aggregator-functions]

NRQL 쿼리에서 숫자가 아닌 데이터에 대해 비 집계 함수를 사용합니다.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="acct-type"
    title={<InlineCode>accountId()</InlineCode>}
  >
    `accountId()` 함수를 사용하여 쿼리된 데이터와 연결된 [계정 ID](/docs/accounts/accounts-billing/account-structure/account-id)를 반환합니다. 이 함수는 인수를 사용하지 않습니다. 다음은 몇 가지 예시 쿼리입니다.

    <CollapserGroup>
      <Collapser title="각 트랜잭션 이벤트에 대한 계정 ID 가져오기">
        이 쿼리는 반환된 각 `Transaction` 이벤트와 연결된 계정 ID를 반환합니다.

        ```sql
        SELECT accountId() FROM Transaction SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="각 계정에 대한 트랜잭션 이벤트 수 가져오기">
        이 쿼리는 각 계정 ID와 연결된 마지막 날의 `Transaction` 이벤트 수를 반환합니다.

        ```sql
        SELECT count(*) FROM Transaction FACET accountId() SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="WHERE 조항에 지정된 각 계정에 대한 트랜잭션 이벤트 수를 가져옵니다.">
        이 쿼리는 계정 ID가 구체적으로 `1` , `2` 또는 `3` 중 하나인 마지막 날의 `Transaction` 이벤트 수를 반환합니다.

        ```sql
        SELECT count(*) FROM Transaction WHERE accountId() IN (1,2,3) SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-aparse"
    title={<><InlineCode>
      aparse(attribute, pattern)
    </InlineCode></>}
  >
    앵커 구문 분석 기능인 `aparse()`를 사용하여 문자열에서 특정 값을 추출합니다. 이는 `capture()`의 대안입니다.

    `aparse()` 두 가지 인수를 취합니다.

    * 문자열 속성

    * 앵커 문자열과 추출 문자가 포함된 패턴 문자열입니다. 예를 들어, `www.*.com`을 사용해 URL에서 도메인을 추출할 수 있습니다.

      `aparse()`를 사용하는 경우, 패턴 문자열에는 위의 `www.` 및 `.com` 같은 앵커가 포함되고, `*`로 표시로 표시해야 추출하려는 문자열의 위치를 식별할 수 있습니다.

      `aparse()` 패턴 문자열에 다음 문자를 사용합니다.

    * `%`: `LIKE` 절에서와 같이 비캡처 와일드카드

    * `*`: 정규식 캡처를 사용하는 것과 유사한 와일드카드 캡처

      실제로, 앵커 문자열은 문자열 속성의 시작이나 끝이 아닌 중간에 자주 발생합니다.

      이 경우 원치 않는 값을 무시하려면 `%` 와일드카드를 사용합니다.(예: `%www.*.com%`)

      `capture()`처럼, `aparse()`의 모든 결과는 문자열입니다. 수학 함수에서 이러한 결과를 사용하려면 `numeric()` 함수로 변환해야 합니다.

      참고: `aparse()`는 대소문자를 구분하지 않습니다.

      <CollapserGroup>
        <Collapser
          title="기본적인 사용"
          id="aparse-basic"
          className="freq-link"
        >
          ```sql
          FROM PageView
            SELECT aparse(browserTransactionName, 'website.com/*')
          ```
        </Collapser>

        <Collapser
          title={<><InlineCode>
            aparse()
          </InlineCode> 특정 값</>}
          id="aparse-specific-values"
          className="freq-link"
        >
          문자열 중간에서 값을 추출하려면 패턴 문자열의 시작과 끝 부분에 비캡처 와일드카드 `%`를 사용합니다. 예:

          ```sql
          FROM Log
            SELECT count(*)
            FACET aparse(string, '%"itemId":"*"%')
          ```
        </Collapser>

        <Collapser
          title={<><InlineCode>
            aparse()
          </InlineCode> 여러 값</>}
          id="aparse-multiple-values"
          className="freq-link"
        >
          여러 값을 변수로 추출할 때는 순서가 중요합니다. 예:

          ```sql
          FROM Log
            WITH aparse(string, 'POST: * body: {"itemId":"*","unitPrice":*}\n') AS (url, itemId, unitPrice)
            SELECT url, itemId, unitPrice
          ```

          변수에 대한 보다 자세한 내용은 [NRQL 변수](#with-as-nrql-var)를 참조하십시오.
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-blob"
    title={<InlineCode>blob(속성)</InlineCode>}
  >
    blob 유형 속성에 `blob()` 함수를 사용하여 해당 속성의 base-64로 인코딩된 문자열을 반환합니다.

    이 함수에는 다음과 같은 제한 사항이 있습니다.

    * `blob()`에 대한 호출을 포함하는 쿼리의 최대 `LIMIT` 값은 20입니다.
    * `blob()` 쿼리의 `WHERE` 절에서는 호출할 수 없습니다.
    * `blob()` 패싯 쿼리 또는 시계열 쿼리에는 사용할 수 없습니다.

      Logging에서 이것이 사용되는 방법에 대한 자세한 내용은 [긴 로그(blob)에서 데이터 찾기](/docs/logs/log-management/ui-data/long-logs-blobs)를 참조하십시오.

      Base-64로 인코딩된 blob을 디코딩하려면 [`decode()` 함수](#func-decode)를 참조하십시오.

      <CollapserGroup>
        <Collapser title={<>확장 로그에서 <InlineCode>
            blob()
          </InlineCode> 사용</>}>
          ```sql
          SELECT message, blob(`newrelic.ext.message`) FROM Log WHERE newrelic.ext.message IS NOT NULL
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-buckets"
    title={<InlineCode>buckets(attribute, ceiling [,number of buckets])</InlineCode>}
  >
    `buckets()` 함수를 사용하여 `FACET` 조항로 분할된 데이터를 범위를 기반으로 버킷으로 집계합니다. 뉴렐릭 데이터베이스에 숫자 값으로 저장된 모든 속성으로 버킷을 만들 수 있습니다.

    세 가지 인수가 필요합니다.

    * Attribute name(속성 이름)
    * 샘플 범위의 최대값(모든 이상값은 최종 버킷에 표시됨)
    * Total number of buckets(총 버킷 수)

      자세한 내용과 예는 [데이터를 버킷으로 분할](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/segment-your-insights-data-buckets)을 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-concat"
    title={<InlineCode>concat(attribute, [, attribute [, ...]][, precision: ]))</InlineCode>}
  >
    `concat()` 함수를 사용하여 인수를 연결한 결과 문자열을 반환합니다.

    숫자, 부울, 튜플 또는 배열 유형의 인수가 최대 20개까지 제공될 수 있습니다. Null 인수와 지원되지 않는 형식의 인수는 무시됩니다. 인수가 제공되지 않으면, 결과는 빈 문자열이 됩니다.

    부동 소수점 숫자 값을 연결할 때 포함되는 소수 자릿수를 제한하기 위해 선택 가능한 정밀도 인수가 제공될 수 있습니다.

    결과 문자열의 최대 길이는 4096자입니다.

    <CollapserGroup>
      <Collapser title="'PageView'에서 여러 기간 값을 포맷이 지정된 문자열로 가져옵니다.">
        이 쿼리는 소수 두 자리와 레이블로 형식이 지정된 `PageView` 이벤트의 백엔드 및 네트워크 기간을 단일 문자열로 반환합니다.

        ```sql
        FROM PageView SELECT concat('Backend Duration: ', backendDuration, ', Network Duration: ', networkDuration, precision: 2)
        ```

        그러면 다음과 같은 형식으로 응답이 반환됩니다.

        `Backend Duration: 0.69, Network Duration: 0`
      </Collapser>

      <Collapser title="형식이 지정된 문자열에 의한 패싯 쿼리 결과">
        이 쿼리는 사용자의 도시, 지역 및 국가로 구성된 문자열로 패싯 처리된 `PageView` 이벤트의 평균 연결 설정 기간을 반환합니다.

        ```sql
        FROM PageView SELECT average(connectionSetupDuration) FACET concat(city, ', ', regionCode, ' ', countryCode) WHERE countryCode IN ('US', 'CA')
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-convert"
    title={<InlineCode>convert(attribute, fromUnits, toUnits)</InlineCode>}
  >
    주어진 입력 값에 대해 제공된 단위 간에 단위 변환을 수행하려면 `convert()` 함수를 사용합니다.

    OpenTelemetry 사양에 맞춰 [UCUM 표준](https://ucum.org/ucum)을 사용해 시간, 길이, 무게, 볼륨, 및 데이터에 대한 일반 단위와 약어가 지원됩니다. 편의를 위해 표준화된 약어는 `ft_us`, `kilobytes` 및 `µs` 외에 `ft` 같은 일부 대체 자연어로 보강됩니다.

    단위는 대소문자를 _구분합니다_. 사양에서 대문자를 요구하지 않는 한 모든 단위는 소문자입니다. 예를 들어, 데이터 단위 `'bits'`는 비트에 유효하고 `'By'`는 바이트에 대해 대문자 `B`가 사용되어야 합니다.

    시간의 가장 큰 단위는 태양력 `year`이며 항상 365.25일입니다.

    <CollapserGroup>
      <Collapser title="속성을 밀리초에서 분으로 변환">
        ```sql
        FROM Transaction SELECT convert(duration, 'ms', 'min') AS durationMin
        ```
      </Collapser>

      <Collapser title="무게의 합을 그램에서 파운드로 변환">
        ```sql
        FROM Product SELECT convert(sum(itemWeight), 'grams', 'lbs')
        ```
      </Collapser>

      <Collapser title="저장된 시간 단위와 초 간 변환">
        이 쿼리는 이벤트 자체에 문자열 속성으로 저장된 단위 정보가 있고 값을 초로 표준화하려고 한다고 가정합니다.

        ```sql
        FROM Metric SELECT average(convert(apm.mobile.external.duration, unit, 's')) WHERE appName = 'my-application'
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-capture"
    title={<InlineCode>캡처(속성, 정규 표현식)</InlineCode>}
  >
    [RE2 구문](https://github.com/google/re2/wiki/Syntax)이 있는 정규식을 사용하여 속성에서 값을 추출하려면 `capture()`를 사용합니다.

    두 가지 인수가 필요합니다.

    * Attribute name(속성 이름)
    * 캡처 구문이 있는 정규 표현식(NRQL의 정규 표현식은 Python과 유사한 구문 `r'...'` 사용)

      캡처할 때, 특정 이름을 고려하여 RE2 명명된 캡처 구문 `...(?P<name> pattern )...`을 사용하여 포함된 패턴을 캡처합니다.

      정규식에 추가적인 캡처 그룹을 지정하여 여러 값을 캡처할 수 있습니다. 예: `...(?P<name1> pattern1)...(?P<name2> pattern2)...`

      참고: 여러 값을 캡처할 때 각 캡처 문은 최대 16개의 캡처 그룹을 가질 수 있으며, 각 NRQL 쿼리는 최대 5개의 캡처 문을 가질 수 있습니다.

      [쿼리 결과를 개선하기 위해 정규식 캡처를 사용](https://newrelic.com/blog/how-to-relic/using-regex-capture)하는 방법을 확인하십시오.

      <Callout variant="tip">
        정규식은 전체 입력과 일치해야 합니다. 캡처 표현식이 예상 결과를 추출하지 않는 경우, 시작 또는 끝에 일부 매치 정규표현식을 위한 패턴인 `.*`가 필요한지 확인합니다. 그러나 부분 정규표현식으로 인해 쿼리 실행이 느려질 수 있습니다.
      </Callout>

      다음은 `capture()`를 사용하여 대시보드 가독성을 높이는 방법을 보여주는 짧은 동영상(3분 5분)입니다.

      <Video
        id="hOPrTWYgPHg"
        type="youtube"
      />

      자세한 내용은 아래 예를 참조하십시오.

      <CollapserGroup>
        <Collapser title={<><InlineCode>
            capture()
          </InlineCode> <InlineCode>
            SELECT
          </InlineCode> 조항 조건 내에서</>}>
          다음은 웹사이트의 도메인 이름을 선택하고 `https://` 및 다음 경로를 제거합니다. `.com`

          ```sql
          SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') FROM PageView SINCE 1 day ago
          ```

          다음은 오류 메시지의 첫 번째 단어만 캡처합니다.

          ```sql
          SELECT capture(errorMessage, r'(?P<firstWord>\S+)\s.+') FROM Transaction SINCE 1 hour ago where errorMessage is not null
          ```
        </Collapser>

        <Collapser title={<><InlineCode>
            capture()
          </InlineCode> <InlineCode>
            FACET
          </InlineCode> 조항 조건 내에서</>}>
          다음은 캡처된 HTTP 메서드에 의해 패싯됩니다.

          ```sql
          SELECT count(*) FROM Log WHERE message like '%HTTP%' FACET capture(message, r'.* "(?P<httpMethod>[A-Z]+) .*')
          ```
        </Collapser>

        <Collapser title={<><InlineCode>
            capture()
          </InlineCode> <InlineCode>
            WHERE
          </InlineCode> 조항 조건 내에서</>}>
          다음은 캡처된 작업 이름이 `ExampleJob`인 정규식과 일치하는 `message` 속성이 있는 로그 이벤트를 기반으로 결과를 필터링합니다.

          ```sql
          SELECT message FROM Log WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' SINCE 10 minutes ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser title={<><InlineCode>
            capture()
          </InlineCode> 숫자 캐스트로</>}>
          다음은 로그 라인에서 CPU 시간의 합계를 캡처합니다. 수학 연산을 수행하려면 명시적으로 숫자로 캐스트해야 합니다.

          ```sql
          SELECT sum(numeric(capture(message, r'.*CpuTime:\s(?P<cpuTime>\d+)'))) FROM Log WHERE message like '%CpuTime:%' SINCE 1 hour ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser title={<><InlineCode>
            capture()
          </InlineCode> NRQL 변수가 있는 여러 값</>}>
          이 예에서 NRQL 변수는 로그 메시지에서 캡처된 여러 값을 저장하는 데 사용됩니다.

          ```sql
          FROM Log
            WITH capture(message, r'POST to carts: (?P<URL>.*) body: {"itemId":"(?P<UUID>.*)","unitPrice":(?P<unitPrice>.*)}.*')
              AS (URL, UUID, unitPrice)
            SELECT URL, UUID, unitPrice
            WHERE URL IS NOT NULL
          ```

          NRQL 변수에 대한 보다 자세한 내용은 [여기](#with-as-nrql-var)를 참조하십시오.
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-decode"
    title={<InlineCode>decode(input, encoding)</InlineCode>}
  >
    문자열과 blob에 대해 base-64 변환을 수행하려면 `decode()`를 사용합니다. 입력 값(첫 번째 인수)은 인코딩(두 번째 인수)에 지정된 Base-64 표준을 사용하여 디코딩됩니다.

    다음 문자열 값은 지원되는 인코딩 매개변수입니다.

    * 'base64': [RFC4648 base-64 표준](https://datatracker.ietf.org/doc/html/rfc4648#section-4) 사용
    * 'base64mime': [RFC2045 base-64 표준(MIME)](https://datatracker.ietf.org/doc/html/rfc2045) 사용
    * 'base64url': [RFC4648 base-64 standard와 URL 및 파일이름에 안전한 알파벳](https://datatracker.ietf.org/doc/html/rfc4648#section-5) 사용

      `WHERE` 또는 `FACET` 절에서는 `blob()`이 허용되지 않으므로, blob 유형이 있는 `decode()` `WHERE` 절이나 패싯 쿼리에서는 지원되지 않습니다.

      문자열을 인코딩하려면 [`encode()` 함수](#func-encode)를 참조하십시오.

      <CollapserGroup>
        <Collapser title={<>문자열 속성에 <InlineCode>
            decode()
          </InlineCode> 사용</>}>
          ```sql
          FROM Span SELECT entity.guid, decode(entity.guid, 'base64') WHERE entity.guid IS NOT NULL
          ```
        </Collapser>

        <Collapser title={<><InlineCode>
            decode()
          </InlineCode> 사용 <InlineCode>
            FACET
          </InlineCode></>}>
          ```sql
          FROM Span SELECT count(*) WHERE entity.guid IS NOT NULL FACET entity.guid, decode(entity.guid, 'base64')
          ```
        </Collapser>

        <Collapser title={<><InlineCode>
            WHERE
          </InlineCode> 절에 <InlineCode>
            decode()
          </InlineCode> 사용</>}>
          ```sql
          FROM Span SELECT count(*) WHERE entity.guid IS NOT NULL AND decode(entity.guid, 'base64') NOT LIKE '%APM%'
          ```
        </Collapser>

        <Collapser title={<>blob 유형 속성과 함께 <InlineCode>
            decode()
          </InlineCode> 사용</>}>
          ```sql
          FROM Log
          WITH blob(`newrelic.ext.message`) as encodedBlob,
          decode(encodedBlob, 'base64') as decodedBlob
          SELECT encodedBlob, decodedBlob
          WHERE newrelic.ext.message IS NOT NULL
          LIMIT 10
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-dimensions"
    title={<InlineCode>{`dimensions(include: {attributes}, exclude: {attributes})`}</InlineCode>}
  >
    `dimensions()` 함수를 사용하여 데이터 유형의 모든 차원 값을 반환합니다.

    선택적 인수를 사용하여 특정 속성을 명시적으로 포함하거나 제외할 수 있습니다.

    * 포함: 있는 경우 포함 목록은 `dimensions()`를 해당 속성으로 제한합니다.
    * 제외: 있는 경우, `dimensions()` 계산은 해당 속성을 무시합니다.

      ```sql
      FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions()
      ```

      `FACET` 조항과 함께 사용하면 `dimensions()`는 Prometheus가 집계되지 않은 쿼리에서 작동하는 방식과 유사하게 이벤트 유형에서 사용 가능한 모든 패싯에 대해 고유한 시계열을 생성합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-encode"
    title={<InlineCode>encode(input, encoding)</InlineCode>}
  >
    문자열에 대해 Base-64 변환을 수행하려면 `encode()`를 사용합니다. 입력 값(첫 번째 인수)은 인코딩(두 번째 인수)에 지정된 Base-64 표준을 사용하여 인코딩됩니다.

    다음 문자열 값은 지원되는 인코딩 매개변수입니다.

    * 'base64': [RFC4648 base-64 표준](https://datatracker.ietf.org/doc/html/rfc4648#section-4) 사용
    * 'base64mime': [RFC2045 base-64 표준(MIME)](https://datatracker.ietf.org/doc/html/rfc2045) 사용
    * 'base64url': [RFC4648 base-64 standard와 URL 및 파일이름에 안전한 알파벳](https://datatracker.ietf.org/doc/html/rfc4648#section-5) 사용

      문자열이나 blob을 디코딩하려면 [`decode()` 함수](#func-decode)를 참조하십시오. `encode()`는 Blob에 지원되지 않습니다.

      <CollapserGroup>
        <Collapser title={<>속성에 <InlineCode>
            encode()
          </InlineCode> 사용</>}>
          ```sql
          FROM PageView SELECT session, encode(session, 'base64')
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cidraddress"
    title={<InlineCode>cidrAddress(attribute [, number [, cidrFormat])</InlineCode>}
  >
    CIDR IP 주소에서 기본 네트워크 주소를 얻으려면 `cidrAddress()` 함수를 사용합니다.

    `cidrAddress()` 는 다음 인수를 사용합니다.

    * attribute - IP 주소 자체 또는 CIDR 표기법의 접두사 길이를 포함하는 문자열 값입니다.

      * 이는 문자열 속성이거나 따옴표로 묶인 문자열 리터럴일 수 있습니다.
      * IP 주소는 IPv4 주소여야 합니다.

    * number - 접두사 길이를 나타내는 정수 값입니다.

      * 이는 정수 속성이거나 정수 값일 수 있습니다.
      * 속성 매개변수가 CIDR 표기법인 경우 이 매개변수는 선택사항이며 CIDR 문자열에 제공된 접두사 길이보다 우선합니다.

    * cidrFormat - 네트워크 주소 출력을 CIDR 표기법으로 형식화해야 하는지 결정하는 데 사용되는 선택적 부울 값입니다. 기본값은 true입니다.

      `cidrAddress()` 함수는 속성 및 숫자 매개변수에 유효한 IP 주소와 접두사 길이가 포함되어 있는 경우 항상 값을 반환합니다. 매개변수 입력이 유효하지 않으면 `cidrAddress()` `null`을 반환합니다.

      <CollapserGroup>
        <Collapser title="가장 많은 요청을 처리하고 있는 서브넷 찾기">
          다음 쿼리는 [SyntheticRequest](/attribute-dictionary/?event=SyntheticRequest) 이벤트 유형에서 가장 많은 요청을 처리하는 서브넷을 반환합니다.

          ```sql
          FROM SyntheticRequest SELECT count(*) FACET cidrAddress(serverIPAddress, 24)
          ```

          그러면 다음과 같은 형식으로 응답이 반환됩니다.

          <table>
            <thead>
              <tr>
                <th>
                  Cidr 서버 주소 IP 주소
                </th>

                <th>
                  count
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  10.0.0.0/24
                </td>

                <td>
                  6k
                </td>
              </tr>

              <tr>
                <td>
                  10.10.1.0/24
                </td>

                <td>
                  4k
                </td>
              </tr>

              <tr>
                <td>
                  10.0.14.0/24
                </td>

                <td>
                  1k
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser title="CIDR 범위에 존재하는 모든 IP 주소 쿼리">
          이 쿼리는 CIDR 범위 10.0.0.0-10.0.0.255 내에 존재하는 [`serverIPAddress`](/attribute-dictionary/?event=SyntheticRequest&attribute=serverIPAddress) 속성의 모든 IP 주소를 반환합니다.

          ```sql
          FROM SyntheticRequest SELECT uniques(serverIPAddress) WHERE cidrAddress(serverIPAddress, 24) = '10.0.0.0/24'
          ```
        </Collapser>

        <Collapser title="쿼리 결과에서 특정 CIDR 범위에 존재하는 IP 주소를 필터링합니다.">
          이 쿼리는 CIDR 범위 10.0.0.0/24 또는 10.10.1.0/24에 속하는 [`serverIPAddress`](/attribute-dictionary/?event=SyntheticRequest&attribute=serverIPAddress) 값을 포함하는 레코드를 제외하면서 모든 레코드 수를 반환합니다.

          ```sql
          FROM SyntheticRequest SELECT count(*) WHERE cidrAddress(serverIPAddress, 24) NOT IN ('10.0.0.0/24', '10.10.1.0/24')
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="event-type"
    title={<InlineCode>eventType()</InlineCode>}
  >
    ```sql
    ...WHERE eventType() = 'EventNameHere'...
    ...FACET eventType()...
    ```

    [FACET](#sel-facet) 조항에서 `eventType()` 함수를 사용하여 선택한 데이터 유형별로 결과를 분류하거나 [WHERE](#sel-where) 조항에서 특정 데이터 유형으로 결과를 필터링합니다. 이는 [filter()](#func-filter) 및 [percent()](#func-percentage) 함수를 사용하여 특정 데이터 유형을 대상으로 지정할 때 특히 유용합니다.

    <Callout variant="important">
      이 컨텍스트에서 "event type"은 NRQL 쿼리로 액세스할 수 있는 데이터 유형을 나타냅니다.
    </Callout>

    <CollapserGroup>
      <Collapser
        id="filter-eventtype"
        title={<><InlineCode>
          filter()
        </InlineCode> 함수에서 <InlineCode>
          eventType()
        </InlineCode> 사용</>}
      >
        이 쿼리는 총 `Transaction`개 결과 중 총 `TransactionError`개 결과의 백분율을 반환합니다. `eventType()` 함수를 사용하여 `filter()` 함수가 있는 특정 유형의 데이터를 대상으로 지정할 수 있습니다.

        ```sql
        SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago
        ```
      </Collapser>

      <Collapser
        id="facet-eventtype"
        title={<>과 함께 <InlineCode>
          eventType()
        </InlineCode> 사용 <InlineCode>
          FACET
        </InlineCode></>}
      >
        이 쿼리는 각 데이터 유형( `Transaction` 및 `TransactionError` )가 반환하는 레코드 수를 표시합니다.

        ```sql
        SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getfield"
    title={<InlineCode>getField(attribute, field)</InlineCode>}
  >
    `getField()` 함수를 사용하여 [디멘션 메트릭 데이터](/docs/data-apis/understand-data/metric-data/metric-data-type)같은 복합 데이터 유형에서 필드를 추출합니다.

    다음 인수를 취합니다.

    <table>
      <thead>
        <tr>
          <th style={{ width: "500px" }}>
            메트릭 유형
          </th>

          <th>
            지원되는 필드
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `summary`
          </td>

          <td>
            `count`, `total`, `max`, `min`, `type`
          </td>
        </tr>

        <tr>
          <td>
            `gauge`
          </td>

          <td>
            `count`, `total`, `max`, `min` , `latest`, `type`
          </td>
        </tr>

        <tr>
          <td>
            `distribution`
          </td>

          <td>
            `count`, `total`, `max`, `min`, `type`
          </td>
        </tr>

        <tr>
          <td>
            `count`
          </td>

          <td>
            `count`, `type`
          </td>
        </tr>

        <tr>
          <td>
            `cumulativeCount`
          </td>

          <td>
            `count`, `cumulative`, `type`
          </td>
        </tr>

        <tr>
          <td>
            `timeslice`
          </td>

          <td>
            `count`, `total`, `totalExclusive`, `min` , `max`, `sumOfSquares`
          </td>
        </tr>
      </tbody>
    </table>

    예:

    ```sql
    SELECT max(getField(mySummary, count)) from Metric
    ```

    ```sql
    SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getCdfCount"
    title={<InlineCode>getCdfCount(attribute, threshold)</InlineCode>}
  >
    `getCdfCount()` 는 [누적 분포 함수](https://en.wikipedia.org/wiki/Cumulative_distribution_function) 의 구현으로, `threshold` 이하의 `attribute` 숫자 값을 반환합니다.

    하나의 임계값만 허용됩니다. `Attribute`는 숫자 속성이거나 분포 메트릭 속성일 수 있습니다. 하나의 쿼리에 혼합 유형이 허용됩니다.

    숫자 유형의 경우 속성이 임계값보다 작거나 같으면 1을 반환하고, 그렇지 않으면 0을 반환합니다. 분포의 경우 분포가 나타내는 데이터 세트의 개수를 반환합니다. 다른 모든 유형의 경우 0을 반환합니다.

    <CollapserGroup>
      <Collapser title="임계값보다 빠르게 첫 번째 페인트 수를 가져옵니다.">
        이 쿼리는 `firstPaint`가 1초 이하인 이벤트 수를 반환합니다.

        ```sql
        FROM PageView SELECT sum(getCdfCount(firstPaint, 1.0))
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-if"
    title={<><InlineCode>
      if(condition, trueValue [, falseValue])
    </InlineCode></>}
  >
    `if()`를 사용하여 쿼리 전체에서 if-then-else 제어 흐름 작업을 수행합니다.

    `if()` 세 가지 인수를 취합니다.

    * condition - true 또는 false로 평가할 수 있는 표현식입니다.
    * trueValue - 부울 표현식이 true인 경우 이 값이 반환됩니다.
    * falseValue - 부울 표현식이 false인 경우 이 선택적 값이 반환되거나 NULL이 제공되지 않은 경우 반환됩니다.

      <CollapserGroup>
        <Collapser title="기본적인 사용">
          ```sql
          FROM Log
            SELECT count(*)
            FACET if(level_name = 'ERROR', 'ERROR', 'NOT_ERROR')
          ```
        </Collapser>

        <Collapser title={<><InlineCode>
            AND
          </InlineCode> 및 <InlineCode>
            OR
          </InlineCode></>}>
          ```sql
          FROM Log
            SELECT count(*)
            FACET if(level_name = 'INFO' OR level_name = 'WARNING', 'NOT_ERROR', 'ERROR')
          ```
        </Collapser>

        <Collapser title={<>Nested <InlineCode>
            If()
          </InlineCode></>}>
          중첩된 if() 함수를 사용하여 조건부 논리를 추가합니다.

          ```sql
          FROM Transaction SELECT count(*)
            FACET if(appName LIKE '%java%', 'Java',
            if(appName LIKE '%kafka%', 'Kafka', 'Other'))
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-jparse"
    title={<InlineCode>jparse(attribute [, path])</InlineCode>}
  >
    JSON 구문 분석 함수인 `jparse()`를 사용하여 문자열 값을 구문 분석하고 NRQL의 다른 일류 값 유형처럼 처리할 수 있는 값의 맵/목록(또는 중첩 구조)을 생성합니다.

    `jparse()` 두 가지 인수를 취합니다.

    * attribute - JSON 문자열 값입니다.
    * path - `attribute` 매개변수 내에서 JSON의 특정 부분을 직접 참조하는 데 사용되는 선택적 문자열 값입니다. 아래 [JSON 구문 분석 경로 구문 참조](#json-parse-path-syntax-reference) 섹션을 참조하십시오.

      `jparse()` 함수는 [RFC 8259 포맷](https://datatracker.ietf.org/doc/html/rfc8259#section-2)에 따라 JSON 값을 구문 분석합니다. `path` 매개변수 없이 `jparse()` 함수를 사용하면 역직렬화된 JSON 값이 반환됩니다.

      대괄호를 사용하여 키/인덱스를 통해 `jparse()` 결과에서 개별 값을 가져오고 `WITH` 절을 사용하여 JSON 키를 속성에 직접 매핑할 수 있습니다.

      <CollapserGroup>
        <Collapser
          id="jparse-square-bracket-syntax"
          title="대괄호 구문을 사용하여 키/인덱스 참조"
        >
          <DNT>
            **Referencing a key**
          </DNT>

          다음 쿼리는 `jsonString` 속성 내에서 `userNames` 키를 참조하고 `['abc', 'xyz']`를 반환합니다.

          ```sql
          WITH '{"userNames": ["abc", "xyz"]}' as jsonString SELECT jparse(jsonString)[userNames]
          ```

          <DNT>
            **Referencing an index**
          </DNT>

          다음 쿼리는 `jsonString` 속성 내의 인덱스 `0`을 참조하고 `'abc'`를 반환합니다.

          ```sql
          WITH '["abc", "xyz"]' as jsonString SELECT jparse(jsonString)[0]
          ```
        </Collapser>

        <Collapser
          id="mapping-json-keys-to-attributes"
          title="JSON 키를 속성에 매핑"
        >
          다음 쿼리는 `WITH` 절에서 `jparse()`를 사용하여 JSON 키 `userName` 및 `id`를 NRQL 변수에 매핑하므로 쿼리의 나머지 부분에서 사용될 수 있습니다.

          ```sql
          WITH '{"userName": "test", "unused": null, "id": 100}' as jsonString, jparse(jsonString) AS (userName, id) SELECT userName, id
          ```
        </Collapser>
      </CollapserGroup>

      JSON 문자열의 특정 값을 구문 분석하려면 `path` 매개변수를 사용할 수 있습니다.

      <Collapser
        id="json-parse-path-syntax-reference"
        title="JSON 구문 분석 경로 구문 참조"
      >
        JSON 데이터는 중요한 형태의 여러 레이어로 중첩되는 것이 일반적입니다. 경로 구문을 사용하면 JSON 데이터의 특정 부분을 직접 참조할 수 있습니다.

        예시 데이터:

        ```
        {
          "valueA": "test",

          "valueB": {

            "nestedValue1": [1, 2, 3],

            "nestedValue2": 100

          },

          "valueC: [

            { "id": 1, "label": "A", "other": 7 },

            { "id": 2, "label": "B", "other": 9  },

            { "id": 3, "label": "C", "other": 13  }

          ]
        }
        ```

        위 데이터를 사용한 경로 구문 예:

        <table id="join-types">
          <thead>
            <tr>
              <th>
                <DNT>
                  **Path Syntax Example**
                </DNT>
              </th>

              <th>
                <DNT>
                  **Result Description**
                </DNT>
              </th>

              <th>
                <DNT>
                  **Result**
                </DNT>
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                'valueA'
              </td>

              <td>
                키의 값 반환
              </td>

              <td>
                `"test"`
              </td>
            </tr>

            <tr>
              <td>
                '[&quot;valueA&quot;]'
              </td>

              <td>
                키의 값 반환
              </td>

              <td>
                `"test"`
              </td>
            </tr>

            <tr>
              <td>
                '[valueA, valueC]'
              </td>

              <td>
                키 값 목록 반환
              </td>

              <td>
                `["test", [...]]`
              </td>
            </tr>

            <tr>
              <td>
                'valueB.nestedValue2'
              </td>

              <td>
                키의 값 반환
              </td>

              <td>
                `100`
              </td>
            </tr>

            <tr>
              <td>
                'valueC[0]'
              </td>

              <td>
                인덱스 0의 목록 값 반환
              </td>

              <td>
                `{"id": 1…}`
              </td>
            </tr>

            <tr>
              <td>
                'valueC[0,2]'
              </td>

              <td>
                인덱스 0과 2의 목록 값 반환
              </td>

              <td>
                `[{"id": 1…}, {"id": 3…}]`
              </td>
            </tr>

            <tr>
              <td>
                'valueC[0:2]'
              </td>

              <td>
                두 번째 인덱스의 값을 제외하고 첫 번째 인덱스에서 두 번째 인덱스까지의 목록 값 범위 반환. 이 경우 인덱스 0과 1의 목록 값 반환
              </td>

              <td>
                `[{"id": 1…}, {"id": 2…}]`
              </td>
            </tr>

            <tr>
              <td>
                'valueC[:2]'
              </td>

              <td>
                두 번째 인덱스의 값을 제외하고 처음부터 두 번째 인덱스까지 목록 값의 범위 반환. 이 경우 인덱스 0과 1의 목록 값 반환
              </td>

              <td>
                `[{"id": 1…}, {"id": 2…}]`
              </td>
            </tr>

            <tr>
              <td>
                'valueC[:-2]'
              </td>

              <td>
                마지막 n을 제외한 모든 목록 값 반환. 여기서 n은 콜론 뒤의 음수(예: [:-n]). 이 경우 인덱스 0의 목록 값 반환
              </td>

              <td>
                `[{"id": 1…}]`
              </td>
            </tr>

            <tr>
              <td>
                'valueC[1:]'
              </td>

              <td>
                지정된 인덱스부터 목록 끝까지의 목록 값 범위 반환. 이 경우 인덱스 1과 2의 목록 값 반환
              </td>

              <td>
                `[{"id": 2…}, {"id": 3…}]`
              </td>
            </tr>

            <tr>
              <td>
                'valueC[-1:]'
              </td>

              <td>
                마지막 n개의 목록 값 반환. 여기서 n은 콜론 앞의 음수(예: [-N:]). 이 경우 인덱스 2의 목록 값 반환
              </td>

              <td>
                `[{"id": 3…}]`
              </td>
            </tr>

            <tr>
              <td>
                'valueC[*]'
              </td>

              <td>
                모든 목록 값 반환
              </td>

              <td>
                `[{"id": 1…}, {"id": 2…},{"id": 3…}]`
              </td>
            </tr>

            <tr>
              <td>
                'valueC[*].id'
              </td>

              <td>
                모든 목록 구성원에서 지정된 키 값 반환. 이 경우 "id" 키 값
              </td>

              <td>
                `[1, 2, 3]`
              </td>
            </tr>

            <tr>
              <td>
                'valueC[\*][&quot;label&quot;, other]'
              </td>

              <td>
                모든 목록 구성원에서 지정된 키 반환. 이 경우 “label”과 “other” 키 값
              </td>

              <td>
                `[["A", 7],…]`
              </td>
            </tr>
          </tbody>
        </table>
      </Collapser>

      예:

      <CollapserGroup>
        <Collapser
          id="basic-jparse-example"
          title="기본 예"
        >
          다음 쿼리는 `jsonString` 속성 내의 JSON 문자열을 구문 분석합니다.

          ```sql
          WITH '{"user": {"name": "John", "id": 5}}' as jsonString SELECT jparse(jsonString)
          ```

          이 쿼리는 역직렬화된 JSON 문자열을 반환합니다.

          ```
          {"user":{"name":"John","id":5}}
          ```
        </Collapser>

        <Collapser
          id="parse-specific-value-from-log-message"
          title="로그 메시지에서 특정 값을 구문 분석합니다."
        >
          일반적인 문제는 로그 메시지 내에 구조화된 많은 데이터가 숨겨져 있다는 것입니다. [`aparse()`](#func-aparse) 및 `jparse()`를 활용하면 노이즈를 제거하고 특정 값을 찾을 수 있습니다.

          다음 쿼리는

          1. `aparse()`를 호출하여 `logMessage` 속성에서 JSON 데이터를 추출합니다.
          2. `jparse()` 및 `user.name` 경로 매개변수를 사용하여 추출된 JSON 데이터에서 `user.name` 필드를 구문 분석합니다.

             ```sql
             WITH '1693242121842: value=\'{"user": {"name": "John", "id": 5}}\', useless=stuff' as logMessage, aparse(logMessage, '%: value=\'*\'%') AS jsonString SELECT jparse(jsonString, 'user.name')
             ```
        </Collapser>

        <Collapser
          id="parse-multiple-values-from-json"
          title="JSON 문자열에서 여러 중첩 값의 구문 분석"
        >
          다음 쿼리는 `jsonString` 속성 내의 개체 목록에서 각 `id` 필드를 구문 분석하고 이러한 값을 배열로 출력합니다.

          ```sql
          WITH '{"users": [{"name": "A", "id": 5}, {"name": "B", "id": 10}]}' as jsonString, jparse(jsonString, 'users[*].id') as ids SELECT ids
          ```

          위 쿼리는 `[5, 10]`을 반환합니다.
        </Collapser>
      </CollapserGroup>

      _관련 함수:_ [`mapKeys()`](#func-mapKeys), [`mapValues()`](#func-mapValues)
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-length"
    title={<InlineCode>length(attribute)</InlineCode>}
  >
    `length()` 함수를 사용하여 문자열 값의 길이 또는 배열 값의 요소 수를 반환합니다.

    단일 인수가 필요합니다.

    <CollapserGroup>
      <Collapser title="PageView에서 URL 길이 가져오기">
        이 쿼리는 `PageView` 이벤트에서 각 URL 문자열의 길이를 반환합니다.

        ```sql
        SELECT length(pageUrl) FROM PageView
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-lookup"
    title={<InlineCode>룩업(테이블)</InlineCode>}
  >
    [룩업 테이블을 업로드](/docs/logs/ui-data/lookup-tables-ui)한 경우, 테이블 이름과 함께 이 함수를 사용해 쿼리에서 테이블의 데이터에 액세스할 수 있습니다. 다음은 예제 쿼리입니다.

    ```sql
    FROM Log
    SELECT count(*)
    WHERE hostname IN (FROM lookup(myHosts) SELECT uniques(myHost))
    ```

    보다 자세한 내용은 [룩업 테이블 데이터를 쿼리하는 방법](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/lookups)을 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-lower"
    title={<InlineCode>lower(str)</InlineCode>}
  >
    `lower()` 함수를 사용하여 문자열 값의 모든 알파벳 문자를 소문자로 변경합니다.

    인수:

    * str - 소문자가 되어야 하는 문자열 값입니다.

      * 여기에는 따옴표로 묶인 리터럴 문자열, 쿼리된 문자열 속성, 문자열을 반환하는 함수 또는 단일 문자열 값을 반환하는 하위 쿼리 등 문자열로 평가되는 모든 것이 해당될 수 있습니다.
      * 이 인수가 null로 평가되면 `lower()` 함수는 null을 반환합니다.

      <CollapserGroup>
        <Collapser title="Lower-case a string">
          이 쿼리는 쿼리의 다양한 부분에서 `lower()` 함수를 사용하는 방법을 보여줍니다.

          ```sql
          FROM PageAction
          SELECT latest(lower(actionName))
          WHERE lower(actionName) = lower('acmePageRenderedEvent') OR lower(actionName) = lower('SubmitLogin')
          FACET concat(actionName, ':', lower(actionName))
          ```

          <img
            title="screenshot lower()"
            alt="screenshot lower()"
            src="/images/lowerExample.webp"
          />

          <figcaption>
            <InlineCode>lower(str)
            </InlineCode> 예
          </figcaption>
        </Collapser>
      </CollapserGroup>

      _관련 함수: [<InlineCode>
      upper()</InlineCode>](#func-upper)_
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mapKeys"
    title={<InlineCode>mapKeys(attribute)</InlineCode>}
  >
    `attribute` 매개변수 내에서 입력으로 맵이 제공된 경우 `mapKeys()` 함수를 사용하여 키 목록을 반환합니다.

    <CollapserGroup>
      <Collapser
        id="extract-list-of-keys"
        title="JSON 문자열 내에서 키 목록 추출"
      >
        ```sql
        WITH '{"userResult1": 100, "userResult2": 200, "userResult3": 4}' as jsonString SELECT mapKeys(jparse(jsonString)) AS keys
        ```

        위의 쿼리는

        1. `jparse()` 함수를 사용하여 `jsonString` 속성 내의 JSON 문자열을 맵으로 역직렬화합니다.
        2. `mapKeys()` 함수를 호출하여 이 맵 내의 모든 키 목록을 추출합니다.
        3. 이 키 목록을 `keys` 속성에 바인딩합니다.

        위 쿼리를 실행하면 `keys`에 `['userResult1', 'userResult2', 'userResult3']` 목록이 포함됩니다.
      </Collapser>

      <Collapser
        id="extract-list-of-keys-with-nested-keys"
        title="중첩된 키가 있는 JSON 문자열에서 키 목록 추출"
      >
        ```sql
        WITH '{"value1": "test", "value2": {"nestedValue1": [1, 2, 3], "nestedValue2": 100}}' as jsonString SELECT mapKeys(jparse(jsonString)) AS keys
        ```

        위 쿼리는 `jsonString` 속성 내의 JSON 문자열에서 가장 바깥쪽 키만 추출합니다. 쿼리를 실행하면 `keys` 에 `['value1', 'value2']` 목록이 포함됩니다.
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mapValues"
    title={<InlineCode>mapValues(attribute)</InlineCode>}
  >
    `attribute` 매개변수 내에 입력으로 맵이 제공된 경우 값 목록을 반환하려면 `mapValues()` 함수를 사용합니다.

    <CollapserGroup>
      <Collapser
        id="extract-list-of-values"
        title="JSON 문자열 내의 값 목록 추출"
      >
        ```sql
        WITH '{"userResult1": 100, "userResult2": 200, "userResult3": 4}' as jsonString SELECT mapValues(jparse(jsonString)) AS values
        ```

        위의 쿼리는

        1. `jparse()` 함수를 사용하여 `jsonString` 속성 내의 JSON 문자열을 맵으로 역직렬화합니다.
        2. `mapValues()` 함수를 호출하여 이 맵 내의 모든 값 목록을 추출합니다.
        3. 이 값 목록을 `values` 속성에 바인딩합니다.

        위 쿼리를 실행하면 `values`에 `[100, 200, 4]` 목록이 포함됩니다.
      </Collapser>

      <Collapser
        id="extract-list-of-values-with-nested-values"
        title="중첩된 값이 있는 JSON 문자열에서 값 목록 추출"
      >
        ```sql
        WITH '{"value1": "test", "value2": {"nestedValue1": [1, 2, 3], "nestedValue2": 100}}' as jsonString SELECT mapValues(jparse(jsonString)) AS values
        ```

        위 쿼리는 `jsonString` 속성 내의 JSON 문자열에서 가장 바깥쪽 값을 추출합니다. 쿼리를 실행한 후 `values` `"test"` 문자열 및 중첩 개체 목록이 포함됩니다.

        이는 JSON 뷰에서 볼 수 있습니다.

        ```json
        "contents": [
          {
            "function": "alias",
            "alias": "values",
            "contents": {
              "constant": [
                "test",
                {
                  "nestedValue1": [
                    1,
                    2,
                    3
                  ],
                  "nestedValue2": 100
                }
              ]
           }
          }
        ],
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-minOf"
    title={<InlineCode>MinuteOf(속성), hourOf(속성) 등</InlineCode>}
  >
    `minuteOf()` 함수를 사용하여 유효한 타임스탬프 값을 보유하는 속성의 &amp;apos;분&amp;apos; 부분(0-59분)만 추출합니다. 이는 `hourOf()`, `weekOf()`과 같은 함수에도 적용됩니다. 시간 기반 함수의 전체 목록은 [시간 전반의 그룹 결과 문서](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-group-results-across-time/#cohorts)의 표를 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mod"
    title={<InlineCode>mod(attribute, divisor)</InlineCode>}
  >
    `mod()` 함수를 사용하여 제공된 숫자 속성 값(첫 번째 인수 또는 피제수)을 숫자 값(두 번째 인수 또는 제수)으로 나눈 후 하한 계수를 반환합니다. 이 모듈로 연산은 WHERE 조항 조건 내에서 결과의 임의 하위 집합으로 필터링하거나 FACET 조항 내에서 결과 집합을 세분화하는 방법으로 사용할 수 있습니다.

    <CollapserGroup>
      <Collapser title={<><InlineCode>
          mod()
        </InlineCode> <InlineCode>
          WHERE
        </InlineCode> 조항 조건 내에서</>}>
        ```sql
        FROM Transaction SELECT * WHERE mod(port, 2) = 1
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title={<><InlineCode>
          mod()
        </InlineCode> <InlineCode>
          FACET
        </InlineCode> 조항 내에서</>}>
        ```sql
        FROM NrConsumption SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-position"
    title={<InlineCode>position(str, substr [, occurrence])</InlineCode>}
  >
    문자열 내에서 하위 문자열의 위치를 찾으려면 `position()` 함수를 사용합니다. 매칭은 대소문자를 구분합니다.

    인수:

    * str - 하위 문자열을 찾을 문자열입니다.
      * 여기에는 따옴표로 묶인 리터럴 문자열, 쿼리된 문자열 속성, 문자열을 반환하는 함수 또는 단일 문자열 값을 반환하는 하위 쿼리 등 문자열로 평가되는 모든 것이 해당될 수 있습니다.

    * substr - str 내에서 검색할 문자열입니다.

    * occurrence - 위치를 반환할 substr의 어커런스를 나타냅니다.

      * _기본값:_ 0
      * 양수인 경우 0을 기준으로 str의 시작 부분에서 n번째 substr을 찾습니다.
      * 음수인 경우 str의 끝 부분에서 n번째 substr을 찾습니다. substr의 마지막 어커런스는 -1 어커런스입니다.

      별칭: <InlineCode>
      indexOf(str, substr \[, occurrence])
      </InlineCode> - `indexOf()`는 `position()` 함수의 다른 이름입니다.

      반환:

    * str 내의 substr 시작 문자의 0부터 시작하는 인덱스입니다.

    * str이 null이거나 substr이 null이거나 참조된 substr 발생을 찾을 수 없는 경우 Null이 반환됩니다.

      <CollapserGroup>
        <Collapser title="URL 내 하위 문자열의 위치 인덱스를 찾습니다.">
          이 쿼리는 <InlineCode>
          position()
          </InlineCode> 함수를 사용하여 문자열 내에서 다양한 하위 문자열의 위치 인덱스를 찾는 방법을 보여줍니다. 여기에서는 [<InlineCode>
          substring()
          </InlineCode>](#func-substring) 함수 인수 내에서 <InlineCode>
          position()
          </InlineCode> 함수를 사용하는 방법도 볼 수 있습니다.

          ```sql
          FROM PageView
          WITH position(pageUrl, ':') as FirstColon,
            position(pageUrl, '/', 1) + 1 as DomainBegin, position(pageUrl, '/', 2) as DomainEnd, DomainEnd - DomainBegin as DomainLength
          SELECT pageUrl, FirstColon, substring(pageUrl, 0, FirstColon) as Protocol,
            DomainBegin, DomainEnd, DomainLength, substring(pageUrl, DomainBegin, DomainLength) as Domain,
            position(pageUrl, '/', -1) as LastSlash, substring(pageUrl, position(pageUrl, '/', -1)) as PathEnd
          ```

          <img
            title="screenshot position()"
            alt="screenshot position()"
            src="/images/positionExample.webp"
          />

          <figcaption>
            <InlineCode>position(str, substr \[, occurrence])
            </InlineCode> 예
          </figcaption>
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="round"
    title={<InlineCode>round(attribute)</InlineCode>}
  >
    `round()` 함수를 사용하여 속성의 반올림된 값을 반환합니다.

    선택적으로 `round()`는 두 번째 인수 `to_nearest`를 사용하여 첫 번째 인수를 두 번째 인수의 가장 가까운 배수로 반올림할 수 있습니다. `to_nearest`는 소수일 수 있습니다.

    ```sql
    SELECT round(n [, to_nearest])
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="stddev"
    title={<InlineCode>stddev(attribute)</InlineCode>}
  >
    `stddev()` 함수를 사용하여 지정된 시간 범위에 걸쳐 숫자 속성에 대해 하나의 [표준 편차](https://en.wikipedia.org/wiki/Standard_deviation)를 반환합니다. 단일 인수가 필요합니다. 속성이 숫자가 아니면 0 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-string"
    title={<InlineCode>string(attribute [, precision: ])</InlineCode>}
  >
    `string()` 함수를 사용하여 숫자, 부울, 튜플 또는 배열 값을 문자열 값으로 변환합니다.

    두 개의 인수가 필요하며 하나는 선택 사항입니다.

    * Attribute name(속성 이름)
    * Precision: 있는 경우 부동 소수점 숫자 값을 변환할 때 포함되는 소수 자릿수에 대한 제한을 적용합니다.

      <CollapserGroup>
        <Collapser title="문자열이 아닌 쿼리 결과를 문자열 값으로 가져오기">
          이 쿼리는 PageView 기간을 소수점 이하 두 자리가 포함된 문자열로 반환합니다.

          ```sql
          FROM PageView SELECT string(duration, precision: 2)
          ```
        </Collapser>

        <Collapser title="문자열이 아닌 집계 함수 결과를 문자열 값으로 가져오기">
          이 쿼리는 PageView 기간의 평균을 소수점 이하 두 자리가 포함된 문자열로 반환합니다.

          ```sql
          FROM PageView SELECT string(average(duration), precision: 2)
          ```
        </Collapser>

        <Collapser title="버림(truncation) 없는 부동 소수점 숫자에 의한 패싯 쿼리 결과">
          `string()`을 사용하여 소수점 이하 자릿수를 버리지 않고 부동 소수점 값으로 패싯합니다.

          ```sql
          FROM PageView SELECT count(*) FACET string(tuple(asnLatitude, asnLongitude), precision: 2)
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-substring"
    title={<InlineCode>substring(str, start [, length])</InlineCode>}
  >
    `substring()` 함수를 사용하여 문자열의 일부를 추출합니다.

    인수:

    * str - 하위 문자열을 추출하는 문자열입니다.

      * 여기에는 따옴표로 묶인 리터럴 문자열, 쿼리된 문자열 속성, 문자열을 반환하는 함수 또는 단일 문자열 값을 반환하는 하위 쿼리 등 문자열로 평가되는 모든 것이 해당될 수 있습니다.
      * 이 인수가 null로 평가되면 `substring()` 함수는 null을 반환합니다.

    * start - 추출을 개시하는 str 내의 위치입니다.

      * str의 첫 번째 문자는 위치 0입니다.
      * 음수 값은 문자열의 마지막 문자가 위치 -1인 str의 끝을 기준으로 위치를 찾습니다.
      * start가 str의 길이보다 크거나 같으면 `substring()` 함수는 빈 문자열을 반환합니다.
      * start가 음수이고 절대값이 str의 길이보다 크면 추출된 하위 문자열은 위치 0에서 시작됩니다.

    * length - str에서 추출할 부분 문자열의 길이 또는 문자 수입니다.

      * _Optional_ - 길이가 제공되지 않으면 확인된 시작 위치 이후의 str에서 모든 문자가 포함됩니다.

      <CollapserGroup>
        <Collapser title="문자열의 다양한 부분 추출">
          이 쿼리는 세션 값의 일부를 반환합니다.

          ```sql
          FROM PageView
          SELECT session, substring(session, 0, 3) as First3,
            substring(session, 3) as After3rd,
            substring(session, -3) as Last3
          ```

          <img
            title="screenshot substring()"
            alt="screenshot substring()"
            src="/images/substringExample.webp"
          />

          <figcaption>
            <InlineCode>substring(str, start \[, length])
            </InlineCode> 예
          </figcaption>
        </Collapser>
      </CollapserGroup>

      _<InlineCode>substring()
      </InlineCode>과 <InlineCode>
      position()
      </InlineCode>을 함께 사용하는 예는 [<InlineCode>
      position()
      </InlineCode>](#func-position) 함수를 참조하십시오._
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-toDatetime"
    title={<InlineCode>toDatetime(timestamp[, pattern [, timezone]])</InlineCode>}
  >
    타임스탬프를 형식이 지정된 날짜/시간 문자열로 변환하려면 `toDatetime()` 함수를 사용합니다.

    `toDatetime()` 는 다음 인수를 사용합니다.

    * timestamp - 날짜/시간 문자열로 변환될 숫자 타임스탬프입니다. 이는 숫자 값이나 속성일 수 있으며 내부적으로 `long`으로 변환됩니다.
    * pattern - 결과 형식을 지정하는 데 사용되는 선택적 날짜/시간 패턴입니다. 패턴 문자열을 구성하는 _방법_은 [DatetimeFormatter 문서](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html)의 형식화 및 구문 분석을 위한 패턴 섹션을 참조하십시오.
      * 이는 상수 문자열 값이어야 하며 패턴이 제공되지 않으면 기본값은 `yyyy-MM-dd'T'HH:mm:ss.SSSXXX`입니다.
    * timezone - 날짜/시간 문자열(예: UTC)를 해석하는 데 사용되는 시간대값으로 선택 사항입니다.

      * 상수 문자열 값이어야 하며 기본값은 UTC이거나 가능한 경우 `WITH TIMEZONE`에 제공된 값입니다.

      입력이 유효한 숫자이면 `toDatetime()` 함수는 항상 값을 반환합니다.

      Alias: `fromTimestamp()` `toDatetime()` 함수의 대체 이름입니다.

      예:

      <CollapserGroup>
        <Collapser title="기본 패턴을 사용하여 타임스탬프 변환">
          다음 쿼리는 `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` 의 기본 패턴을 사용하여 `timestampValue` 속성을 변환합니다. 그러면 날짜/시간 문자열 `1970-01-01T00:20:34.567Z`이 반환됩니다.

          ```sql
          WITH 1234567 as timestampValue SELECT toDatetime(timestampValue)
          ```
        </Collapser>

        <Collapser title="timezone 매개변수를 사용하여 타임스탬프 번역">
          다음 쿼리는 시간대가 'America/Los_Angeles'로 설정된 패턴 문자열 `yyyy-MM-dd` 을 사용하여 `timestampValue` 속성을 변환합니다. 그러면 날짜/시간 문자열 `1969-12-31`이 반환됩니다.

          ```sql
          WITH 1234567 as timestampValue SELECT toDatetime(timestampValue, 'yyyy-MM-dd', timezone:'America/Los_Angeles')
          ```
        </Collapser>

        <Collapser title={<><InlineCode>
            WITH TIMEZONE
          </InlineCode> 절의 시간대를 사용하여 타임스탬프를 변환합니다.</>}>
          다음 쿼리는 `WITH TIMEZONE` 절에 제공된 시간대를 사용하여 `timestampValue` 속성을 변환합니다. 그러면 날짜/시간 문자열 `1969-12-31`이 반환됩니다.

          ```sql
          WITH 1234567 as timestampValue SELECT toDatetime(timestampValue, 'yyyy-MM-dd') FROM Event WITH TIMEZONE 'America/Los_Angeles'
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-toTimestamp"
    title={<InlineCode>toTimestamp(datestring[, pattern [, timezone]])</InlineCode>}
  >
    날짜/시간 문자열에서 에포크 밀리초 단위의 타임스탬프를 구문 분석하려면 `toTimestamp()` 함수를 사용합니다.

    `toTimestamp()` 는 다음 인수를 사용합니다.

    * datestring - 타임스탬프로 변환될 날짜/시간 문자열(epoch 밀리초)입니다. 문자열 속성이거나 따옴표로 묶인 문자열 리터럴일 수 있습니다.
    * pattern - 날짜 문자열 매개변수를 구문 분석하는 데 사용되는 선택적 날짜/시간 패턴입니다. 패턴 문자열을 구성하는 _방법_은 [DatetimeFormatter 문서](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html)의 형식화 및 구문 분석을 위한 패턴 섹션을 참조하십시오.
      * 상수 문자열 값이어야 하며 패턴이 제공되지 않으면 기본값은 `yyyy-MM-dd'T'HH:mm:ss[.SSS][XXX]`입니다.
    * timezone - 날짜 문자열 매개변수를 해석하는 데 사용되는 선택적 시간대 값입니다.(예: PST)

      * 상수 문자열 값이어야 하며 기본값은 UTC이거나 가능한 경우 `WITH TIMEZONE`에 제공된 값입니다.

      Alias: `fromDatetime()` `toTimestamp()` 함수의 대체 이름입니다.

      <Callout variant="tip">
        발견된 문자열이 주어진 패턴과 일치하지 않으면 `null`을 반환합니다. 다양한 패턴의 날짜/시간 문자열이 있는 경우 `OR`을 사용하여 값 중 하나가 null이 아닐 때까지 캐스케이드 방식으로 결과를 통합할 수 있습니다. 선택 사항인 패턴 세그먼트를 사용할 수도 있습니다. 기본 패턴은 대괄호를 사용하여 밀리초 및 영역 오프셋 부분을 선택 사항으로 만듭니다.
      </Callout>

      <CollapserGroup>
        <Collapser
          id="partial-datetime-interpretation"
          title="날짜/시간 문자열을 구문 분석할 때 부분적인 날짜/시간 해석"
        >
          <table>
            <thead>
              <tr>
                <th>
                  시나리오
                </th>

                <th>
                  세부 사항
                </th>

                <th>
                  샘플 패턴
                </th>

                <th>
                  샘플 날짜/시간
                </th>

                <th>
                  아래로 해결
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  시간대가 누락되었습니다.
                </td>

                <td>
                  시간대 인수 또는 WITH TIMEZONE 값을 사용합니다. 기본값은 UTC입니다.
                </td>

                <td>
                  yyyy-MM-dd HH:mm:ss.SSS
                </td>

                <td>
                  2023-10-18 15:27:03.123
                </td>

                <td>
                  2023-10-18T15:27:03.123Z
                </td>
              </tr>

              <tr>
                <td rowspan="8">
                  날짜/시간 필드가 누락되었습니다.
                </td>

                <td rowspan="8">
                  누락된 시간 필드는 0으로 대체됩니다. 누락된 날짜 필드는 1로 대체됩니다. 필드가 있는 경우 우선순위가 더 높은 필드도 모두 있어야 합니다.<br/> 참고: 연도별 날짜 및 분기 패턴이 지원됩니다.
                </td>

                <td>
                  yyyy-MM-dd HH:mm:ss
                </td>

                <td>
                  2023-10-18 15:27:03
                </td>

                <td>
                  2023-10-18T15:27:03.000Z
                </td>
              </tr>

              <tr>
                <td>
                  yyyy-MM-dd HH:mm
                </td>

                <td>
                  2023-10-18 15:27
                </td>

                <td>
                  2023-10-18T15:27:00.000Z
                </td>
              </tr>

              <tr>
                <td>
                  yyyy-MM-dd HH
                </td>

                <td>
                  2023-10-18 15
                </td>

                <td>
                  2023-10-18T15:00:00.000Z
                </td>
              </tr>

              <tr>
                <td>
                  yyyy-MM-dd
                </td>

                <td>
                  2023-10-18
                </td>

                <td>
                  2023-10-18T00:00:00.000Z
                </td>
              </tr>

              <tr>
                <td>
                  yyyy 'day' D
                </td>

                <td>
                  2023 day 291
                </td>

                <td>
                  2023-10-18T00:00:00.000Z
                </td>
              </tr>

              <tr>
                <td>
                  yyyy-MM
                </td>

                <td>
                  2023-10
                </td>

                <td>
                  2023-10-01T00:00:00.000Z
                </td>
              </tr>

              <tr>
                <td>
                  yyyyqqq
                </td>

                <td>
                  2023 Q4
                </td>

                <td>
                  2023-10-01T00:00:00.000Z
                </td>
              </tr>

              <tr>
                <td>
                  yyyy
                </td>

                <td>
                  2023
                </td>

                <td>
                  2023-01-01T00:00:00.000Z
                </td>
              </tr>

              <tr>
                <td rowspan="3">
                  Time only
                </td>

                <td rowspan="3">
                  날짜 없이 시간 패턴을 사용하는 경우 Unix 타임스탬프(밀리초)가 계산됩니다.<br/> 참고: 시간대 조정은 여전히 적용됩니다.
                </td>

                <td>
                  HH:mm
                </td>

                <td>
                  00:30
                </td>

                <td>
                  1971-01-01T00:30:00.000Z
                </td>
              </tr>

              <tr>
                <td>
                  HH:mm O
                </td>

                <td>
                  00:30 GMT-1
                </td>

                <td>
                  1971-01-01T01:30:00.000Z
                </td>
              </tr>

              <tr>
                <td>
                  HH:mm O
                </td>

                <td>
                  00:30 GMT+1
                </td>

                <td>
                  1969-12-31T23:30:00.000Z
                </td>
              </tr>

              <tr>
                <td rowspan="3">
                  12 hour time
                </td>

                <td rowspan="3">
                  12시간 패턴(소문자 h)을 사용하는 경우 오전-오후 패턴(a)도 사용해야 합니다.

                  <br/>

                  참고: 날짜/시간 문자열 내에서는 AM/PM이 대문자여야 합니다.
                </td>

                <td>
                  yyyy-MM-dd h:mm a
                </td>

                <td>
                  2023-10-18 3:27 PM
                </td>

                <td>
                  2023-10-18T15:27:00.000Z
                </td>
              </tr>

              <tr>
                <td>
                  yyyy-MM-dd h:mm
                </td>

                <td>
                  2023-10-18 3:27
                </td>

                <td>
                  지원되지 않는 패턴
                </td>
              </tr>

              <tr>
                <td>
                  yyyy-MM-dd h:mm a
                </td>

                <td>
                  2023-10-18 3:27 pm
                </td>

                <td>
                  null(소문자 pm으로 인해)
                </td>
              </tr>

              <tr>
                <td>
                  Field precedence
                </td>

                <td>
                  If a field is present, all higher precedence fields must also be present.
                </td>

                <td>
                  yyyy dd
                </td>

                <td>
                  2023 18
                </td>

                <td>
                  지원되지 않는 패턴(dd는 날짜이고 월은 누락됨)
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>
      </CollapserGroup>

      예:

      <CollapserGroup>
        <Collapser title="기본 패턴을 사용하여 날짜/시간 문자열 구문 분석">
          다음 쿼리는 `yyyy-MM-dd'T'HH:mm:ss[.SSS][XXX]`의 기본 패턴을 사용하여 날짜/시간 문자열 &amp;apos;2023-10-18T15:27:03.123Z&amp;apos;를 구문 분석합니다. 이는 타임스탬프 값 `1697642823123`을 반환합니다.

          ```sql
          SELECT toTimestamp('2023-10-18T15:27:03.123Z') FROM Event
          ```
        </Collapser>

        <Collapser title="timezone 매개변수를 사용하여 날짜/시간 문자열 구문 분석">
          다음 쿼리는 시간대가 'America/Los_Angeles'로 설정된 날짜/시간 문자열 '2023-11-03 11:00:32'를 구문 분석합니다. 이는 타임스탬프 값 `1699034432000`을 반환합니다.

          ```sql
          SELECT toTimestamp('2023-11-03 11:00:32', 'yyyy-MM-dd HH:mm:ss', timezone:'America/Los_Angeles') FROM Event
          ```
        </Collapser>

        <Collapser title={<><InlineCode>
            WITH TIMEZONE
          </InlineCode> 절의 시간대를 사용하여 날짜/시간 문자열을 구문 분석합니다.</>}>
          다음 쿼리는 `WITH TIMEZONE` 절에 제공된 시간대를 사용하여 날짜/시간 문자열 &amp;apos;2023-11-03 11:00:32&amp;apos;를 구문 분석합니다. 이는 타임스탬프 값 `1699034432000`을 반환합니다.

          ```sql
          SELECT toTimestamp('2023-11-03 11:00:32', 'yyyy-MM-dd HH:mm:ss') FROM Event WITH TIMEZONE 'America/Los_Angeles'
          ```
        </Collapser>
      </CollapserGroup>

      <Callout variant="important">
        UI는 자동으로 `toTimestamp()` 값을 타임스탬프로 감지하고 날짜/시간 값으로 형식을 지정합니다. 실제 숫자 타임스탬프를 표시하려면 `toTimestamp()` 함수를 `string()` 함수로 래핑합니다.
      </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-upper"
    title={<InlineCode>upper(str)</InlineCode>}
  >
    `upper()` 함수를 사용하여 문자열 값의 모든 알파벳 문자를 대문자로 변경합니다.

    인수:

    * str - 대문자가 되어야 하는 문자열 값입니다.
    * 여기에는 따옴표로 묶인 리터럴 문자열, 쿼리된 문자열 속성, 문자열을 반환하는 함수 또는 단일 문자열 값을 반환하는 하위 쿼리 등 문자열로 평가되는 모든 것이 해당될 수 있습니다.
    * 이 인수가 null로 평가되면 `upper()` 함수는 null을 반환합니다.

      <CollapserGroup>
        <Collapser title="Upper-case a string">
          이 쿼리는 쿼리의 다양한 부분에서 `upper()` 함수를 사용하는 방법을 보여줍니다.

          ```sql
          FROM PageAction
          SELECT latest(upper(actionName))
          WHERE upper(actionName) = upper('acmePageRenderedEvent') OR upper(actionName) = upper('SubmitLogin')
          FACET concat(actionName, ':', upper(actionName))
          ```

          <img
            title="screenshot upper()"
            alt="screenshot upper()"
            src="/images/upperExample.webp"
          />

          <figcaption>
            <InlineCode>upper(str)
            </InlineCode> 예
          </figcaption>
        </Collapser>
      </CollapserGroup>

      _관련 함수: [<InlineCode>
      lower()</InlineCode>](#func-lower)_
  </Collapser>
</CollapserGroup>

## 유형 변환 [#type-conversion]

NRQL은 "강제"를 지원하지 않습니다. 즉, 문자열로 저장된 부동 소수점은 문자열로 취급되며 부동 소수점 값을 기대하는 함수에서 작동할 수 없습니다.

다음 함수를 사용하여 숫자 값이 있는 문자열 또는 문자열 값이 있는 부울을 해당 숫자 및 부울 값으로 변환하거나 문자열이 아닌 값을 문자열 값으로 변환할 수 있습니다.

* `numeric()` 함수를 사용하여 문자열 형식의 숫자를 숫자 값으로 변환합니다. 이 함수는 쿼리 결과에 수학 함수를 사용하는 쿼리 또는 `average()` 같은 NRQL 집계 함수에 내장될 수 있습니다.
* `boolean()` 함수를 사용하여 `"true"` 또는 `"false"`의 문자열 값을 해당 부울 값으로 변환합니다.
* `string()` 함수를 사용하여 숫자, 부울, 튜플 또는 배열 값을 문자열 값으로 변환합니다. 보다 자세한 내용은 [`string()`](#func-string) 상단의 설명을 참조하십시오.

## 코멘트 [#comments]

NRQL 쿼리를 작성할 때 팀 구성원이 쿼리를 더 잘 이해하고 사용하는 데 도움이 될 수 있도록 주석을 추가할 수 있습니다.

구문 세부 정보는 다음과 같습니다.

* `--` 두 개의 대시는 같은 줄에서 이 표시기 오른쪽에 있는 모든 텍스트를 주석 처리합니다.
* `//` 두 개의 슬래시는 같은 줄에서 이 표시기 오른쪽에 있는 모든 텍스트를 주석 처리합니다.
* `/* */` 이 문자 집합 사이에 있는 모든 텍스트는 주석 처리됩니다. 이 표시기는 여러 줄에 적용될 수 있습니다.

주석이 모든 곳에 표시되는 것은 아니라는 데 주의하십시오. '최근 쿼리' 및 '쿼리 보기' 같은 일부 뷰에는 주석이 표시되지 않습니다.

주석을 포함하는 몇 가지 쿼리의 예:

```sql
FROM Transaction SELECT uniqueCount(appId) -- This will return the number of unique App IDs
```

```sql
FROM TransactionError
SELECT count(*) SINCE 1 day ago // Transaction Error for the past day
```

```sql
FROM TransactionTrace /* This data may be incomplete;
If so, run a query of Transaction */
SELECT count(*)
```

## 관련 문서 [#related-docs]

NRQL 구문 및 규칙에 대한 정보를 제공하는 다른 자료들을 확인해 보십시오.

* New Relic University [NRQL 교육 과정](https://learn.newrelic.com/writing-nrql-queries)
* [`Metric` 데이터 유형을 쿼리하는 방법 알아보기](/docs/telemetry-data-platform/get-data/apis/query-metric-data-type)
* [하위 쿼리 사용 방법](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql)
* [퍼널을 사용하여 일련의 관련 데이터 평가](/docs/insights/new-relic-insights/features/funnels)
