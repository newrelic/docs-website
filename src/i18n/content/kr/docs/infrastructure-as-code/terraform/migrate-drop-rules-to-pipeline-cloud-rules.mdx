---
title: 삭제 규칙에서 Pipeline cloud 규칙으로 마이그레이션
tags:
  - Data Management
  - Migration
  - Drop Rules
  - Pipeline Control
  - Terraform
  - GitOps
metaDescription: Migrate your NRQL drop rules to Pipeline cloud rules using Terraform with GitOps (CI/CD) or on your local machine.
freshnessValidatedDate: never
translationType: machine
---

<Callout variant="important">
  As of May 21, 2025, new customers can no longer use NRQL drop rules. [NRQL drop rules will be end-of-life](/eol/2025/05/drop-rule-filter) on June 30, 2026.

  데이터 드로핑 규칙을 계속 관리하려면 [Pipeline cloud 규칙](/docs/new-relic-control/pipeline-control/cloud-rules-api) 으로 마이그레이션하세요.
</Callout>

[`newrelic_nrql_drop_rule`](https://registry.terraform.io/providers/newrelic/newrelic/latest/docs/resources/nrql_drop_rule) 리소스를 사용하여 Terraform을 통해 NRQL 삭제 규칙을 관리하는 경우 이를 [`newrelic_pipeline_cloud_rule`](https://registry.terraform.io/providers/newrelic/newrelic/latest/docs/resources/pipeline_cloud_rule) 리소스로 마이그레이션해야 합니다. 뉴렐릭은 이미 기본 삭제 규칙을 마이그레이션했지만 Terraform은 자체 상태 파일을 유지 관리하며 명시적으로 구성한 리소스에 대해서만 알고 있습니다. Terraform에서는 이 두 가지를 완전히 다른 리소스 유형으로 처리하므로 Pipeline cloud 규칙을 Terraform의 상태로 가져와서 이전의 삭제 규칙 리소스를 제거해야 합니다.

## 이주 접근 방식 [#migration-approaches]

이 가이드에서는 Terraform에서 NRQL 삭제 규칙을 Pipeline cloud 규칙으로 마이그레이션하는 두 가지 방법을 다룹니다.

* 기본 Terraform 명령: `terraform import`, `terraform plan` 및 `terraform state rm` 명령을 사용하는 표준 Terraform 스텔라우.

* 뉴렐릭 CLI 자동화 도구: 뉴렐릭은 두 가지 버전으로 제공되는 기본 Terraform을 자동화하는 CLI 도구를 제공합니다.

  * GitOps(연속 통합/연속 배포(CI/CD)): Terraform 상태가 작업 영역(일반적으로 원격 백앤드에 저장됨)에서 직접 액세스할 수 없는 연속 통합/연속 배포(CI/CD) 도구를 사용하는 팀을 위한 것입니다.
  * 로컬 Terraform: 로컬이든 원격이든 Terraform 상태 파일을 직접 읽을 수 있는 Terraform 명령을 실행하는 팀용입니다.

뉴렐릭의 자동화 도구를 사용하면 수동 작업과 오류 발생 가능성이 크게 줄어들기 때문에 이를 사용하는 것이 좋습니다. 하지만 완전한 제어를 선호하거나 특정 요구 사항이 있는 경우 기본 Terraform 명령 방식을 따를 수 있습니다.

## 기본 Terraform 명령으로 마이그레이션 [#native-terraform]

이 섹션에서는 기본 Terraform 명령을 사용하여 `newrelic_nrql_drop_rule` 리소스에서 `newrelic_pipeline_cloud_rule` 리소스로 마이그레이션하기 위한 표준 Terraform 에 대해 설명합니다. 이 섹션의 모든 명령은 삭제 규칙 설정이 있는 Terraform 작업 디렉터리에서 실행해야 합니다.

### 전제 조건 [#native-prerequisites]

* **Terraform 또는 OpenTofu v1.5 이상:** 이 버전에서는 `import` 블록 기능이 도입되어 리소스 설정을 수동으로 작성할 필요가 없어 마이그레이션 프로세스의 효율성이 높아졌습니다.
* **뉴렐릭 Terraform Provider v3.73.0 이상:** 이 권장 버전은 `newrelic_pipeline_cloud_rule` 리소스와 `newrelic_nrql_drop_rule` 리소스의 `pipeline_cloud_rule_entity_id` 속성을 사용하여 Terraform을 통해 Pipeline cloud 규칙을 관리하기 위한 지원을 확장합니다(2025년 9월에 출시된 v3.68.0에 추가됨). 원활한 마이그레이션 프로세스를 보장하기 위한 중요한 버그 수정이 포함되어 있습니다.

### 마이그레이션 단계 [#native-steps]

<Steps>
  <Step>
    #### Pipeline cloud 규칙 ID 가져오기 [#get-pipeline-cloud-rule-ids]

    Terraform 작업 디렉토리에서 새로운 Terraform Provider를 v3.73.0 이상으로 업그레이드한 다음 `terraform apply` 실행하여 기존 `newrelic_nrql_drop_rule` 리소스를 업데이트합니다. 이 작업은 해당 Pipeline cloud 규칙의 ID를 포함하는 `pipeline_cloud_rule_entity_id` 속성을 추가하여 Terraform 상태를 업데이트합니다. 이 규칙은 자동으로 생성됩니다.

    <Callout title="메모">
      더 안전한 작업을 위해 인프라를 변경하지 않고 상태를 업데이트하려면 `-refresh-only` 플래그를 사용하거나, 특정 삭제 규칙 리소스에 대한 작업을 제한하려면 `-target` 사용합니다.
    </Callout>

    Terraform 작업 디렉토리로 이동하여 다음 명령 중 하나를 실행합니다.

    ```bash
    # Apply to update state with pipeline_cloud_rule_entity_id
    terraform apply

    # Safer: use refresh-only to see changes without modifying infrastructure
    terraform apply -refresh-only

    # Targeted: limit operation to specific drop rule resources
    terraform apply -refresh-only -target=newrelic_nrql_drop_rule.foo
    ```

    위 명령 중 하나를 실행하면 각 삭제 규칙에 대해 해당 상태에서 `pipeline_cloud_rule_entity_id` 을 사용할 수 있습니다. 다음 단계를 위해 신분증을 잘 보관하세요.

    ```hcl
    # Example: Get the Pipeline cloud rule ID for a drop rule
    newrelic_nrql_drop_rule.foo.pipeline_cloud_rule_entity_id
    ```
  </Step>

  <Step>
    #### Pipeline cloud 규칙을 Terraform 상태로 가져오기 [#import-pipeline-cloud-rules]

    Terraform 작업 디렉토리에 새 `.tf` 파일(예: `import_pipeline_rules.tf`)을 만듭니다. 이 파일에서 마이그레이션하려는 각 삭제 규칙에 대한 가져오기 블록을 추가합니다. 이전 단계의 `pipeline_cloud_rule_entity_id` 값을 사용합니다.

    ```hcl
    # import_pipeline_rules.tf
    # Create import block using the pipeline_cloud_rule_entity_id from state
    import {
      to = newrelic_pipeline_cloud_rule.foo
      # Reference the ID from the drop rule resource
      id = newrelic_nrql_drop_rule.foo.pipeline_cloud_rule_entity_id

      # Or use the actual value from your state
      # id = "MzgwNjUyNnxOR0VQfFBJUEVMSU5FX0NMT1VEX1JVTEV8MDE5OTRjZjgtYmFmNy03MjU3LWE3M2MtZWY5OTkxYTQxMjgy"
    }
    ```

    그런 다음 Terraform 작업 디렉토리에서 Terraform 명령을 실행하여 설정을 생성하고 가져옵니다.

    ```bash
    # Generate Pipeline cloud rule configuration automatically
    terraform plan -generate-config-out=generated_pipeline_rules.tf

    # Apply to import the Pipeline cloud rules
    terraform apply
    ```
  </Step>

  <Step>
    #### Terraform 상태에서 이전 삭제 규칙 리소스를 제거합니다. [#remove-old-drop-rules]

    Pipeline cloud 규칙을 성공적으로 가져온 후 `terraform state rm` 명령을 사용하여 Terraform 상태에서 `newrelic_nrql_drop_rule` 리소스에 대한 모든 참조를 제거해야 합니다.

    ```bash
    terraform state rm newrelic_nrql_drop_rule.foo
    ```

    이렇게 하면 삭제 규칙이 뉴렐릭에서 삭제되지 않고 Terraform 상태에서 제거됩니다.

    <Callout variant="tip">
      Terraform의 [`removed` 블록](https://developer.hashicorp.com/terraform/language/block/removed) ( **Terraform v1.7 이상** 에서 사용 가능)을 사용하여 설정 파일 내에서 선언적으로 리소스를 상태에서 제거할 수도 있습니다.
    </Callout>
  </Step>

  <Step>
    #### Terraform 설정 정리 [#clean-up-terraform-configuration]

    Terraform 상태에서 삭제 규칙을 제거한 후에는 Terraform 설정 파일에서 모든 `newrelic_nrql_drop_rule` 리소스 블록을 주석화하고 이러한 삭제 규칙에 종속된 모든 보조 리소스를 제거해야 합니다.

    그런 다음 `terraform plan` 실행하여 마이그레이션을 확인합니다.

    ```bash
    terraform plan
    ```

    마이그레이션이 성공적이면 출력에 &quot;변경 사항 없음&quot;이 표시됩니다.
  </Step>
</Steps>

## 뉴렐릭의 자동화 도구로 마이그레이션하세요 [#automation-tools]

위에서 설명한 기본 Terraform 마이그레이션을 간소화하기 위해 스텔릭은 가져오기 및 상태 관리를 처리하는 CLI 자동화 도구를 제공합니다. 이러한 도구는 동일한 기본 Terraform 작업(가져오기, 계획, 적용 및 상태 제거)을 자동화하지만 수동 작업은 훨씬 줄어듭니다.

### 전제 조건 [#automation-prerequisites]

* **Terraform 또는 OpenTofu v1.5 이상:** 자동화된 마이그레이션 방식에 필요합니다.

* **뉴렐릭 Terraform Provider v3.73.0 이상:** 이 권장 버전은 `newrelic_pipeline_cloud_rule` 리소스와 `newrelic_nrql_drop_rule` 리소스의 `pipeline_cloud_rule_entity_id` 속성을 사용하여 Terraform을 통해 Pipeline cloud 규칙을 관리하기 위한 지원을 확장합니다(2025년 9월에 출시된 v3.68.0에 추가됨). 원활한 마이그레이션 프로세스를 보장하기 위한 중요한 버그 수정이 포함되어 있습니다.

* **뉴렐릭 CLI:** 자동화된 마이그레이션 명령을 실행하는 데 필요합니다.

* **환경 변수:**

  * `NEW_RELIC_API_KEY` - 적절한 권한이 있는 귀하의 뉴렐릭 사용자 API 키.
  * `NEW_RELIC_ACCOUNT_ID` - 귀하의 드롭 규칙이 있는 귀하의 뉴렐릭 계정 ID입니다.
  * `NEW_RELIC_REGION` (선택 사항) - 계정 지역에 따라 &apos;US&apos; 또는 &apos;EU&apos;로 설정합니다(기본값은 &apos;US&apos;).

### 접근 방식을 선택하세요 [#choose-approach]

<CollapserGroup>
  <Collapser id="gitops-cicd" title="GitOps 사용하기 (연속 통합/연속 배포(CI/CD))">
    GitOps 자동화 프로세스는 상태 파일에 쉽게 액세스할 수 없는 연속 통합/연속 배포(CI/CD) 환경을 위해 설계된 3단계 접근 방식을 사용합니다. 이 단계에서는 새로운 Pipeline 클라우드 규칙 ID의 안전한 추출, 설정 파일 생성, 파이프라인 내 상태 가져오기 및 정리가 보장됩니다.

    <CollapserGroup>
      <Collapser id="gitops-step1" title="1단계: 연속 통합/연속 배포(CI/CD)에서 삭제 규칙 식별 및 내보내기">
        이 단계에서는 기존 삭제 규칙을 식별하고 매핑을 구조화된 JSON 데이터로 내보내는 연속 통합/연속 배포(CI/CD) Terraform 설정에 유효성 검사 확장을 추가합니다.

        <Callout variant="important">
          이 절차는 한 번에 하나의 작업 공간(한 번에 하나의 Terraform 상태 파일)에 적용됩니다. 삭제 규칙이 적용된 작업 공간이 여러 개 있는 경우 각 작업 공간에 대해 이 프로세스를 반복합니다.
        </Callout>

        <Steps>
          <Step>
            #### 검증 스크립트를 다운로드하고 추가하세요 [#add-validation-script]

            [뉴렐릭 Terraform 제공자 GitHub](https://github.com/newrelic/terraform-provider-newrelic/blob/main/examples/drop_rule_migration_ci/outputs.tf) 에서 `outputs.tf` 파일을 다운로드하고 연속 통합/연속 배포(CI/CD) Terraform 작업공간에 추가하세요.

            이 스크립트는 삭제 규칙 리소스에 대한 검증 및 추출 시스템을 제공하고, 마이그레이션 절차에서 사용할 수 있도록 JSON 형식으로 ID를 출력합니다.
          </Step>

          <Step>
            #### 삭제 규칙 유형에 대한 스크립트 구성 [#configure-drop-rule-types]

            스크립트는 두 가지 유형의 삭제 규칙을 지원합니다.

            * **독립형 삭제 규칙**: `newrelic_nrql_drop_rule` 리소스는 설정에서 직접 정의됨(모듈에 래핑되지 않음)
            * **모듈식 삭제 규칙**: Terraform 모듈 내부에 래핑된 `newrelic_nrql_drop_rule` 리소스

            방금 추가한 `outputs.tf` 파일에서 `locals` 블록에 적절한 플래그를 설정하여 삭제 규칙 유형에 대한 처리를 활성화합니다.

            ```hcl
            locals {
              # Enable for standalone drop rules
              enable_standalone_drop_rules = true

              # Enable for modular drop rules
              enable_modular_drop_rules = false
            }
            ```

            독립 실행형 삭제 규칙이 있는 경우 `enable_standalone_drop_rules` `true` 로 설정합니다. 모듈식 삭제 규칙이 있는 경우 `enable_modular_drop_rules` `true` 으로 설정합니다. 두 유형이 모두 있는 경우 둘 다 활성화할 수 있습니다.
          </Step>

          <Step>
            #### 독립형 삭제 규칙을 추가합니다(해당되는 경우) [#add-standalone-rules]

            독립 실행형 삭제 규칙이 있고 이전 단계에서 해당 규칙을 활성화한 경우 Terraform 설정에서 모든 독립 실행형 `newrelic_nrql_drop_rule` 리소스를 식별합니다.

            예를 들어, Terraform 설정에 다음과 같은 독립형 삭제 규칙이 있는 경우:

            ```hcl
            resource "newrelic_nrql_drop_rule" "drop_debug_logs" {
              account_id  = var.new_relic_account_id
              description = "Filters out debug level logs"
              action      = "drop_data"
              nrql        = "SELECT * FROM Log WHERE level = 'debug'"
            }

            resource "newrelic_nrql_drop_rule" "drop_health_checks" {
              account_id  = var.new_relic_account_id
              description = "Removes health check logs"
              action      = "drop_data"
              nrql        = "SELECT * FROM Log WHERE endpoint = '/health'"
            }

            resource "newrelic_nrql_drop_rule" "drop_pii_data" {
              account_id  = var.new_relic_account_id
              description = "Filters out PII data"
              action      = "drop_data"
              nrql        = "SELECT * FROM Log WHERE contains(message, 'SSN')"
            }
            ```

            각 리소스에 대해 리소스 식별자와 전체 리소스 참조를 기록해야 합니다. 예를 들어 리소스 `newrelic_nrql_drop_rule.drop_debug_logs` 에서:

            * 리소스 식별자는 `drop_debug_logs`
            * 전체 리소스 참조는 다음과 같습니다. `newrelic_nrql_drop_rule.drop_debug_logs`

            `outputs.tf` 파일에서 지정된 독립 실행형 삭제 규칙 섹션의 `standalone_rules` 목록에 다음 리소스를 추가합니다.

            ```hcl
            # Configure standalone drop rules here
            standalone_rules = local.enable_standalone_drop_rules ? [
              {
                name     = "drop_debug_logs"
                resource = newrelic_nrql_drop_rule.drop_debug_logs
              },
              {
                name     = "drop_health_checks"
                resource = newrelic_nrql_drop_rule.drop_health_checks
              },
              {
                name     = "drop_pii_data"
                resource = newrelic_nrql_drop_rule.drop_pii_data
              }
            ] : []
            ```

            <Callout title="메모">
              `name` 필드는 리소스 식별자와 일치해야 하고, `resource` 필드는 전체 리소스 참조와 일치해야 합니다. `count` 또는 `for_each` 메타 인수를 사용하여 생성된 삭제 규칙 리소스의 경우 리소스 식별자(예: `newrelic_nrql_drop_rule.drop_health_checks[0]` 또는 `newrelic_nrql_drop_rule.drop_health_checks["key_1"]`)를 명시적으로 인덱싱합니다. 연속 통합/연속 배포(CI/CD) 환경에서 상태 액세스 권한이 있는 경우 이 bash 명령을 사용하여 목록 형식을 자동으로 생성할 수 있습니다(실험적이며 특정 상태 구조에 따라 조정이 필요할 수 있음).

              ```bash
              terraform state list | \
                grep 'newrelic_nrql_drop_rule' | \
                grep -v '^module\.' | \
                sed -E \
                  -e '/\.([^[]+)\["/ s/^.*\.([^[]+)\["([^"]+)"\].*$/  {\n    name     = "\1_\2"\n    resource = &\n  },/' \
                  -e 't' \
                  -e '/\.([^[]+)\[[0-9]/ s/^.*\.([^[]+)\[([0-9]+)\].*$/  {\n    name     = "\1_\2"\n    resource = &\n  },/' \
                  -e 't' \
                  -e 's/^.*\.([^ ]+)$/  {\n    name     = "\1"\n    resource = &\n  },/'
              ```

              `terraform` 명령을 Terraform 래퍼나 GitOps 도구와 동등한 것으로 바꿔야 할 수도 있습니다.
            </Callout>
          </Step>

          <Step>
            #### 모듈식 드롭 규칙을 추가합니다(해당되는 경우) [#add-modular-rules]

            모듈식 삭제 규칙이 있고 2단계에서 이를 활성화한 경우 스크립트에 추가하기 전에 모듈이 `all_rules` 속성을 내보내는지 확인해야 합니다.

            **필수 조건**: 모듈은 모듈에서 관리하는 모든 `newrelic_nrql_drop_rule` 리소스에 대한 참조를 보유하는 속성 `all_rules` 을 내보내야 합니다.

            {/* 예를 들어, 모듈에 동일한 세 개의 삭제 규칙 리소스가 포함되어 있는 경우: ```hcl resource &quot;newrelic_nrql_drop_rule&quot; &quot;drop_debug_logs&quot; { account_id = var.new_relic_account_id 설명 = &quot;디버그 수준 로그 필터링&quot; 작업 = &quot;drop_data&quot; NRQL = &quot;SELECT * FROM 로그 WHERE level = &apos;debug&apos;&quot; } 리소스 &quot;newrelic_nrql_drop_rule&quot; &quot;drop_health_checks&quot; { account_id = var.new_relic_account_id 설명 = &quot;상태 확인 로그 제거&quot; 작업 = &quot;drop_data&quot; NRQL = &quot;SELECT * FROM 로그 WHERE = &apos;/health&apos;&quot; } 리소스 &quot;newrelic_nrql_drop_rule&quot; &quot;drop_pii_data&quot; { account_id = var.new_relic_account_id 설명 = &quot;PII 데이터 필터링&quot; 작업 = &quot;drop_data&quot; NRQL = &quot;SELECT * FROM 로그 WHERE contains(message, &apos;SSN&apos;)&quot; } ``` */}

            위 단계에서 설명한 것과 동일한 세 가지 삭제 규칙이 있는 경우 다음 출력을 모듈에 추가하세요.

            ```hcl
            output "all_rules" {
              description = "A map of all drop rule resource objects created by this module."
              value = {
                debug_logs    = newrelic_nrql_drop_rule.drop_debug_logs
                health_checks = newrelic_nrql_drop_rule.drop_health_checks
                pii_data      = newrelic_nrql_drop_rule.drop_pii_data
              }
            }
            ```

            그런 다음 `outputs.tf` 파일에서 지정된 모듈식 삭제 규칙 섹션의 `_modular_rules_raw` 목록에 모듈을 추가합니다.

            ```hcl
            # Configure modular drop rules here
            _modular_rules_raw = local.enable_modular_drop_rules ? [
              {
                name     = "production_drop_rules"
                resource = module.drop_rules["production_drop_rules"].all_rules
              }
            ] : []
            ```

            <Callout title="메모">
              연속 통합/연속 배포(CI/CD) 환경에서 상태 액세스 권한이 있는 경우 이 bash 명령을 사용하여 모듈식 규칙에 대한 목록 형식을 자동으로 생성할 수 있습니다(실험적이며 상태 구조에 따라 조정이 필요할 수 있음).

              ```bash
              terraform state list | \
                grep '^module\..*newrelic_nrql_drop_rule' | \
                sed -E 's/(\.newrelic_nrql_drop_rule.*)//' | \
                sort -u | \
                sed -E 's/^module\.([^[]+)\["([^"]+)"\]$/  {\n    name     = "\2"\n    resource = module.\1\["\2"].all_rules\n  },/'
              ```

              `terraform` 명령을 Terraform 래퍼나 GitOps 도구와 동등한 것으로 바꿔야 할 수도 있습니다.
            </Callout>
          </Step>

          <Step>
            #### Terraform Plan 실행 [#run-terraform-plan]

            통합 연속/연속 배포(CI/CD) 환경에서 다음을 실행합니다.

            ```bash
            terraform plan
            ```

            계획이 성공하면 출력에 성공 메시지가 표시됩니다.

            ```
            Changes to Outputs:
              + a_validation_success = "✅ All listed resources export pipeline_cloud_rule_entity_id"
            ```

            이는 모든 삭제 규칙 리소스가 올바르게 구성되었으며 `pipeline_cloud_rule_entity_id` 속성을 내보냈음을 확인합니다. 이제 `terraform apply` 실행할 수 있습니다.

            다음과 같은 검증 오류가 표시되는 경우:

            ```
            Changes to Outputs:
              + validation_errors = [
                  + "❌ Drop rule 'drop_debug_logs' does not export `pipeline_cloud_rule_entity_id` or it is null",
                  + "❌ Drop rule 'drop_health_checks' does not export `pipeline_cloud_rule_entity_id` or it is null",
                  + "❌ Drop rule 'drop_pii_data' does not export `pipeline_cloud_rule_entity_id` or it is null",
                ]
            ```

            즉, 현재 Terraform Provider &gt;= v3.73.0 버전을 사용하고 있지 않습니다. Terraform 설정에서 공급자 버전을 v3.73.0 이상으로 업그레이드한 다음 `terraform plan` 다시 실행하세요.
          </Step>

          <Step>
            #### Terraform Apply를 실행합니다. [#run-terraform-apply]

            계획 출력에 성공 메시지가 표시되는지 확인한 후 다음을 실행합니다.

            ```bash
            terraform apply
            ```

            적용이 성공적으로 완료되면 다음과 같은 출력이 표시됩니다.

            ```
            Apply complete! Resources: 0 added, 0 changed, 0 destroyed.

            Outputs:

            a_validation_success = "✅ All listed resources export pipeline_cloud_rule_entity_id"
            experimental_drop_rule_resource_ids = "{\"drop_rule_resource_ids\":[{\"id\":\"3806526:106878882\",\"name\":\"drop_debug_logs\",\"pipeline_cloud_rule_entity_id\":\"MzgwNjUyNnxORVVMS...\"},{\"id\":\"3806526:106878883\",\"name\":\"drop_health_checks\",\"pipeline_cloud_rule_entity_id\":\"MzgwNjUyNnxORVVMS...\"},{\"id\":\"3806526:106878884\",\"name\":\"drop_pii_data\",\"pipeline_cloud_rule_entity_id\":\"MzgwNjUyNnxORVVMS...\"}]}"
            experimental_drop_rule_resource_ids_formatted = <<EOT
            {
              "drop_rule_resource_ids": [
                {
                  "name": "drop_debug_logs",
                  "id": "3806526:106878882",
                  "pipeline_cloud_rule_entity_id": "MzgwNjUyNnxORVVMS..."
                },
                {
                  "name": "drop_health_checks",
                  "id": "3806526:106878883",
                  "pipeline_cloud_rule_entity_id": "MzgwNjUyNnxORVVMS..."
                },
                {
                  "name": "drop_pii_data",
                  "id": "3806526:106878884",
                  "pipeline_cloud_rule_entity_id": "MzgwNjUyNnxORVVMS..."
                }
              ]
            }
            EOT
            ```
          </Step>

          <Step>
            #### JSON 출력을 복사합니다 [#copy-json-output]

            `experimental_drop_rule_resource_ids_formatted` 출력에서 전체 JSON 문자열을 복사합니다. 2단계에서는 이게 필요합니다.
          </Step>
        </Steps>
      </Collapser>

      <Collapser id="gitops-step2" title="2단계: Pipeline cloud 규칙을 로컬로 설정">
        이 단계에서는 뉴렐릭 CLI를 사용하여 1단계의 JSON 출력을 기반으로 Pipeline cloud 규칙에 대한 Terraform 설정 파일을 자동으로 생성합니다.

        <Steps>
          <Step>
            #### 필요한 환경 변수 설정 [#set-environment-variables]

            CLI 명령을 실행하기 전에 필요한 환경 변수가 설정되어 있는지 확인하세요.

            ```bash
            export NEW_RELIC_API_KEY="your-api-key"
            export NEW_RELIC_ACCOUNT_ID="your-account-id"
            export NEW_RELIC_REGION="US"  # Optional, defaults to 'US'
            ```
          </Step>

          <Step>
            #### JSON 출력을 파일에 저장합니다. [#save-json-output]

            Terraform 작업 공간 디렉토리에 JSON 파일(예: `drop_rules.json`)을 만들고 1단계의 JSON 출력을 붙여넣습니다.

            ```json
            {
              "drop_rule_resource_ids": [
                {
                  "name": "drop_debug_logs",
                  "id": "3806526:106878882",
                  "pipeline_cloud_rule_entity_id": "MzgwNjUyNnxORVVMS..."
                },
                {
                  "name": "drop_health_checks",
                  "id": "3806526:106878883",
                  "pipeline_cloud_rule_entity_id": "MzgwNjUyNnxORVVMS..."
                },
                {
                  "name": "drop_pii_data",
                  "id": "3806526:106878884",
                  "pipeline_cloud_rule_entity_id": "MzgwNjUyNnxORVVMS..."
                }
              ]
            }
            ```
          </Step>

          <Step>
            #### 뉴렐릭 CLI 마이그레이션 명령 실행 [#run-new-relic-cli-migration]

            Terraform 작업 공간 디렉토리로 이동하여 다음을 실행합니다.

            ```bash
            newrelic migrate nrqldroprules tf-importgen-ci --file drop_rules.json
            ```

            <Callout variant="tip">
              단순화를 위해 JSON 파일이 있는 Terraform 작업 공간 디렉토리에서 직접 이 명령을 실행하는 것이 좋습니다. 이렇게 하면 별도의 `--workspacePath` 지정할 필요가 없습니다.
            </Callout>

            **명령을 실행하여 다음을 수행합니다.**

            <table>
              <thead>
                <tr>
                  <th style={{width: "200px"}}>
                    매개변수
                  </th>

                  <th>
                    유형
                  </th>

                  <th>
                    설명
                  </th>

                  <th>
                    필수의
                  </th>
                </tr>
              </thead>

              <tbody>
                <tr>
                  <td>
                    \--파일
                  </td>

                  <td>
                    문자열
                  </td>

                  <td>
                    1단계의 삭제 규칙 매핑이 포함된 JSON 파일의 경로입니다. 

                    <InlineCode>
                      \--file
                    </InlineCode>

                     또는 

                    <InlineCode>
                      \--json
                    </InlineCode>

                     중 하나만 제공해야 하며, 둘 다 제공하면 안 됩니다.
                  </td>

                  <td>
                    예*
                  </td>
                </tr>

                <tr>
                  <td>
                    \--json
                  </td>

                  <td>
                    문자열
                  </td>

                  <td>
                    삭제 규칙 매핑을 포함하는 JSON 문자열입니다. 

                    <InlineCode>
                      \--file
                    </InlineCode>

                     의 대안입니다.
                  </td>

                  <td>
                    예*
                  </td>
                </tr>

                <tr>
                  <td>
                    \--작업공간경로
                  </td>

                  <td>
                    문자열
                  </td>

                  <td>
                    Terraform 작업 공간으로 가는 경로입니다. 생략하면 현재 디렉토리로 기본 설정됩니다.
                  </td>

                  <td>
                    아니요
                  </td>
                </tr>

                <tr>
                  <td>
                    \--두부
                  </td>

                  <td>
                    부울
                  </td>

                  <td>
                    Terraform 대신 OpenTofu를 사용하는 경우 사용하세요.
                  </td>

                  <td>
                    아니요
                  </td>
                </tr>
              </tbody>
            </table>

            **`--json` 을 사용하는 예:**

            파일을 생성하지 않으려면 JSON 문자열을 직접 전달할 수 있습니다.

            ```bash
            newrelic migrate nrqldroprules tf-importgen-ci \
              --json '{"drop_rule_resource_ids":[{"name":"drop_debug_logs","id":"3806526:106878882","pipeline_cloud_rule_entity_id":"MzgwNjUyNnxORVVMS..."}]}'
            ```
          </Step>

          /* &lt;Step&gt; #### 명령의 기능을 이해합니다 [#understand-command-execution] `tf-importgen-ci` 명령은 다음 작업을 자동으로 수행합니다. - 입력 파라미터, 변수 및 환경 변수의 유효성 검사 - 환경과 입력 데이터 간의 계정 ID 일관성 확인 - Terraform/OpenTofu 설치 및 버전 확인(v1.5 이상 필요) - 작업 공간 디렉터리 생성 또는 유효성 검사 - 공급자 설정(`provider.tf`) 생성 - 가져오기 블록(`imports.tf`) 생성 - Terraform/OpenTofu 작업 공간을 초기화합니다. - `terraform plan`을 실행하여 Pipeline cloud 규칙 설정을 생성합니다(`pcrs.tf`). - 모든 설정 파일을 포맷합니다. - 3단계(상태에서 이전 삭제 규칙 제거)에 대한 권장 사항을 제공합니다. &lt;Callout variant=&quot;important&quot;&gt; **계정 ID 유효성 검사:** 이 명령은 JSON 데이터의 계정 ID가 `NEW_RELIC_ACCOUNT_ID` 환경 변수와 일치하는지 자동으로 유효성을 검사합니다. 불일치가 감지되면 잠재적인 가져오기 실패에 대한 경고가 표시됩니다. &lt;/Callout&gt; &lt;Callout title=&quot;참고&quot;&gt; **중복된 리소스 이름:** 입력 데이터에서 중복된 리소스 이름이 발견되면 명령은 고유한 리소스 정의를 보장하기 위해 무작위 알파벳 접미사를 추가하여 자동으로 해당 이름을 해결합니다. &lt;/Callout&gt; &lt;/Step&gt; */

          <Step>
            #### 생성된 파일을 검토하세요 [#review-generated-files]

            CLI 명령은 작업 공간에 세 개의 Terraform 설정 파일을 생성합니다.

            * **`provider.tf`:** 버전 제약 조건이 있는 Terraform 및 뉴렐릭 제공업체 설정입니다.
            * **`imports.tf`:** 뉴렐릭의 기존 Pipeline cloud 규칙에 새 리소스를 연결하는 블록을 가져옵니다.
            * **`pcrs.tf`:** Pipeline cloud 규칙 리소스 정의(명령 실행 중 자동 생성됨).

            이 명령은 3단계에서 사용할 Terraform 상태에서 오래된 삭제 규칙을 제거하기 위한 권장 사항도 표시합니다.

            {/* **생성된 설정의 예:** ```hcl # provider.tf terraform { required_providers { newrelic = { source = &quot;newrelic/newrelic&quot; version = &quot;~&gt; 3.68.0&quot; } } } # imports.tf 가져오기 { to = newrelic_pipeline_cloud_rule.drop_debug_logs id = &quot;3806526:MzgwNjUyNnxORVVMS...&quot; } {를 가져옵니다 = newrelic_pipeline_cloud_rule.drop_health_checks id = &quot;3806526:MzgwNjUyNnxORVVMS...&quot; } {를 가져옵니다 = newrelic_pipeline_cloud_rule.drop_pii_data id = &quot;3806526:MzgwNjUyNnxORVVMS...&quot; } # pcrs.tf (명령 실행 중 자동 생성됨) 리소스 &quot;newrelic_pipeline_cloud_rule&quot; &quot;drop_debug_logs&quot; { account_id = 3806526 설명 = &quot;디버그 수준 로그 필터링&quot; action = &quot;drop&quot; NRQL = &quot;SELECT * FROM Log WHERE level = &apos;debug&apos;&quot; } 리소스 &quot;newrelic_pipeline_cloud_rule&quot; &quot;drop_health_checks&quot; { account_id = 3806526 설명 = &quot;상태 확인 로그 제거&quot; action = &quot;drop&quot; NRQL = &quot;SELECT * FROM Log WHERE endpoint = &apos;/health&apos;&quot; } 리소스 &quot;newrelic_pipeline_cloud_rule&quot; &quot;drop_pii_data&quot; { account_id = 3806526 설명 = &quot;필터링 PII 데이터 삭제&quot; 작업 = &quot;삭제&quot; NRQL = &quot;SELECT * FROM Log WHERE contains(메시지, &apos;SSN&apos;)&quot; } ``` */}
          </Step>

          <Step>
            #### 생성된 설정을 커밋하고 푸시합니다. [#commit-push-generated-configuration]

            생성된 Terraform 파일을 git 저장소에 추가합니다.

            ```bash
            git add .
            git commit -m "Add Pipeline cloud rule migration configuration"
            git push origin your-branch-name
            ```

            이렇게 하면 CI/CD 파이프라인이 3단계의 변경 사항을 처리하게 됩니다.
          </Step>
        </Steps>
      </Collapser>

      <Collapser id="gitops-step3" title="3단계: 연속 통합/연속 배포(CI/CD) 환경에서 Pipeline cloud 규칙 가져오기">
        이 단계에서는 CI/CD가 2단계에서 푸시한 변경 사항을 처리하고, Pipeline cloud 규칙을 Terraform 상태로 가져오고, 이전 삭제 규칙 리소스를 제거합니다.

        <Steps>
          <Step>
            #### Terraform 계획을 검토하세요 [#review-terraform-plan]

            변경 사항을 푸시하면 CI/CD 배포가 자동으로 트리거되어 풀 요청에 대한 계획 주석이 게시됩니다. 계획 출력에는 다음이 표시됩니다.

            * **가져오는 리소스:** 3개의 `newrelic_pipeline_cloud_rule` 리소스
            * **계획 요약:** `Plan: 3 to import, 0 to add, 0 to change, 0 to destroy`

            /* 샘플 Terraform 계획 출력: ```diff Terraform은 다음 작업을 수행합니다. # newrelic_pipeline_cloud_rule.drop_debug_logs가 가져옵니다. 리소스 &quot;newrelic_pipeline_cloud_rule&quot; &quot;drop_debug_logs&quot; { account_id = 3806526 description = &quot;운영 환경에서 디버그 수준 로그를 필터링하여 데이터 볼륨을 줄입니다.&quot; id = &quot;MzgwNjUyNnxOR0VQfFBJUEVMSU5FX0NMT1VEX1JVTEV8MDE5OTRjZjgtYmFmNy03MjU3LWE3M2MtZWY5OTkxYTQxMjgy&quot; name = &quot;NRQL 삭제 규칙 ID: 106878882 사용자 ID: 1004672904에서 생성됨 생성 위치: 2025-09-15T10:43:13.122888Z&quot; NRQL = &quot;DELETE FROM `log` WHERE ((`level` = &apos;debug&apos;) AND (`environment` = &apos;production&apos;))&quot; } # newrelic_pipeline_cloud_rule.drop_health_checks가 가져옴 리소스 &quot;newrelic_pipeline_cloud_rule&quot; &quot;drop_health_checks&quot; { account_id = 3806526 description = &quot;MyCustomEvent 데이터에서 userEmail 및 userName 속성을 제거합니다.&quot; id = &quot;MzgwNjUyNnxOR0VQfFBJUEVMSU5FX0NMT1VEX1JVTEV8MDE5OTRjZmItMTQ0Yy03NDM5LWJhNDYtZjI4MTg0ODc5YmE2&quot; name = &quot;NRQL 삭제 규칙 ID: 106878884 사용자 ID: 1004672904가 생성함 2025-09-15T10:45:47.049993Z에 생성됨&quot; NRQL = &quot;DELETE `userEmail`, `userName` FROM `MyCustomEvent`&quot; } # newrelic_pipeline_cloud_rule.drop_pii_data가 가져옴 리소스 &quot;newrelic_pipeline_cloud_rule&quot; &quot;drop_pii_data&quot; { account_id = 3806526 description = &quot;지표 집계에서 containerId 속성을 제외합니다&quot; id = &quot;MzgwNjUyNnxOR0VQfFBJUEVMSU5FX0NMT1VEX1JVTEV8MDE5OTRjZmItMTQ4Ni03MDI4LWJlMDktZmYzOTM2NWQ4ODUw&quot; name = &quot;NRQL 삭제 규칙 ID: 106878885, 사용자 ID: 1004672904, 생성일: 2025-09-15T10:45:47.060296Z&quot; NRQL = &quot;DELETE `containerId` FROM `MetricAggregate`&quot; } 계획: 가져오기 3개, 추가 0개, 변경 0개, 삭제 0개. ``` */
          </Step>

          <Step>
            #### 변경 사항 적용 [#apply-changes]

            계획을 검토하고 올바른지 확인한 후 풀 요청에 대해 의견을 남겨주세요.

            ```bash
            terraform apply
            ```

            CI/CD 배포는 Terraform 적용을 실행하여 Pipeline cloud 규칙을 Terraform 상태로 가져옵니다.

            샘플 적용 출력:

            ```
            newrelic_pipeline_cloud_rule.drop_health_checks: Importing...
            newrelic_pipeline_cloud_rule.drop_health_checks: Import complete
            newrelic_pipeline_cloud_rule.drop_debug_logs: Importing...
            newrelic_pipeline_cloud_rule.drop_debug_logs: Import complete
            newrelic_pipeline_cloud_rule.drop_pii_data: Importing...
            newrelic_pipeline_cloud_rule.drop_pii_data: Import complete

            Apply complete! Resources: 3 imported, 0 added, 0 changed, 0 destroyed.
            ```
          </Step>

          <Step>
            #### 상태에서 오래된 삭제 규칙을 정리합니다. [#clean-up-drop-rules]

            가져오기가 성공적으로 완료되면 Terraform 상태에서 이전 `newrelic_nrql_drop_rule` 리소스를 제거해야 합니다. 2단계 CLI 출력에 제공된 권장 사항을 사용하세요.

            통합 연속/연속 배포(CI/CD) 환경에서 또는 로컬에서 각 이전 삭제 규칙에 대해 `terraform state rm` 명령을 실행합니다.

            ```bash
            terraform state rm newrelic_nrql_drop_rule.drop_debug_logs
            terraform state rm newrelic_nrql_drop_rule.drop_health_checks
            terraform state rm newrelic_nrql_drop_rule.drop_pii_data
            ```

            <Callout title="메모">
              These commands remove the resources from Terraform state without deleting them from New Relic. The old drop rules will be eventually removed from New Relic at the end-of-life date (June 30, 2026), but are no longer managed by Terraform after this step.
            </Callout>
          </Step>

          <Step>
            #### 마이그레이션 확인 [#verify-migration]

            상태를 정리한 후:

            * 출력을 확인하여 모든 가져오기가 성공적으로 완료되었는지 확인하세요.
            * 뉴렐릭 UI 에서 Pipeline cloud 규칙이 여전히 활성화되어 작동 중인지 확인하세요.
            * 보류 중인 변경 사항이 없는지 확인하려면 `terraform plan` 실행합니다(출력에는 &quot;변경 사항 없음&quot;이 표시되어야 함).
            * `terraform state list` 에 더 이상 이전 삭제 규칙이 나타나지 않는지 확인하세요.
          </Step>

          <Step>
            #### 당신의 풀을 병합하세요 [#merge-pull-request]

            검증이 완료되면 풀 리퀘스트를 병합하여 마이그레이션을 마무리합니다. 이제 Terraform 설정에서 NRQL 삭제 규칙 대신 Pipeline cloud 규칙을 관리합니다.
          </Step>
        </Steps>
      </Collapser>
    </CollapserGroup>

    문제 해결, GitOps 접근 방식에 대한 도움말을 보려면 [1단계 문제 해결, 유효성 검사 문제 해결 가이드](https://github.com/newrelic/terraform-provider-newrelic/blob/main/examples/drop_rule_migration_ci/README.md#troubleshooting) 또는 [2/3단계 문제 해결, CLI 및 가져오기 문제 해결 가이드를](https://github.com/newrelic/newrelic-cli/blob/main/internal/migrate/tf_importgen_ci_guide.md#common-issues-and-troubleshooting) 참조하세요.
  </Collapser>

  <Collapser id="local-terraform" title="로컬 Terraform 사용">
    로컬 자동화 프로세스는 상태 파일에 쉽게 접근하여 상태를 자동으로 업데이트하고, 새 규칙을 생성하고 가져오고, 더 이상 사용되지 않는 리소스를 정리할 수 있다는 사실을 활용하여 3가지 순차적 단계로 간소화되었습니다.

    <CollapserGroup>
      <Collapser id="local-step1" title="1. Pipeline cloud 규칙을 사용하여 Terraform 상태 업데이트">
        이 단계에서는 뉴렐릭 CLI를 사용하여 Terraform 작업 공간의 모든 삭제 규칙을 자동으로 식별하고 Terraform 상태를 해당 Pipeline cloud 규칙으로 업데이트합니다.

        <Steps>
          <Step>
            #### Terraform 작업 공간으로 이동합니다. [#navigate-terraform-workspace]

            터미널을 열고 `newrelic_nrql_drop_rule` 리소스가 있는 Terraform 설정 파일이 있는 디렉토리로 이동합니다.

            ```bash
            cd /path/to/your/terraform/workspace
            ```
          </Step>

          <Step>
            #### 뉴렐릭 CLI 업데이트 명령을 실행하세요 [#run-new-relic-cli-update]

            다음 명령을 실행하여 Terraform 상태를 업데이트하세요.

            ```bash
            newrelic migrate nrqldroprules tf-update
            ```

            이 명령은 자동으로 다음을 수행합니다.

            * Terraform 작업 공간을 스캔하여 모든 `newrelic_nrql_drop_rule` 리소스를 식별합니다.
            * 이러한 리소스에 대해 `terraform plan` 및 `terraform apply` 작업을 실행합니다.
            * 각 삭제 규칙에 대한 `pipeline_cloud_rule_entity_id` 속성을 사용하여 Terraform 상태 파일을 업데이트합니다.
          </Step>

          <Step>
            #### 상태 업데이트 확인 [#verify-state-update]

            명령이 완료되면 Terraform 상태 파일에 삭제 규칙과 Pipeline cloud 규칙 간의 매핑이 포함됩니다. 이를 확인하려면 귀하의 주를 확인하세요.

            ```bash
            terraform show -json | grep pipeline_cloud_rule_entity_id
            ```

            출력에서 각 삭제 규칙에 대한 `pipeline_cloud_rule_entity_id` 값을 확인해야 합니다. 이는 귀하의 주 파일이 성공적으로 업데이트되었음을 확인합니다. 다음 단계에서 CLI가 이러한 값을 자동으로 읽습니다.
          </Step>
        </Steps>
      </Collapser>

      <Collapser id="local-step2" title="2. Pipeline cloud 규칙 생성 및 가져오기">
        <Steps>
          <Step>
            #### 뉴렐릭 CLI 가져오기 생성 명령을 실행합니다. [#run-new-relic-cli-import-generation]

            Terraform 작업 공간 디렉토리에서 다음을 실행합니다.

            ```bash
            newrelic migrate nrqldroprules tf-importgen
            ```

            이 명령은 자동으로 다음을 수행합니다.

            * 삭제 규칙 리소스에 `pipeline_cloud_rule_entity_id` 값이 포함되어 있는지 확인합니다.
            * 각 Pipeline cloud 규칙에 대한 가져오기 블록을 생성합니다.
            * `terraform plan -generate-config-out=generated_pipeline_rules.tf` 실행하여 Pipeline cloud 규칙을 설정합니다.
            * `terraform apply` 실행하여 Pipeline cloud 규칙을 Terraform 상태로 가져옵니다.

            <Callout variant="tip">
              선택적 조치:

              * `--tofu`: Terraform 대신 OpenTofu를 사용하는 경우 사용하세요.
              * `--fileName`: 가져오기 블록에 대한 사용자 정의 파일 이름을 지정합니다(기본적으로 가져오기 블록은 터미널에 인쇄됩니다)
              * `--workspacePath`: 다른 Terraform 작업 공간 경로를 지정합니다(기본값은 현재 디렉토리입니다)
            </Callout>
          </Step>

          <Step>
            #### 가져오기 결과 검토 [#review-import-results]

            명령이 성공적으로 완료되면 Pipeline cloud 규칙이 Terraform 상태로 가져왔습니다. 이 명령은 `terraform plan -generate-config-out` 에 의해 생성된 Pipeline cloud 규칙 리소스 정의를 포함하는 `generated_pipeline_rules.tf` 파일을 생성합니다.
          </Step>
        </Steps>
      </Collapser>

      <Collapser id="local-step3" title="3. Terraform 상태에서 이전 삭제 규칙 제거">
        In this step, you&apos;ll use the New Relic CLI to safely remove the old NRQL drop rule resources from your Terraform state. This command only removes them from Terraform management—the actual drop rules will be eventually removed from New Relic at the end-of-life date (June 30, 2026).

        <Steps>
          <Step>
            #### 뉴렐릭 CLI delist 명령을 실행합니다. [#run-delist-command]

            Terraform 작업 공간 디렉토리에서 다음을 실행합니다.

            ```bash
            newrelic migrate nrqldroprules tf-delist
            ```

            이 명령은:

            * 리소스가 상태에서만 제거될 것임을 확인하는 안전 경고를 표시합니다.
            * Terraform 상태에서 모든 `newrelic_nrql_drop_rule` 리소스를 제거합니다.
            * Terraform 설정 파일을 정리하기 위한 지침을 제공합니다.
          </Step>

          <Step>
            #### Terraform 설정 정리 [#clean-up-configuration]

            delist 명령이 완료된 후에는 Terraform 설정 파일에서 모든 `newrelic_nrql_drop_rule` 리소스 블록을 주석화하거나 제거하여 해당 리소스 블록이 다시 생성되지 않도록 해야 합니다.
          </Step>

          <Step>
            #### 마이그레이션 확인 [#verify-migration]

            설정 파일을 정리한 후 마이그레이션을 확인하세요.

            ```bash
            # Confirm Pipeline cloud rules are in state
            terraform state list | grep pipeline_cloud_rule

            # Confirm old drop rules are removed from state
            terraform state list | grep nrql_drop_rule

            # Verify no pending changes
            terraform plan
            ```

            성공하면 `terraform plan` &quot;변경 사항 없음&quot;이 표시됩니다.
          </Step>
        </Steps>
      </Collapser>
    </CollapserGroup>

    로컬 Terraform 접근 방식에 대한 문제 해결, 해결 도움말은 [로컬 Terraform 문제 해결, CLI 명령 및 가져오기 문제 해결 가이드를](https://github.com/newrelic/newrelic-cli/blob/main/internal/migrate/tf_importgen_guide.md#common-issues-and-troubleshooting) 참조하세요.
  </Collapser>
</CollapserGroup>