---
title: SLI 및 SLO 생성 및 편집
tags:
  - Service Level Management
  - SLI/SLO
metaDescription: 'With New Relic, you can create and consume SLI/SLOs.'
translationType: machine
---

import suggestedSli from 'images/suggested_sli.png'

import customSli from 'images/custom_sli.png'

import sliTags from 'images/sli_tags.png'

import slmEditMenu2 from 'images/slm_edit_menu_2.png'

[New Relic UI](https://one.newrelic.com) 를 통해 수동으로 SLI 및 SLO를 생성할 수 있습니다. 또는 [NerdGraph API](/docs/apis/nerdgraph/examples/nerdgraph-slm/) 및 [Terraform 서비스 수준 리소스](https://registry.terraform.io/providers/newrelic/newrelic/latest/docs/resources/service_level) 를 사용하여 프로세스를 자동화할 수 있습니다.

## 요구 사항 [#requirements]

권한 관련 요구 사항:

* "메트릭에 대한 이벤트 수정/삭제" 기능이 필요합니다. 해당 역할을 얻는 방법은 [사용자 모델](/docs/accounts/original-accounts-billing/original-users-roles/overview-user-models) 에 따라 다릅니다.

  * 새로운 Relic One 사용자 모델: [기능에 대해 자세히 알아보세요.](/docs/accounts/accounts-billing/new-relic-one-user-management/user-management-concepts/#capabilities)
  * 원래 사용자 모델: 이 기능은 관리자 역할, Insights 관리자 역할에 제공되거나 사용자 지정 역할에 제공될 수 있습니다. [역할에 대해 자세히 알아보세요.](/docs/accounts/original-accounts-billing/original-users-roles/users-roles-original-user-model#add-on)

## SLI 및 SLO 생성을 위한 주요 개념 [#key-concepts]

SLI 및 SLO를 정의할 때 이러한 개념을 염두에 두십시오.

### 관련 기관 [#sli-entity]

New Relic 생태계에서 모든 서비스 수준은 데이터를 당사에 보고하거나 액세스 권한이 있는 데이터를 생성하는 스택의 모든 요소인 다른 [엔티티](/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/) 에 연결됩니다. 서비스 수준이 관련된 엔터티는 SLI/SLO 결과가 표시되는 위치를 결정합니다.

New Relic에 보고되는 모든 NRDB 이벤트에 대해 SLI를 정의할 수 있으므로 사용자 지정 이벤트를 기반으로 SLI를 설정할 수도 있습니다. 대부분의 사용자 지정 이벤트는 단일 New Relic 엔터티와 관련이 없지만 더 높은 수준의 비즈니스 및 사용자 경험 통찰력을 제공합니다. 이 경우에도 SLI를 특정 엔터티 또는 워크로드와 연결할 수 있습니다.

### SLI 쿼리 [#sli-queries]

SLI는 유효한 요청의 총 수에서 좋은 응답의 비율로 정의됩니다. 대부분 유효하고 좋은 부분을 정의하여 SLI를 설정합니다.

* **유효한 요청** 은 SLI에 대해 의미 있는 것으로 간주하려는 모든 요청입니다(예: 상태 확인에 의해 시작되지 않은 엔드포인트와 관련된 모든 트랜잭션).
* **좋은 응답** 은 최종 사용자 또는 클라이언트 서비스에 좋은 출력을 제공하기 위해 고려하는 모든 응답입니다(예: 서비스가 2초 미만으로 응답하여 최종 사용자에게 우수한 탐색 경험을 제공함).

또는 잘못된 응답으로 간주되는 항목을 대신 정의할 수 있습니다.

* **잘못된 응답** 은 잘못된 출력을 제공하는 것으로 간주되는 모든 응답입니다(예: 서비스가 서버 오류로 응답하여 클라이언트가 해당 흐름에 실패하도록 하는 경우). New Relic은 자동으로 좋은 응답 수를 `valid - bad` 으로 유도합니다.

요청 기반 SLO는 총 요청 수에 대한 양호한 요청 수의 비율로 정의된 SLI를 기반으로 합니다. 요청 기반 SLO는 해당 비율이 규정 준수 기간의 목표를 충족하거나 초과할 때 충족됩니다.

## 제안된 SLI [#suggested-sli]

이 섹션에서는 일반적으로 서비스 및 브라우저 응용 프로그램의 성능을 측정하는 데 사용되는 몇 가지 SLI를 찾을 수 있습니다.

### New Relic 에이전트로 계측된 APM 서비스용 SLI [#sli-apm]

`Transaction` 이벤트를 기반으로 하는 다음 SLI는 요청 기반 서비스에 가장 일반적입니다.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="service-availability"
    title="서비스 성공"
  >
    서비스 성공은 모든 요청 수에 대한 성공적인 응답 수의 비율입니다. 이것은 사실상 오류율이지만 예상 오류를 제거하는 등 필터링할 수 있습니다.

    **유효한 이벤트 필드**

    ```
    FROM: Transaction
    WHERE: entityGuid = '{entityGuid}'
    ```

    여기서 `{entityGuid}` 은 서비스의 GUID입니다.

    **잘못된 이벤트 필드**

    ```
    FROM: TransactionError
    WHERE: entityGuid = '{entityGuid}' AND error.expected IS FALSE
    ```

    여기서 `{entityGuid}` 은 서비스의 GUID입니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="service-latency"
    title="서비스 지연"
  >
    대기 시간 SLI는 좋은 경험으로 설정된 임계값보다 빠르게 제공된 유효한 요청의 비율을 측정합니다.

    기간 임계값을 결정하려면 지난 몇 주 동안 서비스가 어떻게 수행되었는지 확인하고 그 결과를 현실적이고 달성 가능한 기준으로 사용하십시오. 그런 다음 SLI 임계값을 반복하고 더 야심찬 성능에 맞출 수 있습니다.

    기간 조건에 대한 적절한 값을 선택하기 위해 한 가지 일반적인 방법은 지난 7일 또는 15일 동안 응답의 95 백분위수 기간을 선택하는 것입니다. [쿼리 빌더](/docs/query-your-data/explore-query-data/query-builder/introduction-query-builder/) 를 사용하여 이 기간 임계값을 찾고 이를 사용하여 SLI에 좋은 이벤트로 간주되는 이벤트를 결정합니다.

    `select percentile(duration, 95) from Transaction where entityGuid = '{entityGuid}' since 7 days ago limit max`

    **유효한 이벤트 필드**

    ```
    FROM: Transaction
    WHERE: entityGuid = '{entityGuid}' AND transactionType = 'Web'
    ```

    여기서 `{entityGuid}` 은 서비스의 GUID입니다.

    **좋은 이벤트 필드**

    ```
    FROM: Transaction
    WHERE: entityGuid = '{entityGuid}' AND transactionType = 'Web' AND duration < {duration}
    ```

    * 여기서 `{entityGuid}` 은 서비스의 GUID입니다.
    * 여기서 `{duration}` 은 클라이언트 서비스 또는 최종 사용자에게 좋은 경험을 제공한다고 생각하는 응답 시간(초)입니다.
  </Collapser>
</CollapserGroup>

### OpenTelemetry로 계측된 APM 서비스용 SLI [#sli-otel]

OpenTelemetry 범위를 기반으로 하는 이러한 SLI는 요청 기반 서비스에 가장 일반적입니다.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="otel-availability"
    title="서비스 성공"
  >
    서비스 성공은 모든 요청 수에 대한 성공적인 응답 수의 비율입니다. 이것은 사실상 오류율이지만 예상 오류를 제거하는 등 필터링할 수 있습니다.

    **유효한 이벤트 필드**

    ```
    FROM: Span
    WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer'))
    ```

    여기서 `{entityGuid}` 은 서비스의 GUID입니다.

    **잘못된 이벤트 필드**

    ```
    FROM: Span
    WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) AND otel.status_code = 'ERROR'
    ```

    여기서 `{entityGuid}` 은 서비스의 GUID입니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="otel-latency"
    title="서비스 지연"
  >
    대기 시간 SLI는 좋은 경험으로 설정된 임계값보다 빠르게 제공된 유효한 요청의 비율을 측정합니다.

    기간 임계값을 결정하려면 지난 몇 주 동안 서비스가 어떻게 수행되었는지 확인하고 그 결과를 현실적이고 달성 가능한 기준으로 사용하십시오. 그런 다음 SLI 임계값을 반복하고 더 야심찬 성능에 맞출 수 있습니다.

    기간 조건에 대한 적절한 값을 선택하기 위해 한 가지 일반적인 방법은 지난 7일 또는 15일 동안 응답의 95 백분위수 기간을 선택하는 것입니다. [쿼리 빌더](/docs/query-your-data/explore-query-data/query-builder/introduction-query-builder/) 를 사용하여 이 기간 임계값을 찾고 이를 사용하여 SLI에 좋은 이벤트로 간주되는 이벤트를 결정합니다.

    `select percentile(duration.ms, 95) from Span where entityGuid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) since 7 days ago limit max`

    **유효한 이벤트 필드**

    ```
    FROM: Span
    WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer'))
    ```

    여기서 `{entityGuid}` 은 서비스의 GUID입니다.

    **좋은 이벤트 필드**

    ```
    FROM: Span
    WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) AND duration.ms < {duration}
    ```

    * 여기서 `{entityGuid}` 은 서비스의 GUID입니다.
    * 여기서 `{duration}` 은 클라이언트 서비스 또는 최종 사용자에게 좋은 경험을 제공한다고 생각하는 응답 시간(초)입니다.
  </Collapser>
</CollapserGroup>

### 브라우저 애플리케이션용 SLI [#sli-browser]

다음 SLI는 Google의 Browser Core Web Vitals를 기반으로 합니다.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="browser-availability"
    title="브라우저 앱 성공"
  >
    오류 없이 제공되는 페이지뷰의 비율입니다.

    **유효한 이벤트 필드**

    ```
    FROM: PageView
    WHERE: entityGuid = '{entityGuid}'
    ```

    여기서 `{entityGuid}` 은 서비스의 GUID입니다.

    **잘못된 이벤트 필드**

    ```
    FROM: JavaScriptError
    WHERE: entityGuid = '{entityGuid}' AND firstErrorInSession IS true
    ```

    여기서 `{entityGuid}` 은 브라우저 앱 GUID입니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="browser-contentful-paint"
    title="브라우저 앱에서 가장 큰 콘텐츠가 포함된 페인트"
  >
    뷰포트에 표시되는 가장 큰 콘텐츠 요소가 좋은 경험에 해당하는 것으로 간주되는 임계값보다 빠르게 렌더링된 유효한 페이지 뷰의 비율입니다.

    **유효한 이벤트 필드**

    ```
    FROM: PageViewTiming
    WHERE: entityGuid = '{entityGuid}' AND largestContentfulPaint IS NOT NULL
    ```

    여기서 `{entityGuid}` 은 서비스의 GUID입니다.

    **좋은 이벤트 필드**

    ```
    FROM: PageViewTiming
    WHERE: entityGuid = '{entityGuid}' AND largestContentfulPaint < '{largestContentfulPaint}'
    ```

    * 여기서 `{entityGuid}` 은 브라우저 앱 GUID입니다.

    * 여기서 `{largestContentfulPaint}` 은 최종 사용자에게 좋은 경험을 제공한다고 생각하는 표시 영역에 표시되는 가장 큰 콘텐츠 요소를 렌더링하는 데 걸리는 시간(밀리초)입니다. 빈번한 표준은 4000ms입니다.

      사용자 환경에서 `{largestContentfulPaint}` 에 사용할 현실적인 숫자를 결정하기 위해 한 가지 일반적인 방법은 지난 7일 또는 15일 동안 응답의 95 백분위수 기간을 선택하는 것입니다. 쿼리 빌더를 사용하여 찾습니다.

      `SELECT percentile(largestContentfulPaint, 95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max`
  </Collapser>

  <Collapser
    className="freq-link"
    id="browser-first-delay"
    title="브라우저 앱 첫 번째 입력 지연"
  >
    사용자가 페이지와 처음 상호작용한 시간과 브라우저가 해당 상호작용에 응답한 시간 사이의 시간이 특정 임계값 미만인 페이지 조회수의 비율입니다.

    **유효한 이벤트 필드**

    ```
    FROM: PageViewTiming
    WHERE: entityGuid = '{entityGuid}' AND firstInputDelay IS NOT NULL
    ```

    여기서 `{entityGuid}` 은 서비스의 GUID입니다.

    **좋은 이벤트 필드**

    ```
    FROM: PageViewTiming
    WHERE: entityGuid = '{entityGuid}' AND firstInputDelay < {firstInputDelay}
    ```

    * 여기서 `{entityGuid}` 은 브라우저 앱 GUID입니다.

    * 여기서 `{firstInputDelay}` 은 최종 사용자에게 좋은 경험을 제공하기 위해 브라우저가 응답해야 하는 시간(밀리초)입니다. 빈번한 표준은 300ms입니다.

      사용자 환경에서 `{firstInputDelay}` 에 사용할 현실적인 숫자를 결정하기 위해 한 가지 일반적인 방법은 지난 7일 또는 15일 동안 응답의 95 백분위수 기간을 선택하는 것입니다. 쿼리 빌더를 사용하여 찾습니다.

      `SELECT percentile(firstInputDelay, 95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max facet deviceType`
  </Collapser>

  <Collapser
    className="freq-link"
    id="browser-cumulative-shift"
    title="브라우저 앱 누적 레이아웃 전환"
  >
    CLS(누적 레이아웃 전환)가 좋은 페이지 보기의 비율입니다. CLS는 페이지의 전체 수명 동안 발생하는 모든 예상치 못한 레이아웃 전환에 대한 모든 개별 레이아웃 전환 점수의 총합으로 설명됩니다. 레이아웃 이동은 보이는 요소가 렌더링된 프레임에서 다음 프레임으로 위치를 변경할 때마다 발생합니다.

    **유효한 이벤트 필드**

    ```
    FROM: PageViewTiming
    WHERE: entityGuid = '{entityGuid}' AND cumulativeLayoutShift IS NOT NULL
    ```

    여기서 `{entityGuid}` 은 서비스의 GUID입니다.

    데스크톱 및 모바일 장치에서 별도로 CLS를 추적하기 위해 별도의 SLI를 만들려면 필드 끝에 다음 절 중 하나를 추가합니다.

    * `and deviceType = 'Mobile'`
    * `and deviceType = 'Desktop'`

    **좋은 이벤트 필드**

    ```
    FROM: PageViewTiming
    WHERE: entityGuid = '{entityGuid}' AND cumulativeLayoutShift < {cumulativeLayoutShift}
    ```

    * 여기서 `{entityGuid}` 은 브라우저 앱 GUID입니다.

    * 여기서 `{cumulativeLayoutShift}` 은 사전 설정 값입니다. 좋은 사용자 경험을 제공하려면 사이트의 CLS 점수가 0.1 이하가 되도록 노력해야 합니다. 0.25점 이상의 CLS 점수는 열악한 사용자 경험으로 간주됩니다.

      유효한 이벤트 쿼리를 정의할 때 데스크톱 및 모바일 장치에서 별도로 CLS를 추적하기 위해 별도의 SLI를 만들기로 결정한 경우 필드 끝에 다음 절을 추가합니다.

      * `and deviceType = 'Mobile'`
      * `and deviceType = 'Desktop'`

      환경에서 `{cumulativeLayoutShift}` 에 대해 선택할 현실적인 숫자를 결정하기 위해 일반적인 방법 중 하나는 모바일 및 데스크톱 기기에 걸쳐 분류된 지난 7일 또는 15일 동안 페이지 로드의 75번째 백분위수를 선택하는 것입니다. 쿼리 빌더를 사용하여 찾습니다.

      `SELECT percentile(cumulativeLayoutShift, 95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max facet deviceType`
  </Collapser>
</CollapserGroup>

## 서비스 수준 생성 및 편집 [#create-edit]

[UI의](https://one.newrelic.com/) 여러 위치에서 SLI 및 SLO를 만들 수 있습니다.

* 상단 메뉴의 **서비스 수준** 보기에서. 워크로드를 포함하여 계정 전체의 모든 엔터티와 SLI를 연결할 수 있습니다.
* APM 서비스의 **서비스 수준** 페이지에서. SLI는 해당 특정 APM 서비스와 연결됩니다. 이 시작점을 사용하면 New Relic은 사용 가능한 최신 데이터를 기반으로 이 엔터티 유형에 대한 가장 일반적인 서비스 수준 지표를 자동으로 생성합니다.
* 모든 워크로드의 **서비스 수준** 탭에서. SLI를 워크로드의 엔터티 또는 워크로드 자체와 연결할 수 있습니다.

이 단계를 따르세요:

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="select-sli-source"
    title="SLI 데이터 소스 선택"
  >
    새 SLI를 정의하려면 다음 두 옵션 중 하나를 선택하십시오.

    * **엔터티 데이터** : SLI는 에이전트가 제공하는 표준 데이터를 기반으로 합니다. 이것은 가장 일반적인 옵션입니다. 선택한 경우 사용할 엔터티(예: APM 서비스)를 선택합니다.
    * **사용자 지정 데이터** : 또는 사용자 지정 NRDB 이벤트를 기반으로 SLI를 설정할 수 있습니다. 서비스 수준 데이터를 특정 엔터티에 연결할 수 없거나 서비스 수준을 워크로드에 직접 연결하려는 경우 이 옵션을 사용합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="configure-queries"
    title="쿼리 구성"
  >
    이 단계에서는 어떤 이벤트가 유효한지, 좋은지 나쁜지를 결정하는 SLI 카운트 쿼리를 구성합니다.

    SLI를 APM 서비스 또는 브라우저 앱과 연결하면 New Relic은 몇 가지 일반적인 SLI 및 해당 쿼리를 제안합니다. 최신 데이터를 서비스 수준 목표의 기준으로 사용하며 나중에 SLI 및 SLO를 편집할 수 있습니다.

    <img
      title="Suggested service levels"
      alt="Suggested service levels"
      src={suggestedSli}
    />

    다른 유형의 엔터티를 사용하거나 New Relic에서 제공하는 기준 값을 사용자 지정하려는 경우 필요에 따라 SLI를 사용자 지정할 수 있습니다. 예를 들어 `WHERE` 절을 사용하여 상태 확인을 필터링할 수 있습니다. 각 쿼리에 다른 이벤트 유형을 사용할 수도 있습니다. 이 경우 각 유효한 이벤트가 양호 또는 불량 쿼리에 대한 하나 이하의 이벤트에만 해당하는지 확인하십시오.

    <img
      title="Custom service level"
      alt="Custom service level"
      src={customSli}
    />

    데이터가 수집된 계정은 SLI가 참조하는 엔터티의 계정과 일치합니다. 각 필드에 무엇이 들어가는지 알아보려면 위의 섹션을 참조하십시오.

    오른쪽에는 최종 쿼리가 표시되고 맨 아래에는 지난 며칠 동안 유효하고 좋은/나쁜 이벤트 수의 미리보기가 표시됩니다.

    <Callout variant="important">
      SLI 쿼리는 NRDB 이벤트 및 범위를 지원하지만 아직 차원 메트릭은 지원하지 않습니다.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="set-slo"
    title="SLO 기간 및 대상 설정"
  >
    이 단계에서는 SLI 값을 미리 보고 이 SLI에 대해 하나의 SLO를 추가합니다. 기간의 길이와 목표 비율을 선택하기만 하면 됩니다. 오른쪽의 차트는 설정하고 있는 목표가 실현 가능한지 또는 자주 놓치는지를 예측하는 데 도움이 됩니다.

    순환 기간 SLO가 지원됩니다. 롤링 시간 창에서 SLO 규정 준수는 지난 N일을 고려합니다. 1분마다 가장 오래된 데이터가 현재 계산에서 삭제되고 새 데이터가 이를 대체합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="define-sli"
    title="SLI 이름 지정 및 태그 지정"
  >
    측정 대상을 인식하는 데 도움이 되는 SLI의 짧은 이름을 선택하십시오.

    나중에 UI에서 SLI를 검색, 필터링 및 그룹화하는 데 사용할 수 있도록 SLI에 태그를 추가하는 것이 좋습니다.

    조직에 의미 있는 모든 태그를 설정할 수 있습니다. 드롭다운은 다음과 같은 유용한 태그 키를 제안합니다.

    * `owner`: 이 서비스 수준을 소유하고 SLO 목표를 달성하지 못한 경우 대응하는 팀 또는 사업부입니다.

    * `category`: `latency` 과 같이 SLI가 측정하는 것을 설명하는 키워드입니다. 제안된 서비스 수준 흐름을 따르면 New Relic이 이 태그를 채우고 나중에 편집할 수 있습니다.

    * `environment`: 서비스 수준이 측정하고 사용 사례에 적합한 환경입니다.

    * `maturity`: SLO가 얼마나 안정적인지 이해 관계자에게 알리는 데 유용합니다. `test` , `commitment` 또는 `aspirational` 와 같은 태그 값을 사용하는 것이 좋습니다.

    * `user_journey` 및 `application` : 이러한 종류의 태그는 전체 사용자 여정이든 특정 애플리케이션이든 동일한 사용자 경험에 적용되는 SLI를 그룹화하는 데 도움이 됩니다.

      또한 드롭다운에는 관련 엔터티 태그도 표시되므로 SLI에도 빠르게 추가할 수 있습니다.

      <img
        title="Service level tags"
        alt="Service level tags"
        src={sliTags}
      />

      완료하려면 해당 서비스 수준에 대한 설명을 선택적으로 추가할 수 있습니다.
  </Collapser>
</CollapserGroup>

### SLI 편집 [#edit-sli]

SLI를 만든 후 UI에 액세스하고 **...** 메뉴를 클릭하여 편집합니다.

<img
  title="Edit SLIs.png"
  alt="Edit SLIs"
  src={slmEditMenu2}
/>