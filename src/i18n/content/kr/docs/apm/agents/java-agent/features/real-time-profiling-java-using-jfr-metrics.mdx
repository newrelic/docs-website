---
title: JFR 메트릭을 사용하여 Java에 대한 실시간 프로파일링
tags:
  - Agents
  - Java agent
  - Features
metaDescription: 'APM for Java: Real-time Java profiling using Java Flight Recorder (JFR) metrics.'
freshnessValidatedDate: never
translationType: machine
---

New Relic의 JFR(Java Flight Recorder) 메트릭을 사용하여 Java에 대한 실시간 프로파일링을 사용하면 프로덕션 환경에서 Java 코드에 대해 지속적이고 상시 가동되는 프로파일링을 실행할 수 있습니다. 함께 제공되는 JVM 클러스터 타임라인 보기는 클러스터 전체의 성능 문제를 진단하는 빠르고 직관적인 방법을 제공합니다. 예를 들어 애플리케이션 배포가 클러스터의 전반적인 상태에 어떤 영향을 미치는지 빠르게 확인할 수 있습니다.

## 성능 병목 현상 찾기 [#feature]

Java 애플리케이션 또는 서비스의 성능 병목 현상을 해결하면 다음을 더 잘 이해할 수 있습니다.

* 자원을 낭비하고 있는 곳
* 사건이 일어났을 때
* 사건 중에 일어난 일
* 어떤 성능 문제로 인해 사고가 발생했는지

문제 해결을 더 빠르고 쉽게 하려면 JVM에서 실행되는 코드의 충실도 높은 런타임 특성을 확인해야 하며 해당 데이터가 실시간으로 필요합니다.

## JFR 데몬 [#about]

[JFR 데몬](https://github.com/newrelic/newrelic-jfr-core) 은 JVM의 동작을 [시각화](#find-data) 하기 위해 New Relic 플랫폼의 기능을 활용할 수 있게 해주는 JFR 이벤트 내보내기 도구입니다. New Relic [Java 원격 측정 SDK](https://github.com/newrelic/newrelic-telemetry-sdk-java) 를 기본 구현으로 사용하여 JFR 데몬은 JFR 이벤트를 New Relic 원격 측정 유형으로 변환하고 이를 New Relic의 메트릭 및 이벤트 수집 API에 보고합니다.

JFR 데몬에는 세 가지 다른 사용 시나리오가 있습니다.

* [뉴렐릭 에이전트 JFR 서비스](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#new-relic-java-agent-jfr-service) (권장) - 플래그십 [뉴렐릭 에이전트 에이전트](/docs/agents/java-agent/) 에 내장된 JFR 모니터링. 추가 설정은 필요하지 않습니다. 단순히 [저항 에이전트를 설치하고](/docs/agents/java-agent/installation/install-java-agent/) [JFR 서비스가 활성화되어 있는지](/docs/agents/java-agent/configuration/java-agent-configuration-config-file/#jfr-real-time-profiling) 확인하면 JFR 데이터가 저항 에이전트와 동일한

  <InlinePopover type="apm"/>

  으로 흘러들어갑니다. [뉴렐릭 에이전트 버전 7.0.0+이](/docs/release-notes/agent-release-notes/java-release-notes/java-agent-700/) 필요합니다.

  * <DNT>
      **Note**
    </DNT>

    : JFR 실시간 프로파일링은 [에이전트 서버 측 설정을](/docs/apm/agents/manage-apm-agents/configuration/server-side-agent-configuration/) 통해 전환될 수 있습니다. 이를 통해 리그를 다시 시작할 필요 없이 프로파일링을 토글할 수 있습니다.

* [독립 실행형 프로세스](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#standalone-process) - `jfr-daemon` 을 독립 실행형 프로세스로 실행하고 원격 JMX를 사용하여 기존 Java 프로세스를 모니터링하도록 구성합니다.

* [독립 실행형 Java 에이전트](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#standalone-java-agent) - `jfr-daemon` 을 Java 에이전트로 Java 프로세스에 연결합니다. New Relic Java 에이전트에 대한 경량 대안입니다.

## 지원되는 자바 버전 [#supported-java-versions]

JFR 데몬은 모든 버전의 Java 11 이상을 지원하지만 프로덕션 환경에서 비 LTS 버전의 Java를 사용하지 않는 것이 좋습니다.

일부 공급업체는 JFR을 Java 8 바이너리로 백포트했습니다. 예를 들어 OpenJDK는 버전 8u262에서 JFR을 백포트했습니다. JFR 데몬은 해당 Java 버전과 호환됩니다.

## 요구 사항 및 사용 지침 [#requirements-and-usage-instructions]

요구 사항 및 지침은 각 사용 시나리오에 따라 다릅니다. 자세한 내용은 특정 사용 시나리오에 대한 링크를 참조하십시오.

* New Relic Java 에이전트 JFR 서비스 - [요구 사항](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#requirements-for-new-relic-java-agent-jfr-service) , [구성](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#configuration-for-new-relic-java-agent-jfr-service) 및 [사용 지침](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#usage-for-new-relic-java-agent-jfr-service)
* 독립 실행형 프로세스 - [요구 사항](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#requirements-for-standalone-process) , [구성](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#configuration-for-standalone-usage) 및 [사용 지침](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#usage-for-standalone-process)
* 독립 실행형 Java 에이전트 - [요구 사항](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#requirements-for-standalone-java-agent) , [구성](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#configuration-for-standalone-usage) 및 [사용 지침](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#usage-for-standalone-java-agent)

<Callout variant="important">
  JFR 데몬과 함께 실행되는 앱은 JFR 하위 시스템이 추가 메모리를 사용할 것으로 예상해야 합니다.
</Callout>

<Callout variant="tip">
  저항 에이전트 릴리스 8.0.0 이상을 사용하면 JVM을 다시 시작하지 않고도 JFR 프로파일링 설정을 동적으로 변경할 수 있습니다. <DNT>**Settings > Application > Java Flight Recorder**</DNT> 에서 설정을 전환하거나 `jfr.enabled` 구성을 변경하여 이를 수행합니다.
</Callout>

## 데이터 보기 [#find-data]

데이터를 보려면 <DNT>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > APM & Services > (select service) > More views > Realtime Profiling Java**</DNT> 로 이동하세요.

## 시간 경과에 따른 JVM 클러스터 동작 이해 [#ui]

JVM 클러스터 타임라인 보기는 전체 클러스터에서 JVM 동작을 보여줍니다. 이 타임라인은 더 빠른 문제 해결 및 문제 감지를 가능하게 합니다. 예를 들어 한 눈에 다음을 볼 수 있습니다.

* 최근 배포가 나머지 JVM 클러스터에 미치는 영향
* JVM이 다시 시작될 때
* 개별 인스턴스가 노이즈가 많은 이웃에 의해 영향을 받은 방식

문제 해결을 더 쉽게 하려면 JVM에서 실행되는 코드의 충실도 높은 런타임 특성을 확인해야 하며 해당 데이터가 실시간으로 필요합니다.

<img
  title="new-relic-one-java-flight-record-ui"
  alt="New Relic Java Flight Recorder (JFR) UI"
  src="/images/apm_screenshot-full_Java-Flight-Record-UI.webp"
/>

<figcaption>
  <DNT>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > APM & Services > (select service) > Realtime Profiling Java**</DNT>: JVM 클러스터 타임라인 보기는 클러스터 전체의 JVM 동작을 보여줍니다.
</figcaption>

타임라인의 각 행은 시간 경과에 따른 특정 JVM을 나타냅니다. 각 행 내에서 상자는 해당 JVM 수명의 5분 기간을 나타냅니다. 심각도가 가장 낮은 것부터 가장 심각한 것까지 노란색, 주황색 및 빨간색 신호등은 JVM의 비정상적인 동작을 나타내므로 오류 또는 기타 성능 문제를 조사할 때 해당 인스턴스와 적절한 기간을 드릴다운할 수 있습니다.

<img
  title="JVM-health-info"
  alt="How JVM health is measured"
  src="/images/apm_screenshot-full_Java-JVM-health-UI.webp"
/>

<figcaption>
  JVM 상태 계산 방법에 대한 자세한 분석을 보려면 <DNT>**How is JVM health determined?**</DNT> 선택하세요.
</figcaption>

## JVM 세부정보 [#details]

JVM 세부정보 페이지를 찾으려면 다음으로 이동하세요. <DNT>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > APM & Services > (select service) > Realtime Profiling Java > (select JVM)**</DNT>.

각 JVM의 세부 정보 패널은 몇 가지 중요한 보기를 제공합니다.

* 사용자 CPU 사용량 백분율
* 시스템 CPU 사용량 백분율
* 힙 크기
* 가비지 수집 기간
* 가장 긴 가비지 수집 일시 중지
* 사용자 스레드 CPU 사용률
* 시스템 스레드 CPU 사용률
* 스레드당 작은 개체 할당
* 스레드당 대형 개체 할당
* 스레드당 네트워크 읽기
* 스레드당 네트워크 쓰기
* 스레드당 버퍼 할당 크기
* 총 스레드 할당
* 스레드당 총 개체 할당
* 메타스페이스

## Flame 그래프로 리소스 집약적인 코드 경로 식별 [#flamegraph]

<Callout variant="important">
  플레임 그래프 기능은 [New Relic Java 에이전트 JFR 서비스](https://github.com/newrelic/newrelic-jfr-core/blob/main/README.md#new-relic-java-agent-jfr-service) 사용 시나리오와만 호환됩니다.
</Callout>

"불꽃 그래프"는 호출 트리를 시각화하는 방법입니다. 그래프의 각 블록은 기능을 나타냅니다. 메서드가 소비하는 CPU 시간과 메모리 리소스가 많을수록 해당 블록은 더 넓어집니다.

플레임 그래프를 사용하여 애플리케이션 코드에서 가장 자주 실행되는 Java 클래스 및 메소드를 식별하십시오. Flame 그래프를 사용하여 코드의 핫스팟을 최적화하면 리소스 소비를 줄이고 애플리케이션의 전체 성능을 높일 수 있습니다.

화염 그래프 색상에 대한 몇 가지 세부 정보는 다음과 같습니다.

* 회색 그라데이션: Java SE 패키지의 메서드에 회색 그라데이션을 적용합니다. 통화 수가 적으면 밝은 색조를 띠고 통화 수가 증가함에 따라 점차 어두운 색조로 전환됩니다.
* 노란색-주황색 그라데이션: 노란색-주황색 그라데이션을 다른 라이브러리의 메서드에 적용합니다. 통화 수가 적을수록 노란색이 많아지고, 통화 수가 증가할수록 점차 주황색으로 전환됩니다.

<img
  title="Screenshot of New Relic Java flame graph"
  alt="Screenshot of New Relic Java flame graph."
  src="/images/apm_screenshot-full_Java-jfr-flamegraphs.webp"
/>

<figcaption>
  <DNT>**[one.newrelic.com](https://one.newrelic.com/) > APM & Services > (select service) > Realtime Profiling Java > (select JVM)**</DNT>: Flame 그래프를 포함하여 JVM별 세부정보를 확인할 수 있습니다.
</figcaption>
