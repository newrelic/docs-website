---
title: 의사결정으로 상관 논리 구성
metaDescription: 'For New Relic''s alerts, how to configure the correlation logic using decisions.'
freshnessValidatedDate: never
translationType: machine
---

알림' 상관 로직을 통해 관련 문제를 그룹화하여 산만하고 중복된 알림을 줄입니다. 이벤트가 시스템에 들어오면 상관 관계 논리를 사용할 수 있습니다. 적격 문제는 시간, 알려진 맥락, 관계 데이터를 기준으로 평가됩니다. 여러 문제가 관련되어 있는 경우 상관 관계 논리는 관련 인시던트를 하나의 포괄적인 [문제](/docs/alerts-applied-intelligence/overview/#concepts-terms) 로 퍼널합니다.

우리는 이것을 상관 논리 <DNT>**decisions**</DNT> 라고 부릅니다. 우리는 기본적으로 결정을 내렸지만 결정 페이지에서 직접 결정을 만들고 사용자 정의할 수도 있습니다. 결정 페이지를 찾으려면 <DNT>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts > Decisions**</DNT> 로 이동하세요. 요구사항에 가장 적합하도록 결정을 더 많이 구성할수록 뉴렐릭은 인시던트의 상관관계를 더 잘 파악하고, 소음을 줄이며, 대기 중인 팀에 더 많은 컨텍스트를 제공할 수 있습니다.

<img
  title="NRAI_Decisions_Page.png"
  alt="A screenshot that shows the alert decisions UI."
  src="/images/alerts_screenshot-full_new-relic-decisions-page.webp"
/>

<figcaption>
  <DNT>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts > Incident intelligence > Decisions**</DNT>: 우리의 UI 각 결정이 인시던트의 상관관계를 보여줍니다.
</figcaption>

## 상관 관계란 무엇이며 어떻게 작동합니까? [#what-is-correlaton]

가장 최근의 활성 사건은 상관 관계 논리에 사용할 수 있습니다. 예를 들어 시스템이 호주와 런던에서 합성 모니터가 실패했다는 두 개의 경고를 받았다고 가정해 보겠습니다. 이 두 경고는 고유한 인시던트를 생성합니다. 이러한 인시던트는 팀의 기존 [인시던트 생성 정책](/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/specify-when-alerts-create-incidents/#preference-target) 에 따라 고유한 문제를 생성합니다. 그런 다음 New Relic의 상관 논리는 이러한 사건을 서로 테스트하여 유사성을 찾습니다. 이 경우 여러 위치에서 장애가 발생하는 동일한 모니터이므로 New Relic은 두 사건을 각각의 관련 이벤트를 포함하는 단일 문제로 병합합니다.

이벤트를 상호 연관시킬 때 모든 조합 쌍을 서로 확인하고 가능한 한 많이 조합합니다. 예를 들어:

* 우리의 알고리즘은 사건 A와 B를 연관시킵니다("AB"라고 부름).
* 우리의 알고리즘은 사건 B와 C를 연관시킵니다("BC"라고 부름).
* B가 두 문제에 모두 존재하기 때문에 알고리즘은 세 가지 사건을 모두 하나의 문제로 연관시킵니다.

## 상관 관계 정책 구성 [#configure-correlation]

[경고](/docs/alerts-applied-intelligence/overview/#concepts-terms)기반 문제에 대한 상관 관계를 활성화하려면 해당 [경고 정책](/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/create-edit-or-find-alert-policy/#alert-policy-name) 에 대한 상관 관계에 연결해야 합니다.

<img
  title="Decision - enable correlation for alert policy"
  alt="A screenshot of how to enable correlation for an alert policy."
  src="/images/alerts_screenshot-full_decision-policy-.webp"
/>

<figcaption>
  공지에 대한 상관관계를 활성화하려면 <DNT>**Correlate and suppress noise**</DNT> 확인란을 선택하세요.
</figcaption>

## 의사결정 유형 [#decision-types]

결정은 인시던트 인텔리전스가 문제를 서로 연관시키는 방식을 결정합니다. New Relic의 상관 관계 논리는 세 가지 의사 결정 유형으로 팀에서 사용할 수 있습니다.

* <DNT>
    **Global decision**
  </DNT>

  : 알림 사용을 시작하면 다양한 기본 결정이 자동으로 활성화됩니다.

* <DNT>
    **Suggested decision**
  </DNT>

  : 뉴렐릭의 상관관계 엔진은 이벤트 데이터를 지속적으로 평가하여 상관관계 패턴을 포착하여 노이즈를 줄이는 결정을 제안합니다. 제안된 결정의 시뮬레이션 결과를 미리 보고 활성화하도록 선택할 수 있습니다.

* <DNT>
    **Custom decision**
  </DNT>

  : 팀에서는 사용 사례에 따라 결정을 맞춤화하여 상관관계 효율성을 높일 수 있습니다. 뉴렐릭의 결정 UI 결정의 모든 차원을 구성할 수 있는 유연성을 제공합니다.

## 귀하의 적극적인 결정 검토 [#decisions]

팀의 기존 결정을 검토하려면:

1. <DNT>
     **[one.newrelic.com](https://one.newrelic.com/all-capabilities)> Alerts > Incident intelligence > Decisions**
   </DNT>

   으)로 이동합니다.

2. 활성 결정 목록을 검토합니다. 문제 간의 상관 관계를 생성하는 규칙 논리를 보려면 결정을 클릭하십시오.

3. 상관관계가 있는 결정의 예를 보려면

   <DNT>
     **Recent correlations**
   </DNT>

   탭을 클릭하세요.

4. 이러한 전역 결정을 활성화하거나 비활성화할 수 있는 옵션이 있습니다.

## 소스 구성 [#configure-sources]

결정을 구성하기 전에 상호 연관시킬 소스를 결정하는 것이 중요합니다. 소스는 데이터 입력입니다.

다음 소스에서 데이터를 얻을 수 있습니다.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="configure-source-nr-alerts"
    title="경고"
  >
    <InlinePopover type="alerts"/>정책에 대해 인시던트 인텔리전스를 활성화하면 모니터링 대상에 대한 컨텍스트와 상관관계를 얻을 수 있습니다. 알림에서 데이터를 가져오려면 다음 안내를 따르세요.

    1. <DNT>**[one.newrelic.com](https://one.newrelic.com/all-capabilities)**</DNT> 에서 <DNT>**Alerts**</DNT>) 클릭합니다.

    2. <DNT>**incident intelligence**</DNT> 아래 왼쪽에서 <DNT>**Sources**</DNT> 클릭한 다음 <DNT>**Alerts**</DNT> 클릭합니다.

    3. 알림에 연결할 정책을 선택하고 <DNT>**Connect**</DNT> 클릭합니다.

       공지사항을 추가하거나 이미 연결한 정책을 제거할 수 있습니다. <DNT>**Sources > Alerts**</DNT>.

       <Callout variant="tip">
         경고를 소스로 추가해도 현재 구성이나 알림에는 영향을 미치지 않습니다.
       </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="configure-aporia"
    title="아포리아(MLOps)"
  >
    사고 인텔리전스를 Aporia 기계 학습 모델과 통합하여 기계 학습 모델 성능을 모니터링할 수 있습니다. Aporia 통합을 구성하려면 [문서](/docs/integrations/mlops-integrations/aporia-mlops-integration/) 를 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="configure-aporia"
    title="슈퍼와이즈(MLOps)"
  >
    사고 인텔리전스를 Superwise 기계 학습 모델과 통합하여 기계 학습 모델 성능을 모니터링할 수 있습니다. Superwise 통합을 구성하려면 [문서](/docs/alerts-applied-intelligence/mlops/integrations/superwise-mlops-integration/) 를 참조하세요.
  </Collapser>

  <Collapser
    className="freq-link"
    id="configure-source-rest-api"
    title="REST API"
  >
    인시던트 인텔리전스는 추가 시스템과 통합할 수 있는 전용 REST API 인터페이스를 지원합니다. 인터페이스를 통해 코드 또는 기타 모니터링 솔루션을 계측하여 모든 종류의 메트릭 또는 이벤트를 보고할 수 있습니다.

    * 메트릭은 CPU, 메모리, 디스크 사용률 또는 비즈니스 KPI와 같은 원시 데이터 포인트일 수 있습니다.

    * 이벤트는 모니터링 경고, 배포 이벤트, 인시던트, 예외 또는 설명하려는 기타 상태 변경일 수 있습니다.

      또한 자체 시스템 또는 애플리케이션에서 직접 사고 인텔리전스로 모든 유형의 데이터를 보낼 수 있습니다. REST API는 보안 토큰 기반 인증을 지원하고 JSON 콘텐츠를 입력으로 받아들입니다.

      인증 및 전체 API 참조에 대한 자세한 내용은 [뉴렐릭 알림을 위한 REST API ](/docs/rest-api-new-relic-ai)참조하세요.
  </Collapser>
</CollapserGroup>

### 글로벌 의사결정 [#global-decisions]

팀이 알림을 사용하기 시작하면 글로벌 의사결정이 자동으로 활성화됩니다. 설정이 필요하지 않으며 팀에서 즉시 사용할 수 있습니다. 글로벌 의사결정은 다양한 상관관계 시나리오를 다룹니다.

아래 표는 자동으로 활성화되는 모든 전역 결정에 대한 설명을 제공합니다.

<table id="global-decision-descriptions">
  <thead>
    <tr>
      <th style={{ width: "250px" }}>
        결정 이름
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        동일한 New Relic 대상 이름(NRQL)
      </td>

      <td>
        임계값을 초과한 엔터티 이름과 NRQL 쿼리가 동일한 경우 상관 관계가 활성화됩니다. 동일한 [NRQL 경고 조건](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions) 의 관련 이벤트가 식별됩니다. 이 결정은 예를 들어 동일한 트랜잭션 쿼리 대기 시간 편차가 있는 문제를 관련시키는 데 도움이 됩니다.
      </td>
    </tr>

    <tr>
      <td>
        동일한 New Relic 대상 이름(NRQL이 아님)
      </td>

      <td>
        New Relic 비 NRQL 경고 임계값이 동일하기 때문에 상관 관계가 활성화됩니다. REST 소스에는 적용되지 않습니다. 비 NRQL 엔터티는 [엔터티](/docs/new-relic-solutions/new-relic-one/core-concepts/what-entity-new-relic/), 일반적으로 APPLICATION, HOST 유형을 나타냅니다. [엔터티 합성에 대한 New Relic GitHub 리포지토리를](https://github.com/newrelic/entity-definitions#entity-definitions) 참조하세요. 이 결정으로 동일한 엔터티의 관련 문제가 식별됩니다. 예를 들어 호스트 높은 메모리 문제와 호스트 미보고 문제는 동일한 원인으로 인해 발생할 가능성이 높습니다.
      </td>
    </tr>

    <tr>
      <td>
        동일한 New Relic 대상 ID
      </td>

      <td>
        New Relic 비 NRQL 경고 임계값이 동일하기 때문에 상관 관계가 활성화됩니다. REST 소스에는 적용되지 않습니다. 엔티티 ID를 사용하여 엔티티 인스턴스를 고유하게 식별합니다. [entity.guid](/docs/new-relic-solutions/new-relic-one/core-concepts/what-entity-new-relic#reserved-attributes) 에 대해 자세히 알아보세요.
      </td>
    </tr>

    <tr>
      <td>
        동일한 New Relic 조건
      </td>

      <td>
        New Relic [조건 ID가](/docs/new-relic-solutions/get-started/glossary/#condition_id) 동일하므로 상관관계가 활성화됩니다. 예를 들어, 관련 서비스의 CPU 사용량 증가는 동일한 CPU 사용량 조건에서 인시던트를 유발하여 식별됩니다. 이 논리는 조건 수준 세분성 및 상관 관계 시간 창 정의의 유연성으로 인해 조건당 하나의 문제에 대한 [경고 정책 문제 생성 기본 설정 옵션을](/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/specify-when-alerts-create-incidents/#preference-options) 넘어서는 가치가 있습니다.
      </td>
    </tr>

    <tr>
      <td>
        동일한 New Relic 조건 및 딥 링크 URL
      </td>

      <td>
        뉴렐릭 [조건 ID](/docs/new-relic-solutions/get-started/glossary/#condition_id) 와 딥링크 URL이 동일하기 때문에 상관관계가 활성화됩니다. 딥링크 URL은 [공지사항](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-alert-conditions/) 외에 시계열 및 시간 범위 정보를 제공합니다. 이러한 문제를 연관시키면 인시던트 반응 흐름에서 시간 범위 지표를 사용하여 관련 인시던트를 더 쉽게 살펴보고 심층 분석을 수행할 수 있습니다. 인시던트가 뉴렐릭 공지 조건에 의해 트리거되면 딥링크 URL이 자동으로 생성될 수 있지만, REST 소스의 경우 [deepLinkUrl을](/docs/data-apis/ingest-apis/event-api/incident-event-rest-api/#api-specs) 사용자가 정의해야 합니다.
      </td>
    </tr>

    <tr>
      <td>
        동일한 New Relic 상태 및 제목
      </td>

      <td>
        New Relic [조건 이름과 제목이](/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/incident-event-attributes/#attributes) 동일하므로 상관 관계가 활성화됩니다. 이는 제목과 조건을 비교하여 동일한 경고 메시지와의 관련성을 더욱 긴밀하게 드러내는 세련된 옵션입니다.
      </td>
    </tr>

    <tr>
      <td>
        동일한 k8s 배포
      </td>

      <td>
        Kubernetes 배포가 동일하기 때문에 상관 논리가 활성화됩니다. 많은 인시던트가 단일 배포 변경에서 발생합니다. 이 결정은 번거로운 Kubernetes 엔터티 배포와 동일한 문제를 줄이기 위한 것입니다.
      </td>
    </tr>

    <tr>
      <td>
        동일한 애플리케이션 이름, 정책 및 ID
      </td>

      <td>
        사용자 정의 응용 프로그램 이름, 정책 및 사용자 정의 ID가 동일하기 때문에 상관 논리가 활성화됩니다. 특히 맞춤형 태그 사용자를 대상으로 애플리케이션 문제를 줄이기 위해 이러한 요소와 문제를 연관시킵니다. [태그](/docs/new-relic-solutions/new-relic-one/core-concepts/use-tags-help-organize-find-your-data/) 에 대해 자세히 알아보세요. 사용자 정의 태그 ID는 조건 패밀리 ID 또는 데이터 간의 연결을 식별하는 키로 사용되는 기타 ID 값으로 정의할 수 있습니다.
      </td>
    </tr>

    <tr>
      <td>
        유사한 경고 메시지
      </td>

      <td>
        인시던트의 제목이 비슷하고 동일한 엔터티에서 발생하므로 상관 관계가 활성화됩니다. 이는 유사한 [경고 조건](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-alert-conditions/) 으로 인해 발생하는 동일한 엔터티의 문제를 줄이기 위한 것입니다.
      </td>
    </tr>

    <tr>
      <td>
        동일한 보안 자격 증명, 공개 위치 및 유형
      </td>

      <td>
        보안 자격 증명, 공개 위치 및 사용자 정의 유형이 각각 동일하므로 상관 관계가 활성화됩니다. 이는 동일한 지리적 위치/지역의 문제를 일반적으로 단일 근본 원인(예: 합성 모니터 오류)으로 인해 발생하는 동일한 보안 자격 증명과 연관시키고 동일한 솔루션으로 해결될 가능성이 매우 높습니다. 이 결정의 이점을 누리려면 [태그를 추가하세요](/docs/new-relic-solutions/new-relic-one/core-concepts/use-tags-help-organize-find-your-data/#add-tags) .
      </td>
    </tr>

    <tr>
      <td>
        유사한 문제 구조
      </td>

      <td>
        두 인시던트의 속성 구조와 데이터 내용이 유사하므로 상관관계가 활성화됩니다. 이는 클러스터링의 간단한 버전으로, 매우 관련성이 높은 문제를 줄이기 위해 행렬 계산에 고급 유사성 알고리즘을 채택합니다.
      </td>
    </tr>

    <tr>
      <td>
        위상 종속
      </td>

      <td>
        종속 관계가 있는 인스턴스에서 인시던트가 생성되므로 상관 관계가 활성화됩니다. [즉시 사용 가능한 토폴로지 상관 관계](#topology-requirements) 에 대해 자세히 알아보세요.
      </td>
    </tr>
  </tbody>
</table>

### 제안된 결정 사용 [#suggested-decisions]

선택한 소스의 데이터에 패턴이 있는지 지속적으로 검사하여 노이즈를 줄이는 데 도움이 됩니다. 데이터에서 패턴이 관찰되면 당사의 상관 관계 논리가 향후 이러한 유형의 이벤트를 상관시킬 수 있는 고유한 결정을 제안합니다.

시작하려면 <DNT>**Decisions**</DNT> UI 페이지 주제에서 <DNT>**Suggested decisions**</DNT> 탭을 클릭하세요. 제안된 결정의 논리와 각 제안된 결정을 클릭하면 예상 상관관계율을 확인할 수 있습니다.

<img
  title="Suggested decision block"
  alt="A screenshot of a suggested decision block"
  src="/images/alerts_screenshot-full_suggested-decisions.webp"
/>

<figcaption>
  <DNT>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts > Decisions**</DNT>: 의사결정 UI의 통계 예시입니다.
</figcaption>

제안된 결정을 활성화하려면 <DNT>**Add to your decisions**</DNT> 클릭하세요. 활성화되면 결정이 팀의 기본 결정 테이블에 표시됩니다. 제안된 모든 결정에는 작성자가 뉴렐릭 AI로 표시됩니다(이는 뉴렐릭 알림을 나타냄).

제안된 결정이 귀하의 요구사항과 관련이 없으면 <DNT>**Dismiss**</DNT> 클릭하세요.

## 맞춤 결정 만들기 [#customize]

사용자 정의 결정을 내려 노이즈를 줄이고 상관 관계를 개선할 수 있습니다. 결정을 내리려면 <DNT>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts > Decisions**</DNT> 으로 이동한 다음 <DNT>**Create new decision**</DNT> 클릭하세요.

의사 결정 빌더에는 두 가지 버전이 있습니다.

* 기본 의사 결정 작성기(미리 보기)
* 고급 의사 결정 빌더

이러한 의사 결정 도구를 사용하는 방법에 대한 자세한 내용은 계속 읽으십시오.

### 결정 요소 [#decision-elements]

결정은 다음 요소로 구성됩니다.

* 속성별 상관 관계: 속성의 유사점 또는 차이점을 기준으로 모든 인시던트를 연관시킵니다.
* 특정 값으로 필터링: 특정 값을 가진 인시던트로 범위를 좁힙니다.
* 관련 엔터티로 필터링: 찾고자 하는 공유 연결 또는 종속성의 종류를 선택합니다.
* 상관 관계 시간 범위: 상관 관계를 고려하기 위해 두 인시던트의 생성 시간 사이에 허용되는 최대 시간 차이를 설정합니다.

인시던트 간의 연결이 설정되면 당사의 [알고리즘은](#what-is-correlaton) 상관관계가 있는 인시던트를 단일 문제로 그룹화합니다.

### 기본 의사결정자 [#basic-decision-builder]

<DNT>**This feature is currently in preview and available for only some customers.**</DNT> 액세스 권한이 없는 경우 [고급 의사 결정 작성 도구](#advanced-decision-builder) 에 대한 지침을 참조하세요.

다음은 기본 의사 결정 작성 도구를 사용하는 방법을 보여주는 짧은 비디오(3분 25초)입니다.

<Video
  type="wistia"
  id="xmbcv8rhuu"
/>

기본 의사 결정 빌더는 대부분의 사용 사례를 다루고 상관 관계 일치에 대한 필터 조건을 지정할 수 있는 "속성별 상관 관계"에 중점을 둡니다. 상관 관계가 있는 두 인시던트에 특정 값에 대해 동일한 필터 논리를 적용할 수도 있습니다. 예를 들어 엔터티 이름이 둘 다 `host 1` 인 경우 인시던트를 연관시킬 수 있습니다.

기본 의사결정 빌더를 사용하여 사용자 정의 의사결정을 작성하려면 다음 단계를 완료하십시오. 1, 2, 3단계는 그 자체로는 선택 사항이지만 결정을 내리려면 3단계 중 적어도 하나를 정의해야 합니다.

#### 1단계: 속성별 상관관계 [#basic-correlate-attributes]

드롭다운 메뉴에서 속성을 선택합니다. 가장 인기 있는 옵션인 `equal` 연산자가 미리 선택되어 있거나 다른 [연산자를](#operators)선택할 수 있습니다.

두 번째 속성은 일반적으로 첫 번째 속성과 일치하므로 자동으로 채워집니다. 자동 입력 옵션을 유지하거나 다른 연산자를 선택할 수 있습니다.

완료되면 [시뮬레이션이](#simulations) 자동으로 실행됩니다.

이 단계를 반복하여 최대 8개의 로직 필터를 추가할 수 있습니다.

<CollapserGroup>
  <Collapser
    id="basic-correlate-attributes-ui"
    title="UI 스크린샷 보기"
  >
    <img
      title="A screenshot of the basic decision builder, correlating with attributes."
      alt="A screenshot of the basic decision builder, correlating with attributes."
      src="/images/alerts_screenshot-crop_basic-decision-builder-correlate-attributes.webp"
    />
  </Collapser>
</CollapserGroup>

#### 2단계: 특정 값으로 필터링 [#basic-filter-values]

1. `Filter by specific values` 섹션을 열고 추가 필터를 보려면

   <DNT>
     **See more options**
   </DNT>

   클릭하세요.

2. 속성을 선택합니다.

3. `equal` 연산자가 미리 선택되어 있거나 다른 [연산자를](#operators)선택할 수 있습니다.

4. 다중 선택이 지원되는 선택된 속성에 대한 예상 값을 선택하십시오.

완료되면 [시뮬레이션이](#simulations) 자동으로 실행됩니다.

이 단계를 반복하여 최대 8개의 로직 필터를 추가할 수 있습니다.

<CollapserGroup>
  <Collapser
    id="basic-builder-filer-values-ui"
    title="UI 스크린샷 보기"
  >
    <img
      title="A screenshot of the basic decision builder, filtering by values."
      alt="A screenshot of the basic decision builder, filtering by values."
      src="/images/alerts_screenshot-crop_basic-decision-builder-filter-values.webp"
    />
  </Collapser>
</CollapserGroup>

#### 3단계: 관련 엔터티로 필터링 [#basic-filter-related-entities]

<DNT>**Filter by related entities**</DNT> 클릭하고 엔터티 클래스를 선택합니다.

[New Relic 에이전트](/docs/new-relic-solutions/new-relic-one/install-configure/compatibility-requirements-new-relic-agents-products/)에서 데이터를 수집하면 자동 토폴로지 상관 관계가 생성됩니다. [기본 토폴로지 상관 관계에 대해 자세히 알아보십시오](#topology-requirements).

[NerdGraph API를 사용하여 토폴로지 설정을](/docs/apis/nerdgraph/examples/topology-nerdgraph-tutorial)설정할 수도 있습니다. 이를 통해 모든 토폴로지 관련 결정을 토폴로지 데이터와 일치시킬 수 있습니다. [토폴로지 상관 설정에 대해 자세히 알아보세요](#topology).

<CollapserGroup>
  <Collapser
    id="basic-builder-related-entities-ui"
    title="UI 스크린샷 보기"
  >
    <img
      title="A screenshot of the basic decision builder, filtering by entities."
      alt="A screenshot of the basic decision builder, filtering by entities."
      src="/images/alerts_screenshot-crop_basic-decision-builder-filter-related-entities.webp"
    />
  </Collapser>
</CollapserGroup>

#### 4단계: 상관 관계 시간 범위 설정 [#basic-set-time-range]

이것은 상관 관계를 고려하기 위해 두 인시던트의 생성 시간 사이에 허용되는 최대 시간 차이를 설정합니다. 이 범위 내의 인시던트는 지정된 규칙에 따라 평가되지만 범위 밖의 인시던트는 상관되지 않습니다.

시간 범위는 기본적으로 20분으로 설정됩니다. 1-120분 사이에서 조정할 수 있습니다.

<CollapserGroup>
  <Collapser
    id="basic-builder-time-range"
    title="UI 스크린샷 보기"
  >
    <img
      title="A screenshot of the basic decision builder, setting a correlation time range."
      alt="A screenshot of the basic decision builder, setting a correlation time range."
      src="/images/alerts_screenshot-crop_basic-decision-builder-time-range.webp"
    />
  </Collapser>
</CollapserGroup>

#### 5단계: 시뮬레이션을 사용하여 결정 테스트 [#basic-test-with-simulation]

필터 논리를 추가한 후 시스템은 지난 7일간의 사고 데이터를 사용하여 [시뮬레이션을](#simulations) 자동으로 실행합니다.

<DNT>**Simulate**</DNT> 클릭하여 시뮬레이션을 수동으로 트리거할 수도 있는데, 결정에서 변경된 사항이 있는 경우 수행할 수 있습니다.

<CollapserGroup>
  <Collapser
    id="basic-builder-test-with-simulation-ui"
    title="UI 스크린샷 보기"
  >
    <img
      title="A screenshot of the basic decision builder, testing with a simulation."
      alt="A screenshot of the basic decision builder, testing with a simulation."
      src="/images/alerts_screenshot-crop_basic-decision-builder-run-simulation.webp"
    />
  </Collapser>
</CollapserGroup>

#### 6단계: 결정 이름 지정 및 저장 [#basic-name-save-decision]

이름 및 설명 패널에 액세스하려면 <DNT>**Create decision**</DNT> 클릭합니다. 시스템은 귀하의 결정에 따라 이름을 생성합니다. 원하는 대로 이름과 설명을 사용자 정의합니다.

<CollapserGroup>
  <Collapser
    id="basic-builder-save-decision-ui"
    title="UI 스크린샷 보기"
  >
    <img
      title="A screenshot of the basic decision builder: naming and saving the decision"
      alt="A screenshot of the basic decision builder: naming and saving the decision"
      src="/images/alerts_screenshot-crop_basic-decision-builder-name-describe.webp"
    />
  </Collapser>
</CollapserGroup>

### 고급 의사 결정 빌더 [#advanced-decision-builder]

고급 의사 결정 빌더를 사용하면 서로 다른 논리 필터를 상관 관계에 있는 두 사건에 적용하여 더 복잡한 의사 결정을 내릴 수 있습니다. 예를 들어 하나의 엔터티 이름이 `host 1` 이고 다른 하나의 엔터티 이름이 `host 2`인 경우 인시던트를 연관시킬 수 있습니다. 시간 창만 구성할 수 있는 것 외에 고급 설정도 있습니다.

고급 의사결정 작성기를 사용하려면 다음을 수행하십시오.

1. <DNT>
     **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts > Decisions**
   </DNT>

   으)로 이동합니다.

2. <DNT>
     **Create new decision**
   </DNT>

   클릭한 다음

   <DNT>
     **Use advanced builder**
   </DNT>

   클릭합니다.

사용 가능한 옵션에 대한 자세한 내용은 계속 읽으십시오.

중요 용어:

* 논리 필터:[속성](#operators) 에 대한 [연산자 로](/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/incident-event-attributes/#attributes) 정의된 논리 조건입니다.
* 세그먼트: 논리 필터 조합을 충족하는 인시던트 그룹입니다.

사용자 정의 결정을 작성하려면 다음 단계를 완료하십시오. 1, 2, 3단계는 그 자체로 선택 사항이지만 결정을 내리려면 세 가지 중 하나 이상을 정의해야 합니다.

#### 1단계: 데이터 필터링 [#filter-data]

상관 관계는 두 인시던트 간에 발생합니다. 필터가 정의되지 않은 경우 들어오는 모든 인시던트가 결정에 고려됩니다. 필요에 맞게 의사 결정을 더 많이 구성할수록 사고를 더 잘 연관시키고 노이즈를 줄이며 대기 중인 팀에 더 많은 컨텍스트를 제공할 수 있습니다.

팀은 인시던트의 첫 번째 세그먼트와 인시던트의 두 번째 세그먼트에 대한 필터를 정의할 수 있습니다. 필터 [연산자](#operators) 는 하위 문자열 일치에서 [정규식 일치](#regex) 에 이르기까지 다양하여 원하는 사건 이벤트를 대상으로 지정하고 원하지 않는 사건을 제외하는 데 도움이 됩니다.

<CollapserGroup>
  <Collapser
    id="advanced-decision-builder-filter-data-ui"
    title="UI 스크린샷 보기"
  >
    <img
      title="A screenshot of the advanced decision builder: filter your data"
      alt="A screenshot of the basic decision builder: filter your data"
      src="/images/alerts_screenshot-crop_advanced-decision-builder-filter-data.webp"
    />
  </Collapser>
</CollapserGroup>

#### 2단계: 속성별 상관 관계 [#correlate-context]

데이터를 필터링한 후에는 인시던트 컨텍스트를 비교할 때 사용되는 논리를 정의하십시오. 다음 방법을 기반으로 이벤트를 연관시킬 수 있습니다.

* 표준 연산자를 사용한 속성 값 비교
* [유사성 알고리즘](#algorithms) 을 사용한 속성 값 유사성
* [캡처 그룹이 있는 속성 값 정규식](#regex)
* 유사성 또는 클러스터링 알고리즘을 사용한 전체 사고 비교

<CollapserGroup>
  <Collapser
    id="advanced-decision-builder-correlate-attributes-ui"
    title="UI 스크린샷 보기"
  >
    <img
      title="A screenshot of the advanced decision builder: correlate by attributes"
      alt="A screenshot of the basic decision builder: correlate by attributes"
      src="/images/alerts_screenshot-crop_advanced-decision-builder-correlate-attributes.webp"
    />
  </Collapser>
</CollapserGroup>

#### 3단계: 관련 엔터티별 상관 관계 [#topology-correlation]

자동 토폴로지 상관 관계를 위해 [New Relic 에이전트](/docs/new-relic-solutions/new-relic-one/install-configure/compatibility-requirements-new-relic-agents-products/) 에서 원격 측정 데이터를 수집해야 합니다. [기본 제공되는 토폴로지 상관 관계](#topology-requirements) 에 대해 자세히 알아보십시오.

[NerdGraph API를 사용하여 토폴로지 설정을](/docs/apis/nerdgraph/examples/topology-nerdgraph-tutorial)설정할 수도 있습니다. 이를 통해 모든 토폴로지 관련 결정을 토폴로지 데이터와 일치시킬 수 있습니다. [토폴로지 상관 설정에 대해 자세히 알아보세요](#topology).

<CollapserGroup>
  <Collapser
    id="advanced-builder-related-entities-ui"
    title="UI 스크린샷 보기"
  >
    <img
      title="A screenshot of the advanced decision builder: correlate by related entities"
      alt="A screenshot of the basic decision builder: correlate by related entities"
      src="/images/alerts_screenshot-crop_advanced-decision-builder-related-entities.webp"
    />
  </Collapser>
</CollapserGroup>

#### 4단계: 이름 지정 [#name-your-decision]

결정 논리를 구성한 후 인식할 수 있는 이름과 설명을 지정합니다.

<Callout variant="tip">
  이러한 열린 텍스트 필드에 민감하거나 개인 정보를 추가하지 않도록 하여 보안 문제를 최소화하십시오.
</Callout>

이는 공지 및 UI 의 다른 영역에서 어떤 결정으로 인해 인시던트 쌍이 서로 연관되었는지 나타내는 데 사용됩니다. 다음 단계에서 기본 고급 설정을 업데이트하지 않으려면 <DNT>**Create decision**</DNT> 클릭하여 생성을 완료하세요.

<CollapserGroup>
  <Collapser
    id="advanced-builder-name-decision"
    title="UI 스크린샷 보기"
  >
    <img
      title="A screenshot of the advanced decision builder: name decision"
      alt="A screenshot of the basic decision builder: name decision"
      src="/images/alerts_screenshot-crop_advanced-decision-builder-name-decision.webp"
    />
  </Collapser>
</CollapserGroup>

#### 5단계: 고급 설정 사용 [#advanced-settings]

고급 설정 영역을 사용하여 이벤트를 연관시킬 때 결정이 작동하는 방식을 추가로 사용자 정의하십시오. 각 설정에는 기본값이 있으므로 사용자 지정은 선택 사항입니다.

* <DNT>
    **Time window**
  </DNT>

  : 상관 관계에 적합하도록 두 인시던트가 생성된 시간 사이의 최대 시간을 설정합니다.

* <DNT>
    **Issue priority**
  </DNT>

  : 인시던트가 상관된 경우 더 높거나 낮은 우선순위를 추가하기 위해 기본 우선순위 설정(`inherit priority`)을 재정의합니다.

* <DNT>
    **Frequency**
  </DNT>

  : 트리거할 결정에 대한 결정 논리를 충족해야 하는 최소 인시던트 수를 수정합니다.

* <DNT>
    **Similarity**
  </DNT>

  : 결정 논리에 `similar to` 연산자를 사용하는 경우 알고리즘 목록에서 선택하고 민감도를 설정할 수 있습니다. 이는 귀하가 결정한 모든 `similar to` 연산자에 적용됩니다.

<CollapserGroup>
  <Collapser
    id="advanced-builder-advanced-settings-ui"
    title="UI 스크린샷 보기"
  >
    <img
      title="Decision - advanced settings"
      alt="A screenshot of the decision builder showing how to configure advanced settings."
      src="/images/alerts_screenshot-full_decision-builder-settings.webp"
    />
  </Collapser>
</CollapserGroup>

## 논리 연산자 [#operators]

Decision은 인시던트의 속성 값이 논리 필터에서 평가되는 방식을 유연하게 정의하는 데 도움이 되는 일련의 연산자를 제공합니다. 기본적인 것들은 <DNT>**equals**</DNT>, <DNT>**contains**</DNT>, <DNT>**starts with**</DNT>, <DNT>**ends with**</DNT>, <DNT>**exists**</DNT> 이며 그에 따른 부정 연산자입니다. 예를 들어, <DNT>**does not equal**</DNT>.

유사성 연산자 <DNT>**is similar to**</DNT> 이 있으며, 이 연산자에 대해 기본 [유사성 알고리즘을](#algorithms) 지정할 수 있습니다. 기본적으로 Levenshtein Distance를 사용합니다.

<DNT>**contains (regex)**</DNT> 연산자를 사용하면 [정규식](#regex) 조건을 정의할 수 있습니다. 임의의 데이터 값을 일치시키는 데 강력합니다.

### 유사성 알고리즘 [#algorithms]

다음은 우리가 사용하는 유사성 알고리즘에 대한 기술적인 세부 사항입니다.

<CollapserGroup>
  <Collapser
    id="levenshtein-distance"
    title="레벤슈타인 거리"
  >
    이 측정값은 호스트 이름과 같은 고정 스키마 및 고정 길이가 있는 짧은 문자열을 비교하는 데 유용합니다. 레벤슈타인 거리는 편집 거리라고도 합니다.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            세부
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            작동 원리
          </td>

          <td>
            두 문자열 사이의 Levenshtein 거리는 한 문자열에서 다른 문자열로 가져오기 위한 단일 문자 편집의 최소 수입니다. 허용되는 편집 작업은 삭제, 삽입 및 대체입니다.

            공지 결정에 대한 기본 유사성 노인값은 편집 거리 3입니다. 의사결정 작성기의 <DNT>**Advanced mode**</DNT> 에서 이를 변경할 수 있습니다.
          </td>
        </tr>

        <tr>
          <td>
            사용할 때
          </td>

          <td>
            이 측정은 상대적으로 짧은 문자열을 정적 스키마 및 고정 길이와 비교할 때 가장 유용합니다. 일반적인 응용 프로그램에는 맞춤법 검사기, 컴퓨터 생물학 및 음성 인식이 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            예
          </td>

          <td>
            `number/bumble: 3 (number → bumber → bumblr → bumble)`

            `trying/lying: 2 (trying → rying → lying)`

            `strong/through: 4 (strong → htrong → throng → throug → through)`
          </td>
        </tr>

        <tr>
          <td>
            잠재적인 단점
          </td>

          <td>
            levenshtein distance 알고리즘은 기본적으로 문자열 길이를 고려하도록 정규화되지 않습니다.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="fuzzy-score"
    title="퍼지 점수"
  >
    이 메트릭은 동일한 접두사가 상관 관계의 좋은 지표가 되는 동일한 길이의 문자열을 비교하는 데 유용합니다.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            세부
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            작동 원리
          </td>

          <td>
            퍼지 점수 알고리즘은 문자열 간의 문자 일치에 대해 "점"을 할당하여 작동합니다.

            * 일치하는 각 문자에 대해 1점

            * 후속 경기에 대한 2개의 보너스 포인트

              퍼지 점수가 높을수록 두 문자열 간의 유사도가 커집니다.
          </td>
        </tr>

        <tr>
          <td>
            사용할 때
          </td>

          <td>
            퍼지 점수는 동일하고 비교적 짧은 접두사(이상적으로는 5자 미만)가 있는 문자열에 가장 유용합니다. 최소 보장 점수는 `(length(expected prefix) * 3) - 2` 입니다.
          </td>
        </tr>

        <tr>
          <td>
            예
          </td>

          <td>
            예시: `Decisions / dcsions`

            `d: 1`

            `c: 1`

            `i 1`

            `s: 2`

            `o: 1`

            `n: 1`

            `si: 2`

            `io: 2`

            `on: 2`

            `ns: 2`

            `= 15 points`
          </td>
        </tr>

        <tr>
          <td>
            잠재적인 단점
          </td>

          <td>
            첫 번째 문자열의 첫 번째 문자를 두 번째 문자열에서 찾을 수 없으면 점수가 부여되지 않습니다.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="fuzzy-wuzzy-ratio"
    title="퍼지 퍼지 비율"
  >
    이 메트릭은 길이가 비슷한 문자열을 비교하는 데 유용합니다.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            세부
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            작동 원리
          </td>

          <td>
            <DNT>**fuzzy wuzzy**</DNT> 유사성 측정 계열은 여러 플랫폼에서 서로 다른 레이블이 있는 동일한 이벤트에 대한 지원 케이스를 찾는 데 도움이 되도록 [SeatGeek에서 개발](https://chairnerd.seatgeek.com/fuzzywuzzy-fuzzy-string-matching-in-python/) 했습니다. 두 문자열의 퍼지 워지 비율은 백분율로 표시되며 숫자가 높을수록 문자열이 더 유사함을 나타냅니다. 이는 Python difflib의 [SequenceMatcher 알고리즘을](https://docs.python.org/3/library/difflib.html) 기반으로 합니다.
          </td>
        </tr>

        <tr>
          <td>
            사용할 때
          </td>

          <td>
            퍼지 wuzzy 비율은 매우 짧은 문자열(예: 호스트 이름) 또는 매우 긴 문자열(예: 이벤트 설명), 특히 유사한 길이의 문자열을 비교할 때 효과적입니다.
          </td>
        </tr>

        <tr>
          <td>
            잠재적인 단점
          </td>

          <td>
            이 알고리즘은 3-10 단어 문자열에 대해 효과적으로 사용하기에는 너무 민감합니다. 퍼지 wuzzy에 대한 다른 수정 사항 중 하나(아래 참조)가 더 나은 선택일 수 있습니다.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="fuzzzy-wuzzy-partial"
    title="퍼지 wuzzy 부분 비율"
  >
    이 메트릭은 길이가 다른 문자열을 비교하는 데 유용합니다. 퍼지 wuzzy 알고리즘에 대한 이러한 수정은 유효 길이 제한을 해결하는 데 도움이 됩니다.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            세부
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            작동 원리
          </td>

          <td>
            퍼지 wuzzy 부분 비율을 사용하면 더 짧은 문자열이 더 긴 문자열 내에서 동일한 길이의 각 하위 문자열과 비교됩니다. "가장 일치하는" 부분 문자열의 점수는 퍼지 부분 비율을 결정하는 데 사용됩니다.
          </td>
        </tr>

        <tr>
          <td>
            사용할 때
          </td>

          <td>
            퍼지 wuzzy 부분 비율은 기본 fuzzy wuzzy 알고리즘이 실패하는 비교 유형에 특히 효과적입니다. 일부 중요한 하위 문자열이 겹칠 가능성이 있는 3-10단어 문자열.
          </td>
        </tr>

        <tr>
          <td>
            예
          </td>

          <td>
            예를 들어 다음 문자열 사이:

            `DevOps and SRE teams`

            `DevOps`

            `DevOps` (짧은 문자열, 길이 = 6)은 `DevOps and SRE teams` 내에서 길이가 6인 각 하위 문자열과 비교됩니다. 이러한 부분 문자열( `DevOps` ) 중 하나가 완벽하게 일치하므로 이 두 문자열에 대한 퍼지 wuzzy 부분 비율이 높을 것입니다.
          </td>
        </tr>

        <tr>
          <td>
            잠재적인 단점
          </td>

          <td>
            퍼지 wuzzy가 너무 보수적일 수 있는 경우, fuzzy wuzzy 부분 일치는 상관 관계에 대해 예상보다 더 자유로울 수 있습니다. 필요에 따라 의사결정 작성기에서 임계값을 조정할 수 있습니다.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="fuzzy-wuzzy-token"
    title="퍼지 wuzzy 토큰 설정 비율"
  >
    이 메트릭은 정보의 순서가 다르고 길이가 다를 수 있는 문자열을 비교하는 데 유용합니다. 메시지, 설명 등과 같은 문장에 가장 적합합니다.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            세부
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            작동 원리
          </td>

          <td>
            토큰 집합 비율 알고리즘은 문자열을 비교하는 몇 가지 단계를 따릅니다.

            1. 각 문자열(예: "DevOps 및 SRE 팀"을 "DevOps" "및" "SRE" "팀"으로, "SRE 팀 및 DevOps 엔지니어"를 "SRE" "팀" "및" "DevOps" "엔지니어"로 토큰화 )
            2. 교차 토큰을 새 문자열로 결합하고 나머지 토큰은 남겨둡니다(예: 교차: "DevOps", "and", "SRE"; 나머지1: "팀"; 나머지2: "팀", "엔지니어").
            3. 각 토큰 그룹을 알파벳순으로 지정(예: "및, DevOps, SRE", "팀", 엔지니어, 팀")
            4. 다음 문자열 쌍을 비교하십시오.
            5. 교차로 그룹
            6. 교차 그룹 + 나머지1
            7. 교차 그룹 + 나머지2

               이러한 쌍("가장 일치")의 비교는 퍼지 wuzzy 토큰 세트 비율입니다.
          </td>
        </tr>

        <tr>
          <td>
            사용할 때
          </td>

          <td>
            이 메트릭은 유사한 문자열에 겹치는 단어가 있지만 구성이 다른 경우에 유용합니다. 예를 들어, 동일한 리소스에 대한 다양한 문제에 대한 이벤트 설명입니다.
          </td>
        </tr>

        <tr>
          <td>
            잠재적인 단점
          </td>

          <td>
            퍼지 wuzzy가 너무 보수적일 수 있는 경우 퍼지 wuzzy 토큰 집합 일치는 상관 관계에 대해 예상보다 더 자유로울 수 있습니다. 필요에 따라 의사결정 작성기에서 임계값을 조정할 수 있습니다.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="Jaro-winkler-distance"
    title="자로윙클러 거리"
  >
    이 메트릭은 동일한 접두사가 상관 관계의 강력한 표시인 짧은 문자열에 유용합니다.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            세부
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            작동 원리
          </td>

          <td>
            이 메트릭은 0-1의 척도를 사용하여 두 문자열 간의 유사성을 나타냅니다. 여기서 0은 유사성이 없고(0은 문자열 간에 일치하는 문자) 1은 정확히 일치합니다. Jaro-Winkler 유사성은 다음을 고려합니다.

            * `matching`: 문자열에서 동일하고 유사한 위치에 있는 두 문자.
            * `transpositions`: 문자열에서 시퀀스 순서가 다른 일치하는 문자.
            * `prefix scale`: 처음부터 문자열이 일치하면 Jaro-Winkler 거리가 적절하게 조정됩니다(접두사는 최대 4자).
          </td>
        </tr>

        <tr>
          <td>
            사용할 때
          </td>

          <td>
            이 메트릭은 조옮김에 상당히 관대하지만 문자열에서 더 멀리 떨어진 조옮김은 덜 유용합니다.

            중간에서 긴 문자열에서 Jaro-Winkler 유사성에 사용하기에 일반적으로 안전한 숫자는 0.9입니다. 더 관대한 경우에 `{~}0.85` 을 사용할 수 있습니다(예: 결정에 더 구체적인 다른 논리가 있는 경우).
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="cosine-distance"
    title="코사인 거리"
  >
    이 측정은 큰 텍스트 블록(예: 사건 설명)을 비교하는 데 가장 일반적으로 사용되며 유사성을 쉽게 시각화할 수 있습니다.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            세부
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            작동 원리
          </td>

          <td>
            비교하는 각 텍스트 블록에 대해 블록의 각 고유 단어 수를 나타내는 벡터가 계산됩니다. 결과 벡터의 코사인 거리는 내적을 크기의 곱으로 나눈 값입니다.
          </td>
        </tr>

        <tr>
          <td>
            사용할 때
          </td>

          <td>
            이 측정값은 긴 텍스트 블록을 비교하는 데 가장 유용하며, 특히 비교가 개별 단어의 차이나 철자가 아닌 텍스트 전체를 고려하려는 경우에 가장 유용합니다.
          </td>
        </tr>

        <tr>
          <td>
            예
          </td>

          <td>
            ```
            It is not length of life, but depth of life.
            Depth of life does not depend on length.
            ```

            다음은 이 문장의 단어 수입니다.

            `it 1 0`

            `is 0 1`

            `not 1 1`

            `length 1 1`

            `of 2 1`

            `life 2 1`

            `but 1 0`

            `depth 1 1`

            `does 0 1`

            `depend 0 1`

            `on 0 1`

            다음은 벡터로 표시되는 카운트입니다.

            ```
            [1, 0, 1, 1, 2, 2, 1, 1, 0, 0, 0]
            [0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]
            ```

            이러한 벡터의 코사인 거리는 약 0.9입니다(1이 가장 높은 유사도).
          </td>
        </tr>

        <tr>
          <td>
            잠재적인 단점
          </td>

          <td>
            코사인 거리는 단어의 작은 문자 차이가 중요하지 않은 상황에서는 덜 유용합니다. 또한 코사인 거리는 텍스트 블록의 단어 순서를 무시합니다.
          </td>
        </tr>
      </tbody>
    </table>

    코사인 거리 구현에 대한 자세한 내용 [은 blog.christianperone.com에서 자세한 연습을](http://blog.christianperone.com/2013/09/machine-learning-cosine-similarity-for-vector-space-models-part-iii/) 참조하십시오.
  </Collapser>

  <Collapser
    id="hamming-distance"
    title="해밍 거리"
  >
    이 측정값은 정적 스키마가 있는 더 짧은 텍스트에 유용하지만 동일한 길이의 문자열에만 작동합니다.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            세부
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            사용할 때
          </td>

          <td>
            해밍 거리는 비교되는 문자열의 길이가 같아야 합니다. 이는 두 문자열 간의 차이가 오타로 인한 것일 수 있는 상황 또는 알려진 길이의 두 속성을 비교하려는 상황에 유용한 유사성 메트릭입니다. 예를 들어:

            ```
            Low Disk Space in application myapp in data center us01
            ```

            데이터센터 변경 사항을 허용하려면 해밍 거리를 4로 설정해야 합니다. 해밍 거리의 평균 사용 사례는 약 2-3입니다.
          </td>
        </tr>

        <tr>
          <td>
            예
          </td>

          <td>
            Levenshtein distance와 같은 "edit distance" 메트릭의 더 간단한 버전인 두 문자열 사이의 Hamming 거리는 문자열에서 일치하지 않는(같은 위치의) 문자 수입니다. 예를 들어 아래 문자열에서 해밍 거리는 2입니다.

            ```
            flowers / florets
            ```
          </td>
        </tr>

        <tr>
          <td>
            잠재적인 단점
          </td>

          <td>
            위 예에서는 데이터센터 대신에 서명 이름이 변경되면 상관 관계도 생성됩니다. 거리가 증가할수록 Hamming Distance의 유용성은 급락합니다. 이러한 이유로 1-2개의 문자 대체를 허용하는 것보다 훨씬 더 복잡한 경우(또는 문자열 길이가 일치하지 않는 경우) 다른 유사성 측정을 사용하십시오.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="Jaccard-distance"
    title="자카드 거리"
  >
    이 측정값은 설명이나 전체 사건과 같은 큰 텍스트 블록을 비교하는 데 유용합니다.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            세부
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            작동 원리
          </td>

          <td>
            백분율로 표시된 거리(0은 완전히 유사, 1은 완전히 다름)는 다음 공식으로 계산됩니다.

            ```
            1 - [(# of characters in both sets) / (# of characters in either set) * 100]
            ```

            즉, 자카드 거리는 공유 캐릭터 수를 총 캐릭터 수(공유 및 비공유)로 나눈 값입니다. 자카드 거리가 0.1이면 두 사건 사이에 10% 이하의 문자가 다르다는 것을 의미합니다.
          </td>
        </tr>

        <tr>
          <td>
            사용할 때
          </td>

          <td>
            자카드 거리는 해석하기가 매우 쉽고 특히 큰 데이터 세트가 있는 경우에 유용합니다. 예를 들어, 두 개의 전체 사건 간의 유사성을 비교할 때(하나의 속성과 반대).
          </td>
        </tr>

        <tr>
          <td>
            잠재적인 단점
          </td>

          <td>
            작은 데이터 세트나 누락된 데이터가 있는 상황에서는 덜 효과적입니다. 또한 문자 집합의 다른 순열은 Jaccard 거리에 영향을 미치지 않으므로 오탐을 방지하도록 주의하십시오.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

### 정규식 연산자 [#regex]

[의사결정](#customize) 을 작성할 때 사용 가능한 연산자는 다음과 같습니다.

* `contains (regex)`: [1단계: 데이터 필터링](#customize) 에서 사용됩니다.
* `regular expression match`: [2단계: 문맥 상관 관계](#customize) 에서 사용됩니다.

의사 결정 작성기 [는 정규 표현식에 대해 이 문서에](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html) 설명된 표준을 따릅니다.

<CollapserGroup>
  <Collapser
    id="regex-step-1"
    title="1단계의 정규식"
  >
    정규식이 true로 테스트되려면 전체 속성 값(평가 중인 데이터)이 제공된 정규 표현식과 일치해야 합니다. 캡처된 그룹을 사용할 수 있지만 명시적으로 평가되지는 않습니다.

    예를 들어 속성 값이 `foobarbaz` 인 경우 다음 예는 기준을 충족하고 true로 테스트됩니다.

    * `foo.*`
    * `^.*baz`
    * `\w+`
  </Collapser>

  <Collapser
    id="regex-step-2"
    title="2단계의 정규식"
  >
    정규식을 true로 테스트하려면 인시던트 1 및 인시던트 2의 전체 속성 값이 일치에 포함되어야 합니다. 또한 캡처된 각 그룹( `( )` 괄호 안의 표현식)은 두 값(인시던트 1 및 인시던트 2 속성)에 모두 존재해야 하며 동일한 값을 가져야 합니다.

    * 캡처된 그룹의 수는 두 인시던트 속성에 대해 동일해야 합니다.

    * 각 그룹은 속성 값 사이의 해당 그룹과 같아야 합니다. 인시던트 1 속성 값의 첫 번째 캡처된 그룹 값은 인시던트 2 속성의 첫 번째 캡처된 그룹 값과 동일해야 합니다.

      예를 들어 속성 값 1이 `abc-123-xyz` 이고 속성 값 2가 `abc-777-xyz` 이면 `(\w+)-(?:\w+)-(\w+)` 는 다음 기준을 충족합니다.

    * 전체 값은 표현식과 일치합니다.

    * 첫 번째 및 세 번째 캡처된 그룹은 각각 동일한 값을 갖습니다.

    * 두 번째 그룹은 전체 값이 일치하도록 허용하지만 캡처 그룹 비교에 사용되지 않는 `?:` 을 사용하여 캡처되지 않습니다.
  </Collapser>

  <Collapser
    id="flags"
    title="플래그 정보"
  >
    기본적으로 활성화된 플래그가 없습니다. 의사 결정 작성기의 정규식에 포함할 몇 가지 유용한 플래그는 다음과 같습니다.

    * CASE_INSENSITIVE: (?i)

    * 멀티라인: (?m)

    * 점: (?s)

      이러한 각 플래그의 기능 및 구현에 대한 자세한 내용은 [Oracle의 필드 세부 문서](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#field.detail) 를 참조하십시오.
  </Collapser>
</CollapserGroup>

## 상관 도우미 [#assistant]

상관 관계 도우미를 사용하여 보다 빠르게 [인시던트](/docs/alerts-applied-intelligence/new-relic-alerts/get-started/alerts-ai-overview-page/#incidents) 를 분석하고, 의사 결정 논리를 만들고, 시뮬레이션을 통해 논리를 테스트할 수 있습니다. 상관 도우미를 사용하려면:

1. <DNT>
     **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts > Issues & activity > Incidents**
   </DNT>

   탭으로 이동하세요.

2. 연관시키려는 인시던트의 확인란을 선택하세요. 그런 다음 인시던트 목록 하단에서

   <DNT>
     **Correlate incidents**
   </DNT>

   클릭합니다.

3. 인시던트 상관에 대한 최상의 결과를 얻으려면 빈도 비율이 낮은 공통 속성을 선택하십시오. [빈도 사용에 대해 자세히 알아보세요](#frequency-tips) .

4. 새로운 결정이 데이터의 마지막 주에 미칠 영향을 확인하려면

   <DNT>
     **Simulate**
   </DNT>

   클릭하세요.

5. 사용할 상관 관계를 결정하려면 상관 쌍의 예를 클릭하십시오.

6. 시뮬레이션된 내용이 마음에 들면

   <DNT>
     **Next**
   </DNT>

   클릭한 다음 결정 내용을 지정하고 설명하세요.

7. 시뮬레이션 결과에 너무 많은 잠재적 인시던트가 표시되면 결정에 대해 다른 속성 및 인시던트 세트를 선택하고 다른 시뮬레이션을 실행할 수 있습니다. [시뮬레이션에 대해 자세히 알아보십시오](#simulations) .

<CollapserGroup>
  <Collapser
    id="frequency-tips"
    title="속성 분석"
  >
    두 가지 유형의 속성 분석이 UI에 나타납니다.

    * <DNT>**Common attributes:**</DNT> 이 분석은 선택한 모든 인시던트 간에 정확히 동일한 속성과 값을 강조합니다.

    * <DNT>**Similar attributes:**</DNT> 유사성 분석은 거리가 3인 Levenshtein 알고리즘을 사용하여 3개 이하의 문자 변경이 수행될 경우 값이 동일할 속성을 찾습니다. 숫자 값과 단일 문자 값은 결과에서 필터링됩니다. 유사 속성은 2개의 인시던트를 선택해야 하며, 3개 이상의 인시던트를 선택한 경우 유사성 분석을 수행하지 않습니다.

      최선의 결정을 내리려면 인시던트에서 빈도가 낮은 공통 속성을 선택하는 것이 좋습니다. 다음은 저주파 또는 고주파 속성 선택이 결정에 미치는 영향을 이해하기 위한 팁입니다.

    * <DNT>**Low frequency:**</DNT> 예를 들어 빈도 열에서 0%가 있는 속성은 고유 식별자이거나 지난 달 데이터에서 최근에 보고된 속성일 가능성이 높습니다. 낮은 빈도 속성을 선택하면 소수의 이벤트와 상관 관계가 있을 수 있습니다.

    * <DNT>**High frequency:**</DNT> 반면에 빈도가 100%인 속성은 모든 데이터에 존재하는 속성입니다. 이러한 속성을 선택하면 모든 이벤트가 서로 연관됩니다.

      기본적으로 속성은 최소 빈도로 정렬됩니다. 속성의 빈도 백분율을 클릭하면 지난 달에 해당 속성에 대해 보고된 값의 분포에 대한 정보를 얻을 수 있습니다.
  </Collapser>
</CollapserGroup>

### 시뮬레이션 사용 [#simulations]

시뮬레이션은 데이터의 마지막 주에 대해 논리를 테스트하고 얼마나 많은 상관 관계가 발생했는지 보여줍니다. 시뮬레이션할 때 표시되는 결정 미리보기 정보의 분석은 다음과 같습니다.

* <DNT>
    **Potential correlation rate:**
  </DNT>

  이 결정이 영향을 미쳤을 테스트된 비율입니다.

* <DNT>
    **Total created incidents:**
  </DNT>

  이 결정으로 테스트된 인시던트의 수입니다.

* <DNT>
    **Total estimated correlated incidents:**
  </DNT>

  이 결정의 추정 인시던트 수는 상관관계가 있을 것입니다.

* <DNT>
    **Incident examples:**
  </DNT>

  규칙의 속성과 값은 물론 각 쌍의 기타 인기 있는 속성을 포함하여 결정이 상호 연관되었을 인시던트 쌍의 목록입니다. 인시던트를 클릭하시면 자세한 내용을 보실 수 있습니다.

원하는 결과를 얻을 때까지 필요한 만큼 다양한 속성으로 시뮬레이션을 실행하십시오. 준비가 되면 UI 프롬프트에 따라 결정을 저장합니다.

## 토폴로지 상관 관계 [#topology]

뉴렐릭 알림의 경우 토폴로지는 서비스 맵, 즉 리소스의 서비스와 리소스가 서로 어떻게 관련되어 있는지를 나타냅니다.

의사결정 사용자의 경우 [기본 토폴로지 의사결정](#global-decisions) 이 계정에 추가되고 활성화됩니다. 또한 [사용자 지정 결정을 생성](#customize) 할 수 있는 옵션이 있습니다.

우리의 토폴로지 상관 관계는 사건 소스 간의 관계를 찾아 [사건](/docs/alerts-applied-intelligence/new-relic-alerts/get-started/alerts-ai-overview-page/#incidents) 과 그에 따른 각각의 문제가 상관되어야 하는지 여부를 결정합니다. 토폴로지 상관 관계는 상관 관계의 품질과 발견 속도를 개선하도록 설계되었습니다.

### 요구 사항 [#topology-requirements]

토폴로지 그래프를 명시적으로 설정할 필요 없이 자동 토폴로지 상관 관계를 사용하려면 [New Relic 에이전트](/docs/new-relic-solutions/new-relic-one/install-configure/compatibility-requirements-new-relic-agents-products/) 에서 원격 측정 데이터를 수집해야 합니다. 서비스 및 환경에 더 많은 유형의 New Relic 에이전트가 설치될수록 인시던트를 연관시키기 위한 토폴로지 결정 기회가 더 많아집니다.

### 토폴로지 상관 관계는 어떻게 작동합니까? [#topology-explained]

<img
  title="topology-4.png"
  alt="A screenshot of New Relic topology explained"
  src="/images/alerts_diagram_topology-4.webp"
/>

<figcaption>
  이 서비스 맵에서 호스트와 앱은 꼭짓점이고 관계를 나타내는 선은 가장자리입니다.
</figcaption>

[New Relic 에이전트](/docs/new-relic-solutions/new-relic-one/install-configure/compatibility-requirements-new-relic-agents-products/) 가 수집한 [엔티티 및 관계](/docs/new-relic-solutions/new-relic-one/core-concepts/what-entity-new-relic/) 외에 토폴로지를 설정하려면 [NerdGraph API](#create-topology-graph) 를 사용하십시오.

사용자 정의 토폴로지 상관 관계는 다음 두 가지 주요 개념에 의존합니다.

* <DNT>
    **Vertex:**
  </DNT>

  정점은 모니터링되는 엔터티를 나타냅니다. 인시던트 이벤트가 발생했거나 문제가 있는 증상을 설명하는 소스입니다. 정점에는 엔터티 GUID 또는 기타 ID와 같이 구성된 속성(핵심 값 쌍)이 있어 들어오는 인시던트 이벤트와 연결할 수 있습니다.

* <DNT>
    **Edges:**
  </DNT>

  모서리는 두 정점 사이의 연결입니다. 모서리는 정점 간의 관계를 설명합니다.

인시던트를 연관시키기 위해 토폴로지를 사용하는 방법을 이해하는 것이 도움이 될 수 있습니다.

1. 첫째, New Relic은 모든 관련 사건을 수집합니다. 여기에는 [결정 논리 단계 1과 2](#customize) 가 사실이고 고급 설정에서 정의된 시간 창 내에 있는 사건이 포함됩니다.

   <img
     title="topology-1.png"
     alt="A screenshot of New Relic topology explained"
     src="/images/alerts_diagram_topology-1.webp"
   />

2. 다음으로, 정점의 정의 속성과 인시던트에서 사용 가능한 속성을 사용하여 [토폴로지 그래프](#create-topology-graph) 의 정점에 각 인시던트를 연결하려고 시도합니다.

   <img
     title="topology-2.png"
     alt="A screenshot of New Relic topology explained"
     src="/images/alerts_diagram_topology-2.webp"
   />

   <figcaption>
     인시던트를 토폴로지 그래프의 정보와 연결하는 단계의 예입니다.
   </figcaption>

3. 그런 다음 인시던트와 연관된 정점 쌍이 "위상학적 종속" 연산자를 사용하여 테스트되어 이러한 정점이 서로 연결되어 있는지 확인합니다.

   <img
     title="topology-3.png"
     alt="A screenshot of New Relic topology explained"
     src="/images/alerts_diagram_topology-3.webp"
   />

   <figcaption>
     이 연산자는 그래프에 5개의 홉 내에서 두 정점을 연결하는 경로가 있는지 확인합니다.
   </figcaption>

   그런 다음 인시던트가 상관되고 문제가 함께 병합됩니다.

### 인시던트 이벤트에 속성 추가 [#add-attributes]

인시던트는 정점의 정의 속성을 사용하여 정점에 연결됩니다. ( [설명된 토폴로지](#topology-explained) 아래의 예제 토폴로지에서 각 꼭짓점에는 고유값이 있는 정의 속성 "CID"가 있습니다.) 다음으로 뉴렐릭의 알림 시스템은 속성과 일치하는 정점을 찾습니다.

꼭짓점에 사용하려는 정의 속성이 사건 이벤트에 아직 없는 경우 다음 옵션 중 하나를 사용하여 추가합니다.

<CollapserGroup>
  <Collapser
    id="tag-entities"
    title="New Relic에서 엔티티에 태그 지정"
  >
    [엔터티에 태그](/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data) 를 지정하면 해당 태그가 경고에 의해 생성된 사건 이벤트를 강화합니다. 예를 들어 항목에 `CID` 및 해당 고유 값으로 태그를 지정한 경우 다음과 같이 꼭짓점에 속성을 정의할 수 있습니다. `'newrelic/tags/CID' : CID_VALUE`
  </Collapser>

  <Collapser
    id="facet-data"
    title="New Relic에서 엔티티에 태그 지정"
  >
    하나 이상의 [패싯](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions#syntax) 이 정의된 [NRQL 경고 조건](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions) 을 생성하면 데이터가 속성별로 그룹화됩니다. 또한 발생된 인시던트 이벤트는 해당 속성 및 값으로 보강됩니다. 인시던트의 경우 패싯 속성은 동일한 형식을 따릅니다. `newrelic/tags/ATTRIBUTE_NAME`
  </Collapser>
</CollapserGroup>

### 토폴로지 생성 또는 보기 [#create-topology-graph]

토폴로지를 설정하거나 기존 토폴로지를 보려면 [NerdGraph 토폴로지 튜토리얼](/docs/apis/nerdgraph/examples/topology-nerdgraph-tutorial) 을 참조하십시오.
