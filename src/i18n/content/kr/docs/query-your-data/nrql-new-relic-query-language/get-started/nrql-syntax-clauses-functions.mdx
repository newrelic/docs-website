---
title: 'NRQL 구문, 절 및 함수'
tags:
  - Query your data
  - 'NRQL: New Relic Query Language'
  - Get started
metaDescription: 'A detailed reference list of clauses and functions in NRQL, the New Relic query language.'
translationType: machine
---

import screenApdexFunction from 'images/screen-apdex-function.png'

import percentile0 from 'images/percentile_0.png'

import screenshotInsightsFilter00 from 'images/screenshot_insights_filter_0_0.png'

NRQL은 New Relic 데이터베이스를 쿼리하는 데 사용할 수 있는 쿼리 언어입니다. 이 문서는 NRQL 구문, 절, 구성 요소 및 기능에 대해 설명합니다.

## 통사론 [#syntax]

이 문서는 NRQL 쿼리에 사용되는 함수와 절에 대한 참조입니다. NRQL을 이해하기 위한 기타 리소스:

* [NRQL 소개](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) : NRQL의 용도, 쿼리할 수 있는 데이터 및 기본 NRQL 구문 설명
* [New Relic 차트를 작성하는 데 사용되는 NRQL 쿼리 검사](/docs/using-new-relic/user-interface-functions/view-your-data/standard-new-relic-ui-page-functions#view-query)
* [`Metric` 데이터 유형을 쿼리하는 방법 알아보기](/docs/telemetry-data-platform/get-data/apis/query-metric-data-type)
* [깔때기를 사용하여 일련의 관련 데이터 평가](/docs/insights/new-relic-insights/features/funnels)
* [이벤트 API로 쿼리하기 위한 형식 NRQL](/docs/insights/insights-api/get-data/query-insights-event-data-api)

## 쿼리 구성 요소 [#clauses]

모든 NRQL 쿼리는 `SELECT` 문 또는 `FROM` 절로 시작합니다. 다른 모든 조항은 선택 사항입니다. 아래의 절 정의에는 NRQL 쿼리의 예도 포함되어 있습니다.

### 필수 조항 [#required]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="state-select"
    title={<>필수: <InlineCode>SELECT</InlineCode> 문</>}
  >
    ```
    SELECT attribute ...
    ```

    ```
    SELECT function(attribute) ...
    ```

    `SELECT` 은 [속성](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#attribute) 또는 [함수](#functions) 를 지정하여 쿼리할 데이터 유형의 부분을 지정합니다. 그 뒤에 쉼표로 구분된 하나 이상의 인수가 옵니다. 각 인수에서 다음을 수행할 수 있습니다.

    * `*` 을 와일드카드로 사용하여 사용 가능한 모든 속성의 값을 가져옵니다. 예: `SELECT * from Transaction` .
    * 지정된 속성 또는 [쉼표로 구분된 목록](#commas) 에 지정된 여러 속성과 관련된 값을 가져옵니다.
    * [집계 함수](#functions) 를 선택하여 지정된 속성에서 집계된 값을 가져옵니다.
    * [`AS` 절을 사용하여](#sel-as) 각 인수에 반환된 결과에 레이블을 지정합니다.

    [기본 수학 함수와 함께 `SELECT` 을 사용할](/docs/query-data/nrql-new-relic-query-language/getting-started/nrql-math-using-select) 수도 있습니다.

    <CollapserGroup>
      <Collapser
        id="avg-resp-time-query"
        title="지난주 이후 평균 응답 시간"
      >
        이 쿼리는 지난주 이후의 평균 응답 시간을 반환합니다.

        ```
        SELECT average(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-from"
    title={<>필수: <InlineCode>FROM</InlineCode> 절</>}
  >
    ```
    SELECT ...
      FROM data type
      ...
    ```

    `FROM` 절을 사용하여 쿼리하려는 [데이터 유형](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql#what-you-can-query) 을 지정합니다. `FROM` 또는 [`SELECT`](#state-select) 로 쿼리를 시작할 수 있습니다. [쉼표로 구분된 목록](#commas) 의 여러 데이터 유형에서 동일한 속성에 대한 값을 병합할 수 있습니다.

    <CollapserGroup>
      <Collapser
        id="one-event"
        title="하나의 데이터 유형 쿼리"
      >
        이 쿼리는 지난 7일 동안의 모든 [APM 트랜잭션](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) 수를 반환합니다.

        ```
        SELECT count(*) FROM Transaction SINCE 7 days ago
        ```
      </Collapser>

      <Collapser
        id="multiple-events"
        title="여러 데이터 유형 쿼리"
      >
        이 쿼리는 지난 3일 동안의 모든 [APM 트랜잭션](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) 및 [브라우저 이벤트](/docs/insights/new-relic-insights/decorating-events/browser-default-attributes-insights#browser-attributes-table) 수를 반환합니다.

        ```
        SELECT count(*) FROM Transaction, PageView SINCE 3 days ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### 선택적 조항 [#optional]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="sel-as"
    title={<><InlineCode>AS</InlineCode> 절</>}
  >
    ```
    SELECT ...
      AS 'label'
      ...
    ```

    `AS` 절을 사용하여 작은따옴표로 구분된 문자열을 사용하여 속성, 애그리게이터, 유입경로의 단계 또는 수학 함수의 결과에 레이블을 지정합니다. 레이블은 결과 차트에 사용됩니다.

    <CollapserGroup>
      <Collapser
        id="math-as"
        title={<>수학 함수를 사용한 쿼리 및 <InlineCode>AS</InlineCode></>}
      >
        이 쿼리는 세션당 페이지 뷰 수를 반환합니다.

        ```
        SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session'
          FROM PageView
        ```
      </Collapser>

      <Collapser
        id="funnel-as"
        title={<>깔때기를 사용한 쿼리 및 <InlineCode>AS</InlineCode></>}
      >
        이 쿼리는 지난 주에 사이트의 메인 페이지와 채용 정보 페이지를 모두 방문한 사람들의 수를 반환합니다.

        ```
        SELECT funnel(SESSION,
            WHERE name='Controller/about/main' AS 'Step 1',
            WHERE name = 'Controller/about/careers' AS 'Step 2')
            FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-compare"
    title={<><InlineCode>COMPARE WITH</InlineCode> 절</>}
  >
    ```
    SELECT ... (SINCE or UNTIL) (integer units) AGO
      COMPARE WITH (integer units) AGO
      ...
    ```

    `COMPARE WITH` 절을 사용하여 서로 다른 두 시간 범위의 값을 비교합니다.

    `COMPARE WITH` `SINCE` 또는 `UNTIL` 문이 필요합니다. `COMPARE WITH` 에 의해 지정된 시간은 `SINCE` 또는 `UNTIL` 에 의해 지정된 시간에 상대적입니다. 예를 들어, `SINCE 1 day ago COMPARE WITH 1 day ago` 는 어제와 전날을 비교합니다.

    `COMPARE WITH` 값의 시간 범위는 항상 `SINCE` 또는 `UNTIL` 로 지정된 시간 범위와 동일합니다. 예를 들어 `SINCE 2 hours ago COMPARE WITH 4 hours ago` 은 오후 3시부터 오후 5시까지를 오전 11시부터 오후 1시까지 비교할 수 있습니다.

    `COMPARE WITH` 꺾은선형 차트 또는 빌보드 형식을 지정할 수 있습니다.

    * `TIMESERIES` 을 사용하여 `COMPARE WITH` 은 비교가 시간에 따라 매핑된 선 차트를 만듭니다.
    * `TIMESERIES` 이 없으면 `COMPARE WITH` 은 현재 값과 `COMPARE WITH` 값의 백분율 변경으로 빌보드를 생성합니다.

    **예:** 이 쿼리는 데이터를 1주일 전의 동일한 범위와 비교하여 지난 1시간 동안의 95번째 백분위수를 보여주는 꺾은선형 차트로 반환합니다. 처음에는 단일 값으로, 그 다음에는 꺾은선형 차트로.

    ```
    SELECT percentile(duration) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO

    SELECT percentile(duration) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="extrapolate"
    title={<><InlineCode>EXTRAPOLATE</InlineCode> 절</>}
  >
    다음 데이터 유형과 함께 이 절을 사용할 수 있습니다.

    * `Transaction`

    * `TransactionError`

    * APM 에이전트 API를 통해 보고된 사용자 지정 이벤트

      `EXTRAPOLATE` 의 목적은 쿼리 결과가 시스템의 총 활동을 더 가깝게 나타내도록 [이벤트 데이터의 APM 에이전트 샘플링](/docs/agents/manage-apm-agents/agent-data/new-relic-events-limits-sampling) 효과를 수학적으로 보정하는 것입니다.

      이 절은 APM 에이전트가 너무 많은 [이벤트](/docs/using-new-relic/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#event-data) 를 보고하여 종종 [수확 주기](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#harvest-cycle) 보고 제한을 통과할 때 유용합니다. 이 경우 에이전트는 이벤트를 샘플링하기 시작합니다.

      `EXTRAPOLATE` 이 사용을 지원하는 NRQL 쿼리에 사용되면 **보고된 이벤트** 와 **총 이벤트** 간의 비율을 사용하여 샘플링되지 않은 총 데이터의 근사치를 추정합니다. 사용을 지원하지 않거나 샘플링된 데이터를 사용하지 않은 NRQL 쿼리에서 사용하면 효과가 없습니다.

      <Callout variant="important">
        `EXTRAPOLATE` 은 처리량이나 오류율과 같은 동종 데이터에 가장 유용합니다. 고유한 항목의 수(예: `uniqueCount()` 또는 `uniques()` )를 외삽하려고 시도할 때는 효과적이지 않습니다.
      </Callout>

      이 절은 다음 [집계 기능](/docs/insights/nrql-new-relic-query-language/nrql-reference/nrql-syntax-components-functions#functions) 중 하나를 사용하는 NRQL 쿼리에서만 작동합니다.

    * 정점

    * 평균

    * 세다

    * histogram

    * 합집합

    * 백분율(인수로 취하는 함수가 `EXTRAPOLATE` 을 지원하는 경우)

    * rate(인수로 취하는 함수가 `EXTRAPOLATE` 을 지원하는 경우)

    * stddev

      <CollapserGroup>
        <Collapser
          id="extrapolate-example-1"
          title="처리량 추정의 예"
        >
          이름이 `interestingApplication` 인 서비스의 외삽 처리량을 표시하는 쿼리입니다.

          ```
          SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE
          ```
        </Collapser>

        <Collapser
          id="extrapolate-example-2"
          title="처리량을 시계열로 추정하는 예"
        >
          시계열로 표시되는 트랜잭션 이름별로 이름이 `interestingApplication` 인 서비스의 추정 처리량을 표시하는 쿼리입니다.

          ```
          SELECT count(*) FROM Transaction WHERE appName='interestingApplication'
          SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet"
    title={<><InlineCode>FACET</InlineCode> 절</>}
  >
    ```
    SELECT ...
      FACET attribute
      ...
    ```

    `FACET` 을 사용하여 속성 값으로 결과를 분리하고 그룹화합니다. 예를 들어 `FACET` `PageView` 데이터를 `deviceType` 으로 사용하여 모바일, 태블릿 및 데스크톱 기기에서 발생하는 트래픽의 비율을 파악할 수 있습니다.

    `LIMIT` 절을 사용하여 표시되는 패싯 수를 지정합니다(기본값은 10). 더 복잡한 그룹화의 경우 [`FACET CASES`](#sel-facet-cases) 을 사용합니다. `FACET` 절은 쉼표로 구분된 최대 5개의 속성을 지원합니다.

    패싯은 `SELECT` 절에 제공한 첫 번째 필드를 기준으로 내림차순으로 정렬됩니다. 고유 값이 2,000개가 넘는 속성을 패싯하는 경우 패싯 값의 하위 집합이 선택되고 쿼리 유형에 따라 정렬됩니다.

    `min()` , `max()` , `percentile()` , `average()` 또는 `count()` 를 선택할 때 `FACET` 는 이러한 함수를 사용하여 패싯을 선택하고 정렬하는 방법을 결정합니다. 다른 [기능](#functions) 을 선택할 때 `FACET` 은 패싯 선택 및 정렬 방법을 결정하기 위해 패싯 대상 속성의 빈도를 사용합니다.

    <CollapserGroup>
      <Collapser
        id="faceted-query"
        title={<>다음을 사용하는 패싯 쿼리 <InlineCode>count()</InlineCode></>}
      >
        이 쿼리는 페이지뷰 수가 가장 높은 도시를 보여줍니다. 이 쿼리는 도시당 총 페이지뷰 수를 사용하여 패싯이 선택되고 정렬되는 방식을 결정합니다.

        ```
        SELECT count(*) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="uniquecount"
        title={<>다음을 사용하는 패싯 쿼리 <InlineCode>uniqueCount()</InlineCode></>}
      >
        이 쿼리는 가장 많은 수의 고유 URL에 액세스하는 도시를 보여줍니다. 이 쿼리는 결과에 특정 도시가 나타나는 총 횟수를 사용하여 패싯이 선택되고 정렬되는 방법을 결정합니다.

        ```
        SELECT uniqueCount(pageUrl) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="cohort-analysis"
        title="시간에 따른 결과 그룹화"
      >
        [고급 세분화](/docs/insights/new-relic-insights/features/advanced-segmentation) 및 [코호트 분석](/docs/insights/new-relic-insights/features/cohort-analysis-grouping-results-across-time) 을 통해 버킷 기능을 패싯하여 데이터를 보다 효과적으로 분류할 수 있습니다.

        코호트 분석은 타임스탬프를 기반으로 결과를 그룹화하는 방법입니다. 지정된 날짜 및 시간 범위를 포함하는 버킷으로 분리할 수 있습니다.
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    title={<><InlineCode>FACET ... AS</InlineCode> 절</>}
  >
    쿼리에서 `AS` 키워드를 사용하여 패싯의 이름을 지정하려면 `FACET ... AS` 을 사용합니다. 이 절은 결과에서 패싯에 대해 더 명확하거나 단순화된 이름을 추가하는 데 유용합니다. 또한 [중첩 집계](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query) 쿼리에서 패싯의 이름을 바꾸는 데 사용할 수도 있습니다.

    `FACET ... AS` 쿼리는 결과의 패싯 이름을 변경하지만(예: 테이블의 헤더로 나타날 때) 실제 패싯 이름 자체는 변경하지 않습니다.

    ```
    FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type'
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-cases"
    title={<><InlineCode>FACET CASES</InlineCode> 절</>}
  >
    ```
    SELECT ...
      FACET CASES (
        WHERE <var>attribute</var> <var>operator</var> <var>value</var>, WHERE <var>attribute</var> <var>operator</var> <var>value</var>, ...
        )
      ...
    ```

    `FACET CASES` 을 사용하여 [`FACET`](#sel-facet) 에서 가능한 것보다 더 복잡한 조건으로 데이터를 분류합니다. 여러 조건을 쉼표 `,` 로 구분합니다. 예를 들어, PageView 데이터 및 `FACET CASES` 를 1초 미만, 1-10초, 10초 초과와 같은 범주로 쿼리할 수 있습니다. 사례 내에서 여러 속성을 결합하고 [`AS`](#sel-as) 선택기로 사례에 레이블을 지정할 수 있습니다. 데이터 포인트는 일치하는 첫 번째 패싯 케이스인 최대 하나의 패싯 케이스에 추가됩니다.

    속성과 함께 [시간 함수](/docs/query-data/nrql-new-relic-query-language/nrql-query-examples/group-results-across-time) 를 사용할 수도 있고 `OR` 연산자를 사용하여 지정된 케이스와 일치하지 않는 결과를 패싯할 수 있습니다.

    <CollapserGroup>
      <Collapser
        id="facet-cases-basic"
        title={<>기본 사용법 <InlineCode>WHERE</InlineCode></>}
      >
        ```
        SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10)
        ```
      </Collapser>

      <Collapser
        id="facet-cases-mixnmatch"
        title="여러 속성을 기반으로 그룹화"
      >
        이 예에서는 트랜잭션 이름에 `login` 이 포함된 버킷과 URL에 `login` 이 포함되고 사용자 지정 속성이 사용자가 유료 사용자임을 나타내는 버킷으로 결과를 그룹화합니다.

        ```
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid')
        ```
      </Collapser>

      <Collapser
        id="facet-cases-as-label"
        title={<>다음으로 그룹에 레이블 지정 <InlineCode>AS</InlineCode></>}
      >
        이 예에서는 [`AS`](#sel-as) 선택기를 사용하여 결과에 사람이 읽을 수 있는 이름을 지정합니다.

        ```
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users')
        ```
      </Collapser>

      <Collapser
        id="facet-cases-with-or"
        title={<>패싯 일치하지 않는 데이터 <InlineCode>OR</InlineCode></>}
      >
        이 예에서는 `OR` 연산자를 사용하여 사례와 일치하지 않는 결과를 패싯합니다.

        ```
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') OR name
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-order"
    title={<><InlineCode>FACET ... ORDER BY</InlineCode> 절</>}
  >
    NRQL에서 기본값은 쿼리에서 패싯 선택을 안내하는 `SELECT` 절의 첫 번째 집계입니다. `FACET ... ORDER BY` 을 사용하면 ORDER BY 수정자와 함께 집계 함수를 추가하여 패싯 선택 방법을 지정하여 이 기본 동작을 재정의할 수 있습니다. 특히 이 절은 `LIMIT` 절에 의해 제한되기 전에 최종 결과에서 패싯이 선택되는 우선 순위를 재정의합니다. 이 절은 쿼리에 사용할 수 있지만 경고 또는 스트리밍에는 사용할 수 없습니다.

    이 예에서는 `FACET ... ORDER BY` 을 사용하여 앱 트랜잭션의 평균 기간을 찾는 방법을 보여주며 응답 크기가 가장 높은 앱별로 상위 10개(기본 제한)의 가장 높은 기간을 보여줍니다. 이 경우 `FACET ... ORDER BY` 이 사용되지 않으면 쿼리 결과는 대신 가장 높은 기간별로 상위 10개를 표시하며 응답 크기는 앱 선택과 관련이 없습니다.

    ```
    FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize)
    ```

    <Callout variant="tip">
      작업은 `LIMIT` 절이 적용되기 전에 수행되기 때문에 `FACET ... ORDER BY` 은 최종 쿼리 결과의 정렬에 영향을 미치지 않으며, 이는 시계열이 아닌 쿼리의 결과에서 특히 두드러집니다.
    </Callout>

    <Callout variant="important">
      이 경우 `ORDER BY` 수정자는 `ORDER BY` 절과 다르게 작동합니다. `FACET attribute1 ORDER BY attribute2` 형식을 따르는 쿼리를 구문 분석할 때 New Relic은 이러한 쿼리를 `FACET ... ORDER BY` 쿼리로 읽지만 `ORDER BY` 가 `FACET` 바로 뒤에 나타나는 경우에만 가능합니다. 그렇지 않으면 `ORDER BY` 은 New Relic에 의해 절로 해석됩니다.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-limit"
    title={<><InlineCode>LIMIT</InlineCode> 절</>}
  >
    ```
    SELECT ...
      LIMIT count
      ...
    ```

    `LIMIT` 절을 사용하여 `FACET` 쿼리에서 반환된 패싯 값의 최대 수 또는 `SELECT *` 쿼리에서 반환된 최대 항목 수를 제어합니다. 이 절은 단일 정수 값을 인수로 사용합니다. `LIMIT` 절이 지정되지 않았거나 값이 제공되지 않은 경우 제한은 기본적으로 `FACET` 쿼리의 경우 10, `SELECT *` 쿼리의 경우 100으로 설정됩니다.

    `LIMIT` 절에 허용되는 최대 값은 2,000입니다.

    <CollapserGroup>
      <Collapser title={<>다음을 사용하여 쿼리 <InlineCode>LIMIT</InlineCode></>}>
        이 쿼리는 세션 수별로 상위 20개 국가를 표시하고 Windows 사용자에게만 각 국가에 대한 응답 시간의 95번째 백분위수를 제공합니다.

        ```
        SELECT uniqueCount(session), percentile(duration, 95)
          FROM PageView WHERE userAgentOS = 'Windows'
          FACET countryCode LIMIT 20 SINCE YESTERDAY
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-offset"
    title={<><InlineCode>OFFSET</InlineCode> 절</>}
  >
    ```
    SELECT ...
      LIMIT count OFFSET count
      ...
    ```

    `LIMIT` 과 함께 `OFFSET` 절을 사용하여 `SELECT *` 또는 `SELECT column` 쿼리에서 반환된 행 부분을 제어합니다. `LIMIT` 절과 마찬가지로 `OFFSET` 는 단일 정수 값을 인수로 사용합니다. `OFFSET` 은 쿼리에서 선택한 행이 반환되기 전에 건너뛸 행 수를 설정합니다. 이것은 `LIMIT` 에 의해 제한됩니다.

    `OFFSET` 행은 가장 최근 레코드부터 건너뜁니다.

    예를 들어 `SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1` 쿼리는 가장 최근 값을 제외하고 `Minute_Report` 에서 마지막 5개 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-order-by"
    title={<><InlineCode>ORDER BY</InlineCode> 절</>}
  >
    `ORDER BY` 절을 사용하면 행별로 이벤트 속성을 선택하는 쿼리에서 쿼리 결과를 정렬하는 방법을 지정할 수 있습니다.

    이 쿼리는 기간별로 트랜잭션을 정렬합니다.

    ```
    FROM Transaction SELECT appName, duration ORDER BY duration
    ```

    기본 정렬 순서는 오름차순이지만 `ASC` 또는 `DESC` 수정자를 추가하여 변경할 수 있습니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="show-event-types"
    title={<><InlineCode>SHOW EVENT TYPES</InlineCode> 절</>}
  >
    ```
    SHOW EVENT TYPES...
    ```

    `SHOW EVENT TYPES` 특정 시간 범위 동안 계정에 있는 모든 데이터 유형의 목록을 반환합니다. `SELECT` 대신 쿼리의 첫 번째 절로 사용됩니다.

    <Callout variant="important">
      이 컨텍스트에서 "이벤트 유형"은 NRQL 쿼리로 액세스할 수 있는 데이터 유형을 나타냅니다.
    </Callout>

    <CollapserGroup>
      <Collapser
        id="avg-resp-time-query"
        title="마지막 날의 데이터 유형"
      >
        이 쿼리는 지난 날의 모든 데이터 유형을 반환합니다.

        ```
        SHOW EVENT TYPES SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-since"
    title={<><InlineCode>SINCE</InlineCode> 절</>}
  >
    ```
    SELECT ...
      SINCE [numerical units AGO | phrase]
      ...
    ```

    **기본값** 은 **1시간 전** 입니다.

    `SINCE` 절을 사용하여 반환된 데이터에 대한 시간 범위의 시작을 정의합니다. 쿼리에는 시간대를 지정할 수 있지만 결과에는 지정할 수 없습니다. NRQL 결과는 시스템 시간을 기반으로 합니다.

    NRQL을 사용할 때 UTC 타임스탬프 또는 상대 시간 범위를 설정할 수 있습니다.

    * 타임스탬프는 `YYYY-MM-DD HH:MM:SS ZZZZ` 형식을 사용합니다. 예를 들어, `FROM Transaction SELECT count(*) SINCE '2021-12-25 00:00:00 +0000' UNTIL '2021-12-25 23:59:59 +0000'` .
    * `YESTERDAY` , `TODAY` , `SUNDAY` , `MONDAY` , `TUESDAY` , `WEDNESDAY` , `THURSDAY` , `FRIDAY` , `SATURDAY` 상대 시간 범위를 지원합니다. 예: `SINCE YESTERDAY UNTIL NOW` .
    * `YEAR` , `QUARTER` , `MONTH` , `WEEK` , `DAY` , `HOUR` , `MINUTE` , `SECOND` 도 지원합니다. 이러한 경우 `SINCE` 을 `THIS` 또는 `LAST` 와 결합할 수 있습니다. 예를 들어, `SINCE LAST MONTH UNTIL THIS WEEK` . `SINCE 3 WEEKS AGO UNTIL 10 MINUTES AGO` 에서와 같이 `AGO` 를 포함할 수도 있습니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="slide-by"
    title={<><InlineCode>SLIDE BY</InlineCode> 절</>}
  >
    `SLIDE BY` 절은 슬라이딩 윈도우라는 기능을 지원합니다. 슬라이딩 창을 사용하면 `SLIDE BY` 데이터가 서로 겹치는 시간의 "창"으로 수집됩니다. 이러한 기간은 롤링 집계(예: 롤링 평균)가 좁은 시간 창의 집계보다 더 중요한 경우에 다양한 변형이 있는 선 그래프를 매끄럽게 만드는 데 도움이 될 수 있습니다.

    `SLIDE BY` 을 사용하려면 쿼리에서 `TIMESERIES` 절 뒤에 배치합니다. 예를 들어, 이 쿼리는 1분 `SLIDE BY` 간격으로 5분 창의 데이터를 가져옵니다. 즉, 각 창은 5분 동안 지속되지만 창 1은 0분에 시작하고 창 2는 1분에 시작하고 창 3은 2에서 시작합니다. 분 등이 있습니다.

    ```
    SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute
    ```

    `SLIDE BY` 을(를) 사용할 수 있는 방법과 시기에 대한 자세한 내용은 [슬라이딩 창으로 더 부드러운 차트 만들기](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows) 를 참조하세요. 또는 이 짧은 비디오(약 3분 20초)를 시청하십시오.

    <Video
      id="b9WVyb1wU6w"
      type="youtube"
    />

    <CollapserGroup>
      <Collapser
        id="sliding-window-max-auto"
        title={<><InlineCode>MAX</InlineCode> 또는 <InlineCode>AUTO</InlineCode> 간격으로 <InlineCode>SLIDE BY</InlineCode> 사용</>}
      >
        `MAX` 또는 `AUTO` 과 함께 슬라이딩 창을 사용할 수 있습니다. 그러나 `MAX` 또는 `AUTO` 은 `TIMESERIES` 와 `SLIDE BY` 사이에 둘 수 없습니다.

        이 쿼리는 자동으로 `SLIDE BY` 창 간격을 결정합니다.

        ```
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO
        ```

        이 쿼리는 SLIDE BY 창을 최대 간격 단위로 설정합니다.

        ```
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX
        ```

        <Callout variant="important">
          `AUTO` 또는 `MAX` 에 의해 결정된 `SLIDE BY` 값은 창 크기보다 큰 단계 간격을 생성할 수 있으며, 이로 인해 간격과 예기치 않은 결과가 발생할 수 있습니다.
        </Callout>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timeseries"
    title={<><InlineCode>TIMESERIES</InlineCode> 절</>}
  >
    ```
    SELECT ...
      TIMESERIES integer units
      ...
    ```

    `TIMESERIES` 절을 사용하여 데이터를 지정된 기간으로 분류된 시계열로 반환합니다. `TIMESERIES` 은 특정 차트를 트리거하는 데 사용되므로 기본값이 없습니다.

    시간 범위를 나타내려면 `integer units` 을 사용합니다. 예를 들어:

    * `TIMESERIES 1 minute`
    * `TIMESERIES 30 minutes`
    * `TIMESERIES 1 hour`
    * `TIMESERIES 30 seconds`

    `TIMESERIES` 아래 예와 같이 쿼리 결과를 추가로 맞춤화하기 위해 `MAX` , `AUTO` 및 `SLIDE BY` 와 같은 인수와 결합할 수 있습니다.

    <Callout variant="important">
      `average()` 또는 `percentile()` 과 같은 함수의 경우 집계 기간이 크면 이상값에 상당한 평활화 효과가 있을 수 있습니다. 이것은 쿼리가 슬라이딩 윈도우를 사용하는지 여부에 관계없이 사실입니다.
    </Callout>

    <CollapserGroup>
      <Collapser
        id="set-interval"
        title="설정된 간격 사용"
      >
        제공된 값은 그래프를 구분하는 데 사용되는 단위를 나타냅니다. 예를 들어, 30분 증분을 보여주는 1일 그래프를 표시하려면:

        ```
        SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes
        ```
      </Collapser>

      <Collapser
        id="timeseries-auto"
        title="자동으로 설정된 간격 사용"
      >
        `TIMESERIES` 그래프를 합리적인 수의 분할로 나누는 `AUTO` 으로 설정할 수도 있습니다. 예를 들어 일일 차트는 30분 간격으로 분할되고 주간 차트는 6시간 간격으로 분할됩니다.

        이 쿼리는 6시간마다 데이터 포인트를 사용하여 1주일 동안 클라이언트 측 트랜잭션 시간의 50번째 및 90번째 백분위수를 보여주는 선 차트로 데이터를 반환합니다.

        ```
        SELECT average(duration), percentile(duration, 50, 90)
          FROM PageView SINCE 1 week AGO TIMESERIES AUTO
        ```
      </Collapser>

      <Collapser
        id="timeseries-max"
        title={<><InlineCode>MAX</InlineCode> 간격 사용</>}
      >
        `TIMESERIES` 을 `MAX` 로 설정할 수 있습니다. 그러면 지정된 기간에 허용되는 최대 간격 수로 기간이 자동으로 조정됩니다. 이렇게 하면 `TIMESERIES` 버킷을 수동으로 업데이트하지 않고도 기간을 업데이트할 수 있으며 기간이 허용되는 최대 간격 수로 분할되도록 할 수 있습니다. 반환될 최대 `TIMESERIES` 버킷 수는 366입니다.

        예를 들어 다음 쿼리는 일별 차트의 상한선인 4분 간격을 생성합니다.

        ```
        SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-until"
    title={<><InlineCode>UNTIL</InlineCode> 절</>}
  >
    ```
    SELECT ...
      UNTIL integer units AGO
      ...
    ```

    **기본값** 은 **NOW** 입니다. 기본값 이외의 끝점을 지정하려면 `UNTIL` 만 사용하십시오.

    `UNTIL` 절을 사용하여 데이터를 반환할 시간 범위의 끝을 정의합니다. 시간 범위가 지정되면 데이터가 보존되며 시간 범위가 종료된 후 검토할 수 있습니다.

    자세한 정보 및 예 [는 시간 선택기를 사용하여 시간 설정 조정을](/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/#dash-time-picker) 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-where"
    title={<><InlineCode>WHERE</InlineCode> 절</>}
  >
    `WHERE` 절을 사용하여 결과를 필터링합니다. NRQL은 절에서 지정한 조건을 충족하는 결과를 반환합니다.

    ```
    SELECT function(attribute) ...
      WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ]
      [AND|OR ...]
      ...
    ```

    * 둘 이상의 조건을 지정하는 경우 `AND` 또는 `OR` 연산자로 조건을 구분합니다.
    * [SQL 조인을 시뮬레이션](/docs/insights/nrql-new-relic-query-language/using-nrql/simulate-sql-join-functions-insights) 하려면 `WHERE` 또는 `FACET` 절에서 맞춤 속성을 사용하세요.

    <table id="where-operators">
      <thead>
        <tr>
          <th width={150}>
            **`WHERE` 절이 허용하는 연산자**
          </th>

          <th>
            **설명**
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `=`, `!=` , `<` , `<=` , `>` , `>=`
          </td>

          <td>
            NRQL은 표준 비교 연산자를 허용합니다.

            예시: `state = 'WA'`
          </td>
        </tr>

        <tr>
          <td>
            `AND`
          </td>

          <td>
            두 조건의 교차를 정의하는 데 사용됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `OR`
          </td>

          <td>
            두 조건의 합집합을 정의하는 데 사용됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `IS NULL`
          </td>

          <td>
            속성에 null 값이 있는지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `IS NOT NULL`
          </td>

          <td>
            속성에 null 값이 없는지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `IN`
          </td>

          <td>
            속성의 문자열 값이 지정된 집합에 있는지 확인합니다. 이 방법을 사용하면 여러 `WHERE` 절을 함께 묶는 것보다 더 나은 성능을 얻을 수 있습니다.

            예시: `animalType IN ('cat', 'dog', 'fish')`
          </td>
        </tr>

        <tr>
          <td>
            `NOT IN`
          </td>

          <td>
            속성의 문자열 값이 지정된 집합에 없는지 확인합니다. 이 방법을 사용하면 여러 `WHERE` 절을 함께 묶는 것보다 더 나은 성능을 얻을 수 있습니다.

            값은 쉼표로 구분된 괄호 안에 있어야 합니다. 예를 들어:

            ```
            SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `LIKE`
          </td>

          <td>
            속성에 지정된 하위 문자열이 포함되어 있는지 확인합니다.

            `LIKE` 연산자에 대한 문자열 인수는 문자열의 어느 곳에서나 퍼센트 기호(%)를 와일드카드로 허용합니다. 하위 문자열이 일치하는 문자열을 시작하거나 끝내지 않는 경우 와일드카드는 문자열을 시작하거나 끝내야 합니다.

            **예:**

            `userAgentName LIKE 'IE%'`

            * 즉

            * IE 모바일

              `userAgentName LIKE 'o%a%'`

            * 오페라

            * 오페라 미니

              `userAgentName LIKE 'o%a'`

            * 오페라

              `userAgentName LIKE '%o%a%'`

            * 오페라

            * 오페라 미니

            * 모질라 게코
          </td>
        </tr>

        <tr>
          <td>
            `NOT LIKE`
          </td>

          <td>
            속성에 지정된 하위 문자열이 포함되어 있지 않은지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `RLIKE`
          </td>

          <td>
            속성에 지정된 Regex 하위 문자열이 포함되어 있는지 확인합니다. [RE2 구문](https://github.com/google/re2/wiki/Syntax) 을 사용합니다.

            **예:**

            `appName RLIKE r'z.*|q.*''`

            `hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*'`

            * `z-app`

            * `q-app`

            * `ip-10-351-19-237`

            * `ip-10-351-2-41`

            * `ip-10-351-24-238`

            * `ip-10-351-14-15`

              <Callout variant="important">
                정규식은 기본적으로 전체 문자열 일치로 설정되므로 `^` 및 `$` 은 암시적이며 추가할 필요가 없습니다.
              </Callout>
          </td>
        </tr>

        <tr>
          <td>
            `NOT RLIKE`
          </td>

          <td>
            속성에 지정된 Regex 하위 문자열이 포함되어 있지 않은지 확인합니다. [RE2 구문](https://github.com/google/re2/wiki/Syntax) 을 사용합니다.
          </td>
        </tr>
      </tbody>
    </table>

    <CollapserGroup>
      <Collapser
        id="query-3-conditions"
        title="세 가지 조건이 있는 쿼리 예"
      >
        이 쿼리는 지난 24시간 동안 미국과 캐나다의 Safari 사용자에 대한 URL에 `checkout` 이 있는 페이지의 브라우저 응답 시간을 반환합니다.

        ```
        SELECT histogram(duration, 50, 20) FROM PageView
        WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%'
        SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-metric-format"
    title={<><InlineCode>WITH METRIC_FORMAT</InlineCode> 절</>}
  >
    메트릭 데이터 쿼리에 대한 자세한 내용은 쿼리 [메트릭](#query-metrics) 을 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timezone"
    title={<><InlineCode>WITH TIMEZONE</InlineCode> 절</>}
  >
    ```
    SELECT ... WITH TIMEZONE (selected zone)
      ...
    ```

    기본적으로 쿼리 결과는 사용 중인 브라우저의 시간대에 표시됩니다.

    `WITH TIMEZONE` 절을 사용하여 아직 지정된 시간대가 없는 쿼리의 날짜 또는 시간에 대한 시간대를 선택합니다.

    예를 들어 쿼리 절 `SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'` 은 월요일 자정(동부 표준시)부터 화요일 자정(동부 표준시)까지 기록된 데이터를 반환합니다.

    <table style={{ width: "auto" }}>
      <thead>
        <tr>
          <th colSpan={4}>
            사용 가능한 시간대 선택
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            아프리카/아비장
          </td>

          <td>
            아프리카/아디스아바바
          </td>

          <td>
            아프리카/알제
          </td>

          <td>
            아프리카/블랜타이어
          </td>
        </tr>

        <tr>
          <td>
            아프리카/카이로
          </td>

          <td>
            아프리카/빈트후크
          </td>

          <td>
            아메리카/아닥
          </td>

          <td>
            아메리카/앵커리지
          </td>
        </tr>

        <tr>
          <td>
            아메리카/아라과이나
          </td>

          <td>
            미국/아르헨티나/부에노스아이레스
          </td>

          <td>
            미국/벨리즈
          </td>

          <td>
            아메리카/보고타
          </td>
        </tr>

        <tr>
          <td>
            아메리카/캄포\_그란데
          </td>

          <td>
            아메리카/칸쿤
          </td>

          <td>
            아메리카/카라카스
          </td>

          <td>
            아메리카/시카고
          </td>
        </tr>

        <tr>
          <td>
            아메리카/치와와
          </td>

          <td>
            America/Dawson_Creek
          </td>

          <td>
            미국/덴버
          </td>

          <td>
            아메리카/엔세나다
          </td>
        </tr>

        <tr>
          <td>
            America/Glace_Bay
          </td>

          <td>
            아메리카/갓탑
          </td>

          <td>
            아메리카/구스베이
          </td>

          <td>
            아메리카/하바나
          </td>
        </tr>

        <tr>
          <td>
            아메리카/라파스
          </td>

          <td>
            미국/로스앤젤레스
          </td>

          <td>
            아메리카/미클롱
          </td>

          <td>
            아메리카/몬테비데오
          </td>
        </tr>

        <tr>
          <td>
            미국/뉴욕
          </td>

          <td>
            아메리카/노로냐
          </td>

          <td>
            아메리카/산티아고
          </td>

          <td>
            아메리카/상파울루
          </td>
        </tr>

        <tr>
          <td>
            아메리카/St_Johns
          </td>

          <td>
            아시아/아나디르
          </td>

          <td>
            아시아/방콕
          </td>

          <td>
            아시아/베이루트
          </td>
        </tr>

        <tr>
          <td>
            아시아/다마스쿠스
          </td>

          <td>
            아시아/다카
          </td>

          <td>
            아시아/두바이
          </td>

          <td>
            아시아/가자
          </td>
        </tr>

        <tr>
          <td>
            아시아/홍콩
          </td>

          <td>
            아시아/이르쿠츠크
          </td>

          <td>
            아시아/예루살렘
          </td>

          <td>
            아시아/카불
          </td>
        </tr>

        <tr>
          <td>
            아시아/카트만두
          </td>

          <td>
            아시아/콜카타
          </td>

          <td>
            아시아/크라스노야르스크
          </td>

          <td>
            아시아/마가단
          </td>
        </tr>

        <tr>
          <td>
            아시아/노보시비르스크
          </td>

          <td>
            아시아/랑군
          </td>

          <td>
            아시아/서울
          </td>

          <td>
            아시아/타슈켄트
          </td>
        </tr>

        <tr>
          <td>
            아시아/테헤란
          </td>

          <td>
            아시아/도쿄
          </td>

          <td>
            아시아/블라디보스토크
          </td>

          <td>
            아시아/야쿠츠크
          </td>
        </tr>

        <tr>
          <td>
            아시아/예카테린부르크
          </td>

          <td>
            아시아/예레반
          </td>

          <td>
            대서양/아조레스 제도
          </td>

          <td>
            대서양/케이프 베르데
          </td>
        </tr>

        <tr>
          <td>
            대서양/스탠리
          </td>

          <td>
            호주/애들레이드
          </td>

          <td>
            호주/브리즈번
          </td>

          <td>
            호주/다윈
          </td>
        </tr>

        <tr>
          <td>
            호주/유클라
          </td>

          <td>
            호주/호바트
          </td>

          <td>
            호주/Lord_Howe
          </td>

          <td>
            호주/퍼스
          </td>
        </tr>

        <tr>
          <td>
            칠레/이스터섬
          </td>

          <td>
            기타/GMT+10
          </td>

          <td>
            기타/GMT+8
          </td>

          <td>
            기타/GMT-11
          </td>
        </tr>

        <tr>
          <td>
            기타/GMT-12
          </td>

          <td>
            유럽/암스테르담
          </td>

          <td>
            유럽/벨파스트
          </td>

          <td>
            유럽/베오그라드
          </td>
        </tr>

        <tr>
          <td>
            유럽/브뤼셀
          </td>

          <td>
            유럽/더블린
          </td>

          <td>
            유럽/리스본
          </td>

          <td>
            유럽/런던
          </td>
        </tr>

        <tr>
          <td>
            유럽/민스크
          </td>

          <td>
            유럽/모스크바
          </td>

          <td>
            태평양/오클랜드
          </td>

          <td>
            태평양/채텀
          </td>
        </tr>

        <tr>
          <td>
            태평양/갬비어
          </td>

          <td>
            태평양/키리티마티
          </td>

          <td>
            태평양/마르키즈
          </td>

          <td>
            태평양/미드웨이
          </td>
        </tr>

        <tr>
          <td>
            태평양/노퍽
          </td>

          <td>
            태평양/통가푸
          </td>

          <td>
            UTC
          </td>
        </tr>
      </tbody>
    </table>

    자세한 정보와 예 [는 대시보드 및 차트에서 시간 범위 설정을](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets) 참조하십시오.
  </Collapser>
</CollapserGroup>

## 메트릭 데이터 쿼리 [#query-metrics]

메트릭 데이터는 다른 유형의 데이터보다 복잡합니다. 잘 쿼리하기 위한 특정 팁이 있습니다. 각각 고유한 쿼리 지침이 있는 두 가지 유형의 측정항목 데이터가 있습니다.

* Metric API 및 해당 API를 사용하는 일부 솔루션(예:[Dropwizard 통합](/docs/more-integrations/open-source-telemetry-integrations/dropwizard/dropwizard-reporter) 또는 [Micrometer 통합](/docs/more-integrations/open-source-telemetry-integrations/micrometer/micrometer-metrics-registry) )에서 보고하는 [차원 메트릭을 쿼리합니다](/docs/data-ingest-apis/get-data-new-relic/metric-api/view-query-you-metric-data) .
* [쿼리 메트릭 타임슬라이스 데이터](/docs/query-data/nrql-new-relic-query-language/nrql-query-tutorials/query-metric-timeslice-data-nrql) 는 APM, 모바일 모니터링 및 브라우저 모니터링에서 보고한 원래 메트릭 데이터 유형입니다.

메트릭 데이터를 보고하는 방법에 대한 자세한 내용은 [메트릭 데이터 유형](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics) 을 참조하십시오.

## 기능 [#functions]

이 섹션에서는 NRQL 함수, 즉 [집계 기능](#aggregator-functions) 과 [비](#non-aggregator-functions) 집계 기능에 대해 설명합니다.

### 애그리게이터 기능 [#aggregator-functions]

집계 함수를 사용하여 데이터를 필터링하고 집계할 수 있습니다. 다음을 사용하기 위한 몇 가지 팁:

* [필터 쿼리](http://newrelic.wistia.com/medias/8k4xbxlfwj) , [Apdex 쿼리](http://newrelic.wistia.com/medias/46dvx1mkm0) 및 [백분위수 쿼리](http://newrelic.wistia.com/medias/j3htrz66l0) 에 대한 New Relic University 자습서를 참조하십시오. 또는 [NRQL 쿼리 작성](https://learn.newrelic.com/writing-nrql-queries) 전체 온라인 과정으로 이동합니다.

* 동일한 쿼리(예: `SELECT median(one_metric), median(another_metric)` )에서 집계 함수를 여러 번 사용하는 경우 결과 표시에 문제가 발생할 수 있습니다. 이를 해결하려면 [`AS` 함수](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-as) 를 사용하십시오. 예를 들어:

  ```
   SELECT median(one_metric) as 'med-a', median(another_metric) as 'med-b'
  ```

* 데이터 유형 "강제"는 지원되지 않습니다. [사용 가능한 유형 변환 함수](#type-conversion) 에 대해 읽어보십시오.

* 시간 경과에 따른 결과를 표시하는 방법은 시간 경과에 [따른 결과 그룹화 를](/docs/insights/new-relic-insights/features/cohort-analysis) 참조하십시오.

예:

```
SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
```

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="func-aggregationendtime"
    title={<InlineCode>집계 종료 시간()</InlineCode>}
  >
    `aggregationendtime()` 함수를 사용하여 관련 집계 시간을 반환합니다. 더 구체적으로 말하면, 주어진 집계에 대해 `aggregationendtime()` 함수는 해당 집계 기간 종료의 타임스탬프를 제공합니다. 예를 들어 시계열 쿼리에서 1시간 분량의 데이터를 포함하는 데이터 포인트의 경우 함수는 해당 시간 기간의 끝 타임스탬프를 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-apdex"
    title={<InlineCode>apdex(속성, t: )</InlineCode>}
  >
    `apdex` 함수를 사용하여 단일 거래 또는 모든 거래에 대한 [Apdex 점수](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#score) 를 반환합니다. [속성](/docs/insights/new-relic-insights/decorating-events/insights-attributes) 은 [`duration`](/docs/insights/insights-data-sources/default-events-attributes/apm-default-event-attributes#txn-duration) 또는 [`backendDuration`](/docs/insights/insights-data-sources/default-events-attributes/browser-default-events-attributes-insights#backend-duration) 와 같이 응답 시간을 기반으로 하는 모든 속성이 될 수 있습니다. `t:` 인수는 선택한 속성과 동일한 시간 단위로 [Apdex T](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) 임계값을 정의합니다. 예를 들어 속성이 초 단위로 측정되는 경우 `t` 는 초 단위 임계값이 됩니다.

    `apdex()` 함수에서 반환된 Apdex 점수는 실행 시간에만 기반합니다. APM 오류는 고려하지 않습니다. 트랜잭션에 오류가 포함되어 있지만 [Apdex T](/docs/apm/new-relic-apm/getting-started/glossary#apdex_t) 이하에서 완료되는 경우 해당 트랜잭션은 `apdex ()` 함수에 의해 [만족스러운](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#bullet-satisfied) 것으로 평가됩니다.

    <CollapserGroup>
      <Collapser
        id="apdex-cust-attributes"
        title="특정 고객을 위한 Apdex 받기"
      >
        [사용자 정의 속성을 정의한](/docs/insights/new-relic-insights/decorating-events/insights-custom-attributes) 경우 해당 속성을 기반으로 필터링할 수 있습니다. 예를 들어, 특히 중요한 고객의 Apdex를 모니터링할 수 있습니다.

        ```
        SELECT apdex(duration, t: 0.4) FROM Transaction
          WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago
        ```
      </Collapser>

      <Collapser
        id="apdex-transaction"
        title="특정 트랜잭션에 대한 Apdex 가져오기"
      >
        `name` 속성을 사용하여 특정 트랜잭션에 대한 점수를 반환하거나 `name` 을 생략하여 전체 Apdex를 반환합니다. 이 쿼리는 지난 1시간 동안의 **Controller/notes/index** 트랜잭션에 대한 Apdex 점수를 반환합니다.

        <img
          title="crop-apdex-function"
          alt="crop-apdex-function"
          src={screenApdexFunction}
        />

        <figcaption>
          `apdex` 함수는 사이트에 대한 사용자 만족도를 측정하는 [Apdex 점수](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) 를 반환합니다. 인수는 응답 시간 속성 및 Apdex T 임계값(초)입니다.
        </figcaption>

        ```
        SELECT apdex(duration, t: 0.5) from Transaction
        WHERE name='Controller/notes/index' SINCE 1 hour ago
        ```
      </Collapser>

      <Collapser title="앱에 대한 전체 Apdex 가져오기">
        이 예제 쿼리는 지난 3주 동안 애플리케이션에 대한 전체 Apdex를 반환합니다.

        ```
        SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-average"
    title={<InlineCode>평균(속성)</InlineCode>}
  >
    `average()` 함수를 사용하여 속성의 평균 값을 반환합니다. 단일 속성 이름을 인수로 사용합니다. 속성 값이 숫자가 아니면 집계할 때 무시됩니다. 쿼리 조건과 일치하는 데이터를 찾을 수 없거나 쿼리에서 반환된 숫자 값이 없으면 null 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-buckets"
    title={<InlineCode>버킷(속성, 상한 \[, 버킷 수])</InlineCode>}
  >
    `buckets()` 함수를 사용하여 `FACET` 절로 분할된 데이터를 범위를 기반으로 버킷으로 집계합니다. New Relic 데이터베이스에 숫자 값으로 저장된 모든 속성으로 버킷을 만들 수 있습니다.

    세 가지 인수가 필요합니다.

    * 속성 이름

    * 샘플 범위의 최대값입니다. 모든 이상치는 최종 버킷에 나타납니다.

    * 총 버킷 수

      자세한 내용과 예는 [데이터를 버킷으로 분할](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/segment-your-insights-data-buckets) 을 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-bucket-percentile"
    title={<InlineCode>버킷백분위수(속성)</InlineCode>}
  >
    `bucketPercentile()` 함수는 Prometheus의 [`histogram_quantile`](https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile) 함수에 해당하는 NRQL입니다. 차원 메트릭 데이터와 함께 사용하기 위한 것입니다. quantile 대신 New Relic은 quantile \* 100인 백분위수를 반환합니다.

    `bucketPercentile()` 함수를 사용하여 Prometheus 형식의 히스토그램 데이터에서 분위수를 계산합니다.

    버킷 이름을 인수로 사용하고 버킷 경계를 따라 백분위수를 보고합니다.

    ```
    SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago
    ```

    선택적으로 백분위수 사양을 인수로 추가할 수 있습니다.

    ```
    SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago
    ```

    Prometheus 히스토그램 데이터를 구성하는 데 여러 측정항목이 사용되기 때문에 연결된 `<basename>` 측면에서 특정 Prometheus 측정항목을 쿼리해야 합니다.

    예를 들어, NRQL을 사용하는 `<basename>` `prometheus_http_request_duration_seconds` 과 함께 Prometheus 히스토그램에서 백분위수를 계산하려면 `bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)` 를 사용합니다. \_bucket이 `<basename>` 끝에 접미사로 추가되는 방식에 유의하세요.

    자세한 내용 [은 Prometheus.io 문서](https://prometheus.io/docs/concepts/metric_types/#histogram) 를 참조하세요.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cardinality"
    title={<InlineCode>카디널리티(속성)</InlineCode>}
  >
    `cardinality()` 함수를 사용하여 측정항목의 모든 [측정기준](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics) (속성) 조합 수를 가져옵니다.

    세 개의 인수가 필요하며 모두 선택 사항입니다.

    * 측정항목 이름: 있는 경우 `cardinality()` 은 지정된 측정항목만 계산합니다.

    * 포함: 있는 경우 포함 목록은 카디널리티 계산을 해당 속성으로 제한합니다.

    * 제외: 존재하는 경우 제외 목록으로 인해 카디널리티 계산에서 해당 속성이 무시됩니다.

      ```
      SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list})
      ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-count"
    title={<InlineCode>세다(\*)</InlineCode>}
  >
    `count()` 함수를 사용하여 사용 가능한 레코드 수를 반환합니다. 단일 인수가 필요합니다. `*` , 속성 또는 상수 값입니다. 현재는 일반적인 SQL 동작을 따르고 해당 인수에 대한 값이 있는 모든 레코드를 계산합니다.

    `count(*)` 은(는) 특정 속성의 이름을 지정하지 않으므로 결과는 기본 ["humanize"](/docs/insights/new-relic-insights/managing-dashboards-data/data-formatter-setting-default-formats-numeric-values#format) 형식으로 지정됩니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="derivative"
    title={<InlineCode>도함수(속성 \[,시간 간격])</InlineCode>}
  >
    `derivative()` 주어진 데이터 세트의 변화율을 찾습니다. 변화율은 도함수를 근사화하기 위해 선형 최소 자승 회귀를 사용하여 계산됩니다. 이 계산에는 둘 이상의 데이터 포인트를 비교해야 하므로 평가 범위에 하나의 데이터 포인트만 포함되는 경우 계산이 불확실하고 작동하지 않아 `null` 값이 생성됩니다.

    `time interval` 은 변화율이 계산되는 기간입니다. 예를 들어, `derivative(attributeName, 1 minute)` 은 분당 변경 비율을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-dimensions"
    title={<InlineCode>'차원(포함: {속성}, 제외: {속성})'</InlineCode>}
  >
    `dimensions()` 함수를 사용하여 데이터 유형의 모든 차원 값을 반환합니다.

    선택적 인수를 사용하여 특정 속성을 명시적으로 포함하거나 제외할 수 있습니다.

    * 포함: 있는 경우 포함 목록은 `dimensions()` 을 해당 속성으로 제한합니다.

    * 제외: 있는 경우 `dimensions()` 계산은 해당 속성을 무시합니다.

      ```
      FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions()
      ```

      `FACET` 절과 함께 사용하면 `dimensions()` 은 Prometheus가 집계되지 않은 쿼리에서 작동하는 방식과 유사하게 이벤트 유형에서 사용 가능한 모든 패싯에 대해 고유한 시계열을 생성합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="latestrate"
    title={<InlineCode>lastrate(속성, 시간 간격)</InlineCode>}
  >
    `latestrate()` 함수를 사용하여 마지막 2개의 데이터 포인트를 기반으로 한 값의 변화율을 반환합니다. 문제의 속성을 첫 번째 인수로 사용하고 결과 비율에 대한 시간 단위를 두 번째 인수로 사용합니다. 이 함수는 `change in attribute/time interval` 단위로 결과를 반환합니다.

    이 기능은 최첨단 추세를 보기 위해 속성에 대한 가장 최근의 변경 비율을 제공하는 데 유용할 수 있습니다.

    <CollapserGroup>
      <Collapser title="PageView Duration의 가장 최근 변화율을 가져옵니다.">
        이 쿼리는 마지막 2개의 데이터 포인트를 기반으로 하는 기간의 변화율을 반환합니다. `1 SECOND` 인수 때문에 `duration/second` 단위로 반환됩니다.

        ```
        SELECT latestrate(duration, 1 SECOND) FROM PageView
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-max"
    title={<InlineCode>최대(속성)</InlineCode>}
  >
    `max()` 함수를 사용하여 지정된 시간 범위 동안 숫자 속성의 최대 기록 값을 반환합니다. 단일 속성 이름을 인수로 사용합니다. 속성 값이 숫자가 아니면 집계할 때 무시됩니다. 쿼리 조건과 일치하는 데이터를 찾을 수 없거나 쿼리에서 반환된 숫자 값이 없으면 null 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-median"
    title={<InlineCode>중앙값(속성)</InlineCode>}
  >
    `median()` 함수를 사용하여 속성의 중앙값 또는 50번째 백분위수를 반환합니다. 백분위수 쿼리에 대한 자세한 내용은 백분위 [수()](#func-percentile) 를 참조하십시오.

    <Callout variant="tip">
      `median()` 쿼리는 [쿼리 빌더](/docs/chart-builder/use-chart-builder/get-started/introduction-chart-builder) 를 사용할 때만 사용할 수 있습니다.
    </Callout>

    <CollapserGroup>
      <Collapser title="중간 쿼리">
        이 쿼리는 중앙값에 대한 꺾은선형 차트를 생성합니다.

        ```
        SELECT median(duration) FROM PageView TIMESERIES AUTO
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-min"
    title={<InlineCode>분(속성)</InlineCode>}
  >
    `min()` 함수를 사용하여 지정된 시간 범위 동안 숫자 속성의 최소 기록 값을 반환합니다. 단일 속성 이름을 인수로 사용합니다. 속성 값이 숫자가 아니면 집계할 때 무시됩니다. 쿼리 조건과 일치하는 데이터를 찾을 수 없거나 쿼리에서 반환된 숫자 값이 없으면 null 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-minOf"
    title={<InlineCode>분(속성)</InlineCode>}
  >
    `minuteOf()` 함수를 사용하여 유효한 타임스탬프 값을 보유하는 속성의 분 부분(0-59초)만 추출합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mod"
    title={<InlineCode>mod(속성, 제수)</InlineCode>}
  >
    `mod()` 함수를 사용하여 제공된 숫자 속성 값(첫 번째 인수 또는 피제수)을 숫자 값(두 번째 인수 또는 제수)으로 나눈 후 바닥 계수를 반환합니다. 이 모듈로 연산은 WHERE 절 조건 내에서 결과의 임의 하위 집합으로 필터링하거나 FACET 절 내에서 결과 집합을 세분화하는 방법으로 사용할 수 있습니다.

    <CollapserGroup>
      <Collapser title={<><InlineCode>mod()</InlineCode> <InlineCode>WHERE</InlineCode> 절 조건 내에서</>}>
        ```
        FROM Transaction SELECT * WHERE mod(port, 2) = 1
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title={<><InlineCode>mod()</InlineCode> <InlineCode>FACET</InlineCode> 절 내</>}>
        ```
        FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentage"
    title={<InlineCode>백분율(함수(속성), WHERE 조건)</InlineCode>}
  >
    `percentage()` 함수를 사용하여 일부 조건과 일치하는 대상 데이터 세트의 백분율을 반환합니다.

    첫 번째 인수에는 원하는 속성에 대한 [집계 함수](#functions) 가 필요합니다. 정확히 두 개의 인수를 사용하십시오(처음 두 개 이후의 인수는 무시됨). 속성이 숫자가 아니면 이 함수는 100% 값을 반환합니다.

    ```
    FROM Transaction SELECT percentage(count(*), WHERE error is true ) AS 'Error Percent' Where host LIKE '%west%' EXTRAPOLATE
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentile"
    title={<InlineCode>백분위수(속성 \[, 백분위수 \[, ...]])</InlineCode>}
  >
    `percentile()` 함수를 사용하여 지정된 백분위수에서 속성의 대략적인 값을 반환합니다. 속성이 필요하며 백분위수를 나타내는 인수를 원하는 만큼 사용할 수 있습니다. `percentile()` 함수를 사용하면 백분위수를 소수점 이하 3자리까지 표시할 수 있어 정밀도가 향상됩니다. 백분위수 임계값은 십진수 값으로 지정할 수 있지만 대부분의 데이터 세트에서 서로 0.1보다 가까운 백분위수는 확인되지 않습니다.

    <img
      title="percentile.png"
      alt="percentile.png"
      src={percentile0}
    />

    <figcaption>
      백분위수 표시 예
    </figcaption>

    `TIMESERIES` 을 사용하여 시간 경과에 따라 매핑된 백분위수가 있는 꺾은선형 차트를 생성합니다.

    * 백분위수에 대한 집계 값을 표시하는 빌보드 및 속성 시트를 생성하려면 `TIMESERIES` 을 생략합니다.

      백분위수가 나열되지 않으면 기본값은 95번째 백분위수입니다. 50번째 백분위수 값인 중앙값만 반환하려면 [median()](#func-median) 을 사용할 수도 있습니다.

      <CollapserGroup>
        <Collapser title="기본 백분위수 쿼리">
          이 쿼리는 5번째, 50번째, 95번째 백분위수에 대한 선이 있는 꺾은선형 차트를 생성합니다.

          ```
          SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="predictLinear"
    title={<InlineCode>predictLinear(속성, \[,시간 간격])</InlineCode>}
  >
    `predictLinear()` `derivative()` 함수의 확장입니다. 데이터 세트의 미래 값을 예측하기 위해 유사한 최소 제곱 선형 회귀 방법을 사용합니다.

    * `time interval` 은 쿼리가 앞으로 얼마나 멀리 볼 것인지입니다. 예를 들어, `predictLinear(attributeName, 1 hour)` 은 쿼리 시간 창에서 1시간 후의 선형 예측입니다.
    * 일반적으로 `predictLinear()` 은 디스크 공간과 같이 지속적으로 증가하는 값이나 큰 추세에 대한 예측에 유용합니다.
    * `predictLinear()` 은 선형 회귀이므로 쿼리되는 데이터세트에 익숙하면 정확한 장기 예측을 보장하는 데 도움이 됩니다.
    * 기하급수적으로, 대수적으로 또는 기타 비선형 수단에 의해 증가하는 데이터 세트는 매우 단기 예측에서만 성공할 가능성이 높습니다.
    * New Relic은 `TIMESERIES` 쿼리에서 `predictLinear` 사용을 권장하지 않습니다. 이는 각 버킷이 쿼리 내 상대적인 시간 프레임을 기반으로 개별 예측을 수행하기 때문입니다. 즉, 이러한 쿼리는 시계열의 끝부터 예측을 표시하지 않습니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-rate"
    title={<InlineCode>rate(함수(속성) \[,시간 간격])</InlineCode>}
  >
    `rate()` 함수를 사용하여 시간 간격당 주어진 쿼리의 빈도 또는 비율을 시각화합니다. 예를 들어, 한 시간 동안 분당 페이지뷰 수 또는 하루 동안 시간당 사이트의 고유 세션 수를 알고 싶을 수 있습니다.

    * [`TIMESERIES`](#sel-timeseries) 을 사용하여 시간에 따라 매핑된 요율이 있는 꺾은선형 차트를 생성합니다.

    * 시간 경과에 따른 평균 단일 요율 값을 표시하는 빌보드를 생성하려면 [`TIMESERIES`](#sel-timeseries) 을 생략합니다.

      다음은 지난 6시간 동안 10분당 APM 트랜잭션의 처리량 비율을 보여주는 선형 차트를 생성하는 기본 쿼리입니다.

      ```
      SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago
      TIMESERIES
      ```

      다음은 `rate` 을 사용하여 여러 기간의 데이터를 비교하는 방법을 설명하는 짧은 동영상(3분 21분)입니다.

      <Video
        id="9UArmB4QiVM"
        type="youtube"
      />
  </Collapser>

  <Collapser
    className="freq-link"
    id="round"
    title={<InlineCode>라운드(속성)</InlineCode>}
  >
    `round()` 함수를 사용하여 속성의 반올림된 값을 반환합니다.

    선택적으로 `round()` 은 두 번째 인수 `to_nearest` 를 사용하여 첫 번째 인수를 두 번째 인수의 가장 가까운 배수로 반올림할 수 있습니다. `to_nearest` 는 소수일 수 있습니다.

    ```
    SELECT round(n [, to_nearest])
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="stddev"
    title={<InlineCode>stddev(속성)</InlineCode>}
  >
    `stddev()` 함수를 사용하여 지정된 시간 범위에 걸쳐 숫자 속성에 대해 하나의 [표준 편차](https://en.wikipedia.org/wiki/Standard_deviation) 를 반환합니다. 단일 인수가 필요합니다. 속성이 숫자가 아니면 0 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="stdvar"
    title={<InlineCode>stdvar(속성)</InlineCode>}
  >
    `stdvar()` 함수를 사용하여 지정된 시간 범위에 대한 숫자 속성의 [표준 분산](https://en.wikipedia.org/wiki/Variance) 을 반환합니다.

    단일 인수가 필요합니다. 속성이 숫자가 아니면 0 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-sum"
    title={<InlineCode>합계(속성)</InlineCode>}
  >
    `sum()` 함수를 사용하여 지정된 시간 범위 동안 숫자 속성의 기록된 값 합계를 반환합니다.

    단일 인수가 필요합니다. 첫 번째 인수 이후의 인수는 무시됩니다. 속성이 숫자가 아니면 0 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniqueCount"
    title={<InlineCode>uniqueCount(속성)</InlineCode>}
  >
    `uniqueCount()` 함수를 사용하여 지정된 시간 범위 동안 속성에 대해 기록된 고유 값의 수를 반환합니다.

    <Callout variant="tip">
      쿼리 성능을 최적화하기 위해 이 함수는 256개 이상의 고유 값을 검사하는 쿼리에 대한 대략적인 결과를 반환합니다.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniques"
    title={<><InlineCode>uniques(attribute ,limit</InlineCode><InlineCode>)</InlineCode></>}
  >
    `uniques()` 함수를 사용하여 지정된 시간 범위 동안 속성에 대해 기록된 고유 값 목록을 반환합니다. `facet` 절과 함께 사용하면 각 패싯 값마다 고유한 속성 값 목록이 반환됩니다.

    `limit` 매개변수는 선택사항입니다. 제공되지 않으면 패싯당 고유 속성 값 1,000개의 기본 제한이 적용됩니다. 최대 10,000까지 다른 `limit` 값을 지정할 수 있습니다. `uniques()` 함수는 한계에 도달할 때까지 발견된 고유 속성 값의 첫 번째 세트를 리턴합니다. 따라서 데이터 세트에 5,000개의 고유 속성 값이 있고 제한이 1,000으로 설정된 경우 연산자는 빈도에 관계없이 발견한 처음 1,000개의 고유 값을 반환합니다.

    쿼리 결과에서 반환할 수 있는 최대 값 수는 `uniques()` 제한 `facet` 제한의 곱입니다. 다음 쿼리에서 반환될 수 있는 이론적 최대 값 수는 5백만(5,000 x 1,000)입니다.

    쿼리되는 데이터 세트와 쿼리의 복잡성에 따라 메모리 보호 제한으로 인해 매우 큰 쿼리가 실행되지 않을 수 있습니다.

    ```
    From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000
    ```

    <CollapserGroup>
      <Collapser title={<>사용 <InlineCode>tuple</InlineCode></>}>
        몇 가지 속성의 고유한 조합을 알고 싶다면 `` SELECT uniques(tuple(x, y, ... z)) ...` `` 형식으로 쿼리를 구성하여 고유한 값 튜플을 모두 가져와서 관계를 유지할 수 있습니다. 다음 쿼리에서 `tuple` 은 `index` 및 `cellName` 에서 함께 사용되어 두 값이 조합되어 발생하는 고유 항목을 찾습니다.

        ```
        FROM NodeStatus SELECT uniques(tuple(index, cellName), 5)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-capture"
    title={<InlineCode>캡처(속성, 정규식)</InlineCode>}
  >
    [RE2 구문](https://github.com/google/re2/wiki/Syntax) 이 있는 정규식을 사용하여 속성에서 값을 추출하려면 `capture()` 을 사용합니다.

    두 가지 인수가 필요합니다.

    * 속성 이름

    * 캡처 구문이 있는 정규식. NRQL의 정규 표현식은 Python과 유사한 구문 `r'...'` 을 사용합니다.

      캡처할 때 지정된 이름이 지정된 경우 RE2 명명된 캡처 구문 `...(?P<name> pattern )...` 을 사용하여 포함된 패턴을 캡처합니다. 현재 하나의 캡처 그룹만 지원됩니다.

      [쿼리 결과를 개선하기 위해 정규식 캡처를 사용](https://newrelic.com/blog/how-to-relic/using-regex-capture) 하는 방법을 읽어보세요.

      다음은 `capture()` 을 사용하여 대시보드 가독성을 높이는 방법을 보여주는 짧은 동영상(3분 5분)입니다.

      <Video
        id="hOPrTWYgPHg"
        type="youtube"
      />

      자세한 내용은 아래 예를 참조하세요.

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> <InlineCode>SELECT</InlineCode> 절 조건 내에서</>}>
          다음은 웹사이트의 도메인 이름을 선택하고 `https://` 및 다음 경로를 제거합니다. `.com`

          ```
          SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') FROM PageView SINCE 1 day ago
          ```

          다음은 오류 메시지의 첫 번째 단어만 캡처합니다.

          ```
          SELECT capture(errorMessage, r'(?P<firstWord>\S+)\s.+') FROM Transaction SINCE 1 hour ago where errorMessage is not null
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> <InlineCode>FACET</InlineCode> 절 조건 내에서</>}>
          다음은 캡처된 HTTP 메서드에 의해 패싯됩니다.

          ```
          SELECT count(*) FROM Log WHERE message like '%HTTP%' FACET capture(message, r'.* "(?P<httpMethod>[A-Z]+) .*')
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> <InlineCode>WHERE</InlineCode> 절 조건 내에서</>}>
          다음은 캡처된 작업 이름이 `ExampleJob` 인 정규식과 일치하는 `message` 속성이 있는 로그 이벤트를 기반으로 결과를 필터링합니다.

          ```
          SELECT message FROM Log WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' SINCE 10 minutes ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> 숫자 캐스트로</>}>
          다음은 로그 라인에서 CPU 시간의 합계를 캡처합니다. 수학 연산을 수행하려면 명시적으로 숫자로 캐스트해야 합니다.

          ```
          SELECT sum(numeric(capture(message, r'.*CpuTime:\s(?P<cpuTime>\d+)'))) FROM Log WHERE message like '%CpuTime:%' SINCE 1 hour ago
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>
</CollapserGroup>

### 비 집계 함수 [#non-aggregator-functions]

NRQL 쿼리에서 숫자가 아닌 데이터에 대해 비 집계 함수를 사용합니다.

<CollapserGroup>
  <Collapser
    className="freq-link"
    title={<InlineCode>계정 ID()</InlineCode>}
  >
    `accountId()` 함수를 사용하여 쿼리된 데이터와 연결된 [계정 ID](/docs/accounts/accounts-billing/account-structure/account-id) 를 반환합니다. 이 함수는 인수를 사용하지 않습니다. 다음은 몇 가지 예시 쿼리입니다.

    <CollapserGroup>
      <Collapser title="각 거래 이벤트에 대한 계정 ID 가져오기">
        이 쿼리는 반환된 각 `Transaction` 이벤트와 연결된 계정 ID를 반환합니다.

        ```
        SELECT accountId() FROM Transaction SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="각 계정에 대한 트랜잭션 이벤트 수 가져오기">
        이 쿼리는 각 계정 ID와 연결된 마지막 날의 `Transaction` 이벤트 수를 반환합니다.

        ```
        SELECT count(*) FROM Transaction FACET accountId() SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="WHERE 절에 지정된 각 계정에 대한 트랜잭션 이벤트 수를 가져옵니다.">
        이 쿼리는 계정 ID가 구체적으로 `1` , `2` 또는 `3` 중 하나인 마지막 날의 `Transaction` 이벤트 수를 반환합니다.

        ```
        SELECT count(*) FROM Transaction WHERE accountId() IN (1,2,3) SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    title={<InlineCode>가장 이른(속성)</InlineCode>}
  >
    `earliest()` 함수를 사용하여 지정된 시간 범위 동안 속성에 대한 가장 이른 값을 반환합니다.

    단일 인수가 필요합니다. 첫 번째 인수 이후의 인수는 무시됩니다.

    `FACET` 과 함께 사용하는 경우 각 결과 패싯에 대한 속성의 가장 최근 값을 반환합니다.

    <CollapserGroup>
      <Collapser title="PageView에서 사용자 에이전트당 가장 빠른 국가 가져오기">
        이 쿼리는 PageView 이벤트에서 각 사용자 에이전트별로 가장 빠른 국가 코드를 반환합니다.

        ```
        SELECT earliest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    title={<InlineCode>이벤트 유형()</InlineCode>}
  >
    ```
    ...WHERE eventType() = 'EventNameHere'...
    ...FACET eventType()...
    ```

    [FACET](#sel-facet) 절에서 `eventType()` 함수를 사용하여 선택한 데이터 유형별로 결과를 분류하거나 [WHERE](#sel-where) 절에서 결과를 특정 데이터 유형으로 필터링합니다. 이는 [filter()](#func-filter) 및 [percent()](#func-percentage) 함수를 사용하여 특정 데이터 유형을 대상으로 지정할 때 특히 유용합니다.

    <Callout variant="important">
      이 컨텍스트에서 "이벤트 유형"은 NRQL 쿼리로 액세스할 수 있는 데이터 유형을 나타냅니다.
    </Callout>

    <CollapserGroup>
      <Collapser
        id="filter-eventtype"
        title={<><InlineCode>filter()</InlineCode> 함수에서 <InlineCode>eventType()</InlineCode> 사용</>}
      >
        이 쿼리는 총 `Transaction` 결과 중 총 `TransactionError` 결과의 백분율을 반환합니다. `eventType()` 함수를 사용하여 filter() 함수로 특정 유형의 데이터를 대상으로 지정할 수 있습니다.

        ```
        SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago
        ```
      </Collapser>

      <Collapser
        id="facet-eventtype"
        title={<>다음과 함께 <InlineCode>eventType()</InlineCode> 사용 <InlineCode>FACET</InlineCode></>}
      >
        이 쿼리는 각 데이터 유형( `Transaction` 및 `TransactionError` )이 반환하는 레코드 수를 표시합니다.

        ```
        SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-filter"
    title={<InlineCode>필터(함수(속성), WHERE 조건)</InlineCode>}
  >
    `filter()` 함수를 사용하여 SELECT 문의 집계 함수 중 하나에 대한 결과를 제한합니다. `filter()` 을 `FACET` 또는 `TIMESERIES` 와 함께 사용할 수 있습니다. 필터는 `SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' ...` 와 같은 여러 집계를 선택할 때만 유용합니다. 그렇지 않으면 표준 `WHERE` 절을 사용하는 것이 좋습니다.

    <CollapserGroup>
      <Collapser title="제안 코드를 사용한 구매 분석">
        `filter()` 을 사용하여 제안 코드를 사용하는 사람과 사용하지 않는 사람에 대해 일련의 거래에서 구입한 항목을 비교할 수 있습니다.

        <img
          title="screenshot insights filter"
          alt="screenshot insights filter"
          src={screenshotInsightsFilter00}
        />

        <figcaption>
          `filter()` 함수를 사용하여 SELECT 문의 집계 함수 중 하나에 대한 결과를 제한합니다.
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-funnel"
    title={<InlineCode>깔때기(속성, 단계)</InlineCode>}
  >
    `funnel()` 함수를 사용하여 깔때기형 차트를 생성합니다. 속성을 첫 번째 인수로 사용합니다. 그런 다음 단계를 쉼표로 구분된 [`WHERE`](#sel-where) 절(레이블에 대한 선택적 [`AS`](#sel-as) 절 포함)로 지정합니다.

    자세한 내용과 예는 [유입경로 문서](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/funnels-evaluate-data-series-events) 를 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getfield"
    title={<InlineCode>getField(속성, 필드)</InlineCode>}
  >
    `getField()` 함수를 사용하여 [측정항목 데이터](/docs/telemetry-data-platform/understand-data/new-relic-data-types/#metrics) 와 같은 복합 데이터 유형에서 필드를 추출합니다.

    다음 인수를 취합니다.

    <table>
      <thead>
        <tr>
          <th style={{ width: "500px" }}>
            측정항목 유형
          </th>

          <th>
            지원되는 필드
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `summary`
          </td>

          <td>
            개수, 합계, 최대, 최소, 유형
          </td>
        </tr>

        <tr>
          <td>
            `gauge`
          </td>

          <td>
            개수, 총계, 최대, 최소, 최신, 유형
          </td>
        </tr>

        <tr>
          <td>
            `distribution`
          </td>

          <td>
            개수, 합계, 최대, 최소, 유형
          </td>
        </tr>

        <tr>
          <td>
            `counter`
          </td>

          <td>
            카운트, 유형
          </td>
        </tr>

        <tr>
          <td>
            `timeslice`
          </td>

          <td>
            개수, 총계, totalExclusive, 최소 및 최대
          </td>
        </tr>
      </tbody>
    </table>

    예:

    ```
    SELECT max(getField(mySummary, count)) from Metric
    ```

    ```
    SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-histogram"
    title={<InlineCode>히스토그램(속성, 상한 \[,버킷 수])</InlineCode>}
  >
    `histogram()` 함수를 사용하여 히스토그램을 생성합니다. 세 가지 인수가 필요합니다.

    * 속성 이름

    * 샘플 범위의 최대값

    * 총 버킷 수(1-500개 포함)

      <CollapserGroup>
        <Collapser
          id="histogram-response-times"
          title="PageView 이벤트의 응답 시간 히스토그램"
        >
          이 쿼리는 20개 버킷에 대해 최대 10초 범위의 응답 시간 히스토그램을 생성합니다.

          ```
          SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="histogram-prometheus"
          title="Prometheus 히스토그램 버킷"
        >
          `histogram()` Prometheus 히스토그램 버킷 허용:

          ```
          SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="distribution-metric"
          title="New Relic 분포 지표"
        >
          `histogram()` [분포 측정항목](/docs/data-ingest-apis/get-data-new-relic/metric-api/events-metrics-service-create-metrics#limits-rules) 을 입력으로 수락합니다.

          ```
          SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="histogram-facet-heatmap"
          title="FACET 절이 있는 히스토그램"
        >
          FACET 절과 함께 `histogram()` 을 사용하여 히트맵 차트를 생성합니다.

          ```
          SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="keyset"
    title={<InlineCode>키셋()</InlineCode>}
  >
    `keyset()` 을 사용하면 주어진 시간 범위 동안 주어진 데이터 유형에 대한 모든 속성을 볼 수 있습니다. 인수가 필요하지 않습니다. 문자열 유형 키, 숫자 유형 키, 부울 유형 키 및 모든 키의 그룹을 포함하는 JSON 구조를 반환합니다.

    <CollapserGroup>
      <Collapser title="데이터 유형에 대한 모든 속성 보기">
        이 쿼리는 마지막 날의 `PageView` 이벤트에 대해 찾은 속성을 반환합니다.

        ```
        SELECT keyset() FROM PageView SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latest"
    title={<InlineCode>최신(속성)</InlineCode>}
  >
    `latest()` 함수를 사용하여 지정된 시간 범위 동안 속성의 가장 최근 값을 반환합니다.

    단일 인수가 필요합니다. 첫 번째 인수 이후의 인수는 무시됩니다.

    `FACET` 과 함께 사용하는 경우 각 결과 패싯에 대한 속성의 가장 최근 값을 반환합니다.

    <CollapserGroup>
      <Collapser title="PageView에서 사용자 에이전트당 가장 최근 국가 가져오기">
        이 쿼리는 PageView 이벤트에서 각 사용자 에이전트별로 가장 최근의 국가 코드를 반환합니다.

        ```
        SELECT latest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

## 유형 변환

NRQL은 "강제"를 지원하지 않습니다. 즉, 문자열로 저장된 부동 소수점은 문자열로 취급되며 부동 소수점 값을 기대하는 함수에서 작동할 수 없습니다.

다음 함수를 사용하여 숫자 값이 있는 문자열 또는 문자열 값이 있는 부울을 숫자 및 부울 유형으로 변환할 수 있습니다.

* `numeric()` 함수를 사용하여 문자열 형식의 숫자를 숫자 함수로 변환합니다. 이 함수는 쿼리 결과에 수학 함수를 사용하는 쿼리 또는 `average()` 과 같은 NRQL 집계 함수에 빌드할 수 있습니다.
* `boolean()` 함수를 사용하여 "true" 또는 "false" 문자열 값을 해당 부울 값으로 변환합니다.