---
title: 'NRQL 구문, 조항 및 함수'
tags:
  - Query your data
  - 'NRQL: New Relic Query Language'
  - Get started
metaDescription: 'A detailed reference list of clauses and functions in NRQL, the New Relic query language.'
translationType: human
---

import queriesnrqlApdexNRQLQueryBuilder from 'images/queries-nrql_screenshot-full_apdex-NRQL-query-builder.png'

import lowerExample from 'images/lowerExample.png'

import percentile0 from 'images/percentile_0.png'

import positionExample from 'images/positionExample.png'

import queriesnrqlPercentileNRQLQueryBuilder from 'images/queries-nrql_screenshot-full_percentile-NRQL-query-builder.png'

import queriesnrqlFilterNRQLQueryBuilder from 'images/queries-nrql_screenshot-full_filter-NRQL-query-builder.png'

import screenshotInsightsFilter00 from 'images/screenshot_insights_filter_0_0.png'

import substringExample from 'images/substringExample.png'

import upperExample from 'images/upperExample.png'

NRQL은 뉴렐릭 데이터베이스를 쿼리하는 데 사용할 수 있는 쿼리 언어입니다. 이 문서는 NRQL 구문, 조항, 구성 요소 및 기능에 대해 설명합니다.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="Getting started with New Relic"
    title="뉴렐릭이 처음이신가요?"
  >
    뉴렐릭이 처음 접해보고 NRQL을 얼마나 쉽게 사용할 수 있는지 알고 싶으시다면, 무료로 플랫폼을 시작하고 튜토리얼을 따라하시기 바랍니다. 해야 할 일은 다음과 같습니다.

    1. 아직 계정이 없으시다면, [지금 무료 계정을 신청](https://newrelic.com/signup)하십시오.
    2. [에이전트 및 통합](/docs/infrastructure/host-integrations/get-started/introduction-host-integrations/)을 사용해 공통 프레임워크 및 툴에서 데이터를 자동으로 수집할 수 있습니다.
    3. 권장되는 뉴렐릭 설정 방법은 [빠른 실행 가이드](/docs/new-relic-solutions/get-started/quick-launch-guide)를 참조하십시오. 쿼리할 데이터 인제스트를 시작할 수 있으며, 이 튜토리얼을 비롯해 모든 튜토리얼을 사용할 준비가 모두 완료되었습니다.
  </Collapser>
</CollapserGroup>

## 구문(Syntax) [#syntax]

이 리소스에는 NRQL 쿼리에서 사용할 수 있는 다양한 기능과 절에 대한 설명이 포함되어 있습니다. NRQL에 대한 정보를 확인할 수 있는 다른 보편적인 자료는 다음과 같습니다.

* [NRQL 소개](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql): NRQL 전체에 대한 간략한 개요를 제공하고 다른 소개 문서에 대한 링크를 제공합니다.
* [NRQL 사용 방법](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql-how-nrql-works): NRQL의 작동 방식과 이를 사용해 데이터를 쿼리하는 방법을 설명합니다.
* [입문 NRQL 튜토리얼](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql-tutorial): 기본 쿼리에 익숙해지도록 설계된 NRQL 기본 튜토리얼입니다.
* New Relic University [NRQL 교육 과정](https://learn.newrelic.com/writing-nrql-queries)
* [`Metric` 데이터 유형을 쿼리하는 방법 알아보기](/docs/telemetry-data-platform/get-data/apis/query-metric-data-type)
* [하위 쿼리 사용 방법](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql)
* [퍼널을 사용하여 일련의 관련 데이터 평가](/docs/insights/new-relic-insights/features/funnels)

## 쿼리 구성 요소 [#clauses]

모든 NRQL 쿼리는 `SELECT` 문 또는 `FROM` 조항로 시작합니다. 다른 모든 조항은 선택 사항입니다. 아래의 조항 정의에는 NRQL 쿼리의 예도 포함되어 있습니다.

### 필수 조항 [#required]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="state-select"
    title={<>필수: <InlineCode>SELECT</InlineCode> 문</>}
  >
    ```sql
    SELECT attribute ...
    ```

    ```sql
    SELECT function(attribute) ...
    ```

    `SELECT`는 [속성](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#attribute) 또는 [함수](#functions)를 지정하여 데이터 유형의 쿼리할 부분을 지정합니다. 그 뒤에 쉼표로 구분된 하나 이상의 인수가 옵니다. 각 인수에서 다음을 수행할 수 있습니다.

    * `*`를 와일드카드로 사용하여 사용 가능한 모든 속성의 값을 가져옵니다. 예: `SELECT * from Transaction`.
    * 지정된 속성 또는 [쉼표로 구분된 목록](#commas)에 지정된 여러 속성과 관련된 값을 가져옵니다.
    * [집계 함수](#functions)를 선택하여 지정된 속성에서 집계된 값을 가져옵니다.
    * [`AS` 조항을 사용하여](#sel-as) 각 인수에 반환된 결과에 레이블을 지정합니다.

    [기본 수학 함수와 함께 `SELECT`를 사용할](/docs/query-data/nrql-new-relic-query-language/getting-started/nrql-math-using-select) 수도 있습니다.

    <CollapserGroup>
      <Collapser
        id="avg-resp-time-query"
        title="지난주 이후 평균 응답 시간"
      >
        이 쿼리는 지난주 이후의 평균 응답 시간을 반환합니다.

        ```sql
        SELECT average(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-from"
    title={<>필수: <InlineCode>FROM</InlineCode> 조항</>}
  >
    ```sql
    SELECT ...
      FROM data type
      ...
    ```

    `FROM` 조항을 사용하여 쿼리하려는 [데이터 유형](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql#what-you-can-query)을 지정합니다. `FROM` 또는 [`SELECT`](#state-select)로 쿼리를 시작할 수 있습니다. [쉼표로 구분된 목록](#commas)의 여러 데이터 유형에서 동일한 속성에 대한 값을 병합할 수 있습니다.

    <CollapserGroup>
      <Collapser
        id="one-event"
        title="하나의 데이터 유형 쿼리"
      >
        이 쿼리는 지난 7일 동안의 모든 [APM 트랜잭션](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) 수를 반환합니다.

        ```sql
        SELECT count(*) FROM Transaction SINCE 7 days ago
        ```
      </Collapser>

      <Collapser
        id="multiple-events"
        title="여러 데이터 유형 쿼리"
      >
        이 쿼리는 지난 3일 동안의 모든 [APM 트랜잭션](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) 및 [브라우저 이벤트](/docs/insights/new-relic-insights/decorating-events/browser-default-attributes-insights#browser-attributes-table) 수를 반환합니다.

        ```sql
        SELECT count(*) FROM Transaction, PageView SINCE 3 days ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### 옵션 조항 [#optional]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="sel-as"
    title={<><InlineCode>AS</InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      AS 'label'
      ...
    ```

    `AS` 조항을 사용하여 작은따옴표로 구분된 문자열을 사용하여 속성, 집합기, 퍼널의 단계 또는 수학 함수의 결과에 레이블을 지정합니다. 레이블은 결과 차트에 사용됩니다.

    <CollapserGroup>
      <Collapser
        id="math-as"
        title={<>수학 함수를 사용한 쿼리 및 <InlineCode>AS</InlineCode></>}
      >
        이 쿼리는 세션당 페이지 뷰 수를 반환합니다.

        ```sql
        SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session'
          FROM PageView
        ```
      </Collapser>

      <Collapser
        id="funnel-as"
        title={<>퍼널을 사용한 쿼리 및 <InlineCode>AS</InlineCode></>}
      >
        이 쿼리는 지난 주에 사이트의 메인 페이지와 채용 정보 페이지를 모두 방문한 사람들의 수를 반환합니다.

        ```sql
        SELECT funnel(SESSION,
            WHERE name='Controller/about/main' AS 'Step 1',
            WHERE name = 'Controller/about/careers' AS 'Step 2')
            FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-compare"
    title={<><InlineCode>COMPARE WITH</InlineCode> 절</>}
  >
    ```sql
    SELECT ... (SINCE or UNTIL) (integer units) AGO
      COMPARE WITH (integer units) AGO
      ...
    ```

    `COMPARE WITH` 조항을 사용하여 서로 다른 두 시간 범위의 값을 비교합니다.

    `COMPARE WITH` `SINCE` 또는 `UNTIL` 문이 필요합니다. `COMPARE WITH`에 의해 지정된 시간은 `SINCE` 또는 `UNTIL`에 의해 지정된 시간에 상대적입니다. 예를 들어, `SINCE 1 day ago COMPARE WITH 1 day ago`는 어제와 전날을 비교합니다.

    `COMPARE WITH` 값의 시간 범위는 항상 `SINCE` 또는 `UNTIL`로 지정된 시간 범위와 동일합니다. 예를 들어 `SINCE 2 hours ago COMPARE WITH 4 hours ago`는 오후 3시부터 오후 5시까지를 오전 11시부터 오후 1시까지 비교할 수 있습니다.

    `COMPARE WITH` 라인 차트 또는 빌보드 형식을 지정할 수 있습니다.

    * `TIMESERIES`를 사용하여, `COMPARE WITH`는 비교가 시간에 따라 매핑된 라인 차트를 만듭니다.
    * `TIMESERIES`가 없으면 &#x7B; `COMPARE WITH`는 현재 값과 `COMPARE WITH` 값의 백분율 변경으로 빌보드를 생성합니다.

    **예**: 이 쿼리는 1주일 전의 동일한 범위와 비교하여 지난 주의 95번째 백분위수를 보여주는 선형 차트로 데이터를 반환합니다. 처음에는 단일 값으로, 그 다음에는 선형 차트로 보여줍니다.

    ```sql
    SELECT percentile(duration, 95) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO

    SELECT percentile(duration, 95) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO
    ```

    <Callout variant="important">
      `COMPARE WITH`을 사용하는 `FACET` 쿼리의 경우, 결과로 야기되는 패싯은 비교되는 이전 시간 범위가 아니라 `SINCE` 및 `UNTIL`을 사용하여 지정된 시간 범위를 기반으로 선택됩니다. 이전 시간 범위에 대한 `FACET` 쿼리의 결과에만 다른 패싯 세트가 포함될 수 있습니다.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="extrapolate"
    title={<><InlineCode>EXTRAPOLATE</InlineCode> 절</>}
  >
    다음 데이터 유형과 함께 이 조항을 사용할 수 있습니다.

    * `Transaction`

    * `TransactionError`

    * APM 에이전트 API를 통해 보고된 커스텀 이벤트

      `EXTRAPOLATE`의 목적은 쿼리 결과가 시스템의 총 활동을 더 가깝게 나타내도록 [이벤트 데이터의 APM 에이전트 샘플링](/docs/agents/manage-apm-agents/agent-data/new-relic-events-limits-sampling) 효과를 수학적으로 보정하는 것입니다.

      이 조항은 APM 에이전트가 너무 많은 [이벤트](/docs/using-new-relic/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#event-data)를 보고하여 종종 [하베스트 주기](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#harvest-cycle) 보고 한도를 넘어갈 때 유용합니다. 이 경우 에이전트는 이벤트를 샘플링하기 시작합니다.

      `EXTRAPOLATE`가 사용을 지원하는 NRQL 쿼리에 사용되면 **보고된 이벤트**와 **총 이벤트** 간의 비율을 사용하여 샘플링되지 않은 총 데이터의 근사치를 외삽합니다. 사용을 지원하지 않거나 샘플링된 데이터를 사용하지 않은 NRQL 쿼리에서 사용하면 효과가 없습니다.

      <Callout variant="important">
        `EXTRAPOLATE`는 처리량이나 오류율과 같은 동종 데이터에 가장 유용합니다. 고유한 항목의 수(예: `uniqueCount()` 또는 `uniques()` )를 외삽하려고 시도할 때는 효과적이지 않습니다.
      </Callout>

      이 조항은 다음 [집계 기능](/docs/insights/nrql-new-relic-query-language/nrql-reference/nrql-syntax-components-functions#functions) 중 하나를 사용하는 NRQL 쿼리에서만 작동합니다.

    * `apdex`

    * `average`

    * `count`

    * `histogram`

    * `sum`

    * `percentage` (인수로 취하는 함수가 `EXTRAPOLATE`를 지원하는 경우)

    * `rate` (인수로 취하는 함수가 `EXTRAPOLATE`를 지원하는 경우)

    * `stddev`

      <CollapserGroup>
        <Collapser
          id="extrapolate-example-1"
          title="처리량 외삽의 예"
        >
          이름이 `interestingApplication`인 서비스의 외삽 처리량을 표시하는 쿼리입니다.

          ```sql
          SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE
          ```
        </Collapser>

        <Collapser
          id="extrapolate-example-2"
          title="처리량을 시계열로 외삽하는 예"
        >
          시계열로 표시되는 트랜잭션 이름별로 이름이 `interestingApplication`인 서비스의 외삽 처리량을 표시하는 쿼리입니다.

          ```sql
          SELECT count(*) FROM Transaction WHERE appName='interestingApplication'
          SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet"
    title={<><InlineCode>FACET</InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      FACET attribute
      ...
    ```

    `FACET`을 사용하여 속성 값으로 결과를 분리하고 그룹화합니다. 예를 들어 `deviceType`으로 `FACET` `PageView` 데이터를 사용하여 모바일, 태블릿 및 데스크톱 기기에서 발생하는 트래픽의 비율을 파악할 수 있습니다.

    `LIMIT` 조항을 사용하여 표시되는 패싯 수를 지정합니다(기본값은 10). 더 복잡한 그룹화의 경우 [`FACET CASES`](#sel-facet-cases)를 사용합니다. `FACET` 조항은 쉼표로 구분된 최대 5개의 속성을 지원합니다.

    패싯은 `SELECT` 조항에 제공한 첫 번째 필드를 기준으로 내림차순으로 정렬됩니다. 고유 값이 2,000개가 넘는 속성을 패싯하는 경우 패싯 값의 하위 집합이 선택되고 쿼리 유형에 따라 정렬됩니다.

    `min()` , `max()` , `percentile()` , `average()` 또는 `count()`를 선택할 때 `FACET`은 이러한 함수를 사용하여 패싯을 선택하고 정렬하는 방법을 결정합니다. 다른 [기능](#functions)을 선택할 때 `FACET`은 패싯 선택 및 정렬 방법을 결정하기 위해 패싯 대상 속성의 빈도를 사용합니다.

    <CollapserGroup>
      <Collapser
        id="faceted-query"
        title={<>다음을 사용하는 패싯 쿼리 <InlineCode>count()</InlineCode></>}
      >
        이 쿼리는 페이지뷰 수가 가장 높은 도시를 보여줍니다. 이 쿼리는 도시당 총 페이지뷰 수를 사용하여 패싯이 선택되고 정렬되는 방식을 결정합니다.

        ```sql
        SELECT count(*) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="uniquecount"
        title={<>다음을 사용하는 패싯 쿼리 <InlineCode>uniqueCount()</InlineCode></>}
      >
        이 쿼리는 가장 많은 수의 고유 URL에 액세스하는 도시를 보여줍니다. 이 쿼리는 결과에 특정 도시가 나타나는 총 횟수를 사용하여 패싯이 선택되고 정렬되는 방법을 결정합니다.

        ```sql
        SELECT uniqueCount(pageUrl) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="cohort-analysis"
        title="시간에 따른 결과 그룹화"
      >
        [고급 세분화](/docs/insights/new-relic-insights/features/advanced-segmentation) 및 [코호트 분석](/docs/insights/new-relic-insights/features/cohort-analysis-grouping-results-across-time)을 통해 버킷 기능을 패싯하여 데이터를 보다 효과적으로 분류할 수 있습니다.

        코호트 분석은 타임스탬프를 기반으로 결과를 그룹화하는 방법입니다. 지정된 날짜 및 시간 범위를 포함하는 버킷으로 분리할 수 있습니다.
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="facet-as"
    title={<><InlineCode>FACET ... AS</InlineCode> 절</>}
  >
    쿼리에서 `AS` 키워드를 사용하여 패싯의 이름을 지정하려면 `FACET ... AS`를 사용합니다. 이 조항은 결과에서 패싯에 대해 더 명확하거나 단순화된 이름을 추가하는 데 유용합니다. 또한 [중첩 집계](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query) 쿼리에서 패싯의 이름을 바꾸는 데 사용할 수도 있습니다.

    `FACET ... AS` 쿼리는 결과의 패싯 이름을 변경하지만(예: 테이블의 헤더로 나타날 때) 실제 패싯 이름 자체는 변경하지 않습니다.

    ```sql
    FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type'
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-cases"
    title={<><InlineCode>FACET CASES</InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      FACET CASES (
        WHERE attribute operator value, WHERE attribute operator value, ...
        )
      ...
    ```

    `FACET CASES`를 사용하여 [`FACET`](#sel-facet)에서 가능한 것보다 더 복잡한 조건으로 데이터를 분류합니다. 여러 조건을 쉼표 `,`로 구분합니다. 예를 들어, PageView 데이터 및 `FACET CASES`를 1초 미만, 1-10초, 10초 초과와 같은 범주로 쿼리할 수 있습니다. 사례 내에서 여러 속성을 결합하고 [`AS`](#sel-as) 선택기로 사례에 레이블을 지정할 수 있습니다. 데이터 포인트는 일치하는 첫 번째 패싯 케이스인 최대 하나의 패싯 케이스에 추가됩니다.

    속성과 함께 [시간 함수](/docs/query-data/nrql-new-relic-query-language/nrql-query-examples/group-results-across-time)를 사용할 수도 있고 `OR` 연산자를 사용하여 지정된 케이스와 일치하지 않는 결과를 패싯할 수 있습니다.

    <CollapserGroup>
      <Collapser
        id="facet-cases-basic"
        title={<>기본 사용법 <InlineCode>WHERE</InlineCode></>}
      >
        ```sql
        SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10)
        ```
      </Collapser>

      <Collapser
        id="facet-cases-mixnmatch"
        title="여러 속성을 기반으로 그룹화"
      >
        이 예에서는 트랜잭션 이름에 `login`이 포함된 버킷과 URL에 `login`이 포함되고 사용자 지정 속성이 사용자가 유료 사용자임을 나타내는 버킷으로 결과를 그룹화합니다.

        ```sql
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid')
        ```
      </Collapser>

      <Collapser
        id="facet-cases-as-label"
        title={<>다음으로 그룹에 레이블 지정 <InlineCode>AS</InlineCode></>}
      >
        이 예에서는 [`AS`](#sel-as) 선택기를 사용하여 결과에 사람이 읽을 수 있는 이름을 지정합니다.

        ```sql
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users')
        ```
      </Collapser>

      <Collapser
        id="facet-cases-with-or"
        title={<>패싯 일치하지 않는 데이터 <InlineCode>OR</InlineCode></>}
      >
        이 예에서는 `OR` 연산자를 사용하여 사례와 일치하지 않는 결과를 패싯합니다.

        ```sql
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') OR name
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-order"
    title={<><InlineCode>FACET ... ORDER BY</InlineCode> 절</>}
  >
    NRQL에서 기본값은 쿼리에서 패싯 선택을 안내하는 `SELECT` 조항의 첫 번째 집계입니다. `FACET ... ORDER BY`를 사용하면 ORDER BY 수정자와 함께 집계 함수를 추가하여 패싯 선택 방법을 지정하여 이 기본 동작을 재정의할 수 있습니다. 특히 이 조항은 `LIMIT` 조항에 의해 제한되기 전에 최종 결과에서 패싯이 선택되는 우선순위를 재정의합니다. 이 조항은 쿼리에 사용할 수 있지만 알림 또는 스트리밍에는 사용할 수 없습니다.

    이 예에서는 `FACET ... ORDER BY`를 사용하여 앱 트랜잭션의 평균 기간을 찾는 방법을 보여주며 응답 크기가 가장 높은 앱별로 상위 10개(기본 제한)의 가장 높은 기간을 보여줍니다. 이 경우 `FACET ... ORDER BY`가 사용되지 않으면 쿼리 결과는 대신 가장 높은 기간별로 상위 10개를 표시하며 응답 크기는 앱 선택과 관련이 없습니다.

    ```sql
    FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize)
    ```

    <Callout variant="tip">
      작업은 `LIMIT` 조항이 적용되기 전에 수행되기 때문에 `FACET ... ORDER BY`는 최종 쿼리 결과의 정렬에 영향을 미치지 않으며, 이는 시계열이 아닌 쿼리의 결과에서 특히 두드러집니다.
    </Callout>

    <Callout variant="important">
      이 경우 `ORDER BY` 수정자는 `ORDER BY` 조항과 다르게 작동합니다. `FACET attribute1 ORDER BY attribute2` 형식을 따르는 쿼리를 구문 분석할 때 뉴렐릭은 이러한 쿼리를 `FACET ... ORDER BY` 쿼리로 읽지만 `ORDER BY`가 `FACET` 바로 뒤에 나타나는 경우에만 가능합니다. 그렇지 않으면 `ORDER BY`는 뉴렐릭에 의해 조항로 해석됩니다.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-limit"
    title={<><InlineCode>LIMIT</InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      LIMIT count
      ...
    ```

    `LIMIT` 조항을 사용하여 `FACET` 쿼리에서 반환된 패싯 값의 최대 수 또는 `SELECT *` 쿼리에서 반환된 최대 항목 수를 제어합니다. 이 조항은 단일 정수 값을 인수로 사용합니다. `LIMIT` 조항이 지정되지 않았거나 값이 제공되지 않은 경우 제한은 기본적으로 `FACET` 쿼리의 경우 10, `SELECT *` 쿼리의 경우 100으로 설정됩니다.

    `LIMIT` 조항에 허용되는 최대 값은 2,000입니다.

    <CollapserGroup>
      <Collapser title={<>다음을 사용하여 쿼리 <InlineCode>LIMIT</InlineCode></>}>
        이 쿼리는 세션 수별로 상위 20개 국가를 표시하고 Windows 사용자에게만 각 국가에 대한 응답 시간의 95번째 백분위수를 제공합니다.

        ```sql
        SELECT uniqueCount(session), percentile(duration, 95)
          FROM PageView WHERE userAgentOS = 'Windows'
          FACET countryCode LIMIT 20 SINCE YESTERDAY
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-offset"
    title={<><InlineCode>OFFSET</InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      LIMIT count OFFSET count
      ...
    ```

    `LIMIT` 과 함께 `OFFSET` 조항을 사용하여 `SELECT *` 또는 `SELECT column` 쿼리에서 반환된 행 부분을 제어합니다. `LIMIT` 조항과 마찬가지로 `OFFSET` 는 단일 정수 값을 인수로 사용합니다. `OFFSET`은 쿼리에서 선택한 행이 반환되기 전에 건너뛸 행 수를 설정합니다. 이것은 `LIMIT`에 의해 제한됩니다.

    `OFFSET` 행은 가장 최근부터 건너뜁니다.

    예를 들어, `SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1` 쿼리는 가장 최근 값을 제외하고 `Minute_Report`에서 마지막 5개 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-order-by"
    title={<><InlineCode>ORDER BY</InlineCode> 절</>}
  >
    `ORDER BY` 조항을 사용하면 행별로 이벤트 속성을 선택하는 쿼리에서 쿼리 결과를 정렬하는 방법을 지정할 수 있습니다.

    이 쿼리는 기간별로 트랜잭션을 정렬합니다.

    ```sql
    FROM Transaction SELECT appName, duration ORDER BY duration
    ```

    기본 정렬 순서는 오름차순이지만 `ASC` 또는 `DESC` 수정자를 추가하여 변경할 수 있습니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="show-event-types"
    title={<><InlineCode>SHOW EVENT TYPES</InlineCode> 절</>}
  >
    ```sql
    SHOW EVENT TYPES...
    ```

    `SHOW EVENT TYPES` 특정 시간 범위 동안 계정에 있는 모든 데이터 유형의 목록을 반환합니다. `SELECT` 대신 쿼리의 첫 번째 조항로 사용됩니다.

    <Callout variant="important">
      이 컨텍스트에서 "이벤트 유형"은 NRQL 쿼리로 액세스할 수 있는 데이터 유형을 나타냅니다.
    </Callout>

    <CollapserGroup>
      <Collapser
        id="avg-resp-time-query"
        title="마지막 날의 데이터 유형"
      >
        이 쿼리는 지난 날의 모든 데이터 유형을 반환합니다.

        ```sql
        SHOW EVENT TYPES SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-since"
    title={<><InlineCode>SINCE</InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      SINCE [numerical units AGO | phrase]
      ...
    ```

    **기본값**은 **1시간 전** 입니다.

    `SINCE` 조항을 사용하여 반환된 데이터에 대한 시간 범위의 시작을 정의합니다. 쿼리에는 시간대를 지정할 수 있지만 결과에는 지정할 수 없습니다. NRQL 결과는 시스템 시간을 기반으로 합니다.

    NRQL을 사용할 때 UTC 타임스탬프 또는 상대 시간 범위를 설정할 수 있습니다.

    * 타임스탬프는 `YYYY-MM-DD HH:MM:SS ZZZZ` 포맷을 사용합니다. 예를 들어:

      ```sql
      FROM Transaction SELECT count(*) SINCE '2021-12-25 00:00:00 +0000' UNTIL '2021-12-25 23:59:59 +0000'
      ```

    * `YESTERDAY`, `TODAY`, `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY` 상대 시간 범위를 지원합니다. 예: `SINCE YESTERDAY UNTIL NOW`

    * `YEAR`, `QUARTER`, `MONTH`, `WEEK`, `DAY`, `HOUR`, `MINUTE`, `SECOND`도 지원합니다. 이러한 경우 `SINCE`을 `THIS` 또는 `LAST`와 결합할 수 있습니다. 예: `SINCE LAST MONTH UNTIL THIS WEEK`. `SINCE 3 WEEKS AGO UNTIL 10 MINUTES AGO`에서와 같이 `AGO`를 포함할 수도 있습니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="slide-by"
    title={<><InlineCode>SLIDE BY</InlineCode> 절</>}
  >
    `SLIDE BY` 조항은 슬라이딩 창이라는 기능을 지원합니다. 슬라이딩 창을 사용하면 `SLIDE BY` 데이터가 서로 겹치는 시간의 "창"으로 수집됩니다. 이러한 기간은 롤링 집계(예: 롤링 평균)가 좁은 시간 창의 집계보다 더 중요한 경우에 다양한 변형이 있는 라인 그래프를 매끄럽게 만드는 데 도움이 될 수 있습니다.

    `SLIDE BY`를 사용하려면 쿼리에서 `TIMESERIES` 조항 뒤에 배치합니다. 예를 들어, 이 쿼리는 1분 `SLIDE BY` 간격으로 5분 창의 데이터를 가져옵니다. 즉, 각 창은 5분 동안 지속되지만, 창 1은 0분에 시작하고, 창 2는 1분에 시작하고, 창 3은 2분에서 시작하는 것입니다.

    ```sql
    SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute
    ```

    `SLIDE BY`를 사용하는 방법과 시기에 대한 자세한 내용은 [슬라이딩 창으로 더 보기 쉬운 차트 만들기](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows)를 참조하십시오. 또는 이 짧은 비디오(약 3분 20초)를 시청하십시오.

    <Video
      id="b9WVyb1wU6w"
      type="youtube"
    />

    <CollapserGroup>
      <Collapser
        id="sliding-window-max-auto"
        title={<><InlineCode>SLIDE BY</InlineCode> with <InlineCode>MAX</InlineCode> or <InlineCode>AUTO</InlineCode> interval 사용</>}
      >
        `MAX` 또는 `AUTO`와 함께 슬라이딩 창을 사용할 수 있습니다. 그러나 `MAX` 또는 `AUTO`는 `TIMESERIES`와 `SLIDE BY` 사이에 둘 수 없습니다.

        이 쿼리는 자동으로 `SLIDE BY` 창 간격을 결정합니다.

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO
        ```

        이 쿼리는 SLIDE BY 창을 최대 간격 단위로 설정합니다.

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX
        ```

        <Callout variant="important">
          `AUTO` 또는 `MAX`에 의해 결정된 `SLIDE BY` 값은 창 크기보다 큰 단계 간격을 생성할 수 있으며, 이로 인해 간격과 예기치 않은 결과가 발생할 수 있습니다.
        </Callout>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timeseries"
    title={<><InlineCode>TIMESERIES</InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      TIMESERIES integer units
      ...
    ```

    `TIMESERIES` 조항을 사용하여 데이터를 지정된 기간으로 분류된 시계열로 반환합니다. `TIMESERIES`는 특정 차트를 트리거하는 데 사용되므로 기본값이 없습니다.

    시간 범위를 나타내려면 `integer units`를 사용합니다. 예:

    * `TIMESERIES 1 minute`
    * `TIMESERIES 30 minutes`
    * `TIMESERIES 1 hour`
    * `TIMESERIES 30 seconds`

    `TIMESERIES` 아래 예와 같이 쿼리 결과를 추가로 맞춤화하기 위해 `MAX`, `AUTO` 및 `SLIDE BY` 같은 인수와 결합할 수 있습니다.

    <Callout variant="important">
      `average()` 또는 `percentile()` 같은 함수의 경우 집계 기간이 크면 이상값에 상당한 평활화 효과가 있을 수 있습니다. 이것은 쿼리가 슬라이딩 윈도우를 사용하는지 여부에 관계없이 해당됩니다.
    </Callout>

    <CollapserGroup>
      <Collapser
        id="set-interval"
        title="설정된 간격 사용"
      >
        제공된 값은 그래프를 구분하는 데 사용되는 단위를 나타냅니다. 예를 들어, 30분 증분을 보여주는 1일 그래프를 표시하려면:

        ```sql
        SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes
        ```
      </Collapser>

      <Collapser
        id="timeseries-auto"
        title="자동으로 설정된 간격 사용"
      >
        `TIMESERIES` 그래프를 합리적인 수의 분할로 나누는 `AUTO`로 설정할 수도 있습니다. 예를 들어 일일 차트는 30분 간격으로 분할되고 주간 차트는 6시간 간격으로 분할됩니다.

        이 쿼리는 6시간마다 데이터 포인트를 사용하여 1주일 동안 클라이언트 측 트랜잭션 시간의 50번째 및 90번째 백분위수를 보여주는 선 차트로 데이터를 반환합니다.

        ```sql
        SELECT average(duration), percentile(duration, 50, 90)
          FROM PageView SINCE 1 week AGO TIMESERIES AUTO
        ```
      </Collapser>

      <Collapser
        id="timeseries-max"
        title={<><InlineCode>MAX</InlineCode> interval 사용</>}
      >
        `TIMESERIES` 을 `MAX`로 설정할 수 있습니다. 그러면 지정된 기간에 허용되는 최대 간격 수로 기간이 자동으로 조정됩니다. 이렇게 하면 `TIMESERIES` 버킷을 수동으로 업데이트하지 않고도 기간을 업데이트할 수 있으며 기간이 허용되는 최대 간격 수로 분할되도록 할 수 있습니다. 반환될 최대 `TIMESERIES` 버킷 수는 366입니다.

        예를 들어 다음 쿼리는 일별 차트의 상한선인 4분 간격을 생성합니다.

        ```sql
        SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-until"
    title={<><InlineCode>UNTIL</InlineCode> 절</>}
  >
    ```sql
    SELECT ...
      UNTIL integer units AGO
      ...
    ```

    **기본값**은 **NOW**입니다. 기본값 이외의 엔드포인트을 지정하려면 `UNTIL` 만 사용합니다.

    `UNTIL` 조항을 사용하여 데이터를 반환할 시간 범위의 끝을 정의합니다. 시간 범위가 지정되면 데이터가 보존되며 시간 범위가 종료된 후 검토할 수 있습니다.

    자세한 정보 및 예는[시간 설정 조정](/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/#dash-time-picker)을 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-where"
    title={<><InlineCode>WHERE</InlineCode> 절</>}
  >
    `WHERE` 조항을 사용하여 결과를 필터링합니다. NRQL은 조항에서 지정한 조건을 충족하는 결과를 반환합니다.

    ```sql
    SELECT function(attribute) ...
      WHERE attribute [operator 'value' | IN ('value' [, 'value']) | IS [NOT] NULL ]
      [AND|OR ...]
      ...
    ```

    * 둘 이상의 조건을 지정하는 경우 `AND` 또는 `OR` 연산자로 조건을 구분합니다.
    * [SQL `JOIN`을 시뮬레이션](/docs/insights/nrql-new-relic-query-language/using-nrql/simulate-sql-join-functions-insights)하려면 `WHERE` 또는 `FACET` 절에서 커스텀 속성을 사용합니다.

    <table id="where-operators">
      <thead>
        <tr>
          <th width={150}>
            **`WHERE` 조항이 허용하는 연산자**
          </th>

          <th>
            **설명**
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `=`, `!=`, `<`, `<=` , `>`, `>=`
          </td>

          <td>
            NRQL은 표준 비교 연산자를 허용합니다. 예시: `state = 'WA'`

            부울 값이 있는 속성의 경우 `=`이 아닌 `IS`를 사용합니다.
          </td>
        </tr>

        <tr>
          <td>
            `AND`
          </td>

          <td>
            두 조건의 교차를 정의하는 데 사용됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `OR`
          </td>

          <td>
            두 조건의 합집합을 정의하는 데 사용됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `IS NULL`
          </td>

          <td>
            속성에 null 값이 있는지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `IS NOT NULL`
          </td>

          <td>
            속성에 null 값이 없는지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `IS TRUE`
          </td>

          <td>
            속성의 부울 값이 `true`인지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `IS FALSE`
          </td>

          <td>
            속성의 부울 값이 `false`인지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `IN`
          </td>

          <td>
            속성의 문자열 값이 지정된 집합에 있는지 확인합니다. 이 방법을 사용하면 여러 `WHERE` 조항을 함께 묶는 것보다 더 나은 성능을 얻을 수 있습니다.

            예: `animalType IN ('cat', 'dog', 'fish')`
          </td>
        </tr>

        <tr>
          <td>
            `NOT IN`
          </td>

          <td>
            속성의 문자열 값이 지정된 집합에 없는지 확인합니다. 이 방법을 사용하면 여러 `WHERE` 조항을 함께 묶는 것보다 더 나은 성능을 얻을 수 있습니다.

            값은 쉼표로 구분된 괄호 안에 있어야 합니다. 예를 들어:

            ```sql
            SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `LIKE`
          </td>

          <td>
            속성에 지정된 하위 문자열이 포함되어 있는지 확인합니다.

            `LIKE` 연산자에 대한 문자열 인수는 문자열의 어느 곳에서나 퍼센트 기호(%)를 와일드카드로 허용합니다. 하위 문자열이 일치하는 문자열을 시작하거나 끝내지 않는 경우 와일드카드는 문자열을 시작하거나 끝내야 합니다.

            **예:**

            `userAgentName LIKE 'IE%'`

            * IE

            * IE Mobile

              `userAgentName LIKE 'o%a%'`

            * Opera

            * Opera Mini

              `userAgentName LIKE 'o%a'`

            * Opera

              `userAgentName LIKE '%o%a%'`

            * Opera

            * Opera Mini

            * Mozilla Gecko
          </td>
        </tr>

        <tr>
          <td>
            `NOT LIKE`
          </td>

          <td>
            속성에 지정된 하위 문자열이 포함되어 있지 않은지 확인합니다.
          </td>
        </tr>

        <tr>
          <td>
            `RLIKE`
          </td>

          <td>
            속성에 지정된 Regex 하위 문자열이 포함되어 있는지 확인합니다. [RE2 구문](https://github.com/google/re2/wiki/Syntax)을 사용합니다.

            **예:**

            `appName RLIKE r'z.*|q.*''`

            * `z-app`

            * `q-app`

              `hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*'`

            * `ip-10-351-19-237`

            * `ip-10-351-2-41`

            * `ip-10-351-24-238`

            * `ip-10-351-14-15`

              <Callout variant="important">
                정규식은 기본적으로 전체 문자열 일치로 설정되므로 `^` 및 `$`는 암시적이며 추가할 필요가 없습니다.
              </Callout>
          </td>
        </tr>

        <tr>
          <td>
            `NOT RLIKE`
          </td>

          <td>
            속성에 지정된 Regex 하위 문자열이 포함되어 있지 않은지 확인합니다. [RE2 구문](https://github.com/google/re2/wiki/Syntax)을 사용합니다.
          </td>
        </tr>
      </tbody>
    </table>

    <CollapserGroup>
      <Collapser
        id="query-3-conditions"
        title="세 가지 조건이 있는 쿼리 예"
      >
        이 쿼리는 지난 24시간 동안 미국과 캐나다의 Safari 사용자에 대한 URL에 `checkout`이 있는 페이지의 브라우저 응답 시간을 반환합니다.

        ```sql
        SELECT histogram(duration, 50, 20) FROM PageView
        WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%'
        SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-metric-format"
    title={<><InlineCode>WITH METRIC_FORMAT</InlineCode> 절</>}
  >
    메트릭 데이터 쿼리에 대한 자세한 내용은 [쿼리 메트릭](#query-metrics)을 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-as-nrql-var"
    title={<><InlineCode>WITH ... AS</InlineCode> 절(NRQL 변수)</>}
  >
    ```sql
    FROM ...
      WITH function(attribute) AS var
      SELECT var
      ...
    ```

    쿼리의 어느 곳에서나 참조할 수 있는 변수로 값을 저장하려면 `WITH ... AS` 절을 사용하여 NRQL 변수를 정의합니다. 주요 규칙 및 팁:

    * `WITH ... AS` 절은 `FROM`/`SELECT` 절 앞, 중간 또는 바로 뒤에 올 수 있습니다.
    * 행 단위 함수(예: `capture()`)만 변수로 설정할 수 있습니다. `average()` 같은 집계 함수는 지원되지 않습니다.
    * 하나의 `WITH` 만 사용할 수 있지만, 쉼표로 구분되는 한 여러 NRQL 변수를 사용할 수 있습니다.
    * 정의된 NRQL 변수가 기존 속성과 이름이 동일한 경우, 해당 변수가 우선합니다.
    * 변수 이름에는 `%` 기호가 포함될 수 없습니다.

    다음은 몇 가지 예시 쿼리입니다.

    <CollapserGroup>
      <Collapser
        id="basic-nrql-var"
        title="변수의 기본적인 사용"
      >
        ```sql
        FROM Transaction
          WITH duration*1000 AS millisec
          SELECT millisec
        ```
      </Collapser>

      <Collapser
        id="multiple-nrql-var"
        title="여러 변수 사용"
      >
        ```sql
        FROM Log
          WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice)
          SELECT itemId, unitPrice
        ```

        [앵커 구문 분석](#func-aparse) (`aparse()`)에 대해 보다 자세히 알아보십시오.
      </Collapser>

      <Collapser
        id="nrql-var-other-clauses"
        title="다른 절에서의 변수 사용"
      >
        이 예에서 NRQL 변수 `unitPrice`는 또 다른 변수 `unitPriceNum`을 사용하여 추출된 문자열을 숫자로 변환합니다. 그런 다음 변수는 `SELECT`, `WHERE` 및 `FACET` 절에서 사용됩니다.

        ```sql
        FROM Log
          WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice),
            numeric(unitPrice) AS unitPriceNum
          SELECT sum(unitPriceNum)
          FACET itemId
          WHERE unitPriceNum < 100
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timezone"
    title={<><InlineCode>WITH TIMEZONE</InlineCode> 절</>}
  >
    ```sql
    SELECT ... WITH TIMEZONE (selected zone)
      ...
    ```

    `WITH TIMEZONE` 조항을 사용하여 아직 지정된 시간대가 없는 쿼리의 날짜 또는 시간에 대한 시간대를 선택합니다.

    날짜 시간에 시간대를 지정하지 않고 `WITH TIMEZONE` 절을 포함하면 `since` 및 `until` 절은 제공된 시간대를 유지합니다.

    `WITH TIMEZONE` 절을 포함하지 않고 날짜 시간 문자열에 시간대를 포함하면 날짜 시간 문자열 시간대가 유지됩니다.

    <Callout variant="important">
      지정되지 않은 경우 기본 시간대는 항상 UTC입니다. 결과의 원시 타임스탬프 값(JSON 뷰에 표시)은 항상 UTC입니다. UI는 계정 설정에서 지정한 시간대로 결과를 표시합니다. 타임스탬프 문자열의 시간대는 항상 작동합니다. 이는 `WITH TIMEZONE` 시간대를 대체합니다.
    </Callout>

    예를 들어 쿼리 절 `SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'`은 미국/뉴욕 시간으로 월요일 자정부터 미국/뉴욕 시간으로 화요일 자정까지 기록된 데이터를 반환합니다.

    다음은 쿼리 타임스팬 절의 몇 가지 예입니다.

    * `WITH TIMEZONE` 절을 사용하는 날짜 시간 문자열에 시간대가 없습니다.

      ```sql
      SINCE today UNTIL '2022-05-19T12:00' WITH TIMEZONE 'America/Los_Angeles'
      ```

      이는 `"beginTime": "2022-05-19T07:00:00Z"` 및 `"endTime": "2022-05-19T19:00:00Z"`로 해결됩니다.

    * `WITH TIMEZONE` 절을 사용하지 않는 날짜 시간 문자열의 시간대:

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500'
      ```

      이는 `"beginTime": "2022-05-19T00:00:00Z"` 및 `"endTime": "2022-05-19T17:00:00Z"`로 해결됩니다.

    * 일광 절약 시간제 동안 -0700인 미국/로스앤젤레스 `WITH TIMEZONE` 절을 사용하는 날짜 시간 문자열의 시간대:

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500' WITH TIMEZONE 'America/Los_Angeles'
      ```

      이는 `"beginTime": "2022-05-19T07:00:00Z"` 및 `"endTime": "2022-05-19T19:00:00Z"`로 해결됩니다.

    <table style={{ width: "auto" }}>
      <thead>
        <tr>
          <th colSpan={4}>
            사용 가능한 시간대 선택
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            아프리카/아비장
          </td>

          <td>
            아프리카/아디스아바바
          </td>

          <td>
            아프리카/알제
          </td>

          <td>
            아프리카/블랜타이어
          </td>
        </tr>

        <tr>
          <td>
            아프리카/카이로
          </td>

          <td>
            아프리카/빈트후크
          </td>

          <td>
            아메리카/아닥
          </td>

          <td>
            아메리카/앵커리지
          </td>
        </tr>

        <tr>
          <td>
            아메리카/아라과이나
          </td>

          <td>
            아메리카/아르헨티나/부에노스아이레스
          </td>

          <td>
            아메리카/벨리즈
          </td>

          <td>
            아메리카/보고타
          </td>
        </tr>

        <tr>
          <td>
            아메리카/캄포\_그란데
          </td>

          <td>
            아메리카/칸쿤
          </td>

          <td>
            아메리카/카라카스
          </td>

          <td>
            아메리카/시카고
          </td>
        </tr>

        <tr>
          <td>
            아메리카/치와와
          </td>

          <td>
            아메리카/도슨\_크릭
          </td>

          <td>
            아메리카/덴버
          </td>

          <td>
            아메리카/엔세나다
          </td>
        </tr>

        <tr>
          <td>
            아메리카/글레이스\_베이
          </td>

          <td>
            아메리카/갓탑
          </td>

          <td>
            아메리카/구스베이
          </td>

          <td>
            아메리카/하바나
          </td>
        </tr>

        <tr>
          <td>
            아메리카/라파스
          </td>

          <td>
            아메리카/로스앤젤레스
          </td>

          <td>
            아메리카/미클롱
          </td>

          <td>
            아메리카/몬테비데오
          </td>
        </tr>

        <tr>
          <td>
            아메리카/뉴욕
          </td>

          <td>
            아메리카/노로냐
          </td>

          <td>
            아메리카/산티아고
          </td>

          <td>
            아메리카/상파울루
          </td>
        </tr>

        <tr>
          <td>
            아메리카/세인트\_존스
          </td>

          <td>
            아시아/아나디르
          </td>

          <td>
            아시아/방콕
          </td>

          <td>
            아시아/베이루트
          </td>
        </tr>

        <tr>
          <td>
            아시아/다마스쿠스
          </td>

          <td>
            아시아/다카
          </td>

          <td>
            아시아/두바이
          </td>

          <td>
            아시아/가자
          </td>
        </tr>

        <tr>
          <td>
            아시아/홍콩
          </td>

          <td>
            아시아/이르쿠츠크
          </td>

          <td>
            아시아/예루살렘
          </td>

          <td>
            아시아/카불
          </td>
        </tr>

        <tr>
          <td>
            아시아/카트만두
          </td>

          <td>
            아시아/콜카타
          </td>

          <td>
            아시아/크라스노야르스크
          </td>

          <td>
            아시아/마가단
          </td>
        </tr>

        <tr>
          <td>
            아시아/노보시비르스크
          </td>

          <td>
            아시아/랑군olation
          </td>

          <td>
            아시아/서울
          </td>

          <td>
            아시아/타슈켄트
          </td>
        </tr>

        <tr>
          <td>
            아시아/테헤란
          </td>

          <td>
            아시아/도쿄
          </td>

          <td>
            아시아/블라디보스토크
          </td>

          <td>
            아시아/야쿠츠크
          </td>
        </tr>

        <tr>
          <td>
            아시아/예카테린부르크
          </td>

          <td>
            아시아/예레반
          </td>

          <td>
            대서양/아조레스 제도
          </td>

          <td>
            대서양/케이프 베르데
          </td>
        </tr>

        <tr>
          <td>
            대서양/스탠리
          </td>

          <td>
            호주/애들레이드
          </td>

          <td>
            호주/브리즈번
          </td>

          <td>
            호주/다윈
          </td>
        </tr>

        <tr>
          <td>
            호주/유클라
          </td>

          <td>
            호주/호바트
          </td>

          <td>
            호주/로드\_하위
          </td>

          <td>
            호주/퍼스
          </td>
        </tr>

        <tr>
          <td>
            칠레/이스터섬
          </td>

          <td>
            기타/GMT+10
          </td>

          <td>
            기타/GMT+8
          </td>

          <td>
            기타/GMT-11
          </td>
        </tr>

        <tr>
          <td>
            기타/GMT-12
          </td>

          <td>
            유럽/암스테르담
          </td>

          <td>
            유럽/벨파스트
          </td>

          <td>
            유럽/베오그라드
          </td>
        </tr>

        <tr>
          <td>
            유럽/브뤼셀
          </td>

          <td>
            유럽/더블린
          </td>

          <td>
            유럽/리스본
          </td>

          <td>
            유럽/런던
          </td>
        </tr>

        <tr>
          <td>
            유럽/민스크
          </td>

          <td>
            유럽/모스크바
          </td>

          <td>
            태평양/오클랜드
          </td>

          <td>
            태평양/채텀
          </td>
        </tr>

        <tr>
          <td>
            태평양/갬비어
          </td>

          <td>
            태평양/키리티마티
          </td>

          <td>
            태평양/마르키즈
          </td>

          <td>
            태평양/미드웨이
          </td>
        </tr>

        <tr>
          <td>
            태평양/노퍽
          </td>

          <td>
            태평양/통가푸
          </td>

          <td>
            UTC
          </td>
        </tr>
      </tbody>
    </table>

    자세한 정보와 예는 [대시보드 및 차트에서 시간 범위 설정](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets)을 참조하십시오.
  </Collapser>
</CollapserGroup>

## 메트릭 데이터 쿼리 [#query-metrics]

메트릭 데이터는 다른 유형의 데이터보다 복잡합니다. 이를 효과적으로 쿼리하기 위한 몇 가지 팁이 있습니다. 두 가지 유형의 메트릭 데이터가 있으며 각각 고유한 쿼리 지침이 존재합니다.

* Metric API 및 해당 API를 사용하는 일부 솔루션(예:[Dropwizard 통합](/docs/more-integrations/open-source-telemetry-integrations/dropwizard/dropwizard-reporter) 또는 [Micrometer 통합](/docs/more-integrations/open-source-telemetry-integrations/micrometer/micrometer-metrics-registry) )에서 보고하는 [차원 메트릭을 쿼리합니다.](/docs/data-ingest-apis/get-data-new-relic/metric-api/view-query-you-metric-data)
* [쿼리 메트릭 타임슬라이스 데이터](/docs/query-data/nrql-new-relic-query-language/nrql-query-tutorials/query-metric-timeslice-data-nrql)는 APM, 모바일 모니터링 및 브라우저 모니터링에서 보고한 기존 메트릭 데이터 유형입니다.

메트릭 데이터를 보고하는 방법에 대한 자세한 내용은 [메트릭 데이터 유형](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics)을 참조하십시오.

## 기능 [#functions]

이 섹션에서는 NRQL 함수, 즉 [집계 기능](#aggregator-functions)과 [비](#non-aggregator-functions) 집계 기능에 대해 설명합니다.

### 집합기 기능 [#aggregator-functions]

집계 함수를 사용하여 데이터를 필터링하고 집계할 수 있습니다. 사용을 위한 몇 가지 팁은 다음과 같습니다.

* [필터 쿼리](http://newrelic.wistia.com/medias/8k4xbxlfwj), [Apdex 쿼리](http://newrelic.wistia.com/medias/46dvx1mkm0) 및 [백분위수 쿼리](http://newrelic.wistia.com/medias/j3htrz66l0)에 대한 New Relic University 자습서를 참조하십시오. 또는 [NRQL 쿼리 작성](https://learn.newrelic.com/writing-nrql-queries)에 대한 전체 온라인 과정을 방문하십시오.

* 동일한 쿼리(예: `SELECT median(one_metric), median(another_metric)` )에서 집계 함수를 여러 번 사용하는 경우 결과 표시에 문제가 발생할 수 있습니다. 이 문제를 해결하려면 [`AS` 함수](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-as)를 사용합니다. 예:

  ```sql
   SELECT median(one_metric) as 'med-a', median(another_metric) as 'med-b'
  ```

* 데이터 유형 "강제"는 지원되지 않습니다. [사용 가능한 유형 변환 함수](#type-conversion)에 대해 알아보십시오.

* 시간 경과에 따른 결과를 표시하는 방법은 시간 경과에 [따른 결과 그룹화](/docs/insights/new-relic-insights/features/cohort-analysis)를 참조하십시오.

예:

```sql
SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
```

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="func-aggregationendtime"
    title={<InlineCode>aggregationendtime()</InlineCode>}
  >
    `aggregationendtime()` 함수를 사용하여 관련 집계 시간을 반환합니다. 더 구체적으로 말하면, 주어진 집계에 대해 `aggregationendtime()` 함수는 해당 집계 기간의 끝 타임스탬프를 제공합니다. 예를 들어, 시계열 쿼리에서 1시간 분량의 데이터를 포함하는 데이터 포인트의 경우 함수는 해당 시간 기간의 끝 타임스탬프를 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-apdex"
    title={<InlineCode>apdex(attribute, t: )</InlineCode>}
  >
    `apdex` 함수를 사용하여 단일 트랜잭션 또는 모든 트랜잭션에 대한 [Apdex 점수](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#score)를 반환합니다. [속성](/docs/insights/new-relic-insights/decorating-events/insights-attributes)은 [`duration`](/docs/insights/insights-data-sources/default-events-attributes/apm-default-event-attributes#txn-duration) 또는 [`backendDuration`](/docs/insights/insights-data-sources/default-events-attributes/browser-default-events-attributes-insights#backend-duration) 같이 응답 시간을 기반으로 하는 모든 속성이 될 수 있습니다. `t:` 인수는 선택한 속성과 동일한 시간 단위로 [Apdex T](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) 임계값을 정의합니다. 예를 들어 속성이 초 단위로 측정되는 경우 `t`는 초 단위 임계값이 됩니다.

    `apdex()` 함수에서 반환된 Apdex 점수는 실행 시간에만 기반합니다. APM 오류는 고려하지 않습니다. 트랜잭션에 오류가 있지만 [Apdex T](/docs/apm/new-relic-apm/getting-started/glossary#apdex_t) 이하에서 완료되는 경우, 해당 트랜잭션은 `apdex ()` 함수에 의해 [만족스러운](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#bullet-satisfied) 것으로 평가됩니다.

    <CollapserGroup>
      <Collapser
        id="apdex-cust-attributes"
        title="특정 고객을 위한 Apdex 받기"
      >
        [사용자 정의 속성을 정의한](/docs/insights/new-relic-insights/decorating-events/insights-custom-attributes) 경우 해당 속성을 기반으로 필터링할 수 있습니다. 예를 들어, 특히 중요한 고객의 Apdex를 모니터링할 수 있습니다.

        ```sql
        SELECT apdex(duration, t: 0.4) FROM Transaction
          WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago
        ```
      </Collapser>

      <Collapser
        id="apdex-transaction"
        title="특정 트랜잭션에 대한 Apdex 가져오기"
      >
        `name` 속성을 사용하여 특정 트랜잭션에 대한 점수를 반환하거나 `name`을 생략하여 전체 Apdex를 반환합니다. 이 쿼리는 지난 1시간 동안의 **Controller/notes/index** 트랜잭션에 대한 Apdex 점수를 반환합니다.

        <img
          title="crop-apdex-function"
          alt="crop-apdex-function"
          src={queriesnrqlApdexNRQLQueryBuilder}
        />

        <figcaption>
          `apdex` 함수는 사이트에 대한 사용자 만족도를 측정하는 [Apdex 점수](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction)를 반환합니다. 인수는 응답 시간 속성 및 Apdex T 임계값(초)입니다.
        </figcaption>

        ```sql
        SELECT apdex(duration, t: 0.5) from Transaction
        WHERE name='Controller/notes/index' SINCE 1 hour ago
        ```
      </Collapser>

      <Collapser title="앱에 대한 전체 Apdex 가져오기">
        이 예제 쿼리는 지난 3주 동안 애플리케이션에 대한 전체 Apdex를 반환합니다.

        ```sql
        SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-average"
    title={<InlineCode>average(attribute)</InlineCode>}
  >
    `average()` 함수를 사용하여 속성의 평균 값을 반환합니다. 단일 속성 이름을 인수로 사용합니다. 속성 값이 숫자가 아니면 집계할 때 무시됩니다. 쿼리 조건과 일치하는 데이터를 찾을 수 없거나 쿼리에서 반환된 숫자 값이 없으면 null 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-buckets"
    title={<InlineCode>buckets(attribute, ceiling \[,number of buckets])</InlineCode>}
  >
    `buckets()` 함수를 사용하여 `FACET` 조항로 분할된 데이터를 범위를 기반으로 버킷으로 집계합니다. 뉴렐릭 데이터베이스에 숫자 값으로 저장된 모든 속성으로 버킷을 만들 수 있습니다.

    세 가지 인수가 필요합니다.

    * Attribute name(속성 이름)

    * 샘플 범위의 최대값입니다. 모든 이상치는 최종 버킷에 나타납니다.

    * Total number of buckets(총 버킷 수)

      자세한 내용과 예는 [데이터를 버킷으로 분할](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/segment-your-insights-data-buckets)을 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-bucket-percentile"
    title={<InlineCode>bucketPercentile(attribute)</InlineCode>}
  >
    `bucketPercentile()` 함수는 Prometheus의 [`histogram_quantile`](https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile) 함수에 해당하는 NRQL입니다. 차원 메트릭 데이터와 함께 사용하기 위한 것입니다. quantile 대신 뉴렐릭은 quantile \* 100인 백분위수를 반환합니다.

    `bucketPercentile()` 함수를 사용하여 Prometheus 형식의 히스토그램 데이터에서 분위수를 계산합니다.

    버킷 이름을 인수로 사용하고 버킷 경계를 따라 백분위수를 보고합니다.

    ```sql
    SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago
    ```

    선택적으로 백분위수 사양을 인수로 추가할 수 있습니다.

    ```sql
    SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago
    ```

    Prometheus 히스토그램 데이터를 구성하는 데 여러 측정항목이 사용되기 때문에 연결된 `<basename>` 측면에서 특정 Prometheus 메트릭을 쿼리해야 합니다.

    예를 들어, NRQL을 사용하는 `<basename>` `prometheus_http_request_duration_seconds`와 함께 Prometheus 히스토그램에서 백분위수를 계산하려면 `bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)`을 사용합니다. \_bucket이 `<basename>` 끝에 접미사로 추가되는 방식에 유의하십시오.

    자세한 내용은 [Prometheus.io 문서](https://prometheus.io/docs/concepts/metric_types/#histogram)를 참조하세요.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cardinality"
    title={<InlineCode>cardinality(attribute)</InlineCode>}
  >
    `cardinality()` 함수를 사용하여 메트릭의 모든 [측정기준](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics)(속성) 조합 수를 가져옵니다.

    세 개의 인수가 필요하며 모두 선택 사항입니다.

    * 측정항목 이름: 있는 경우 `cardinality()`은 지정된 메트릭만 계산합니다.

    * Include(포함): 존재하는 경우, 포함 목록은 카디널리티 계산을 해당 속성으로 제한합니다.

    * Exclude(제외): 존재하는 경우 제외 목록으로 인해 카디널리티 계산에서 해당 속성이 무시됩니다.

      ```sql
      SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list})
      ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-count"
    title={<InlineCode>count(\*)</InlineCode>}
  >
    `count()` 함수를 사용하여 사용 가능한 레코드 수를 반환합니다. 단일 인수가 필요합니다. `*` , 속성 또는 상수 값입니다. 현재는 일반적인 SQL 동작을 따르고 해당 인수에 대한 값이 있는 모든 레코드를 계산합니다.

    `count(*)`는 특정 속성의 이름을 지정하지 않으므로 결과는 기본 ["humanize"](/docs/insights/new-relic-insights/managing-dashboards-data/data-formatter-setting-default-formats-numeric-values#format) 형식으로 지정됩니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="derivative"
    title={<InlineCode>derivative(attribute \[,time interval])</InlineCode>}
  >
    `derivative()` 주어진 데이터 세트의 변화율을 찾습니다. 변화율은 도함수를 근사화하기 위해 선형 최소제곱 회귀를 사용하여 계산됩니다. 이 계산에는 둘 이상의 데이터 포인트를 비교해야 하므로 평가 범위에 하나의 데이터 포인트만 포함되는 경우 계산이 불확실하고 작동하지 않아 `null` 값이 생성됩니다.

    `time interval`은 변화율이 계산되는 기간입니다. 예를 들어, `derivative(attributeName, 1 minute)`는 분당 변경 비율을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-dimensions"
    title={<InlineCode>{'dimensions(include: {attributes}, exclude: {attributes})'}</InlineCode>}
  >
    `dimensions()` 함수를 사용하여 데이터 유형의 모든 차원 값을 반환합니다.

    선택적 인수를 사용하여 특정 속성을 명시적으로 포함하거나 제외할 수 있습니다.

    * 포함: 있는 경우 포함 목록은 `dimensions()`를 해당 속성으로 제한합니다.

    * 제외: 있는 경우, `dimensions()` 계산은 해당 속성을 무시합니다.

      ```sql
      FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions()
      ```

      `FACET` 조항과 함께 사용하면 `dimensions()`는 Prometheus가 집계되지 않은 쿼리에서 작동하는 방식과 유사하게 이벤트 유형에서 사용 가능한 모든 패싯에 대해 고유한 시계열을 생성합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="latestrate"
    title={<InlineCode>latestrate(attribute, time interval)</InlineCode>}
  >
    `latestrate()` 함수를 사용하여 마지막 2개의 데이터 포인트를 기반으로 한 값의 변화율을 반환합니다. 문제의 속성을 첫 번째 인수로 사용하고 결과 비율에 대한 시간 단위를 두 번째 인수로 사용합니다. 이 함수는 `change in attribute/time interval` 단위로 결과를 반환합니다.

    이 기능은 최첨단 추세를 보기 위해 속성에 대한 가장 최근의 변경 비율을 제공하는 데 유용할 수 있습니다.

    <CollapserGroup>
      <Collapser title="PageView Duration의 가장 최근 변화율을 가져오기">
        이 쿼리는 마지막 2개의 데이터 포인트를 기반으로 하는 기간의 변화율을 반환합니다. `1 SECOND` 인수때문에 `duration/second` 단위로 반환됩니다.

        ```sql
        SELECT latestrate(duration, 1 SECOND) FROM PageView
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-max"
    title={<InlineCode>max(attribute)</InlineCode>}
  >
    `max()` 함수를 사용하여 지정된 시간 범위 동안 숫자 속성의 최대 기록 값을 반환합니다. 단일 속성 이름을 인수로 사용합니다. 속성 값이 숫자가 아니면 집계할 때 무시됩니다. 쿼리 조건과 일치하는 데이터를 찾을 수 없거나 쿼리에서 반환된 숫자 값이 없으면 null 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-median"
    title={<InlineCode>median(attribute)</InlineCode>}
  >
    `median()` 함수를 사용하여 속성의 중앙값 또는 50번째 백분위수를 반환합니다. 백분위수 쿼리에 대한 자세한 내용은 백분위 [수()](#func-percentile)를 참조하십시오.

    <Callout variant="tip">
      `median()` 쿼리는 [쿼리 빌더](/docs/chart-builder/use-chart-builder/get-started/introduction-chart-builder)를 사용할 때만 사용할 수 있습니다.
    </Callout>

    <CollapserGroup>
      <Collapser title="중앙값 쿼리">
        이 쿼리는 중앙값에 대한 라인 차트를 생성합니다.

        ```sql
        SELECT median(duration) FROM PageView TIMESERIES AUTO
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-min"
    title={<InlineCode>min(attribute)</InlineCode>}
  >
    `min()` 함수를 사용하여 지정된 시간 범위 동안 숫자 속성의 최소 기록 값을 반환합니다. 단일 속성 이름을 인수로 사용합니다. 속성 값이 숫자가 아니면 집계할 때 무시됩니다. 쿼리 조건과 일치하는 데이터를 찾을 수 없거나 쿼리에서 반환된 숫자 값이 없으면 null 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-minOf"
    title={<InlineCode>minuteOf(attribute)</InlineCode>}
  >
    `minuteOf()` 함수를 사용하여 유효한 타임스탬프 값을 보유하는 속성의 '분' 부분(0-59분)만 추출합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mod"
    title={<InlineCode>mod(attribute, divisor)</InlineCode>}
  >
    `mod()` 함수를 사용하여 제공된 숫자 속성 값(첫 번째 인수 또는 피제수)을 숫자 값(두 번째 인수 또는 제수)으로 나눈 후 하한 계수를 반환합니다. 이 모듈로 연산은 WHERE 조항 조건 내에서 결과의 임의 하위 집합으로 필터링하거나 FACET 조항 내에서 결과 집합을 세분화하는 방법으로 사용할 수 있습니다.

    <CollapserGroup>
      <Collapser title={<><InlineCode>mod()</InlineCode> <InlineCode>WHERE</InlineCode> 조항 조건 내에서</>}>
        ```sql
        FROM Transaction SELECT * WHERE mod(port, 2) = 1
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title={<><InlineCode>mod()</InlineCode> <InlineCode>FACET</InlineCode> 조항 내에서</>}>
        ```sql
        FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentage"
    title={<InlineCode>percentage(function(attribute), WHERE condition)</InlineCode>}
  >
    `percentage()` 함수를 사용하여 일부 조건과 일치하는 대상 데이터 세트의 백분율을 반환합니다.

    첫 번째 인수에는 원하는 속성에 대한 [집계 함수](#functions)가 필요합니다. 정확히 두 개의 인수를 사용하십시오. (처음 두 개 이후의 인수는 무시됨) 속성이 숫자가 아니면 이 함수는 100% 값을 반환합니다.

    ```sql
    FROM Transaction SELECT percentage(count(*), WHERE error is true ) AS 'Error Percent' Where host LIKE '%west%' EXTRAPOLATE
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentile"
    title={<InlineCode>percentile(attribute \[, percentile \[, ...]])</InlineCode>}
  >
    `percentile()` 함수를 사용하여 지정된 백분위수에서 속성의 대략적인 값을 반환합니다. 속성이 필요하며 백분위수를 나타내는 인수를 원하는 만큼 사용할 수 있습니다. `percentile()` 함수를 사용하면 백분위수를 소수점 이하 3자리까지 표시할 수 있어 정밀도가 향상됩니다. 백분위수 임계값은 십진수 값으로 지정할 수 있지만 대부분의 데이터 세트에서 서로 0.1보다 가까운 백분위수는 확인되지 않습니다.

    <img
      title="percentile.png"
      alt="percentile.png"
      src={queriesnrqlPercentileNRQLQueryBuilder}
    />

    <figcaption>
      백분위수 표시 예
    </figcaption>

    `TIMESERIES`를 사용하여 시간 경과에 따라 매핑된 백분위수가 있는 라인 차트를 생성합니다.

    * 백분위수에 대한 집계 값을 표시하는 빌보드 및 속성 시트를 생성하려면 `TIMESERIES`를 생략합니다.

      백분위수가 나열되지 않으면 기본값은 95번째 백분위수입니다. 50번째 백분위수 값인 중앙값만 반환하려면 [median()](#func-median)을 사용할 수도 있습니다.

      <CollapserGroup>
        <Collapser title="기본 백분위수 쿼리">
          이 쿼리는 5번째, 50번째, 95번째 백분위수에 대한 선이 있는 라인 차트를 생성합니다.

          ```sql
          SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="predictLinear"
    title={<InlineCode>predictLinear(attribute, \[,time interval])</InlineCode>}
  >
    `predictLinear()` `derivative()` 함수의 확장입니다. 데이터 세트의 미래 값을 예측하기 위해 유사한 최소 제곱 선형 회귀 방법을 사용합니다.

    * `time interval`은 쿼리가 앞으로 얼마나 멀리 볼 것인지입니다. 예를 들어, `predictLinear(attributeName, 1 hour)`는 쿼리 시간 창에서 1시간 후의 선형 예측입니다.
    * 일반적으로 `predictLinear()`는 디스크 공간과 같이 지속적으로 증가하는 값이나 큰 추세에 대한 예측에 유용합니다.
    * `predictLinear()` 선형 회귀이므로 쿼리되는 데이터세트에 익숙하면 정확한 장기 예측을 보장하는 데 도움이 됩니다.
    * 기하급수적으로, 대수적으로 또는 기타 비선형 수단에 의해 증가하는 데이터 세트는 단기 예측에서만 성공할 가능성이 높습니다.
    * 뉴렐릭은 `TIMESERIES` 쿼리에서 `predictLinear` 사용을 권장하지 않습니다. 이는 각 버킷이 쿼리 내 상대적인 시간 프레임을 기반으로 개별 예측을 수행하기 때문입니다. 즉, 이러한 쿼리는 시계열의 끝부터 예측을 표시하지 않습니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-rate"
    title={<InlineCode>rate(function(attribute) \[,time interval])</InlineCode>}
  >
    `rate()` 함수를 사용하여 시간 간격당 주어진 쿼리의 빈도 또는 비율을 시각화합니다. 예를 들어, 한 시간 동안 분당 페이지뷰 수 또는 하루 동안 시간당 사이트의 고유 세션 수를 알고 싶을 수 있습니다.

    * [`TIMESERIES`](#sel-timeseries)를 사용하여 시간에 따라 매핑된 요율이 있는 라인 차트를 생성합니다.

    * 시간 경과에 따른 평균 단일 요율 값을 표시하는 빌보드를 생성하려면 [`TIMESERIES`](#sel-timeseries)를 생략합니다.

      다음은 지난 6시간 동안 10분당 APM 트랜잭션의 처리량 비율을 보여주는 라인 차트를 생성하는 기본 쿼리입니다.

      ```sql
      SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago
      TIMESERIES
      ```

      다음은 `rate`를 사용하여 여러 기간의 데이터를 비교하는 방법을 설명하는 짧은 동영상(3분 21분)입니다.

      <Video
        id="9UArmB4QiVM"
        type="youtube"
      />
  </Collapser>

  <Collapser
    className="freq-link"
    id="round"
    title={<InlineCode>round(attribute)</InlineCode>}
  >
    `round()` 함수를 사용하여 속성의 반올림된 값을 반환합니다.

    선택적으로 `round()`는 두 번째 인수 `to_nearest`를 사용하여 첫 번째 인수를 두 번째 인수의 가장 가까운 배수로 반올림할 수 있습니다. `to_nearest`는 소수일 수 있습니다.

    ```sql
    SELECT round(n [, to_nearest])
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="stddev"
    title={<InlineCode>stddev(attribute)</InlineCode>}
  >
    `stddev()` 함수를 사용하여 지정된 시간 범위에 걸쳐 숫자 속성에 대해 하나의 [표준 편차](https://en.wikipedia.org/wiki/Standard_deviation)를 반환합니다. 단일 인수가 필요합니다. 속성이 숫자가 아니면 0 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="stdvar"
    title={<InlineCode>stdvar(attribute)</InlineCode>}
  >
    `stdvar()` 함수를 사용하여 지정된 시간 범위에 대한 숫자 속성의 [표준 분산](https://en.wikipedia.org/wiki/Variance)을 반환합니다.

    단일 인수가 필요합니다. 속성이 숫자가 아니면 0 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-sum"
    title={<InlineCode>sum(attribute)</InlineCode>}
  >
    `sum()` 함수를 사용하여 지정된 시간 범위 동안 숫자 속성의 기록된 값 합계를 반환합니다.

    단일 인수가 필요합니다. 첫 번째 인수 이후의 인수는 무시됩니다. 속성이 숫자가 아니면 0 값을 반환합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniqueCount"
    title={<InlineCode>uniqueCount(attribute)</InlineCode>}
  >
    `uniqueCount()` 함수를 사용하여 지정된 시간 범위 동안 속성에 대해 기록된 고유 값의 수를 반환합니다.

    <Callout variant="tip">
      쿼리 성능을 최적화하기 위해 이 함수는 256개 이상의 고유 값을 검사하는 쿼리에 대해 대략적인 결과를 반환합니다.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniques"
    title={<><InlineCode>uniques(attribute ,limit</InlineCode><InlineCode>)</InlineCode></>}
  >
    `uniques()` 함수를 사용하여 지정된 시간 범위 동안 속성에 대해 기록된 고유 값 목록을 반환합니다. `facet` 조항과 함께 사용하면 각 패싯 값마다 고유한 속성 값 목록이 반환됩니다.

    `limit` 매개변수는 선택사항입니다. 제공되지 않으면 패싯당 고유 속성 값 1,000개의 기본 제한이 적용됩니다. 최대 10,000까지 다른 `limit` 값을 지정할 수 있습니다. `uniques()` 함수는 한계에 도달할 때까지 발견된 고유 속성 값의 첫 번째 세트를 반환합니다. 따라서 데이터 세트에 5,000개의 고유 속성 값이 있고 한도가 1,000으로 설정된 경우 연산자는 빈도에 관계없이 발견한 처음 1,000개의 고유 값을 반환합니다.

    쿼리 결과에서 반환될 수 있는 값의 최대 수는 `uniques()` 한도 `facet` 한도의 곱입니다. 다음 쿼리에서 반환될 수 있는 이론적 최대 값 수는 5백만(5,000 x 1,000)입니다.

    쿼리되는 데이터 세트와 쿼리의 복잡성에 따라 메모리 보호 제한으로 인해 매우 큰 쿼리가 실행되지 않을 수 있습니다.

    ```sql
    From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000
    ```

    <CollapserGroup>
      <Collapser title={<>사용 <InlineCode>tuple</InlineCode></>}>
        몇 가지 속성의 고유한 조합을 알고 싶다면 `SELECT uniques(tuple(x, y, ... z)) ...` 형식으로 쿼리를 구성하여 고유한 값에 대한 튜플을 모두 가져와서 관계를 유지할 수 있습니다. 다음 쿼리에서 `tuple`은 `index` 및 `cellName`에서 함께 사용되어 두 값이 조합되어 발생하는 고유 항목을 찾습니다.

        ```sql
        FROM NodeStatus SELECT uniques(tuple(index, cellName), 5)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### 비 집계 함수 [#non-aggregator-functions]

NRQL 쿼리에서 숫자가 아닌 데이터에 대해 비 집계 함수를 사용합니다.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="acct-type"
    title={<InlineCode>accountId()</InlineCode>}
  >
    `accountId()` 함수를 사용하여 쿼리된 데이터와 연결된 [계정 ID](/docs/accounts/accounts-billing/account-structure/account-id)를 반환합니다. 이 함수는 인수를 사용하지 않습니다. 다음은 몇 가지 예시 쿼리입니다.

    <CollapserGroup>
      <Collapser title="각 트랜잭션 이벤트에 대한 계정 ID 가져오기">
        이 쿼리는 반환된 각 `Transaction` 이벤트와 연결된 계정 ID를 반환합니다.

        ```sql
        SELECT accountId() FROM Transaction SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="각 계정에 대한 트랜잭션 이벤트 수 가져오기">
        이 쿼리는 각 계정 ID와 연결된 마지막 날의 `Transaction` 이벤트 수를 반환합니다.

        ```sql
        SELECT count(*) FROM Transaction FACET accountId() SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="WHERE 조항에 지정된 각 계정에 대한 트랜잭션 이벤트 수를 가져옵니다.">
        이 쿼리는 계정 ID가 구체적으로 `1` , `2` 또는 `3` 중 하나인 마지막 날의 `Transaction` 이벤트 수를 반환합니다.

        ```sql
        SELECT count(*) FROM Transaction WHERE accountId() IN (1,2,3) SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-aparse"
    title={<><InlineCode>aparse(attribute, pattern)</InlineCode></>}
  >
    앵커 구문 분석 기능인 `aparse()`를 사용하여 문자열에서 특정 값을 추출합니다. 이는 `capture()`의 대안입니다.

    `aparse()` 두 가지 인수를 취합니다.

    * 문자열 속성
    * 앵커 문자열과 추출 문자가 있는 패턴 문자열. 예:URL에서 도메인을 추출하는 'www.\*.com'

    `aparse()`를 사용할 때, 패턴 문자열에는 'www.'와 '.com’ 같은 앵커가 포함되고 '\*'로 표시를 해야 추출하려는 문자열의 위치를 식별할 수 있습니다.

    `aparse()` 패턴 문자열에 다음 문자를 사용합니다.

    * '%' - `LIKE` 절에서 볼 수 있는 비캡처 와일드카드
    * '\*' - 정규식 캡처를 사용하는 것과 유사한 와일드카드 캡처

    실제로, 앵커 문자열은 문자열 속성의 시작이나 끝이 아닌 중간에 자주 발생합니다.

    이 경우 '%' 와일드카드를 사용하여 원치 않는 값을 무시합니다. (예: '%www.\*.com%')

    `capture()`처럼, `aparse()`의 모든 결과는 문자열입니다. 수학 함수에서 이러한 결과를 사용하려면 `numeric()` 함수로 변환해야 합니다.

    참고: `aparse()`는 대소문자를 구분하지 않습니다.

    <CollapserGroup>
      <Collapser
        title="기본적인 사용"
        id="aparse-basic"
        className="freq-link"
      >
        ```sql
        FROM PageView
          SELECT aparse(browserTransactionName, 'website.com/*')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>aparse()</InlineCode> 특정 값</>}
        id="aparse-specific-values"
        className="freq-link"
      >
        문자열 중간에서 값을 추출하려면, 패턴 문자열의 시작과 끝에 비캡처 와일드카드 '%'를 사용합니다. 예:

        ```sql
        FROM Log
          SELECT count(*)
          FACET aparse(string, '%"itemId":"*"%')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>aparse()</InlineCode> 여러 값</>}
        id="aparse-multiple-values"
        className="freq-link"
      >
        여러 값을 변수로 추출할 때는 순서가 중요합니다. 예:

        ```sql
        FROM Log
          WITH aparse(string, 'POST: * body: {"itemId":"*","unitPrice":*}\n') AS (url, itemId, unitPrice)
          SELECT url, itemId, unitPrice
        ```

        변수에 대한 보다 자세한 내용은 [NRQL 변수](#with-as-nrql-var)를 참조하십시오.
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-concat"
    title={<InlineCode>concat(attribute, \[, attribute \[, ...]]\[, precision: ]))</InlineCode>}
  >
    `concat()` 함수를 사용하여 인수를 연결한 결과 문자열을 반환합니다.

    숫자, 부울, 튜플 또는 배열 유형의 인수가 최대 20개까지 제공될 수 있습니다. Null 인수와 지원되지 않는 형식의 인수는 무시됩니다. 인수가 제공되지 않으면, 결과는 빈 문자열이 됩니다.

    부동 소수점 숫자 값을 연결할 때 포함되는 소수 자릿수를 제한하기 위해 선택 가능한 정밀도 인수가 제공될 수 있습니다.

    결과 문자열의 최대 길이는 4096자입니다.

    <CollapserGroup>
      <Collapser title="PageView에서 포맷이 지정된 문자열로 여러 기간 값 가져오기">
        이 쿼리는 소수 두 자리와 레이블로 형식이 지정된 PageView 이벤트의 백엔드 및 네트워크 기간을 단일 문자열로 반환합니다.

        ```sql
        FROM PageView SELECT concat('Backend Duration: ', backendDuration, ', Network Duration: ', networkDuration, precision: 2)
        ```

        그러면 다음과 같은 형식으로 응답이 반환됩니다.

        `Backend Duration: 0.69, Network Duration: 0`
      </Collapser>

      <Collapser title="형식이 지정된 문자열에 의한 패싯 쿼리 결과">
        이 쿼리는 사용자의 도시, 지역 및 국가로 구성된 문자열로 패싯 처리된 PageView 이벤트의 평균 연결 설정 기간을 반환합니다.

        ```sql
        FROM PageView SELECT average(connectionSetupDuration) FACET concat(city, ', ', regionCode, ' ', countryCode) WHERE countryCode IN ('US', 'CA')
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-capture"
    title={<InlineCode>캡처(속성, 정규 표현식)</InlineCode>}
  >
    [RE2 구문](https://github.com/google/re2/wiki/Syntax)이 있는 정규식을 사용하여 속성에서 값을 추출하려면 `capture()`를 사용합니다.

    두 가지 인수가 필요합니다.

    * 속성 이름.

    * 캡처 구문이 있는 정규식. NRQL의 정규 표현식은 Python과 유사한 구문 `r'...'`을 사용합니다.

      캡처할 때, 특정 이름을 고려하여 RE2 명명된 캡처 구문 `...(?P<name> pattern )...`을 사용하여 포함된 패턴을 캡처합니다.

      정규식에 추가적인 캡처 그룹을 지정하여 여러 값을 캡처할 수 있습니다. 예: `...(?P<name1> pattern1)...(?P<name2> pattern2)...`

      참고: 여러 값을 캡처할 때 각 캡처 문은 최대 16개의 캡처 그룹을 가질 수 있으며, 각 NRQL 쿼리는 최대 5개의 캡처 문을 가질 수 있습니다.

      [쿼리 결과를 개선하기 위해 정규식 캡처를 사용](https://newrelic.com/blog/how-to-relic/using-regex-capture)하는 방법을 확인하십시오.

      <Callout variant="tip">
        정규식은 전체 입력과 일치해야 합니다. 캡처 표현식이 예상 결과를 추출하지 않는 경우, 시작 또는 끝에 일부 매치 정규표현식을 위한 패턴인 `.*`가 필요한지 확인합니다. 그러나 부분 정규표현식으로 인해 쿼리 실행이 느려질 수 있습니다.
      </Callout>

      다음은 `capture()`를 사용하여 대시보드 가독성을 높이는 방법을 보여주는 짧은 동영상(3분 5분)입니다.

      <Video
        id="hOPrTWYgPHg"
        type="youtube"
      />

      자세한 내용은 아래 예를 참조하십시오.

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> <InlineCode>SELECT</InlineCode> 조항 조건 내에서</>}>
          다음은 웹사이트의 도메인 이름을 선택하고 `https://` 및 다음 경로를 제거합니다. `.com`

          ```sql
          SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') FROM PageView SINCE 1 day ago
          ```

          다음은 오류 메시지의 첫 번째 단어만 캡처합니다.

          ```sql
          SELECT capture(errorMessage, r'(?P<firstWord>\S+)\s.+') FROM Transaction SINCE 1 hour ago where errorMessage is not null
          ```
        </Collapser>

        <Collapser title={<><InlineCode>capture()</InlineCode> <InlineCode>FACET</InlineCode> 조항 조건 내에서</>}>
          다음은 캡처된 HTTP 메서드에 의해 패싯됩니다.

          ```sql
          SELECT count(*) FROM Log WHERE message like '%HTTP%' FACET capture(message, r'.* "(?P<httpMethod>[A-Z]+) .*')
          ```
        </Collapser>

        <Collapser title={<><InlineCode>capture()</InlineCode> <InlineCode>WHERE</InlineCode> 조항 조건 내에서</>}>
          다음은 캡처된 작업 이름이 `ExampleJob`인 정규식과 일치하는 `message` 속성이 있는 로그 이벤트를 기반으로 결과를 필터링합니다.

          ```sql
          SELECT message FROM Log WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' SINCE 10 minutes ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> 숫자 캐스트로</>}>
          다음은 로그 라인에서 CPU 시간의 합계를 캡처합니다. 수학 연산을 수행하려면 명시적으로 숫자로 캐스트해야 합니다.

          ```sql
          SELECT sum(numeric(capture(message, r'.*CpuTime:\s(?P<cpuTime>\d+)'))) FROM Log WHERE message like '%CpuTime:%' SINCE 1 hour ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> NRQL 변수가 있는 여러 값</>}>
          이 예에서 NRQL 변수는 로그 메시지에서 캡처된 여러 값을 저장하는 데 사용됩니다.

          ```sql
          FROM Log
            WITH capture(message, r'POST to carts: (?P<URL>.*) body: {"itemId":"(?P<UUID>.*)","unitPrice":(?P<unitPrice>.*)}.*')
              AS (URL, UUID, unitPrice)
            SELECT URL, UUID, unitPrice
            WHERE URL IS NOT NULL
          ```

          NRQL 변수에 대한 보다 자세한 내용은 [여기](#with-as-nrql-var)를 참조하십시오.
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="earliest-func"
    title={<InlineCode>earliest(attribute)</InlineCode>}
  >
    `earliest()` 함수를 사용하여 지정된 시간 범위 동안 속성에 대한 가장 이른 값을 반환합니다.

    단일 인수가 필요합니다. 첫 번째 인수 이후의 인수는 무시됩니다.

    `FACET`과 함께 사용하는 경우 각 결과 패싯에 대한 속성의 가장 최근 값을 반환합니다.

    <CollapserGroup>
      <Collapser title="PageView에서 사용자 에이전트당 가장 빠른 국가 가져오기">
        이 쿼리는 `PageView` 이벤트에서 각 사용자 에이전트당 가장 빠른 국가 코드를 반환합니다.

        ```sql
        SELECT earliest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="event-type"
    title={<InlineCode>eventType()</InlineCode>}
  >
    ```sql
    ...WHERE eventType() = 'EventNameHere'...
    ...FACET eventType()...
    ```

    [FACET](#sel-facet) 조항에서 `eventType()` 함수를 사용하여 선택한 데이터 유형별로 결과를 분류하거나 [WHERE](#sel-where) 조항에서 특정 데이터 유형으로 결과를 필터링합니다. 이는 [filter()](#func-filter) 및 [percent()](#func-percentage) 함수를 사용하여 특정 데이터 유형을 대상으로 지정할 때 특히 유용합니다.

    <Callout variant="important">
      이 컨텍스트에서 "event type"은 NRQL 쿼리로 액세스할 수 있는 데이터 유형을 나타냅니다.
    </Callout>

    <CollapserGroup>
      <Collapser
        id="filter-eventtype"
        title={<><InlineCode>filter()</InlineCode> 함수에서 <InlineCode>eventType()</InlineCode> 사용</>}
      >
        이 쿼리는 총 `Transaction`개 결과 중 총 `TransactionError`개 결과의 백분율을 반환합니다. `eventType()` 함수를 사용하여 `filter()` 함수가 있는 특정 유형의 데이터를 대상으로 지정할 수 있습니다.

        ```sql
        SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago
        ```
      </Collapser>

      <Collapser
        id="facet-eventtype"
        title={<>과 함께 <InlineCode>eventType()</InlineCode> 사용 <InlineCode>FACET</InlineCode></>}
      >
        이 쿼리는 각 데이터 유형( `Transaction` 및 `TransactionError` )가 반환하는 레코드 수를 표시합니다.

        ```sql
        SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-filter"
    title={<InlineCode>filter(function(attribute), WHERE condition)</InlineCode>}
  >
    `filter()` 함수를 사용하여 SELECT 문의 집계 함수 중 하나에 대한 결과를 제한합니다. `filter()`을 `FACET` 또는 `TIMESERIES`와 함께 사용할 수 있습니다. 필터는 다음과 같은 여러 집계를 선택할 때만 유용합니다.

    ```sql
    SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' ...
    ```

    그렇지 않으면, 표준 `WHERE` 절을 사용하는 것이 좋습니다.

    <CollapserGroup>
      <Collapser title="오퍼 코드를 사용한 구매 분석">
        `filter()`를 사용하여 제안 코드를 사용하는 사람과 사용하지 않는 사람에 대해 일련의 트랜잭션에서 구입한 항목을 비교할 수 있습니다.

        <img
          title="screenshot insights filter"
          alt="screenshot insights filter"
          src={queriesnrqlFilterNRQLQueryBuilder}
        />

        <figcaption>
          `filter()` 함수를 사용하여 `SELECT` 문의 집계 함수 중 하나에 대한 결과를 제한합니다.
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-funnel"
    title={<InlineCode>funnel(attribute, steps)</InlineCode>}
  >
    `funnel()` 함수를 사용하여 퍼널 차트를 생성합니다. 속성을 첫 번째 인수로 사용합니다. 그런 다음 단계를 쉼표로 구분된 [`WHERE`](#sel-where) 조항(레이블에 대한 선택적 [`AS`](#sel-as) 조항 포함)로 지정합니다.

    자세한 내용과 예는 [퍼널 문서](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/funnels-evaluate-data-series-events)를 참조하십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getfield"
    title={<InlineCode>getField(attribute, field)</InlineCode>}
  >
    `getField()` 함수를 사용하여 [디멘션 메트릭 데이터](/docs/data-apis/understand-data/metric-data/metric-data-type)같은 복합 데이터 유형에서 필드를 추출합니다.

    다음 인수를 취합니다.

    <table>
      <thead>
        <tr>
          <th style={{ width: "500px" }}>
            메트릭 유형
          </th>

          <th>
            지원되는 필드
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `summary`
          </td>

          <td>
            `count`, `total`, `max`, `min`, `type`
          </td>
        </tr>

        <tr>
          <td>
            `gauge`
          </td>

          <td>
            `count`, `total`, `max`, `min` , `latest`, `type`
          </td>
        </tr>

        <tr>
          <td>
            `distribution`
          </td>

          <td>
            `count`, `total`, `max`, `min`, `type`
          </td>
        </tr>

        <tr>
          <td>
            `count`
          </td>

          <td>
            `count`, `type`
          </td>
        </tr>

        <tr>
          <td>
            `cumulativeCount`
          </td>

          <td>
            `count`, `cumulative`, `type`
          </td>
        </tr>

        <tr>
          <td>
            `timeslice`
          </td>

          <td>
            `count`, `total`, `totalExclusive`, `min` , `max`, `sumOfSquares`
          </td>
        </tr>
      </tbody>
    </table>

    예:

    ```sql
    SELECT max(getField(mySummary, count)) from Metric
    ```

    ```sql
    SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-histogram"
    title={<InlineCode>histogram(attribute, ceiling \[,number of buckets])</InlineCode>}
  >
    `histogram()` 함수를 사용하여 히스토그램을 생성합니다. 세 가지 인수가 필요합니다.

    * Attribute name(속성 이름)

    * 샘플 범위의 최대값

    * 총 버킷 수(1-500, inclusive)

      <CollapserGroup>
        <Collapser
          id="histogram-response-times"
          title="PageView 이벤트의 응답 시간 히스토그램"
        >
          이 쿼리는 20개 버킷에 대해 최대 10초 범위의 응답 시간 히스토그램을 생성합니다.

          ```sql
          SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="histogram-prometheus"
          title="Prometheus 히스토그램 버킷"
        >
          `histogram()` Prometheus 히스토그램 버킷 허용:

          ```sql
          SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="distribution-metric"
          title="뉴렐릭 분포 메트릭"
        >
          `histogram()` [분포 측정항목](/docs/data-ingest-apis/get-data-new-relic/metric-api/events-metrics-service-create-metrics#limits-rules)을 입력으로 수락합니다.

          ```sql
          SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="histogram-facet-heatmap"
          title="FACET 조항이 있는 히스토그램"
        >
          `FACET` 절과 함께 `histogram()`를 사용하여 히트맵 차트를 생성합니다.

          ```sql
          SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-if"
    title={<><InlineCode>if(condition, trueValue , falseValue)</InlineCode></>}
  >
    `if()`를 사용하여 쿼리 전체에서 if-then-else 제어 흐름 작업을 수행합니다.

    `if()` 세 가지 인수를 취합니다.

    * condition - true 또는 false로 평가할 수 있는 표현식입니다.
    * trueValue - 부울 표현식이 true인 경우 이 값이 반환됩니다.
    * falseValue - 부울 표현식이 false인 경우 이 선택적 값이 반환되거나 NULL이 제공되지 않은 경우 반환됩니다.

    <CollapserGroup>
      <Collapser title="기본적인 사용">
        ```sql
        FROM Log
          SELECT count(*)
          FACET if(level_name = 'ERROR', 'ERROR', 'NOT_ERROR')
        ```
      </Collapser>

      <Collapser title={<><InlineCode>AND</InlineCode> 및 <InlineCode>OR</InlineCode></>}>
        ```sql
        FROM Log
          SELECT count(*)
          FACET if(level_name = 'INFO’ OR level_name = ‘WARNING’, 'NOT_ERROR', 'ERROR’)
        ```
      </Collapser>

      <Collapser title={<>Nested <InlineCode>If()</InlineCode></>}>
        중첩된 if() 함수를 사용하여 조건부 논리를 추가합니다.

        ```sql
        FROM Transaction SELECT count(*)
          FACET if(appName LIKE '%java%', 'Java',
          if(appName LIKE '%kafka%', 'Kafka', 'Other'))
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="keyset"
    title={<InlineCode>keyset()</InlineCode>}
  >
    `keyset()`를 사용하면 주어진 시간 범위 동안 주어진 데이터 유형에 대한 모든 속성을 볼 수 있습니다. 인수가 필요하지 않습니다. 문자열 유형 키, 숫자 유형 키, Boolean 유형 키 및 모든 키의 그룹을 포함하는 JSON 구조를 반환합니다.

    <CollapserGroup>
      <Collapser title="데이터 유형에 대한 모든 속성 보기">
        이 쿼리는 마지막 날의 `PageView` 이벤트에 대해 찾은 속성을 반환합니다.

        ```sql
        SELECT keyset() FROM PageView SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latest"
    title={<InlineCode>latest(attribute)</InlineCode>}
  >
    `latest()` 함수를 사용하여 지정된 시간 범위 동안 속성의 가장 최근 값을 반환합니다.

    단일 인수가 필요합니다. 첫 번째 인수 이후의 인수는 무시됩니다.

    `FACET`과 함께 사용하는 경우 각 결과 패싯에 대한 속성의 가장 최근 값을 반환합니다.

    <CollapserGroup>
      <Collapser title="PageView에서 사용자 에이전트당 가장 최근 국가 가져오기">
        이 쿼리는 `PageView` 이벤트에서 각 사용자 에이전트당 가장 최근의 국가 코드를 반환합니다.

        ```sql
        SELECT latest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-length"
    title={<InlineCode>length(attribute)</InlineCode>}
  >
    `length()` 함수를 사용하여 문자열 값의 길이 또는 배열 값의 요소 수를 반환합니다.

    단일 인수가 필요합니다. 첫 번째 인수 이후의 인수는 무시됩니다.

    <CollapserGroup>
      <Collapser title="PageView에서 URL 길이 가져오기">
        이 쿼리는 `PageView` 이벤트에서 각 URL 문자열의 길이를 반환합니다.

        ```sql
        SELECT length(pageUrl) FROM PageView
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-lower"
    title={<InlineCode>lower(str)</InlineCode>}
  >
    `lower()` 함수를 사용하여 문자열 값의 모든 알파벳 문자를 소문자로 변경합니다.

    인수:

    * str - 소문자가 되어야 하는 문자열 값입니다.

      * 여기에는 따옴표로 묶인 리터럴 문자열, 쿼리된 문자열 속성, 문자열을 반환하는 함수 또는 단일 문자열 값을 반환하는 하위 쿼리 등 문자열로 평가되는 모든 것이 해당될 수 있습니다.
      * 이 인수가 null로 평가되면 `lower()` 함수는 null을 반환합니다.

      <CollapserGroup>
        <Collapser title="Lower-case a string">
          이 쿼리는 쿼리의 다양한 부분에서 `lower()` 함수를 사용하는 방법을 보여줍니다.

          ```sql
          FROM PageAction
          SELECT latest(lower(actionName))
          WHERE lower(actionName) = lower('acmePageRenderedEvent') OR lower(actionName) = lower('SubmitLogin')
          FACET concat(actionName, ':', lower(actionName))
          ```

          <img
            title="screenshot lower()"
            alt="screenshot lower()"
            src={lowerExample}
          />

          <figcaption>
            <InlineCode>lower(str)</InlineCode> 예
          </figcaption>
        </Collapser>
      </CollapserGroup>

      _관련 함수: [<InlineCode>upper()</InlineCode>](#func-upper)_
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-position"
    title={<InlineCode>position(str, substr \[, occurrence])</InlineCode>}
  >
    `position()` 함수를 사용하여 문자열 내에서 하위 문자열의 위치를 찾습니다.

    인수:

    * str - 하위 문자열을 찾을 문자열입니다.

      * 여기에는 따옴표로 묶인 리터럴 문자열, 쿼리된 문자열 속성, 문자열을 반환하는 함수 또는 단일 문자열 값을 반환하는 하위 쿼리 등 문자열로 평가되는 모든 것이 해당될 수 있습니다.

    * substr - str 내에서 검색할 문자열입니다.

    * occurrence - 위치를 반환할 substr의 어커런스를 나타냅니다.

      * _기본값:_ 0
      * 양수인 경우 0을 기준으로 str의 시작 부분에서 n번째 substr을 찾습니다.
      * 음수인 경우 str의 끝 부분에서 n번째 substr을 찾습니다. substr의 마지막 어커런스는 -1 어커런스입니다.

      별칭: <InlineCode>indexOf(str, substr , occurrence)</InlineCode> - `indexOf()`는 `position()` 함수의 다른 이름입니다.

      반환:

      * str 내의 substr 시작 문자의 0부터 시작하는 인덱스입니다.
      * 참조된 substr 항목을 찾을 수 없으면 -1이 반환됩니다.
      * str 또는 substr이 null이면 null을 반환합니다.
      * 검색은 대소문자를 구분합니다.

    <CollapserGroup>
      <Collapser title="URL 내 하위 문자열의 위치 인덱스를 찾습니다.">
        이 쿼리는 <InlineCode>position()</InlineCode> 함수를 사용하여 문자열 내에서 다양한 하위 문자열의 위치 인덱스를 찾는 방법을 보여줍니다. 여기에서는 [<InlineCode>substring()</InlineCode>](#func-substring) 함수 인수 내에서 <InlineCode>position()</InlineCode> 함수를 사용하는 방법도 볼 수 있습니다.

        ```sql
        FROM PageView
        WITH position(pageUrl, ':') as FirstColon,
          position(pageUrl, '/', 1) + 1 as DomainBegin, position(pageUrl, '/', 2) as DomainEnd, DomainEnd - DomainBegin as DomainLength
        SELECT pageUrl, FirstColon, substring(pageUrl, 0, FirstColon) as Protocol,
          DomainBegin, DomainEnd, DomainLength, substring(pageUrl, DomainBegin, DomainLength) as Domain,
          position(pageUrl, '/', -1) as LastSlash, substring(pageUrl, position(pageUrl, '/', -1)) as PathEnd
        ```

        <img
          title="screenshot position()"
          alt="screenshot position()"
          src={positionExample}
        />

        <figcaption>
          <InlineCode>position(str, substr , occurrence)</InlineCode> 예
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-string"
    title={<InlineCode>string(attribute \[, precision: ])</InlineCode>}
  >
    `string()` 함수를 사용하여 숫자, 부울, 튜플 또는 배열 값을 문자열 값으로 변환합니다.

    두 개의 인수가 필요하며 하나는 선택 사항입니다.

    * Attribute name(속성 이름)
    * Precision: 있는 경우 부동 소수점 숫자 값을 변환할 때 포함되는 소수 자릿수에 대한 제한을 적용합니다.

    <CollapserGroup>
      <Collapser title="문자열이 아닌 쿼리 결과를 문자열 값으로 가져오기">
        이 쿼리는 PageView 기간을 소수점 이하 두 자리가 포함된 문자열로 반환합니다.

        ```sql
        FROM PageView SELECT string(duration, precision: 2)
        ```
      </Collapser>

      <Collapser title="문자열이 아닌 집계 함수 결과를 문자열 값으로 가져오기">
        이 쿼리는 PageView 기간의 평균을 소수점 이하 두 자리가 포함된 문자열로 반환합니다.

        ```sql
        FROM PageView SELECT string(average(duration), precision: 2)
        ```
      </Collapser>

      <Collapser title="버림(truncation) 없는 부동 소수점 숫자에 의한 패싯 쿼리 결과">
        `string()`을 사용하여 소수점 이하 자릿수를 버리지 않고 부동 소수점 값으로 패싯합니다.

        ```sql
        FROM PageView SELECT count(*) FACET string(tuple(asnLatitude, asnLongitude), precision: 2)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-substring"
    title={<InlineCode>substring(str, start \[, length])</InlineCode>}
  >
    `substring()` 함수를 사용하여 문자열의 일부를 추출합니다.

    인수:

    * str - 하위 문자열을 추출하는 문자열입니다.

      * 여기에는 따옴표로 묶인 리터럴 문자열, 쿼리된 문자열 속성, 문자열을 반환하는 함수 또는 단일 문자열 값을 반환하는 하위 쿼리 등 문자열로 평가되는 모든 것이 해당될 수 있습니다.
      * 이 인수가 null로 평가되면 `substring()` 함수는 null을 반환합니다.

    * start - 추출을 개시하는 str 내의 위치입니다.

      * str의 첫 번째 문자는 위치 0입니다.
      * 음수 값은 문자열의 마지막 문자가 위치 -1인 str의 끝을 기준으로 위치를 찾습니다.
      * start가 str의 길이보다 크거나 같으면 `substring()` 함수는 빈 문자열을 반환합니다.
      * start가 음수이고 절대값이 str의 길이보다 크면 추출된 하위 문자열은 위치 0에서 시작됩니다.

    * length - str에서 추출할 부분 문자열의 길이 또는 문자 수입니다.

      * _Optional_ - 길이가 제공되지 않으면 확인된 시작 위치 이후의 str에서 모든 문자가 포함됩니다.

      <CollapserGroup>
        <Collapser title="문자열의 다양한 부분 추출">
          이 쿼리는 세션 값의 일부를 반환합니다.

          ```sql
          FROM PageView
          SELECT session, substring(session, 0, 3) as First3,
            substring(session, 3) as After3rd,
            substring(session, -3) as Last3
          ```

          <img
            title="screenshot substring()"
            alt="screenshot substring()"
            src={substringExample}
          />

          <figcaption>
            <InlineCode>substring(str, start , length)</InlineCode> 예
          </figcaption>
        </Collapser>
      </CollapserGroup>

      _<InlineCode>substring()</InlineCode>과 <InlineCode>position()</InlineCode>을 함께 사용하는 예는 [<InlineCode>position()</InlineCode>](#func-position) 함수를 참조하십시오._
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-upper"
    title={<InlineCode>upper(str)</InlineCode>}
  >
    `upper()` 함수를 사용하여 문자열 값의 모든 알파벳 문자를 대문자로 변경합니다.

    인수:

    * str - 대문자가 되어야 하는 문자열 값입니다.

    * 여기에는 따옴표로 묶인 리터럴 문자열, 쿼리된 문자열 속성, 문자열을 반환하는 함수 또는 단일 문자열 값을 반환하는 하위 쿼리 등 문자열로 평가되는 모든 것이 해당될 수 있습니다.

    * 이 인수가 null로 평가되면 `upper()` 함수는 null을 반환합니다.

      <CollapserGroup>
        <Collapser title="Upper-case a string">
          이 쿼리는 쿼리의 다양한 부분에서 `upper()` 함수를 사용하는 방법을 보여줍니다.

          ```sql
          FROM PageAction
          SELECT latest(upper(actionName))
          WHERE upper(actionName) = upper('acmePageRenderedEvent') OR upper(actionName) = upper('SubmitLogin')
          FACET concat(actionName, ':', upper(actionName))
          ```

          <img
            title="screenshot upper()"
            alt="screenshot upper()"
            src={upperExample}
          />

          <figcaption>
            <InlineCode>upper(str)</InlineCode> 예
          </figcaption>
        </Collapser>
      </CollapserGroup>

      _관련 함수: [<InlineCode>lower()</InlineCode>](#func-lower)_
  </Collapser>
</CollapserGroup>

## 유형 변환

NRQL은 "강제"를 지원하지 않습니다. 즉, 문자열로 저장된 부동 소수점은 문자열로 취급되며 부동 소수점 값을 기대하는 함수에서 작동할 수 없습니다.

다음 함수를 사용하여 숫자 값이 있는 문자열 또는 문자열 값이 있는 부울을 해당 숫자 및 부울 값으로 변환하거나 문자열이 아닌 값을 문자열 값으로 변환할 수 있습니다.

* `numeric()` 함수를 사용하여 문자열 형식의 숫자를 숫자 값으로 변환합니다. 이 함수는 쿼리 결과에 수학 함수를 사용하는 쿼리 또는 `average()` 같은 NRQL 집계 함수에 내장될 수 있습니다.
* `boolean()` 함수를 사용하여 `"true"` 또는 `"false"`의 문자열 값을 해당 부울 값으로 변환합니다.
* `string()` 함수를 사용하여 숫자, 부울, 튜플 또는 배열 값을 문자열 값으로 변환합니다. 보다 자세한 내용은 [`string()`](#func-string) 상단의 설명을 참조하십시오.