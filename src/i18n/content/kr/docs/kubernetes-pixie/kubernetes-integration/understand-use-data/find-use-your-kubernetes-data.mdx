---
title: Kubernetes 데이터 찾기 및 사용
tags:
  - Integrations
  - Kubernetes integration
  - Understand and use data
metaDescription: 'New Relic''s Kubernetes integration: How to install and activate the integration, and what data is reported.'
translationType: machine
---

import img0NewRelicOneKubernetesDashboard from 'images/2020-04-28-17.33.47.gif'

쿼리 빌더와 NerdGraph API를 사용하여 자체 차트를 만들고 모든[Kubernetes 통합](/docs/integrations/kubernetes-integration/get-started/introduction-kubernetes-integration) 데이터를 [쿼리](/docs/using-new-relic/data/understand-data/query-new-relic-data) 할 수 있습니다. 우리의 통합은 컨테이너 오케스트레이션 계층을 계측하여 Kubernetes 데이터를 수집합니다. 더 간단하고 시각적인 경험을 위해[클러스터 탐색기](/docs/integrations/kubernetes-integration/understand-use-data/kubernetes-cluster-explorer) 를 사용하십시오.

<img
  title="2020-04-28 17.33.47.gif"
  alt="New Relic - Kubernetes dashboard"
  src={img0NewRelicOneKubernetesDashboard}
/>

<figcaption>
  **[one.newrelic.com](https://one.newrelic.com) > 대시보드** : [쿼리 빌더](/docs/chart-builder/use-chart-builder/get-started/introduction-chart-builder) 를 사용하여 Kubernetes 데이터를 쿼리하고 명확한 시각화를 생성할 수 있습니다.
</figcaption>

## Kubernetes 데이터 쿼리 [#view-data]

[Kubernetes 데이터를 쿼리](/docs/using-new-relic/data/understand-data/query-new-relic-data) 하는 가장 간단한 방법은 [NRQL 쿼리](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) 를 수락하는 [쿼리 빌더](/docs/query-your-data/explore-query-data/query-builder/use-advanced-nrql-mode-specify-data) 를 사용하는 것입니다. 또는 [NerdGraph API](/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph) 를 사용하여 Kubernetes 데이터를 검색할 수 있습니다.

### 이벤트 유형 [#event-types]

Kubernetes 데이터는 다음 [이벤트 유형](/docs/using-new-relic/data/understand-data/new-relic-data-types#event-data) 에 연결됩니다.

<table>
  <thead>
    <tr>
      <th style={{ width: "275px" }}>
        이벤트 이름
      </th>

      <th>
        Kubernetes 데이터 유형
      </th>

      <th style={{ width: "200px" }}>
        이후 사용 가능
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `K8sNodeSample`
      </td>

      <td>
        [노드 데이터](#node-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sNamespaceSample`
      </td>

      <td>
        [네임스페이스 데이터](#namespace-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sDeploymentSample`
      </td>

      <td>
        [배포 데이터](#deployment-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sReplicasetSample`
      </td>

      <td>
        [레플리카세트 데이터](#replica-set-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sDaemonsetSample`
      </td>

      <td>
        [DaemonSet 데이터](#daemonset-data)
      </td>

      <td>
        v1.13.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sStatefulsetSample`
      </td>

      <td>
        [StatefulSet 데이터](#statefulset-data)
      </td>

      <td>
        v1.13.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sPodSample`
      </td>

      <td>
        [포드 데이터](#pod-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sClusterSample`
      </td>

      <td>
        [클러스터 데이터](#cluster-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sContainerSample`
      </td>

      <td>
        [컨테이너 데이터](#container-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sVolumeSample`
      </td>

      <td>
        [볼륨 데이터](#volume-data)
      </td>

      <td>
        v1.0.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sApiServerSample`
      </td>

      <td>
        [API 서버 데이터](#api-server-data)
      </td>

      <td>
        v1.11.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sControllerManagerSample`
      </td>

      <td>
        [컨트롤러 관리자 데이터](#controller-manager-data)
      </td>

      <td>
        v1.11.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sSchedulerSample`
      </td>

      <td>
        [스케줄러 데이터](#scheduler-data)
      </td>

      <td>
        v1.11.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sEtcdSample`
      </td>

      <td>
        [etcd 데이터](#etcd-data)
      </td>

      <td>
        v1.11.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sEndpointSample`
      </td>

      <td>
        [엔드포인트 데이터](#endpoint-data)
      </td>

      <td>
        v1.13.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sServiceSample`
      </td>

      <td>
        [서비스 데이터](#service-data)
      </td>

      <td>
        v1.13.0
      </td>
    </tr>

    <tr>
      <td>
        `K8sHpaSample`
      </td>

      <td>
        [수평형 포드 자동 확장 처리 데이터](#hpa-data)
      </td>

      <td>
        v2.3.0
      </td>
    </tr>
  </tbody>
</table>

## 알림 관리 [#alerts]

Kubernetes 데이터에 대한 경고 위반에 대해 알림을 받을 수 있습니다.

<CollapserGroup>
  <Collapser
    id="create-alert"
    title="경고 조건 만들기"
  >
    Kubernetes 통합에 대한 경고 조건을 생성하려면 다음 안내를 따르세요.

    1. [**one.newrelic.com**](http://one.newrelic.com) **> 인프라 > 설정 > 경고 > Kubernetes** 로 이동한 다음 **경고 조건 생성** 을 선택합니다.

    2. 선택한 속성만 있는 Kubernetes 엔터티에 대한 경고를 필터링하려면 **필터** 를 선택합니다.

    3. 임계값 설정을 선택합니다. 다음 **경우에 경고 트리거** 옵션에 대한 자세한 내용은 [경고 유형](#alert-types) 을 참조하십시오.

    4. 기존 [알림 정책](/docs/alerts/new-relic-alerts/configuring-alert-policies/create-or-rename-alert-policy) 을 선택하거나 새 알림 정책을 만듭니다.

    5. **만들기** 를 선택합니다.

       경고 조건의 임계값이 트리거되면 New Relic은 정책의 알림 채널에 [알림](#notifications) 을 보냅니다.
  </Collapser>

  <Collapser
    id="alert-types"
    title="사전 정의된 경고 유형 및 임계값 사용"
  >
    Kubernetes 통합은 자체 경고 정책 및 경고 조건과 함께 제공됩니다. 사전 정의된 경고 조건이 무엇인지 보려면 [Kubernetes 통합: 사전 정의된 경고 정책](/docs/integrations/kubernetes-integration/kubernetes-events/kubernetes-integration-predefined-alert-policy) 을 참조하십시오.

    또한 Kubernetes 통합을 포함하여 사용하는 [New Relic 통합에서](/docs/integrations/new-relic-integrations/getting-started/introduction-infrastructure-integrations) 수집한 모든 메트릭에 대한 경고 조건을 생성할 수 있습니다.

    1. 경고 유형 **통합** 을 선택하십시오.
    2. **데이터 원본** 선택 드롭다운에서 Kubernetes(K8s) 데이터 원본을 선택합니다.
  </Collapser>

  <Collapser
    id="notifications"
    title="경고 알림 선택"
  >
    경고 조건의 임계값이 트리거되면 New Relic은 경고 정책에서 선택한 알림 채널로 메시지를 보냅니다. 알림 유형에 따라 다음과 같은 옵션이 있을 수 있습니다.

    * [사건 보기](/docs/alerts/new-relic-alerts/reviewing-alert-incidents/view-violation-event-details-incidents) .

    * [사건을 인정하십시오](/docs/alerts/new-relic-alerts/reviewing-alert-incidents/acknowledge-alert-incidents) .

    * 식별자 이름을 선택하여 사고 데이터 차트로 이동합니다.

      경고를 트리거한 엔터티 식별자는 알림 메시지 상단 근처에 나타납니다. 식별자 형식은 경고 유형에 따라 다릅니다.

    * **사용 가능한 포드가 원하는 포드 알림보다 적습니다** .

      ```
      K8s:<var>CLUSTER_NAME</var>:<var>PARENT_NAMESPACE</var>:replicaset:<var>REPLICASET_NAME</var>
      ```

    * **CPU 또는 메모리 사용량** 경고:

      ```
      K8s:<var>CLUSTER_NAME</var>:<var>PARENT_NAMESPACE</var>:<var>POD_NAME</var>:container:<var>CONTAINER_NAME</var>
      ```

      여기 예시들이 있습니다.

      <CollapserGroup>
        <Collapser
          id="pod-alerts"
          title="Pod 경고 알림 예시"
        >
          **사용 가능한 포드가 원하는 포드보다 적음** 알림의 경우 문제를 트리거하는 `ReplicaSet` 의 ID는 다음과 같을 수 있습니다.

          ```
          k8s:beam-production:default:replicaset:nginx-deployment-1623441481
          ```

          이 식별자에는 다음 정보가 포함됩니다.

          * 클러스터 이름: `beam-production`
          * 상위 네임스페이스: `default`
          * `ReplicaSet` 이름: `nginx-deployment-1623441481`
        </Collapser>

        <Collapser
          id="container-resource"
          title="컨테이너 리소스 알림 예시"
        >
          컨테이너 CPU 또는 메모리 사용량 경고의 경우 엔터티는 다음과 같을 수 있습니다.

          ```
          k8s:beam-production:kube-system:kube-state-metrics-797bb87c75-zncwn:container:kube-state-metrics
          ```

          이 식별자에는 다음 정보가 포함됩니다.

          * 클러스터 이름: `beam-production`
          * 상위 네임스페이스: `kube-system`
          * 포드 네임스페이스: `kube-state-metrics-797bb87c75-zncwn`
          * 컨테이너 이름: `kube-state-metrics`
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    id="nrql-alerts"
    title="NRQL을 사용하여 경고 조건 생성"
  >
    [NRQL 쿼리에 대한 경고 조건을 생성](/docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries) 하려면 표준 절차를 따르십시오.
  </Collapser>
</CollapserGroup>

## Kubernetes 속성 및 측정항목 [#metrics]

Kubernetes 통합은 다음 메트릭 및 기타 [속성](/docs/accounts-partnerships/education/getting-started-new-relic/glossary#attribute) 을 수집합니다.

### 노드 데이터 [#node-data]

노드 데이터에 대해 `K8sNodeSample` 이벤트를 쿼리합니다.

<table>
  <thead>
    <tr>
      <th style={{ width: "325px" }}>
        노드 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `allocatableCpuCores`
      </td>

      <td>
        노드 할당 가능한 CPU 코어
      </td>
    </tr>

    <tr>
      <td>
        `allocatableMemoryBytes`
      </td>

      <td>
        노드 할당 가능한 메모리 바이트
      </td>
    </tr>

    <tr>
      <td>
        `allocatablePods`
      </td>

      <td>
        노드 할당 가능한 포드
      </td>
    </tr>

    <tr>
      <td>
        `allocatableEphemeralStorageBytes`
      </td>

      <td>
        노드 할당 가능한 임시 스토리지 바이트
      </td>
    </tr>

    <tr>
      <td>
        `capacityCpuCores`
      </td>

      <td>
        노드 CPU 용량
      </td>
    </tr>

    <tr>
      <td>
        `capacityMemoryBytes`
      </td>

      <td>
        노드 메모리 용량(바이트)
      </td>
    </tr>

    <tr>
      <td>
        `capacityPods`
      </td>

      <td>
        노드의 포드 용량
      </td>
    </tr>

    <tr>
      <td>
        `capacityEphemeralStorageBytes`
      </td>

      <td>
        노드 임시 스토리지 용량
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Kubernetes 통합을 설치할 때 클러스터에 지정한 이름
      </td>
    </tr>

    <tr>
      <td>
        `condition.{conditionName}={conditionValue}`
      </td>

      <td>
        현재 관찰된 노드 상태의 상태입니다. 보고된 조건은 Kubernetes 특징 및 설치된 운영자에 따라 다를 수 있습니다.<br/> 일반적인 조건의 예는 Ready, DiskPressure, MemoryPressure, PIDPressure 및 NetworkUnavailable입니다.<br/> 조건 값은 `1` (true), `0` (false) 또는 `-1` (알 수 없음)일 수 있습니다.
      </td>
    </tr>

    <tr>
      <td>
        `cpuUsedCoreMilliseconds`
      </td>

      <td>
        코어 밀리초 단위로 측정된 노드 CPU 사용량
      </td>
    </tr>

    <tr>
      <td>
        `cpuUsedCores`
      </td>

      <td>
        코어로 측정된 노드 CPU 사용량
      </td>
    </tr>

    <tr>
      <td>
        `cpuRequestedCores`
      </td>

      <td>
        요청된 총 CPU 코어 양
      </td>
    </tr>

    <tr>
      <td>
        `allocatableCpuCoresUtilization`
      </td>

      <td>
        할당 가능한 CPU 코어와 관련하여 실제로 사용된 CPU 코어의 백분율
      </td>
    </tr>

    <tr>
      <td>
        `fsAvailableBytes`
      </td>

      <td>
        노드 파일 시스템에서 사용 가능한 바이트
      </td>
    </tr>

    <tr>
      <td>
        `fsCapacityBytes`
      </td>

      <td>
        노드 파일 시스템의 총 용량(바이트)
      </td>
    </tr>

    <tr>
      <td>
        `fsInodes`
      </td>

      <td>
        노드 파일 시스템의 총 inode 수
      </td>
    </tr>

    <tr>
      <td>
        `fsInodesFree`
      </td>

      <td>
        노드 파일 시스템의 여유 inode
      </td>
    </tr>

    <tr>
      <td>
        `fsInodesUsed`
      </td>

      <td>
        노드 파일 시스템에서 사용된 inode
      </td>
    </tr>

    <tr>
      <td>
        `fsUsedBytes`
      </td>

      <td>
        노드 파일 시스템에서 사용된 바이트
      </td>
    </tr>

    <tr>
      <td>
        `fsCapacityUtilization`
      </td>

      <td>
        용량에 대한 노드 파일 시스템에서 사용된 바이트의 백분율
      </td>
    </tr>

    <tr>
      <td>
        `memoryAvailableBytes`
      </td>

      <td>
        노드에서 사용 가능한 메모리 바이트
      </td>
    </tr>

    <tr>
      <td>
        `memoryMajorPageFaultsPerSecond`
      </td>

      <td>
        노드의 초당 주요 페이지 부재 수
      </td>
    </tr>

    <tr>
      <td>
        `memoryPageFaults`
      </td>

      <td>
        노드의 페이지 부재 수
      </td>
    </tr>

    <tr>
      <td>
        `memoryRssBytes`
      </td>

      <td>
        RSS 메모리의 바이트
      </td>
    </tr>

    <tr>
      <td>
        `memoryUsedBytes`
      </td>

      <td>
        사용된 메모리 바이트
      </td>
    </tr>

    <tr>
      <td>
        `memoryWorkingSetBytes`
      </td>

      <td>
        작업 세트의 메모리 바이트
      </td>
    </tr>

    <tr>
      <td>
        `memoryRequestedBytes`
      </td>

      <td>
        요청된 메모리의 총량
      </td>
    </tr>

    <tr>
      <td>
        `allocatableMemoryUtilization`
      </td>

      <td>
        노드 할당 가능 메모리에 대한 작업 세트의 메모리 바이트 백분율
      </td>
    </tr>

    <tr>
      <td>
        `net.errorCountPerSecond`
      </td>

      <td>
        네트워크를 통한 수신/전송 중 초당 오류 수
      </td>
    </tr>

    <tr>
      <td>
        `nodeName`
      </td>

      <td>
        포드가 실행 중인 호스트 이름
      </td>
    </tr>

    <tr>
      <td>
        `net.rxBytesPerSecond`
      </td>

      <td>
        네트워크를 통해 수신된 초당 바이트 수
      </td>
    </tr>

    <tr>
      <td>
        `net.txBytesPerSecond`
      </td>

      <td>
        네트워크를 통해 전송된 초당 바이트 수
      </td>
    </tr>

    <tr>
      <td>
        `runtimeAvailableBytes`
      </td>

      <td>
        컨테이너 런타임 파일 시스템에 사용 가능한 바이트
      </td>
    </tr>

    <tr>
      <td>
        `runtimeCapacityBytes`
      </td>

      <td>
        컨테이너 런타임 파일 시스템에 할당된 총 용량(바이트)
      </td>
    </tr>

    <tr>
      <td>
        `runtimeInodes`
      </td>

      <td>
        컨테이너 런타임 파일 시스템의 총 inode 수
      </td>
    </tr>

    <tr>
      <td>
        `runtimeInodesFree`
      </td>

      <td>
        컨테이너 런타임 파일 시스템의 무료 inode
      </td>
    </tr>

    <tr>
      <td>
        `runtimeInodesUsed`
      </td>

      <td>
        컨테이너 런타임 파일 시스템에서 사용된 inode
      </td>
    </tr>

    <tr>
      <td>
        `runtimeUsedBytes`
      </td>

      <td>
        컨테이너 런타임 파일 시스템에서 사용된 바이트
      </td>
    </tr>

    <tr>
      <td>
        `unschedulable`
      </td>

      <td>
        새 포드의 노드 예약 가능성 상태입니다. 값은 0(거짓) 또는 1(참)일 수 있습니다.
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        특정 노드를 필터링하고 쿼리할 수 있도록 노드와 연결된 레이블
      </td>
    </tr>
  </tbody>
</table>

### 네임스페이스 데이터 [#namespace-data]

네임스페이스 데이터에 대해 `K8sNamespaceSample` 이벤트를 쿼리합니다.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        네임스페이스 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Kubernetes 통합을 설치할 때 클러스터에 지정한 이름
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        생성된 네임스페이스의 타임스탬프
      </td>
    </tr>

    <tr>
      <td>
        `namespace`
      </td>

      <td>
        식별자로 사용할 네임스페이스의 이름
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        특정 네임스페이스를 필터링하고 쿼리할 수 있도록 네임스페이스와 연결된 레이블
      </td>
    </tr>

    <tr>
      <td>
        `status`
      </td>

      <td>
        네임스페이스의 현재 상태입니다.

        값은 `Active` 또는 `Terminated`
      </td>
    </tr>
  </tbody>
</table>

### 배포 데이터 [#deployment-data]

배포 데이터에 대해 `K8sDeploymentSample` 이벤트를 쿼리합니다.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        배포 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Kubernetes 통합을 설치할 때 클러스터에 지정한 이름
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        배포가 생성된 타임스탬프
      </td>
    </tr>

    <tr>
      <td>
        `deploymentName`
      </td>

      <td>
        식별자로 사용할 배포 이름
      </td>
    </tr>

    <tr>
      <td>
        `namespace`
      </td>

      <td>
        배포가 속한 네임스페이스의 이름
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        특정 배포를 필터링하고 쿼리할 수 있도록 배포와 연결된 레이블
      </td>
    </tr>

    <tr>
      <td>
        `podsAvailable`
      </td>

      <td>
        현재 사용 가능한 복제본 수
      </td>
    </tr>

    <tr>
      <td>
        `podsDesired`
      </td>

      <td>
        배포에서 정의한 복제본 수
      </td>
    </tr>

    <tr>
      <td>
        `podsTotal`
      </td>

      <td>
        현재 실행 중인 총 복제본 수
      </td>
    </tr>

    <tr>
      <td>
        `podsUnavailable`
      </td>

      <td>
        현재 사용할 수 없는 복제본 수
      </td>
    </tr>

    <tr>
      <td>
        `podsUpdated`
      </td>

      <td>
        원하는 배포 상태를 달성하기 위해 업데이트된 복제본 수
      </td>
    </tr>

    <tr>
      <td>
        `podsMissing`
      </td>

      <td>
        누락된 총 복제본 수(원하는 복제본 수, podsDesired, 빼기 총 복제본 수, podsTotal)
      </td>
    </tr>
  </tbody>
</table>

### 레플리카세트 데이터 [#replica-set-data]

`ReplicaSet` 데이터에 대한 `K8sReplicasetSample` 이벤트 쿼리:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        복제본 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Kubernetes 통합을 설치할 때 클러스터에 지정한 이름
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        `ReplicaSet` 이(가) 생성된 타임스탬프
      </td>
    </tr>

    <tr>
      <td>
        `deploymentName`
      </td>

      <td>
        식별자로 사용할 배포 이름
      </td>
    </tr>

    <tr>
      <td>
        `namespace`
      </td>

      <td>
        `ReplicaSet` 이 속한 네임스페이스의 이름
      </td>
    </tr>

    <tr>
      <td>
        `observedGeneration`
      </td>

      <td>
        에 의해 관찰된 세대를 나타내는 정수 `ReplicaSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsDesired`
      </td>

      <td>
        배포에서 정의한 복제본 수
      </td>
    </tr>

    <tr>
      <td>
        `podsFullyLabeled`
      </td>

      <td>
        `ReplicaSet` 포드 템플릿 레이블과 일치하는 레이블이 있는 포드 수
      </td>
    </tr>

    <tr>
      <td>
        `podsReady`
      </td>

      <td>
        이에 대해 준비된 복제본 수 `ReplicaSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsTotal`
      </td>

      <td>
        현재 실행 중인 총 복제본 수
      </td>
    </tr>

    <tr>
      <td>
        `podsMissing`
      </td>

      <td>
        현재 누락된 총 복제본 수(원하는 복제본 수, podsDesired에서 준비된 복제본 수 podsReady를 뺀 값)
      </td>
    </tr>

    <tr>
      <td>
        `replicasetName`
      </td>

      <td>
        식별자로 사용할 `ReplicaSet` 의 이름
      </td>
    </tr>
  </tbody>
</table>

### DaemonSet 데이터 [#daemonset-data]

`DaemonSet` 데이터에 대한 `K8sDaemonsetSample` 이벤트 쿼리:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        DaemonSet 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Kubernetes 통합을 설치할 때 클러스터에 지정한 이름
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        `DaemonSet` 이(가) 생성된 타임스탬프
      </td>
    </tr>

    <tr>
      <td>
        `namespaceName`
      </td>

      <td>
        `DaemonSet` 이 속한 네임스페이스의 이름
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        `DaemonSet` 에 연결된 라벨을 사용하여 특정 항목을 필터링하고 쿼리할 수 있습니다. `DaemonSet`
      </td>
    </tr>

    <tr>
      <td>
        데몬셋 이름
      </td>

      <td>
        와 관련된 이름 `DaemonSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsDesired`
      </td>

      <td>
        데몬 포드를 실행해야 하는 노드 수
      </td>
    </tr>

    <tr>
      <td>
        `podsScheduled`
      </td>

      <td>
        최소한 하나의 데몬 포드를 실행하고 있어야 하는 노드 수
      </td>
    </tr>

    <tr>
      <td>
        `podsAvailable`
      </td>

      <td>
        데몬 포드를 실행해야 하고 하나 이상의 데몬 포드가 실행 중이고 사용 가능한 노드 수
      </td>
    </tr>

    <tr>
      <td>
        `podsReady`
      </td>

      <td>
        데몬 포드를 실행해야 하고 하나 이상의 데몬 포드가 실행 중이고 준비되어 있어야 하는 노드 수
      </td>
    </tr>

    <tr>
      <td>
        `podsUnavailable`
      </td>

      <td>
        데몬 포드를 실행해야 하고 실행 중인 데몬 포드가 없고 사용 가능한 노드 수
      </td>
    </tr>

    <tr>
      <td>
        `podsMisscheduled`
      </td>

      <td>
        데몬 포드를 실행하지만 실행하지 않아야 하는 노드의 수
      </td>
    </tr>

    <tr>
      <td>
        `podsUpdatedScheduled`
      </td>

      <td>
        업데이트된 데몬 포드를 실행하는 총 노드 수
      </td>
    </tr>

    <tr>
      <td>
        `podsMissing`
      </td>

      <td>
        현재 누락된 총 복제본 수(원하는 복제본 수, podsDesired에서 준비된 복제본 수 podsReady를 뺀 값)
      </td>
    </tr>

    <tr>
      <td>
        `metadataGeneration`
      </td>

      <td>
        원하는 상태의 특정 세대를 나타내는 시퀀스 번호
      </td>
    </tr>
  </tbody>
</table>

### StatefulSet 데이터 [#statefulset-data]

`StatefulSet` 데이터에 대한 `K8sStatefulsetSample` 이벤트 쿼리:

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        StatefulSet 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Kubernetes 통합을 설치할 때 클러스터에 지정한 이름
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        `StatefulSet` 이(가) 생성된 타임스탬프
      </td>
    </tr>

    <tr>
      <td>
        `namespaceName`
      </td>

      <td>
        `StatefulSet` 이 속한 네임스페이스의 이름
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        `StatefulSet` 에 연결된 라벨을 사용하여 특정 항목을 필터링하고 쿼리할 수 있습니다. `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `statefulsetName`
      </td>

      <td>
        와 관련된 이름 `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsDesired`
      </td>

      <td>
        원하는 포드 수 `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsReady`
      </td>

      <td>
        당 준비된 복제본 수 `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsCurrent`
      </td>

      <td>
        당 현재 복제본 수 `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsTotal`
      </td>

      <td>
        당 복제본 수 `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsUpdated`
      </td>

      <td>
        업데이트된 복제본 수 `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `podsMissing`
      </td>

      <td>
        현재 누락된 총 복제본 수(원하는 복제본 수, podsDesired에서 준비된 복제본 수 podsReady를 뺀 값)
      </td>
    </tr>

    <tr>
      <td>
        `observedGeneration`
      </td>

      <td>
        `StatefulSet` 컨트롤러에서 관찰한 생성
      </td>
    </tr>

    <tr>
      <td>
        `metadataGeneration`
      </td>

      <td>
        원하는 상태의 특정 세대를 나타내는 시퀀스 번호 `StatefulSet`
      </td>
    </tr>

    <tr>
      <td>
        `currentRevision`
      </td>

      <td>
        시퀀스에서 포드를 생성하는 데 사용되는 `StatefulSet` 의 버전을 나타냅니다. 값 범위: <var>0</var> 과 <var>podsCurrent</var> 사이
      </td>
    </tr>

    <tr>
      <td>
        `updateRevision`
      </td>

      <td>
        시퀀스에서 포드를 생성하는 데 사용되는 `StatefulSet` 의 버전을 나타냅니다. 값 범위: <var>podsDesired-podsUpdated</var> 와 <var>podsDesired</var> 사이
      </td>
    </tr>
  </tbody>
</table>

### 포드 데이터 [#pod-data]

포드 데이터에 대한 `K8sPodSample` 이벤트를 쿼리합니다.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        포드 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Kubernetes 통합을 설치할 때 클러스터에 지정한 이름
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        Pod가 생성된 시간의 타임스탬프(epoch 초)
      </td>
    </tr>

    <tr>
      <td>
        `createdBy`
      </td>

      <td>
        포드를 생성한 Kubernetes 객체의 이름입니다.

        예를 들어, `newrelic-infra`
      </td>
    </tr>

    <tr>
      <td>
        `createdKind`
      </td>

      <td>
        포드를 생성한 Kubernetes 개체의 종류입니다.

        예: `DaemonSet` .
      </td>
    </tr>

    <tr>
      <td>
        `deploymentName`
      </td>

      <td>
        식별자로 사용할 배포 이름
      </td>
    </tr>

    <tr>
      <td>
        `isReady`
      </td>

      <td>
        포드가 요청을 처리할 준비가 되었는지 여부를 나타내는 부울
      </td>
    </tr>

    <tr>
      <td>
        `isScheduled`
      </td>

      <td>
        포드가 노드에서 실행되도록 예약되었는지 여부를 나타내는 부울
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        특정 포드를 필터링하고 쿼리할 수 있도록 포드와 연결된 레이블
      </td>
    </tr>

    <tr>
      <td>
        `message`
      </td>

      <td>
        마지막 포드 상태 변경과 관련된 세부정보
      </td>
    </tr>

    <tr>
      <td>
        `namespace`
      </td>

      <td>
        포드가 속한 네임스페이스의 이름
      </td>
    </tr>

    <tr>
      <td>
        `net.errorCountPerSecond`
      </td>

      <td>
        네트워크를 통한 수신/전송 중 초당 오류 수
      </td>
    </tr>

    <tr>
      <td>
        `net.errorsPerSecond`
      </td>

      <td>
        초당 오류 수
      </td>
    </tr>

    <tr>
      <td>
        `net.rxBytesPerSecond`
      </td>

      <td>
        네트워크를 통해 수신된 초당 바이트 수
      </td>
    </tr>

    <tr>
      <td>
        `net.txBytesPerSecond`
      </td>

      <td>
        네트워크를 통해 전송된 초당 바이트 수
      </td>
    </tr>

    <tr>
      <td>
        `nodeIP`
      </td>

      <td>
        포드가 실행 중인 호스트 IP 주소
      </td>
    </tr>

    <tr>
      <td>
        `nodeName`
      </td>

      <td>
        포드가 실행 중인 호스트 이름
      </td>
    </tr>

    <tr>
      <td>
        `podIP`
      </td>

      <td>
        포드의 IP 주소입니다. IP가 없으면 비어 있습니다.
      </td>
    </tr>

    <tr>
      <td>
        `podName`
      </td>

      <td>
        식별자로 사용할 포드의 이름
      </td>
    </tr>

    <tr>
      <td>
        `reason`
      </td>

      <td>
        Pod가 현재 상태인 이유
      </td>
    </tr>

    <tr>
      <td>
        `startTime`
      </td>

      <td>
        팟(Pod)이 Epoch(초) 단위로 실행되기 시작한 타임스탬프
      </td>
    </tr>

    <tr>
      <td>
        `status`
      </td>

      <td>
        포드의 현재 상태입니다.

        값은 `Pending` , `Running` , `Succeeded` , `Failed` , `Unknown`
      </td>
    </tr>
  </tbody>
</table>

### 클러스터 데이터 [#cluster-data]

클러스터 데이터를 보려면 `K8sClusterSample` 이벤트를 쿼리합니다.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        클러스터 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Kubernetes 통합을 설치할 때 클러스터에 지정한 이름
      </td>
    </tr>

    <tr>
      <td>
        `clusterK8sVersion`
      </td>

      <td>
        클러스터가 실행 중인 Kubernetes 버전
      </td>
    </tr>
  </tbody>
</table>

### 컨테이너 데이터 [#container-data]

컨테이너 데이터에 대해 `K8sContainerSample` 이벤트를 쿼리합니다.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        컨테이너 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Kubernetes 통합을 설치할 때 클러스터에 지정한 이름
      </td>
    </tr>

    <tr>
      <td>
        `containerID`
      </td>

      <td>
        컨테이너와 연결된 고유 ID입니다. Docker를 실행하는 경우 Docker 컨테이너 ID입니다.
      </td>
    </tr>

    <tr>
      <td>
        `containerImage`
      </td>

      <td>
        컨테이너가 실행 중인 이미지의 이름
      </td>
    </tr>

    <tr>
      <td>
        `containerImageID`
      </td>

      <td>
        컨테이너가 실행 중인 이미지와 연결된 고유 ID
      </td>
    </tr>

    <tr>
      <td>
        `containerName`
      </td>

      <td>
        컨테이너와 연결된 이름
      </td>
    </tr>

    <tr>
      <td>
        `cpuLimitCores`
      </td>

      <td>
        포드 사양의 컨테이너에 대해 정의된 CPU 코어 제한을 나타내는 정수
      </td>
    </tr>

    <tr>
      <td>
        `cpuRequestedCores`
      </td>

      <td>
        포드 사양의 컨테이너에 대해 정의된 요청된 CPU 코어
      </td>
    </tr>

    <tr>
      <td>
        `cpuUsedCores`
      </td>

      <td>
        컨테이너에서 실제로 사용하는 CPU 코어
      </td>
    </tr>

    <tr>
      <td>
        `cpuCoresUtilization`
      </td>

      <td>
        지정된 CPU 제한과 관련하여 컨테이너에서 실제로 사용하는 CPU 코어의 백분율입니다. 이 백분율은 다음 계산을 기반으로 합니다. ( `cpuUsedCores` / `cpuLimitCores` ) \* 100
      </td>
    </tr>

    <tr>
      <td>
        `requestedCpuCoresUtilization`
      </td>

      <td>
        지정된 CPU 요청과 관련하여 컨테이너에서 실제로 사용하는 CPU 코어의 백분율
      </td>
    </tr>

    <tr>
      <td>
        `deploymentName`
      </td>

      <td>
        식별자로 사용할 배포 이름
      </td>
    </tr>

    <tr>
      <td>
        `isReady`
      </td>

      <td>
        부울. 컨테이너의 준비 상태 확인 성공 여부
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        특정 컨테이너를 필터링하고 쿼리할 수 있도록 컨테이너와 연결된 레이블
      </td>
    </tr>

    <tr>
      <td>
        `memoryLimitBytes`
      </td>

      <td>
        포드 사양에서 컨테이너에 대해 정의된 메모리의 제한 바이트를 나타내는 정수
      </td>
    </tr>

    <tr>
      <td>
        `memoryRequestedBytes`
      </td>

      <td>
        정수. 포드 사양의 컨테이너에 대해 정의된 요청된 메모리 바이트
      </td>
    </tr>

    <tr>
      <td>
        `memoryUsedBytes`
      </td>

      <td>
        정수. 컨테이너에서 실제로 사용하는 메모리 바이트
      </td>
    </tr>

    <tr>
      <td>
        `memoryUtilization`
      </td>

      <td>
        지정된 메모리 제한과 관련하여 컨테이너에서 실제로 사용하는 메모리의 백분율
      </td>
    </tr>

    <tr>
      <td>
        `requestedMemoryUtilization`
      </td>

      <td>
        지정된 메모리 요청과 관련하여 컨테이너가 실제로 사용한 메모리 비율
      </td>
    </tr>

    <tr>
      <td>
        `memoryWorkingSetBytes`
      </td>

      <td>
        정수. 작업 세트의 메모리 바이트
      </td>
    </tr>

    <tr>
      <td>
        `memoryWorkingSetUtilization`
      </td>

      <td>
        지정된 메모리 제한과 관련하여 컨테이너에서 실제로 사용하는 작업 집합 메모리의 백분율
      </td>
    </tr>

    <tr>
      <td>
        `requestedMemoryWorkingSetUtilization`
      </td>

      <td>
        지정된 메모리 요청과 관련하여 컨테이너에서 실제로 사용하는 작업 집합 메모리의 백분율
      </td>
    </tr>

    <tr>
      <td>
        `namespace`
      </td>

      <td>
        컨테이너가 속한 네임스페이스의 이름
      </td>
    </tr>

    <tr>
      <td>
        `nodeIP`
      </td>

      <td>
        컨테이너가 실행 중인 호스트 IP 주소
      </td>
    </tr>

    <tr>
      <td>
        `nodeName`
      </td>

      <td>
        컨테이너가 실행 중인 호스트 이름
      </td>
    </tr>

    <tr>
      <td>
        `podName`
      </td>

      <td>
        식별자로 사용할 컨테이너가 있는 포드의 이름
      </td>
    </tr>

    <tr>
      <td>
        `reason`
      </td>

      <td>
        컨테이너가 현재 상태인 이유를 제공합니다.
      </td>
    </tr>

    <tr>
      <td>
        `restartCount`
      </td>

      <td>
        컨테이너가 다시 시작된 횟수
      </td>
    </tr>

    <tr>
      <td>
        `status`
      </td>

      <td>
        컨테이너의 현재 상태입니다.

        값은 `Running` , `Terminated` 또는 `Unknown`
      </td>
    </tr>

    <tr>
      <td>
        `containerCpuCfsPeriodsDelta`
      </td>

      <td>
        경과된 시행 기간 간격의 델타 변경
      </td>
    </tr>

    <tr>
      <td>
        `containerCpuCfsThrottledPeriodsDelta`
      </td>

      <td>
        조절 기간 간격의 델타 변경
      </td>
    </tr>

    <tr>
      <td>
        `containerCpuCfsThrottledSecondsDelta`
      </td>

      <td>
        컨테이너가 조절된 기간의 델타 변경(초)
      </td>
    </tr>

    <tr>
      <td>
        `containerCpuCfsPeriodsTotal`
      </td>

      <td>
        경과된 시행 기간 간격의 총 수
      </td>
    </tr>

    <tr>
      <td>
        `containerCpuCfsThrottledPeriodsTotal`
      </td>

      <td>
        조절된 기간 간격의 총 수
      </td>
    </tr>

    <tr>
      <td>
        `containerCpuCfsThrottledSecondsTotal`
      </td>

      <td>
        컨테이너가 조절된 총 시간(초)
      </td>
    </tr>

    <tr>
      <td>
        `containerMemoryMappedFileBytes`
      </td>

      <td>
        이 컨테이너에서 사용하는 메모리 매핑된 파일의 총 크기(바이트)
      </td>
    </tr>
  </tbody>
</table>

### 볼륨 데이터 [#volume-data]

볼륨 데이터에 대한 `K8sVolumeSample` 이벤트를 쿼리합니다.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        볼륨 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `volumeName`
      </td>

      <td>
        생성 시 볼륨에 할당한 이름
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        볼륨이 구성된 클러스터
      </td>
    </tr>

    <tr>
      <td>
        `namespace`
      </td>

      <td>
        볼륨이 구성된 네임스페이스
      </td>
    </tr>

    <tr>
      <td>
        `podName`
      </td>

      <td>
        볼륨이 연결된 포드입니다. Kubernetes 모니터링 통합은 포드에 연결된 볼륨을 나열합니다.
      </td>
    </tr>

    <tr>
      <td>
        `persistent`
      </td>

      <td>
        [영구](https://kubernetes.io/docs/concepts/storage/persistent-volumes/) 볼륨인 경우 이 값은 다음으로 설정됩니다. `true`
      </td>
    </tr>

    <tr>
      <td>
        `pvcNamespace`
      </td>

      <td>
        영구 볼륨 클레임이 구성된 네임스페이스
      </td>
    </tr>

    <tr>
      <td>
        `pvcName`
      </td>

      <td>
        생성 시 영구 볼륨 클레임에 할당한 이름
      </td>
    </tr>

    <tr>
      <td>
        `fsCapacityBytes`
      </td>

      <td>
        볼륨의 용량(바이트)
      </td>
    </tr>

    <tr>
      <td>
        `fsUsedBytes`
      </td>

      <td>
        볼륨 사용량(바이트)
      </td>
    </tr>

    <tr>
      <td>
        `fsAvailableBytes`
      </td>

      <td>
        볼륨의 사용 가능한 용량(바이트)
      </td>
    </tr>

    <tr>
      <td>
        `fsUsedPercent`
      </td>

      <td>
        백분율로 표시된 볼륨 사용량
      </td>
    </tr>

    <tr>
      <td>
        `fsInodes`
      </td>

      <td>
        볼륨의 총계 `inodes`
      </td>
    </tr>

    <tr>
      <td>
        `fsInodesUsed`
      </td>

      <td>
        `inodes` 볼륨에서 사용
      </td>
    </tr>

    <tr>
      <td>
        `fsInodesFree`
      </td>

      <td>
        `inodes` 볼륨에서 사용 가능
      </td>
    </tr>
  </tbody>
</table>

MetricsProvider 인터페이스를 구현하는 볼륨 플러그인에서 볼륨 데이터를 사용할 수 있습니다.

* AWSElasticBlockStore
* 애저디스크
* Azure 파일
* 분석
* 가변 볼륨
* 플로커
* GCEPersistentDisk
* GlusterFS
* iSCSI
* NFS
* 스토리지OS
* Vsphere볼륨

### API 서버 데이터 [#api-server-data]

API 서버 데이터를 보려면 `K8sApiServerSample` [이벤트](/docs/telemetry-data-platform/understand-data/new-relic-data-types/#events-new-relic) 를 쿼리합니다. 자세한 내용은 [컨트롤 플레인 모니터링 구성](http://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/configure-control-plane-monitoring) 을 참조하세요.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        API 서버 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `processResidentMemoryBytes`
      </td>

      <td>
        상주 메모리 크기(바이트)
      </td>
    </tr>

    <tr>
      <td>
        `processCpuSecondsDelta`
      </td>

      <td>
        사용자와 시스템 CPU 소요 시간의 차이(초)
      </td>
    </tr>

    <tr>
      <td>
        `goThreads`
      </td>

      <td>
        생성된 OS 스레드 수
      </td>
    </tr>

    <tr>
      <td>
        `goGoroutines`
      </td>

      <td>
        현재 존재하는 고루틴의 수
      </td>
    </tr>

    <tr>
      <td>
        `apiserverRequestDelta_verb_VERB_code_CODE`
      </td>

      <td>
        Verb 및 HTTP 응답 코드별로 구분된 apiserver 요청 수의 차이
      </td>
    </tr>

    <tr>
      <td>
        `apiserverRequestRate_verb_VERB_code_CODE`
      </td>

      <td>
        각 동사 및 HTTP 응답 코드에 대해 구분된 apiserver 요청 비율
      </td>
    </tr>

    <tr>
      <td>
        `restClientRequestsDelta_code_CODE_method_METHOD`
      </td>

      <td>
        메소드 및 코드별로 분할된 HTTP 요청 수의 차이
      </td>
    </tr>

    <tr>
      <td>
        `restClientRequestsRate_code_CODE_method_METHOD`
      </td>

      <td>
        메소드 및 코드별로 분할된 HTTP 요청 수의 비율
      </td>
    </tr>

    <tr>
      <td>
        `etcdObjectCounts_resource_RESOURCE-KIND`
      </td>

      <td>
        마지막 확인 시점에 저장된 객체 개수, 종류별 분할
      </td>
    </tr>
  </tbody>
</table>

### 컨트롤러 관리자 데이터 [#controller-manager-data]

컨트롤러 관리자 데이터를 보려면 `K8sControllerManagerSample` 이벤트를 쿼리합니다. 자세한 내용은 [컨트롤 플레인 모니터링 구성](http://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/configure-control-plane-monitoring) 을 참조하세요.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        컨트롤러 관리자 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `processResidentMemoryBytes`
      </td>

      <td>
        상주 메모리 크기(바이트)
      </td>
    </tr>

    <tr>
      <td>
        `processCpuSecondsDelta`
      </td>

      <td>
        사용자와 시스템 CPU 시간의 차이(초)
      </td>
    </tr>

    <tr>
      <td>
        `goThreads`
      </td>

      <td>
        생성된 OS 스레드 수
      </td>
    </tr>

    <tr>
      <td>
        `goGoroutines`
      </td>

      <td>
        현재 존재하는 고루틴의 수
      </td>
    </tr>

    <tr>
      <td>
        `workqueueAddsDelta_name_WORK-QUEUE-NAME`
      </td>

      <td>
        workqueue에서 처리한 총 추가 수의 차이
      </td>
    </tr>

    <tr>
      <td>
        `workqueueDepth_name_WORK-QUEUE-NAME`
      </td>

      <td>
        현재 작업 대기열 깊이
      </td>
    </tr>

    <tr>
      <td>
        `workqueueRetriesDelta_name_WORK-QUEUE-NAME`
      </td>

      <td>
        workqueue에서 처리한 총 재시도 횟수의 차이
      </td>
    </tr>

    <tr>
      <td>
        `leaderElectionMasterStatus`
      </td>

      <td>
        보고 시스템이 관련 임대의 마스터인지 여부의 게이지, `0` 은 `backup` , `1` 는 `master`
      </td>
    </tr>
  </tbody>
</table>

### 스케줄러 데이터 [#scheduler-data]

스케줄러 데이터를 보려면 `K8sSchedulerSample` 이벤트를 쿼리합니다. 자세한 내용은 [컨트롤 플레인 모니터링 구성](http://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/configure-control-plane-monitoring) 을 참조하세요.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        스케줄러 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `processResidentMemoryBytes`
      </td>

      <td>
        상주 메모리 크기(바이트)
      </td>
    </tr>

    <tr>
      <td>
        `processCpuSecondsDelta`
      </td>

      <td>
        사용자와 시스템 CPU 시간의 차이(초)
      </td>
    </tr>

    <tr>
      <td>
        `goThreads`
      </td>

      <td>
        생성된 OS 스레드 수
      </td>
    </tr>

    <tr>
      <td>
        `goGoroutines`
      </td>

      <td>
        현재 존재하는 고루틴의 수
      </td>
    </tr>

    <tr>
      <td>
        `leaderElectionMasterStatus`
      </td>

      <td>
        보고 시스템이 관련 임대의 마스터인지 여부의 게이지, `0` 은 `backup` , `1` 는 `master`
      </td>
    </tr>

    <tr>
      <td>
        `httpRequestDurationMicroseconds_handler_HANDLER_quantile_QUANTILE`
      </td>

      <td>
        분위수당 HTTP 요청 지연 시간(마이크로초)
      </td>
    </tr>

    <tr>
      <td>
        `httpRequestDurationMicroseconds_handler_HANDLER_sum`
      </td>

      <td>
        HTTP 요청 대기 시간의 합계(마이크로초)
      </td>
    </tr>

    <tr>
      <td>
        `httpRequestDurationMicroseconds_handler_HANDLER_count`
      </td>

      <td>
        관찰된 HTTP 요청 이벤트 수
      </td>
    </tr>

    <tr>
      <td>
        `restClientRequestsDelta_code_CODE_host_HOST_method_METHOD`
      </td>

      <td>
        상태 코드, 메서드 및 호스트별로 분할된 HTTP 요청 수의 차이
      </td>
    </tr>

    <tr>
      <td>
        `restClientRequestsRate_code_CODE_host_HOST_method_METHOD`
      </td>

      <td>
        상태 코드, 메서드 및 호스트별로 분할된 HTTP 요청 수의 비율
      </td>
    </tr>

    <tr>
      <td>
        `schedulerScheduleAttemptsDelta_result_RESULT`
      </td>

      <td>
        결과에 따른 포드 예약 시도 횟수의 차이입니다. `unschedulable` 은 포드를 예약할 수 없음을 의미하고 `error` 은 내부 스케줄러 문제를 의미합니다.
      </td>
    </tr>

    <tr>
      <td>
        `schedulerScheduleAttemptsRate_result_RESULT`
      </td>

      <td>
        결과에 따른 포드 예약 시도 횟수의 비율입니다. `unschedulable` 은 포드를 예약할 수 없음을 의미하고 `error` 은 내부 스케줄러 문제를 의미합니다.
      </td>
    </tr>

    <tr>
      <td>
        `schedulerSchedulingDurationSeconds_operation_OPERATION_quantile_QUANTILE`
      </td>

      <td>
        스케줄링 작업의 하위 부분으로 분할된 스케줄링 지연 시간(초)
      </td>
    </tr>

    <tr>
      <td>
        `schedulerSchedulingDurationSeconds_operation_OPERATION_sum`
      </td>

      <td>
        스케줄링 작업의 하위 부분으로 분할된 스케줄링 대기 시간(초)의 합계
      </td>
    </tr>

    <tr>
      <td>
        `schedulerSchedulingDurationSeconds_operation_OPERATION_count`
      </td>

      <td>
        스케줄링 작업의 하위 부분으로 분할된 스케줄링의 관찰된 이벤트 수입니다.
      </td>
    </tr>

    <tr>
      <td>
        `schedulerPreemptionAttemptsDelta`
      </td>

      <td>
        현재까지 클러스터에서 총 선점 시도의 차이
      </td>
    </tr>

    <tr>
      <td>
        `schedulerPodPreemptionVictims`
      </td>

      <td>
        선정된 선점 피해자 수
      </td>
    </tr>
  </tbody>
</table>

### etcd 데이터 [#etcd-data]

`K8sEtcdSample` [이벤트](/docs/telemetry-data-platform/understand-data/new-relic-data-types/#events-new-relic) 를 쿼리하여 etcd 데이터를 확인합니다. 자세한 내용은 [컨트롤 플레인 모니터링 구성](http://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/configure-control-plane-monitoring) 을 참조하세요.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        etcd 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `processResidentMemoryBytes`
      </td>

      <td>
        상주 메모리 크기(바이트)
      </td>
    </tr>

    <tr>
      <td>
        `processCpuSecondsDelta`
      </td>

      <td>
        사용자와 시스템 CPU 시간의 차이(초)
      </td>
    </tr>

    <tr>
      <td>
        `goThreads`
      </td>

      <td>
        생성된 OS 스레드 수
      </td>
    </tr>

    <tr>
      <td>
        `goGoroutines`
      </td>

      <td>
        현재 존재하는 고루틴의 수
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerHasLeader`
      </td>

      <td>
        리더의 존재 여부. `1` 은 존재, `0` 은 존재하지 않음
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerLeaderChangesSeenDelta`
      </td>

      <td>
        표시된 리더 변경 수의 차이
      </td>
    </tr>

    <tr>
      <td>
        `etcdMvccDbTotalSizeInBytes`
      </td>

      <td>
        물리적으로 할당된 기본 데이터베이스의 총 크기(바이트)
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsCommittedDelta`
      </td>

      <td>
        커밋된 총 합의 제안 수의 차이
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsCommittedRate`
      </td>

      <td>
        커밋된 총 합의 제안 수 비율
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsAppliedDelta`
      </td>

      <td>
        적용된 총 합의 제안 수의 차이
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsAppliedRate`
      </td>

      <td>
        총 합의 제안 건수 적용 비율
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsPending`
      </td>

      <td>
        커밋할 보류 중인 제안의 현재 수
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsFailedDelta`
      </td>

      <td>
        실패한 제안서의 총 개수 차이
      </td>
    </tr>

    <tr>
      <td>
        `etcdServerProposalsFailedRate`
      </td>

      <td>
        실패한 제안의 총 개수 비율
      </td>
    </tr>

    <tr>
      <td>
        `processOpenFds`
      </td>

      <td>
        열린 파일 설명자 수
      </td>
    </tr>

    <tr>
      <td>
        `processMaxFds`
      </td>

      <td>
        열린 파일 설명자의 최대 수
      </td>
    </tr>

    <tr>
      <td>
        `processFdsUtilization`
      </td>

      <td>
        열 수 있는 최대 수에 대한 열린 파일 설명자 비율
      </td>
    </tr>

    <tr>
      <td>
        `etcdNetworkClientGrpcReceivedBytesRate`
      </td>

      <td>
        gRPC 클라이언트에서 받은 총 바이트 수 비율
      </td>
    </tr>

    <tr>
      <td>
        `etcdNetworkClientGrpcSentBytesRate`
      </td>

      <td>
        gRPC 클라이언트로 전송된 총 바이트 수 비율
      </td>
    </tr>
  </tbody>
</table>

### 엔드포인트 데이터 [#endpoint-data]

엔드포인트 데이터에 대한 `K8sEndpointSample` 이벤트를 쿼리합니다.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        엔드포인트 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Kubernetes 통합을 설치할 때 클러스터에 지정한 이름
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        엔드포인트가 생성된 시간의 타임스탬프
      </td>
    </tr>

    <tr>
      <td>
        `namespaceName`
      </td>

      <td>
        엔드포인트가 속한 네임스페이스의 이름
      </td>
    </tr>

    <tr>
      <td>
        `endpointName`
      </td>

      <td>
        엔드포인트와 연결된 이름
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        특정 엔드포인트를 필터링하고 쿼리할 수 있도록 엔드포인트와 연결된 레이블
      </td>
    </tr>

    <tr>
      <td>
        `addressAvailable`
      </td>

      <td>
        엔드포인트에서 사용 가능한 주소 수
      </td>
    </tr>

    <tr>
      <td>
        `addressNotReady`
      </td>

      <td>
        엔드포인트에서 준비되지 않은 주소 수
      </td>
    </tr>
  </tbody>
</table>

### 서비스 데이터 [#service-data]

서비스 데이터에 대한 `K8sServiceSample` [이벤트](/docs/telemetry-data-platform/understand-data/new-relic-data-types/#events-new-relic) 를 쿼리합니다.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        서비스 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Kubernetes 통합을 설치할 때 클러스터에 지정한 이름
      </td>
    </tr>

    <tr>
      <td>
        `createdAt`
      </td>

      <td>
        서비스가 생성된 타임스탬프
      </td>
    </tr>

    <tr>
      <td>
        `namespaceName`
      </td>

      <td>
        서비스가 속한 네임스페이스의 이름
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        특정 서비스를 필터링하고 쿼리할 수 있도록 서비스와 연결된 레이블
      </td>
    </tr>

    <tr>
      <td>
        `serviceName`
      </td>

      <td>
        서비스와 연결된 이름
      </td>
    </tr>

    <tr>
      <td>
        `loadBalancerIP`
      </td>

      <td>
        `Spectype` 이 `LoadBalancer` 인 경우 외부 부하 분산기의 IP입니다.
      </td>
    </tr>

    <tr>
      <td>
        `externalName`
      </td>

      <td>
        `Spectype` 인 경우 외부 이름 값 `ExternalName`
      </td>
    </tr>

    <tr>
      <td>
        `clusterIP`
      </td>

      <td>
        `Spectype` 인 경우 내부 클러스터 IP `ClusterIP`
      </td>
    </tr>

    <tr>
      <td>
        `specType`
      </td>

      <td>
        서비스 유형
      </td>
    </tr>

    <tr>
      <td>
        `selector.LABEL_NAME`
      </td>

      <td>
        이 서비스가 대상으로 하는 레이블 선택기
      </td>
    </tr>
  </tbody>
</table>

### 수평형 포드 자동 확장 처리 데이터 [#hpa-data]

Horizontal Pod Autoscaler 데이터에 대한 `K8sHpaSample` 이벤트를 쿼리합니다.

<table>
  <thead>
    <tr>
      <th style={{ width: "270px" }}>
        HPA 속성
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Kubernetes 통합을 설치할 때 클러스터에 지정한 이름
      </td>
    </tr>

    <tr>
      <td>
        `label.LABEL_NAME`
      </td>

      <td>
        특정 자동 크기 조정기를 필터링하고 쿼리할 수 있도록 HPA와 연결된 레이블
      </td>
    </tr>

    <tr>
      <td>
        `currentReplicas`
      </td>

      <td>
        이 자동 확장 처리에서 관리하는 포드의 현재 복제본 수
      </td>
    </tr>

    <tr>
      <td>
        `desiredReplicas`
      </td>

      <td>
        이 자동 확장 처리에서 관리하는 포드의 원하는 복제본 수
      </td>
    </tr>

    <tr>
      <td>
        `minReplicas`
      </td>

      <td>
        자동 확장 처리에서 설정할 수 있는 포드 수의 하한, 기본적으로 1
      </td>
    </tr>

    <tr>
      <td>
        `maxReplicas`
      </td>

      <td>
        자동 확장 처리에서 설정할 수 있는 포드 수의 상한값입니다. 보다 작을 수 없음 `minReplicas`
      </td>
    </tr>

    <tr>
      <td>
        `targetMetric`
      </td>

      <td>
        원하는 복제본 수를 계산할 때 이 자동 확장 처리에서 사용하는 측정항목 사양
      </td>
    </tr>

    <tr>
      <td>
        `isAble`
      </td>

      <td>
        자동 스케일러가 스케일을 가져오고 업데이트할 수 있는지 여부와 백오프 관련 조건이 스케일링을 방해하는지 여부를 나타내는 부울
      </td>
    </tr>

    <tr>
      <td>
        `isActive`
      </td>

      <td>
        자동 스케일러가 활성화되었는지 여부를 나타내는 부울(원하는 스케일을 계산할 수 있는 경우)
      </td>
    </tr>

    <tr>
      <td>
        `isLimited`
      </td>

      <td>
        자동 확장 처리가 구성된 최대 또는 최소 복제본으로 제한되는지 여부를 나타내는 부울
      </td>
    </tr>

    <tr>
      <td>
        `labels`
      </td>

      <td>
        Prometheus 레이블로 변환된 Kubernetes 레이블 수
      </td>
    </tr>

    <tr>
      <td>
        `metadataGeneration`
      </td>

      <td>
        HorizontalPodAutoscaler 컨트롤러에서 관찰한 생성
      </td>
    </tr>
  </tbody>
</table>

## APM 모니터링 애플리케이션의 Kubernetes 메타데이터 [#apm-custom-attributes]

[애플리케이션을 Kubernetes와 연결](/docs/integrations/kubernetes-integration/metadata-injection/kubernetes-apm-metadata-injection) 하면 애플리케이션 추적 및 분산 추적에 다음 속성이 추가됩니다.

* `nodeName`
* `containerName`
* `podName`
* `clusterName`
* `deploymentName`
* `namespaceName`

## 더 많은 도움을 받으려면 [#logs-versions]