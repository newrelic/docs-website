---
title: 기본 제공 로그 구문 분석 규칙
tags:
  - Logs
  - Log management
  - UI and data
metaDescription: 'A list of all New Relic''s log parsing rules, which you can use to easily parse common log formats.'
freshnessValidatedDate: never
translationType: machine
---

New Relic은 기본 제공 규칙에 따라 일반적인 로그 형식을 구문 분석할 수 있으므로 고유한 구문 분석 규칙을 만들 필요가 없습니다. 다음은 로그 구문 분석 규칙, 해당 [Grok](https://github.com/thekrakken/java-grok/tree/master/src/main/resources/patterns) 패턴 및 구문 분석되는 필드입니다.

## 파싱 예시 [#parsing-example]

좋은 예는 정형화되지 않은 텍스트를 포함하는 기본 NGINX 액세스 로그입니다. 검색할 때 유용하지만 그 외에는 그다지 유용하지 않습니다. 다음은 일반적인 라인의 예입니다.

```
127.180.71.3 - - [10/May/1997:08:05:32 +0000] "GET /downloads/product_1 HTTP/1.1" 304 0 "-" "Debian APT-HTTP/1.3 (0.8.16~exp12ubuntu10.21)"
```

구문 분석되지 않은 형식에서는 대부분의 질문에 답하기 위해 전체 텍스트 검색을 수행해야 합니다. 구문 분석 후 로그는 `response code` 및 `request URL` 과 같은 속성으로 구성됩니다.

```json
{
  "remote_addr":"93.180.71.3",
  "time":"1586514731",
  "method":"GET",
  "path":"/downloads/product_1",
  "version":"HTTP/1.1",
  "response":"304",
  "bytesSent": 0,
  "user_agent": "Debian APT-HTTP/1.3 (0.8.16~exp12ubuntu10.21)"
}
```

구문 분석을 사용하면 해당 값에 대해 패싯하는 [사용자 지정 쿼리](/docs/using-new-relic/data/understand-data/query-new-relic-data) 를 더 쉽게 만들 수 있습니다. 이를 통해 요청 URL당 응답 코드 분포를 이해하고 문제가 있는 페이지를 빠르게 찾을 수 있습니다.

## 추가하다 `logtype` [#logattr]

로그를 집계할 때는 로그를 쉽게 정리하고 검색하고 분석할 수 있도록 메타데이터를 제공하는 것이 중요합니다. 이를 위한 간단한 방법 중 하나는 로그 메시지를 전송할 때 `logtype` 속성을 추가하는 것입니다. [내장 구문 분석 규칙은](/docs/logs/ui-data/built-log-parsing-rules) 특정 `logtype` 값에 기본적으로 적용됩니다.

<Callout variant="tip">
  `logType` , `logtype` 및 `LOGTYPE` 필드는 모두 기본 제공 규칙에 대해 지원됩니다. 검색을 쉽게 하려면 조직의 단일 구문에 맞추는 것이 좋습니다.
</Callout>

다음은 [지원되는 배송 방법](/docs/logs/enable-new-relic-logs) 중 일부에서 보낸 로그에 `logtype` 을(를) 추가하는 방법의 몇 가지 예입니다.

<CollapserGroup>
  <Collapser className="freq-link" id="infrastructure-log-forwarder-example" title="New Relic 인프라 에이전트 예시">
    `logtype` 을 [`attribute`](/docs/logs/forward-logs/forward-your-logs-using-infrastructure-agent#attributes) 로 추가합니다. 명명된 각 소스에 대해 로그 유형을 설정해야 합니다.

    ```yml
    logs:
      - name: file-simple
        file: /path/to/file
        attributes:
          logtype: fileRaw
      - name: nginx-example
        file: /var/log/nginx.log
        attributes:
          logtype: nginx
    ```
  </Collapser>

  <Collapser className="freq-link" id="fluentd-example" title="유창한 예">
    `record_transformer`를 사용하여 새 필드를 추가하는 `.conf` 파일에 필터 블록을 추가합니다. 이 예에서는 `nginx`의 `logtype`을 사용하여 내장 NGINX 구문 분석 규칙을 트리거합니다. 다른 [Fluentd 예제](https://github.com/newrelic/fluentd-examples)들을 확인해 보십시오.

    ```apacheconf
    <filter containers>
      @type record_transformer
      enable_ruby true
      <record>
        #Add logtype to trigger a built-in parsing rule for nginx access logs
        logtype nginx
        #Set timestamp from the value contained in the field "time"
        timestamp record["time"]
        #Add hostname and tag fields to all records
        hostname "#{Socket.gethostname}"
        tag ${tag}
      </record>
    </filter>
    ```
  </Collapser>

  <Collapser className="freq-link" id="fluentbit-example" title="Fluent Bit 예제">
    `record_modifier` 을 사용하여 새 필드를 추가하는 필터 블록을 `.conf` 파일에 추가합니다. 이 예에서는 `nginx` 의 `logtype` 를 사용하여 기본 제공 NGINX 구문 분석 규칙을 트리거합니다. 다른 [Fluent Bit 예제](https://github.com/newrelic/fluentbit-examples) 를 확인하십시오.

    ```ini
    [FILTER]
        Name   record_modifier
        Match  *
        Record logtype nginx
        Record hostname ${HOSTNAME}
        Record service_name Sample-App-Name
    ```
  </Collapser>

  <Collapser className="freq-link" id="logstash-example" title="로그스태시 예시">
    `add_field` mutate 필터를 사용하여 새 필드를 추가하는 필터 블록을 Logstash 구성에 추가합니다. 이 예에서는 `nginx` 의 `logtype` 을 사용하여 기본 제공 NGINX 구문 분석 규칙을 트리거합니다. 다른 [Logstash 예제](https://github.com/newrelic/logstash-examples) 를 확인하십시오.

    ```ini
    filter {
      mutate {
        add_field => {
          "logtype" => "nginx"
          "service_name" => "myservicename"
          "hostname" => "%{host}"
        }
      }
    }
    ```
  </Collapser>

  <Collapser className="freq-link" id="api-example" title="로그 API 예시">
    New Relic으로 전송된 JSON 요청에 속성을 추가할 수 있습니다. 이 예에서는 값이 `nginx` 인 `logtype` 속성을 추가하여 기본 제공 NGINX 구문 분석 규칙을 트리거합니다. [Logs API](/docs/logs/new-relic-logs/log-api/introduction-log-api) 사용에 대해 자세히 알아보세요.

    ```
    POST /log/v1 HTTP/1.1
    Host: log-api.newrelic.com
    Content-Type: application/json
    X-License-Key: YOUR_LICENSE_KEY
    Accept: */*
    Content-Length: 133
    {
      "timestamp": TIMESTAMP_IN_UNIX_EPOCH,
      "message": "User 'xyz' logged in",
      "logtype": "nginx",
      "service": "login-service",
      "hostname": "login.example.com"
    }
    ```
  </Collapser>
</CollapserGroup>

구문 분석 규칙을 프로그래밍 방식으로 관리하려면 api.newrelic.com/graphiql에서 GraphQL 형식 API인 [NerdGraph](https://api.newrelic.com/graphiql) 를 사용하십시오. 자세한 내용은 구문 분석 규칙을 생성, 쿼리 및 삭제하는 [NerdGraph 자습서](/docs/apis/nerdgraph/examples/nerdgraph-log-parsing-rules-tutorial) 를 참조하세요.

<CollapserGroup>
  <Collapser id="apache" title="아파치">
    <DNT>**Source:**</DNT> `logtype = 'apache'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `clientip`: 클라이언트의 IP 주소입니다.
    * `verb`: HTTP 동사
    * `ident`: 요청하는 클라이언트의 사용자 ID
    * `response`: 응답의 HTTP 상태 코드
    * `request`: URI 및 요청 중인
    * `httpversion`: 요청의 HTTP 버전
    * `rawrequest`: 데이터가 게시된 경우 원시 HTTP 요청
    * `bytes`: 보낸 바이트 수
    * `referrer`: HTTP 리퍼러
    * `agent`: 클라이언트의 사용자 에이전트
  </Collapser>

  <Collapser id="apache_error" title="아파치 오류">
    <DNT>**Source:**</DNT> `logtype = 'apache_error'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    \[%{DATA:apache_error.timestamp}\] \[%{WORD:apache_error.source}:%{DATA:level}\] \[pid %{NUMBER:apache_error.pid}(:tid %{NUMBER:apache_error.tid})?\] (%{DATA:apache_error.sourcecode}\(%{NUMBER:apache_error.linenum}\): )?(?:\[client %{IPORHOST:apache_error.clientip}:%{POSINT:apache_error.port}\] ){0,1}%{GREEDYDATA:apache_error.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `apache_error.timestamp`: 로그 문의 타임스탬프
    * `apache_error.source`: 소스 모듈
    * `level`: 로그 레벨
    * `apache_error.pid`: 아파치 PID(프로세스 식별자)
    * `apache_error.tid`: 아파치 TID(스레드 식별자)
    * `apache_error.sourcecode`: 아파치 소스코드
    * `apache_error.linenum`: 소스코드 줄 번호
    * `apache_error.clientip`: 클라이언트 IP 주소
    * `apache_error.port`: 클라이언트 IP 포트 번호
    * `apache_error.message`: 오류 메시지
  </Collapser>

  <Collapser id="application-load-balancer" title="애플리케이션 로드 밸런서">
    <DNT>**Source:**</DNT> `logtype = 'alb'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} "%{DATA:request}" "%{DATA:user_agent}" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} "%{DATA:trace_id}" "%{NOTSPACE:domain_name}" "%{NOTSPACE:chosen_cert_arn}" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} "%{NOTSPACE:actions_executed}" "%{NOTSPACE:redirect_url}" "%{NOTSPACE:error_reason}" (?:"|)%{DATA:target_port_list}(?:"|) (?:"|)%{DATA:target_status_code_list}(?:"|) "%{NOTSPACE:classification}" "%{NOTSPACE:classification_reason}"
    ```

    <DNT>
      **Results:**
    </DNT>

    <table>
      <thead>
        <tr>
          <th style={{ width: "250px" }}>
            들
          </th>

          <th>
            정의
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `type`
          </td>

          <td>
            요청 또는 연결 유형입니다. 가능한 값은 다음과 같습니다.

            * `http`: HTTP
            * `https`: SSL/TLS를 통한 HTTP
            * `h2`: SSL/TLS를 통한 HTTP/2
            * `ws`: 웹소켓
            * `wss`: SSL/TLS를 통한 WebSockets
          </td>
        </tr>

        <tr>
          <td>
            `elb`
          </td>

          <td>
            로드 밸런서의 리소스 ID입니다. 액세스 로그 항목을 구문 분석하는 경우 리소스 ID에 슬래시( `/` )가 포함될 수 있습니다.
          </td>
        </tr>

        <tr>
          <td>
            `client_ip`
          </td>

          <td>
            요청하는 클라이언트의 IP 주소
          </td>
        </tr>

        <tr>
          <td>
            `client_port`
          </td>

          <td>
            요청하는 클라이언트의 IP 포트
          </td>
        </tr>

        <tr>
          <td>
            `target_ip`
          </td>

          <td>
            이 요청을 처리한 대상의 IP 주소입니다.

            * 클라이언트가 전체 요청을 보내지 않은 경우 로드 밸런서는 요청을 대상으로 전달할 수 없으며 이 값은 `-` 으로 설정됩니다.
            * 대상이 Lambda 함수인 경우 이 값은 `-` 으로 설정됩니다.
            * 요청이 AWS WAF에 의해 차단된 경우 이 값은 `-` 으로 설정되고 `elb_status_code` `403` 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `target_port`
          </td>

          <td>
            이 요청을 처리한 대상의 IP 포트입니다.

            * 클라이언트가 전체 요청을 보내지 않은 경우 로드 밸런서는 요청을 대상으로 전달할 수 없으며 이 값은 `-` 으로 설정됩니다.
            * 대상이 Lambda 함수인 경우 이 값은 `-` 으로 설정됩니다.
            * 요청이 AWS WAF에 의해 차단된 경우 이 값은 `-` 으로 설정되고 `elb_status_code` `403` 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `target_port_list`
          </td>

          <td>
            이 요청을 처리한 대상의 IP 주소 및 포트입니다.

            * 클라이언트가 전체 요청을 보내지 않은 경우 로드 밸런서는 요청을 대상으로 전달할 수 없으며 이 값은 `-` 으로 설정됩니다.
            * 대상이 Lambda 함수인 경우 이 값은 `-` 으로 설정됩니다.
            * 요청이 AWS WAF에 의해 차단된 경우 이 값은 `-` 으로 설정되고 `elb_status_code` `403` 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `request_processing_time`
          </td>

          <td>
            로드 밸런서가 요청을 수신한 시간부터 대상으로 보낼 때까지 경과된 총 시간(초 단위, 밀리초 정밀도)입니다.

            * 로드 밸런서가 요청을 대상에 전달할 수 없는 경우 이 값은 `-1` 으로 설정됩니다. 이는 대상이 유휴 시간 초과 전에 연결을 닫거나 클라이언트가 잘못된 요청을 보내는 경우 발생할 수 있습니다.
            * 등록된 대상이 유휴 시간 초과 전에 응답하지 않는 경우 이 값을 `-1` 으로 설정할 수도 있습니다.
          </td>
        </tr>

        <tr>
          <td>
            `target_processing_time`
          </td>

          <td>
            로드 밸런서가 대상에 요청을 보낸 시간부터 대상이 응답 헤더를 보내기 시작할 때까지 경과된 총 시간(초 단위, 밀리초 단위)입니다.

            * 로드 밸런서가 요청을 대상에 전달할 수 없는 경우 이 값은 `-1` 으로 설정됩니다. 이는 대상이 유휴 시간 초과 전에 연결을 닫거나 클라이언트가 잘못된 요청을 보내는 경우 발생할 수 있습니다.
            * 등록된 대상이 유휴 시간 초과 전에 응답하지 않는 경우 이 값을 `-1` 으로 설정할 수도 있습니다.
          </td>
        </tr>

        <tr>
          <td>
            `response_processing_time`
          </td>

          <td>
            로드 밸런서가 대상에서 응답 헤더를 수신한 시간부터 클라이언트에 응답을 보내기 시작할 때까지 경과된 총 시간(초 단위, 밀리초 단위)입니다. 여기에는 로드 밸런서의 대기 시간과 로드 밸런서에서 클라이언트로의 연결 획득 시간이 모두 포함됩니다.

            로드 밸런서가 대상에 요청을 보낼 수 없는 경우 이 값은 `-1` 으로 설정됩니다. 이는 유휴 시간 초과 전에 대상이 연결을 닫거나 클라이언트가 잘못된 요청을 보내는 경우 발생할 수 있습니다.
          </td>
        </tr>

        <tr>
          <td>
            `elb_status_code`
          </td>

          <td>
            로드 밸런서의 응답 상태 코드
          </td>
        </tr>

        <tr>
          <td>
            `target_status_code_list`
          </td>

          <td>
            대상 응답의 상태 코드입니다. 이 값은 대상에 대한 연결이 설정되고 대상이 응답을 보낸 경우에만 기록됩니다. 그렇지 않으면 `-` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `received_bytes`
          </td>

          <td>
            클라이언트(요청자)로부터 받은 요청의 크기(바이트)입니다. HTTP 요청의 경우 여기에 헤더가 포함됩니다. WebSocket의 경우 연결 시 클라이언트로부터 받은 총 바이트 수입니다.
          </td>
        </tr>

        <tr>
          <td>
            `sent_bytes`
          </td>

          <td>
            클라이언트(요청자)에게 보낸 응답의 크기(바이트)입니다. HTTP 요청의 경우 여기에 헤더가 포함됩니다. WebSocket의 경우 연결 시 클라이언트에 전송된 총 바이트 수입니다.
          </td>
        </tr>

        <tr>
          <td>
            `request`
          </td>

          <td>
            HTTP 요청
          </td>
        </tr>

        <tr>
          <td>
            `user_agent`
          </td>

          <td>
            요청을 보낸 클라이언트를 식별하는 사용자 에이전트 문자열로, 큰따옴표로 묶입니다. 문자열은 하나 이상의 제품 식별자인 제품/버전으로 구성됩니다. 문자열이 8KB보다 길면 잘립니다.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            SSL 암호. 리스너가 HTTPS 리스너가 아닌 경우 이 값은 `-` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            SSL 프로토콜. 리스너가 HTTPS 리스너가 아닌 경우 이 값은 `-` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `target_group_arn`
          </td>

          <td>
            대상 그룹의 Amazon 리소스 이름(ARN)
          </td>
        </tr>

        <tr>
          <td>
            `trace_id`
          </td>

          <td>
            큰따옴표로 묶인 `X-Amzn-Trace-Id header` 의 내용
          </td>
        </tr>

        <tr>
          <td>
            `domain_name`
          </td>

          <td>
            큰따옴표로 묶인 TLS 핸드셰이크 동안 클라이언트에서 제공한 SNI 도메인입니다. 클라이언트가 SNI를 지원하지 않거나 도메인이 인증서와 일치하지 않고 기본 인증서가 클라이언트에 제공되는 경우 이 값은 `-` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `chosen_cert_arn`
          </td>

          <td>
            큰따옴표로 묶인 클라이언트에 제공된 인증서의 ARN입니다.

            * 세션이 재사용되는 경우 `session-reused` 으로 설정합니다.
            * 리스너가 HTTPS 리스너가 아닌 경우 `-` 으로 설정합니다.
          </td>
        </tr>

        <tr>
          <td>
            `matched_rule_priority`
          </td>

          <td>
            요청과 일치하는 규칙의 우선 순위 값입니다.

            * 규칙이 일치하면 `1` 에서 `50000` 사이의 값입니다.
            * 일치하는 규칙이 없고 기본 작업이 수행된 경우 이 값은 `0` 으로 설정됩니다.
            * 규칙 평가 중에 오류가 발생하면 `-1` 으로 설정됩니다.
            * 다른 오류의 경우 `-` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `request_creation_time`
          </td>

          <td>
            로드 밸런서가 클라이언트로부터 ISO 8601 형식의 요청을 받은 시간입니다.
          </td>
        </tr>

        <tr>
          <td>
            `actions_executed`
          </td>

          <td>
            큰따옴표로 묶인 요청을 처리할 때 수행되는 작업입니다. 이 값은 `actions_taken` 에 설명된 값을 포함할 수 있는 쉼표로 구분된 목록입니다. 잘못된 요청과 같은 조치가 취해지지 않은 경우 이 값은 `-` 로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `redirect_url`
          </td>

          <td>
            큰따옴표로 묶인 HTTP 응답의 위치 헤더에 대한 리디렉션 대상의 URL입니다. 리디렉션 작업이 수행되지 않은 경우 이 값은 `-` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `error_reason`
          </td>

          <td>
            큰따옴표로 묶인 오류 이유 코드입니다.

            * 요청이 실패한 경우 오류 원인 코드에 설명된 오류 코드 중 하나입니다.
            * 수행한 작업에 인증 작업이 포함되어 있지 않거나 대상이 Lambda 함수가 아닌 경우 이 값은 `-` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `classification`
          </td>

          <td>
            분류.
          </td>
        </tr>

        <tr>
          <td>
            `classification_reason`
          </td>

          <td>
            분류 이유입니다.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="cassandra" title="Cassandra">
    원천: `logtype = 'cassandra'`

    그록

    ```grok
    %{WORD:level}%{SPACE}\\[%{NOTSPACE:cassandra.thread}\\] %{TIMESTAMP_ISO8601:cassandra.timestamp} %{NOTSPACE:cassandra.source}:%{INT:cassandra.line.number} - %{GREEDYDATA:cassandra.message}
    ```

    ### 결과

    * `level`: 메시지의 로그 레벨(all, trace, debug, info, warn, error, off)
    * `cassandra.thread`: 로그문을 발행하는 쓰레드의 이름
    * `cassandra.timestamp`: 로그 문의 타임스탬프
    * `cassandra.source`: 소스 파일 이름
    * `cassandra.line.number`: 메시지의 줄 번호
    * `cassandra.message`: 원시 카산드라 메시지
  </Collapser>

  <Collapser id="cloudfront" title="CloudFront(표준 로그)">
    <DNT>**Source:**</DNT> `logtype = 'cloudfront-web'`

    <DNT>
      **Grok:**
    </DNT>

    ```
    ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end}
    ```

    <DNT>
      **Results:**
    </DNT>

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            들
          </th>

          <th>
            정의
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            요청을 처리한 엣지 로케이션입니다. 각 에지 위치는 3자리 코드와 임의로 할당된 번호로 식별됩니다. 예: `DFW3` .

            3자리 코드는 일반적으로 엣지 로케이션 근처 공항의 국제항공운송협회(International Air Transport Association) 공항 코드에 해당합니다. (이 약어는 향후 변경될 수 있습니다.)
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            헤더를 포함하여 CloudFront가 요청에 대한 응답으로 최종 사용자에게 제공한 총 바이트 수입니다. 예: `1045619` . WebSocket 연결의 경우 연결을 통해 서버에서 클라이언트로 보낸 총 바이트 수입니다.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            요청한 뷰어의 IP 주소(IPv4 또는 IPv6 형식). 뷰어가 HTTP 프록시 또는 부하 분산기를 사용하여 요청을 보낸 경우 `c_ip` 값은 프록시 또는 부하 분산기의 IP 주소입니다. `X-Forwarded-For` 도 참조하십시오.
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            HTTP 요청 방법: `DELETE` , `GET` , `HEAD` , `OPTIONS` , `PATCH` , `POST` 또는 `PUT`
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            CloudFront 배포의 도메인 이름. 예: `d111111abcdef8.cloudfront.net` .
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            경로 및 개체를 식별하는 URI 부분입니다. 예: `/images/cat.jpg` . URL 및 쿼리 문자열의 물음표는 포함되지 않습니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            HTTP 상태 코드 예: `200` . 상태 코드 `000` 는 CloudFront가 요청에 응답하기 전에 뷰어가 연결을 닫았음을 나타냅니다(예: 브라우저 탭 닫기). CloudFront에서 응답을 보내기 시작한 후 최종 사용자가 연결을 닫으면 로그에 해당 HTTP 상태 코드가 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            요청을 시작한 도메인의 이름입니다. 일반적인 리퍼러에는 검색 엔진, 개체에 직접 연결되는 기타 웹사이트, 자체 웹사이트가 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            요청의 User-Agent 헤더 값입니다. User-Agent 헤더는 요청을 제출한 장치 및 브라우저 유형, 해당되는 경우 어떤 검색 엔진과 같은 요청 소스를 식별합니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            URI의 쿼리 문자열 부분(있는 경우). URI에 쿼리 문자열이 포함되지 않은 경우 이 필드의 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            이름-값 쌍 및 관련 속성을 포함한 요청의 쿠키 헤더입니다.

            * 쿠키 로깅을 활성화하면 CloudFront는 오리진에 전달하기로 선택한 쿠키에 관계없이 모든 요청의 쿠키를 기록합니다.
            * 요청에 쿠키 헤더가 포함되지 않은 경우 이 필드의 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            CloudFront에서 마지막 바이트가 엣지 로케이션을 떠난 후 응답을 분류하는 방법입니다. 경우에 따라 CloudFront에서 응답을 보낼 준비가 된 시간과 CloudFront에서 응답 전송을 완료한 시간 사이에 결과 유형이 변경될 수 있습니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            요청을 고유하게 식별하는 암호화된 문자열입니다. 응답 헤더에서 이것은 `x-amz-cf-id` 입니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            뷰어가 이 요청에 대한 Host 헤더에 포함시킨 값입니다. 이것은 요청의 도메인 이름입니다.

            * 객체 URL에서 CloudFront 도메인 이름을 사용하는 경우 이 필드에 해당 도메인 이름이 포함됩니다.
            * `http://example.com/logo.png` 와 같은 개체 URL에서 대체 도메인 이름을 사용하는 경우 이 필드에는 `example.com` 과 같은 대체 도메인 이름이 포함됩니다. 대체 도메인 이름을 사용하려면 배포에 추가해야 합니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            뷰어가 요청에 지정한 프로토콜: `http` , `https` , `ws` 또는 `wss` .
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            헤더를 포함하여 뷰어가 요청에 포함시킨 데이터의 바이트 수입니다. WebSocket 연결의 경우 연결 시 클라이언트에서 서버로 보낸 총 바이트 수입니다.
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            CloudFront 엣지 서버가 최종 사용자의 요청을 수신한 시간과 CloudFront에서 측정된 엣지 서버의 출력 대기열에 응답의 마지막 바이트를 쓰는 시간 사이의 시간(1000분의 1초 단위, 예: 0.002)입니다. 서버.

            뷰어의 관점에서 전체 개체를 가져오는 데 걸리는 총 시간은 네트워크 대기 시간 및 TCP 버퍼링으로 인해 이 값보다 길어집니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            뷰어가 HTTP 프록시 또는 부하 분산기를 사용하여 요청을 보낸 경우 필드 5의 `c_ip` 값은 프록시 또는 부하 분산기의 IP 주소입니다. 이 경우 이 필드는 요청을 시작한 뷰어의 IP 주소입니다.

            이 필드에는 해당되는 경우 IPv4 및 IPv6 주소가 포함됩니다. 뷰어가 HTTP 프록시 또는 부하 분산기를 사용하지 않은 경우 `x_forwarded_for` 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            필드 17의 `cs_protocol` 이 `https` 인 경우 이 필드에는 클라이언트와 CloudFront가 요청 및 응답 전송을 위해 협상한 SSL/TLS 프로토콜이 포함됩니다. 가능한 값은 다음과 같습니다.

            * SSLv3

            * TLSv1

            * TLSv1.1

            * TLSv1.2

              필드 17의 `cs_protocol` 이 `http` 인 경우 이 필드의 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            필드 17의 `cs_protocol` 이 `https` 이면 이 필드에는 클라이언트와 CloudFront가 요청 및 응답 암호화를 위해 협상한 SSL/TLS 암호가 포함됩니다. 가능한 값은 다음과 같습니다.

            * `ECDHE-RSA-AES128-GCM-SHA256`

            * `ECDHE-RSA-AES128-SHA256`

            * `ECDHE-RSA-AES128-SHA`

            * `ECDHE-RSA-AES256-GCM-SHA384`

            * `ECDHE-RSA-AES256-SHA384`

            * `ECDHE-RSA-AES256-SHA`

            * `AES128-GCM-SHA256`

            * `AES256-GCM-SHA384`

            * `AES128-SHA256`

            * `AES256-SHA`

            * `AES128-SHA`

            * `DES-CBC3-SHA`

            * `RC4-MD5`

              필드 17의 `cs_protocol` 이 `http` 인 경우 이 필드의 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            최종 사용자에게 응답을 반환하기 직전에 CloudFront에서 응답을 분류한 방법입니다. 가능한 값은 다음과 같습니다.

            * `Hit`: CloudFront는 엣지 캐시에서 최종 사용자에게 객체를 제공했습니다.
            * `RefreshHit`: CloudFront가 엣지 캐시에서 객체를 찾았지만 만료되었기 때문에 CloudFront가 오리진에 연락하여 캐시에 객체의 최신 버전이 있는지 확인했습니다.
            * `Miss`: 엣지 캐시의 객체가 요청을 충족할 수 없었기 때문에 CloudFront는 요청을 오리진 서버로 전달하고 결과를 최종 사용자에게 반환했습니다.
            * `LimitExceeded`: CloudFront 제한을 초과하여 요청이 거부되었습니다.
            * `CapacityExceeded`: 객체 제공 요청 당시 엣지 로케이션에 용량이 충분하지 않았기 때문에 CloudFront에서 `503` 오류를 반환했습니다.
            * `Error`: 일반적으로 이는 요청으로 인해 클라이언트 오류( `sc_status` 는 `4xx` ) 또는 서버 오류( `sc_status` 는 `5xx` )가 발생했음을 의미합니다. `x_edge_result_type` 의 값이 `Error` 이고 이 필드의 값이 `Error` 이 **아닌** 경우 클라이언트는 다운로드를 완료하기 전에 연결이 끊긴 것입니다.
            * `Redirect`: CloudFront는 HTTP에서 HTTPS로 리디렉션합니다. `sc_status` 이 `403` 이고 콘텐츠의 지리적 배포를 제한하도록 CloudFront를 구성한 경우 요청이 제한된 위치에서 왔을 수 있습니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            뷰어가 요청에서 지정한 HTTP 버전입니다. 가능한 값은 다음과 같습니다.

            * `HTTP/0.9`
            * `HTTP/1.0`
            * `HTTP/1.1`
            * `HTTP/2.0`
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            배포에 대해 필드 수준 암호화가 구성된 경우 이 필드에는 요청 본문이 성공적으로 처리되었는지 여부를 나타내는 코드가 포함됩니다.

            배포에 대해 필드 수준 암호화가 구성되지 않은 경우 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `fle-encrypted-fields`
          </td>

          <td>
            CloudFront에서 암호화하여 오리진으로 전달한 필드의 수입니다. CloudFront는 데이터를 암호화할 때 처리된 요청을 오리진으로 스트리밍하므로 `fle-status` 값이 오류인 경우에도 `fle-encrypted-fields` 에 값이 있을 수 있습니다.

            배포에 대해 필드 수준 암호화가 구성되지 않은 경우 `fle-encrypted-fields` 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            뷰어의 요청 포트 번호입니다.
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            서버에서 측정된 요청 수신과 응답의 첫 번째 바이트 쓰기 사이의 시간(초)입니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            `x-edge-result-type` <DNT>**is not**</DNT> `Error` 일 때 이 필드에는 `x-edge-result-type` 과 동일한 값이 포함됩니다. `x-edge-result-type` <DNT>**is**</DNT> `Error` 일 때 이 필드에는 특정 유형의 오류가 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            응답의 HTTP Content-Type 헤더 값입니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            응답의 HTTP Content-Length 헤더 값입니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc_range_start`
          </td>

          <td>
            응답에 HTTP Content-Range 헤더가 포함된 경우 이 필드에는 범위 시작 값이 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            응답에 HTTP Content-Range 헤더가 포함된 경우 이 필드에는 범위 종료 값이 포함됩니다.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="cloudfront-rtl" title="CloudFront(실시간 로그)">
    <DNT>**Source:**</DNT> `logtype = 'cloudfront-rtl'`

    <DNT>
      **Grok:**
    </DNT>

    ```
    ^%{NOTSPACE:timestamp}.\d{3}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:cs_ip_version}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_cookie}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:c_country}%{SPACE}%{NOTSPACE:cs_accept_encoding}%{SPACE}%{NOTSPACE:cs_accept}%{SPACE}%{NOTSPACE:cache_behavior_path_pattern}%{SPACE}%{NOTSPACE:cs_headers}%{SPACE}%{NOTSPACE:cs_header_names}%{SPACE}%{NOTSPACE:cs_headers_count}$
    ```

    <DNT>
      **Results:**
    </DNT>

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            들
          </th>

          <th>
            정의
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `timestamp`
          </td>

          <td>
            에지 서버가 요청에 대한 응답을 완료한 날짜 및 시간입니다.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            요청한 뷰어의 IP 주소입니다(예: `192.0.2.183` 또는 `2001:0db8:85a3:0000:0000:8a2e:0370:7334` . 뷰어가 HTTP 프록시 또는 로드 밸런서를 사용하여 요청을 보낸 경우 이 필드의 값은 프록시 또는 로드 밸런서의 IP 주소입니다. `x-forwarded-for` 필드도 참조하십시오.
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            서버에서 측정된 요청 수신과 응답의 첫 번째 바이트 쓰기 사이의 시간(초)입니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            HTTP 상태 코드 예: `200` . 상태 코드 `000` 는 CloudFront가 요청에 응답하기 전에 뷰어가 연결을 닫았음을 나타냅니다(예: 브라우저 탭 닫기). CloudFront에서 응답을 보내기 시작한 후 최종 사용자가 연결을 닫으면 로그에 해당 HTTP 상태 코드가 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            헤더를 포함하여 요청에 대한 응답으로 서버가 뷰어에게 보낸 총 바이트 수입니다. WebSocket 연결의 경우 연결을 통해 서버에서 클라이언트로 보낸 총 바이트 수입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            뷰어에서 수신한 HTTP 요청 메서드입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            뷰어 요청의 프로토콜(http, https, ws 또는 wss)입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            뷰어가 요청의 Host 헤더에 포함시킨 값입니다. 객체 URL에서 CloudFront 도메인 이름(예: d111111abcdef8.cloudfront.net)을 사용하는 경우, 이 필드에는 해당 도메인 이름이 포함됩니다. 개체 URL(예: [www.example.com](http://www.example.com) )에서 대체 도메인 이름(CNAME)을 사용하는 경우 이 필드는 대체 도메인 이름을 포함합니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            쿼리 문자열(있는 경우)을 포함하지만 도메인 이름이 없는 전체 요청 URL입니다. 예: `/images/cat.webp?mobile=true` .
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            헤더를 포함하여 뷰어가 요청에 포함시킨 데이터의 총 바이트 수입니다. WebSocket 연결의 경우 연결 시 클라이언트에서 서버로 보낸 총 바이트 수입니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            요청을 처리한 엣지 로케이션입니다. 각 에지 위치는 3자리 코드와 임의로 할당된 번호(예: DFW3)로 식별됩니다. 3자리 코드는 일반적으로 엣지 로케이션의 지리적 위치에 가까운 공항에 대한 IATA(International Air Transport Association) 공항 코드에 해당합니다. (이 약어는 향후 변경될 수 있습니다.)
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            CloudFront에서 마지막 바이트가 엣지 로케이션을 떠난 후 응답을 분류하는 방법입니다. 경우에 따라 CloudFront에서 응답을 보낼 준비가 된 시간과 CloudFront에서 응답 전송을 완료한 시간 사이에 결과 유형이 변경될 수 있습니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            요청을 고유하게 식별하는 불투명 문자열입니다. CloudFront는 또한 x-amz-cf-id 응답 헤더에서 이 문자열을 보냅니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            CloudFront 배포의 도메인 이름(예: `d111111abcdef8.cloudfront.net` ).
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            서버에서 측정한 대로 서버가 뷰어의 요청을 수신한 시점부터 서버가 응답의 마지막 바이트를 출력 대기열에 쓸 때까지의 시간(1000분의 1초 단위, 예: 0.082)입니다. 뷰어의 관점에서 전체 응답을 얻는 데 걸리는 총 시간은 네트워크 대기 시간과 TCP 버퍼링으로 인해 이 값보다 더 깁니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            뷰어가 요청에서 지정한 HTTP 버전입니다. 가능한 값은 `HTTP/0.9` , `HTTP/1.0` , `HTTP/1.1` , `HTTP/2.0` 및 `HTTP/3.0` 입니다.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip_version`
          </td>

          <td>
            요청의 IP 버전(IPv4 또는 IPv6)입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            요청의 User-Agent 헤더 값입니다. User-Agent 헤더는 요청을 제출한 장치 및 브라우저 유형 또는 요청이 검색 엔진에서 온 경우 검색 엔진과 같은 요청 소스를 식별합니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            요청의 Referer 헤더 값입니다. 이것은 요청을 시작한 도메인의 이름입니다. 일반적인 리퍼러에는 검색 엔진, 개체에 직접 연결되는 기타 웹사이트, 자신의 웹사이트가 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            이름-값 쌍 및 관련 속성을 포함한 요청의 쿠키 헤더입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            요청 URL의 쿼리 문자열 부분(있는 경우).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            뷰어에게 응답을 반환하기 직전에 서버가 응답을 분류한 방법입니다. x-edge-result-type 필드도 참조하십시오. 가능한 값은 다음과 같습니다.

            * `Hit`: 서버가 캐시에서 뷰어에게 개체를 제공했습니다.
            * `RefreshHit`: 서버가 캐시에서 개체를 찾았지만 개체가 만료되어 서버가 원본에 연락하여 캐시에 개체의 최신 버전이 있는지 확인했습니다.
            * `Miss`: 캐시에 있는 객체가 요청을 만족시킬 수 없어 서버가 원본 서버로 요청을 전달하고 뷰어에게 결과를 반환했다.
            * `LimitExceeded`: CloudFront 할당량(이전에는 한도라고 함)이 초과되어 요청이 거부되었습니다.
            * `CapacityExceeded`: 서버는 개체를 제공하라는 요청 당시 용량이 충분하지 않았기 때문에 503 오류를 반환했습니다.
            * `Error`: 일반적으로 이는 요청으로 인해 클라이언트 오류(sc-status 필드의 값이 4xx 범위에 있음) 또는 서버 오류(sc-status 필드의 값이 5xx 범위에 있음)가 발생했음을 의미합니다. x-edge-result-type 필드의 값이 Error이고 이 필드의 값이 Error가 아닌 경우 클라이언트는 다운로드를 완료하기 전에 연결이 끊긴 것입니다.
            * `Redirect`: 서버가 배포 설정에 따라 뷰어를 HTTP에서 HTTPS로 리디렉션했습니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            뷰어가 HTTP 프록시 또는 로드 밸런서를 사용하여 요청을 보낸 경우 c-ip 필드의 값은 프록시 또는 로드 밸런서의 IP 주소입니다. 이 경우 이 필드는 요청을 시작한 뷰어의 IP 주소입니다. 이 필드에는 IPv4 주소(예: `192.0.2.183` ) 또는 IPv6 주소(예: `2001:0db8:85a3:0000:0000:8a2e:0370:7334` )가 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            요청이 HTTPS를 사용하는 경우 이 필드에는 뷰어와 서버가 요청 및 응답을 전송하기 위해 협상한 SSL/TLS 프로토콜이 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            요청이 HTTPS를 사용하는 경우 이 필드에는 뷰어와 서버가 요청 및 응답을 암호화하기 위해 협상한 SSL/TLS 암호가 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            마지막 바이트가 서버를 떠난 후 서버가 응답을 분류한 방법입니다. 경우에 따라 서버가 응답을 보낼 준비가 된 시간과 응답 전송을 완료한 시간 사이에 결과 유형이 변경될 수 있습니다. `x-edge-response-result-type` 필드도 참조하세요. 예를 들어, HTTP 스트리밍에서 서버가 캐시에서 스트림의 세그먼트를 찾는다고 가정합니다. 이 시나리오에서 이 필드의 값은 일반적으로 `Hit` 입니다. 그러나 서버가 전체 세그먼트를 전달하기 전에 뷰어가 연결을 닫으면 최종 결과 유형(및 이 필드의 값)은 `Error` 입니다. 콘텐츠를 캐시할 수 없고 원본에 직접 프록시되기 때문에 WebSocket 연결은 이 필드에 대해 `Miss` 값을 갖습니다.

            가능한 값은 다음과 같습니다.

            * `Hit`: 서버가 캐시에서 뷰어에게 개체를 제공했습니다.
            * `RefreshHit`: 서버가 캐시에서 개체를 찾았지만 개체가 만료되어 서버가 원본에 연락하여 캐시에 개체의 최신 버전이 있는지 확인했습니다.
            * `Miss`: 캐시의 객체가 요청을 만족시킬 수 없어 서버가 요청을 원본으로 전달하고 결과를 뷰어에게 반환했습니다.
            * `LimitExceeded`: CloudFront 할당량(이전에는 제한이라고 함)이 초과되어 요청이 거부되었습니다.
            * `CapacityExceeded`참고: 서버는 개체를 제공하라는 요청 당시 용량이 충분하지 않았기 때문에 HTTP 503 상태 코드를 반환했습니다.
            * `Error`: 일반적으로 이는 요청으로 인해 클라이언트 오류(sc-status 필드의 값이 4xx 범위에 있음) 또는 서버 오류(sc-status 필드의 값이 5xx 범위에 있음)가 발생했음을 의미합니다. `sc-status` 필드의 값이 `200` 이거나 이 필드의 값이 `Error` 이고 `x-edge-response-result-type` 필드의 값이 `Error` 가 아니면 HTTP 요청이 성공했지만 클라이언트가 모든 바이트를 수신하기 전에 연결이 끊어졌습니다.
            * `Redirect`: 서버가 배포 설정에 따라 뷰어를 HTTP에서 HTTPS로 리디렉션했습니다.
          </td>
        </tr>

        <tr>
          <td>
            `fle_encrypted_fields`
          </td>

          <td>
            서버가 암호화하여 오리진에 전달한 필드 수준 암호화 필드의 수입니다. CloudFront 서버는 데이터를 암호화할 때 처리된 요청을 오리진으로 스트리밍하므로 `fle-status` 값이 오류인 경우에도 이 필드에 값이 있을 수 있습니다.
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            배포에 대해 필드 수준 암호화가 구성된 경우 이 필드에는 요청 본문이 성공적으로 처리되었는지 여부를 나타내는 코드가 포함됩니다. 서버가 요청 본문을 성공적으로 처리하고 지정된 필드의 값을 암호화하고 요청을 원본으로 전달하면 이 필드의 값은 처리됨입니다. 이 경우 `x-edge-result-type` 값은 여전히 클라이언트 측 또는 서버 측 오류를 나타낼 수 있습니다.

            이 필드에 가능한 값은 다음과 같습니다. \* `ForwardedByContentType` : 콘텐츠 유형이 구성되지 않았기 때문에 서버가 구문 분석 또는 암호화 없이 요청을 원본으로 전달했습니다.

            * `ForwardedByQueryArgs`: 요청에 필드 수준 암호화에 대한 구성에 없는 쿼리 인수가 포함되어 있기 때문에 서버가 구문 분석이나 암호화 없이 요청을 원본으로 전달했습니다.
            * `ForwardedDueToNoProfile`: 필드 수준 암호화를 위한 구성에 프로필이 지정되지 않았기 때문에 서버가 구문 분석이나 암호화 없이 요청을 원본으로 전달했습니다.
            * `MalformedContentTypeClientError`: Content-Type 헤더의 값이 잘못된 형식이기 때문에 서버가 요청을 거부하고 뷰어에게 HTTP 400 상태 코드를 반환했습니다.
            * `MalformedInputClientError`: 요청 본문이 잘못된 형식이기 때문에 서버가 요청을 거부하고 뷰어에게 HTTP 400 상태 코드를 반환했습니다.
            * `MalformedQueryArgsClientError`참고: 쿼리 인수가 비어 있거나 형식이 잘못되었기 때문에 서버가 요청을 거부하고 뷰어에게 HTTP 400 상태 코드를 반환했습니다.
            * `RejectedByContentType`참고: 필드 수준 암호화를 위한 구성에 콘텐츠 유형이 지정되지 않았기 때문에 서버가 요청을 거부하고 뷰어에게 HTTP 400 상태 코드를 반환했습니다.
            * `RejectedByQueryArgs`참고: 필드 수준 암호화에 대한 구성에 쿼리 인수가 지정되지 않았기 때문에 서버가 요청을 거부하고 뷰어에게 HTTP 400 상태 코드를 반환했습니다.
            * `ServerError`: 원본 서버에서 오류를 반환했습니다. 요청이 필드 수준 암호화 할당량(이전에는 제한이라고 함)을 초과하는 경우 이 필드에는 다음 오류 코드 중 하나가 포함되고 서버는 뷰어에게 HTTP 상태 코드 400을 반환합니다.
            * `FieldLengthLimitClientError`: 암호화되도록 구성된 필드가 허용되는 최대 길이를 초과했습니다.
            * `FieldNumberLimitClientError`: 배포가 암호화하도록 구성된 요청에 허용된 필드 수보다 더 많이 포함되어 있습니다.
            * `RequestLengthLimitClientError`: 요청 본문의 길이가 필드 수준 암호화가 구성된 경우 허용되는 최대 길이를 초과했습니다..
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            응답의 HTTP Content-Type 헤더 값입니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            응답의 HTTP Content-Length 헤더 값입니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-start`
          </td>

          <td>
            응답에 HTTP Content-Range 헤더가 포함된 경우 이 필드에는 범위 시작 값이 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            응답에 HTTP Content-Range 헤더가 포함된 경우 이 필드에는 범위 종료 값이 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            뷰어의 요청 포트 번호입니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            `x-edge-result-type` 필드의 값이 `Error` 이면 이 필드에는 특정 유형의 오류가 포함됩니다. 개체가 Origin Shield 캐시에서 뷰어에게 제공되었을 때 이 필드에는 `OriginShieldHit` 가 포함됩니다. 다른 모든 경우에 이 필드는 `x-edge-result-type` 과 동일한 값을 포함합니다. 이 필드에 가능한 값은 다음과 같습니다.

            * `AbortedOrigin`: 서버에서 원본에 문제가 발생했습니다.
            * `OriginCommError`: 오리진에 연결하거나 오리진에서 데이터를 읽는 동안 요청 시간이 초과되었습니다.
            * `ClientCommError`: 서버와 뷰어 간의 통신 문제로 뷰어 응답이 끊겼습니다.
            * `ClientGeoBlocked`: 시청자의 지리적 위치에서 요청을 거부하도록 배포가 구성됩니다.
            * `ClientHungUpRequest`: 뷰어가 요청을 보내는 동안 중간에 중지되었습니다.
            * `Error` – 오류 유형이 다른 범주에 맞지 않는 오류가 발생했습니다. 이 오류 유형은 서버가 캐시에서 오류 응답을 제공할 때 발생할 수 있습니다.
            * `InvalidRequest`: 서버가 뷰어로부터 잘못된 요청을 받았습니다.
            * `InvalidRequestBlocked`: 요청한 리소스에 대한 접근이 차단되었습니다.
            * `InvalidRequestCertificate`: 배포가 HTTPS 연결이 설정된 SSL/TLS 인증서와 일치하지 않습니다.
            * `InvalidRequestHeader`: 요청에 잘못된 헤더가 있습니다.
            * `InvalidRequestMethod`: 사용된 HTTP 요청 방법을 처리하도록 배포가 구성되지 않았습니다. 이는 배포가 캐시 가능한 요청만 지원하는 경우에 발생할 수 있습니다.
            * `OriginConnectError`: 서버가 원본에 연결할 수 없습니다.
            * `OriginContentRangeLengthError`: 원본 응답의 Content-Length 헤더가 Content-Range 헤더의 길이와 일치하지 않습니다.
            * `OriginDnsError`: 서버가 원본의 도메인 이름을 확인할 수 없습니다.
            * `OriginError`: 출처가 잘못된 응답을 반환했습니다.
            * `OriginHeaderTooBigError`: 오리진에서 반환된 헤더가 에지 서버에서 처리하기에는 너무 큽니다.
            * `OriginInvalidResponseError`: 출처가 잘못된 응답을 반환했습니다.
            * `OriginReadError`: 서버가 원본에서 읽을 수 없습니다.
            * `OriginShieldHit`: 개체가 Origin Shield 캐시에서 뷰어에게 제공되었습니다.
            * `OriginWriteError`: 서버가 원본에 쓸 수 없습니다.
            * `OriginZeroSizeObjectError`: 원본에서 보낸 크기가 0인 개체로 인해 오류가 발생했습니다.
            * `SlowReaderOriginError`: 뷰어가 원본 오류를 일으킨 메시지를 읽는 속도가 느렸습니다.
          </td>
        </tr>

        <tr>
          <td>
            `c_country`
          </td>

          <td>
            시청자의 IP 주소에 따라 결정되는 시청자의 지리적 위치를 나타내는 국가 코드입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_accept_encoding`
          </td>

          <td>
            뷰어 요청의 `Accept-Encoding` 헤더 값입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_accept`
          </td>

          <td>
            뷰어 요청의 `Accept` 헤더 값입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cache_behavior_path_pattern`
          </td>

          <td>
            뷰어 요청과 일치하는 캐시 동작을 식별하는 경로 패턴입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_headers`
          </td>

          <td>
            뷰어 요청의 HTTP 헤더(이름 및 값)입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_header_names`
          </td>

          <td>
            뷰어 요청의 HTTP 헤더 이름(값 아님)입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_headers_count`
          </td>

          <td>
            뷰어 요청의 HTTP 헤더 수입니다.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="elastic-load-balancer" title="탄력적 로드 밸런서">
    <DNT>**Source:**</DNT> `logtype = 'elb'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} "%{DATA:request}" "%{DATA:user_agent}" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol}
    ```

    <DNT>
      **Results:**
    </DNT>

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            들
          </th>

          <th>
            정의
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            요청을 처리한 엣지 로케이션입니다. 각 에지 위치는 3자리 코드와 임의로 할당된 번호로 식별됩니다. 예: `DFW3` . 3자리 코드는 일반적으로 엣지 로케이션 근처 공항의 국제항공운송협회(International Air Transport Association) 공항 코드와 일치합니다. (이 약어는 향후 변경될 수 있습니다.)
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            헤더를 포함하여 CloudFront가 요청에 대한 응답으로 최종 사용자에게 제공한 총 바이트 수입니다. 예: `1045619` . WebSocket 연결의 경우 연결을 통해 서버에서 클라이언트로 보낸 총 바이트 수입니다.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            요청한 뷰어의 IP 주소입니다. 뷰어가 HTTP 프록시 또는 부하 분산기를 사용하여 요청을 보낸 경우 `c_ip` 값은 프록시 또는 부하 분산기의 IP 주소입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            HTTP 요청 방법: `DELETE` , `GET` , `HEAD` , `OPTIONS` , `PATCH` , `POST` 또는 `PUT`
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            CloudFront 배포의 도메인 이름. 예: `d111111abcdef8.cloudfront.net` .
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            경로 및 개체를 식별하는 URI 부분입니다. 예: `/images/cat.jpg` . URL 및 쿼리 문자열의 물음표( `?` )는 로그에 포함되지 않습니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            HTTP 상태 코드(예: `200` ) 상태 코드 `000` 는 CloudFront가 요청에 응답하기 전에 뷰어가 연결을 닫았음을 나타냅니다(예: 브라우저 탭 닫기).

            CloudFront에서 응답을 보내기 시작한 후 최종 사용자가 연결을 닫으면 로그에 해당 HTTP 상태 코드가 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            요청을 시작한 도메인의 이름입니다. 일반적인 리퍼러에는 검색 엔진, 개체에 직접 연결되는 기타 웹사이트, 자신의 웹사이트가 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            요청의 User-Agent 헤더 값입니다. User-Agent 헤더는 요청을 제출한 장치 및 브라우저 유형 및 해당되는 경우 검색 엔진과 같은 요청 소스를 식별합니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            URI의 쿼리 문자열 부분(있는 경우). URI에 쿼리 문자열이 포함되지 않은 경우 이 필드의 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            이름-값 쌍 및 관련 속성을 포함한 요청의 쿠키 헤더입니다.

            * 쿠키 로깅을 활성화하면 CloudFront는 오리진에 전달하기로 선택한 쿠키에 관계없이 모든 요청에서 쿠키를 기록합니다.
            * 요청에 쿠키 헤더가 포함되지 않은 경우 이 필드의 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            CloudFront에서 마지막 바이트가 엣지 로케이션을 떠난 후 응답을 분류하는 방법입니다. 경우에 따라 CloudFront에서 응답을 보낼 준비가 된 시간과 CloudFront에서 응답 전송을 완료한 시간 사이에 결과 유형이 변경될 수 있습니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            요청을 고유하게 식별하는 암호화된 문자열입니다. 응답 헤더에서 이것은 `x-amz-cf-id` 입니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            뷰어가 이 요청에 대한 Host 헤더에 포함시킨 값입니다. 이것은 요청의 도메인 이름입니다.

            * 객체 URL에서 CloudFront 도메인 이름을 사용하는 경우 이 필드에 해당 도메인 이름이 포함됩니다.
            * `[http://example.com/logo.png` 와 같은 개체 URL에서 대체 도메인 이름을 사용하는 경우 이 필드에는 `example.com` 과 같은 대체 도메인 이름이 포함됩니다. 대체 도메인 이름을 사용하려면 배포에 추가해야 합니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            뷰어가 요청에 지정한 프로토콜: `http` , `https` , `ws` 또는 `wss` .
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            헤더를 포함하여 뷰어가 요청에 포함시킨 데이터의 바이트 수입니다. WebSocket 연결의 경우 연결 시 클라이언트에서 서버로 보낸 총 바이트 수입니다.
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            CloudFront 엣지 서버가 최종 사용자의 요청을 수신한 시간과 CloudFront에서 측정된 엣지 서버의 출력 대기열에 응답의 마지막 바이트를 쓰는 시간 사이의 시간(1000분의 1초 단위, 예: 0.002)입니다. 서버.

            뷰어의 관점에서 전체 개체를 가져오는 데 걸리는 총 시간은 네트워크 대기 시간 및 TCP 버퍼링으로 인해 이 값보다 길어집니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            뷰어가 HTTP 프록시 또는 부하 분산기를 사용하여 요청을 보낸 경우 필드 5의 `c_ip` 값은 프록시 또는 부하 분산기의 IP 주소입니다. 이 경우 이 필드는 요청을 시작한 뷰어의 IP 주소입니다. 이 필드에는 해당되는 경우 IPv4 및 IPv6 주소가 포함됩니다.

            뷰어가 HTTP 프록시 또는 부하 분산기를 사용하지 않은 경우 `x_forwarded_for` 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            필드 17의 `cs_protocol` 이 `https` 인 경우 이 필드에는 클라이언트와 CloudFront가 요청 및 응답 전송을 위해 협상한 SSL/TLS 프로토콜이 포함됩니다. 가능한 값은 다음과 같습니다.

            * SSLv3
            * TLSv1
            * TLSv1.1
            * TLSv1.2 필드 17의 `cs_protocol` 이 `http` 인 경우 이 필드의 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            필드 17의 `cs_protocol` 이 `https` 이면 이 필드에는 클라이언트와 CloudFront가 요청 및 응답 암호화를 위해 협상한 SSL/TLS 암호가 포함됩니다. 가능한 값은 다음과 같습니다.

            * `ECDHE-RSA-AES128-GCM-SHA256`

            * `ECDHE-RSA-AES128-SHA256`

            * `ECDHE-RSA-AES128-SHA`

            * `ECDHE-RSA-AES256-GCM-SHA384`

            * `ECDHE-RSA-AES256-SHA384`

            * `ECDHE-RSA-AES256-SHA`

            * `AES128-GCM-SHA256`

            * `AES256-GCM-SHA384`

            * `AES128-SHA256`

            * `AES256-SHA`

            * `AES128-SHA`

            * `DES-CBC3-SHA`

            * `RC4-MD5`

              `cs_protocol` 이 `http` 이면 이 필드의 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            최종 사용자에게 응답을 반환하기 직전에 CloudFront에서 응답을 분류한 방법입니다. 가능한 값은 다음과 같습니다.

            * `Hit`: CloudFront는 엣지 캐시에서 최종 사용자에게 객체를 제공했습니다.
            * `RefreshHit`: CloudFront가 엣지 캐시에서 객체를 찾았지만 만료되었기 때문에 CloudFront가 오리진에 연락하여 캐시에 객체의 최신 버전이 있는지 확인했습니다.
            * `Miss`: 엣지 캐시의 객체가 요청을 충족할 수 없었기 때문에 CloudFront는 요청을 오리진 서버로 전달하고 결과를 최종 사용자에게 반환했습니다.
            * `LimitExceeded`: CloudFront 제한을 초과하여 요청이 거부되었습니다.
            * `CapacityExceeded`: 객체 제공 요청 당시 엣지 로케이션에 용량이 충분하지 않았기 때문에 CloudFront에서 `503` 오류를 반환했습니다.
            * `Error`: 일반적으로 이는 요청으로 인해 클라이언트 오류( `sc_status` 는 `4xx` ) 또는 서버 오류( `sc_status` 는 `5xx` )가 발생했음을 의미합니다. `x_edge_result_type` 의 값이 `Error` 이고 이 필드의 값이 `Error` 이 **아닌** 경우 클라이언트는 다운로드를 완료하기 전에 연결이 끊긴 것입니다.
            * `Redirect`: CloudFront는 HTTP에서 HTTPS로 리디렉션합니다. `sc_status` 이 `403` 이고 콘텐츠의 지리적 배포를 제한하도록 CloudFront를 구성한 경우 요청이 제한된 위치에서 왔을 수 있습니다.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            뷰어가 요청에서 지정한 HTTP 버전입니다. 가능한 값은 다음과 같습니다.

            * `HTTP/0.9`
            * `HTTP/1.0`
            * `HTTP/1.1`
            * `HTTP/2.0`
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            배포에 대해 필드 수준 암호화가 구성된 경우 이 필드에는 요청 본문이 성공적으로 처리되었는지 여부를 나타내는 코드가 포함됩니다. 배포에 대해 필드 수준 암호화가 구성되지 않은 경우 이 필드의 값은 하이픈( `-` )입니다.

            CloudFront가 요청 본문을 성공적으로 처리하고 지정된 필드의 값을 암호화하고 요청을 오리진으로 전달할 때 이 필드의 값은 `Processed` 입니다. 이 경우 `x_edge_result_type` 값은 여전히 클라이언트 측 또는 서버 측 오류를 나타낼 수 있습니다.

            요청이 필드 수준 암호화 제한을 초과하는 경우 `fle-status` 에는 다음 오류 코드 중 하나가 포함되고 CloudFront는 최종 사용자에게 HTTP 상태 코드 `400` 를 반환합니다.
          </td>
        </tr>

        <tr>
          <td>
            `fle-encrypted-fields`
          </td>

          <td>
            CloudFront에서 암호화하여 오리진으로 전달한 필드의 수입니다. CloudFront는 데이터를 암호화할 때 처리된 요청을 오리진으로 스트리밍하므로 `fle_status` 값이 오류인 경우에도 `fle_encrypted_fields` 에 값이 있을 수 있습니다.

            배포에 대해 필드 수준 암호화가 구성되지 않은 경우 `fle_encrypted_fields` 값은 하이픈( `-` )입니다.
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            뷰어의 요청 포트 번호입니다.
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            서버에서 측정된 요청 수신과 응답의 첫 번째 바이트 쓰기 사이의 시간(초)입니다.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            `x_edge_result_type` <DNT>**is not**</DNT> `Error` 일 때 이 필드에는 `x_edge_result_type` 과 동일한 값이 포함됩니다. `x_edge_result_type` <DNT>**is**</DNT> `Error` 일 때 이 필드에는 특정 유형의 오류가 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            응답의 HTTP Content-Type 헤더 값입니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            응답의 HTTP Content-Length 헤더 값입니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc_range_start`
          </td>

          <td>
            응답에 HTTP Content-Range 헤더가 포함된 경우 이 필드에는 범위 시작 값이 포함됩니다.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            응답에 HTTP Content-Range 헤더가 포함된 경우 이 필드에는 범위 종료 값이 포함됩니다.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="haproxy" title="HAProxy">
    <DNT>**Source:**</DNT> `logtype = 'haproxy_http'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{HOSTPORT:client} \\[%{NOTSPACE:haproxy_timestamp}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{NUMBER:time_queue}/%{NUMBER:time_backend_connect}/%{NUMBER:time_duration} %{NUMBER:bytes_read} %{NOTSPACE:termination_state} %{NUMBER:actconn}/%{NUMBER:feconn}/%{NUMBER:beconn}/%{NUMBER:srvconn}/%{NUMBER:retries} %{NUMBER:srv_queue}/%{NUMBER:backend_queue}
    ```

    ```
    %{HOSTPORT:client} \\[%{NOTSPACE:haproxy_timestamp}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{NUMBER:time_client_req}/%{NUMBER:time_queue}/%{NUMBER:time_backend_connect}/%{NUMBER:time_server_response}/%{NUMBER:time_duration} %{NUMBER:status_code} %{NUMBER:bytes_read} %{NOTSPACE:captured_request_cookie} %{NOTSPACE:captured_response_cookie} %{NOTSPACE:termination_state_with_cookie_status} %{NUMBER:actconn}/%{NUMBER:feconn}/%{NUMBER:beconn}/%{NUMBER:srvconn}/%{NUMBER:retries} %{NUMBER:srv_queue}/%{NUMBER:backend_queue}?( \\\"%{GREEDYDATA:full_http_request}\\\")?( %{NOTSPACE:captured_response_headers})?
    ```

    <DNT>
      **Results:**
    </DNT>

    * `client`: 이 요청의 소스 IP/포트
    * `haproxy_timestamp`: 이 요청이 수락된 타임스탬프
    * `frontend_name`: 이 요청에 사용된 프런트엔드의 이름
    * `backend_name`: 이 요청에 사용된 백엔드의 이름
    * `server_name`: 이 요청에 사용된 백엔드 그룹의 서버 이름
    * `time_client_req`: 클라이언트의 전체 요청을 기다리는 시간(ms)
    * `time_queue`: 대기열에서 대기하는 시간(ms)
    * `time_backend_connect`: 목적지 서버에 접속하는데 걸리는 시간(ms)
    * `time_server_response`: 목적지 서버가 응답을 보내는 시간(ms)
    * `time_duration`: HAProxy에서 활성화된 총 요청 시간(ms)
    * `status_code`: HTTP 응답 코드
    * `bytes_read`: 이 요청에서 읽은 총 바이트
    * `captured_request_cookie`: 요청에서 캡처한 쿠키
    * `captured_response_cookie`: 응답에서 캡처한 쿠키
    * `termination_state`: 연결 해제 시 세션 상태
    * `termination_state_with_cookie_status`: 연결 해제 시 쿠키 상태를 포함한 세션 상태
    * `actconn`: 활성 연결
    * `feconn`: 프런트엔드 연결
    * `beconn`: 백엔드 연결
    * `srvconn`: 서버 연결
    * `retries`: 재시도
    * `srv_queue`: 서버 큐 크기
    * `backend_queue`: 백엔드 대기열 크기
    * `full_http_request`: 완전한 HTTP 요청 라인
    * `captured_response_headers`: 응답에서 캡처된 헤더
  </Collapser>

  <Collapser id="ktranslate-health" title="K번역 건강">
    <DNT>**Source:**</DNT> `logtype = 'ktranslate-health'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{NOTSPACE:timestamp} ktranslate(/)?(%{GREEDYDATA:container_service})? \[%{NOTSPACE:severity}] %{GREEDYDATA:message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `timestamp`: 로그의 시간
    * `container_service`: ktranslate에서 컨테이너를 구별하는 데 사용되는 고유 식별자입니다. 선택적 `--service_name` 플래그를 사용하여 Docker 런타임 중에 설정됩니다.
    * `severity`: 로그 라인의 심각도
    * `message`: 메시지 필드에는 이벤트에 대한 정보를 제공하는 자유 형식 메시지가 포함됩니다.
  </Collapser>

  <Collapser id="linux_cron" title="리눅스 크론(/var/log/cron)">
    <DNT>**Source:**</DNT> `logtype = 'linux_cron'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{SYSLOGTIMESTAMP:linux_cron.timestamp} %{NOTSPACE:linux_cron.hostname} %{DATA:linux_cron.process}(\[%{NUMBER:linux_cron.pid:integer}\])?: (\(%{DATA:linux_cron.user}\))?%{GREEDYDATA:linux_cron.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `linux_cron.timestamp`: 로그의 시간
    * `linux_cron.hostname`: Linux 서버 호스트 이름
    * `linux_cron.process`: 리눅스 cron 프로세스 이름
    * `linux_cron.pid`: Linux cron PID(프로세스 식별자)
    * `linux_cron.user`: cron을 실행한 리눅스 사용자
    * `linux_cron.message`: 로그 메시지
  </Collapser>

  <Collapser id="linux_messages" title="Linux 메시지(/var/log/messages)">
    <DNT>**Source:**</DNT> `logtype = 'linux_messages'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{SYSLOGTIMESTAMP:linux_messages.timestamp} %{NOTSPACE:linux_messages.hostname} %{DATA:linux_messages.process}(\[%{NUMBER:linux_messages.pid:integer}\])?: %{GREEDYDATA:linux_messages.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `linux_messages.timestamp`: 로그의 시간
    * `linux_messages.hostname`: Linux 서버 호스트 이름
    * `linux_messages.process`: 리눅스 프로세스 이름
    * `linux_messages.pid`: Linux PID(프로세스 식별자)
    * `linux_messages.message`: 로그 메시지
  </Collapser>

  <Collapser id="iis" title="마이크로소프트 IIS">
    <DNT>**Source:**</DNT> `logtype = 'iis_w3c'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken}
    ```

    <DNT>
      **Results:**
    </DNT>

    IIS는 여러 [구성 옵션](https://docs.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms524877\(v=vs.90\)) 을 허용합니다. 기본값 이외의 옵션을 구성한 경우 Grok 패턴은 로그를 구문 분석하지 않습니다. 이 경우 [사용자 정의 구문 분석](/docs/logs/ui-data/parsing/#custom-parsing) 을 사용하는 것이 좋습니다.
  </Collapser>

  <Collapser id="mongodb" title="몽고디브">
    <DNT>**Source:**</DNT> `logtype = 'mongodb'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{TIMESTAMP_ISO8601:mongodb.timestamp} %{WORD:mongodb.severity} %{WORD:mongodb.component} *\[%{WORD:mongodb.context}\] %{GREEDYDATA:mongodb.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `mongodb.timestamp`: 로그 문의 타임스탬프
    * `mongodb.severity`: 로그 문의 심각도 수준(F=치명적, E=오류, W=경고, I=정보, D1-5=디버그)
    * `mongodb.component`: 로그문을 발행하는 쓰레드의 카테고리
    * `mongodb.context`: 로그문을 발행하는 쓰레드의 이름
    * `mongodb.message`: 원시 mongodb 메시지
  </Collapser>

  <Collapser id="monit" title="모니터">
    <DNT>**Source:**</DNT> `logtype = 'monit'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    \\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `state`: 로그 라인의 심각도
    * `message`: 메시지
  </Collapser>

  <Collapser id="mysql-error" title="MySQL 오류">
    <DNT>**Source:**</DNT> `logtype = 'mysql-error'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    \\[%{WORD:log_level}\\]
    ```

    <DNT>
      **Results:**
    </DNT>

    * `log_level`: 로그 라인의 심각도
  </Collapser>

  <Collapser id="nginx" title="NGINX">
    <DNT>**Source:**</DNT> `logtype = 'nginx'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `clientip`: 클라이언트의 IP 주소
    * `verb`: HTTP 동사
    * `ident`: 요청하는 클라이언트의 사용자 ID
    * `response`: 응답의 HTTP 상태 코드
    * `request`: URI 및 요청 중인
    * `httpversion`: 요청의 HTTP 버전
    * `rawrequest`: 데이터가 게시된 경우 원시 HTTP 요청
    * `bytes`: 보낸 바이트 수
    * `referrer`: HTTP 리퍼러
    * `agent`: 클라이언트의 사용자 에이전트
  </Collapser>

  <Collapser id="nginx-error" title="NGINX 오류">
    <DNT>**Source:**</DNT> `logtype = 'nginx-error'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \[%{WORD:severity}\] %{POSINT:pid}#%{NUMBER}: \*%{NUMBER} %{GREEDYDATA:errormessage} client: %{IPORHOST:client}, server: %{NOTSPACE:server}, request: (\\)?"%{DATA:request}", (?:, upstream: \"%{URI:upstream}\")?host: (\\)?"%{NOTSPACE:host}(\\)?"(, referrer: (\\)?"%{URI:referrer}(\\)?")?
    ```

    <DNT>
      **Results:**
    </DNT>

    * `severity`: 로그 라인의 심각도
    * `pid`: 서버 프로세스 ID
    * `errormessage`: 오류 메시지
    * `clientip`: 호출 클라이언트의 IP 주소
    * `server`: 서버 IP 주소
    * `request`: 전체 요청
    * `upstream`: 업스트림 URI
    * `host`: 서버의 호스트 이름
    * `referrer`: HTTP 리퍼러
  </Collapser>

  <Collapser id="postgresql" title="PostgreSQL">
    원천: `logtype = 'postgresql'`

    그록:

    ```grok
    %{DATA:postgresql.timestamp} \[%{NUMBER:postgresql.pid}\] %{WORD:level}:\s+%{GREEDYDATA:postgresql.message}
    ```

    ### 결과

    * `postgresql.timestamp`: 로그의 타임스탬프
    * `postgresql.pid`: 서버 프로세스 ID
    * `level`: 메시지의 로그 레벨
    * `postgresql.message`: 로그 메시지
  </Collapser>

  <Collapser id="rabbitmq" title="래빗엠큐">
    <DNT>**Source:**</DNT> `logtype = 'rabbitmq'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{TIMESTAMP_ISO8601:rabbitmq.timestamp} \[%{LOGLEVEL:level}\] \<%{DATA:rabbitmq.pid}\> %{GREEDYDATA:rabbitmq.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `rabbitmq.timestamp`: 로그의 타임스탬프
    * `level`: 메시지의 로그 수준(디버그, 정보, 경고, 오류, 위험, 없음)
    * `rabbitmq.pid`: 로그 라인의 프로세스 ID
    * `rabbitmq.message`: rabbitmq 오류 메시지
  </Collapser>

  <Collapser id="redis" title="Redis">
    <DNT>**Source:**</DNT> `logtype = 'redis'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{POSINT:redis.pid}:%{NOTSPACE:redis.role} (?<redistimestamp>[\d-]+ [a-zA-Z]+ [\d]+ [\d:]+.[\d]{3}) %{NOTSPACE:level} %{GREEDYDATA:redis.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `redis.pid`: 로그 라인의 프로세스 ID
    * `redis.role`: 인스턴스 역할(X 센티넬, C RDB/AOF 쓰기 자식, S 슬레이브, M 마스터)
    * `redistimestamp`: 로그의 타임스탬프
    * `level`: 메시지의 로그 수준(. debug, - verbose, \* 주의, # warning)
    * `redis.message`: redis 오류 메시지
  </Collapser>

  <Collapser id="route53" title="53번 국도">
    <DNT>**Source:**</DNT> `logtype = 'route-53'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `log_format_version`: 로그의 버전이 지정된 형식입니다.
    * `zone_id`: 이 로그의 모든 DNS 쿼리와 연결된 호스팅 영역의 ID입니다.
    * `query`: 요청에 지정된 도메인 또는 하위 도메인입니다.
    * `query_type`: 요청에 지정된 DNS 레코드 유형 또는 `ANY`
    * `response_code`: Route 53이 DNS 쿼리에 대한 응답으로 반환한 DNS 응답 코드입니다.
    * `protocol`: 쿼리를 제출하는 데 사용된 프로토콜(TCP 또는 UDP)입니다.
    * `edge_location`: 쿼리에 응답한 Route 53 엣지 로케이션입니다. 각 에지 위치는 3자리 코드와 임의의 숫자로 식별됩니다. 예: `DFW3` . 3자리 코드는 일반적으로 엣지 로케이션 근처 공항의 국제항공운송협회(International Air Transport Association) 공항 코드와 일치합니다. (이 약어는 향후 변경될 수 있습니다.)
    * `resolver_ip`: Route 53에 요청을 제출한 DNS 해석기의 IP 주소입니다.
    * `edns_client_subnet`: DNS 해석기에서 사용 가능한 경우 요청이 시작된 클라이언트의 부분 IP 주소입니다.
  </Collapser>

  <Collapser id="syslog-rfc5424" title="시스템 로그 RFC-5424">
    <DNT>**Source:**</DNT> `logtype = 'syslog-rfc5424'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\-|%{NOTSPACE:app.name}) +(?:\\-|%{NOTSPACE:procid}) (?:\\-|%{NOTSPACE:msgid}) +(?:\[%{DATA:structured.data}\]|-|) +%{GREEDYDATA:message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `pri`: 우선 순위는 메시지 기능과 심각도를 모두 나타냅니다.
    * `version`: Syslog 프로토콜 버전.
    * `log.timestamp`: 원본 타임스탬프.
    * `hostname`: 원래 Syslog 메시지를 보낸 시스템입니다.
    * `app.name`: 메시지를 보낸 장치 또는 응용 프로그램입니다.
    * `procid`: Syslog 시스템과 연결된 프로세스 이름 또는 프로세스 ID입니다.
    * `msgid`: 메시지 유형을 식별합니다.
    * `structured.data`: 구조화된 데이터 문자열 값입니다.
    * `sd.sd-id.sd-param-name`참고: `structured.data` 콘텐츠는 사전 정의된 명명 규칙 `sd.sd-id.sd-param-name` 에 따라 별도의 속성으로도 구문 분석됩니다. 다음에 나오는 구조화된 데이터 구문 분석 예제를 참조하세요.
    * `message`: 이벤트에 대한 정보를 제공하는 자유 형식 메시지입니다.

    <DNT>
      **Structured data parsing examples:**
    </DNT>

    구조화된 데이터 `[example one="1" two="2"]` 은(는) 두 가지 다른 속성으로 구문 분석됩니다.

    ```
    sd.example.one: "1"
    sd.example.two: "2"
    ```

    동일한 구조화된 데이터 블록에 중복 매개변수 이름이 포함된 경우 속성 이름에 인덱스 기반 접미사도 추가합니다. 예를 들어 구조화된 데이터 `[example number="1" number="2"]` 는 다음과 같이 구문 분석됩니다.

    ```
    sd.example.number.0: "1"
    sd.example.number.1: "2"
    ```

    기업 번호가 할당된 구조화된 데이터의 경우 추가 속성도 구문 분석됩니다. 예를 들어 구조화된 데이터 `[example@123 number="1"]` 는 다음과 같이 구문 분석됩니다.

    ```
    sd.example.enterprise.number: 123
    sd.example.number: "1"
    ```
  </Collapser>
</CollapserGroup>