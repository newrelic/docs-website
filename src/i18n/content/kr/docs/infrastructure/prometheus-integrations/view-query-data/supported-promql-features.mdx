---
title: 지원되는 PromQL 기능
tags:
  - Integrations
  - Prometheus integrations
  - View and query data
metaDescription: Read about how support Promethus and PromQL features.
translationType: machine
---

New Relic은 PromQL 스타일 쿼리를 지원하고 쿼리 빌더는 PromQL 구문 쿼리를 가장 가까운 NRQL 근사값으로 변환하는 PromQL 스타일 쿼리 모드를 제공합니다. 근사 방법은 소수의 엣지 케이스가 완전히 지원되지 않는다는 것을 의미하지만 압도적인 대다수의 쿼리에 대한 적용 범위를 제공하여 780만 개의 상위 Grafana 대시보드 다운로드에서 쿼리의 99.5% 이상을 지원합니다.

PromQL 쿼리로 작업하는 방법과 표준 PromQL과 PromQL과 유사한 쿼리 언어 간의 차이점에 대해 알아보려면 계속 읽으십시오.

<Callout variant="important">
  Prometheus 쿼리 및 연산자에 대한 일반 정보는 [Prometheus.io](https://prometheus.io/docs/prometheus/latest/querying/operators/) 문서를 참조하세요.
</Callout>

## 지원되는 기능 [#features]

다음 집계, 산술, 수학 및 비율 유사 함수를 지원합니다. Prometheus 및 PromQL에 대한 지원을 계속 확장함에 따라 이 목록이 업데이트됩니다.

<CollapserGroup>
  <Collapser
    id=""
    title="집계 연산자 및 함수"
  >
    * 집계 연산자:

      * [`avg()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`count()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`min()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`max()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`quantile()`](https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`stddev()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * `stdvar()`
      * [`sum()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`topk()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)

      집계 기능:

      * `histogram_quantile()`

    * `<aggregation>_over_time()` 기능:

      * [`avg_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`count_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`min_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`max_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`quantile_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`stdev_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`stvar_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`sum_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
  </Collapser>

  <Collapser
    id=""
    title="산술 이항 연산자"
  >
    * [`+` (덧셈)](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`-` (빼기)](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`*` (곱셈)](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`/` (분할)](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`%` (퍼센트)](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`^` (제곱/지수)](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
  </Collapser>

  <Collapser title="논리 연산자">
    * [`and`](https://prometheus.io/docs/prometheus/latest/querying/operators/#logical-set-binary-operators)
    * [`or`](https://prometheus.io/docs/prometheus/latest/querying/operators/#logical-set-binary-operators)
  </Collapser>

  <Collapser
    id=""
    title="날짜/시간 함수"
  >
    * `day_of_month()`
    * `day_of_week()`
    * [`days_in_month()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#days_in_month)
    * `hour()`
    * `minute()`
    * `month()`
    * `time()`
    * `timestamp()`
    * `year()`
  </Collapser>

  <Collapser
    id=""
    title="수학 함수"
  >
    * [`abs()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#abs)
    * [`ceil()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#ceil)
    * [`clamp_max()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#clamp_max)
    * [`clamp_min()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#clamp_min)
    * [`exp()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#exp)
    * [`floor()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#floor)
    * [`ln()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#ln)
    * [`log10()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#log10)
    * [`log2()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#log2)
    * [`round()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#round)
    * [`sqrt()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#sqrt)
  </Collapser>

  <Collapser
    id=""
    title="비율과 같은 기능"
  >
    * [`delta()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#delta)
    * [`deriv()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#deriv)
    * [`idelta()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#idelta)
    * [`increase()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#increase)
    * [`irate()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#irate)
    * [`rate()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#rate)
  </Collapser>

  <Collapser title="예측 기능">
    * `predict_linear`
  </Collapser>

  <Collapser
    id=""
    title="시계열 선택기"
  >
    다음을 포함하여 PromQL 시계열 선택기를 지원합니다.

    * [인스턴트 벡터 선택기](https://prometheus.io/docs/prometheus/latest/querying/basics/#instant-vector-selectors)

    * [범위 시리즈 선택기](https://prometheus.io/docs/prometheus/latest/querying/basics/#range-vector-selectors)

    * [`offset` 수정자](https://prometheus.io/docs/prometheus/latest/querying/basics/#offset-modifier)

      <Callout variant="important">
        쿼리의 모든 벡터에 동일한 오프셋 값이 있는 경우에만 `offset` 쿼리를 지원합니다.
      </Callout>
  </Collapser>
</CollapserGroup>

## PromQL 문제 해결 [#troubleshooting]

이 섹션에서는 PromQL과 PromQL 스타일 쿼리 동작 간의 동작 차이점과 이러한 차이점을 해결하는 방법에 대해 설명합니다. 이는 쿼리 빌더에서 고급 쿼리와 [PromQL 스타일 모드](/docs/query-your-data/explore-query-data/chart-builder/use-advanced-promql-mode-specify-data) 를 사용하려는 경우 특히 관련이 있습니다.

### 측정항목 유형

Prometheus 권장 사항에 따르면 게이지에서는 delta()와 같은 일부 함수만 사용해야 하고 카운터에서는 rate() 및 growth()와 같은 다른 함수만 사용해야 하지만 Prometheus의 쿼리는 그렇지 않더라도 대부분의 시간 동안 계속 작동합니다. 그 지시를 따르십시오.

그러나 NRDB는 PromQL 스타일 누적 카운터를 `delta` 카운터로 변환하기 때문에 잘못된 데이터 유형에서 이러한 함수를 사용할 때 우리의 구현은 용서할 수 없으며 다르거나 잘못된 답변을 생성합니다.

이러한 이유로 Prometheus에서 이러한 권장 사항을 따르지 않더라도 PromQL 스타일 쿼리로 작업할 때 모든 Prometheus 권장 사항을 따르는 것이 가장 좋습니다.

### 제한

* 모든 사용자를 위한 시스템의 안정성과 성능을 보장하기 위해 실행할 수 있는 쿼리에 몇 가지 제한을 둡니다. 모든 경우에 범위 쿼리에서 366단계 제한을 적용합니다. 또한 기본적으로 쿼리에서 100개의 시계열만 반환하도록 기본 설정되어 있습니다.
* 더 많이(또는 더 적게) 보려면 쿼리에 `topk()` 를 명시적으로 추가해야 합니다. (PromQL 스타일 쿼리의 `topk()` 구현은 Prometheus의 구현과 다릅니다.)
* 쿼리가 사용할 수 있는 총 메모리를 제한합니다. 즉, 많은 수의 시간 단계 또는 많은 수의 시계열에 대한 요청이 거부될 수 있음을 의미합니다. 특히 단순 산술 집계보다 계산에 훨씬 더 많은 메모리가 필요한 고유한 `count` 또는 `quantile` 와 같은 집계와 결합된 경우에 그렇습니다.

### 범위 벡터 선택기(슬라이딩 창 및 스무딩 동작) [#range-vector]

슬라이딩 윈도우 시계열 집계를 지원합니다. 자세한 내용은 [NRQL 구문, 절, 함수 리소스](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions#slide-by) 및 [슬라이딩 창 심층](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows) 분석을 참조하세요.

NRQL과 PromQL 스타일 언어 간의 번역에 대한 자세한 내용은 [PromQL 쿼리를 NRQL로 번역](/docs/integrations/prometheus-integrations/view-query-data/translate-promql-queries-nrql) 을 참조하세요.

### 쿼리 범위 및 데이터 스크래핑 간격 [#query-range]

* PromQL의 쿼리 범위는 " `TIMESERIES` 버킷 크기가 현재 기간보다 큼" 오류를 피하기 위해 쿼리의 단계 크기 기간보다 커야 합니다.
* 인스턴트 쿼리를 처리할 때 최대 1분의 데이터를 검사합니다. 스크래핑 간격이 1분보다 크면 일부 쿼리로 인해 **데이터를 찾을 수 없습니다** . 최소 1분에 한 번 데이터를 전송하여 이를 피하십시오.
* NRQL 쿼리의 시계열 단위가 애플리케이션의 스크래핑 간격보다 짧은 경우 일부 기간에 데이터가 부족하고 결과 그래프가 들쭉날쭉하거나 최고점과 최저점을 포함할 수 있습니다. 일반적으로 스크래핑 간격 이상으로 단계 크기를 설정합니다.