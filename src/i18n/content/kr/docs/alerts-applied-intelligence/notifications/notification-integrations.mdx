---
title: 경고 및 적용된 인텔리전스 알림 통합
tags:
  - Alerts and applied intelligence
  - Applied intelligence
  - Incident intelligence
  - Destinations
metaDescription: Alerts and applied intelligence notification integrations are specific services and platforms you can use to send notifications from New Relic.
freshnessValidatedDate: never
translationType: machine
---

import accountsJiraDestination from 'images/accounts_screenshot-crop_jira-destination.webp'

import accountsJiraTemplate from 'images/accounts_screenshot-crop_jira-template.webp'

import accountsBridgeEventPattern from 'images/accounts_screenshot-crop_bridge-event-pattern.webp'

import accountsServiceNowDestination from 'images/accounts_screenshot-crop_service-now-destination.webp'

import accountsServiceNowCreateDestination from 'images/accounts_screenshot-crop_servicenow-create-destination.webp'

import accountsServiceNowMessageTemplate from 'images/accounts_screenshot-crop_service-now-message-template.webp'

import accountsWebhookServiceNowFields from 'images/accounts_screenshot-crop_webhook-serviceNowFields.webp'

import accountsSlackDestinationAuthentication from 'images/accounts_screenshot-crop_slack-destination-authentication.webp'

import accountsSlackSignIn from 'images/accounts_screenshot-crop_slack-sign-in.webp'

import accountsSlackDestinationAllowAccess from 'images/accounts_screenshot-crop_slack-destination-allow-access.webp'

import accountsSlackAuthenticationCompleted from 'images/accounts_screenshot-crop_slack-authentication-completed.webp'

import accountsSlackMessageTemplate from 'images/accounts_screenshot-crop_slack-message-template.webp'

import accountsSlackChannelTestNotification from 'images/accounts_screenshot-crop_slack-channel-test-notification.webp'

import accountsWebhookDestination from 'images/accounts_screenshot-crop_webhook-destination.webp'

import accountsWebhookPreviewError from 'images/accounts_screenshot-crop_webhook-preview-error.webp'

import accountsWebhookNotificationTemplate from 'images/accounts_screenshot-crop_webhook-notification-template.webp'

import accountsEmailConfWorkflow from 'images/accounts_screenshot-crop_email-configure-workflow.webp'

import accountsEmailSettings from 'images/accounts_screenshot-crop_email-settings.webp'

import accountsAWSEventBridgeDestination from 'images/accounts_screenshot-crop_awseventbridge-destination.webp'

import accountsPagerDutyAccountDestinationNewUi from 'images/accounts_screenshot-crop_pager-duty-account-destination-new-ui.webp'

import accountsPagerDutyAddNewWorkflow from 'images/accounts_screenshot-crop_pager-duty-add-webhook.webp'

import accountsPagerDutyAddNewRelicIntegration from 'images/accounts_screenshot-crop_pager-duty-add-new-relic-integration.webp'

import accountsPagerDutyIntegrationOpened from 'images/accounts_screenshot-crop_pager-duty-integration-opened.webp'

import accountsPagerDutyServiceDestination from 'images/accounts_screenshot-crop_pager-duty-service-destination.webp'

import accountsMigrateSlackNewWorkflow from 'images/accounts_screenshot-crop_slack-new-workflow.webp'

import accountsMigrateSlackRemoveLegacy from 'images/accounts_screenshot-crop_slack-remove-legacy.webp'

경고 및 적용된 인텔리전스 알림 통합을 통해 특정 서비스 및 플랫폼을 New Relic 플랫폼에 연결할 수 있습니다. 이러한 연결을 사용하여 New Relic에서 알림을 보낼 수 있습니다. 이러한 알림을 통해 검토가 필요한 문제에 대한 정보를 얻거나 감지된 문제에 대한 결정을 내리는 데 도움이 됩니다.

## 통합 세부정보 [#detail]

각각의 특정 알림 통합에 대해 자세히 알아보세요.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="jira"
    title="아틀라시안 지라"
  >
    New Relic을 Atlassian Jira(Cloud)와 통합하고 Jira 이슈를 자동으로 생성, 업데이트 및 종료합니다.

    <Video
      type="wistia"
      id="vp5rigddko"
    />

    ### 권한 [#jira-permissions]

    <Callout variant="important">
      이 통합은 JIRA 온프레미스 또는 데이터 센터 설치를 지원하지 않습니다.
    </Callout>

    Jira `API-Token` 에서 필요한 권한은 `BROWSE_PROJECTS`, `ASSIGN_ISSUES`, `CLOSE_ISSUES`, `CREATE_ISSUES`, `EDIT_ISSUES`, `RESOLVE_ISSUES`, `TRANSITION_ISSUES`, `USER_PICKER`및 `ADD_COMMENTS`입니다.

    양방향 동기화 토글을 활성화하려면 제공된 Jira `API-Key` 에 `Admin` 역할이 있어야 합니다.

    ### Jira 대상 설정 [#set-up-jira]

    Jira 이슈를 만든 다음 Jira와 New Relic을 활성화하여 업데이트를 공유하고 동기화 상태를 유지하세요.

    Jira 대상을 만들려면 다음 단계를 따르세요.

    1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI** 로 이동하고 **Destinations** \[대상을] 클릭한 다음 **Jira를** 선택합니다.

    2. 다음 정보를 입력하십시오.

       * **이름:** 대상을 식별하기 위한 사용자 지정 이름입니다.
       * **URL:** 대상의 URL입니다.
       * **사용자 이름:** 사용자의 이메일 주소입니다.
       * **API 토큰:** Atlassian 계정에서 생성됩니다.

    대상을 저장하기 전에 **Test connection** \[연결 테스트] 버튼을 클릭하여 연결을 확인하는 것이 좋습니다.

    <img
      width="80%;"
      title="Jira destination configuration."
      alt="A screenshot of a Jira destination configuration."
      src={accountsJiraDestination}
    />

    ### 양방향 동기화 [#jira-two-way]

    양방향 동기화는 워크플로에 적용할 수 있습니다. 활성화하려면 양방향 통합 토글을 켭니다.

    설정하면 Jira 계정에 [Jira Webhook이](https://developer.atlassian.com/server/jira/platform/webhooks/) 생성됩니다. 웹후크에는 New Relic에 대한 액세스 세부 정보(URL 및 API 키)가 포함되어 있습니다.

    ### New Relic 워크플로와 동기화 [#two-way-sync-workflows]

    * Jira 문제 상태가 `done` 으로 변경되면 New Relic 문제 종료가 트리거됩니다.
    * Jira 문제 상태가 `in-progress` 으로 변경되면 New Relic 문제 확인이 트리거됩니다.

    ### Workflows에서 메시지 템플릿 구성 [#configure-jira-message-template]

    Jira 문제에 대한 템플릿을 구성하려면 다음 단계를 따르세요.

    1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+ Add a new workflow** \[+ 새 워크플로 추가]버튼을 클릭합니다.
    2. 기존 대상을 선택하거나 새 대상을 만듭니다.
    3. 대상에 연결한 후 프로젝트를 선택한 다음 사용할 Jira 이슈 유형을 선택하세요.
    4. 이슈 유형을 선택하면 구성된 프로젝트의 필드가 Jira 인스턴스에 자동으로 매핑됩니다.

    시작하는 데 도움이 되도록 필수 및 권장 필드와 값이 자동으로 채워집니다. 계속하기 전에 모든 필수 필드에 값을 포함했는지 확인하세요.

    ### 테스트 알림 보내기 [#send-jira-test]

    Jira 문제를 보려면 기본 필드 값이 포함된 테스트 알림을 클릭하세요. 성공하면 Jira에서 사건을 볼 수 있는 링크가 제공됩니다.

    <img
      width="80%;"
      title="The Jira-specific custom variables menu."
      alt="A screenshot of the Jira-specific custom variables menu."
      src={accountsJiraTemplate}
    />

    <figcaption>
      Jira 알림 메시지 템플릿.
    </figcaption>
  </Collapser>

  <Collapser
    className="freq-link"
    id="eventBridge"
    title="AWS 이벤트브리지"
  >
    New Relic 및 [AWS EventBridge를](https://aws.amazon.com/eventbridge/) 사용하여 AWS Lambda, Amazon Simple 알림 서비스(SNS) 대기열, CloudWatch 로그 등과 같은 대상에 알림을 사용자 지정하고 전달합니다.

    <Video
      type="wistia"
      id="24mucmd1mj"
    />

    ### EventBridge 대상 설정 [#set-up-eventbridge]

    <Callout variant="important">
      New Relic은 AWS에 [SaaS 파트너 이벤트 소스](https://aws.amazon.com/eventbridge/integrations/) 로 나열됩니다.
    </Callout>

    AWS EventBridge 대상을 생성하려면 다음 단계를 따르십시오.

    1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI** 로 이동하고 **Destinations** \[대상을] 클릭한 다음 **AWS EventBridge**를 선택합니다.

    2. 다음 정보를 입력하십시오.

       * **이름:** 대상을 식별하기 위한 사용자 지정 이름입니다.
       * **AWS 지역:** AWS 지역 엔드포인트입니다. 이벤트 소스가 호스팅되는 지역을 선택하십시오.
       * **AWS 계정 ID:** AWS 계정 ID입니다. 이것은 12자리 숫자입니다.

       <img
         width="80%;"
         title="AWS EventBridge destination"
         alt="AWS EventBridge destination"
         src={accountsAWSEventBridgeDestination}
       />

    ### 이벤트 소스 선택 [#eventbridge-source]

    AWS 계정 ID로 EventBridge 대상을 구성한 후 새 이벤트 소스를 생성하면 EventBridge에서 사용할 수 있습니다.

    1. 대상 이름을 선택하거나 만듭니다.

    2. 이벤트 소스를 선택하거나 생성합니다.

       새 이벤트 소스를 생성하면 AWS EventBridge 계정에 통합 파트너 이벤트 소스로 생성됩니다.

    ### AWS 계정의 이벤트 소스를 연결하고 규칙을 생성합니다. [#eventbridge-rule]

    이벤트 소스를 이벤트 버스와 연결하려면:

    1. AWS EventBridge 콘솔의 탐색 창에서 **Partner event sources** \[파트너 이벤트 소스를] 선택합니다.

    2. 파트너 이벤트 소스 옆에 있는 버튼을 선택한 다음 **Associate with event bus** \[이벤트 버스와 연결을] 선택합니다.

       이벤트 소스의 상태가 **Pending** 에서 **Active**로 변경되고 이벤트 버스의 이름이 이벤트 소스 이름과 일치하도록 업데이트됩니다. 이제 New Relic의 이벤트와 일치하는 규칙 생성을 시작할 수 있습니다.

    3. 이벤트 버스에 대한 규칙을 만듭니다.

       New Relic에서 보낸 알림에 반응하려면 New-Relic 이벤트를 필터링하는 이벤트 패턴으로 규칙을 만들어야 합니다.

       <img
         width="80%;"
         title="Event pattern with the newrelic partner prefix."
         alt="A screenshot of rule Event pattern."
         src={accountsBridgeEventPattern}
       />

       자세한 지침 [은 이벤트 소스 규칙을 생성하는](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-saas.html#eb-create-rule-partner-events) 방법에 대한 이 AWS 문서를 사용하십시오.

    ### 워크플로에서 메시지 이벤트 템플릿 구성 [#message-eventbridge]

    **Workflows** 로 이동하여 기존 워크플로 또는 **Add a new Workflow** \[새 워크플로 추가] 버튼을 클릭하고 EventBridge 대상을 선택합니다. New Relic에서 EventBridge로 알림을 보낼 때 메시지 템플릿을 사용하여 해당 알림을 사용자 지정할 수 있습니다.

    기본 템플릿을 사용하거나 직접 맞춤설정할 수 있습니다. **Variables** \[변수] [메뉴 에서](/docs/alerts-applied-intelligence/notifications/message-templates/#variables-menu) 변수를 선택하고 [핸들바 구문을 적용하여](/docs/alerts-applied-intelligence/notifications/message-templates/#handlebars-syntax) 이벤트를 풍부하게 만드세요.

    EventBridge API에는 JSON이 필요하며 템플릿 미리 보기에는 렌더링된 JSON이 표시됩니다. 이벤트 템플릿이 유효한 JSON을 준수하면 AWS EventBridge에 테스트 알림을 보낼 수 있습니다. 자세한 내용은 [JSON 사용 예를](/docs/alerts-applied-intelligence/notifications/message-templates/#usage-examples) 참조하세요.
  </Collapser>

  <Collapser
    className="freq-link"
    id="email"
    title="이메일"
  >
    [워크플로](/docs/alerts-applied-intelligence/applied-intelligence/incident-workflows/incident-workflows/)의 알림 채널로 **이메일을** 선택하면 이메일 대상이 자동으로 생성되므로 **대상** 메뉴에서 구성할 필요가 없습니다. 각 이메일 대상은 연결된 워크플로우에 대해 고유하며 이는 대상 피드에서 중복으로 표시될 수 있음을 의미합니다.

    이메일 알림을 보내려면:

    1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI** 로 이동합니다.

    2. 왼쪽 탐색 패널에서 **워크플로를** 선택합니다.

    3. **+ 워크플로 추가를**클릭합니다.

       <img
         width="80%;"
         title="Configure your workflow"
         alt="Configure your workflow"
         src={accountsEmailConfWorkflow}
       />

    4. 워크플로의 이름을 지정합니다. 이 필드는 필수이며 고유해야 합니다.

    5. 필요한 데이터를 필터링합니다. **기본** 및 **고급** 옵션 중에서 선택하여 보내려는 문제를 추가할 수 있습니다.

    6. **추가 설정을** 클릭하여 데이터를 보강합니다. **데이터 강화를** 활성화하여 NRQL 쿼리를 작성합니다.

    7. **저장 후 종료를**클릭합니다.

    8. 알림 방법으로 **이메일을** 선택합니다.

       <img
         width="60%;"
         title="Email settings"
         alt="A screenshot of the email settings."
         src={accountsEmailSettings}
       />

    9. 알림을 보낼 이메일을 추가합니다. 하나 이상의 수신자를 추가할 수 있습니다.

       * 이메일 주소를 검색하여 New Relic 계정이 있는 사용자를 찾을 수 있습니다.
       * New Relic 계정이나 이메일 배포 목록이 없는 사용자를 추가하려면 전체 이메일 주소를 입력하십시오.
       * 이메일 설정에 추가된 각 이메일 주소 목록은 대상 피드에 표시될 고유한 대상을 생성합니다.
       * 기존 대상과 이미 연결된 이메일 주소로 대상을 생성하면 두 항목을 병합할 수 있는 옵션을 제공하는 메시지가 나타납니다. **Merge** \[병합을] 선택하면 대상이 결합되어 알림이 의도한 수신자에게 효율적으로 전달됩니다.
       * [알림 로그](/docs/alerts-applied-intelligence/notifications/destinations/#notifications-log)에서 대상별로 이메일 알림을 따를 수 있습니다.

    10. 전자 메일 메시지를 사용자 지정합니다.

        * 이메일 제목의 경우 기본 페이로드를 사용하거나 필요한 데이터를 포함하도록 사용자 정의할 수 있습니다.
        * 이메일 본문에는 변경할 수 없는 기본 데이터가 포함되어 있지만 사용자 지정 추가 세부 정보를 추가할 수도 있습니다. 이러한 사용자 지정은 **사용자 지정 세부 정보** 섹션 아래에 나타납니다.
        * 이메일을 풍부하게 하려면 [변수 메뉴](/docs/alerts-applied-intelligence/notifications/message-templates/#variables-menu) 에서 변수를 선택하고 [핸들바 구문](/docs/alerts-applied-intelligence/notifications/message-templates/#handlebars-syntax) 을 적용하십시오.

    11. **테스트 알림 보내기를** 클릭하여 이메일 알림이 받은 편지함에 도착하는지 확인합니다.

    12. **저장** 을 클릭합니다.

    13. **워크플로 활성화 를**클릭합니다.

    워크플로 메인 페이지에서 생성된 워크플로를 클립보드에 활성화, 편집, 삭제 또는 워크플로 ID를 복사할 수 있습니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="freshservice"
    title="프레시서비스"
  >
    New Relic을 FreshService와 통합하여 FreshService 티켓을 자동으로 생성하고 해결하세요.

    ### Webhook를 사용하여 FreshService 대상 설정

    1. [one.newrelic.com](https://one.newrelic.com/) > **Alerts & AI** 로 이동하여 **Destinations** \[대상을] 클릭한 다음 **Webhook**을 선택합니다.

    2. 다음 정보를 입력하십시오.

       * 웹훅 이름: FreshService 웹훅의 참조 이름입니다.

       * 엔드포인트 URL: [https://yourdomain.freshservice.com/api/v2/tickets](https://yourdomain.freshservice.com/api/v2/tickets) (yourdomain을 FreshService 헬프데스크 이름으로 바꾸세요)

       * 인증을 활성화하고 기본 인증을 선택합니다. 사용자 이름 및 비밀번호에 다음 정보를 입력합니다.

         * **Username** \[사용자 이름]: [FreshService API 키](https://support.freshservice.com/en/support/solutions/articles/50000000306-where-do-i-find-my-api-key-)
         * **Password** \[비밀번호]: X(비밀번호는 대문자 X입니다)

    3. 목적지를 저장하세요.

    ### 워크플로를 생성하고 워크플로 변수를 사용하여 FreshService 속성을 사용자 지정하세요.

    1. [one.newrelic.com](https://one.newrelic.com/) > **Alerts & AI** 로 이동하여 **Workflows** \[워크플로를] 클릭합니다. **+ Add a new workflow** \[+ 새 워크플로 추가를] 클릭합니다.

    2. 워크플로의 이름을 입력합니다.

    3. 데이터 필터링에서 원하는 필터 기준을 생성하여 대상에 알림을 보냅니다.

    4. 알림에서 **Webhook** \[웹후크를] 선택하고 다음 정보로 알림 메시지를 사용자 지정합니다.

       * 대상 필드에서 위 단계에서 생성된 FreshService 대상을 선택합니다.

       * [Workflow 변수를](/docs/alerts-applied-intelligence/applied-intelligence/incident-workflows/custom-variables-incident-workflows/) 관련 [FreshService 매개변수](https://api.freshservice.com/#create_ticket) 로 보내도록 페이로드를 맞춤설정하세요. (샘플 페이로드 참조)

         * 워크플로 변수의 도우미 함수에 대한 자세한 내용은 [핸들바 구문을](/docs/alerts-applied-intelligence/notifications/message-templates/#handlebars-syntax) 참조하세요.
         * 사용자 정의 필드를 추가하려면 [FreshService 사용자 정의 필드를](https://support.freshservice.com/en/support/solutions/articles/154126-customizing-ticket-fields) 참조하세요.
         * 워크플로 변수 유형은 FreshService 매개변수 유형과 일치해야 합니다.

    5. “테스트 알림 보내기”를 클릭하여 알림을 테스트합니다. 새로 생성된 티켓을 보려면 FreshService 티켓으로 이동하세요.

    ### 샘플 페이로드

    ```json
    {
      "subject": {{ json annotations.title.[0] }},
      "description": "{{ issuePageUrl }}",
      "priority": 1,
      "status": {{#eq state "ACTIVATED"}}2{{else}}5{{/eq}},
      "email": "supportemail@domain.com",
      "custom_fields": {
        "nr_account_id": {{ nrAccountId }}
      }
    }

    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="mobile_push"
    title="New Relic 모바일 푸시"
  >
    New Relic iOS 또는 Android 모바일 앱에 푸시 알림을 보냅니다.

    <Video
      type="wistia"
      id="s29hxnyi4v"
    />

    ### 모바일 푸시 대상 설정 [#set-mobile_push-destination]

    모바일 푸시 대상을 생성하려면 다음이 필요합니다.

    * **푸시 대상 이름:** 고유한 대상 이름입니다.

    * **사용자 ID:** 현재 로그인한 사용자를 기준으로 자동으로 채워집니다.

      <Callout variant="important">
        현재는 [수정 기능이](/docs/alerts-applied-intelligence/notifications/destinations#requirements) 있는 현재 로그인된 사용자에 대해서만 모바일 푸시 대상을 생성할 수 있습니다. 사용자에 대해 단일 푸시 대상만 생성할 수도 있습니다. 두 개 이상 생성하려고 하면 오류가 표시됩니다. 대상을 저장하기 전에 **연결 테스트** 버튼을 사용하여 연결을 테스트하는 것이 좋습니다.
      </Callout>

    ### 워크플로에서 푸시 알림을 받을 시기 구성 [#mobile]

    **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+Add a new workflow** \[+새 워크플로 추가] 버튼을 클릭하고 모바일 알리미를 선택합니다. 모바일 푸시를 구성하려면 모바일 알리미를 클릭하고 원하는 대상을 선택합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="opsgeniewebhook_templates"
    title="옵스제니"
  >
    ### Atlassian Opsgenie용 웹후크 템플릿

    웹훅 템플릿을 사용하여 워크플로에서 Opsgenie로 알림 보내기: [워크플로용 Opsgenie 웹훅 템플릿](https://support.atlassian.com/opsgenie/docs/integrate-opsgenie-with-new-relic-alerts-new/)
  </Collapser>

  <Collapser
    className="freq-link"
    id="pagerduty"
    title="호출기 의무"
  >
    New Relic을 PagerDuty와 통합하여 PagerDuty 사고를 자동으로 생성, 업데이트, 확인 및 해결합니다.

    <Video
      type="wistia"
      id="lvzd77zj17"
    />

    PagerDuty와 통합하는 두 가지 방법을 제공합니다.

    * **[REST API 키를 사용한 계정 수준 통합(권장)](#pagerduty-ali)**: 이 완전 자동 통합은 양방향 동기화와 단일 New Relic 대상에서 여러 PagerDuty 서비스를 정의하는 기능을 지원합니다.
    * **[Service integration using Events API keys](#pagerduty-sli) \[Events API 키를 사용한 서비스 통합]**: 이 단일 서비스 통합은 서비스 수준 통합 키를 사용하며 각 고유 PagerDuty 서비스에 대해 별도의 New Relic 대상이 필요합니다.

    ### 계정 수준 통합 [#pagerduty-ali]

    이 완전 자동 통합은 양방향 동기화와 단일 New Relic 대상에서 여러 PagerDuty 서비스를 정의하는 기능을 지원합니다.

    ### 권한 [#pd-permissions]

    이 통합에는 다음 작업을 수행할 수 있는 권한이 필요합니다.

    * [서비스 나열](https://developer.pagerduty.com/api-reference/b3A6Mjc0ODE5Ng-list-services)

    * [통합 생성](https://developer.pagerduty.com/api-reference/b3A6Mjc0ODIwMw-create-a-new-integration)

    * [웹훅 구독 만들기](https://developer.pagerduty.com/api-reference/b3A6MjkyNDc4NA-create-a-webhook-subscription)

    * [메모 만들기](https://developer.pagerduty.com/api-reference/b3A6Mjc0ODE1MA-create-a-note-on-an-incident)

    * [팀 나열](https://developer.pagerduty.com/api-reference/b3A6Mjc0ODIyMw-list-teams)

    * [사용자 나열](https://developer.pagerduty.com/api-reference/b3A6Mjc0ODIzMw-list-users)

      이 통합에는 REST API 키가 필요합니다. PagerDuty에는 두 가지 유형의 REST API 키가 있습니다.

    * [일반 액세스 키](https://support.pagerduty.com/docs/generating-api-keys#section-generating-a-general-access-rest-api-key): 위에 나열된 모든 권한이 포함되어 있으며 PagerDuty 관리자 및 계정 소유자가 액세스할 수 있습니다. [PagerDuty 지침을 참조하세요](https://support.pagerduty.com/docs/api-access-keys#generate-a-general-access-rest-api-key).

    * [개인 사용자 토큰](https://support.pagerduty.com/docs/generating-api-keys#section-generating-a-personal-rest-api-key) : 계정에 고급 권한이 있는 경우 고유한 개인 REST API 키를 생성할 수 있습니다. 개인 REST API 키를 사용한 요청은 사용자 권한으로 제한됩니다. 사용자 토큰 API 키를 제공하기로 선택한 경우 위에 설명된 필수 권한이 있는지 확인하십시오. [PagerDuty 지침을 참조하십시오](https://support.pagerduty.com/docs/api-access-keys#generate-a-user-token-rest-api-key) .

      <Callout variant="tip">
        개인 사용자 토큰의 경우 실제 사용자에 속하지 않는 전용 통합 사용자를 사용하는 것이 좋습니다.
      </Callout>

    ### 목적지 설정 [#set-up-pagerduty]

    PagerDuty 대상을 만들려면 다음 안내를 따르세요.

    1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI** 로 이동하고 **Destinations** \[대상을] 클릭한 다음 **PagerDuty**를 선택합니다.

    2. 다음 정보를 입력하십시오.

       * **이름** : 목적지를 식별하기 위한 사용자 정의 이름입니다.
       * **API 키**: 이 통합의 경우 REST API 키를 제공하라는 메시지가 표시됩니다. PagerDuty에는 [일반 액세스](https://support.pagerduty.com/docs/generating-api-keys#section-generating-a-general-access-rest-api-key) 및 [사용자 토큰](https://support.pagerduty.com/docs/generating-api-keys#section-generating-a-personal-rest-api-key)의 두 가지 유형의 REST API 키가 있습니다.

       대상을 저장하기 전에 연결 **테스트** 버튼을 클릭하여 연결을 테스트하는 것이 좋습니다.

       <img
         width="80%;"
         title="PagerDuty account-level destination configuration"
         alt="A screenshot of a PagerDuty account-level destination configuration"
         src={accountsPagerDutyAccountDestinationNewUi}
       />

    ### 양방향 동기화 [#two-way-pagerduty]

    양방향 동기화를 활성화하려면 **two-way integration** \[양방향 통합] 토글을 켜세요. 활성화되면 선택한 PagerDuty 서비스에 대한 이후 단계에서 PagerDuty 구독이 생성됩니다( [메시지 템플릿 사용자 정의](#message-pagerduty) 참조). 웹훅에는 New Relic에 대한 액세스 세부정보(URL 및 New Relic API 키)가 포함되어 있습니다. 기본적으로 New Relic에서 생성된 PagerDuty 인시던트에 대한 모든 상태 변경은 New Relic에 다시 동기화됩니다.

    <Callout variant="important">
      특정 서비스에서 지능형 경고 그룹화를 사용하는 PagerDuty Event Intelligence 또는 Digital Operations 고객인 경우 New Relic으로 다시 전송된 PagerDuty 사고에 잠재적인 불일치가 발생할 수 있습니다.
    </Callout>

    ### New Relic 워크플로와 동기화 [#two-way-sync-workflows]

    * PagerDuty 인시던트가 해결되면 New Relic 문제의 종료가 트리거됩니다.

    * PagerDuty 인시던트가 확인되면 New Relic 문제에 대한 확인이 트리거됩니다.

      ### 워크플로에서 메시지 템플릿 구성 [#message-pagerduty]

      메시지 템플릿을 구성하려면:

      1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+ Add a new workflow** \[+ 새 워크플로 추가] 버튼을 클릭하고 PagerDuty 알리미를 선택합니다.
      2. 대상을 선택하거나 새 대상을 만드세요.
      3. PagerDuty 서비스를 선택합니다.
      4. 사용자를 선택합니다. New Relic은 선택된 사용자를 대신하여 메모를 게시합니다.
      5. Pagerduty의 Custom Details 섹션으로 세부 정보를 보냅니다. 기본 페이로드를 사용하거나 문제 페이로드의 자유 텍스트 또는 동적 변수를 사용하여 사용자 정의할 수 있습니다. [변수 메뉴](/docs/alerts-applied-intelligence/notifications/message-templates/#variables-menu) 에서 변수를 선택하고 [핸들바 구문을](/docs/alerts-applied-intelligence/notifications/message-templates/#handlebars-syntax) 적용하여 페이로드를 보강하십시오. 오른쪽의 **미리보기** 섹션에는 템플릿이 렌더링된 후 예상되는 페이로드가 표시됩니다. 페이로드가 유효한 JSON을 형성하지 않으면 오류가 표시되고 템플릿을 저장할 수 없습니다.

    PagerDuty 경고의 사용자 정의 세부 정보가 자동으로 채워집니다.

    ### 테스트 알림 보내기 [#test-notification-pagerduty]

    기본 필드 값이 있는 테스트 알림을 클릭하면 PagerDuty 사건이 어떻게 표시되는지 확인할 수 있습니다. 성공하면 인시던트가 생성되고 링크가 나타납니다.

    <img
      width="80%;"
      title="PagerDuty service-level workflow configuration."
      alt="A screenshot of a PagerDuty service-level workflow configuration."
      src={accountsPagerDutyAddNewWorkflow}
    />

    ### 서비스 통합 [#pagerduty-sli]

    이 통합을 위해서는 New Relic이 인시던트를 생성할 서비스에 New Relic PagerDuty 통합을 설정해야 합니다. PagerDuty 서비스에서 New Relic 통합을 생성하려면 다음을 수행하십시오.

    1. **Services > Service Directory** 로 이동하고 통합을 추가할 서비스를 선택합니다.

    2. **Integrations** \[통합] 탭을 선택하고 **Add an integration** \[통합 추가를]클릭합니다.

    3. 목록에서 New Relic 통합을 찾아 표시하고 **Add** \[추가를]클릭하십시오.

       <img
         title="PagerDuty New Relic integration."
         width="70%;"
         alt="New Relic integration."
         src={accountsPagerDutyAddNewRelicIntegration}
       />

    4. **Integration Key** \[통합 키를]보고 복사하려면 오른쪽을 클릭하십시오.

       <img
         title="PagerDuty New Relic integration key."
         alt="New Relic integration key."
         src={accountsPagerDutyIntegrationOpened}
       />

    ### 메시지 템플릿 구성 [#message-pagerduty]

    메시지 템플릿을 구성하려면:

    1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+ Add a new workflow** \[+ 새 워크플로 추가] 버튼을 클릭하고 PagerDuty 알리미를 선택합니다.
    2. 대상을 선택하거나 새 대상을 만드세요.
    3. (선택 사항) 기본 인시던트 요약을 편집합니다.

    PagerDuty 알림의 사용자 지정 세부 정보는 자동으로 채워집니다.

    ### 테스트 알림 보내기 [#test-notification-pagerduty]

    기본 필드 값이 있는 테스트 알림을 클릭하면 PagerDuty 인시던트가 어떻게 나타나는지 확인할 수 있습니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="servicenow"
    title="ServiceNow(사고 관리)"
  >
    <Callout>
      이 통합을 설치하지 않는 것이 좋습니다. 대신 New Relic 워크플로와의 새로운 인증 통합을 사용하는 것이 좋습니다. [다음 섹션](#servicenow-certified) 에서 설치 및 사용 방법을 확인하세요.
    </Callout>

    New Relic을 ServiceNow ITSM과 통합하고 ServiceNow 인시던트를 자동으로 생성, 업데이트 및 해결합니다.

    <Video
      type="wistia"
      id="6or6n8am4k"
    />

    ### 역할 [#roles-servicenow]

    통합의 일부로 ServiceNow 인시던트 테이블 및 기타 선택적 값에서 필드를 가져옵니다. 다음 권한이 필요합니다.

    * 테이블 `sys_dictionary` , `sys_choice` , `sys_user` 및 `task` 에 대한 전체 읽기 권한.

    * `incident` 에 대한 읽기/쓰기 권한.

    * `caller` 열에 대한 사용자를 가져오려면 `sys_user` 테이블에 대한 읽기 권한이 필요합니다.

      기본적으로 세분화되지 않은 역할 `personalize_choices`, `personalize_dictionary`, `rest_service` 또는 `snc_platform_rest_api_access` 및 `itil` 에는 위의 권한이 있습니다. 양방향 통합을 활성화하려면 `api_key_credentials` 테이블에 대한 읽기/쓰기 권한이 필요합니다. `credentials_admin` 및 `discovery_admin` 역할이 이를 제공합니다.

    ### 목적지 설정 [#set-up-service-destination]

    ServiceNow 대상을 생성하려면:

    1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI** 로 이동하고 **Destinations** \[대상을] 클릭한 다음 **ServiceNow**를 선택합니다.

    2. 다음 정보를 입력하십시오.

       * **목적지 이름: 목적지** 를 식별하기 위한 사용자 정의 이름.
       * **도메인:** 대상의 URL입니다.
       * **Username** \[사용자 이름]: 사용자의 이름입니다.
       * **비밀번호:** 사용자의 비밀번호입니다.

       대상을 저장하기 전에 연결 **테스트** 버튼을 클릭하여 연결을 테스트하는 것이 좋습니다.

       ### 양방향 동기화 [#two-way-snow]

       **양방향 통합을**구성하려면:

       1. `two-way integration` 토글을 켭니다.
       2. 이 [XML 파일을](https://storage.googleapis.com/newrelic-notifications/snow-two-way-sync/Newrelic-Snow-Sync-Configurations.xml)열고 다운로드하십시오. 여기에는 New Relic으로 다시 이벤트를 트리거하는 비즈니스 규칙이 포함되어 있습니다.
       3. ServiceNow 사이드바 메뉴에서 **System Definition > Business Rules** 으로 이동합니다.
       4. 열 헤더 중 하나에서 메뉴 아이콘을 클릭하고 **XML 가져오기** 를 선택한 다음 다운로드한 XML 파일을 업로드합니다.

       대상을 저장하면 New Relic API 키가 `api_key_credentials` 에 보관됩니다. 키는 New Relic에 대한 REST 콜백 호출의 일부로 헤더에 전송됩니다.

       ### 워크플로와 동기화 [#two-way-sync-snow-workflows]

       * ServiceNow 사고 상태가 해결됨으로 변경되면 New Relic 문제가 종료됩니다.
       * ServiceNow 사고 상태가 열림에서 변경되면 New Relic 문제에 대한 승인이 트리거됩니다.

    ### 워크플로에서 메시지 템플릿 구성 [#configure-servicenow-message-template]

    1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+ Add a new workflow** \[+ 새 워크플로 추가] 버튼을 클릭합니다.

    2. ServiceNow 대상을 선택합니다.

    3. 연결에 성공하면 ServiceNow 인시던트 테이블 열이 계정에서 가져와서 ServiceNow 인스턴스에 자동으로 매핑됩니다.

       시작하는 데 도움이 되도록 필수 및 권장 필드가 기본값으로 미리 채워져 있습니다. 지원되는 필드에 사용자 정의 값을 추가할 때 이슈 페이로드에서 동적 값을 추가하거나 고유한 값을 작성할 수 있습니다. 필수가 아닌 필드를 제거하고 직접 추가할 수 있습니다.

    ### 테스트 알림 보내기 [#send-servicenow-test]

    기본 필드 값으로 ServiceNow 인시던트를 보려면 **Send test notification** \[테스트 알림 보내기를] 클릭합니다. 성공하면 생성된 사건의 링크가 표시됩니다.

    <img
      width="80%;"
      title="ServiceNow incident template."
      alt="A screenshot of some recommended ServiceNow-incident fields and values."
      src={accountsServiceNowMessageTemplate}
    />

    <figcaption>
      ServiceNow-Incident 템플릿에 대한 필드를 선택, 편집 또는 제거합니다.
    </figcaption>
  </Collapser>

  <Collapser
    className="freq-link"
    id="servicenow-certified"
    title="ServiceNow(인증 애플리케이션)"
  >
    인증된 ServiceNow와 New Relic 워크플로의 통합은 ServiceNow 스토어에서 사용할 수 있습니다. ServiceNow를 사용할 때 다음 사항을 기억하세요.

    * ServiceNow 인스턴스는 New Relic 문제 알림을 `New Relic Issues` 으로 저장합니다.

    * ServiceNow에서 라우팅 정책을 구성하여 해당 문제가 특정 정책과 일치할 때 해당 문제를 나타내거나 대응하는 작업 또는 기타 레코드를 생성할 수 있습니다.

    * ServiceNow의 승인 또는 종료 이벤트는 New Relic의 문제를 승인하거나 종료할 수 있습니다.

    * ServiceNow에서 New Relic 문제를 실행 가능한 작업으로 자동 변환할 수 있습니다.

    * ServiceNow는 문제에 대해 New Relic으로부터 업데이트를 받을 수 있습니다.

    * 정책 엔진을 사용하면 New Relic 경고가 들어오는 대로 자격을 부여할 수 있습니다.

    * 엔터티를 구성 항목과 일치시키고 이를 사용 가능한 작업 테이블과 연결합니다.

    * ServiceNow에서 New Relic 강화를 이미지로 보내고 볼 수 있습니다.

      ServiceNow 애플리케이션 대상 또는 웹후크 대상을 사용하여 ServiceNow를 New Relic과 통합할 수 있습니다.

    <table>
      <thead>
        <tr>
          <th>
            New Relic 대상 유형
          </th>

          <th>
            서비스나우
          </th>

          <th>
            웹훅
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            유효 탑재량
          </td>

          <td>
            New Relic에 의해 제어됨
          </td>

          <td>
            귀하가 관리하는 JSON 페이로드
          </td>
        </tr>

        <tr>
          <td>
            ServiceNow에서 New Relic을 업데이트하는 기능
          </td>

          <td>
            포함되어 있습니다. 대상이 생성되면 New Relic 연결이 자동으로 생성됩니다.
          </td>

          <td>
            포함되어 있습니다. New Relic 연결을 수동으로 생성해야 합니다.
          </td>
        </tr>

        <tr>
          <td>
            라우팅 정책
          </td>

          <td>
            포함됨
          </td>

          <td>
            포함됨
          </td>
        </tr>

        <tr>
          <td>
            대상 필드를 직접 업데이트하는 기능
          </td>

          <td>
            예, 기본 New Relic Flow 디자이너와 함께 엔터티의 태그를 사용합니다.
          </td>

          <td>
            예, 엔터티의 태그를 사용하고 기본 New Relic Flow 디자이너와 함께 웹후크 페이로드에 지정합니다.
          </td>
        </tr>
      </tbody>
    </table>

    ### ServiceNow 애플리케이션 대상 설정 [#servicenow-destination]

    ServiceNow 대상을 생성하려면 다음 단계를 따르십시오.

    1. ServiceNow 스토어에서 New Relic 애플리케이션을[다운로드](https://store.servicenow.com/sn_appstore_store.do#!/store/application/d117597d1b9b9d9078faddf7b04bcba7/1.0.0?referer=%2Fstore%2Fsearch%3Flistingtype%3Dallintegrations%25253Bancillary_app%25253Bcertified_apps%25253Bcontent%25253Bindustry_solution%25253Boem%25253Butility%25253Btemplate%26q%3Dnew%2520relic&sl=sh) 하고 설치합니다.

    2. ServiceNow 내부에서 사용자를 생성합니다. **Web service access only** \[웹 서비스 액세스 전용] 옵션을 활성화하고 생성된 사용자에게 `x_newre_core.inbound_api` 역할을 부여했는지 확인하세요. 생성된 비밀번호를 복사하여 저장하세요.

    3. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI** 로 이동하고 **Destinations** \[대상을] 클릭한 다음 **ServiceNow**를 선택합니다.

       <img
         width="80%;"
         title="Create a ServiceNow destination"
         alt="Create a ServiceNow destination"
         src={accountsServiceNowCreateDestination}
       />

    4. **Next**클릭합니다.

    5. 도메인, 사용자 이름, 비밀번호를 추가합니다. 도메인에는 `*.service-now.com` 포함되어야 합니다. 2단계에서 복사한 비밀번호를 추가하세요.

    6. **Next**클릭합니다.

    7. 목적지의 이름을 지정하세요.

    8. **Save destination** \[목적지 저장 을] 클릭합니다.

       ### 웹훅 대상 설정 [#servicenow-webhook-destination]

       웹훅 대상을 만들려면 다음 단계를 따르세요.

    9. ServiceNow 스토어에서 New Relic 애플리케이션을[다운로드](https://store.servicenow.com/sn_appstore_store.do#!/store/application/d117597d1b9b9d9078faddf7b04bcba7/1.0.0?referer=%2Fstore%2Fsearch%3Flistingtype%3Dallintegrations%25253Bancillary_app%25253Bcertified_apps%25253Bcontent%25253Bindustry_solution%25253Boem%25253Butility%25253Btemplate%26q%3Dnew%2520relic&sl=sh) 하고 설치합니다.

    10. ServiceNow 내부에서 사용자를 생성합니다. **Web service access only** \[웹 서비스 액세스 전용] 옵션을 활성화하고 생성된 사용자에게 `x_newre_core.inbound_api` 역할을 부여했는지 확인하세요. 생성된 비밀번호를 복사하여 저장하세요.

    11. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI** 로 이동하고 **Destinations** \[대상을] 클릭한 다음 **Webhook**을 선택합니다.

    12. 다음 필드를 채우십시오.

        * **Webhook name** \[Webhook 이름]: Webhook을 식별하기 위한 이름입니다.

        * **Endpoint URL** \[끝점 URL]: 대상의 끝점 URL입니다. `*.service-now.com/api/x_newre_core/new_relic/issue/notification` 포함해야 합니다(예: `https://my_instance.service-now.com/api/x_newre_core/new_relic/issue/notification`.

        * **Use authorization** \[인증 사용]: **Basic authorization** \[기본 인증] 옵션을 활성화하고 사용자 이름과 복사된 비밀번호를 입력하여 ServiceNow를 인증합니다.

          <img
            width="80%;"
            title="Create a webhook destination"
            alt="Create a webhook destination"
            src={accountsWebhookDestination}
          />

    13. **Save destination** \[목적지 저장 을] 클릭합니다.

    아래에서 웹훅 대상을 생성하는 방법을 보여주는 짧은 비디오를 볼 수 있습니다.

    <Video
      type="wistia"
      id="0er0remkv0"
    />

    웹훅 페이로드에 `serviceNowFields` 를 추가하려면 다음 안내를 따르세요.

    1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI** 로 이동하여 **Workflows** \[워크플로를] 클릭합니다.

    2. 다음을 클릭하세요. <Icon name="fe-more-horizontal"/> 기존 Webhook의 아이콘을 클릭하고 **Edit 를** 선택하거나 **+ Add a new workflow** \[+ 새 워크플로 추가] 버튼을 클릭합니다.

    3. **Webhook** \[웹훅] 채널을 클릭하세요.

    4. 필요한 `serviceNowFields` 속성을 추가하여 기본 페이로드를 수정합니다.

       <img
         width="80%;"
         title="Adding the `serviceNowFields` attributes"
         alt="Adding the `serviceNowFields` attributes"
         src={accountsWebhookServiceNowFields}
       />

    5. **Send test notification** \[테스트 알림 보내기를] 클릭하여 변경 사항을 확인하세요.

    6. **Save message** \[메시지 저장 을] 클릭합니다.

    7. **워크플로 활성화 를**클릭합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="slack"
    title="느슨하게"
  >
    Slack 채널에 알림 메시지를 보냅니다. 자세한 내용은 [이전 Slack 웹훅 대상에서 새 Slack 앱으로 마이그레이션하는 방법을](#migrate-slack) 참조하세요.

    <Video
      type="wistia"
      id="zs92j5i31v"
    />

    ### 전제 조건 [#slack-prereqs]

    Slack 작업공간에는 [New Relic 애플리케이션](https://newrelic.slack.com/apps/AP92KQJS3-new-relic?tab=more_info)(또는 `one.eu.newrelic` 고객의 경우 [EU 앱](https://slack.com/apps/AS5D75HQQ-new-relic-eu?tab=more_info) )이 설치되어 있어야 합니다. 애플리케이션을 개별적으로 설치하려면 먼저 워크스페이스 관리자가 애플리케이션을 승인해야 합니다. 도움이 필요하면 [support@newrelic.com](mailto:support@newrelic.com) 으로 문의하세요.

    ### Slack 대상 설정 [#set-slack-destination]

    1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI** 로 이동하고 **Destinations** \[대상을] 클릭한 다음 **Slack**을 선택합니다.

    2. **Authenticate in one click** \[클릭 한 번으로 인증] 버튼을 클릭하여 Slack 랜딩 페이지로 이동하고 OAuth2 인증 프로세스를 계속합니다. 필요한 워크스페이스에 로그인하지 않은 경우 로그인을 위해 Slack으로 리디렉션됩니다.

       <img
         width="60%;"
         title="Create a Slack destination with a click."
         alt="A screenshot of the one-click Slack authentication."
         src={accountsSlackDestinationAuthentication}
       />

    3. 작업 영역 이름을 추가하거나 관련 작업 영역을 선택하고 **계속** 을 클릭합니다.

       <img
         width="50%;"
         title="add a Slack workspace."
         alt="add a workspace."
         src={accountsSlackSignIn}
       />

    4. 선택한 작업 공간에 로그인하면 New Relic이 지정된 작업을 수행하도록 허용합니다.

       <img
         width="40%;"
         title="select a workspace and configure permissions."
         alt="A screenshot permissions configurations."
         src={accountsSlackDestinationAllowAccess}
       />

    5. **허용** 을 클릭하고 대상 페이지로 돌아갑니다.

       <img
         width="80%;"
         title="authentication completed successfully."
         alt="A screenshot completed authentication."
         src={accountsSlackAuthenticationCompleted}
       />

    ### 워크플로에서 Slack 메시지 템플릿 구성 [#configure-slack-message-settings]

    1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+ Add a workflow** \[+ 워크플로 추가] 버튼을 클릭합니다.

    2. 메시지를 보낼 목적지(Workspace)와 Slack 채널을 선택하세요. 필요한 작업 공간에 대해 미리 정의된 대상이 없는 경우 새 대상을 생성할 수 있습니다. 개인 정보 보호를 위해 사용자는 비공개 채널을 선택하기 위해 한 번 인증을 받아야 합니다. 비공개 채널을 선택하면 봇이 자동으로 채널에 추가됩니다.

    3. 기본 알림을 사용하거나 사용자 정의 세부 정보로 보강할 수 있습니다. [변수 메뉴](/docs/alerts-applied-intelligence/notifications/message-templates/#variables-menu) 에서 변수를 선택하고 [핸들바 구문](/docs/alerts-applied-intelligence/notifications/message-templates/#handlebars-syntax) 을 적용하여 페이로드를 보강하십시오.

    4. 미리 정의된 예제 페이로드가 포함된 테스트 알림을 채널에 보내려면 **Send test notification** \[테스트 알림 보내기] 버튼을 클릭합니다. 이렇게 하면 선택한 Slack 채널에 메시지가 생성됩니다.

       <img
         width="80%;"
         title="Authenticate to select private channels."
         alt="Slack settings, user is not authenticated."
         src={accountsSlackMessageTemplate}
       />
  </Collapser>

  <Collapser
    className="freq-link"
    id="Splunk_on_call_templates"
    title="Splunk 대기 중(VictorOps)"
  >
    ### Splunk On-call용 Webhook 템플릿

    [Webhook 템플릿을](https://help.victorops.com/knowledge-base/new-relic-integration-guide/#about-splunk-on-call-and-new-relic)사용하여 워크플로에서 Splunk On-call로 알림 보내기
  </Collapser>

  <Collapser
    className="freq-link"
    id="webhook"
    title="웹훅"
  >
    지정된 HTTPS 엔드포인트에 알림 메시지를 보내려면 워크플로에서 웹후크 알리미를 사용해야 합니다. 기본적으로 알리미는 요청의 콘텐츠 유형이 JSON이라고 가정하고 지정된 엔드포인트에 HTTP POST 요청을 보냅니다. 구성을 시작하면 Webhook 알리미는 즉시 사용할 수 있는 기본 JSON 페이로드 구조를 제공합니다. 그러나 더 많은 사용자 정의가 필요한 경우 핸들바 템플릿 구문을 사용하여 페이로드를 수정할 수 있습니다. 이를 통해 페이로드 내의 변수를 동적으로 채워 특정 요구 사항에 맞게 조정할 수 있습니다.

    페이로드 외에도 웹후크 요청에 추가 HTTP 헤더를 포함할 수 있습니다. 이는 수신 엔드포인트에 추가 정보 또는 인증 토큰을 전달하는 데 유용할 수 있습니다. 다음은 웹후크 설정에 대한 비디오 자습서입니다.

    <Video
      type="wistia"
      id="feyutwgew8"
    />

    ### 웹훅 대상 설정 [#set-webhook-destination]

    웹후크 대상을 생성하려면 다음 단계를 따르십시오.

    1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI** 로 이동하고 **Destinations** \[대상을] 클릭한 다음 **Webhook**을 선택합니다.

    2. 다음 정보를 입력하십시오.

       * **웹후크 이름:** 웹후크의 참조 이름입니다.
       * **Endpoint URL:** \[엔드포인트 URL:] HTTP POST 요청이 전송될 대상 애플리케이션의 엔드포인트입니다.
       * **Use authorization \[승인 사용]:** (선택사항) `Basic Authentication`, `OAuth 2.0` 또는 `Bearer Token` 중에서 선택할 수 있습니다.

       <img
         width="80%;"
         title="Webhook destination configuration"
         alt="Webhook destination configuration"
         src={accountsWebhookDestination}
       />

    웹후크 작업이 처음이고 구성을 테스트하고 서비스를 작성하지 않고 웹후크 페이로드를 검사하려는 경우 HTTP catch-all 서비스를 사용할 수 있습니다. [Beeceptor](https://beeceptor.com) 및 [Webhook.site는](https://webhook.site) HTTP 페이로드를 수신한 다음 이벤트의 JSON 페이로드를 검사할 수 있는 지정된 URL을 제공하는 서비스의 예입니다. 이 기능은 개발 프로세스를 시작하기 전에 관련 정보를 수집하는 데 유용합니다.

    이 페이로드를 사용하기 위해 새 서비스를 구축하는 경우 로컬에서 테스트해야 합니다. 로컬 터널을 사용하는 것은 프로덕션 서버에 배포하기 전에 로컬 환경에서 웹후크를 테스트하고 디버깅하는 데 좋습니다. 이러한 터널을 사용하면 로컬 시스템의 New Relic에서 들어오는 웹후크 요청을 수신할 수 있으므로 개발 중에 공개적으로 액세스할 수 있는 서버가 필요하지 않습니다. Beeceptor 또는 ngrok와 같은 도구를 사용하면 원하는 애플리케이션 포트 또는 주소를 지정하여 요청을 로컬 서버로 전달하는 임시 공용 URL을 만들 수 있습니다. 이렇게 하면 로컬 개발 환경에서 웹후크 페이로드를 직접 관찰하고 분석할 수 있으므로 반복 및 디버깅이 빨라집니다.

    ### 양방향 동기화 [#two-way-webhook]

    워크플로에서 전송된 알림의 경우 [Nerdgraph를](/docs/apis/nerdgraph/examples/nerdgraph-issues-api-via-github/#resolve-ack-issues) 사용하여 문제를 확인하거나 종료할 수 있습니다. 웹후크를 사용하여 양방향 동기화를 테스트할 때 Beeceptor의 사용자 정의 응답 상태 및 페이로드 템플릿을 사용할 수 있습니다. 이를 통해 수신된 이벤트를 승인할 때 원하는 응답 초안을 작성할 수 있습니다.

    ### 웹훅 이벤트 템플릿 구성 [#configure-webhook-event-template]

    목록에서 웹훅 대상을 선택하고 `HTTP-POST` 요청을 구성합니다.

    요청 구성을 위해서는 다음이 필요합니다.

    1. 템플릿의 이름을 설정합니다.
    2. 대상 목록에서 미리 구성된 대상을 선택하거나 새로 만듭니다.
    3. 사용자 정의 헤더를 추가합니다(선택 사항).
    4. 요청의 페이로드를 구성합니다.

    ### 워크플로에서 웹훅 페이로드 사용자 지정 [#customize-webhook-payload]

    **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+ Add a new workflow** \[+ 새 워크플로 추가] 버튼을 클릭하고 Webhook 대상을 선택합니다.

    <Callout variant="important">
      요청의 콘텐츠 유형은 기본적으로 JSON이므로 페이로드도 JSON 형식이어야 합니다. 형식에 익숙해지려면 [사용 예](/docs/alerts-applied-intelligence/notifications/message-templates/#usage-examples) 를 참조하십시오.
    </Callout>

    기본 페이로드를 사용하거나 필요한 데이터를 포함하도록 사용자 정의할 수 있습니다. [변수 메뉴](/docs/alerts-applied-intelligence/notifications/message-templates/#variables-menu) 에서 변수를 선택하고 [핸들바 구문을](/docs/alerts-applied-intelligence/notifications/message-templates/#handlebars-syntax) 적용하여 웹훅을 강화하세요. 오른쪽의 **Preview** \[미리보기] 섹션에는 템플릿이 렌더링된 후 예상되는 페이로드가 표시됩니다. 페이로드가 유효한 JSON을 형성하지 않으면 오류가 발생하고 템플릿을 저장할 수 없습니다.

    <img
      width="80%;"
      title="An invalid Json payload."
      alt="A screenshot of an invalid Json payload."
      src={accountsWebhookPreviewError}
    />

    <Callout variant="tip">
      정의되지 않은 유형 오류는 속성이 최근에 인덱싱되지 않았거나 존재하지 않음을 나타낼 수 있습니다.오류를 수정하려면 `if else` 문을 추가해 보세요.예를 들어, `"closed_at": {{#if issueClosedAtUtc}} {{ json issueClosedAtUtc }} {{else}}"None"{{/if}}`
    </Callout>

    웹훅 페이로드가 유효한 JSON을 준수하는 경우 정의된 웹훅 대상에 테스트 알림을 보낼 수 있습니다. 모든 것이 올바르게 연결되었는지 확인하려면 테스트 알림을 보내는 것이 좋습니다.

    <img
      width="80%;"
      title="A test webhook notification template."
      alt="A screenshot of a test webhook notification template."
      src={accountsWebhookNotificationTemplate}
    />
  </Collapser>

  <Collapser
    className="freq-link"
    id="xMatters_templates"
    title="xMatters"
  >
    ### xMatters용 웹후크 템플릿

    Webhook 템플릿을 사용하여 워크플로에서 xMatters로 알림을 보냅니다.

    ```json
    {
    {{#if nrAccountId}}"account_id": {{nrAccountId}},{{/if}}
    "account_name": {{json accumulations.tag.account.[0]}},
    {{#if accumulations.tag.action}}"action":{{json accumulations.tag.action.[0]}},{{/if}}
    "closed_violations_count": {
        "critical": {{#if closedIncidentsCount}}{{closedIncidentsCount}}{{else}}0{{/if}},
        "warning": 0,
        "total": {{#if closedIncidentsCount}}{{closedIncidentsCount}}{{else}}0{{/if}}
    },
    "condition_family_id": {{accumulations.conditionFamilyId.[0]}},
    "condition_id": {{accumulations.conditionFamilyId.[0]}},
    "condition_name": {{json accumulations.conditionName.[0]}},
    {{#if accumulations.evaluationName}}"condition_metric_name": {{json accumulations.evaluationName.[0]}},{{/if}}
    {{#if accumulations.evaluationMetricValueFunction}}"condition_metric_value_function": {{json accumulations.evaluationMetricValueFunction.[0]}},{{/if}}
    "current_state": {{#if issueClosedAt}}"closed"{{else if issueAcknowledgedAt}}"acknowledged"{{else}}"open"{{/if}},
    "details": {{json issueTitle}},
    "duration": {{#if issueDurationMs}}{{issueDurationMs}}{{else}}0{{/if}},
    "event_type": "INCIDENT",
    "incident_acknowledge_url": {{json issueAckUrl}},
    "incident_url": {{json issuePageUrl}},
    "incident_id": {{json issueId}},
    "metadata": {
        {{#if locationStatusesObject}}"location_statuses": {{locationStatusesObject}},{{/if}}
        {{#if accumulations.metadata_entity_type}}"entity.type": {{json accumulations.metadata_entity_type.[0]}},{{/if}}
        {{#if accumulations.metadata_entity_name}}"entity.name": {{json accumulations.metadata_entity_name.[0]}}{{/if}}
    },
    "open_violations_count": {
        "critical": {{#if openIncidentsCount}}{{openIncidentsCount}}{{else}}0{{/if}},
        "warning": 0,
        "total": {{#if openIncidentsCount}}{{openIncidentsCount}}{{else}}0{{/if}}
    },
    "policy_name": {{json accumulations.policyName.[0]}},
    {{#if policyUrl}}"policy_url": {{json policyUrl}},{{/if}}
    "radar_entity": {
        "accountId": {{json accumulations.tag.accountId.[0]}},
        "domain": {{json accumulations.conditionProduct.[0]}},
        "domainId": {{json issueId}},
        "entityGuid": {{json entitiesData.entities.[0].id}},
        "name": {{#if accumulations.targetName}}{{json accumulations.targetName.[0]}}{{else if entitiesData.entities}}{{json entitiesData.entities.[0].name}}{{else}}"NA"{{/if}},
        "type": {{#if entitiesData.types.[0]}}{{json entitiesData.types.[0]}}{{else}}"NA"{{/if}}
    },
    {{#if accumulations.runbookUrl}}"runbook_url": {{json accumulations.runbookUrl.[0]}},{{/if}}
    "severity": {{#eq HIGH priority}}"WARNING"{{else}}{{json priority}}{{/eq}},
    "state": {{json state}},
    "status": {{json status}},
    "targets": [
        {
            "id": {{#if entitiesData.entities.[0].id}}{{json entitiesData.entities.[0].id}}{{else if accumulations.nrqlEventType}}{{json accumulations.nrqlEventType.[0]}}{{else}}"N/A"{{/if}},
            "name": {{#if accumulations.targetName}}{{json accumulations.targetName.[0]}}{{else if entitiesData.entities}}{{json entitiesData.entities.[0].name}}{{else}}"NA"{{/if}},
            "link": {{json issuePageUrl}},
            "product": {{json accumulations.conditionProduct.[0]}},
            "type": {{#if entitiesData.types.[0]}}{{json entitiesData.types.[0]}}{{else}}"NA"{{/if}},
            "labels": {
                {{#each accumulations.rawTag}}{{#if this.[0]}}"{{@key}}":{{json this.[0]}},{{/if}}{{/each}}
                "NewRelic": "targetLabels"
            }
        }
    ],
    "timestamp": {{#if closedAt}}{{closedAt}}{{else if acknowledgedAt}}{{acknowledgedAt}}{{else}}{{createdAt}}{{/if}},
    "timestamp_utc_string": {{json issueUpdatedAt}},
    "version": "1.0",
    {{#if accumulations.conditionDescription}}"VIOLATION DESCRIPTION": {{json accumulations.conditionDescription.[0]}},{{/if}}
    {{#if violationChartUrl}}"violation_chart_url": {{json violationChartUrl}},{{/if}}
    "violation_callback_url": {{json issuePageUrl}}
    }
    ```
  </Collapser>
</CollapserGroup>

## 레거시 Slack 대상을 새 Slack 대상으로 마이그레이션 [#migrate-slack]

레거시 Slack 대상을 새 Slack 대상으로 마이그레이션하려면 다음 단계를 따르십시오.

1. 새로운 Slack 대상을 설정하세요.

2. 레거시 Slack 대상으로 보내는 각 워크플로에 대해 다음을 수행합니다.

   * 레거시 알림과 함께 전송된 Slack 채널을 찾아 저장합니다.

   <img
     width="80%;"
     title="Migrate Slack, create a new workflow."
     alt="Migrate Slack, create a new workflow."
     src={accountsMigrateSlackNewWorkflow}
   />

   * 알림을 테스트하여 작동하는지 확인합니다.

   * 기존 레거시 Slack 알리미를 제거합니다.

     <img
       width="80%;"
       title="Migrate Slack, remove the existing legacy slack notifier."
       alt="Migrate Slack, remove the existing legacy slack notifier."
       src={accountsMigrateSlackRemoveLegacy}
     />

   * **Test workflow** \[테스트 워크플로를] 클릭하여 필터와 일치하는 실제 문제(있는 경우)를 확인합니다.

   * 워크플로를 저장합니다.

## API 옵션 [#api]

NerdGraph API를 사용하여 [목적지](/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-destinations) 와 [알림 채널](/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-channels) 을 보고 구성할 수도 있습니다.