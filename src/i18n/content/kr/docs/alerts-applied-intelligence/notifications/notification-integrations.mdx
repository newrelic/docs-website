---
title: 경고 및 적용된 인텔리전스 알림 통합
tags:
  - Alerts and applied intelligence
  - Applied intelligence
  - Incident intelligence
  - Destinations
metaDescription: Alerts and applied intelligence notification integrations are specific services and platforms you can use to send notifications from New Relic.
translationType: machine
---

import accountsJiraDestination from 'images/accounts_screenshot-crop_jira-destination.webp'

import accountsJiraTemplate from 'images/accounts_screenshot-crop_jira-template.webp'

import accountsBridgeEventPattern from 'images/accounts_screenshot-crop_bridge-event-pattern.webp'

import accountsServiceNowDestination from 'images/accounts_screenshot-crop_service-now-destination.webp'

import accountsServiceNowMessageTemplate from 'images/accounts_screenshot-crop_service-now-message-template.webp'

import accountsSlackDestinationAuthentication from 'images/accounts_screenshot-crop_slack-destination-authentication.webp'

import accountsSlackSignIn from 'images/accounts_screenshot-crop_slack-sign-in.webp'

import accountsSlackDestinationAllowAccess from 'images/accounts_screenshot-crop_slack-destination-allow-access.webp'

import accountsSlackAuthenticationCompleted from 'images/accounts_screenshot-crop_slack-authentication-completed.webp'

import accountsSlackMessageTemplate from 'images/accounts_screenshot-crop_slack-message-template.webp'

import accountsSlackChannelTestNotification from 'images/accounts_screenshot-crop_slack-channel-test-notification.webp'

import accountsWebhookDestination from 'images/accounts_screenshot-crop_webhook-destination.webp'

import accountsWebhookPreviewError from 'images/accounts_screenshot-crop_webhook-preview-error.webp'

import accountsWebhookNotificationTemplate from 'images/accounts_screenshot-crop_webhook-notification-template.webp'

import accountsEmailConfWorkflow from 'images/accounts_screenshot-crop_email-configure-workflow.webp'

import accountsEmailSettings from 'images/accounts_screenshot-crop_email-settings.webp'

import accountsAWSEventBridgeDestination from 'images/accounts_screenshot-crop_awseventbridge-destination.webp'

import accountsPagerDutyAccountDestinationNewUi from 'images/accounts_screenshot-crop_pager-duty-account-destination-new-ui.webp'

import accountsPagerDutyAddNewWorkflow from 'images/accounts_screenshot-crop_pager-duty-add-webhook.webp'

import accountsPagerDutyAddNewRelicIntegration from 'images/accounts_screenshot-crop_pager-duty-add-new-relic-integration.webp'

import accountsPagerDutyIntegrationOpened from 'images/accounts_screenshot-crop_pager-duty-integration-opened.webp'

import accountsPagerDutyServiceDestination from 'images/accounts_screenshot-crop_pager-duty-service-destination.webp'

import accountsMigrateSlackNewWorkflow from 'images/accounts_screenshot-crop_slack-new-workflow.webp'

import accountsMigrateSlackRemoveLegacy from 'images/accounts_screenshot-crop_slack-remove-legacy.webp'

경고 및 적용된 인텔리전스 알림 통합을 통해 특정 서비스 및 플랫폼을 New Relic 플랫폼에 연결할 수 있습니다. 이러한 연결을 사용하여 New Relic에서 알림을 보낼 수 있습니다. 이러한 알림을 통해 검토가 필요한 문제에 대한 정보를 얻거나 감지된 문제에 대한 결정을 내리는 데 도움이 됩니다.

## 통합 세부정보 [#detail]

각각의 특정 알림 통합에 대해 자세히 알아보세요.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="jira"
    title="아틀라시안 지라"
  >
    New Relic을 Atlassian Jira(Cloud)와 통합하고 Jira 이슈를 자동으로 생성, 업데이트 및 종료합니다.

    <Video
      type="wistia"
      id="vp5rigddko"
    />

    ### 권한 [#jira-permissions]

    <Callout variant="important">
      이 통합은 JIRA 온프레미스 또는 데이터 센터 설치를 지원하지 않습니다.
    </Callout>

    Jira `API-Token` 에서 필요한 권한은 `BROWSE_PROJECTS`, `ASSIGN_ISSUES`, `CLOSE_ISSUES`, `CREATE_ISSUES`, `EDIT_ISSUES`, `RESOLVE_ISSUES`, `TRANSITION_ISSUES`, `USER_PICKER`및 `ADD_COMMENTS`입니다.

    양방향 동기화 토글을 활성화하려면 제공된 Jira `API-Key` 에 `Admin` 역할이 있어야 합니다.

    ### Jira 대상 설정 [#set-up-jira]

    Jira 이슈를 만든 다음 Jira와 New Relic을 활성화하여 업데이트를 공유하고 동기화 상태를 유지하세요.

    Jira 대상을 만들려면 다음 단계를 따르세요.

    1. **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI**로 이동하고 **Destinations** \[대상을]클릭한 다음 **Jira**를선택합니다.

    2. 다음 정보를 입력하십시오.

       * **이름:** 대상을 식별하기 위한 사용자 지정 이름입니다.
       * **URL:** 대상의 URL입니다.
       * **사용자 이름:** 사용자의 이메일 주소입니다.
       * **API 토큰:** Atlassian 계정에서 생성됩니다.

    대상을 저장하기 전에 **Test connection** \[연결 테스트] 버튼을 클릭하여 연결을 확인하는 것이 좋습니다.

    <img
      width="80%;"
      title="Jira destination configuration."
      alt="A screenshot of a Jira destination configuration."
      src={accountsJiraDestination}
    />

    ### 양방향 동기화 [#jira-two-way]

    양방향 동기화는 워크플로에 적용할 수 있습니다. 활성화하려면 양방향 통합 토글을 켭니다.

    설정하면 Jira 계정에 [Jira Webhook이](https://developer.atlassian.com/server/jira/platform/webhooks/) 생성됩니다. 웹후크에는 New Relic에 대한 액세스 세부 정보(URL 및 API 키)가 포함되어 있습니다.

    ### NewRelic 워크플로와 동기화 [#two-way-sync-workflows]

    * JIRA 문제 상태가 `done`로 변경되면 New Relic 문제의 종료가 트리거됩니다.
    * JIRA 문제 상태가 `in-progress`로 변경되면 New Relic 문제 확인이 트리거됩니다.

    ### Workflows에서 메시지 템플릿 구성 [#configure-jira-message-template]

    Jira 문제에 대한 템플릿을 구성하려면 다음 단계를 따르세요.

    1. **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+ Add a new workflow** \[+ 새 워크플로 추가] 버튼을 클릭합니다.
    2. 목적지를 선택하세요. 이 단계에서 새 대상을 만들 수도 있습니다.
    3. 대상에 성공적으로 연결되면 프로젝트를 선택한 다음 사용하려는 Jira 이슈 유형을 선택합니다.
    4. 문제 유형이 선택되면 구성된 프로젝트의 필드가 계정에서 가져와 자동으로 Jira 인스턴스에 매핑됩니다.

    시작하는 데 도움이 되도록 필수 및 권장 필드와 값을 자동으로 채웁니다. 모든 필수 필드에 값을 포함합니다.

    ### 테스트 알림 보내기 [#send-jira-test]

    JIRA 문제를 보려면 기본 필드 값이 있는 테스트 알림을 클릭하십시오.

    성공하면 JIRA에서 사건을 볼 수 있는 링크가 있습니다.

    <img
      width="80%;"
      title="The Jira-specific custom variables menu."
      alt="A screenshot of the Jira-specific custom variables menu."
      src={accountsJiraTemplate}
    />

    <figcaption>
      Jira 알림 메시지 템플릿.
    </figcaption>
  </Collapser>

  <Collapser
    className="freq-link"
    id="eventBridge"
    title="AWS 이벤트브리지"
  >
    New Relic 및 [AWS EventBridge](https://aws.amazon.com/eventbridge/) 를 사용하여 AWS Lambda, Amazon Simple Notification Service(SNS) 대기열, CloudWatch Logs 등과 같은 대상에 대한 알림을 사용자 지정하고 전달할 수 있습니다.

    <Video
      type="wistia"
      id="24mucmd1mj"
    />

    ### EventBridge 대상 설정 [#set-up-eventbridge]

    <Callout variant="important">
      New Relic은 AWS에 [SaaS 파트너 이벤트 소스](https://aws.amazon.com/eventbridge/integrations/) 로 나열됩니다.
    </Callout>

    AWS EventBridge 대상을 생성하려면 다음 단계를 따르십시오.

    1. **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI**로 이동하고 **Destinations**를클릭한 다음 **AWS EventBridge**를선택합니다.

    2. 다음 정보를 입력하십시오.

       * **이름:** 대상을 식별하기 위한 사용자 지정 이름입니다.
       * **AWS 지역:** AWS 지역 엔드포인트입니다. 이벤트 소스가 호스팅되는 지역을 선택하십시오.
       * **AWS 계정 ID:** AWS 계정 ID입니다. 이것은 12자리 숫자입니다.

       <img
         width="80%;"
         title="AWS EventBridge destination"
         alt="AWS EventBridge destination"
         src={accountsAWSEventBridgeDestination}
       />

    ### 이벤트 소스 선택 [#eventbridge-source]

    AWS 계정 ID로 EventBridge 대상을 구성한 후 새 이벤트 소스를 생성하면 EventBridge에서 사용할 수 있습니다.

    1. 대상 이름을 선택하거나 만듭니다.

    2. 이벤트 소스를 선택하거나 생성합니다.

       새 이벤트 소스를 생성하면 AWS EventBridge 계정에 통합 파트너 이벤트 소스로 생성됩니다.

    ### AWS 계정의 이벤트 소스를 연결하고 규칙을 생성합니다. [#eventbridge-rule]

    이벤트 소스를 이벤트 버스와 연결하려면:

    1. AWS EventBridge 콘솔의 탐색 창에서 **Partner event sources** \[파트너 이벤트 소스를] 선택합니다.

    2. 파트너 이벤트 소스 옆에 있는 버튼을 선택한 다음 **Associate with event bus** \[이벤트 버스와 연결을] 선택합니다.

       이벤트 소스의 상태가 **Pending** 에서 **Active**로 변경되고 이벤트 버스의 이름이 이벤트 소스 이름과 일치하도록 업데이트됩니다. 이제 New Relic의 이벤트와 일치하는 규칙 생성을 시작할 수 있습니다.

    3. 이벤트 버스에 대한 규칙을 만듭니다.

       New Relic에서 보낸 알림에 반응하려면 New-Relic 이벤트를 필터링하는 이벤트 패턴으로 규칙을 만들어야 합니다.

       <img
         width="80%;"
         title="Event pattern with the newrelic partner prefix."
         alt="A screenshot of rule Event pattern."
         src={accountsBridgeEventPattern}
       />

       자세한 지침 [은 이벤트 소스 규칙을 생성하는](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-saas.html#eb-create-rule-partner-events) 방법에 대한 이 AWS 문서를 사용하십시오.

    ### Workflows에서 메시지 이벤트 템플릿 구성 [#message-eventbridge]

    워크플로로 이동하여 기존 워크플로 또는 **Add a new Workflow** \[새 워크플로 추가] 버튼을 클릭하고 eventbridge 대상을 선택합니다. New Relic에서 EventBridge로 알림을 보낼 때 메시지 템플릿을 사용하여 해당 알림을 사용자 지정할 수 있습니다.

    기본 템플릿을 사용하거나 직접 사용자 정의할 수 있습니다. [변수 메뉴](/docs/alerts-applied-intelligence/notifications/message-templates/#variables-menu) 에서 변수를 선택하고 [핸들바 구문을](/docs/alerts-applied-intelligence/notifications/message-templates/#handlebars-syntax) 적용하여 이벤트를 풍부하게 만드십시오.

    EventBridge API에는 JSON이 필요합니다. [JSON 사용 예](/docs/alerts-applied-intelligence/notifications/message-templates/#usage-examples) 를 참조하십시오. 템플릿 미리보기는 렌더링된 JSON을 보여줍니다.

    이벤트 템플릿이 유효한 JSON을 준수하면 AWS EventBridge에 테스트 알림을 보낼 수 있습니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="email"
    title="이메일"
  >
    [워크플로](/docs/alerts-applied-intelligence/applied-intelligence/incident-workflows/incident-workflows/)의 알림 채널로 **이메일을** 선택하면 이메일 대상이 자동으로 생성되므로 **대상** 메뉴에서 구성할 필요가 없습니다. 각 이메일 대상은 연결된 워크플로우에 대해 고유하며 이는 대상 피드에서 중복으로 표시될 수 있음을 의미합니다.

    이메일 알림을 보내려면:

    1. **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI** 로 이동합니다.

    2. 왼쪽 탐색 패널에서 **워크플로를** 선택합니다.

    3. **+ 워크플로 추가를**클릭합니다.

       <img
         width="80%;"
         title="Configure your workflow"
         alt="Configure your workflow"
         src={accountsEmailConfWorkflow}
       />

    4. 워크플로의 이름을 지정합니다. 이 필드는 필수이며 고유해야 합니다.

    5. 필요한 데이터를 필터링합니다. **기본** 및 **고급** 옵션 중에서 선택하여 보내려는 문제를 추가할 수 있습니다.

    6. **추가 설정을** 클릭하여 데이터를 보강합니다. **데이터 강화를** 활성화하여 NRQL 쿼리를 작성합니다.

    7. **저장 후 종료를**클릭합니다.

    8. 알림 방법으로 **이메일을** 선택합니다.

       <img
         width="60%;"
         title="Email settings"
         alt="A screenshot of the email settings."
         src={accountsEmailSettings}
       />

    9. 알림을 보낼 이메일을 추가합니다. 하나 이상의 수신자를 추가할 수 있습니다.

       * 이메일 주소를 검색하여 New Relic 계정이 있는 사용자를 찾을 수 있습니다.
       * New Relic 계정이나 이메일 배포 목록이 없는 사용자를 추가하려면 전체 이메일 주소를 입력하십시오.
       * 이메일 설정에 추가된 각 이메일 주소 목록은 대상 피드에 표시될 고유한 대상을 생성합니다.
       * [알림 로그](/docs/alerts-applied-intelligence/notifications/destinations/#notifications-log)에서 대상별로 이메일 알림을 따를 수 있습니다.

    10. 전자 메일 메시지를 사용자 지정합니다.

        * 이메일 제목의 경우 기본 페이로드를 사용하거나 필요한 데이터를 포함하도록 사용자 정의할 수 있습니다.
        * 이메일 본문에는 변경할 수 없는 기본 데이터가 포함되어 있지만 사용자 지정 추가 세부 정보를 추가할 수도 있습니다. 이러한 사용자 지정은 **사용자 지정 세부 정보** 섹션 아래에 나타납니다.
        * 이메일을 풍부하게 하려면 [변수 메뉴](/docs/alerts-applied-intelligence/notifications/message-templates/#variables-menu) 에서 변수를 선택하고 [핸들바 구문](/docs/alerts-applied-intelligence/notifications/message-templates/#handlebars-syntax) 을 적용하십시오.

    11. **테스트 알림 보내기를** 클릭하여 이메일 알림이 받은 편지함에 도착하는지 확인합니다.

    12. **저장** 을 클릭합니다.

    13. **워크플로 활성화 를**클릭합니다.

    워크플로 메인 페이지에서 생성된 워크플로를 클립보드에 활성화, 편집, 삭제 또는 워크플로 ID를 복사할 수 있습니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="mobile_push"
    title="New Relic 모바일 푸시"
  >
    New Relic iOS 또는 Android 모바일 앱에 푸시 알림을 보냅니다.

    <Video
      type="wistia"
      id="s29hxnyi4v"
    />

    ### 모바일 푸시 대상 설정 [#set-mobile_push-destination]

    모바일 푸시 대상을 생성하려면 다음이 필요합니다.

    * **푸시 대상 이름:** 고유한 대상 이름입니다.

    * **사용자 ID:** 현재 로그인한 사용자를 기준으로 자동으로 채워집니다.

      <Callout variant="important">
        현재는 [수정 기능이](/docs/alerts-applied-intelligence/notifications/destinations#requirements)있는 현재 로그인한 사용자에 대한 모바일 푸시 대상을 만드는 것으로 제한되어 있습니다. 사용자를 위한 단일 푸시 대상만 생성할 수 있습니다. 하나 이상 만들려고 하면 오류가 나타납니다. 대상을 저장하기 전에 **연결 테스트** 버튼을 통해 연결을 테스트하는 것이 좋습니다.
      </Callout>

    ### 워크플로에서 푸시 알림을 받을 시기 구성 [#mobile]

    **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+Add a new workflow** \[+새 워크플로 추가] 버튼을 클릭하고 모바일 알리미를 선택합니다. 모바일 푸시를 구성하려면 모바일 알리미를 클릭하고 원하는 대상을 선택합니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="opsgeniewebhook_templates"
    title="옵스제니"
  >
    ### Atlassian Opsgenie용 웹후크 템플릿

    웹후크 템플릿을 사용하여 워크플로에서 Opsgenie로 알림 보내기 워크플로[용 Opsgenie 웹후크 템플릿](https://support.atlassian.com/opsgenie/docs/integrate-opsgenie-with-new-relic-alerts-new/)
  </Collapser>

  <Collapser
    className="freq-link"
    id="pagerduty"
    title="호출기 의무"
  >
    New Relic을 PagerDuty와 통합하여 PagerDuty 사고를 자동으로 생성, 업데이트, 확인 및 해결합니다.

    <Video
      type="wistia"
      id="lvzd77zj17"
    />

    PagerDuty와 통합하는 두 가지 방법을 제공합니다.

    * **[REST API 키를 사용한 계정 수준 통합(권장)](#pagerduty-ali)** : 통합은 완전 자동이며 양방향 동기화 및 단일 New Relic 대상에서 여러 PagerDuty 서비스를 정의하는 기능을 지원합니다.
    * **[이벤트 API 키를 사용한 서비스 통합](#pagerduty-sli)** : 단일 서비스 통합은 서비스 수준 통합 키를 사용하며 각 고유한 PagerDuty 서비스에 대해 별도의 New Relic 대상이 필요합니다.

    ### 계정 수준 통합 [#pagerduty-ali]

    통합은 완전 자동이며 양방향 동기화와 단일 New Relic 대상에서 여러 PagerDuty 서비스를 정의하는 기능을 지원합니다.

    ### 권한 [#pd-permissions]

    이 통합에는 다음 작업을 수행할 수 있는 권한이 필요합니다.

    * [서비스 나열](https://developer.pagerduty.com/api-reference/b3A6Mjc0ODE5Ng-list-services)
    * [통합 생성](https://developer.pagerduty.com/api-reference/b3A6Mjc0ODIwMw-create-a-new-integration)
    * [웹훅 구독 만들기](https://developer.pagerduty.com/api-reference/b3A6MjkyNDc4NA-create-a-webhook-subscription)
    * [메모 만들기](https://developer.pagerduty.com/api-reference/b3A6Mjc0ODE1MA-create-a-note-on-an-incident)
    * [팀 나열](https://developer.pagerduty.com/api-reference/b3A6Mjc0ODIyMw-list-teams)
    * [사용자 나열](https://developer.pagerduty.com/api-reference/b3A6Mjc0ODIzMw-list-users)

    이 통합에는 REST API 키가 필요합니다. PagerDuty에는 두 가지 유형의 REST API 키가 있습니다.

    * [일반 액세스 키](https://support.pagerduty.com/docs/generating-api-keys#section-generating-a-general-access-rest-api-key): 위에 나열된 모든 권한을 포함하며 PagerDuty 관리자 및 계정 소유자가 액세스할 수 있습니다. [PagerDuty 지침을 참조하십시오](https://support.pagerduty.com/docs/api-access-keys#generate-a-general-access-rest-api-key).

    * [개인 사용자 토큰](https://support.pagerduty.com/docs/generating-api-keys#section-generating-a-personal-rest-api-key) : 계정에 고급 권한이 있는 경우 고유한 개인 REST API 키를 생성할 수 있습니다. 개인 REST API 키를 사용한 요청은 사용자 권한으로 제한됩니다. 사용자 토큰 API 키를 제공하기로 선택한 경우 위에 설명된 필수 권한이 있는지 확인하십시오. [PagerDuty 지침을 참조하십시오](https://support.pagerduty.com/docs/api-access-keys#generate-a-user-token-rest-api-key) .

      <Callout variant="tip">
        개인 사용자 토큰의 경우 실제 사용자에 속하지 않는 전용 통합 사용자를 사용하는 것이 좋습니다.
      </Callout>

    ### 목적지 설정 [#set-up-pagerduty]

    PagerDuty 대상을 만들려면 다음 단계를 따르십시오.

    1. **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI**로 이동하고 **Alerts & AI** \[대상을]클릭한 다음 **PagerDuty**를선택합니다.

    2. 다음 정보를 입력하십시오.

       * **이름** : 목적지를 식별하기 위한 사용자 정의 이름입니다.
       * **API 키**: 이 통합의 경우 REST API 키를 제공하라는 메시지가 표시됩니다. PagerDuty에는 [일반 액세스](https://support.pagerduty.com/docs/generating-api-keys#section-generating-a-general-access-rest-api-key) 및 [사용자 토큰](https://support.pagerduty.com/docs/generating-api-keys#section-generating-a-personal-rest-api-key)의 두 가지 유형의 REST API 키가 있습니다.

    대상을 저장하기 전에 연결 **테스트** 버튼을 클릭하여 연결을 테스트하는 것이 좋습니다.

    <img
      width="80%;"
      title="PagerDuty account-level destination configuration"
      alt="A screenshot of a PagerDuty account-level destination configuration"
      src={accountsPagerDutyAccountDestinationNewUi}
    />

    ### 양방향 동기화 [#two-way-pagerduty]

    양방향 동기화를 활성화하려면 **양방향 통합** 토글을 켭니다.

    켜져 있으면 선택한 PagerDuty 서비스에 대한 PagerDuty 구독이 이후 단계에서 생성됩니다( [메시지 템플릿 사용자 지정](#message-pagerduty) 참조). 웹훅에는 New Relic(URL 및 New Relic API 키)에 대한 액세스 세부 정보가 포함되어 있습니다.

    기본적으로 New Relic에 의해 생성된 PagerDuty 사건에 대한 모든 상태 변경은 New Relic에 다시 동기화됩니다.

    <Callout variant="important">
      특정 서비스에서 Intelligent Alert Grouping을 사용하는 PagerDuty 이벤트 인텔리전스 또는 디지털 운영 고객인 경우 New Relic으로 다시 전송되는 PagerDuty 사건에 잠재적인 불일치가 있을 수 있습니다.
    </Callout>

    ### New Relic 워크플로와 동기화 [#two-way-sync-workflows]

    * PagerDuty 인시던트가 해결되면 New Relic 문제의 종료가 트리거됩니다.
    * PagerDuty 인시던트가 확인되면 New Relic 문제에 대한 확인이 트리거됩니다.

    ### Workflows에서 메시지 템플릿 구성 [#message-pagerduty]

    메시지 템플릿을 구성하려면:

    1. **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+ Add a new Workflow** \[+ 새 워크플로 추가] 버튼을 클릭하고 PagerDuty 알리미를 선택합니다.

    2. 목적지를 선택하세요. 이 단계에서 새 대상을 만들 수도 있습니다.

    3. PagerDuty 서비스를 선택합니다.

    4. 사용자를 선택합니다. New Relic은 선택된 사용자를 대신하여 메모를 게시합니다.

    5. Pagerduty의 Custom Details 섹션으로 세부 정보를 보냅니다. 기본 페이로드를 사용하거나 문제 페이로드의 자유 텍스트 또는 동적 변수를 사용하여 사용자 정의할 수 있습니다. [변수 메뉴](/docs/alerts-applied-intelligence/notifications/message-templates/#variables-menu) 에서 변수를 선택하고 [핸들바 구문을](/docs/alerts-applied-intelligence/notifications/message-templates/#handlebars-syntax) 적용하여 페이로드를 보강하십시오. 오른쪽의 **미리보기** 섹션에는 템플릿이 렌더링된 후 예상되는 페이로드가 표시됩니다. 페이로드가 유효한 JSON을 형성하지 않으면 오류가 표시되고 템플릿을 저장할 수 없습니다.

       PagerDuty 알림의 사용자 지정 세부 정보는 자동으로 채워집니다.

    ### 테스트 알림 보내기 [#test-notification-pagerduty]

    기본 필드 값이 있는 테스트 알림을 클릭하면 PagerDuty 인시던트가 어떻게 나타나는지 확인할 수 있습니다. 성공하면 인시던트가 생성되고 링크가 나타납니다.

    <img
      width="80%;"
      title="PagerDuty service-level workflow configuration."
      alt="A screenshot of a PagerDuty service-level workflow configuration."
      src={accountsPagerDutyAddNewWorkflow}
    />

    ### 서비스 통합 [#pagerduty-sli]

    이 통합을 위해서는 New Relic이 인시던트를 생성할 서비스에서 New Relic PagerDuty 통합을 설정해야 합니다.

    PagerDuty 서비스에서 New Relic 통합을 생성하려면 다음 단계를 따르십시오.

    1. **Services > Service Directory** 로 이동하고 통합을 추가할 서비스를 선택합니다.

    2. **Integrations** \[통합] 탭을 선택하고 **Add an integration** \[통합 추가를]클릭합니다.

    3. 목록에서 New Relic 통합을 찾아 표시하고 **Add** \[추가를]클릭하십시오.

       <img
         title="PagerDuty New Relic integration."
         width="70%;"
         alt="New Relic integration."
         src={accountsPagerDutyAddNewRelicIntegration}
       />

    4. **Integration Key** \[통합 키를]보고 복사하려면 오른쪽을 클릭하십시오.

       <img
         title="PagerDuty New Relic integration key."
         alt="New Relic integration key."
         src={accountsPagerDutyIntegrationOpened}
       />

    ### 메시지 템플릿 구성 [#message-pagerduty]

    메시지 템플릿을 구성하려면:

    1. **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+ Add a new workflow** \[+ 새 워크플로 추가] 버튼을 클릭하고 PagerDuty 알리미를 선택합니다.
    2. 목적지를 선택하세요. 이 단계에서 새 대상을 만들 수도 있습니다.
    3. (선택 사항) 기본 인시던트 요약을 편집합니다.

    PagerDuty 알림의 사용자 지정 세부 정보는 자동으로 채워집니다.

    ### 테스트 알림 보내기 [#test-notification-pagerduty]

    기본 필드 값이 있는 테스트 알림을 클릭하면 PagerDuty 인시던트가 어떻게 나타나는지 확인할 수 있습니다.
  </Collapser>

  <Collapser
    className="freq-link"
    id="servicenow"
    title="ServiceNow(사고 관리)"
  >
    <Callout>
      현재 이 통합을 더 이상 설치하지 않는 것이 좋습니다.

      대신 New Relic Workflows와 함께 새롭게 인증된 통합을 사용하는 것이 좋습니다. [다음 섹션](#servicenow-certified)에서 설치 및 사용 방법을 참조하십시오.
    </Callout>

    New Relic을 ServiceNow ITSM과 통합하고 ServiceNow 인시던트를 자동으로 생성, 업데이트 및 해결합니다.

    <Video
      type="wistia"
      id="6or6n8am4k"
    />

    ### 역할 [#roles-servicenow]

    통합의 일부로 ServiceNow 인시던트 테이블 및 기타 선택적 값에서 필드를 가져옵니다. 다음 권한이 필요합니다.

    * 테이블 `sys_dictionary` , `sys_choice` , `sys_user` 및 `task` 에 대한 전체 읽기 권한.

    * `incident` 에 대한 읽기/쓰기 권한.

    * `caller` 열에 대한 사용자를 가져오려면 `sys_user` 테이블에 대한 읽기 권한이 필요합니다.

      기본 제공되지 않는 세분화된 역할 `personalize_choices` , `personalize_dictionary` , `rest_service` 또는 `snc_platform_rest_api_access` 및 `itil` 에는 위의 권한이 있습니다.

      양방향 통합을 사용하려면 `api_key_credentials` 테이블에 대한 읽기/쓰기 권한이 필요합니다.`credentials_admin` 및 `discovery_admin` 역할이 이를 제공합니다.

    ### 목적지 설정 [#set-up-service-destination]

    ServiceNow 대상을 생성하려면 다음 단계를 따르십시오.

    1. **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI**로 이동하고 **Destinations** \[대상을]클릭한 다음 **ServiceNow**를선택합니다.

    2. 다음 정보를 입력하십시오.

       * **목적지 이름: 목적지** 를 식별하기 위한 사용자 정의 이름.
       * **도메인:** 대상의 URL입니다.
       * **Username** \[사용자 이름]: 사용자의 이름입니다.
       * **비밀번호:** 사용자의 비밀번호입니다.

    대상을 저장하기 전에 연결 **테스트** 버튼을 클릭하여 연결을 테스트하는 것이 좋습니다.

    ### 양방향 동기화 [#two-way-snow]

    **양방향 통합을**구성하려면:

    1. `two-way integration` 토글을 켭니다.
    2. 이 [XML 파일을](https://storage.googleapis.com/newrelic-notifications/snow-two-way-sync/Newrelic-Snow-Sync-Configurations.xml)열고 다운로드하십시오. 여기에는 New Relic으로 다시 이벤트를 트리거하는 비즈니스 규칙이 포함되어 있습니다.
    3. ServiceNow 사이드바 메뉴에서 **System Definition > Business Rules** 으로 이동합니다.
    4. 열 헤더 중 하나에서 메뉴 아이콘을 클릭하고 **XML 가져오기** 를 선택한 다음 다운로드한 XML 파일을 업로드합니다.

    대상이 저장되면 New Relic API 키가 `api_key_credentials`에 보관됩니다. 키는 New Relic에 대한 REST 콜백 호출의 일부로 헤더로 전송됩니다.

    ### 워크플로와 동기화 [#two-way-sync-snow-workflows]

    * ServiceNow 사고 상태가 해결됨으로 변경되면 New Relic 문제가 종료됩니다.
    * ServiceNow 사고 상태가 열림에서 변경되면 New Relic 문제에 대한 승인이 트리거됩니다.

    ### 워크플로에서 메시지 템플릿 구성 [#configure-servicenow-message-template]

    1. **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+ Add a new workflow** \[+ 새 워크플로 추가] 버튼을 클릭합니다.

    2. ServiceNow 대상을 선택합니다.

    3. 연결에 성공하면 ServiceNow 인시던트 테이블 열이 계정에서 가져와서 ServiceNow 인스턴스에 자동으로 매핑됩니다.

       시작하는 데 도움이 되도록 필수 및 권장 필드가 기본값으로 미리 채워져 있습니다.

       지원되는 필드에 대한 사용자 정의 값을 추가할 때 이슈 페이로드에서 동적 값을 추가하거나 고유한 값을 작성할 수 있습니다.

       필요하지 않은 필드를 제거하고 자신의 필드를 추가할 수 있습니다.

    ### 테스트 알림 보내기 [#send-servicenow-test]

    **Send test notification** \[테스트 알림 보내기를] 클릭하여 기본 필드 값으로 ServiceNow 사건을 확인합니다. 성공하면 생성된 인시던트에 대한 링크가 표시됩니다.

    <img
      width="80%;"
      title="ServiceNow incident template."
      alt="A screenshot of some recommended ServiceNow-incident fields and values."
      src={accountsServiceNowMessageTemplate}
    />

    <figcaption>
      ServiceNow-Incident 템플릿에 대한 필드를 선택, 편집 또는 제거합니다.
    </figcaption>
  </Collapser>

  <Collapser
    className="freq-link"
    id="servicenow-certified"
    title="Servicenow(인증된 애플리케이션)"
  >
    New Relic Workflows와의 인증된 Servicenow 통합은 ServiceNow 스토어에서 사용할 수 있습니다. [포럼](https://forum.newrelic.com/s/hubtopic/aAX8W00000006D7/coming-soon-a-new-integration-between-new-relic-workflows-and-servicenow)에서 이 통합에 대해 자세히 알아보세요.

    ### 목적지 설정 [#set-up-destination]

    ServiceNow 대상을 생성하려면 다음 단계를 따르십시오.

    1. ServiceNow 스토어에서 New Relic 애플리케이션을[다운로드](https://store.servicenow.com/sn_appstore_store.do#!/store/application/d117597d1b9b9d9078faddf7b04bcba7/1.0.0?referer=%2Fstore%2Fsearch%3Flistingtype%3Dallintegrations%25253Bancillary_app%25253Bcertified_apps%25253Bcontent%25253Bindustry_solution%25253Boem%25253Butility%25253Btemplate%26q%3Dnew%2520relic&sl=sh) 하고 설치합니다.

    2. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Alerts & AI** 로 이동하고 **Destinations** \[대상을] 클릭한 다음 **Webhook** \[웹후크를] 선택합니다.

    3. 다음 필드를 채우십시오.

       * **Destination Name** \[목적지 이름]: 목적지를 식별하기 위한 이름.
       * **Domain**: 대상의 끝점 URL입니다. `*.service-now.com/api/x_newre_core/new_relic/issue/notification`포함해야 합니다(예: `https://my_instance.service-now.com/api/x_newre_core/new_relic/issue/notification`.
       * **사용자 이름**: ServiceNow를 인증할 사용자의 이름입니다. `x_newre_core.inbound_api` 권한이 있어야 합니다.
       * **Password** \[비밀번호]: ServiceNow를 인증하기 위한 사용자의 비밀번호입니다.

    4. servicenow 스토어에서[ **Installation Guide** \[설치 안내서를\]다운로드](https://store.servicenow.com/appStoreAttachments.do?sys_id=90ce114e1baa6510e0190d48624bcbd3) 하고 지침을 따르십시오.
  </Collapser>

  <Collapser
    className="freq-link"
    id="slack"
    title="느슨하게"
  >
    Slack 채널에 알림 메시지를 보냅니다.

    자세한 내용은 [이전 Slack 웹훅 대상에서 새 Slack 앱으로 마이그레이션하는 방법을](#migrate-slack) 참조하세요.

    <Video
      type="wistia"
      id="zs92j5i31v"
    />

    ### 전제 조건 [#slack-prereqs]

    Slack 작업 공간에는 [New Relic 애플리케이션](https://newrelic.slack.com/apps/AP92KQJS3-new-relic?tab=more_info)(또는 `one.eu.newrelic` 고객의 경우 [EU 앱](https://slack.com/apps/AS5D75HQQ-new-relic-eu?tab=more_info) )이 설치되어 있어야 합니다. 애플리케이션을 개별적으로 설치하기 전에 워크스페이스 관리자가 애플리케이션을 승인해야 합니다. 앱 지원은 [support@newrelic.com](mailto:support@newrelic.com) 으로 문의하십시오.

    ### Slack 대상 설정 [#set-slack-destination]

    1. **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI**로 이동하고 **Destinations** \[대상을]클릭한 다음 **Slack**을선택합니다.

    2. **Authenticate in one click** \[클릭 한 번으로 인증] 버튼을 클릭하여 Slack 랜딩 페이지로 이동하고 OAuth2 인증 프로세스를 계속합니다. 필요한 워크스페이스에 로그인하지 않은 경우 로그인을 위해 Slack으로 리디렉션됩니다.

       <img
         width="60%;"
         title="Create a Slack destination with a click."
         alt="A screenshot of the one-click Slack authentication."
         src={accountsSlackDestinationAuthentication}
       />

    3. 작업 영역 이름을 추가하거나 관련 작업 영역을 선택하고 **계속** 을 클릭합니다.

       <img
         width="50%;"
         title="add a Slack workspace."
         alt="add a workspace."
         src={accountsSlackSignIn}
       />

    4. 선택한 작업 공간에 로그인하면 New Relic이 지정된 작업을 수행하도록 허용합니다.

       <img
         width="40%;"
         title="select a workspace and configure permissions."
         alt="A screenshot permissions configurations."
         src={accountsSlackDestinationAllowAccess}
       />

    5. **허용** 을 클릭하고 대상 페이지로 돌아갑니다.

       <img
         width="80%;"
         title="authentication completed successfully."
         alt="A screenshot completed authentication."
         src={accountsSlackAuthenticationCompleted}
       />

    ### Workflows에서 Slack 메시지 템플릿 구성 [#configure-slack-message-settings]

    1. **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+ Add a workflow** \[+ 워크플로 추가] 버튼을 클릭합니다.

    2. 메시지를 보낼 목적지(Workspace)와 Slack 채널을 선택하세요. 필요한 작업 공간에 대해 미리 정의된 대상이 없는 경우 새 대상을 생성할 수 있습니다. 개인 정보 보호를 위해 사용자는 비공개 채널을 선택하기 위해 한 번 인증을 받아야 합니다. 비공개 채널을 선택하면 봇이 자동으로 채널에 추가됩니다.

    3. 기본 알림을 사용하거나 사용자 정의 세부 정보로 보강할 수 있습니다. [변수 메뉴](/docs/alerts-applied-intelligence/notifications/message-templates/#variables-menu) 에서 변수를 선택하고 [핸들바 구문](/docs/alerts-applied-intelligence/notifications/message-templates/#handlebars-syntax) 을 적용하여 페이로드를 보강하십시오.

    4. 미리 정의된 예제 페이로드가 포함된 테스트 알림을 채널에 보내려면 **Send test notification** \[테스트 알림 보내기] 버튼을 클릭합니다. 이렇게 하면 선택한 Slack 채널에 메시지가 생성됩니다.

       <img
         width="80%;"
         title="Authenticate to select private channels."
         alt="Slack settings, user is not authenticated."
         src={accountsSlackMessageTemplate}
       />
  </Collapser>

  <Collapser
    className="freq-link"
    id="Splunk_on_call_templates"
    title="Splunk 대기 중(VictorOps)"
  >
    ### Splunk On-call용 Webhook 템플릿

    [Webhook 템플릿을](https://help.victorops.com/knowledge-base/new-relic-integration-guide/#about-splunk-on-call-and-new-relic)사용하여 워크플로에서 Splunk On-call로 알림 보내기
  </Collapser>

  <Collapser
    className="freq-link"
    id="webhook"
    title="웹훅"
  >
    지정된 HTTPS 끝점에 알림 메시지를 보내려면 Workflows에서 웹후크 알리미를 사용해야 합니다. 기본적으로 알리미는 요청의 콘텐츠 유형이 JSON이라고 가정하고 지정된 끝점에 HTTP POST 요청을 합니다. 구성을 시작하면 Webhook 알리미는 즉시 사용할 수 있는 기본 JSON 페이로드 구조를 제공합니다. 그러나 더 많은 사용자 지정이 필요한 경우 Handlebars 템플릿 구문을 사용하여 페이로드를 수정할 수 있습니다. 이를 통해 페이로드 내의 변수를 동적으로 채우고 특정 요구 사항에 맞게 조정할 수 있습니다.

    페이로드 외에도 웹후크 요청에 추가 HTTP 헤더를 포함할 수 있습니다. 이는 수신 엔드포인트에 추가 정보 또는 인증 토큰을 전달하는 데 유용할 수 있습니다. 다음은 웹후크 설정에 대한 비디오 자습서입니다.

    <Video
      type="wistia"
      id="feyutwgew8"
    />

    ### 웹훅 대상 설정 [#set-webhook-destination]

    웹후크 대상을 생성하려면 다음 단계를 따르십시오.

    1. **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI**로 이동하고 **Destinations**\[대상을]클릭한 다음 **Webhook** \[웹후크를]선택합니다.

    2. 다음 정보를 입력하십시오.

       * **웹후크 이름:** 웹후크의 참조 이름입니다.
       * **Endpoint URL:** \[엔드포인트 URL:] HTTP POST 요청이 전송될 대상 애플리케이션의 엔드포인트입니다.
       * **인증 사용:** (선택사항) `Basic Authentication` 또는 `Bearer Token`중에서 선택할 수 있습니다.

       <img
         width="80%;"
         title="Webhook destination configuration"
         alt="Webhook destination configuration"
         src={accountsWebhookDestination}
       />

    웹후크 작업이 처음이고 구성을 테스트하고 서비스를 작성하지 않고 웹후크 페이로드를 검사하려는 경우 HTTP catch-all 서비스를 사용할 수 있습니다. [Beeceptor](https://beeceptor.com) 및 [Webhook.site는](https://webhook.site) HTTP 페이로드를 수신한 다음 이벤트의 JSON 페이로드를 검사할 수 있는 지정된 URL을 제공하는 서비스의 예입니다. 이 기능은 개발 프로세스를 시작하기 전에 관련 정보를 수집하는 데 유용합니다.

    이 페이로드를 사용하기 위해 새 서비스를 구축하는 경우 로컬에서 테스트해야 합니다. 로컬 터널을 사용하는 것은 프로덕션 서버에 배포하기 전에 로컬 환경에서 웹후크를 테스트하고 디버깅하는 데 좋습니다. 이러한 터널을 사용하면 로컬 시스템의 New Relic에서 들어오는 웹후크 요청을 수신할 수 있으므로 개발 중에 공개적으로 액세스할 수 있는 서버가 필요하지 않습니다. Beeceptor 또는 ngrok와 같은 도구를 사용하면 원하는 애플리케이션 포트 또는 주소를 지정하여 요청을 로컬 서버로 전달하는 임시 공용 URL을 만들 수 있습니다. 이렇게 하면 로컬 개발 환경에서 웹후크 페이로드를 직접 관찰하고 분석할 수 있으므로 반복 및 디버깅이 빨라집니다.

    ### 양방향 동기화 [#two-way-webhook]

    워크플로에서 보낸 알림의 경우 [Nerdgraph를](/docs/apis/nerdgraph/examples/nerdgraph-issues-api-via-github/#resolve-ack-issues)사용하여 문제를 확인하거나 종료할 수 있습니다.

    웹후크와의 양방향 동기화를 테스트하는 경우 Beeceptor의 사용자 정의된 응답 상태 및 페이로드 템플릿을 사용할 수 있습니다. 이렇게 하면 수신된 이벤트를 승인할 때 원하는 응답 초안을 작성할 수 있습니다.

    ### 웹훅 이벤트 템플릿 구성 [#configure-webhook-event-template]

    목록에서 웹훅 대상을 선택하고 `HTTP-POST` 요청을 구성합니다.

    요청 구성을 위해서는 다음이 필요합니다.

    1. 템플릿의 이름을 설정합니다.
    2. 대상 목록에서 미리 구성된 대상을 선택하거나 새로 만듭니다.
    3. 사용자 정의 헤더를 추가합니다(선택 사항).
    4. 요청의 페이로드를 구성합니다.

    ### 워크플로에서 웹후크 페이로드 사용자 지정 [#customize-webhook-payload]

    **[one.newrelic.com](https://one.newrelic.com/all-capabilities) > Alerts & AI > Workflows** 로 이동하여 기존 워크플로를 클릭하거나 **+ Add a new workflow** \[+ 새 워크플로 추가] 버튼을 클릭하고 Webhook 대상을 선택합니다.

    <Callout variant="important">
      요청의 콘텐츠 유형은 기본적으로 JSON이므로 페이로드도 JSON 형식이어야 합니다. 형식에 익숙해지려면 [사용 예](/docs/alerts-applied-intelligence/notifications/message-templates/#usage-examples) 를 참조하십시오.
    </Callout>

    기본 페이로드를 사용하거나 필요한 데이터를 포함하도록 사용자 정의할 수 있습니다. [변수 메뉴](/docs/alerts-applied-intelligence/notifications/message-templates/#variables-menu) 에서 변수를 선택하고 [핸들바 구문](/docs/alerts-applied-intelligence/notifications/message-templates/#handlebars-syntax) 을 적용하여 웹훅을 풍부하게 만드십시오.

    오른쪽의 **미리보기** 섹션에는 템플릿이 렌더링된 후 예상되는 페이로드가 표시됩니다. 페이로드가 유효한 JSON을 형성하지 않으면 오류가 발생하고 템플릿을 저장할 수 없습니다.

    <img
      width="80%;"
      title="An invalid Json payload."
      alt="A screenshot of an invalid Json payload."
      src={accountsWebhookPreviewError}
    />

    <Callout variant="tip">
      정의되지 않은 유형 오류는 속성이 최근에 인덱싱되지 않았거나 존재하지 않음을 나타낼 수 있습니다.오류를 수정하려면 `if else` 문을 추가해 보세요.예를 들어, `"closed_at": {{#if issueClosedAtUtc}} {{ json issueClosedAtUtc }} {{else}}"None"{{/if}}`
    </Callout>

    웹훅 페이로드가 유효한 JSON을 준수하는 경우 정의된 웹훅 대상으로 테스트 알림을 보낼 수 있습니다.

    모든 것이 올바르게 연결되었는지 확인하기 위해 테스트 알림을 보내는 것이 좋습니다.

    <img
      width="80%;"
      title="A test webhook notification template."
      alt="A screenshot of a test webhook notification template."
      src={accountsWebhookNotificationTemplate}
    />
  </Collapser>

  <Collapser
    className="freq-link"
    id="xMatters_templates"
    title="xMatters"
  >
    ### xMatters용 웹후크 템플릿

    Webhook 템플릿을 사용하여 Workflows에서 xMatters로 알림을 보냅니다.

    ```json
    {
    {{#if nrAccountId}}"account_id": {{nrAccountId}},{{/if}}
    "account_name": {{json accumulations.tag.account.[0]}},
    {{#if accumulations.tag.action}}"action":{{json accumulations.tag.action.[0]}},{{/if}}
    "closed_violations_count": {
        "critical": {{#if closedIncidentsCount}}{{closedIncidentsCount}}{{else}}0{{/if}},
        "warning": 0,
        "total": {{#if closedIncidentsCount}}{{closedIncidentsCount}}{{else}}0{{/if}}
    },
    "condition_family_id": {{accumulations.conditionFamilyId.[0]}},
    "condition_id": {{accumulations.conditionFamilyId.[0]}},
    "condition_name": {{json accumulations.conditionName.[0]}},
    {{#if accumulations.evaluationName}}"condition_metric_name": {{json accumulations.evaluationName.[0]}},{{/if}}
    {{#if accumulations.evaluationMetricValueFunction}}"condition_metric_value_function": {{json accumulations.evaluationMetricValueFunction.[0]}},{{/if}}
    "current_state": {{#if issueClosedAt}}"closed"{{else if issueAcknowledgedAt}}"acknowledged"{{else}}"open"{{/if}},
    "details": {{json issueTitle}},
    "duration": {{#if issueDurationMs}}{{issueDurationMs}}{{else}}0{{/if}},
    "event_type": "INCIDENT",
    "incident_acknowledge_url": {{json issueAckUrl}},
    "incident_url": {{json issuePageUrl}},
    "incident_id": {{json issueId}},
    "metadata": {
        {{#if locationStatusesObject}}"location_statuses": {{locationStatusesObject}},{{/if}}
        {{#if accumulations.metadata_entity_type}}"entity.type": {{json accumulations.metadata_entity_type.[0]}},{{/if}}
        {{#if accumulations.metadata_entity_name}}"entity.name": {{json accumulations.metadata_entity_name.[0]}}{{/if}}
    },
    "open_violations_count": {
        "critical": {{#if openIncidentsCount}}{{openIncidentsCount}}{{else}}0{{/if}},
        "warning": 0,
        "total": {{#if openIncidentsCount}}{{openIncidentsCount}}{{else}}0{{/if}}
    },
    "policy_name": {{json accumulations.policyName.[0]}},
    {{#if policyUrl}}"policy_url": {{json policyUrl}},{{/if}}
    "radar_entity": {
        "accountId": {{json accumulations.tag.accountId.[0]}},
        "domain": {{json accumulations.conditionProduct.[0]}},
        "domainId": {{json issueId}},
        "entityGuid": {{json entitiesData.entities.[0].id}},
        "name": {{#if accumulations.targetName}}{{json accumulations.targetName.[0]}}{{else if entitiesData.entities}}{{json entitiesData.entities.[0].name}}{{else}}"NA"{{/if}},
        "type": {{#if entitiesData.types.[0]}}{{json entitiesData.types.[0]}}{{else}}"NA"{{/if}}
    },
    {{#if accumulations.runbookUrl}}"runbook_url": {{json accumulations.runbookUrl.[0]}},{{/if}}
    "severity": {{#eq HIGH priority}}"WARNING"{{else}}{{json priority}}{{/eq}},
    "state": {{json state}},
    "status": {{json status}},
    "targets": [
        {
            "id": {{#if entitiesData.entities.[0].id}}{{json entitiesData.entities.[0].id}}{{else if accumulations.nrqlEventType}}{{json accumulations.nrqlEventType.[0]}}{{else}}"N/A"{{/if}},
            "name": {{#if accumulations.targetName}}{{json accumulations.targetName.[0]}}{{else if entitiesData.entities}}{{json entitiesData.entities.[0].name}}{{else}}"NA"{{/if}},
            "link": {{json issuePageUrl}},
            "product": {{json accumulations.conditionProduct.[0]}},
            "type": {{#if entitiesData.types.[0]}}{{json entitiesData.types.[0]}}{{else}}"NA"{{/if}},
            "labels": {
                {{#each accumulations.rawTag}}{{#if this.[0]}}"{{@key}}":{{json this.[0]}},{{/if}}{{/each}}
                "NewRelic": "targetLabels"
            }
        }
    ],
    "timestamp": {{#if closedAt}}{{closedAt}}{{else if acknowledgedAt}}{{acknowledgedAt}}{{else}}{{createdAt}}{{/if}},
    "timestamp_utc_string": {{json issueUpdatedAt}},
    "version": "1.0",
    {{#if accumulations.conditionDescription}}"VIOLATION DESCRIPTION": {{json accumulations.conditionDescription.[0]}},{{/if}}
    {{#if violationChartUrl}}"violation_chart_url": {{json violationChartUrl}},{{/if}}
    "violation_callback_url": {{json issuePageUrl}}
    }
    ```
  </Collapser>
</CollapserGroup>

## 레거시 Slack 대상을 새 Slack 대상으로 마이그레이션 [#migrate-slack]

레거시 Slack 대상을 새 Slack 대상으로 마이그레이션하려면 다음 단계를 따르십시오.

1. [새 Slack 대상을](/docs/alerts-applied-intelligence/notifications/notification-integrations/#slack-prereqs)설정합니다.

2. 레거시 Slack 대상으로 보내는 각 워크플로에 대해 다음을 수행합니다.

   * 레거시 알림과 함께 전송된 Slack 채널을 찾아 저장합니다.

   <img
     width="80%;"
     title="Migrate Slack, create a new workflow."
     alt="Migrate Slack, create a new workflow."
     src={accountsMigrateSlackNewWorkflow}
   />

   * 알림을 테스트하여 작동하는지 확인합니다.

   * 기존 레거시 Slack 알리미를 제거합니다.

     <img
       width="80%;"
       title="Migrate Slack, remove the existing legacy slack notifier."
       alt="Migrate Slack, remove the existing legacy slack notifier."
       src={accountsMigrateSlackRemoveLegacy}
     />

   * **Test workflow** \[테스트 워크플로를] 클릭하여 필터와 일치하는 실제 문제(있는 경우)를 확인합니다.

   * 워크플로를 저장합니다.

## API 옵션 [#api]

NerdGraph API를 사용하여 [목적지](/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-destinations) 와 [알림 채널](/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-channels) 을 보고 구성할 수도 있습니다.