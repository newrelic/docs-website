---
title: 네트워크 모니터링을 위한 고급 구성
tags:
  - Integrations
  - Network monitoring
  - Advanced configuration
metaDescription: Advanced configuration options for network monitoring
freshnessValidatedDate: never
translationType: machine
---

네트워크 모니터링을 구성할 때 사용할 수 있는 모든 옵션을 살펴보려면 다음 섹션을 참조하세요.

## `snmp-base.yaml` 샘플 파일 [#snmp-base-yml-template]

다음은 SNMP 및 플로우 데이터 장치를 폴링하기 위해 `ktranslate` Docker 이미지에서 사용하는 `snmp-base.yaml` 파일에서 사용할 수 있는 다양한 설정 옵션의 예입니다. 또한 [GitHub의 KTranslate 저장소](https://github.com/kentik/ktranslate/blob/main/config/snmp.yaml.sample) 에서 주석이 많이 달린 샘플을 볼 수도 있습니다.

```yaml
# Configuration of every device monitored by this container
devices:
  # Sample of SNMP v2c device
  ups_snmpv2c__10.10.0.201:
    device_name: ups_snmpv2c
    device_ip: 10.10.0.201
    snmp_comm: $YOUR_COMMUNITY_STRING
    oid: .1.3.6.1.4.1.318.1.3.27
    description: "APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: apc_ups.yml
    provider: kentik-ups
    poll_time_sec: 300
    retries: 1
    timeout_ms: 5000
    user_tags:
      owning_team: dc_ops
    discovered_mibs:
    - PowerNet-MIB_UPS
    - TCP-MIB
    - UDP-MIB
    purge_after_num: 1
  # Sample of SNMP v3 device
  router_snmpv3__10.10.0.202:
    device_name: router_snmpv3
    device_ip: 10.10.0.202
    snmp_v3:
      user_name: $YOUR_USER_NAME
      authentication_protocol: $YOUR_AUTH_PROTOCOL
      authentication_passphrase: $YOUR_AUTH_PASSPHRASE
      privacy_protocol: $YOUR_PRIVACY_PROTOCOL
      privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
    oid: .1.3.6.1.4.1.9.1.544
    description: "Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version
      15.1(3)T4, RELEASE SOFTWARE (fc1)\r\nTechnical Support: http://www.cisco.com/techsupport\r\nCopyright
      (c) 1986-2012 by Cisco Systems, Inc.\r\nCompiled Thu 24-May-12 04:27 by prod_rel_team"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: cisco-asr.yml
    provider: kentik-router
    user_tags:
      owning_team: core-networking
    discovered_mibs:
    - BGP4-MIB
    - CISCO-MEMORY-POOL-MIB
    - CISCO-PROCESS-MIB
    - IF-MIB
    - OSPF-MIB
    engine_id: "80:00:01:01:0a:14:1e:28"
    match_attributes:
      if_interface_name: "^Ten.*|^Gig.*"
      "!if_Alias": "[Uu]plink"
  # Sample of SNMP v1 device
  netbotz_snmpv1__10.10.0.203:
    device_name: netbotz_snmpv1
    device_ip: 10.10.0.201
    snmp_comm: $YOUR_COMMUNITY_STRING
    use_snmp_v1: true
    oid: .1.3.6.1.4.1.5528.100.20.10.2013
    description: "Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: apc-netbotz.yml
    provider: kentik-netbotz
    user_tags:
      owning_team: sys_ops
    discovered_mibs:
    - IF-MIB
    - IP-MIB
    - TCP-MIB
    - UDP-MIB
    no_use_bulkwalkall: true
  # Sample of "flow only" device
  flow_only__10.10.0.210:
    device_name: flow_only
    device_ip: 10.10.0.210
    user_tags:
      owning_team: net_eng
    flow_only: true
  # Sample of "ping only" device
  ping_only__10.10.0.220:
    device_name: ping_only
    device_ip: 10.10.0.220
    provider: kentik-ping
    user_tags:
      owning_team: load_balancing
    ping_only: true
    ping_interval_sec: 5
  # Sample of Arista eAPI device
  arista_eapi_10.10.0.230:
    device_name: arista_eapi
    device_ip: 10.10.0.230
    snmp_comm: public
    oid: .1.3.6.1.4.1.30065.1.3011.7020.3735.24.2878.2
    description: "Arista Networks EOS version 4.22.9M running on an Arista
      Networks DCS-7020SR-24C2"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: arista-switch.yml
    provider: kentik-switch
    discovered_mibs:
    - ARISTA-BGP4V2-MIB
    - ARISTA-QUEUE-MIB
    - BGP4-MIB
    - HOST-RESOURCES-MIB
    - IF-MIB
    ext:
      ext_only: false
      eapi_config:
        username: $YOUR_ARISTA_API_USERNAME
        password: $YOUR_ARISTA_API_PASSWORD
        transport: https
        port: 443
  # Sample of Meraki Dashboard API device
  meraki_dashboard_api:
    device_name: meraki_controller
    device_ip: snmp.meraki.com
    provider: meraki-cloud-controller
    ext:
      ext_only: true
      meraki_config:
        api_key: $YOUR_MERAKI_API_KEY
        monitor_devices: true
        monitor_org_changes: true
        monitor_uplinks: true
        monitor_vpn_status: true
        organizations:
          - "Top Org.*"
        networks:
          - "Production"
          - "Guest"
        product_types:
          - appliance
        preferences:
          device_status_only: true
          hide_uplink_usage: false
          show_vpn_peers: true
          show_network_attr: true
# Configuration for receipt of SNMP Traps
trap:
  listen: 0.0.0.0:1620
  community: public
  version: ""
  transport: ""
  v3_config: null
  trap_only: false
  drop_undefined: false
# Configuration for the SNMP discovery job
discovery:
  cidrs:
  - 10.0.0.0/24
  - 10.0.0.202/32
  ignore_list:
  - 10.0.0.98
  - 10.0.0.99
  debug: false
  ports:
  - 161
  - 1161
  default_communities:
  - $YOUR_COMMUNITY_STRING_1
  - $YOUR_COMMUNITY_STRING_2
  - $YOUR_COMMUNITY_STRING_3
  use_snmp_v1: false
  default_v3: null
  add_mibs: true
  threads: 4
  add_devices: true
  replace_devices: true
  no_dedup_engine_id: false
  check_all_ips: true
global:
  poll_time_sec: 60
  drop_if_outside_poll: false
  mib_profile_dir: /etc/ktranslate/profiles
  mibs_db: /etc/ktranslate/mibs.db
  mibs_enabled:
  - ARISTA-BGP4V2-MIB
  - ARISTA-QUEUE-MIB
  - BGP4-MIB
  - CISCO-MEMORY-POOL-MIB
  - CISCO-PROCESS-MIB
  - HOST-RESOURCES-MIB
  - IF-MIB
  - OSPF-MIB
  - PowerNet-MIB_UPS
  timeout_ms: 3000
  retries: 0
  global_v3: null
  response_time: false
  user_tags:
    environment: production
  match_attributes:
    if_Description: ".*WAN.*"
  purge_devices_after_num: 0
```

<CollapserGroup>
  <Collapser
    id="devices"
    title="장치 섹션"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            키 이름
          </th>

          <th>
            필수의
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            장치 이름
          </td>

          <td>
            ✓
          </td>

          <td>
            장치의 이름입니다. 이것은 New Relic에 있는 장치의 고유 식별자입니다.
          </td>
        </tr>

        <tr>
          <td>
            device_ip
          </td>

          <td>
            ✓
          </td>

          <td>
            장치의 대상 IP입니다.
          </td>
        </tr>

        <tr>
          <td>
            snmp_comm
          </td>

          <td>
            ✓ (SNMPv1/2c에 필요)
          </td>

          <td>
            `SNMPv1/2c` 사용할 커뮤니티 문자열입니다.
          </td>
        </tr>

        <tr>
          <td>
            use_snmp_v1
          </td>

          <td>
            ✓ (SNMPv1에 필요)
          </td>

          <td>
            SNMPv1을 사용할지 여부를 나타냅니다. 기본적으로 `false` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            snmp_v3
          </td>

          <td>
            ✓ (SNMPv3에 필요)
          </td>

          <td>
            [SNMP v3 구성](#snmpv3-config)
          </td>
        </tr>

        <tr>
          <td>
            디버그
          </td>

          <td/>

          <td>
            SNMP 폴링 중에 디버그 수준 로깅을 활성화할지 여부를 나타냅니다. 기본적으로 `false` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            포트
          </td>

          <td/>

          <td>
            SNMP 쿼리를 보낼 포트입니다. 기본적으로 포트 `161` 로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            이드
          </td>

          <td>
            ✓ (SNMP 폴링에 필요)
          </td>

          <td>
            기기에 대해 검색된 `systemObjectID | sysObjectID | sysOID` 입니다. 이것은 기기를 알려진 SNMP 프로필과 일치시키고 `provider` 속성을 설정하는 데 사용됩니다. 일치하는 항목이 없으면 `provider` 를 [kentik 기본](/docs/network-performance-monitoring/troubleshooting/snmp-discovery-kentik-default) 장치로 설정합니다.
          </td>
        </tr>

        <tr>
          <td>
            description
          </td>

          <td/>

          <td>
            기기의 검색된 `sysDescr` 입니다. 이 필드는 정보용입니다.
          </td>
        </tr>

        <tr>
          <td>
            last_checked
          </td>

          <td/>

          <td>
            타임스탬프는 이 장치가 `ktranslate` Docker 이미지에 의해 마지막으로 발견된 시간입니다. 이 필드는 정보 제공용입니다.
          </td>
        </tr>

        <tr>
          <td>
            mib_profile
          </td>

          <td>
            ✓ (SNMP 폴링에 필요)
          </td>

          <td>
            `sysOID` 을(를) 기반으로 검색 실행 중에 이 장치와 연결된 SNMP 프로필 파일입니다. <DNT>**If this starts with a bang (!) token, it will override the automatic matching from the `sysOID` and use a manual override.**</DNT> 예: `"!cisco-asa.yml"` (따옴표가 필요함).
          </td>
        </tr>

        <tr>
          <td>
            공급자
          </td>

          <td>
            ✓ (New Relic에 필요)
          </td>

          <td>
            New Relic의 엔티티 합성 시 사용되는 값입니다. 이는 일치하는 `mib_profile` 을 기반으로 자동 생성되며 엔터티가 생성되려면 [엔터티 정의](https://github.com/newrelic/entity-definitions/search?q=%22attribute%3A+provider%22+filename%3Adefinition.yml) 저장소의 규칙 중 하나와 일치해야 합니다. 장치를 수동으로 추가하는 경우 이 값이 유효한지 주의해야 합니다.
          </td>
        </tr>

        <tr>
          <td>
            poll_time_sec
          </td>

          <td/>

          <td>
            SNMP 폴링 빈도를 초 단위로 나타냅니다. 이 설정은 `global.poll_time_sec` 속성을 재정의하는 데 사용됩니다.
          </td>
        </tr>

        <tr>
          <td>
            재시도
          </td>

          <td/>

          <td>
            SNMP OID 폴링 재시도 횟수를 나타냅니다. 이 설정은 `global.retries` 속성을 재정의하는 데 사용됩니다.
          </td>
        </tr>

        <tr>
          <td>
            timeout_ms
          </td>

          <td/>

          <td>
            SNMP 폴링 시간 초과를 밀리초 단위로 나타냅니다. 이 설정은 `global.timeout_ms` 속성을 재정의하는 데 사용됩니다.
          </td>
        </tr>

        <tr>
          <td>
            user_tags
          </td>

          <td/>

          <td>
            `key:value` 장치에 더 많은 컨텍스트를 제공하기 위해 속성을 쌍으로 구성합니다. 이 수준의 태그는 `global.user_tags` 속성에 적용된 모든 태그에 추가됩니다.
          </td>
        </tr>

        <tr>
          <td>
            발견된\_mibs
          </td>

          <td/>

          <td>
            이 기기가 응답할 수 있는 일치하는 `mib_profile` 에서 가져온 MIB 목록입니다. 이 필드는 정보용입니다.
          </td>
        </tr>

        <tr>
          <td>
            engine_id
          </td>

          <td/>

          <td>
            이 장치의 SNMP 에이전트에 대해 검색된 고유 엔진 ID입니다. 일반적으로 SNMP v3 검색 중에 발견됩니다. 이 필드는 정보용입니다.
          </td>
        </tr>

        <tr>
          <td>
            match_attributes
          </td>

          <td/>

          <td>
            `attribute:regex` 허용 목록에 메트릭을 추가하는 쌍입니다. 이 수준의 쌍은 `global.match_attributes` 속성에 적용된 모든 쌍에 추가됩니다. [RE2](https://github.com/google/re2/wiki/Syntax) 구문을 사용하고 기본 `OR` 연산자가 있습니다. `AND` 연산자를 강제 실행하려면 접두사 키에 `!` 를 붙입니다.
          </td>
        </tr>

        <tr>
          <td>
            monitor_admin_shut
          </td>

          <td/>

          <td>
            `Administratively Shutdown` 상태의 인터페이스를 모니터링할지 여부를 나타냅니다. 기본적으로 `false` 로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            no_use_bulkwalkall
          </td>

          <td/>

          <td>
            `true` 때 SNMP `GETBULK` 요청 작업을 비활성화합니다. 기본적으로 `false` 로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            응답 시간
          </td>

          <td/>

          <td>
            이 장치에 대해 [응답 시간](#response_time-attribute) 폴링이 활성화되었는지 여부를 나타냅니다. 기본적으로 `false` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            ping_only
          </td>

          <td/>

          <td>
            모든 SNMP 폴링을 비활성화하고 `true`일 때 이 장치에 대한 [응답 시간](#response_time-attribute) 폴링을 활성화합니다. 이 설정은 `global.response_time` 속성을 재정의합니다. 기본적으로 `false`로 설정되어 있습니다. 각 ping_only 장치에 대해 `provider: kentik_ping` 행을 포함했는지 확인하고 싶을 것입니다.
          </td>
        </tr>

        <tr>
          <td>
            ping_interval_sec
          </td>

          <td/>

          <td>
            이 설정은 `ping_only` \| `response_time` 폴링.
          </td>
        </tr>

        <tr>
          <td>
            flow_only
          </td>

          <td/>

          <td>
            `true` 일 때 모든 SNMP 폴링을 비활성화합니다. 기본적으로 `false` 로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            purge_after_num
          </td>

          <td/>

          <td>
            X개의 예약된 검색 작업이 실패한 후 구성 파일에서 장치를 제거합니다. <DNT>**This setting overrides the global `purge_devices_after_num` setting.**</DNT> 기기를 영구적으로 유지하려면 이를 `-1` 로 설정하고, 퍼지 레버 값을 설정하려면 정수 >= `1` 로 설정하세요. (기본값: `0`)
          </td>
        </tr>

        <tr>
          <td>
            내선
          </td>

          <td>
            ✓ (API 폴링에 필요)
          </td>

          <td>
            [API 폴링 구성](#optional-api-polling-configurations)
          </td>
        </tr>

        <tr>
          <td>
            ext.ext_only
          </td>

          <td/>

          <td>
            이 `device_name` 구성에 대한 모든 SNMP 폴링을 비활성화합니다. 기본값: `false`.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="trap"
    title="트랩 섹션"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            키 이름
          </th>

          <th>
            필수의
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            듣다
          </td>

          <td>
            ✓
          </td>

          <td>
            SNMP 트랩을 수신하기 위한 수신 IP 포트입니다. 기본적으로 `0.0.0.0:1620` 으로 설정되어 있으며 `docker run ...` 명령에서 리디렉션을 사용하여 호스트의 보다 일반적인 UDP 162를 컨테이너의 UDP 1620으로 리디렉션합니다. 리디렉션은 이 플래그로 수행됩니다. `-p 162:1620/udp`
          </td>
        </tr>

        <tr>
          <td>
            지역 사회
          </td>

          <td/>

          <td>
            SNMP 트랩을 수신하기 위한 SNMPv1/v2c 커뮤니티 문자열입니다. 기본적으로 우리는 들어오는 트랩이 이 커뮤니티와 일치하지 않더라도 계속 처리합니다.
          </td>
        </tr>

        <tr>
          <td>
            버전
          </td>

          <td/>

          <td>
            사용할 SNMP 버전입니다. 옵션은 `v1` , `v2c` 및 `v3` 입니다. 기본적으로 `v2c` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            수송
          </td>

          <td/>

          <td>
            사용할 SNMP 전송 프로토콜입니다. 옵션은 `TCP` 및 `UDP` 입니다. 기본적으로 다음으로 설정되어 있습니다. `UDP`
          </td>
        </tr>

        <tr>
          <td>
            v3_config
          </td>

          <td/>

          <td>
            사용할 [SNMP v3 구성](#snmpv3-config) 입니다. `version: v3` 경우에만 사용됩니다.
          </td>
        </tr>

        <tr>
          <td>
            trap_only
          </td>

          <td/>

          <td>
            이를 `true` 로 설정하면 들어오는 트랩만 수신 대기하는 컨테이너를 원하는 경우에 사용되는 SNMP 또는 ICMP 폴링을 컨테이너가 시도하지 못하게 됩니다.
          </td>
        </tr>

        <tr>
          <td>
            드롭\_미정의
          </td>

          <td/>

          <td>
            이를 `true` 으로 설정하면 컨테이너가 기존 SNMP 프로필에 명시적으로 정의되지 않은 SNMP 트랩 메시지를 전달하는 것을 방지할 수 있습니다. (기본값: `false`)
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="discovery"
    title="디스커버리 섹션"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            키 이름
          </th>

          <th>
            필수의
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            사이다
          </td>

          <td>
            ✓
          </td>

          <td>
            [CIDR 표기법](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)의 대상 IP 범위 배열입니다. [시간 제한을 피하려면](/docs/network-performance-monitoring/troubleshooting/snmp-discovery-no-devices)이러한 범위의 크기에 주의하십시오.
          </td>
        </tr>

        <tr>
          <td>
            무시 목록
          </td>

          <td/>

          <td>
            모든 검색 작업 중에 명시적으로 무시하려는 IP 주소의 배열입니다.
          </td>
        </tr>

        <tr>
          <td>
            디버그
          </td>

          <td/>

          <td>
            검색 중에 디버그 수준 로깅을 활성화할지 여부를 나타냅니다. 기본적으로 다음으로 설정되어 있습니다. `false`
          </td>
        </tr>

        <tr>
          <td>
            항구
          </td>

          <td>
            ✓
          </td>

          <td>
            SNMP 폴링 중에 스캔할 대상 포트의 배열입니다.
          </td>
        </tr>

        <tr>
          <td>
            default_communities
          </td>

          <td>
            ✓ (SNMPv1/2c에 필요)
          </td>

          <td>
            SNMP 폴링 중에 스캔할 SNMPv1/v2c 커뮤니티 문자열의 배열입니다. 이 배열은 순서대로 평가되고 발견은 첫 번째 통과 커뮤니티를 수락합니다.
          </td>
        </tr>

        <tr>
          <td>
            use_snmp_v1
          </td>

          <td>
            ✓ (SNMPv1에 필요)
          </td>

          <td>
            검색 중에 SNMPv1을 사용할지 여부를 나타냅니다. 기본적으로 다음으로 설정되어 있습니다. `false`
          </td>
        </tr>

        <tr>
          <td>
            default_v3
          </td>

          <td>
            ✓ (SNMPv3에 필요)
          </td>

          <td>
            SNMP 폴링 중 스캔할 단일 [SNMPv3 구성](#snmpv3-config) .
          </td>
        </tr>

        <tr>
          <td>
            other_v3s
          </td>

          <td>
            ✓ (SNMPv3에 필요)
          </td>

          <td>
            SNMP 폴링 중에 검색할 다중 [SNMPv3 설정](#snmpv3-config) . <DNT>**Use this option OR `default_v3`, not both**</DNT>
          </td>
        </tr>

        <tr>
          <td>
            add_devices
          </td>

          <td>
            ✓
          </td>

          <td>
            검색된 기기를 `snmp-base.yaml` 파일의 `devices` 섹션에 추가할지 여부를 나타냅니다. 기본적으로 `true` 로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            add_mibs
          </td>

          <td>
            ✓
          </td>

          <td>
            검색된 MIB를 `snmp-base.yaml` 파일의 `global.mibs_enabled` 섹션에 추가할지 여부를 나타냅니다. 기본적으로 `true` 로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            스레드
          </td>

          <td>
            ✓
          </td>

          <td>
            검색 중에 사용할 스레드의 정수 제한입니다. 컨테이너에서 사용할 수 있는 코어 수보다 작아야 합니다. 기본적으로 `4` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            replace_devices
          </td>

          <td>
            ✓
          </td>

          <td>
            검색된 기기가 `snmp-base.yaml` 파일의 `devices` 섹션에 이미 있는 경우 교체할지 여부를 나타냅니다. 기본적으로 `true` 로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            no_dedup_engine_id
          </td>

          <td/>

          <td>
            `true` 으로 설정하면 보고된 SNMP 엔진 ID를 기반으로 검색된 장치가 동일한 장치로 표시되는 경우 해당 장치의 중복 제거가 비활성화됩니다. 기본적으로 다음으로 설정되어 있습니다. `false`
          </td>
        </tr>

        <tr>
          <td>
            check_all_ips
          </td>

          <td/>

          <td>
            `true` 으로 설정하면 검색 작업이 TCP 포트 스캔을 통해 활성 상태를 먼저 확인하지 않고 `cidrs` 배열의 모든 대상 IP 주소에 대해 SNMP 연결을 시도하도록 합니다. 이 설정은 검색 작업의 속도를 늦추지만 `/32` 재정의를 사용하여 `cidrs` 어레이에 나열되지 않은 기기에 대해 검색이 실패하는 문제를 우회하는 데 도움이 될 수 있습니다. 기본적으로 다음으로 설정되어 있습니다. `false`
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="global"
    title="글로벌 섹션"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            키 이름
          </th>

          <th>
            필수의
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            poll_time_sec
          </td>

          <td>
            ✓
          </td>

          <td>
            장치를 폴링하는 시간(초)입니다. `devices.<deviceName>.poll_time_sec` 속성을 사용하여 기기별로 재정의할 수 있습니다. 기본적으로 `60` 로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            drop_if_outside_poll
          </td>

          <td/>

          <td>
            폴링이 `poll_time_sec` 에 설정된 값보다 오래 걸리는 경우 이 주기에서 모든 값을 삭제할지 여부를 나타냅니다. 기본적으로는 `false` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            mib_profile_dir
          </td>

          <td/>

          <td>
            선별된 MIB 프로필을 찾기 위한 디렉터리입니다. 이는 Kentik의 [snmp-profiles](https://github.com/kentik/snmp-profiles) 저장소에서 자동으로 `ktranslate` 이미지로 가져오며 Docker 런타임에 프로필의 로컬 디렉터리에 대한 볼륨 마운트를 만들어 재정의할 수 있습니다.
          </td>
        </tr>

        <tr>
          <td>
            mibs_db
          </td>

          <td/>

          <td/>
        </tr>

        <tr>
          <td>
            mibs_enabled
          </td>

          <td>
            ✓
          </td>

          <td>
            모든 활성 MIB 중 `ktranslate` Docker 이미지가 폴링됩니다. 이 목록은 `discovery_add_mibs` 속성이 `true` 인 경우 검색 중에 자동으로 생성됩니다. 여기에 나열되지 않은 MIB는 설정 파일의 어떤 장치에서도 폴링되지 않습니다. `MIB-NAME.tableName` 구문을 사용하여 MIB 파일에서 직접 SNMP 테이블을 지정할 수 있습니다. 예: `HOST-RESOURCES-MIB.hrProcessorTable`.
          </td>
        </tr>

        <tr>
          <td>
            timeout_ms
          </td>

          <td>
            ✓
          </td>

          <td>
            SNMP 쿼리 시간 초과 시간(밀리초)입니다. 이는 `devices.<deviceName>.timeout_ms` 속성을 사용하여 기기별로 재정의할 수 있습니다. 기본적으로는 `3000` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            재시도
          </td>

          <td>
            ✓
          </td>

          <td>
            실패한 SNMP 폴링을 재시도하려는 시도 횟수입니다. 이는 `devices.<deviceName>.retries` 속성을 사용하여 기기별로 재정의할 수 있습니다. 기본적으로는 `0` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            user_tags
          </td>

          <td/>

          <td>
            `key:value` 장치에 더 많은 컨텍스트를 제공하기 위해 속성을 쌍으로 구성합니다. 이 수준의 태그는 구성 파일의 모든 장치에 적용됩니다.
          </td>
        </tr>

        <tr>
          <td>
            match_attributes
          </td>

          <td/>

          <td>
            `attribute:regex` 허용 목록에 메트릭을 추가하는 쌍입니다. 이 수준의 쌍은 구성 파일의 모든 장치와 일치합니다. [RE2](https://github.com/google/re2/wiki/Syntax) 구문을 사용하고 기본 `OR` 연산자가 있습니다. `AND` 연산자를 강제 실행하려면 접두사 키 `!` .
          </td>
        </tr>

        <tr>
          <td>
            응답 시간
          </td>

          <td/>

          <td>
            구성 파일의 모든 장치에 대해 [응답 시간](#response_time-attribute) 폴링이 활성화되었는지 여부를 나타냅니다. 기본적으로 `false` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            purge_devices_after_num
          </td>

          <td/>

          <td>
            X개의 예약된 검색 작업이 실패한 후 구성 파일에서 장치를 제거합니다. 기기를 영구적으로 보관하려면 이를 `-1` 로 설정하고, 삭제 청년 값을 설정하려면 정수 >= `1` 로 설정하세요. 기본적으로는 `0` 으로 설정됩니다.
          </td>
        </tr>

        <tr>
          <td>
            [watch_profile_changes](#watch-profile-changes)
          </td>

          <td/>

          <td>
            `mib_profile_dir` 경로의 프로필 변경 시 [SNMP 스레드를 다시 로드](#reload-snmp-threads) 하도록 감시자를 설정합니다. 기본적으로는 `false` 으로 설정됩니다.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## 클라우드 제공업체 비밀 [#cloud-provider-secrets]

네트워크 모니터링 에이전트에는 [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/), [Azure Key Vault](https://learn.microsoft.com/en-us/azure/key-vault/general/) 및 [GCP Secret Manager](https://cloud.google.com/secret-manager/docs) 에서 키를 검색하는 기능이 기본적으로 지원됩니다.

<Callout variant="important">
  SNMPv1 및 SNMPv2c는 프로토콜 자체가 기본적으로 일반 텍스트를 통해 커뮤니티 문자열을 보내기 때문에 클라우드 비밀 사용을 지원하지 않습니다. SNMP 인증의 보안이 우려되는 경우 SNMPv3을 사용하도록 업데이트하세요.
</Callout>

<Collapser
  id="cloud-secrets"
  title="클라우드 비밀 설정"
>
  <Tabs>
    <TabsBar>
      <TabsBarItem id="aws-secrets-manager">
        AWS 비밀 관리자
      </TabsBarItem>

      <TabsBarItem id="azure-key-vault">
        Azure 키 자격 증명 모음
      </TabsBarItem>

      <TabsBarItem id="gcp-secret-manager">
        GCP 비밀 관리자
      </TabsBarItem>
    </TabsBar>

    <TabsPages>
      <TabsPageItem id="aws-secrets-manager">
        AWS Secrets Manager를 사용하려면 다음 세 가지 [환경 변수를](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html#envvars-list) 설정하고 런타임 시 docker 에 제공해야 합니다.

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                이름
              </th>

              <th>
                설명
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `AWS_ACCESS_KEY_ID`
              </td>

              <td>
                사용자를 인증하기 위한 자격 증명의 일부로 사용되는 AWS 액세스 키를 지정합니다.
              </td>
            </tr>

            <tr>
              <td>
                `AWS_SECRET_ACCESS_KEY`
              </td>

              <td>
                사용자를 인증하기 위한 자격 증명의 일부로 사용되는 AWS 보안 키를 지정합니다.
              </td>
            </tr>

            <tr>
              <td>
                `AWS_REGION`
              </td>

              <td>
                요청을 보낼 AWS 리전을 지정합니다.
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \
        -e AWS_ACCESS_KEY_ID=$YOUR_AWS_ACCESS_KEY_ID \
        -e AWS_SECRET_ACCESS_KEY=$YOUR_AWS_SECRET_ACCESS_KEY \
        -e AWS_REGION=$YOUR_AWS_REGION \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>

      <TabsPageItem id="azure-key-vault">
        Azure Key Vault를 사용하려면 다음 5가지 환경 변수를 설정하고 런타임 시 docker 에 제공해야 합니다.

        <Callout variant="tip">
          `KT_AZURE_KEY_VAULT_NAME` 또는 `KT_AZURE_KEY_VAULT_URL` 중 하나를 설정해야 하며 둘 다 설정할 필요는 없습니다. 기본값은 `KT_AZURE_KEY_VAULT_NAME` 사용하는 것이며 에이전트는 공통 URL 패턴을 사용합니다. `https://$KT_AZURE_KEY_VAULT_NAME.vault.azure.net/`
        </Callout>

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                이름
              </th>

              <th>
                설명
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `KT_AZURE_KEY_VAULT_NAME`
              </td>

              <td>
                비밀이 저장되는 저장소 이름입니다.
              </td>
            </tr>

            <tr>
              <td>
                `KT_AZURE_KEY_VAULT_URL`
              </td>

              <td>
                부채, 목표에 대한 API 호출에 대한 선택적 전체 URL입니다.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_CLIENT_ID](https://learn.microsoft.com/en-us/entra/identity-platform/howto-create-service-principal-portal#sign-in-to-the-application)
              </td>

              <td>
                `Application ID` 이라고도 하며 이는 비밀에 액세스하는 데 사용되는 서비스 주체의 식별자입니다.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_CLIENT_SECRET](https://learn.microsoft.com/en-us/entra/identity-platform/howto-create-service-principal-portal#option-3-create-a-new-client-secret)
              </td>

              <td>
                인증 중에 서비스 주체에 사용되는 클라이언트 비밀(비밀번호)입니다. 이 ID는 클라이언트 비밀번호의 <DNT>**value**</DNT> 용이며 비밀번호 자체의 ID가 아닙니다.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_SUBSCRIPTION_ID](https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id#find-your-azure-subscription)
              </td>

              <td>
                이는 비밀이 관리되는 구독과 연결된 32자리 GUID입니다.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_TENANT_ID](https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id#find-your-microsoft-entra-tenant)
              </td>

              <td>
                `Directory ID` 이라고도 하며 이는 서비스 원칙이 저장되는 Microsoft Entra의 테넌트에 대한 식별자입니다.
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -e KT_AZURE_KEY_VAULT_NAME=$YOUR_KEY_VAULT_NAME \
        #### Optional: Provide the full URL to target
        # -e KT_AZURE_KEY_VAULT_URL=$YOUR_KEY_VAULT_URL \
        -e AZURE_CLIENT_ID=$YOUR_CLIENT_ID \
        -e AZURE_CLIENT_SECRET=$YOUR_CLIENT_SECRET \
        -e AZURE_TENANT_ID=$YOUR_TENANT_ID \
        -e AZURE_SUBSCRIPTION_ID=$YOUR_SUBSCRIPTION_ID \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>

      <TabsPageItem id="gcp-secret-manager">
        GCP Secret Manager를 사용하려면 두 가지 환경 변수와 함께 사용자 인증 정보 JSON 파일에 대해 다음 볼륨 마운트를 설정하고 이를 런타임 시 docker 에 제공해야 합니다.

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                이름
              </th>

              <th>
                설명
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                [서비스 계정 키](https://cloud.google.com/iam/docs/keys-create-delete#creating)
              </td>

              <td>
                사용자를 인증하는 데 사용되는 서비스 계정 키의 로컬 파일 경로를 지정합니다. 이 파일은 docker 컨테이너에 볼륨이 마운트된 후 `GOOGLE_APPLICATION_CREDENTIALS` 환경 변수에서 참조됩니다.
              </td>
            </tr>

            <tr>
              <td>
                [GOOGLE_APPLICATION_CREDENTIALS](https://cloud.google.com/docs/authentication/provide-credentials-adc#local-key)
              </td>

              <td>
                서비스 계정 키 파일을 매핑한 컨테이너의 파일 경로를 지정합니다.
              </td>
            </tr>

            <tr>
              <td>
                [GOOGLE_CLOUD_PROJECT](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
              </td>

              <td>
                비밀이 저장되는 고유 프로젝트 ID를 지정합니다.
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -v $YOUR_LOCAL_SERVICE_ACCOUNT_KEY_FILE_PATH:/gcp_snmp_sa_key.json \
        -e GOOGLE_APPLICATION_CREDENTIALS='./gcp_snmp_sa_key.json' \
        -e GOOGLE_CLOUD_PROJECT=$YOUR_PROJECT_ID \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>
    </TabsPages>
  </Tabs>
</Collapser>

## SNMPv3 옵션 [#snmpv3-options]

<CollapserGroup>
  <Collapser
    id="snmpv3-config"
    title="SNMPv3 구성"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            키 이름
          </th>

          <th>
            필수의
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            사용자 이름
          </td>

          <td>
            ✓
          </td>

          <td>
            SNMPv3 인증을 위한 사용자 이름
          </td>
        </tr>

        <tr>
          <td>
            인증 프로토콜
          </td>

          <td>
            ✓
          </td>

          <td>
            SNMPv3 인증 프로토콜. 가능한 값은 `NoAuth` , `MD5` 또는 `SHA`
          </td>
        </tr>

        <tr>
          <td>
            인증\_암호구
          </td>

          <td/>

          <td>
            SNMPv3 인증 암호
          </td>
        </tr>

        <tr>
          <td>
            프라이버시\_프로토콜
          </td>

          <td>
            ✓
          </td>

          <td>
            SNMPv3 개인 정보 보호 프로토콜. 가능한 값은 `NoPriv` , `DES` , `AES` , `AES192` , `AES256` , `AES192C` 또는 `AES256C`
          </td>
        </tr>

        <tr>
          <td>
            개인 정보 보호 문구
          </td>

          <td/>

          <td>
            SNMPv3 개인 정보 암호
          </td>
        </tr>

        <tr>
          <td>
            context_engine_id
          </td>

          <td/>

          <td>
            SNMPv3 컨텍스트 엔진 ID
          </td>
        </tr>

        <tr>
          <td>
            컨텍스트 이름
          </td>

          <td/>

          <td>
            SNMPv3 컨텍스트 이름
          </td>
        </tr>
      </tbody>
    </table>

    ### 예:

    <Callout variant="tip">
      AWS, Azure, GCP의 비밀을 사용하려면 에이전트가 목표 API를 쿼리하는 데 필요한 [적절한 환경 변수와 기타 인증 정보를 제공](/docs/network-performance-monitoring/advanced/advanced-config/#cloud-secrets) 해야 합니다.
    </Callout>

    <Tabs>
      <TabsBar>
        <TabsBarItem id="v3-plain-text">
          일반 텍스트
        </TabsBarItem>

        <TabsBarItem id="v3-aws-secret">
          AWS 비밀
        </TabsBarItem>

        <TabsBarItem id="v3-azure-secret">
          Azure 비밀
        </TabsBarItem>

        <TabsBarItem id="v3-gcp-secret">
          GCP 비밀
        </TabsBarItem>
      </TabsBar>

      <TabsPages>
        <TabsPageItem id="v3-plain-text">
          ```yaml
          discovery:
            default_v3:
              user_name: $YOUR_SNMPV3_USER
              authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
              authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
              privacy_protocol: $YOUR_PRIVACY_PROTOCOL
              privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-aws-secret">
          ```yaml
          discovery:
            default_v3: aws.sm.$YOUR_SECRET_NAME
          ```

          AWS에서는 모든 관련 `key:value` 쌍이 포함된 [JSON 구조로 비밀을 저장](https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_secret_json_structure.html) 해야 합니다. 이것은 예입니다:

          ```json
          {
          "user_name": "$YOUR_SNMPV3_USER",
          "authentication_protocol": "$YOUR_AUTHENTICATION_PROTOCOL",
          "authentication_passphrase": "$YOUR_AUTHENTICATION_PASSPHRASE",
          "privacy_protocol": "$YOUR_PRIVACY_PROTOCOL",
          "privacy_passphrase": "$YOUR_PRIVACY_PASSPHRASE"
          }
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-azure-secret">
          ```yaml
          discovery:
            default_v3: azure.kv.$YOUR_SECRET_NAME
          ```

          Azure에서는 모든 관련 `key:value` 쌍이 포함된 [여러 줄 구조로 비밀을 저장](https://learn.microsoft.com/en-us/azure/key-vault/secrets/multiline-secrets) 해야 합니다. 이것은 예입니다:

          ```
          user_name: $YOUR_SNMPV3_USER
          authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
          authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
          privacy_protocol: $YOUR_PRIVACY_PROTOCOL
          privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-gcp-secret">
          ```yaml
          discovery:
            default_v3: gcp.sm.$YOUR_SECRET_NAME
          ```

          GCP에서는 모든 관련 `key:value` 쌍이 포함된 [여러 줄 구조로 비밀을 저장](https://cloud.google.com/secret-manager/docs/create-secret-quickstart) 해야 합니다. 이것은 예입니다:

          ```
          user_name: $YOUR_SNMPV3_USER
          authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
          authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
          privacy_protocol: $YOUR_PRIVACY_PROTOCOL
          privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>
      </TabsPages>
    </Tabs>
  </Collapser>

  <Collapser
    id="multiple-v3-discovery"
    title="여러 SNMP v3 프로필로 검색 실행"
  >
    여러 SNMP v3 프로필로 검색 작업 실행을 지원하려면 `discovery.default_v3` 키를 [SNMPv3 구성](#snmpv3-config) 의 배열을 보유하는 `discovery.other_v3s` 키로 바꿀 수 있습니다.

    ```yaml
    discovery:
      other_v3s:
      - user_name: $YOUR_USER_NAME_1
        authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL_1
        authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE_1
        privacy_protocol: $YOUR_PRIVACY_PROTOCOL_1
        privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE_1
        context_engine_id: ""
        context_name: ""
      - user_name: $YOUR_USER_NAME_2
        authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL_2
        authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE_2
        privacy_protocol: $YOUR_PRIVACY_PROTOCOL_1
        privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE_2
        context_engine_id: ""
        context_name: ""
    ```

    이는 클라우드 공급자 비밀 관리자를 사용해도 작동할 수 있습니다. AWS의 예:

    ```yaml
    discovery:
      other_v3s:
      - aws.sm.$YOUR_SECRET_NAME_1
      - aws.sm.$YOUR_SECRET_NAME_2
    ```
  </Collapser>
</CollapserGroup>

## API 폴링 구성 [#api-polling-configurations]

<Callout variant="tip">
  API 인증 설정에서 클라우드 공급자 비밀을 사용할 수도 있습니다.
</Callout>

<CollapserGroup>
  <Collapser
    id="arista"
    title="아리스타 eAPI"
  >
    [Arista eAPI](https://www.arista.com/assets/data/pdf/Whitepapers/Arista_eAPI_FINAL.pdf) 통합은 일반적으로 SNMP 폴링을 통해 사용할 수 없는 추가 BGP 및 MLAG 원격 측정을 수집합니다.

    * BGP 세부정보는 다음 명령에서 수집됩니다. `show ip bgp summary vrf all`

      BGP 원격 측정을 찾기 위한 NRQL:

      ```sql
      FROM Metric SELECT
        max(kentik.eapi.bgp.InMsgQueue) AS 'InQ', // Messages Queued from the Neighbor
        max(kentik.eapi.bgp.MsgReceived) AS 'MsgSent', // Messages Received from the Neighbor
        max(kentik.eapi.bgp.MsgSent) AS 'MsgRcvd', // Messages Sent to the Neighbor
        latest(peer_state) AS 'State', // State of the BGP session
        latest(kentik.eapi.bgp.UpDownTime) AS 'Up/Down', // Period the BGP session has been in current state
        latest(kentik.eapi.bgp.Version) AS 'V' // BGP version number
      FACET
        entity.name AS 'Device',
        router_id AS 'Device IP',
        peer AS 'BGP Peer',
        peer_asn AS 'BGP Peer ASN',
        vrf AS 'VRF Name'
      ```

      <br/>

    * MLAG 세부정보는 다음 명령에서 수집됩니다. `show mlag detail`

      MLAG 원격 측정을 찾는 NRQL:

      ```sql
      FROM Metric SELECT
        latest(kentik.eapi.mlag.PortsConfigured) AS 'Ports Configured', // Count of MLAG ports currently configured
        latest(kentik.eapi.mlag.PortsDisabled) AS 'Ports Disabled', // Count of MLAG ports in 'Disabled' state
        latest(kentik.eapi.mlag.PortsActivePartial) AS 'Ports Active-partial', // Count of MLAG ports in 'Active-partial' state 
        latest(kentik.eapi.mlag.PortsInactive) AS 'Ports Inactive', // Count of MLAG ports in 'Inactive' state
        latest(kentik.eapi.mlag.PortsActiveFull) AS 'Ports Active-full', // Count of MLAG ports in 'Active-full' state
        latest(kentik.eapi.mlag.PortsErrdisabled) AS 'Ports Err-disabled', // Count of MLAG ports in 'Err-disabled' state
        latest(config_sanity) AS 'Config-Sanity', // Current result of 'config-sanity' check
        latest(state) AS 'State', // Current MLAG state
        latest(neg_status) AS 'Negotiation Status', // Current negotiation status between switches
        latest(peer_address) AS 'Peer Address', // Address of MLAG peer
        latest(peer_link) AS 'Peer Link', // Link name for MLAG peer
        latest(peer_link_status) AS 'Peer Link Status', // Status of MLAG peer
        latest(local_interface) AS 'Local Interface', // Local interface used for MLAG configuration
        latest(local_intf_status) AS 'Local Interface Status' // Status of local interface used for MLAG configuration
      FACET
        entity.name AS 'Device',
        domain_id AS 'MLAG Domain ID'
      ```

      ### 구성 옵션

      <table>
        <thead>
          <tr>
            <th style={{ width: "200px" }}>
              키 이름
            </th>

            <th>
              필수의
            </th>

            <th>
              설명
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              eapi_config.사용자 이름
            </td>

            <td>
              ✓
            </td>

            <td>
              eAPI 인증을 인증하기 위해 장치에 전달할 사용자 이름입니다.
            </td>
          </tr>

          <tr>
            <td>
              eapi_config.password
            </td>

            <td>
              ✓
            </td>

            <td>
              eAPI 인증을 인증하기 위해 장치에 전달할 비밀번호입니다.
            </td>
          </tr>

          <tr>
            <td>
              eapi_config.transport
            </td>

            <td/>

            <td>
              사용할 연결 전송 유형을 지정합니다. 가능한 값은 `https` 및 `http` 입니다. 기본값: `https`.
            </td>
          </tr>

          <tr>
            <td>
              eapi_config.port
            </td>

            <td>
              ✓
            </td>

            <td>
              eAPI 연결을 위한 끝점의 TCP 포트입니다.
            </td>
          </tr>
        </tbody>
      </table>
  </Collapser>

  <Collapser
    id="meraki"
    title="메라키 대시보드 API"
  >
    [Meraki 대시보드 API](https://developer.cisco.com/meraki/api/) 통합은 Meraki 환경의 상태와 관련된 다양한 지표를 가져옵니다. 설정 옵션의 조합을 사용하면 필요에 따라 다양한 모니터링 시나리오를 설정하고 뉴렐릭 계정에 일부를 생성할 수 있습니다.

    <CollapserGroup>
      <Collapser
        id="meraki-organization"
        title="메라키 조직 구성"
      >
        조직 지표는 기본적으로 `Meraki Organization` 부문을 생성하는 데만 사용되는 `kentik.meraki.organization.Count` 지표 아래에 수집됩니다. 이는 주로 Meraki 계층 구조를 시각화하여 네트워크와 장치를 상위 조직에 정렬하기 위한 것입니다.

        * `meraki_config.monitor_org_changes: true`: [조직 구성 변경 가져오기](https://developer.cisco.com/meraki/api/get-organization-configuration-changes/) 끝점을 사용하여 조직의 변경 로그를 봅니다.

          조직 구성 변경 원격 분석을 찾는 NRQL:

          ```sql
          FROM KExtEvent SELECT *
          ```
      </Collapser>

      <Collapser
        id="meraki-network"
        title="Meraki Network 부분"
      >
        * `meraki_config.preferences.show_network_attr: true`

          네트워크 지표는 `Meraki Network` 부문을 생성하는 데만 사용되는 `kentik.meraki.network.Count` 지표 아래에 수집됩니다. 이는 주로 Meraki 계층 구조를 시각화하고 장치를 구성원인 네트워크에 정렬하기 위한 것입니다.
      </Collapser>

      <Collapser
        id="meraki-device"
        title="Meraki 장치 부분"
      >
        * `meraki_config.monitor_devices: true && meraki_config.preferences.device_status_only: true`: [조직 장치 상태 가져오기](https://developer.cisco.com/meraki/api/get-organization-devices-statuses/) 엔드포인트를 사용하여 조직의 모든 Meraki 장치 상태를 나열합니다.

          장치 상태 원격 분석을 찾기 위한 NRQL:

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Device Status' // Current status of this device
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            src_addr AS 'Device Public IP',
            mac AS 'Device MAC',
            model AS 'Device Model',
            serial AS 'Device Serial',
            address AS 'Device Address',
            lat AS 'Device Latitude',
            lng AS 'Device Longitude',
            notes AS 'Device Notes'
          WHERE instrumentation.name = 'meraki.device_status'
          ```

          <br/>

        * `meraki_config.monitor_uplinks: true && meraki_config.preferences.hide_uplink_usage: false`: [조직 업링크 상태 가져오기](https://developer.cisco.com/meraki/api/get-organization-uplinks-statuses/) 및 [네트워크 엔드포인트별 조직 어플라이언스 업링크 사용량 가져오기를](https://developer.cisco.com/meraki/api/get-organization-appliance-uplinks-usage-by-network/) 모두 사용하여 조직의 모든 Meraki MX, MG 및 Z 시리즈 장치의 업링크 상태와 성능을 나열합니다.

          장치 업링크 원격 측정을 찾기 위한 NRQL:

          ```sql
          FROM Metric SELECT
            max(kentik.meraki.uplinks.LatencyMS) AS 'Uplink Latency', // Uplink measured latency in milliseconds
            max(kentik.meraki.uplinks.LossPct) AS 'Uplink Loss %', // Uplink measured loss percentage
            max(kentik.meraki.uplinks.Recv) AS 'Uplink Receive Bytes', // Uplink bytes received
            max(kentik.meraki.uplinks.Sent) AS 'Uplink Transmit Bytes', // Uplink bytes sent
            latest(status) AS 'Uplink Status' // Latest status of the uplink
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            interface AS 'Device Uplink Interface',
            model AS 'Device Model',
            serial AS 'Device Serial'
          WHERE org_id IS NOT NULL
          ```

          <br/>

        * `meraki_config.monitor_uplinks: true && meraki_config.preferences.hide_uplink_usage: true`: [조직 업링크 상태 가져오기](https://developer.cisco.com/meraki/api/get-organization-uplinks-statuses/) 엔드포인트를 사용하여 조직에 있는 모든 Meraki MX, MG 및 Z 시리즈 장치의 업링크 상태만 나열합니다.

          장치 업링크 상태 원격 측정을 찾기 위한 NRQL:

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Uplink Status' // Latest status of the uplink
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            interface AS 'Device Uplink Interface',
            model AS 'Device Model',
            serial AS 'Device Serial'
          WHERE org_id IS NOT NULL
          ```

          <br/>

        * `meraki_config.monitor_vpn_status: true && meraki_config.preferences.show_vpn_peers: false`: [Get Organization Appliance VPN Statuses](https://developer.cisco.com/meraki/api/get-organization-appliance-vpn-statuses/) 엔드포인트를 사용하여 조직의 네트워크 전반에 걸쳐 VPN 상태를 표시합니다.

          VPN 상태 원격 측정을 찾기 위한 NRQL:

          ```sql
          FROM Metric SELECT
            latest(status) AS 'VPN Status' // Latest status of this VPN
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            serial AS 'Device Serial',
            vpn_mode AS 'VPN Mode',
            wan1 OR wan2 AS 'WAN Interface IP'
          WHERE instrumentation.name = 'meraki.vpn_status'
          AND org_id IS NOT NULL
          ```

          <br/>

        * `meraki_config.monitor_vpn_status: true && meraki_config.preferences.show_vpn_peers: true`: [조직 어플라이언스 VPN 상태 가져오기](https://developer.cisco.com/meraki/api/get-organization-appliance-vpn-statuses/) 끝점을 사용하여 조직의 네트워크 전반에 걸쳐 VPN 피어에 대한 정보를 추가합니다.

          VPN 피어 원격 측정을 찾기 위한 NRQL:

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Peer Status' // Current status of this VPN peer
          FACET
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            serial AS 'Device Serial',
            vpn_mode AS 'VPN Mode',
            wan1 AS 'WAN 1 IP',
            wan2 AS 'WAN 2 IP',
            peer_name AS 'Peer Name', // Name of this peer
            peer_reachability AS 'Peer Reachability', // Latest results of reachability test for this peer
            peer_network_id AS 'Peer Network ID', // Network ID for this peer
            peer_type AS 'Peer Type' // Type of Peer (Meraki vs Third-party)
          WHERE metricName = 'kentik.meraki.vpn_status.PeerStatus'
          ```
      </Collapser>

      <Collapser
        id="meraki-config-options"
        title="Meraki 설정 옵션"
      >
        <Collapser
          id="meraki-primary-config"
          title="기본 구성 옵션"
        >
          <Callout variant="tip">
            [API](/docs/network-performance-monitoring/advanced/ktranslate-container-management/#container-runtime-options) 환경 변수를 사용하면 API 키를 설정 파일에 일반 텍스트로 저장하지 않고 Meraki 통합에 전달할 수 있습니다.
          </Callout>

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  키 이름
                </th>

                <th>
                  필수의
                </th>

                <th>
                  입력
                </th>

                <th>
                  설명
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki_config.api_key
                </td>

                <td>
                  ✓ ( [KENTIK_MERAKI_API_KEY](/docs/network-performance-monitoring/advanced/ktranslate-container-management) 환경 변수를 사용하는 경우 필요하지 않음)
                </td>

                <td>
                  API 키(문자열)
                </td>

                <td>
                  인증을 위한 [Meraki 대시보드 API 키입니다](https://documentation.meraki.com/General_Administration/Other_Topics/Cisco_Meraki_Dashboard_API#Enable_API_Access) .
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.max_http_retry
                </td>

                <td/>

                <td>
                  1-10 사이의 정수(기본값: 2)
                </td>

                <td>
                  `HTTP 429` 오류를 반환하는 API 요청에 대해 재시도 빈도를 제어하는 선택적 설정입니다. 재시도 간격은 5초입니다.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_devices
                </td>

                <td/>

                <td>
                  사실 | 거짓(기본값: 거짓)
                </td>

                <td>
                  조직의 모든 Meraki 장치 상태를 모니터링합니다.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_org_changes
                </td>

                <td/>

                <td>
                  사실 | 거짓(기본값: 거짓)
                </td>

                <td>
                  조직의 변경 로그를 모니터링합니다.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_uplinks
                </td>

                <td/>

                <td>
                  사실 | 거짓(기본값: 참)
                </td>

                <td>
                  조직의 모든 Meraki MX, MG 및 Z 시리즈 장치의 업링크 상태와 성능을 모니터링합니다.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_vpn_status
                </td>

                <td/>

                <td>
                  사실 | 거짓(기본값: 거짓)
                </td>

                <td>
                  조직의 네트워크 전체에서 VPN 상태를 모니터링합니다.
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser
          id="meraki-filter-config"
          title="필터링 옵션"
        >
          이러한 옵션을 사용하면 Meraki 환경에서 특정 대상 개체로 모니터링을 제한할 수 있습니다.

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  키 이름
                </th>

                <th>
                  필수의
                </th>

                <th>
                  입력
                </th>

                <th>
                  설명
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki_config.organizations
                </td>

                <td/>

                <td>
                  [RE2 구문](https://github.com/google/re2/wiki/Syntax) 의 정규식(기본값: null)
                </td>

                <td>
                  모든 모니터링을 특정 조직 목록으로 필터링합니다.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.networks
                </td>

                <td/>

                <td>
                  [RE2 구문](https://github.com/google/re2/wiki/Syntax) 의 정규식(기본값: null)
                </td>

                <td>
                  모든 모니터링을 특정 네트워크 목록으로 필터링합니다.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.product_types
                </td>

                <td/>

                <td>
                  유효한 유형은 무선, 어플라이언스, 스위치, 시스템 관리자, 카메라, CellularGateway, 센서 및 cloudGateway입니다. (기본값: null)
                </td>

                <td>
                  특정 유형의 장치를 필터링하기 위해 [monitor_devices](https://developer.cisco.com/meraki/api/get-organization-devices-statuses/) API 요청에 매개변수를 추가합니다.
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser
          id="meraki-additional-config"
          title="추가 환경설정"
        >
          이러한 옵션을 사용하면 기본 구성 옵션에서 수집된 데이터를 추가로 정의할 수 있습니다. 위의 예시 섹션에는 다양한 조합이 설명되어 있습니다.

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  키 이름
                </th>

                <th>
                  필수의
                </th>

                <th>
                  입력
                </th>

                <th>
                  설명
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki_config.preferences.device_status_only
                </td>

                <td/>

                <td>
                  사실 | 거짓(기본값: 거짓)
                </td>

                <td>
                  폴링을 상태 정보로만 제한하기 위해 `monitor_devices: true` 사용할 때 _필요합니다_ . <DNT>**(This is used to prevent timeout issues.)**</DNT>
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.preferences.hide_uplink_usage
                </td>

                <td/>

                <td>
                  사실 | 거짓(기본값: 거짓)
                </td>

                <td>
                  성능 측정항목을 제거하고 업링크에 대한 상태 정보만 반환하기 위해 `monitor_uplinks` 와 함께 사용됩니다.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.preferences.show_vpn_peers
                </td>

                <td/>

                <td>
                  사실 | 거짓(기본값: 거짓)
                </td>

                <td>
                  VPN 피어에 원격 분석을 추가하기 위해 `monitor_vpn_status` 과 함께 사용됩니다.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.preferences.show_network_attr
                </td>

                <td/>

                <td>
                  사실 | 거짓(기본값: 거짓)
                </td>

                <td>
                  네트워크에 텔레메트리를 추가하는 데 사용됩니다. `Meraki Network` 부분을 생성하는 데 필요합니다.
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>
      </Collapser>

      ### 최소 구성 예 [#meraki-minimum-config]

      ```yaml
      # This represents the minimal configuration required for a container that only performs Meraki API polling.
      # By default we only monitor uplinks. All other items are optional.
      ---
       devices:
          meraki_cloud_controller:
            device_name: meraki_cloud_controller
            device_ip: snmp.meraki.com
            provider: meraki-cloud-controller
            ext:
              ext_only: true
              meraki_config:
                api_key: "$YOUR_API_KEY"
       trap: {}
       discovery: {}
       global:
         poll_time_sec: 300
         timeout_ms: 30000
      ```

      ### 전체 설정 예시 [#meraki-full-config]

      #### `Meraki Organization`, `Meraki Network` 및 `Meraki Device` 부문을 생성하는 데 필요한 모든 옵션입니다.

      ```yaml
      devices:
        meraki_dashboard_api:
          device_name: meraki_controller
          device_ip: snmp.meraki.com
          provider: meraki-cloud-controller
          ext:
            ext_only: true
            meraki_config:
              api_key: $YOUR_MERAKI_API_KEY
              monitor_devices: true
              monitor_org_changes: true
              monitor_uplinks: true
              monitor_vpn_status: true
              preferences:
                device_status_only: true
                hide_uplink_usage: false
                show_vpn_peers: true
                show_network_attr: true
      trap: {}
      discovery: {}
      global:
        poll_time_sec: 300
        timeout_ms: 30000
      ```

      #### 여러 Meraki 대시보드 API 키 타겟팅

      ```yaml
      devices:
         # Entity 1 - monitor everything this API key has access to
         meraki_all:
           device_name: meraki_all
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_1"
               max_http_retry: 8
               monitor_devices: true
               monitor_org_changes: true
               monitor_uplinks: true
               monitor_vpn_status: true
               preferences:
                 device_status_only: true
                 show_vpn_peers: true
                 hide_uplink_usage: false
         # Entity 2 - Monitor these specific organizations under this API key
         meraki_single_org:
           device_name: meraki_single_org
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_2"
               monitor_devices: true
               monitor_org_changes: true
               monitor_uplinks: true
               monitor_vpn_status: true
               preferences:
                 device_status_only: true
                 show_vpn_peers: true
                 hide_uplink_usage: false
               organizations:
                 - "Org 1 - Prod.*"
                 - "Org 2 - Staging"
         # Entity 3 - Monitor specific devices filtered by organization, network, and product types; using the same API key from Entity 2
         meraki_filtered:
           device_name: meraki_filtered
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_2"
               monitor_devices: true
               monitor_uplinks: false
               preferences:
                 device_status_only: true
               organizations:
                 - "Org 3 - Remote Sites"
               networks:
                 - "Corp.*99"
                 - "Retail.*"
               product_types:
                 - wireless
                 - appliance
      trap: {}
      discovery: {}
      global:
        poll_time_sec: 300
        timeout_ms: 30000
      ```
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

## 외부 구성 파일 [#external-config-files]

다양한 설정 및 자동화 요구 사항을 지원하기 위해 docker 컨테이너에 볼륨 마운트하는 외부 파일을 사용하여 표준 설정 파일의 특정 요소를 분리할 수 있습니다. 외부 설정 파일당 하나의 인수와 함께 `docker run` 명령에 아래 마운트 인수를 포함해야 합니다.

```
-v `pwd`/fileName.yaml:/fileName.yaml \
```

이러한 파일의 구문은 큰따옴표를 포함하여 `"@fileName.yaml"` 입니다.

<CollapserGroup>
  <Collapser
    id="discovery-cidrs-file"
    title="디스커버리 CIDR"
  >
    예시:

    ```yaml
    discovery:
      cidrs: "@cidrs.yaml"
    ```

    CIDR 파일은 다음과 같은 YAML 목록 구문을 사용해야 합니다.

    ```yaml
    - 10.10.0.0/24
    - 10.20.0.0/24
    - 192.168.0.21/32
    ```
  </Collapser>

  <Collapser
    id="devices-file"
    title="장치"
  >
    예시:

    ```yaml
    devices:
      "@neteng-devices.yaml"
    ```

    기기 파일은 기본 구성 파일의 표준 `devices` 섹션과 동일한 구문을 사용해야 하며 검색 중에 생성되는 선택적 필드는 생략해야 합니다.

    ```yaml
    devices:
      # Sample of SNMP v2c device
      ups_snmpv2c__10.10.0.201:
        device_name: ups_snmpv2c
        device_ip: 10.10.0.201
        snmp_comm: $YOUR_COMMUNITY_STRING
        oid: .1.3.6.1.4.1.318.1.3.27
        mib_profile: apc_ups.yml
        provider: kentik-ups
        poll_time_sec: 300
        retries: 1
        timeout_ms: 5000
        user_tags:
          owning_team: dc_ops
    ```
  </Collapser>
</CollapserGroup>

## `match_attributes` 속성 [#match_attributes-attribute]

관찰 가능성 요구 사항에 대한 값을 생성하지 않는 데이터 필터링을 지원하기 위해 `global.match_attributes.{}` 및/또는 `devices.[].match_attributes.{}` 속성 맵을 설정할 수 있습니다.

이는 데이터를 New Relic으로 전달하기 전에 `ktranslate` 수준에서 필터링을 제공하여 인터페이스와 같은 항목의 모니터링을 세부적으로 제어할 수 있게 해줍니다.

이 맵의 기본 동작은 `OR` 조건이지만 키 이름에 `!` 접두사를 추가하여 이 조건을 재정의하고 `AND` 연산자를 강제 실행할 수 있습니다. 이는 일치하는 항목만 반환하고 모든 `null` 및 `""` (빈) 결과를 생략하는 데에도 유용합니다.

<CollapserGroup>
  <Collapser
    id="default-or-null"
    title="null 및 빈 값이 있는 기본 'OR'"
  >
    `if_Alias` `Uplink` 로 시작할 때 일치합니다. <DNT>**OR**</DNT> `if_interface_name` `Gig` 로 시작할 때 모든 `null` 및 `""` 값을 유지합니다.

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          if_Alias: "^Uplink.*"
          if_interface_name: "^Gig.*"
    ```
  </Collapser>

  <Collapser
    id="and-no-null"
    title="'AND', null 및 빈 값 생략"
  >
    `if_Alias` `Uplink` 로 시작하는 경우 일치 <DNT>**AND**</DNT> `if_interface_name` `Gig` 로 시작하는 경우 모든 `null` 및 `""` 값을 삭제합니다.

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          if_Alias: "^Uplink.*"
          "!if_interface_name": "^Gig.*"
    ```
  </Collapser>

  <Collapser
    id="single-no-null"
    title="단일 일치, null 및 빈 값 생략"
  >
    `if_Alias` 이 `Uplink` 로 시작하는 경우 일치하고 모든 `null` 및 `""` 값을 삭제합니다.

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          "!if_Alias": "^Uplink.*"
    ```
  </Collapser>

  <Collapser
    id="negate-lookup"
    title="부정적인 예측을 만들어라"
  >
    Golang의 정규식 패키지는 기본적으로 부정 예측 패턴(`q(?!u)`)을 지원하지 않습니다. 이 문제를 해결하려면 `DOES_NOT_MATCH` 토큰을 속성 맵에 추가하여 일치 패턴의 반대 결과를 효과적으로 제공할 수 있습니다.

    예를 들어 `Uplink` 문자열을 포함 **하지 않는** 모든 인터페이스를 일치시키려면 다음과 같이 하십시오. 다음과 같은 설정을 사용할 수 있습니다.

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          "!if_Alias": "^Uplink.*"
          DOES_NOT_MATCH: true
    ```
  </Collapser>
</CollapserGroup>

## `response_time` 및 `ping_only` 속성 [#response_time-attribute]

성능 통계에 액세스할 수 없거나 사용할 수 없는 기기의 모니터링을 지원하거나 기본 RTT(왕복 시간) 모니터링이 필요한 간단한 경우에 `global.response_time` 또는 `devices.[].ping_only` 속성을 `true` 로 설정할 수 있습니다.

이 기능은 평균, 최소, 최대 및 stddev 왕복 시간(RTT)을 수집하기 위해 [go-ping](https://pkg.go.dev/github.com/sparrc/go-ping) 패키지를 사용하여 ICMP 또는 권한이 없는 UDP 패킷을 장치로 보냅니다. 또한 이 패키지는 `ktranslate` 에서 기기 IP 주소로 초당 1패킷 전송을 기준으로 엔드포인트에 대한 패킷 손실률을 보여줍니다. 이는 `devices.[].ping_interval_sec` 속성을 설정하여 재정의할 수 있습니다. Docker 런타임 중에 `KENTIK_PING_PRIV=false` 환경 변수를 설정하여 권한 있는 ICMP 패킷 또는 UDP의 기본 사용에서 전환할 수 있습니다.

`global.response_time` 속성을 `true` 로 설정하면 기존 SNMP 폴링 위에 RTT 모니터링이 추가됩니다. RTT용 UDP|ICMP 패킷만 있고 SNMP 폴링이 없는 장치를 모니터링하려면 `devices.[].ping_only: true` 를 사용합니다.

New Relic에서 다음 지표를 조사하여 이 폴링의 결과를 볼 수 있습니다.

```sql
FROM Metric SELECT
  average(kentik.ping.AvgRttMs) AS 'Average',
  max(kentik.ping.MaxRttMs) AS 'Max',
  min(kentik.ping.MinRttMs) AS 'Min',
  average(kentik.ping.StdDevRtt) AS 'StdDev',
  latest(kentik.ping.PacketLossPct) AS 'Packet Loss %'
FACET device_name
```

<Callout variant="tip">
  흐름 기기에서 RTT 측정항목을 수집하려는 경우 `flow_only` 속성 대신 `ping_only` 속성을 사용할 수 있습니다. `ping_only` 및 `flow_only` 이 모두 `true` 이면 기기는 `flow_only` 기기로 처리됩니다.
</Callout>

## `flow_only` 속성 [#flow_only-attribute]

흐름 데이터만 수집하려는 기기의 모니터링을 지원하려면 `devices.<deviceName>.flow_only` 속성을 `true` 로 설정할 수 있습니다.

그러면 `KFlow` 이벤트 네임스페이스에 텔넷리만 포함하는 <DNT>**Flow Device**</DNT> 부분이 생성됩니다. 또는 설정 파일에 있는 장치에서 SNMP 장치로 흐름 텔레메트리를 수집하면 <DNT>**Router**</DNT> 또는 <DNT>**Firewall**</DNT> 와 같은 기존 구성요소에 `KFlow` 데이터 장식이 추가됩니다.

New Relic에서 다음 이벤트를 조사하여 이 폴링의 결과를 볼 수 있습니다.

```sql
FROM KFlow SELECT *
WHERE instrumentation.name = 'netflow-events'
```

## 플로우 데이터 애플리케이션 매핑

기본적으로 흐름 원격 분석은 특정 흐름 대화에서 사용 중인 계층 4 포트의 평가를 기반으로 알려진 애플리케이션에 매핑됩니다. 필요한 경우 Docker 런타임 중에 `-application_map` 플래그에 YAML 파일을 제공하여 기본 매핑을 재정의할 수 있습니다. 이렇게 하면 식별한 포트를 기반으로 애플리케이션 이름을 지정할 수 있습니다.

구문 예:

```yaml
applications:
  - ports: [9092, 9093]
    name: kafka
  - ports: [80, 8080]
    name: http
  - ports: [443, 8443]
    name: https
```

## 플로우 데이터 입력 필터링

기본적으로 흐름 데이터 컨테이너는 수신하는 모든 흐름 패킷을 수집하고 처리합니다. 필요한 경우 `-nf.source` 플래그에 포함 필터를 추가하여 제공한 필터와 일치하지 않는 모든 트래픽을 무시할 수 있습니다.

<CollapserGroup>
  <Collapser
    id="flow-filter-options"
    title="흐름 필터 옵션"
  >
    통사론: `--filters $TYPE,$FIELD,$FUNCTION,$MATCH`

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            인수 이름
          </th>

          <th>
            필수의
          </th>

          <th>
            설명
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            $TYPE
          </td>

          <td>
            ✓
          </td>

          <td>
            적용할 필터의 유형입니다. 가능한 값은 `string` , `int` 및 `addr` 입니다.
          </td>
        </tr>

        <tr>
          <td>
            $필드
          </td>

          <td>
            ✓
          </td>

          <td>
            일치 패턴을 평가할 필드의 이름입니다.
          </td>
        </tr>

        <tr>
          <td>
            $FUNCTION
          </td>

          <td>
            ✓
          </td>

          <td>
            평가 중에 사용할 함수 유형입니다. 가능한 값은 `Equal: ==` , `NotEqual: !=` , `LessThan: <` , `GreaterThan: >` , `Contains: %`
          </td>
        </tr>

        <tr>
          <td>
            $MATCH
          </td>

          <td>
            ✓
          </td>

          <td>
            일치 패턴으로 사용할 값입니다.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="example-flow-filters"
    title="예시 필터"
  >
    * `10.0.0.0/24` CIDR 범위의 소스 주소에서만 흐름 데이터를 수집합니다.

      ```
      -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24
      ```

    * 대상 포트가 다음과 같지 않은 흐름 데이터만 수집합니다. `8531`

      ```
      -nf.source netflow5 --filters int,l4_dst_port,!=,8531
      ```

    * `10.0.0.0/24` CIDR 범위에 있고 대상 포트가 `8531` 과 같지 않은 소스 주소에서만 흐름 데이터를 수집합니다(암시적 `AND` 연산자).

      ```
      --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531
      ```
  </Collapser>
</CollapserGroup>

## 사용자 정의 SNMP 프로필 자동 다시 로드 [#reload-snmp-threads]

기본적으로 `ktranslate` docker [mib_profile_dir](#global) 경로의 SNMP 프로필에 대한 변경 사항을 통합하려면 컨테이너를 수동으로 삭제하고 다시 빌드해야 합니다. docker 이미지가 공개 [snmp-profiles 위치](https://github.com/kentik/snmp-profiles) 에서 사용 가능한 최신 프로필을 가져오므로 이는 대부분의 배포에서 정상적인 동작입니다. [사용자 정의 프로필을](/docs/network-performance-monitoring/advanced/snmp-profiles/#private) 제공하는 상황에서는 [watch_profile_changes](#global) 설정을 사용하여 컨테이너가 컨테이너의 기본 구성 및 SNMP 프로필을 자동으로 새로 고치도록 할 수 있습니다.

<Callout variant="important">
  이는 [감시자 라이브러리](https://github.com/fsnotify/fsnotify?tab=readme-ov-file#are-subdirectories-watched) 의 제한으로 인해 재귀적이지 않습니다. 따라서 하위 디렉터리에서 프로필이 변경되면 변경 사항을 트리거하기 위해 최상위 파일도 편집해야 합니다.
</Callout>

다음 디렉토리 구조를 가정하면:

```
.
└── /snmp-profiles/
    └── profiles/
        └── kentik-snmp/
            ├── 3com
            ├── _general
            ├── a10networks
            └── ...
```

이 새로 고침 주기를 트리거하려면 디렉터리 루트에 새 파일을 배치하고 수동으로 변경해야 합니다. 이를 구현하는 쉬운 방법은 변경사항이 제출될 때 `last_updated.txt` 과 같은 파일에 타임스탬프를 작성하는 것입니다.

```
.
└── /snmp-profiles/
    ├── last_updated.txt
    └── profiles/
        └── kentik-snmp/
            ├── 3com
            ├── _general
            ├── a10networks
            └── ...
```
