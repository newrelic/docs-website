---
title: 흐름흐름 정의 스키마
tags:
  - workflow automation
  - workflow schemas
  - workflow automation API
metaDescription: Workflow definitions are written in YAML. Keys use a camelCase naming convention.
freshnessValidatedDate: never
translationType: machine
---

<Callout title="시사">
  이 기능은 아직 개발 중이지만 꼭 사용해 보시기 바랍니다!

  이 기능은 현재 [출시 전 정책](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy) 에 따라 미리보기 프로그램의 일부로 제공됩니다.
</Callout>

## 개요

워크플로우 정의는 YAML로 작성됩니다. 키는 `camelCase` 명명 규칙을 사용합니다.

### 스키마 속성

<table>
  <thead>
    <tr>
      <th>
        재산
      </th>

      <th>
        필수 또는 선택
      </th>

      <th>
        유형
      </th>

      <th>
        체재
      </th>

      <th>
        제약
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`name`**
      </td>

      <td>
        필수의
      </td>

      <td>
        문자열
      </td>

      <td>
        정규 표현식을 준수해야 합니다. 

        `^[A-Za-z_][A-Za-z0-9_-]*$`
      </td>

      <td>
        **최대 길이**

        : 100
      </td>

      <td>
        **`name`**

         값은 대소문자를 구분하지 않습니다. 예를 들어, 

        `ExampleWorkflow`

        , 

        `exampleworkflow`

        , 

        `EXAMPLEWORKFLOW`

         은 모두 동일한 차트우 정의를 나타내는 것으로 간주됩니다.
      </td>
    </tr>

    <tr>
      <td>
        **`description`**
      </td>

      <td>
        선택 과목
      </td>

      <td>
        문자열
      </td>

      <td>
        정규 표현식을 준수해야 합니다. 

        `^[A-Za-z0-9 _-]*$`
      </td>

      <td>
        **최대 길이**

        : 200
      </td>

      <td>
        워크플로우의 목적을 설명하는 

        `description`

         입니다.
      </td>
    </tr>

    <tr>
      <td>
        **`workflowInputs`**
      </td>

      <td>
        선택 과목
      </td>

      <td />

      <td>
        지도의 지도
      </td>

      <td>
        **최대 크기**

        : 100
      </td>

      <td>
        워크플로우가 받아들이는 입력의 맵입니다. 자세한 속성은 아래를 참조하십시오.
      </td>
    </tr>
  </tbody>
</table>

### 워크플로 입력

**예** :

```yaml
    workflowInputs:
  myInput1:
    type: String
  myInput2:
    type: Number
    defaultValue: 42
```

* **`workflowInputs.<inputName>`** (필수)

  * **타입**: 문자열 ([표현식 안전 패턴](#expression-safe-pattern) 준수)
  * **최소 길이**: 1
  * **최대 길이**: 50
  * **설명**: 폴리스우 입력의 이름입니다.

* **`workflowInputs.<inputName>.type`** (필수)

  * **유형**: 열거형(`Boolean, List, Map, String, Int, Float`)
  * **설명**: 폴리스우 입력의 데이터 유형입니다.

* **`workflowInputs.<inputName>.defaultValue`** (선택 사항)

  * **유형**: 모든 유형; `type` 준수해야 합니다.
  * **설명**: 플레시아우 입력의 기본값입니다.

* **`workflowInputs.<inputName>.required`** (선택 사항)

  * **유형**: 부울(`True`, `False`).
  * **설명**: 이 필드의 기본값은 &quot;True&quot;입니다.

* **`workflowInputs.<inputName>.enumValues`** (선택 사항)

  * **유형**: 목록(`String`).
  * **설명**: 이 필드의 기본값은 빈 목록 `{}` 입니다. workflowInput 유형이 Enum인 경우 이 설정이 필요합니다.

* **`workflowInputs.<inputName>.validations`** (선택 사항)

  * **유형**: 지도가 없습니다.
  * **설명**: 사용자가 제공한 유효성 검사 입력에 대해 수행할 유효성 검사입니다. 이 항목은 선택 사항입니다. 여기에 설명된 속성은 모든 유효성 검사 유형에 존재합니다. 특정 유효성 검사 유형은 [유효성 검사 유형](#validation-types) 섹션에서 설명한 대로 추가 속성을 지원합니다.

* **`validations[*].type`** (필수)

  * **유형**: 문자열
  * **설명**: 이 필드에 대해 어떤 유효성 검사가 수행될지를 나타내는 유효성 검사 유형입니다. 각 유효성 검사 유형에 대한 자세한 내용은 [유효성 검사 유형을](#validation-types) 참조하십시오.

* **`validations[*].errorMessage`** (필수)

  * **유형**: 문자열
  * **설명**: 특정 유효성 검사가 실패했을 때 사용자가 원하는 오류 메시지입니다.

#### 유효성 검사를 위한 YAML 예시

```yaml
  name: calendar_demo

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'
      validations:
        - type: regex
          errorMessage: "The provided timezone is not correct"
          pattern: "^[A-Za-z]+\/[A-Za-z_]+(?:\/[A-Za-z_]+)?$"

        - type: maxLength
          errorMessage: "Timezone length should be less than 100"
          length: 100

    accountId:
      type: Int
      validations:
        - type: minIntValue
          errorMessage: "Account id should be greater than 100000"
          minValue: 100000
        - type: maxIntValue
          errorMessage: "Account id should be less than 9999999"
          maxValue: 9999999

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'
        selectors:
          - name: timezone
            expression: '.responseBody | fromjson.abbreviation'
          - name: datetime
            expression: '.responseBody | fromjson.datetime'
```

## 단계 [#steps]

<table>
  <thead>
    <tr>
      <th>
        재산
      </th>

      <th>
        필수 또는 선택
      </th>

      <th>
        유형
      </th>

      <th>
        제약
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`steps`**
      </td>

      <td>
        필수의
      </td>

      <td>
        지도의 재발
      </td>

      <td />

      <td>
        그루우 정의를 실행할 때 수행해야 하는 단계입니다. 최소한 한 단계는 있어야 합니다. 여기에 설명된 속성은 모든 단계 유형에 존재합니다. 특정 단계 유형은 

        [단계 유형](#step-types)

         섹션에 설명된 대로 추가 속성을 지원합니다.
      </td>
    </tr>
  </tbody>
</table>

<Callout variant="important">
  단계는 `steps` 에 정의된 순서대로 실행됩니다. 다른 순서를 원하는 경우 `jump` 수행할 수 있습니다. `steps[*].next` 속성을 건너뛸 원하는 단계의 이름으로 설정하십시오.
</Callout>

### 공통 단계 속성

<table>
  <thead>
    <tr>
      <th>
        재산
      </th>

      <th>
        필수 또는 선택
      </th>

      <th>
        유형
      </th>

      <th>
        체재
      </th>

      <th>
        제약
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`steps[*].name`**
      </td>

      <td>
        필수의
      </td>

      <td>
        문자열
      </td>

      <td>
        [표현식 안전 패턴을](#expression-safe-pattern)

         준수해야 하며 

        `end`

         될 수 없습니다.
      </td>

      <td>
        **최대 길이:**

         100
      </td>

      <td>
        `steps[*].next`

         에서 참조할 단계의 이름입니다. 특수 키워드 

        `end`

        , 

        `continue`

        , 

        `break`

         은 종료 단계, 루프의 연속 또는 루프에서 나가는 것을 나타내는 데 사용되므로 사용할 수 없습니다.
      </td>
    </tr>

    <tr>
      <td>
        **`steps[*].type`**
      </td>

      <td>
        필수의
      </td>

      <td>
        문자열
      </td>

      <td />

      <td />

      <td>
        단계 유형은 단계가 실행될 때 수행하는 작업을 나타냅니다. 사용 가능한 옵션은 아래의 

        [단계 유형을](#step-types)

         참조하십시오.
      </td>
    </tr>

    <tr>
      <td>
        **`steps[*].next`**
      </td>

      <td>
        선택 과목
      </td>

      <td>
        문자열
      </td>

      <td>
        표현 안전 패턴을 준수해야 합니다.
      </td>

      <td />

      <td>
        이 단계가 성공적으로 완료되면 실행될 다음 단계의 이름입니다. 특수 키워드 &apos;end&apos;를 사용하면 이 단계가 마지막으로 실행되어야 함을 나타낼 수 있습니다. 

        `next`

         생략되면 정의 

        `steps`

         의 다음 항목이 암묵적인 다음 단계로 사용됩니다. 후속 입력이 없으면, 해당 입력란이 완성됩니다.
      </td>
    </tr>

    <tr>
      <td>
        **`steps[*].ignoreErrors`**
      </td>

      <td>
        선택 과목
      </td>

      <td>
        부울
      </td>

      <td />

      <td />

      <td>
        `ignoreErrors`

         은(는) 워크플로우 단계 내의 설정 옵션입니다. 기본값은 false입니다. 

        `ignoreErrors`

         

        `true`

         로 설정함으로써, 이 단계 실행 중에 발생하는 오류가 전체 이 단계의 실패를 초래하지 않도록 합니다. 대신, 그라우는 후속 단계를 계속 실행합니다.
      </td>
    </tr>
  </tbody>
</table>

## 단계 유형 [#step-types]

### 동작 [#action]

특정 동작을 실행하는 단계입니다. 사용 가능한 옵션은 [액션 카탈로그를](/docs/workflow-automation/setup-and-configuration/actions-catalog/actions-catalog) 참조하십시오.

* **`steps[*].action`** (필수)

  * **유형**: 문자열
  * **설명**: 실행할 작업 함수의 정규화된 이름입니다. 다음 규칙을 따라야 합니다. `<company domain>.<category of work>.<action name in camelCase>`

**예** :

* 뉴렐릭 서비스를 사용한 작업(예: NerdGraph를 통해): `newrelic.dashboards.getDashboard`

* Slack을 사용한 작업: `slack.chat.postMessage`

* **`steps[*].version`** (필수)

  * **유형**: 문자열
  * **설명**: 실행할 작업 함수의 버전입니다.

* **`steps[*].inputs`** (선택 사항)

  * **유형**: 값 맵(표현식 포함)

  * **설명**:

    * 액션 함수에 전달할 입력입니다. 허용되는 구체적인 입력은 각 작업에 의해 정의됩니다.
    * 입력값에는 표현식을 사용할 수 있습니다. 자세한 내용은 표현식 문자열 섹션을 참조하십시오.

  <Callout variant="important">
    민감한 데이터(API 키나 비밀, PII, PHI 또는 개인 식별 데이터)는 인수로 전달되어서는 안 됩니다.
  </Callout>

* **`steps[*].inputs.selectors`** (선택 사항)

  * **유형**: `name` 형식의 맵 목록이며 `expression` 포함됩니다.

  * **설명**:

    * `selectors` 입력을 사용하면 지정된 요소만 반환하도록 출력을 재정의할 수 있습니다.
    * 표현식을 사용할 수 있습니다. 자세한 내용은 [표현식 문자열](#expression-strings) 섹션을 참조하십시오.

**예** :

* 제시된 예에서 우리는 http.get 작업의 응답으로 `timezone` 및 `datetime` 얻습니다.

```yaml
  name: calendar_demo

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'
    accountId:
      type: Int

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'
        selectors:
          - name: timezone
            expression: '.responseBody | fromjson.abbreviation'
          - name: datetime
            expression: '.responseBody | fromjson.datetime'
```

### 고리 [#loop]

루프는 `in` 으로 정의된 주어진 컬렉션을 반복하고 각 반복에 대해 루프 변수 `index` 과 `element` 를 생성합니다. 이러한 루프 변수는 표현식 `${{ .steps.<loopStepName>.loop.element }}` 또는 루프 내에서만 액세스할 수 있습니다. `${{ .steps.<loopStepName>.loop.index }`

자세한 내용은 다음을 참조하세요.

<CollapserGroup>
  <Collapser id="moreforloop" title="목록, 맵 또는 컬렉션을 반복하기 위한 루프">
    `loop` 을 사용하여 리스트, 맵 또는 컬렉션을 순회할 수 있습니다.

    루프는 `in` 으로 정의된 주어진 컬렉션을 순회합니다. 각 반복마다 자동으로 루프 변수 `index` 과 `element` 를 생성합니다. 이러한 루프 변수는 JQ 표현식 `${{ .steps.<loopStepName>.loop.element }}` 을 사용하여 루프 내에서 접근할 수 있습니다. `${{ .steps.<loopStepName>.loop.index }}`

    * `for` (필수의)

      * **유형**: 상수
      * **설명**: 루프의 시작 신호입니다.

    * `in` (필수의)

      * **유형**: 문자열(표현식)
      * **설명**: 요소 컬렉션으로 평가되어야 하는 표현식입니다.

    * `steps` (필수의)

      * **설명**: 루프의 각 반복에서 실행되는 단계입니다. 단계는 다른 루프를 포함한 모든 유형의 단계가 될 수 있습니다.

    **예시**:

    다음은 루프 `workflowInputs` 을 실행하는 방법을 보여줍니다. 참고로, 결과는 컬렉션 형식이어야 합니다.

    ```yaml
      name: myWorkflow
      steps:
        - name: loopStep
          type: loop
          for:
            in: '${{ .workflowInputs.count }}'
            steps:
              - name: step1
                type: action
                action: internal.example.sayHello
                version: '1'
                inputs:
                  name: 'Element : ${{ .steps.loopStep.loop.element }} , Index : ${{ .steps.loopStep.loop.index }}' # not exist outside of this loop
    ```

    <Callout variant="important">
      * `for`: (필수의). 이는 for 루프의 시작을 나타내는 최상위 요소입니다.
      * `in`: (필수의). 반복할 입력 컬렉션을 자바로 캐스팅할 수 있어야 합니다.
      * `steps`: (필수의). 각 반복마다 단계가 실행됩니다.
      * `element` `index` 은 루프의 일부로 자동으로 할당됩니다.
      * `index` 0부터 시작합니다.
      * `element` 복잡한 요소들의 모음이 있는 경우, 해당 요소는 복잡한 유형이 될 수 있습니다.
      * 반복문 내부에서 생성된 변수(반복문 변수 및 단계 출력)는 반복문 내에서만 접근 가능합니다.
      * 이 변수들은 루프가 종료될 때 초기화되며, 루프 외부에서 접근하면 null이 됩니다.
      * 반복문은 반복문 외부에서 정의된 변수에 접근할 수 있습니다.
    </Callout>

    **정수에 대한 간단한 for 루프**

    ```yaml
      name: myWorkflow
      steps:
        - name: loopStep
          type: loop
          for:
            in: ${{ [range(1; 6)] }}
            steps:
              - name: step1
                type: action
                action: internal.example.sayHello
                version: '1'
                inputs:
                  name: 'Element: ${{ .steps.loopStep.loop.element }} , Index : ${{ .steps.loopStep.loop.index }}'  # Element : [1, 2, 3, 4, 5] , Index : [0, 1, 2, 3, 4]
    ```

    **지도를 위한 간단한 루프**

    ```yaml
      name: myWorkflow
      steps:
        - name: loopStep
          type: loop
          for:
            in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
            steps:
              - name: step1
                type: action
                action: internal.example.sayHello
                version: '1'
                inputs:
                  name: 'Element : ${{ .steps.loopStep.loop.element }} , Index : ${{ .steps.loopStep.loop.index }}'  # Element: [{ "key1": "val1" }, { "key2": "val2"}] , Index : [0, 1]
    ```

    **루프 내에서 점프**

    동일한 for 루프에 속하는 명명된 단계 간에는 건너뛰기가 허용됩니다. for 루프 안으로 들어가거나 나가는 것, 내부 루프나 외부 루프로 이동하는 것, 또는 서로 다른 두 for 루프 사이를 이동하는 것은 허용되지 않습니다.

    ```yaml
      name: myWorkflow
      steps:
        - name: firstStep
          type: action
          action: example.messaging.sayHello
          version: '1.0.0'
        - name: loopStep
          type: loop
          for:
            in: '${{ .workflowInputs.count }}'
            steps:
              - name: step1
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
                next: step3                                 # Okay within the loop
              - name: step2
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.step1.outputs.greeting }}'
              - name: step3
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                next: firstStep                            # Not okay, first step is not in the loop context
    ```

    **반복문에서는 break 또는 continue를 사용하세요.**

    for 루프의 흐름을 변경하려면 `next: break` 또는 `next: continue` 사용할 수 있습니다. `break` 와 `continue` 은 루프 내에서 암시적으로 정의된 예약된 점프 목표입니다. 루프 외부에서 `next: break` 또는 `next: continue` 를 사용하면 렐름우 단계의 끝으로 이동합니다.

    * `end` 은 루프 내부에서 사용되는 경우 `break` 과 동일한 역할을 합니다.
    * Next는 두 스위치 단계나 모든 유형의 단계에서 사용될 수 있습니다.

    ```yaml
      name: myWorkflow
      steps:
        - name: loopStep
          type: loop
          for:
            in: '${{ [range(1; 6)] }}'
            steps:
              - name: insideLoopStep1
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
                next: continue
              - name: insideLoopStep2
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
        - name: loopStepAgain
          type: loop
          for:
            in: '${{ .workflowInputs.count }}'
            steps:
              - name: switchStep
                type: switch
                switch:
                  - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                    next: break
              - name: insideLoopStepAgain
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStepAgain.loop.element }}'
    ```
  </Collapser>
</CollapserGroup>

* **`steps[*].for`** (필수)

  * **유형**: 상수
  * **설명**: 루프 시작 신호

* **`steps[*].in`** (필수)

  * **유형**: 문자열(표현식)

  * **설명**: 요소 컬렉션으로 평가해야 하는 표현식입니다.

  * **`steps[*].steps`** (선택 사항)

    * **설명**: 루프의 각 반복에서 실행되는 단계입니다. 위의 단계에 대한 정의를 참조하세요.

**예** :

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: "${{ [range(1; 5)] }}"
        steps:
          - name: step1
            type: action
            action: newrelic.ingest.sendLogs
            version: 1
            inputs:
              logs:
                - message: "Loop: ${{ .steps.loopStep.loop.element }}"
```

### 스위치 [#switch]

* 다양한 조건을 검사하고 참으로 평가되는 첫 번째 분기를 취하는 단계입니다.

* 스위치는 목록에 임의의 개수의 `condition` 개 요소를 포함할 수 있습니다. 조건을 순서대로 확인하고, 참인 첫 번째 조건부터 처리합니다. 만약 어느 것도 참으로 평가되지 않으면, `steps[*].next` 에 정의된 대로 `next` 단계를 실행합니다.

  * **`steps[*].switch`** (필수)

    * **유형**: 기타
    * **설명**: 평가할 조건의 정렬된 목록을 지정하는 switch case의 배열입니다.

  * **`steps[*].switch[*].condition`** (필수)

    * **유형**: 문자열([표현식](#expression-strings))
    * **설명**: 스위치 케이스의 상태. 만약 참으로 평가되면, `next` 단계가 실행됩니다.
    * 자세한 내용은 [표현식 문자열](#expression-strings) 섹션을 참조하십시오.

  * **`steps[*].switch[*].next`** (필수)

    * **타입**: 문자열 ([표현식 안전 패턴](#expression-safe-pattern) 준수)
    * **설명**: 해당 조건식이 참으로 평가될 경우 실행할 단계의 이름입니다. 특수 키워드 `end` 을 사용하면 이 단계가 마지막으로 실행되어야 함을 나타낼 수 있습니다.

  ```yaml
    - name: hasCompleted
      type: switch
      switch:
        - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Failed" }}
          next: displayError
        - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Success" }}
          next: displaySuccess
      next: displayUnexpected
  ```

### 기다리다 [#wait]

지정된 시간(초) 동안 실행을 일시 중지한 후 계속 진행하는 단계입니다.

대기 단계에서는 하나 이상의 신호를 수신할 수도 있습니다. 각 신호에는 목록에 정의된 해당 다음 단계가 있어야 합니다. 대기 기간 동안 신호가 수신되면, 수신된 첫 번째 신호가 처리되고, 그레이터우는 정의된 다음 단계를 실행합니다. 신호가 수신되지 않으면 대기 시간이 종료된 후 정상적으로 작동합니다.

신호로부터 수신된 값은 대기 단계의 출력에 저장되며, 이후 단계에서 논리 연산이나 처리에 사용될 수 있습니다.

**예** :

```yaml
  name: waitSignalExample
  workflowInputs:
  steps:
    - name: waitStep
      type: wait
      seconds: 300
      signals: [{name: 'mySignalName', next: 'firstStep'}]
    - name: endStep
      type: action
      action: newrelic.instrumentation.log
      version: 1
      inputs:
        message: "didn't get signal"
      next: end
    - name: firstStep
      type: action
      action: newrelic.instrumentation.log
      version: 1
      inputs:
        message: ${{ .steps.waitStep.outputs.signalInputs.myString }}
```

* **`steps[*].seconds`** (필수)

  * **유형**: 숫자
  * **설명**: 폴리스우 실행을 계속하기 전에 기다리는 시간(초)입니다.

* **`steps[*].signals`**

  * **유형**: 기타
  * **설명**: 수신 시 프로그램 흐름을 전환하는 신호입니다.

* **`steps[*].signals[*].name`**

  * **유형**: 문자열
  * **설명**: 수신할 신호의 이름입니다.

* **`steps[*].signals[*].next`**

  * **유형**: 문자열
  * **설명**: 지정된 신호를 수신하면 실행할 단계입니다.

### 양수인 [#assign]

전체 과정에서 사용할 변수를 정의하는 단계입니다. 이 단계에서는 후속 단계에서 참조할 수 있는 변수에 값을 할당합니다. 모든 변수를 한 곳에 정의함으로써, 이 단계 유형은 도표우를 더욱 읽기 쉽고 최적화되게 만듭니다.

**샘플 워크플로우**:

```yaml
  name: sampleWorkflowWithAssign
  description: WorkflowAssignDemo

  workflowInputs:
    initialValue:
      type: String
    anotherValue:
      type: Int

  steps:
    - name: runAction
      type: action
      action: internal.http.post
      version: 1
      inputs:
        url: 'http://localhost:8505/tasks/gc' # temporal-activity-worker-java service port
        selectors:
          - name: statusCode
            expression: '.statusCode'
          - name: responseBody
            expression: '.responseBody'
    - name: variableInitialization
      type: assign
      inputs:
        stringVar: "${{ .workflowInputs.initialValue }}"
        intVar: "${{ .workflowInputs.anotherValue }}"
        concatenationVar: "${{ .workflowInputs.initialValue }} - concatenated"
        booleanVar: true
        mapVar:
          key1: "value1"
          key2: "${{ .workflowInputs.initialValue }}"
        listVar:
          - "listItem1"
          - "${{ .workflowInputs.initialValue }}"
          - "${{ .workflowInputs.anotherValue }}"
        statusCode: ${{ .steps.runAction.outputs.statusCode }}

    - name: wait
      type: wait
      seconds: 2

    - name: logVariables
      type: action
      action: newrelic.ingest.sendLogs
      version: 1
      inputs:
        logs:
          - message: "stringVar: ${{ .steps.variableInitialization.outputs.stringVar }}"
          - message: "intVar: ${{ .steps.variableInitialization.outputs.intVar }}"
          - message: "concatenationVar: ${{ .steps.variableInitialization.outputs.concatenationVar }}"
          - message: "booleanVar: ${{ .steps.variableInitialization.outputs.booleanVar }}"
          - message: "mapVar: ${{ .steps.variableInitialization.outputs.mapVar | tojson }}"
          - message: "listVar: ${{ .steps.variableInitialization.outputs.listVar | tojson }}"
          - message: "statusCode: ${{ .steps.variableInitialization.outputs.statusCode }}"
```

* **`steps[*].inputs`** (필수)

  * **데이터 유형**: 값 맵([표현식](#expression-strings) 포함)
  * **설명**:
    * 입력값은 변수 이름과 해당 변수에 할당된 값으로 이루어진 맵입니다. 변수에 비밀 참조가 할당되면 해당 참조는 비밀 참조로 유지되며 실제 값으로 변환되지 않습니다. 하지만 다른 표현식(예: 연산자우 입력)은 평가되어 실제 값으로 변환됩니다.
  * 허용되는 입력 유형: `Integer`, `Double`, `Boolean`, `String`, `Array` `Map`

## 유효성 검사 유형 [#validation-types]

<table>
  <thead>
    <tr>
      <th>
        유효성 검사 유형
      </th>

      <th>
        재산
      </th>

      <th>
        필수 또는 선택
      </th>

      <th>
        유형
      </th>

      <th>
        설명
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`regex`**
      </td>

      <td>
        `validations[*].pattern`
      </td>

      <td>
        필수의
      </td>

      <td>
        문자열
      </td>

      <td>
        제공된 정규 표현식 패턴에 대해 &apos;검증우&apos; 입력 값을 검증합니다.
      </td>
    </tr>

    <tr>
      <td>
        **`maxIntValue`**
      </td>

      <td>
        `validations[*].maxValue`
      </td>

      <td>
        필수의
      </td>

      <td>
        정수
      </td>

      <td>
        입력값이 제공된 최대값보다 작아야 함을 검증합니다.
      </td>
    </tr>

    <tr>
      <td>
        **`minIntValue`**
      </td>

      <td>
        `validations[*].minValue`
      </td>

      <td>
        필수의
      </td>

      <td>
        정수
      </td>

      <td>
        입력값이 제공된 최소값보다 커야 하는지 검증합니다.
      </td>
    </tr>

    <tr>
      <td>
        **`maxLength`**
      </td>

      <td>
        `validations[*].length`
      </td>

      <td>
        필수의
      </td>

      <td>
        정수
      </td>

      <td>
        입력 문자열과 컬렉션(

        `Array, Set, Map, etc.`

        )의 최대 길이를 검증합니다.
      </td>
    </tr>
  </tbody>
</table>

## 공유 유형 [#shared-types]

### 표현식 문자열 [#expression-strings]

몇몇 속성은 도표우 실행 중에 평가되는 내장 표현식이 포함된 문자열 값을 허용하므로 도표우 정의에서 동적 값을 사용할 수 있습니다.

표현식 문자열은 하나 이상의 표현식을 포함할 수 있으며, 각 표현식은 이중 중괄호로 묶입니다. 중괄호 안의 내용은 [jq를](https://jqlang.org/manual/) 사용하여 평가되며, jq는 값에 접근하고 조작할 수 있는 강력한 기능을 제공합니다.

**예** :

입력 문자열의 길이를 구합니다.

`${{ .workflowInputs.myString | length }}`

표현식의 유효성을 검사하고 테스트하려면 [JQ Playground를](https://play.jqlang.org/) 사용하십시오.

### 발현 특성 [#expression-properties]

표현식을 사용하여 여러 속성에 접근할 수 있습니다. 이러한 속성은 `scope` 객체에 있으므로 범위 객체의 해당 속성에 액세스하려면 표현식이 마침표 `(.)` 로 시작해야 합니다.

이용 가능한 속성은 다음과 같습니다.

* `workflowInputs` - 시작 시 뷰우에 전달되는 입력값을 담고 있는 객체입니다.

**예** :

`${{ .workflowInputs.myInput }}`

* `steps` - 각 단계에 대한 속성을 포함하는 객체
* `steps.<stepName>` - 특정 단계에 대한 속성을 포함하는 객체
* `steps.<stepName>.outputs` - 단계 또는 작업에 특정한 결과 속성을 포함하는 객체입니다.

**예** : `${{ .steps.myStep.outputs.myResult }}`

### 발현 평가 결과 [#expression-evaluation-results]

하나의 jq 표현식으로 모든 JSON 유형을 평가할 수 있습니다. 하지만 표현식 문자열의 최종 결과는 문자열에 표현식만 포함되어 있는지 아니면 추가 콘텐츠가 포함되어 있는지에 따라 달라집니다.

**단일 표현식(JSON 유형 유지)**:

표현식 문자열이 주변에 내용이 없고 하나의 표현식으로만 구성된 경우, 원래 JSON 유형을 유지하면서 jq 표현식의 결과로 평가됩니다. 예를 들어, `${{ .workflowInputs.myArray }}` an으로 평가됩니다. 이는 복잡한 데이터 구조를 전달하는 데 유용합니다.

**여러 표현 또는 혼합된 콘텐츠(문자열로 변환)**:

표현식 문자열에 단일 표현식 이외의 내용이 포함되어 있으면 문자열 결과로 평가됩니다. 이는 표현식 앞뒤에 내용이 있거나 문자열 내에 여러 표현식이 포함된 경우에 발생합니다. 문자열 내의 각 표현식은 평가되어 문자열 표현으로 변환됩니다.

<Callout variant="important">
  jq 표현식이 null로 평가되면 null 노드가 반환됩니다. 예를 들어 표현식 `${{ .workflowInputs.missingInput }}` 은 `missingInput` 입력으로 주어지지 않으면 null을 반환합니다.
</Callout>

**예** :

`myArray` 의 값이 `[1, 2, 3]` 이라고 가정해 봅시다.

<table>
  <thead>
    <tr>
      <th>
        표현식 문자열
      </th>

      <th>
        결과 데이터
      </th>

      <th>
        결과 유형
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `${{ .workflowInputs.myArray }}`
      </td>

      <td>
        `[1, 2, 3]`
      </td>

      <td>
        숫자의 비교
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        삼
      </td>

      <td>
        숫자
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        사실
      </td>

      <td>
        부울
      </td>
    </tr>

    <tr>
      <td>
        `Input is not empty: ${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        `"Input is not empty: true"`
      </td>

      <td>
        문자열
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray }} has length ${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        `"has length 3"`
      </td>

      <td>
        문자열
      </td>
    </tr>
  </tbody>
</table>

### 표현 안전 패턴 [#expression-safe-pattern]

표현식에서 사용할 수 있는 속성은 다음 조건을 충족해야 합니다. `^[A-Za-z_][A-Za-z0-9_]*$`

### 비밀 참고 자료 [#secret-references]

비밀 값은 Secret Service에서 검색할 비밀의 이름을 지정하는 참조 문자열을 통해 작업에서 사용될 수 있습니다. 스텔라우 정의에서 비밀을 참조하려면 다음 구문을 사용하세요.

* `${{ :secrets:<SECRET_NAME> }}` 비밀이 아닌 것에 대해 `namespace`
* `${{ :secrets:<NAMESPACE>:<SECRET_NAME> }}` 비밀을 위해 `namespace`
* `${{ :secrets:<SCOPE>:<NAMESPACE>:<SECRET_NAME> }}` 범위 및 네임스페이스 내의 비밀 정보입니다. 현재 범위는 `ACCOUNT` 또는 `ORGANIZATION` 만 허용합니다.

표현식 문자열에는 비밀 참조와 JQ 표현식이 혼합되어 포함될 수 있습니다. `and/or` 여러 개의 비밀 참조.

**예시**:

```yaml
  steps:
  - name: mySecretStep
    type: action
    action: newrelic.instrumentation.log
    inputs:
      message: My message
      licenseKey: ${{ :secrets:<SECRET_NAME> }}
```

```yaml
  steps:
    - name: bearer_auth
      type: action
      action: utils.http.post
      inputs:
        headers:
          Authorization: Bearer ${{ :secrets:<SECRET_NAME> }}
```

## 예 [#examples]

### 캘린더 데모

입력, HTTP 액션, 선택자, 대기 단계, NRQL 쿼리, 스위치 문 및 Slack 공지를 포함한 여러 워크플로우 기능을 보여주는 완전한 워크플로우 예제입니다.

```yaml
  name: calendar_demo

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'
    accountId:
      type: Int

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'
        selectors:
          - name: timezone
            expression: '.responseBody | fromjson.abbreviation'
          - name: datetime
            expression: '.responseBody | fromjson.datetime'

    - name: logTime
      type: action
      action: newrelic.instrumentation.log
      version: 1
      inputs:
        message: 'DEMO: In the ${{ .steps.getCurrentTime.outputs.timezone }} timezone, the current time is ${{ .steps.getCurrentTime.outputs.datetime }}'
        licenseKey: ${{ :secrets:STAGING_NEW_RELIC_LICENSE_KEY }}

    - name: wait
      type: wait
      seconds: 1

    - name: queryForLog
      type: action
      action: newrelic.nrql.query
      version: 1
      inputs:
        accountIds: ['${{ .workflowInputs.accountId }}']
        query: FROM Log SELECT * WHERE message LIKE 'DEMO:%${{ .steps.getCurrentTime.outputs.datetime }}'

    - name: checkQuery
      type: switch
      switch:
        - condition: ${{ .steps.queryForLog.outputs.results | length > 0 }}
          next: postResultsMessage

    - name: postWaitingMessage
      type: action
      action: slack.chat.postMessage
      version: 1
      inputs:
        channel: test-channel-workflow
        text: Waiting for log message...
        token: ${{ :secrets:dn_staging_slack_token }}
      next: wait

    - name: postResultsMessage
      type: action
      action: slack.chat.postMessage
      version: 1
      inputs:
        channel: test-channel-workflow
        text: 'Found log message! ${{ .steps.queryForLog.outputs.results[0].message }}'
        token: ${{ :secrets:dn_staging_slack_token }}
```