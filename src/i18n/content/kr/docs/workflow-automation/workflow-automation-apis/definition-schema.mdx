---
title: 흐름흐름 정의 스키마
tags:
  - workflow automation
  - workflow schems
  - workflow automation API
metaDescription: Workflow definitions are written in YAML. Keys use a camelCase naming convention.
freshnessValidatedDate: never
translationType: machine
---

<Callout title="시사">
  이 기능은 아직 개발 중이지만 꼭 사용해 보시기 바랍니다!

  이 기능은 현재 [출시 전 정책](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy) 에 따라 미리보기 프로그램의 일부로 제공됩니다.
</Callout>

## 개요

워크플로우 정의는 YAML로 작성됩니다. 키는 `camelCase` 명명 규칙을 사용합니다.

### **이름** (필수)

* **유형**: 문자열
* **형식**: 정규식 `^[A-Za-z_][A-Za-z0-9_-]*$` 을 준수해야 합니다.
* **최대 길이**: 100
* **설명**: `name` 값은 대소문자를 구분하지 않습니다. 예를 들어, `ExampleWorkflow`, `exampleworkflow`, `EXAMPLEWORKFLOW` 은 모두 동일한 파라다이스우 정의를 나타내는 것으로 간주됩니다.

### **설명** (선택 사항)

* **유형**: 문자열
* **형식**: 정규식 `^[A-Za-z0-9 _-]*$` 을 준수해야 합니다.
* **최대 길이**: 200
* **설명**: 팰리세이드우의 목적을 설명하는 `description` 입니다.

### **workflowInputs** (선택 사항)

* **유형**: 지도의 지도
* **최대 크기**: 100
* **설명**: 워크플로우가 수용하는 입력의 맵입니다.
* **예** :

```java
  workflowInputs:
    myInput1:
      type: String
    myInput2:
      type: Number
      defaultValue: 42
```

* **`workflowInputs.<inputName>`** (필수)

  * **유형**: 문자열( [표현식 안전 패턴]() 에 따름)
  * **최소 길이**: 1
  * **최대 길이**: 50
  * **설명**: 폴리스우 입력의 이름입니다.

* **`workflowInputs.<inputName>.type`** (필수)

  * **Type**: Enum (Boolean, List, Map, String, Int, 날짜)
  * **설명**: 폴리스우 입력의 데이터 유형입니다.

* **`workflowInputs.<inputName>.defaultValue`** (선택 사항)

  * **유형**: 모든 유형; `type` 준수해야 합니다.
  * **설명**: 플레시아우 입력의 기본값입니다.

* **단계** (필수)

  * **유형**: 지도의 없음
  * **설명**: 플레우스 정의가 실행될 때 수행되는 단계입니다. 최소한 한 단계가 있어야 합니다.

  <Callout variant="important">
    단계는 `steps` 에 정의된 순서대로 실행됩니다.

    다른 순서가 필요한 경우, `steps[*].next` 속성을 점프할 단계의 이름으로 설정하여 &quot;점프&quot;를 수행할 수 있습니다.
  </Callout>

  * **`steps[*].name`** (필수)

    * **유형**: 문자열( [표현식 안전 패턴]() 에 따름; `end` 일 수 없음)
    * **최대 길이**: 100
    * **설명**: `steps[*].next` 에서 참조할 단계의 이름입니다. `end`, `continue` 또는 `break` 과 같은 특수 키워드는 종료 단계, 루프의 계속 또는 루프의 중단을 나타내는 데 사용되므로 사용할 수 없습니다.

  * **`steps[*].type`** (필수)

    * **유형**: 문자열
    * **설명**: 단계의 유형으로, 단계가 실행될 때 수행되는 작업을 나타냅니다. 사용 가능한 옵션은 [단계 유형]() 을 참조하세요.

  * [**`steps[*].next`**](#steps-next) (선택 사항)

    * **유형**: 문자열( [표현식 안전 패턴]() 에 따름)

    * **설명**:

      * 이 단계가 성공적으로 완료되면 실행할 다음 단계의 이름입니다. 특수 키워드 `end` 을 사용하면 이 단계가 마지막에 실행되어야 함을 나타낼 수 있습니다.
      * `next` 이 생략되면 정의의 `steps` 에 있는 다음 항목이 암시적 다음 단계로 사용됩니다. 다음 항목이 없으면 플로우가 완료됩니다.

## 단계 유형

### **행동**

특정 작업을 실행하는 단계입니다. 사용 가능한 옵션은 [Action Catalog](/docs/workflow-automation/setup-and-configuration/actions-catalog/actions-catalog) 를 참조하세요.

* **`steps[*].action`** (필수)

  * **유형**: 문자열

  * **설명**: 실행할 작업 함수의 정규화된 이름입니다. 다음 규칙을 따라야 합니다.

    `<company domain>.<category of work>.<action name in camelCase>`

  * **예** :

    * 뉴렐릭 서비스를 사용한 작업(예: NerdGraph를 통해): `newrelic.dashboards.getDashboard`
    * Slack을 사용한 작업: `slack.chat.postMessage`

* **`steps[*].version`** (필수)

  * **유형**: 문자열
  * **설명**: 실행할 작업 함수의 버전입니다.

* **`steps[*].inputs`** (선택 사항)

  * **유형**: 값 맵( [표현식]() 포함)

  * **설명**:

    * 액션 함수에 전달할 입력입니다. 허용되는 구체적인 입력은 각 작업에 의해 정의됩니다.
    * 입력에는 표현식을 사용할 수 있습니다. 자세한 내용은 [표현식 문자열]() 섹션을 참조하세요.

  <Callout variant="important">
    민감한 데이터(API 키나 비밀, PII, PHI 또는 개인 식별 데이터)는 인수로 전달되어서는 안 됩니다.
  </Callout>

* **`steps[*].inputs.selectors`** (선택 사항)

  * **유형**: `name` 과 `expression` 의 형태로 된 지도 목록입니다.

  * **설명**:

    * `selectors` 입력을 사용하면 지정된 요소만 반환하도록 출력을 다시 정의할 수 있습니다.
    * 표현을 사용할 수 있습니다. 자세한 내용은 [표현식 문자열]() 섹션을 참조하세요.

  * **예시**

    * 제시된 예에서 우리는 http.get 작업의 응답으로 `pageUrl` 및 `statusDescription` 얻습니다.

    ```yaml
        name: status
        description: A workflow for checking the status of New Relic components

        steps:
          - name: query1
            type: action
            action: http.get
            version: 1
            inputs:
              url: "https://status.newrelic.com/api/v2/status.json"
              selectors:
                - name: statusCode
                  expression: '.statusCode'
                - name: pageUrl
                  expression: '.responseBody | fromjson | .page.url'
                - name: statusDescription
                  expression: '.responseBody | fromjson | .status.description'

          - name: logOutput1
            type: action
            action: newrelic.ingest.sendLogs
            version: 1
            inputs:
              logs:
                - message: "status is '${{ .steps.query1.outputs.statusDescription }}' details at ${{ .steps.query1.outputs.pageUrl }}"
    ```

### **고리**

루프는 `in` 으로 정의된 주어진 컬렉션을 반복하고 각 반복에 대해 루프 변수 `index` 과 `element` 를 생성합니다. 이러한 루프 변수는 표현식 `${{ .steps.<loopStepName>.loop.element }}` 또는 루프 내에서만 액세스할 수 있습니다. `${{ .steps.<loopStepName>.loop.index }`

자세한 내용은 아래를 참조하세요.

<CollapserGroup>
  <Collapser id="moreforloop" title="목록, 맵 또는 컬렉션을 반복하기 위한 루프">
    루프를 사용하면 목록, 맵 또는 컬렉션을 반복할 수 있습니다.

    * `for` (필수의)

      * **유형**: 상수
      * **설명**: 루프의 시작 신호입니다.

    * `in` (필수의)

      * **유형**: 문자열(표현식)
      * **설명**: 요소 컬렉션으로 평가되어야 하는 표현식입니다.

    * `steps` (필수의)

      * **설명**: 루프의 각 반복에서 실행되는 단계입니다. 단계는 다른 루프를 포함한 모든 유형의 단계가 될 수 있습니다.

      * **예**: 다음은 루프 workflowInputs를 실행하는 방법을 보여줍니다. 결과는 컬렉션 유형이어야 합니다.

        ```yaml
            name: myWorkflow
            steps:
              - name: loopStep
                type: loop
                for:
                  in: '${{ .workflowInputs.count }}'
                  steps:
                    - name: step1
                      type: action
                      action: example.messaging.sayHello
                      version: '1.0.0'
                      inputs:
                        name: '${{ .steps.loopStep.loop.element }}' # not exist outside of this loop
                        index: '${{ .steps.loopStep.loop.index }}' # not exist outside of this loop
        ```

    <Callout variant="important">
      * `element` `index` 은 루프의 일부로 자동으로 할당됩니다.
      * `Index` 0부터 시작합니다.
      * 복잡한 요소 컬렉션이 있는 경우 `element` 은 복잡한 유형이 될 수 있습니다.
      * 루프 내 단계의 모든 루프 변수와 출력은 루프 수준 범위를 갖습니다. 이러한 변수는 루프를 종료한 후 지워지고 루프 외부에서 이 변수에 접근하면 null 값이 반환됩니다. 루프는 이전에 정의된 경우 루프 외부에 있는 변수에 액세스할 수 있습니다.
    </Callout>

    **정수에 대한 간단한 for 루프**

    ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: ${{ [range(1; 6)] }}
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'  # [1, 2, 3, 4, 5]
                    index: '${{ .steps.loopStep.loop.index }}' # [0, 1, 2, 3, 4]
    ```

    **지도를 위한 간단한 루프**

    ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'  # [{ "key1": "val1" }, { "key2": "val2"}]
                    index: '${{ .steps.loopStep.loop.index }}' # [0, 1]
    ```

    **루프 내에서 점프**

    동일한 for 루프에 속하는 명명된 단계 사이만 점프할 수 있습니다. for 루프 안팎으로 점프하거나, 내부/외부 루프로 점프하거나, 두 개의 서로 다른 for 루프 사이로 점프하는 것은 허용되지 않습니다.

    ```yaml
        name: myWorkflow
        steps:
          - name: firstStep
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
          - name: loopStep
            type: loop
            for:
              in: '${{ .workflowInputs.count }}'
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'
                  next: step3                                 # Okay within the loop
                - name: step2
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.step1.outputs.greeting }}'
                - name: step3
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  next: firstStep                            # Not okay, first step is not in the loop context
    ```

    **루프에서 break/continue를 사용하세요**

    for 루프의 흐름을 변경하려면 `next: break` 또는 `next: continue` 사용할 수 있습니다. `break` 와 `continue` 은 루프 내에서 암시적으로 정의된 예약된 점프 목표입니다. 루프 외부에서 `next: break` 또는 `next: continue` 를 사용하면 렐름우 단계의 끝으로 이동합니다.

    * `end` 은 루프 내부에서 사용되는 경우 `break` 과 동일한 역할을 합니다.
    * Next는 두 스위치 단계나 모든 유형의 단계에서 사용될 수 있습니다.

    ```yaml
      name: myWorkflow
      steps:
        - name: loopStep
          type: loop
          for:
            in: '${{ [range(1; 6)] }}'
            steps:
              - name: insideLoopStep1
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
                next: continue
              - name: insideLoopStep2
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
        - name: loopStepAgain
          type: loop
          for:
            in: '${{ .workflowInputs.count }}'
            steps:
              - name: switchStep
                type: switch
                switch:
                  - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                    next: break
              - name: insideLoopStepAgain
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStepAgain.loop.element }}'
    ```
  </Collapser>
</CollapserGroup>

* **`steps[*].for`** (필수)

  * **유형**: 상수
  * **설명**: 루프 시작 신호

* **`steps[*].in`** (필수)

  * **유형**: 문자열(표현식)

  * **설명**: 요소 컬렉션으로 평가해야 하는 표현식입니다.

  * **`steps[*].steps`** (선택 사항)

    * **설명**: 루프의 각 반복에서 실행되는 단계입니다. 위의 단계에 대한 정의를 참조하세요.

    * **예** :

      ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: "${{ [range(1; 5)] }}""
              steps:
                - name: step1
                  type: action
                  action: newrelic.ingest.sendLogs
                  version: 1
                  inputs:
                    logs:
                      - message: "Loop: ${{ .steps.loopStep.loop.element }}"
      ```

### **스위치**

* 다양한 조건을 검사하고 참으로 평가되는 첫 번째 분기를 취하는 단계입니다.

* 스위치는 목록에 아무리 많은 조건 요소라도 포함할 수 있습니다. 조건을 순서대로 검사하여 참으로 평가되는 첫 번째 조건을 처리합니다. 아무것도 참으로 평가되지 않으면 steps\[\*].next에 정의된 대로 다음 단계를 실행합니다.

* **`steps[*].switch`** (필수)

  * **유형**: 기타
  * **설명**: 평가할 조건의 정렬된 목록을 지정하는 switch case의 배열입니다.

* **`steps[*].switch[*].condition`** (필수)

  * **유형**: 문자열(표현식)
  * **설명**: 스위치 케이스의 상태입니다. true로 평가되면 해당 사례의 다음 단계가 실행됩니다.

* **`steps[*].switch[*].next`** (필수)

  * **유형**: 문자열( [표현식 안전 패턴]() 에 따름)
  * **설명**: 케이스의 조건이 참으로 평가될 경우 실행할 단계의 이름입니다. 특수 키워드 end는 이 단계가 마지막에 실행되어야 함을 나타내는 데 사용할 수 있습니다.

  ```yaml
  - name: hasCompleted
    type: switch
    switch:
      - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Failed" }}
        next: displayError
      - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Success" }}
        next: displaySuccess
    next: displayUnexpected
  ```

### 기다리다

팰리세이드우 실행을 계속하기 전에 특정 시간(초) 동안 기다리게 하는 단계입니다. 또한 하나 이상의 신호를 수신할 수도 있습니다. 대기하는 동안 신호가 수신되지 않으면 정상적으로 진행됩니다. 신호는 목록으로 정의됩니다. 각 신호에는 해당 다음 단계가 정의되어 있어야 합니다. 수신된 첫 번째 신호가 처리됩니다. 신호에 대해 수신된 값은 대기 단계의 단계 출력에 저장되며 이후 단계의 논리 처리에 사용될 수 있습니다.

* 예시:

  ```yaml
    name: waitSignalExample
    workflowInputs:
    steps:
      - name: waitStep
        type: wait
        seconds: 300
        signals: [{name: 'mySignalName', next: 'firstStep'}]
      - name: endStep
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: "didn't get signal"
        next: end
      - name: firstStep
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: ${{ .steps.waitStep.outputs.signalInputs.myString }}
  ```

* **`steps[*].seconds`** (필수)

  * **유형**: 숫자
  * **설명**: 폴리스우 실행을 계속하기 전에 기다리는 시간(초)입니다.

* **`steps[*].signals`**

  * **유형**: 기타
  * **설명**: 수신 시 프로그램 흐름을 전환하는 신호입니다.

* **`steps[*].signals[*].name`**

  * **유형**: 문자열
  * **설명**: 수신할 신호의 이름입니다.

* **`steps[*].signals[*].next`**

  * **유형**: 문자열
  * **설명**: 지정된 신호를 수신하면 실행할 단계입니다.

## 공유 유형

### 표현식 문자열

여러 속성은 플레임웨어 실행 중에 평가되는 내장 표현식이 있는 문자열 값을 허용하므로 플레임웨어 정의 내에서 동적 값을 사용할 수 있습니다. 표현식 문자열에는 하나 이상의 표현식이 포함될 수 있으며, 각 표현식은 이중 중괄호로 묶입니다. 중괄호 안의 내용은 jq를 사용하여 평가됩니다.

jq는 다양한 방법으로 값에 접근하고 이를 조작할 수 있는 기능을 제공합니다. 예를 들어, 펠로스우 입력 문자열의 길이는 다음을 통해 얻을 수 있습니다. `${{ .workflowInputs.myString | length }}`

[JQ 표현식을 빌드하고 테스트](https://play.jqlang.org/) 하려면 이 도구를 사용할 수 있습니다.

### 발현 특성

표현식을 사용하여 여러 속성에 접근할 수 있습니다. 이러한 속성은 &quot;범위&quot; 객체에 있으므로 표현식은 마침표(.)로 시작해야 범위 객체의 해당 속성에 액세스할 수 있습니다.

이용 가능한 속성은 다음과 같습니다.

* `workflowInputs` - 시작 시 에펠우에 전달되는 입력을 포함하는 객체입니다.
  * 예시: `${{ .workflowInputs.myInput }}`
* `steps` - 에리스우의 각 단계에 대한 속성을 포함하는 객체
  * `steps.<stepName>` - 특정 단계에 대한 속성을 포함하는 객체
    * `steps.<stepName>.outputs` - 단계/작업에 특정한 결과 속성을 포함하는 객체입니다.
      * 예시: `${{ .steps.myStep.outputs.myResult }}`

### 발현 평가 결과

단일 jq 표현식은 모든 JSON 유형으로 평가될 수 있지만, 전체 표현식 문자열의 최종 결과는 표현식을 둘러싼 문자열 내용(있는 경우)에 따라 달라진다는 점에 유의하는 것이 중요합니다.

표현식 문자열 전체가 단일 표현식으로 구성된 경우 jq 표현식의 결과로 평가되며 결과의 JSON 유형이 유지됩니다. 예를 들어, 로그플로우가 입력으로 포함되는 경우 문자열 `${{ .workflowInputs.myArray }}` 은 포함으로 평가됩니다. 이는 스텔라우 내에서 복잡한 데이터를 전달하는 데 유용할 수 있습니다.

표현식 문자열에 단일 표현식이 아닌 다른 내용이 포함되어 있는 경우 문자열 결과로 평가됩니다. 예를 들어, 표현식 앞/뒤에 내용이 있거나 문자열 내에 여러 표현식이 있는 경우 이런 일이 발생합니다. 문자열 내의 각 표현식은 평가되어 문자열 표현으로 변환됩니다.

예시:

다음 예제에서는 myArray의 값이 \[1, 2, 3]이라고 가정합니다.

<table>
  <thead>
    <tr>
      <th>
        표현식 문자열
      </th>

      <th>
        결과 데이터
      </th>

      <th>
        결과 유형
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `${{ .workflowInputs.myArray }}`
      </td>

      <td>
        \[1, 2, 3]
      </td>

      <td>
        숫자의 비교
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        삼
      </td>

      <td>
        숫자
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        진정한
      </td>

      <td>
        부울
      </td>
    </tr>

    <tr>
      <td>
        `Input is not empty: ${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        &quot;입력이 비어 있지 않습니다: true&quot;
      </td>

      <td>
        끈
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray }} has length ${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        &quot;길이는 3입니다&quot;
      </td>

      <td>
        끈
      </td>
    </tr>
  </tbody>
</table>

### 표현 안전 패턴 [#expression-safe-pattern]

표현식에서 사용할 수 있는 속성은 다음 정규식을 따라야 합니다. `^[A-Za-z_][A-Za-z0-9_]*$`

### 비밀 참조

비밀 값은 Secret Service에서 검색할 비밀의 이름을 지정하는 참조 문자열을 통해 작업에서 사용될 수 있습니다. 스텔라우 정의에서 비밀을 참조하려면 다음 구문을 사용하세요.

* `${{ :secrets:<SECRET_NAME> }}` 비밀이 아닌 것에 대해 `namespace`
* `${{ :secrets:<NAMESPACE>:<SECRET_NAME> }}` 비밀을 위해 `namespace`

표현식 문자열에는 비밀 참조와 JQ 표현식이 혼합되어 있거나 여러 개의 비밀 참조가 포함될 수 있습니다.

예:

```yaml
  steps:
  - name: bearer_auth
    type: action
    action: http.post
    inputs:
      headers:
        Authorization: Bearer ${{ :secrets:<SECRET_NAME> }}
```

## 예

* 안녕하세요 세상

```yaml
name: helloWorld
description: 'A hello world workflow'

workflowInputs:
  name:
    type: String
    defaultValue: World
    required: false
    validations:
      - type: maxLength
        errorMessage: "name must be at most 100 characters"
        length: 100
  slackTokenSecret:
    type: String
    defaultValue: "${{ :secrets:SLACK_TOKEN }}"
  slackChannel:
    type: String
    defaultValue: my-channel
    validations:
      - type: regex
        errorMessage: "A slack channel name must be lowercase and can only contain letters, numbers, and hyphens"
        pattern: "^[a-z0-9\\-]+$"
    required: true

steps:
  - name: init1
    type: assign
    inputs:
      greeting: Hello ${{ .workflowInputs.name }}

  - name: logName
    type: action
    action: newrelic.ingest.sendLogs
    version: 1
    inputs:
      logs:
        - message: ${{ .steps.init1.outputs.greeting }}

  - name: waiting1
    type: wait
    seconds: 1

  - name: queryForLog
    type: action
    action: newrelic.nrdb.query
    version: 1
    inputs:
      query: >-
        FROM Log SELECT * WHERE message LIKE '${{ .steps.init1.outputs.greeting
        }}'

  - name: checkResult
    type: switch
    switch:
      - condition: ${{ .steps.queryForLog.outputs.results | length > 0 }}
        next: FoundMessage

  - name: waitingMessage
    type: action
    action: slack.chat.postMessage
    version: 1
    inputs:
      channel: ${{ .workflowInputs.slackChannel }}
      text: Waiting for log message...
      token: ${{ .workflowInputs.slackTokenSecret }}
    next: waiting1

  - name: FoundMessage
    type: action
    action: slack.chat.postMessage
    version: 1
    inputs:
      channel: ${{ .workflowInputs.slackChannel }}
      text: Found message! ${{ .steps.queryForLog.outputs.results[0].message }}
      token: ${{ .workflowInputs.slackTokenSecret }}
```