---
title: 워크플로우 예제
tags:
  - workflow automation
  - workflow
  - automation
  - examples
metaDescription: 'Common workflow automation scenarios and examples for incident response, infrastructure management, and integrations.'
freshnessValidatedDate: never
translationType: machine
---

이 페이지에서는 펠릭스우 Automation을 사용하여 구축할 수 있는 일반적인 자동화 시나리오를 보여줍니다. 이러한 예를 자신만의 워크플로우의 시작점으로 사용하거나 준비된 구현하다, 배포하다 솔루션에 대한 [템플릿을](/docs/workflow-automation/create-a-workflow-automation/use-a-template) 탐색하세요.

## API 게이트웨이 롤백

API 게이트웨이 구성을 이전 상태로 되돌려 오류와 잘못된 구성을 수정할 수 있습니다.

**이 흐름이 하는 일은:**

* 뉴렐릭 변경 추적을 이용하여 이슈와 관련된 최근 형태, 배포를 탐지합니다.
* 승인 버튼이 포함된 Slack 알림을 보냅니다. `(:+1: or :-1:)`
* 승인 후 롤백을 자동화하기 위해 AWS Systems Manager 문서를 생성합니다.
* API Gateway 통합을 이전 Lambda 버전으로 롤백합니다.
* 롤백을 적용하기 위한 새로운 구현, 배포를 생성합니다.
* Slack에 성공 또는 실패 알림을 보냅니다.
* 완료 후 SSM 문서를 정리합니다.

**요구 사항:**

* API Gateway 및 Systems Manager에 대한 권한이 있는 AWS 자격 증명
* 공지 및 승인을 받기 위한 구성된 Slack 앱
* 변경 추적을 통한 뉴렐릭 모니터링

**주요 작업**: `newrelic.nerdgraph.execute`, `slack.chat.postMessage`, `slack.chat.getReactions`, `aws.systemsManager.writeDocument`, `aws.systemsManager.startAutomation`, `aws.systemsManager.waitForAutomationStatus`, `aws.systemsManager.deleteDocument`

## EC2 인스턴스 관리

최적의 성능과 비용을 위해 EC2 인스턴스의 프로비저닝, 확장 및 종료를 자동화합니다.

**이 흐름이 하는 일은:**

* 뉴렐릭으로부터 높은 CPU 사용률 알림을 받았습니다.
* 알려진 세부 정보를 검색하고 영향을 받은 EC2 제외를 식별합니다.
* 인스턴스 세부 정보와 함께 크기 조정 승인을 requests Slack 알림을 보냅니다.
* 승인 후 인스턴스 크기 조정을 자동화하는 SSM 문서를 생성합니다.
* 인스턴스를 중지하고, 인스턴스 유형을 수정하고, 다시 시작합니다.
* 크기 조정 과정 중에 Slack으로 진행 상황 업데이트를 보냅니다.
* 완료를 기다린 후 성공 또는 실패 상태를 전송합니다.
* SSM 문서를 정리하고 최종 확인 메일을 보냅니다.

**요구 사항:**

* EC2 및 Systems Manager에 대한 권한이 있는 AWS 자격 증명
* EC2 지표에 대한 활성 뉴클릭 공지 용어
* 공지 및 승인을 받기 위한 구성된 Slack 앱

**주요 작업**: `newrelic.nerdgraph.execute`, `newrelic.nrdb.query`, `slack.chat.postMessage`, `slack.chat.getReactions`, `aws.systemsManager.writeDocument`, `aws.systemsManager.startAutomation`, `aws.systemsManager.waitForAutomationStatus`, `aws.systemsManager.deleteDocument`, `utils.datetime.fromEpoch`, `utils.uuid.generate`

## 구현, 배포 롤백

롤백 구현, 부분이 비정상이 되는 경우 배포하고 AWS SQS 또는 HTTP로 알립니다.

**이 흐름이 하는 일은:**

* 지정된 기간 동안 패널의 공지 심각도를 모니터링합니다(기본값 30분).
* 매분 엔티티 상태를 확인합니다.
* 조각이 CRITICAL 또는 WARNING이 되면 비정상 상태를 기록합니다.
* AWS SQS를 통해 롤백 알림을 보냅니다(구성된 경우). 자세한 내용 포함
* HTTP 웹후크를 통해 롤백 공지를 보냅니다(구성된 경우)
* 전체 기간 동안 정상 상태를 유지하면 로그인 성공
* 엔티티가 발견되지 않으면 모니터링을 중지합니다.

**요구 사항:**

* 공지 심각도 검토를 통한 뉴렐릭
* (선택사항) 롤백을 수신할 AWS SQS 대기열 및 역할 공지
* (선택) 롤백을 받기 위한 HTTP 엔드포인트 공지

**주요 동작**: `newrelic.nerdgraph.execute`, `newrelic.ingest.sendLogs`, `aws.execute.api`, `(sqs.send_message)` `http.post`

## AWS SQS 메시징

메시지를 AWS SQS 큐로 전송하여 하위 처리 또는 알림 시스템에 전달합니다.

**이 흐름이 하는 일은:**

* 지정된 SQS 큐로 메시지를 보냅니다.
* AWS IAM 역할 인증을 사용하여 안전한 액세스를 제공합니다.
* 확인을 위해 메시지 ID와 성공 상태를 반환합니다.

**요구 사항:**

* `sqs:SendMessage` 권한이 있는 AWS 자격 증명
* SQS 큐 URL
* IAM 역할이 AWS 자동화를 위해 구성되었습니다([ AWS 자격 증명 설정](/docs/workflow-automation/setup-and-configuration/set-up-aws-credentials) 참조).

**주요 작업**: `aws.execute.api`, `(sqs.send_message)`

```yaml
  name: aws_execute_api_sqs_example

  workflowInputs:
    awsRoleArn:
      type: String
    awsRegion:
      type: String
      defaultValue: us-west-2
    awsQueueUrl:
      type: String

  steps:
    - name: sendSqsMessage
      type: action
      action: aws.execute.api
      version: 1
      inputs:
        awsRoleArn: ${{ .workflowInputs.awsRoleArn }}
        region: ${{ .workflowInputs.awsRegion }}
        service: sqs
        api: send_message
        parameters:
          QueueUrl: "${{ .workflowInputs.awsQueueUrl }}"
          MessageBody: |
            {
              "message": "deployment is bad",
              "status": "not good"
            }
        selectors:
          - name: success
            expression: '.success'
          - name: messageId
            expression: '.response.MessageId'
```

## 복잡한 NRQL 알림

표준 알림에서 지원하지 않는 복잡한 NRQL 쿼리(예: 시간 창에 걸쳐 데이터를 비교하거나 알림을 트리거하기 전에 사용자 지정 로직을 적용하는 경우)를 처리합니다.

**이 흐름이 하는 일은:**

* 서로 다른 시간 범위(10분 전부터 5분 전까지 vs 최근 5분)를 비교하는 두 개의 NRQL 쿼리를 실행합니다.
* 쿼리 결과를 비교하여 개수가 증가했는지 확인합니다.
* 스위치 단계를 사용하여 새로운 이벤트가 감지될 때만 조건부로 알림을 보냅니다.
* 쿼리 결과 및 CSV 첨부 파일을 이메일로 공지합니다.
* 10분 간격으로 실행되도록 예약하여 지속적인 모니터링이 가능합니다.

**요구 사항:**

* 쿼리에 대한 데이터가 있는 뉴렐릭 계정
* 뉴렐릭에 구성된 이메일 대상([Send 공지 from 플로우](/docs/workflow-automation/setup-and-configuration/create-destinations) 참조)
* [CreateSchedule API](/docs/workflow-automation/workflow-automation-apis/create-schedule)사용하여 예약됨

**주요 작업**: `newrelic.nrdb.query`, `newrelic.notification.sendEmail`

**사용 사례**: 이 패턴은 표준 뉴렐릭 노트가 다음과 같은 요구 사항을 처리할 수 없을 때 유용합니다.

* 여러 시간대에 걸쳐 비교
* 쿼리 결과에 사용자 지정 수학 연산 적용
* 특정 확률, 한계 또는 패턴이 감지될 때만 트리거됩니다.
* 조건부 논리를 사용하여 여러 쿼리의 데이터를 결합합니다.

```yaml
  name: Complex_Alert_Workflow
  description: 'Compares NRQL results across time windows and sends alerts when new events are detected'

  workflowInputs:
    destinationId:
      type: String
    query:
      type: String
      defaultValue: 'FROM Span SELECT count(*)'

  steps:
    - name: query1
      type: action
      action: newrelic.nrdb.query
      version: 1
      inputs:
        query: "${{ .workflowInputs.query }} SINCE 10 minutes ago UNTIL 5 minutes ago"
        accountIds:
          - 7401815
        selectors:
          - name: length
            expression: '[ .results[] | length ]'
          - name: count
            expression: '[ .results[0].count ]'

    - name: query2
      type: action
      action: newrelic.nrdb.query
      version: 1
      inputs:
        query: "${{ .workflowInputs.query }} SINCE 5 minutes ago"
        accountIds:
          - 7401815
        selectors:
          - name: length
            expression: '[ .results[] | length ]'
          - name: count
            expression: '[ .results[0].count ]'

    - name: CheckForNewEvents
      type: switch
      switch:
        - condition: >-
            ${{ (.steps.query2.outputs.count - .steps.query1.outputs.count) > 0 }}
          next: sendEmail
      next: end

    - name: sendEmail
      type: action
      action: newrelic.notification.sendEmail
      version: 1
      inputs:
        destinationId: ${{ .workflowInputs.destinationId }}
        subject: Hello there!
        message: >-
          More spans incoming!!!
          There are --- ${{ (.steps.query2.outputs.count - .steps.query1.outputs.count) }} ---
          new Spans that were ingested in the last 5 minutes
        attachments:
          - type: QUERY
            query: ${{ .workflowInputs.query }} SINCE 5 minutes ago
            format: CSV
            filename: span_count.csv
      next: end
```

**이 작업을 예약하려면** `*/10 * * * *` (10분마다)와 같은 cron 표현식을 사용하여 [CreateSchedule API](/docs/workflow-automation/create-a-workflow-automation/start-schedule#scheduled) 사용하십시오. 최소 예약 간격은 10분이라는 점을 기억하세요. 자세한 내용은 [워크플로우 제한을](/docs/workflow-automation/limitations-and-faq/workflow-limits) 참조하세요.

## Slack에 보고서 보내기

NRQL 쿼리 출력을 CSV 파일로 Slack에 보냅니다.

**이 흐름이 하는 일은:**

* 지정된 뉴렐릭 계정에 대해 NRQL 쿼리를 실행합니다.
* 쿼리 결과에서 CSV 파일을 생성합니다.
* 메시지와 함께 지정된 Slack 채널에 CSV 파일을 게시합니다.

**요구 사항:**

* 뉴렐릭 자격 증명 및 기능적인 NRQL 쿼리
* 의의와 댓, 목표 채널로 구성된 Slack 앱

**주요 작업**: `newrelic.nrdb.query`, `utils.transform.toCSV`, `slack.chat.postMessage`

## JSON 파싱

뉴렐릭 공개 상태 API JSON(HTTP)을 구문 분석하고 선택적으로 운영 및 비운영 구성 요소를 차단합니다.

**이 흐름이 하는 일은:**

* 뉴렐릭 상태 API에서 JSON 데이터를 가져옵니다.
* 구성 요소를 작동 상태에 따라 추출하고 분류합니다.
* 조건부로 운영 구성 요소를 테스트합니다(활성화된 경우)
* 비작동 구성 요소를 조건부로 로그합니다(활성화된 경우)
* HTTP 오류를 처리하고 로그인을 했습니다.

**요구 사항:**

* 뉴렐릭 상태 API (`summary.json`)에 대한 접근
* newrelic.ingest.sendLogs를 통해 로그를 보낼 수 있는 권한

**주요 작업**: `http.get`, `newrelic.ingest.sendLogs`

## REST API 폴링 및 로깅

REST API 엔드포인트를 폴링하고, 결과를 반복하고, 데이터를 뉴렐릭에 로깅합니다.

<Callout variant="important">
  전체 페이로드를 얻으려면 선택기를 사용할 필요가 없습니다. 대부분의 워크플로우 도구는 전체 응답 객체를 직접 참조할 수 있도록 해줍니다.
</Callout>

### 간단한 GET 요청 및 로그

API를 폴링하고 전체 응답을 로깅하는 기본적인 사용 사례는 다음과 같습니다.

**이 흐름이 하는 일은:**

* 트리거: 예약(예: 5분마다) 또는 수동으로 실행하려면 &apos;실행&apos;을 사용할 수 있습니다.

* HTTP 요청 단계:

  * 메서드: GET
  * URL: [https://pokeapi.co/api/v2/pokemon](https://pokeapi.co/api/v2/pokemon)
  * 전체 응답 본문을 변수(예: `{{.http_response}}`)에 저장합니다.

* 로그/이벤트 생성 단계:

  * `{{.http_response.body}}` 전체를 페이로드로 전송하세요
  * 선택자가 필요 없습니다. 원시 JSON을 그대로 전달하면 됩니다.

### 반복문과 선택자를 사용하는 REST API

이 예제는 API에서 모든 결과를 수집하고, 결과를 순회하며, 개별 HTTP 호출을 수행하고, 추출된 데이터를 로그에 기록합니다.

**이 흐름이 하는 일은:**

* REST API 엔드포인트에서 모든 결과를 가져옵니다.
* 응답의 각 결과를 순회합니다.
* 루프의 데이터를 사용하여 각 항목에 대해 개별 API 호출을 수행합니다.
* 선택기를 사용하여 각 응답에서 특정 필드를 추출합니다.
* 맞춤 속성을 사용하여 추출된 데이터를 뉴렐릭에 기록합니다.

**요구 사항:**

* REST API 엔드포인트에 대한 접근 권한
* 로그 전송 권한 `newrelic.ingest.sendLogs`

**주요 작업**: `http.get`, `newrelic.ingest.sendLogs`

```yaml
  name: pokemon_workflow
  description: ''
  steps:
    - name: get_all_pokemons
      type: action
      action: http.get
      version: '1'
      inputs:
        url: https://pokeapi.co/api/v2/pokemon
        selectors:
          - name: pokemons
            expression: .responseBody | fromjson.results
    - name: pokemon_loop
      type: loop
      for:
        in: ${{ .steps.get_all_pokemons.outputs.pokemons }}
        steps:
          - name: get_individual_pokemon
            type: action
            action: http.get
            version: '1'
            inputs:
              url: ${{ .steps.pokemon_loop.loop.element.url }}
              selectors:
                - name: pokemon_name
                  expression: .responseBody | fromjson.name
                - name: pokemon_id
                  expression: .responseBody | fromjson.id
                - name: pokemon_stats
                  expression: .responseBody | fromjson.stats
          - name: log_pokemon_info
            type: action
            action: newrelic.ingest.sendLogs
            version: '1'
            inputs:
              logs:
                - message: >-
                    Pokemon name is: ${{
                    .steps.get_individual_pokemon.outputs.pokemon_name}}, Id: ${{
                    .steps.get_individual_pokemon.outputs.pokemon_id}}
                  attributes:
                    pokemon_stats: ${{ .steps.get_individual_pokemon.outputs.pokemon_stats}}
            next: continue
      next: end
```

### REST API를 CSV로 변환

이 예시는 선택자 없이 전체 응답을 사용하는 방법, API 데이터를 CSV로 변환하는 방법, 그리고 Slack을 통해 공유하는 방법을 보여줍니다.

**이 흐름이 하는 일은:**

* 입력된 시간대를 기반으로 World Time API에서 현재 시간 데이터를 가져옵니다.
* 전체 JSON 응답을 CSV 형식으로 변환합니다.
* CSV 데이터를 뉴렐릭에 기록해 주세요
* CSV 파일을 슬랙 채널에 게시합니다.

**요구 사항:**

* REST API 엔드포인트에 대한 접근 권한
* newrelic.ingest.sendLogs를 통해 로그를 보낼 수 있는 권한
* 의미 및 부과, 목표 채널로 구성된 Slack 앱

**주요 동작**: `http.get`, `utils.transform.toCSV`, `newrelic.ingest.sendLogs` `slack.chat.postMessage`

```yaml
  name: jsontocsv

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'

    - name: csv1
      type: action
      action: utils.transform.toCSV
      version: 1
      inputs:
        json: ${{ .steps.getCurrentTime.outputs.responseBody }}

    - name: logOutput
      type: action
      action: newrelic.ingest.sendLogs
      version: 1
      inputs:
        logs:
          - message: 'CSV: ${{ .steps.csv1.outputs.csv }}'

    - name: postCsv
      type: action
      action: slack.chat.postMessage
      version: 1
      inputs:
        channel: test-channel-workflow
        text: "Current Date details"
        attachment:
          filename: 'file.csv'
          content: ${{ .steps.csv1.outputs.csv }}
        token: ${{ :secrets:dn_staging_slack_token }}
```

## 사용 가능한 템플릿 흐름

위에 나열된 템플릿은 뉴렐릭 파라다이스 자동화 UI 에서 직접 사용할 수 있습니다. 접근 방법:

1. **All Capabilities &gt; Workflow Automation**로 이동
2. **Create workflow** \[워크플로 만들기]를 클릭하세요.
3. **Use a template** \[템플릿 사용을]선택하세요
4. 템플릿을 찾아보고 사용 사례에 맞는 활동 흐름을 선택하세요.

각 템플릿에는 다음이 포함됩니다.

* 사전 구성된 워크플로우 단계 및 로직
* 예제 입력 매개변수,
* 필수 자격 증명 및 통합
* 예상 결과 문서화

템플릿을 그대로 사용하거나 특정 요구 사항에 맞게 사용자 정의할 수 있습니다.

## 단계 간 데이터 전달

모든 에라스우는 템플릿 구문을 사용하여 이전 단계의 출력을 참조할 수 있습니다. 이를 통해 여러 작업을 연결하고 복잡한 자동화 논리를 구축할 수 있습니다.

### 워크플로우 입력 사용

실행 시간에 동적 값을 전달하려면 `${{ .workflowInputs.variableName }}` 구문을 사용할 수 있습니다. 이 구문은 엔드포인트 URL 및 기타 입력 필드에서 작동합니다.

**예시:**

```json
  {
    "inputs": [
      {
        "key": "urlParams",
        "value": "{\"filter\": \"active\"}"
      },
      {
        "key": "headers",
        "value": "{\"Api-Key\": \"your-api-key\"}"
      }
    ]
  }
```

### 기본 데이터 전달

이 예제 공지 쿼리는 뉴렐릭에서 발행되고 각 활성 문제에 대해 공지를 Slack으로 보냅니다.

```yaml
  name: alertSlack
  description: "query Alert Issues and send notifications to Slack"

  workflowInputs:
    accountId:
      type: Int

  steps:
    - name: getAlert
      type: action
      action: newrelic.nerdgraph.execute
      version: 1
      inputs:
        graphql: |
          query GetAlertIssues($accountId: Int!) {
            actor {
              account(id: $accountId) {
                aiIssues {
                  issues(filter: {states: ACTIVATED}) {
                    issues {
                      issueId
                      priority
                      state
                      title
                    }
                  }
                }
              }
            }
          }
        variables:
          accountId: ${{ .workflowInputs.accountId }}

    - name: loopStep
      type: loop
      for:
        in: ${{ .steps.getAlert.outputs.data.actor.account.aiIssues.issues.issues }}
        steps:
          - name: sendToSlack
            type: action
            action: slack.chat.postMessage
            version: 1
            inputs:
              token: ${{ :secrets:your_slack_token }}
              channel: incident-channel
              text: >
                issueId: ${{ .steps.loopStep.loop.element.issueId }}
                priority: ${{ .steps.loopStep.loop.element.priority }}
                state: ${{ .steps.loopStep.loop.element.state }}
                title: ${{ .steps.loopStep.loop.element.title | tostring }}
```

### 루프 구조

루프를 사용하면 목록, 맵 또는 컬렉션을 반복할 수 있습니다.

루프는 `in` 으로 정의된 주어진 컬렉션을 순회합니다. 이는 각 반복마다 자동으로 루프 변수 `index` 과 `element` 를 생성합니다. 이러한 루프 변수는 [JQ 표현식](https://play.jqlang.org/) `${{ .steps.<loopStepName>.loop.element }}` 또는 `${{ .steps.<loopStepName>.loop.index }}` 사용하여 루프 내에서 접근할 수 있습니다.

**매개변수:**

* **`for`** (필수): 루프 시작 신호
* **`in`** (필수, 문자열 표현식): 요소 컬렉션으로 평가되어야 하는 표현식입니다.
* **`steps`** (필수): 루프의 각 반복마다 실행될 단계입니다. 단계는 다른 루프를 포함하여 모든 유형의 단계를 의미할 수 있습니다.

**흐름 입력이 포함된 루프:**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
```

**중요 사항:**

* `for`: 필수의. 이는 for 루프의 시작을 나타내는 최상위 요소입니다.
* `in`: 필수의. 반복할 입력 컬렉션을 자바로 캐스팅할 수 있어야 합니다.
* `steps`: 필수의. 각 반복마다 단계가 실행됩니다.
* `element` 그리고 `index` 루프의 일부로 자동으로 할당됩니다.
* `index` 0부터 시작합니다.
* `element` 은 복합 요소로 이루어진 컬렉션이 있는 경우 복합 유형이 될 수 있습니다.
* 반복문 내부에서 생성된 변수(반복문 변수 및 단계 출력)는 반복문 내에서만 접근 가능합니다.
* 이 변수들은 루프가 종료될 때 초기화되며, 루프 외부에서 접근하면 null이 됩니다.
* 반복문은 반복문 외부에서 정의된 변수에 접근할 수 있습니다.

**정수에 대한 간단한 반복문:**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: ${{ [range(1; 6)] }}
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
```

**지도를 위한 간단한 반복문:**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
```

**루프 안에서 점프하기:**

동일한 for 루프에 속하는 명명된 단계 사이만 점프할 수 있습니다. for 루프 안팎으로 점프하거나, 내부/외부 루프로 점프하거나, 두 개의 서로 다른 for 루프 사이로 점프하는 것은 허용되지 않습니다.

```yaml
  name: myWorkflow
  steps:
    - name: firstStep
      type: action
      action: internal.example.sayHello
      version: '1'
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: step3  # Okay within the loop
          - name: step2
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.step1.outputs.greeting }}'
          - name: step3
            type: action
            action: internal.example.sayHello
            version: '1'
            next: firstStep  # Not okay, first step is not in the loop context
```

**반복문에서 break/continue를 사용하세요:**

for 루프의 흐름을 변경하려면 `next: break` 또는 `next: continue` 사용할 수 있습니다. `break` 와 `continue` 루프 내에서 암묵적으로 정의된 예약된 점프 타겟임을 유의하십시오. 루프 외부에서 `next: break` 또는 `next: continue` 사용하면 열기우 단계의 끝으로 이동합니다.

`end` 은 루프 내에서 사용될 경우 `break` 과 동일한 역할을 합니다. Next는 스위치 단계 또는 모든 유형의 단계에서 사용할 수 있습니다.

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [range(1; 6)] }}'
        steps:
          - name: insideLoopStep1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: continue
          - name: insideLoopStep2
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
    - name: loopStepAgain
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: switchStep
            type: switch
            switch:
              - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                next: break
          - name: insideLoopStepAgain
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStepAgain.loop.element }}'
```

### 데이터를 사용한 조건 논리

```yaml
  steps:
    - name: checkCPU
      type: action
      action: newrelic.nerdgraph.execute
      version: 1
      # ... query configuration

    - name: decideAction
      type: switch
      switch:
        - condition: "${{ .steps.checkCPU.outputs.data.actor.account.nrql.results[0].average > 90 }}"
          next: resizeInstance
        - condition: "${{ .steps.checkCPU.outputs.data.actor.account.nrql.results[0].average > 70 }}"
          next: sendWarning
      next: normalOperation

    - name: resizeInstance
      type: action
      action: aws.ec2.modifyInstanceAttribute
      version: 1
      # ... resize configuration

    - name: sendWarning
      type: action
      action: slack.chat.postMessage
      version: 1
      # ... warning message

    - name: normalOperation
      type: action
      action: newrelic.ingest.sendLogs
      version: 1
      # ... log normal status
```

## 무엇 향후 계획

* **[문제 해결, 해결](/docs/workflow-automation/troubleshooting)**: 자격 증명 오류, 통합 문제, 워크플로우 실패를 수정합니다.
* **[모범 사례](/docs/workflow-automation/limitations-and-faq/workflow-best-practices)**: 오류 처리, 성능 최적화, 테스트 전략.
* **[팰런티우 제한](/docs/workflow-automation/limitations-and-faq/workflow-limits)**: 시간 초과, 비율 제한 및 제약 조건을 이해합니다.