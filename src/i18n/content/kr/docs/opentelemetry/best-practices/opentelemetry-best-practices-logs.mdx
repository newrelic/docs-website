---
title: 뉴렐릭의 OpenTelemetry 로그
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
  - Logs
metaDescription: Details on how New Relic works with OpenTelemetry logs
freshnessValidatedDate: '2024-05-17T00:00:00.000Z'
translationType: human
---

이 문서는 뉴렐릭이 전용 OTLP 엔드포인트를 통해 수신된 OpenTelemetry 로그를 어떻게 처리하는지 설명합니다.

OpenTelemetry 로그를 뉴렐릭으로 보내는 방법은 크게 두 가지가 있습니다.

* [수집기로 직접 전송](https://opentelemetry.io/docs/specs/otel/logs/#direct-to-collector):

  * 애플리케이션이 로그를 뉴렐릭 OTLP 엔드포인트로 직접 보낼 수 있습니다.
  * 구현과 관련된 자세한 내용은 [OpenTelemetry 언어 문서](https://opentelemetry.io/docs/languages/)를 참조하고, 뉴렐릭을 사용한 모니터링 서비스에 대한 자세한 내용은 [OpenTelemetry APM 모니터링](/docs/opentelemetry/get-started/apm-monitoring/opentelemetry-apm-intro/)을 참조하시기 바랍니다.

* [파일 또는 `stdout`를 통한 전송](https://opentelemetry.io/docs/specs/otel/logs/#via-file-or-stdout-logs):

  * 파일이나 표준 출력(`stdout`)에 기록된 애플리케이션 로그를 스크랩을 하는 방법입니다.

  * OpenTelemetry 수집기가 보통 이 작업에 사용되며, 스크랩된 로그는 뉴렐릭 OTLP 엔드포인트로 전달됩니다.

  * 보다 자세한 정보는 아래의 OpenTelemetry 리소스를 참조하십시오.

    * [OpenTelemetry 수집기](https://opentelemetry.io/docs/collector/)
    * [쿠버네티스와 파일 로그 수신기](https://opentelemetry.io/docs/kubernetes/collector/components/#filelog-receiver)
    * [Log4j2를 사용해 Java 애플리케이션에서 전송 방법을 보여주는 예시](https://github.com/newrelic/newrelic-opentelemetry-examples/tree/main/other-examples/java/logs-in-context-log4j2)

선택한 수집 방법에 관계없이 성공적인 통합을 위해서는 로그를 해당 엔드포인트로 내보내도록 로그 소스를 구성해야 합니다. 계속 진행하기 전에 [엔드포인트 설정 요구 사항](/docs/opentelemetry/best-practices/opentelemetry-otlp/#configure-endpoint-port-protocol)을 확인하십시오.

## OTLP 로그 레코드 매핑 [#otlp-log-mapping]

뉴렐릭은 OTLP 로그 레코드를 `Log` 데이터 유형에 매핑합니다. 아래 표는 [`LogRecord` proto 메시지](https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/logs/v1/logs.proto)의 필드가 뉴렐릭 `Log`에 매핑되는 방식을 설명합니다.

<table>
  <thead>
    <tr>
      <th>
        OTLP `logs.proto` 필드
      </th>

      <th>
        뉴렐릭 `Log` 필드
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `ResourceLogs.Resource.attributes`
      </td>

      <td>
        각 키/값은 `Log` 필드의 속성입니다 **\[1]**
      </td>
    </tr>

    <tr>
      <td>
        `ScopeLogs.InstrumentationScope.name`
      </td>

      <td>
        `otel.library.name`
      </td>
    </tr>

    <tr>
      <td>
        `ScopeLogs.InstrumentationScope.version`
      </td>

      <td>
        `otel.library.version`
      </td>
    </tr>

    <tr>
      <td>
        `ScopeLogs.InstrumentationScope.attributes`
      </td>

      <td>
        각 키/값은 `Log` 필드의 속성입니다 **\[1]**
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.time_unix_nanos`
      </td>

      <td>
        `timestamp` **\[2]**
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.severity_number`
      </td>

      <td>
        `severity.number`
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.severity_text`
      </td>

      <td>
        `severity.text`
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.body`
      </td>

      <td>
        `message`, 또는 구문 분석이 된 속성 **\[3]**
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.attributes`
      </td>

      <td>
        각 키/값은 `Log` 필드의 속성입니다 **\[1]**
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.dropped_attribute_count`
      </td>

      <td>
        `otel.dropped_attributes_count`
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.flags`
      </td>

      <td>
        `w3c.flags` (정수)
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.trace_id`
      </td>

      <td>
        `trace.id`
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.span_id`
      </td>

      <td>
        `span.id`
      </td>
    </tr>
  </tbody>
</table>

### 표 각주 [#otlp-mapping-notes]

**\[1]** 리소스 속성, 범위 속성, 로그 레코드 속성, 최상위 레벨 로그 레코드 필드 및 `LogRecord.body`의 구문 분석된 속성이 충돌하는 경우 **\[3]** 선례의 순서(높은 순에서 낮은 순)는 `LogRecord.body` -> 최상위 레벨 `LogRecord.*` 필드 > `LogRecord.attributes` > `ScopeLogs.InstrumentationScope.attributes` > `ResourceLogs.Resource.attributes`입니다.

**\[2]** `LogRecord.time_unix_nanos`가 없으면 `timestamp`가 뉴렐릭이 데이터를 수신한 시간으로 설정됩니다.

**\[3]** [로그 구문 분석(파싱)](/docs/logs/ui-data/parsing/)은 평문 로그 텍스트에서 속성 추출을 시도하기 위해 `LogRecord.body`에 적용됩니다. 예를 들어 JSON 구조의 로그 포맷을 사용하는 경우 키/값은 결과 로그의 속성이 됩니다. 이는 파일 또는 `stdout`에서 로그를 수집할 때 특히 유용합니다. 이 경우 로그 레코드( [APM 서비스 상호 연관](#service-correlation)에 필요)와 연결된 리소스 속성이 없고 `LogRecord.trace_id` / `LogRecord.span_id` ( [트레이스 상호 연관](#trace-correlation)에 필요)에 대한 값이 없는 것이 일반적입니다. 필수 필드를 성공적으로 구문 분석할 수 있으면 상호 연관이 의도한 대로 작동합니다.

## OpenTelemetry APM 서비스와의 상관관계 [#service-correlation]

로그에 [필수 속성](/docs/opentelemetry/best-practices/opentelemetry-best-practices-resources/#required-attributes)이 포함된 경우 로그는 서비스 엔터티와 상호 연관됩니다. 일반적으로 이는 `ResourceLogs.Resource.attributes` 같은 로그의 리소스 속성에서 나오지만 [OTLP 매핑의 각주 3](#otlp-mapping-notes)에 설명된 대로 `LogRecord.body`에서 구문 분석이 될 수도 있습니다.

서비스의 로그를 보려면 해당 서비스의 [로그 페이지](/docs/logs/ui-data/use-logs-ui/)로 이동하십시오.

## 트레이스와의 상호 연관 [#trace-correlation]

`trace.id`와 `span.id` 속성을 완료(resolve) 할 수 있는 경우 로그는 트레이스와 상호 연관됩니다. 일반적으로 이는 `LogRecord.trace_id`와 `LogRecord.span_id` 필드에서 나오지만 [OTLP 매핑](#otlp-mapping-notes)의 각주 3번에 설명된 대로 `LogRecord.body`에서 구문 분석이 될 수도 있습니다.

특정 트레이스의 컨텍스트에서 기록된 로그를 보는 방법은 두 가지가 있습니다.

* [트레이스 세부정보 페이지](/docs/distributed-tracing/ui-data/trace-details/#view-your-logs)에서 **로그** 탭으로 이동합니다.
* 서비스의 [로그 페이지](/docs/logs/ui-data/use-logs-ui/)로 이동하여 로그를 클릭하여 로그 세부 정보를 엽니다. 트레이스와 연관이 된 경우 **로그 세부정보**에서 **트레이스 세부정보**로 이동할 수 있습니다.
