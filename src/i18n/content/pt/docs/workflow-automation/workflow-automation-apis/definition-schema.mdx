---
title: Esquema de definição de fluxo de trabalho
tags:
  - workflow automation
  - workflow schemas
  - workflow automation API
metaDescription: Workflow definitions are written in YAML. Keys use a camelCase naming convention.
freshnessValidatedDate: never
translationType: machine
---

<Callout title="visualização">
  Ainda estamos trabalhando nesse recurso, mas adoraríamos que você experimentasse!

  Atualmente, esse recurso é fornecido como parte de um programa de visualização de acordo com nossas [políticas de pré-lançamento](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy).
</Callout>

## Visão geral

Uma definição de fluxo de trabalho descreve o processo automatizado a ser executado. As definições de fluxo de trabalho são escritas em YAML usando uma convenção de nomenclatura `camelCase`. Cada fluxo de trabalho consiste em:

* **Propriedades do esquema**: Informações básicas (nome, descrição, entradas)
* **Etapas**: A sequência de ações a serem executadas
* **Expressões**: Valores dinâmicos usando a sintaxe jq
* **Segredos**: Referências de credenciais seguras

## Conceitos fundamentais

Antes de criar fluxos de trabalho, entenda estes conceitos básicos usados em todas as definições de fluxo de trabalho.

### Cadeias de expressões [#expression-strings]

Diversas propriedades aceitam valores de string com expressões incorporadas que são avaliadas durante a execução do fluxo de trabalho, permitindo valores dinâmicos nas definições do fluxo de trabalho.

As cadeias de expressões podem conter uma ou mais expressões, cada uma delimitada por chaves duplas. O conteúdo entre chaves é avaliado usando [jq](https://jqlang.org/manual/), que fornece recursos poderosos para acessar e manipular valores.

**Exemplo**:

Obter o comprimento de uma string de entrada de fluxo de trabalho:

`${{ .workflowInputs.myString | length }}`

Para validar e testar suas expressões, use o [JQ Playground](https://play.jqlang.org/).

### Propriedades de expressão [#expression-properties]

Diversas propriedades podem ser acessadas por meio de expressões. Essas propriedades residem em um objeto `scope`, portanto, as expressões devem começar com um ponto `(.)` para acessar essas propriedades do objeto de escopo.

Os imóveis disponíveis são:

* `workflowInputs` - Objeto contendo as entradas passadas para o fluxo de trabalho no início.

**Exemplo**:

`${{ .workflowInputs.myInput }}`

* `steps` - Objeto contendo uma propriedade para cada etapa do fluxo de trabalho
* `steps.<stepName>` - Objeto contendo propriedades para uma etapa específica
* `steps.<stepName>.outputs` - Objeto contendo propriedades de resultado, específicas para a etapa ou ação.

**Exemplo**: `${{ .steps.myStep.outputs.myResult }}`

### Resultados da avaliação da expressão [#expression-evaluation-results]

Uma única expressão jq pode resultar em qualquer tipo JSON. No entanto, o resultado final de uma string de expressão depende de a string conter apenas a expressão ou conteúdo adicional.

**Expressão única (preserva o tipo JSON)**:

Se uma string de expressão consistir em apenas uma expressão sem conteúdo circundante, ela será avaliada como o resultado da expressão jq, mantendo seu tipo JSON original. Por exemplo, `${{ .workflowInputs.myArray }}` é avaliado como uma matriz. Isso é útil para transmitir estruturas de dados complexas dentro de um fluxo de trabalho.

**Expressões múltiplas ou conteúdo misto (converte para string)**:

Se uma expressão contiver conteúdo que não seja uma única expressão, ela será avaliada como um resultado em formato de string. Isso ocorre quando uma expressão tem conteúdo antes ou depois dela, ou quando a string contém múltiplas expressões. Cada expressão dentro da string é avaliada e convertida em uma representação em string.

<Callout variant="important">
  Quando uma expressão jq é avaliada como nula, um nó nulo é retornado. Por exemplo, a expressão `${{ .workflowInputs.missingInput }}` retorna nulo se `missingInput` não for fornecido como entrada do fluxo de trabalho.
</Callout>

**Exemplo**:

Vamos supor que `myArray` tenha o valor de `[1, 2, 3]`.

<table>
  <thead>
    <tr>
      <th>
        string de expressão
      </th>

      <th>
        Dados de resultados
      </th>

      <th>
        Tipo de resultado
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `${{ .workflowInputs.myArray }}`
      </td>

      <td>
        `[1, 2, 3]`
      </td>

      <td>
        matriz de números
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        3
      </td>

      <td>
        Número
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        Verdadeiro
      </td>

      <td>
        Boleano
      </td>
    </tr>

    <tr>
      <td>
        `Input is not empty: ${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        `"Input is not empty: true"`
      </td>

      <td>
        Corda
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray }} has length ${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        `"has length 3"`
      </td>

      <td>
        Corda
      </td>
    </tr>
  </tbody>
</table>

### Expressão padrão seguro [#expression-safe-pattern]

As propriedades que podem ser usadas em expressões devem estar em conformidade com: `^[A-Za-z_][A-Za-z0-9_]*$`

### Referências secretas [#secret-references]

Os valores secretos podem ser usados em ações por meio de strings de referência que especificam o nome de um segredo a ser pesquisado no Serviço de Segredos. Para referenciar um segredo em uma definição de fluxo de trabalho, use a seguinte sintaxe:

* `${{ :secrets:<SECRET_NAME> }}` para um segredo que não está em um `namespace`
* `${{ :secrets:<NAMESPACE>:<SECRET_NAME> }}` para um segredo em um `namespace`
* `${{ :secrets:<SCOPE>:<NAMESPACE>:<SECRET_NAME> }}` para um segredo no escopo e namespace. O escopo aceita apenas `ACCOUNT` ou `ORGANIZATION` por enquanto.

Uma string de expressão pode conter uma mistura de referências secretas e expressões JQ `and/or` múltiplas referências secretas.

**Exemplos**:

```yaml
  steps:
  - name: mySecretStep
    type: action
    action: newrelic.instrumentation.log
    inputs:
      message: My message
      licenseKey: ${{ :secrets:<SECRET_NAME> }}
```

```yaml
  steps:
    - name: bearer_auth
      type: action
      action: utils.http.post
      inputs:
        headers:
          Authorization: Bearer ${{ :secrets:<SECRET_NAME> }}
```

## Estrutura do esquema

### Propriedades do esquema

<table>
  <thead>
    <tr>
      <th>
        Propriedade
      </th>

      <th>
        Obrigatório ou opcional
      </th>

      <th>
        Tipo
      </th>

      <th>
        Formatar
      </th>

      <th>
        Restrições
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`name`**
      </td>

      <td>
        Obrigatório
      </td>

      <td>
        Corda
      </td>

      <td>
        Deve estar em conformidade com a expressão regular. 

        `^[A-Za-z_][A-Za-z0-9_-]*$`
      </td>

      <td>
        **Comprimento máximo**

        : 100
      </td>

      <td>
        Os valores 

        **`name`**

         não diferenciam maiúsculas de minúsculas. Por exemplo, 

        `ExampleWorkflow`

        , 

        `exampleworkflow`

         e 

        `EXAMPLEWORKFLOW`

         são todos considerados como representando a mesma definição de fluxo de trabalho.
      </td>
    </tr>

    <tr>
      <td>
        **`description`**
      </td>

      <td>
        Opcional
      </td>

      <td>
        Corda
      </td>

      <td>
        Deve estar em conformidade com a expressão regular. 

        `^[A-Za-z0-9 _-]*$`
      </td>

      <td>
        **Comprimento máximo**

        : 200
      </td>

      <td>
        Um 

        `description`

         do fluxo de trabalho descrevendo o propósito do fluxo de trabalho.
      </td>
    </tr>

    <tr>
      <td>
        **`workflowInputs`**
      </td>

      <td>
        Opcional
      </td>

      <td />

      <td>
        Mapa de mapas
      </td>

      <td>
        **Tamanho máximo**

        : 100
      </td>

      <td>
        Um mapa das entradas de fluxo de trabalho que o fluxo de trabalho aceita. Veja as características detalhadas abaixo.
      </td>
    </tr>
  </tbody>
</table>

### entradas de fluxo de trabalho

**Exemplo**:

```yaml
    workflowInputs:
  myInput1:
    type: String
  myInput2:
    type: Number
    defaultValue: 42
```

* **`workflowInputs.<inputName>`** (Obrigatório)

  * **Tipo**: String (em conformidade com [o padrão de segurança de expressão](#expression-safe-pattern))
  * **Comprimento mínimo**: 1
  * **Comprimento máximo**: 50
  * **Descrição**: O nome da entrada do fluxo de trabalho.

* **`workflowInputs.<inputName>.type`** (Obrigatório)

  * **Tipo**: Enum (`Boolean, List, Map, String, Int, Float`)
  * **Descrição**: O tipo de dados da entrada do fluxo de trabalho.

* **`workflowInputs.<inputName>.defaultValue`** (Opcional)

  * **Tipo**: Qualquer; deve estar em conformidade com `type`.
  * **Descrição**: O valor padrão para a entrada do fluxo de trabalho.

* **`workflowInputs.<inputName>.required`** (Opcional)

  * **Tipo**: Booleano (`True`, `False`).
  * **Descrição**: O valor padrão deste campo é &quot;Verdadeiro&quot;.

* **`workflowInputs.<inputName>.enumValues`** (Opcional)

  * **Tipo**: Lista (`String`).
  * **Descrição**: O valor padrão deste campo é uma lista vazia `{}`. Isso é necessário quando o tipo workflowInput é Enum.

* **`workflowInputs.<inputName>.validations`** (Opcional)

  * **Tipo**: matriz de mapas.
  * **Descrição**: Validações a serem realizadas nas entradas do fluxo de trabalho fornecidas pelo usuário. Este campo é opcional. As propriedades descritas aqui estão presentes em todos os tipos de validação. Os Tipos de Validação Específicos suportam propriedades adicionais, conforme discutido na seção [Tipos de Validação](#validation-types).

* **`validations[*].type`** (Obrigatório)

  * **Tipo**: String
  * **Descrição**: O tipo de validação que indica qual validação ocorrerá neste campo. Consulte [Tipos de Validação](#validation-types) para obter mais informações sobre cada tipo de validação.

* **`validations[*].errorMessage`** (Obrigatório)

  * **Tipo**: String
  * **Descrição**: A mensagem de erro que o usuário deseja receber quando uma validação específica falhar.

#### Exemplo de YAML para validações

```yaml
  name: calendar_demo

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'
      validations:
        - type: regex
          errorMessage: "The provided timezone is not correct"
          pattern: "^[A-Za-z]+\/[A-Za-z_]+(?:\/[A-Za-z_]+)?$"

        - type: maxLength
          errorMessage: "Timezone length should be less than 100"
          length: 100

    accountId:
      type: Int
      validations:
        - type: minIntValue
          errorMessage: "Account id should be greater than 100000"
          minValue: 100000
        - type: maxIntValue
          errorMessage: "Account id should be less than 9999999"
          maxValue: 9999999

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'
        selectors:
          - name: timezone
            expression: '.responseBody | fromjson.abbreviation'
          - name: datetime
            expression: '.responseBody | fromjson.datetime'
```

### Tipos de validação [#validation-types]

<table>
  <thead>
    <tr>
      <th>
        Tipo de validação
      </th>

      <th>
        Propriedade
      </th>

      <th>
        Obrigatório ou opcional
      </th>

      <th>
        Tipo
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`regex`**
      </td>

      <td>
        `validations[*].pattern`
      </td>

      <td>
        Obrigatório
      </td>

      <td>
        Corda
      </td>

      <td>
        Valida o valor de entrada do fluxo de trabalho em relação ao padrão regex fornecido.
      </td>
    </tr>

    <tr>
      <td>
        **`maxIntValue`**
      </td>

      <td>
        `validations[*].maxValue`
      </td>

      <td>
        Obrigatório
      </td>

      <td>
        Inteiro
      </td>

      <td>
        Valida se o valor de entrada do fluxo de trabalho deve ser menor que o valor máximo fornecido.
      </td>
    </tr>

    <tr>
      <td>
        **`minIntValue`**
      </td>

      <td>
        `validations[*].minValue`
      </td>

      <td>
        Obrigatório
      </td>

      <td>
        Inteiro
      </td>

      <td>
        Valida se o valor de entrada do fluxo de trabalho deve ser maior que o valor mínimo fornecido.
      </td>
    </tr>

    <tr>
      <td>
        **`maxLength`**
      </td>

      <td>
        `validations[*].length`
      </td>

      <td>
        Obrigatório
      </td>

      <td>
        Inteiro
      </td>

      <td>
        Valida o comprimento máximo das strings de entrada do fluxo de trabalho e das coleções (

        `Array, Set, Map, etc.`

        ).
      </td>
    </tr>
  </tbody>
</table>

## Passos [#steps]

<table>
  <thead>
    <tr>
      <th>
        Propriedade
      </th>

      <th>
        Obrigatório ou opcional
      </th>

      <th>
        Tipo
      </th>

      <th>
        Restrições
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`steps`**
      </td>

      <td>
        Obrigatório
      </td>

      <td>
        matriz de mapas
      </td>

      <td />

      <td>
        Etapas a serem executadas quando a definição do fluxo de trabalho for acionada. Deve haver pelo menos um passo. As propriedades descritas aqui estão presentes em todos os tipos de degrau. Tipos de etapas específicos suportam propriedades adicionais, conforme descrito na seção 

        [Tipos de etapas](#step-types)

        .
      </td>
    </tr>
  </tbody>
</table>

<Callout variant="important">
  Os passos são executados na ordem em que são definidos na matriz `steps`. Se uma ordem diferente for desejada, um `jump` pode ser realizado definindo a propriedade `steps[*].next` para o nome do passo desejado para pular.
</Callout>

### Propriedades comuns dos degraus

<table>
  <thead>
    <tr>
      <th>
        Propriedade
      </th>

      <th>
        Obrigatório ou opcional
      </th>

      <th>
        Tipo
      </th>

      <th>
        Formatar
      </th>

      <th>
        Restrições
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`steps[*].name`**
      </td>

      <td>
        Obrigatório
      </td>

      <td>
        Corda
      </td>

      <td>
        Deve estar em conformidade com 

        [o padrão seguro de expressão,](#expression-safe-pattern)

         não pode ser 

        `end`

        .
      </td>

      <td>
        **Comprimento máximo:**

         100
      </td>

      <td>
        O nome da etapa a ser referenciada por 

        `steps[*].next`

        . Não podem ser as palavras-chave especiais 

        `end`

        , 

        `continue`

         ou 

        `break`

        , pois estas são usadas para indicar uma etapa de término, uma continuação de um loop ou para sair de um loop.
      </td>
    </tr>

    <tr>
      <td>
        **`steps[*].type`**
      </td>

      <td>
        Obrigatório
      </td>

      <td>
        Corda
      </td>

      <td />

      <td />

      <td>
        O tipo da etapa, indicando o que a etapa faz quando executada. Consulte os 

        [tipos de etapas](#step-types)

         abaixo para ver as opções disponíveis.
      </td>
    </tr>

    <tr>
      <td>
        **`steps[*].next`**
      </td>

      <td>
        Opcional
      </td>

      <td>
        Corda
      </td>

      <td>
        Deve estar em conformidade com o padrão de segurança de expressão.
      </td>

      <td />

      <td>
        O nome da próxima etapa a ser executada quando esta etapa for concluída com sucesso. A palavra-chave especial &quot;end&quot; pode ser usada para indicar que esta etapa deve ser a última a ser executada. Se 

        `next`

         for omitido, a entrada seguinte na matriz de definição 

        `steps`

         será usada como a próxima etapa implícita. Caso não haja nenhuma entrada subsequente, o fluxo de trabalho será concluído.
      </td>
    </tr>

    <tr>
      <td>
        **`steps[*].ignoreErrors`**
      </td>

      <td>
        Opcional
      </td>

      <td>
        Boleano
      </td>

      <td />

      <td />

      <td>
        O 

        `ignoreErrors`

         é uma opção de configuração dentro de uma etapa de um fluxo de trabalho. O valor padrão é falso. Ao definir 

        `ignoreErrors`

         para 

        `true`

        , o fluxo de trabalho garante que quaisquer erros encontrados durante a execução desta etapa não farão com que todo o fluxo de trabalho falhe. Em vez disso, o fluxo de trabalho continuará executando as etapas subsequentes.
      </td>
    </tr>
  </tbody>
</table>

## Tipos de etapas [#step-types]

### Ação [#action]

Uma etapa que executa uma ação específica. Consulte o [catálogo de ações](/docs/workflow-automation/setup-and-configuration/actions-catalog/actions-catalog) para ver as opções disponíveis.

* **`steps[*].action`** (Obrigatório)

  * **Tipo**: String
  * **Descrição**: O nome completo da função de ação a ser executada. Deve seguir a seguinte convenção: `<company domain>.<category of work>.<action name in camelCase>`

**Exemplo**:

* Ação utilizando os serviços do New Relic (por exemplo, através do NerdGraph): `newrelic.dashboards.getDashboard`

* Ação usando o Slack: `slack.chat.postMessage`

* **`steps[*].version`** (Obrigatório)

  * **Tipo**: String
  * **Descrição**: A versão da função de ação a ser executada.

* **`steps[*].inputs`** (Opcional)

  * **Tipo**: Mapa de valores (inclui expressões)

  * **Descrição**:

    * Os parâmetros a serem passados para a função de ação. As entradas específicas aceitas são definidas por cada ação.
    * As entradas podem usar expressões. Consulte a seção Cadeias de Expressão para obter detalhes.

  <Callout variant="important">
    Não devem ser passados dados sensíveis (nenhuma chave de API ou segredos, nenhum dado PII, PHI ou qualquer dado de identificação pessoal) como argumentos.
  </Callout>

* **`steps[*].inputs.selectors`** (Opcional)

  * **Tipo**: lista de mapas no formato `name` com `expression`.

  * **Descrição**:

    * A entrada `selectors` permite redefinir a saída para retornar apenas os elementos especificados.
    * Podem ser utilizadas expressões. Consulte a seção [Cadeias de expressão](#expression-strings) para obter detalhes.

**Exemplo**:

* No exemplo dado, estamos recebendo `timezone` e `datetime` como resposta da ação http.get.

```yaml
  name: calendar_demo

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'
    accountId:
      type: Int

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'
        selectors:
          - name: timezone
            expression: '.responseBody | fromjson.abbreviation'
          - name: datetime
            expression: '.responseBody | fromjson.datetime'
```

### Laço [#loop]

Um loop itera sobre coleções (listas, mapas, arrays) e cria automaticamente as variáveis `index` e `element` para cada iteração. Essas variáveis de loop são acessíveis apenas dentro do loop usando `${{ .steps.<loopStepName>.loop.element }}` ou `${{ .steps.<loopStepName>.loop.index }}`

**Propriedades:**

* **`steps[*].for`** (Obrigatório)

  * **Tipo**: Constante
  * **Descrição**: Sinaliza o início de um loop

* **`steps[*].in`** (Obrigatório)

  * **Tipo**: String (expressão)
  * **Descrição**: Expressão que avalia uma coleção de elementos

* **`steps[*].steps`** (Obrigatório)

  * **Descrição**: Etapas executadas em cada iteração. Pode incluir qualquer tipo de etapa, incluindo loops aninhados.

<Callout variant="important">
  * **para:** (obrigatório). Este é o elemento de nível superior que indica o início de um loop for.
  * **em:** (obrigatório). Para que a coleção de entrada seja iterada, ela deve ser convertível para Java Array.
  * **etapas:** (obrigatório). Em cada iteração, as etapas serão executadas.
  * **element** e **index** são atribuídos automaticamente como parte do loop.
  * `index` é baseado em zero, `element` pode ser um tipo complexo se você tiver uma coleção de elementos complexos.
  * As variáveis criadas dentro do loop (variáveis do loop e saídas de cada etapa) só são acessíveis dentro do próprio loop.
  * Essas variáveis são zeradas quando o loop termina e serão nulas se acessadas fora do loop.
  * Os loops podem acessar variáveis definidas fora do loop.
</Callout>

**Exemplo: Loop básico**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element : ${{ .steps.loopStep.loop.element }} , Index : ${{ .steps.loopStep.loop.index }}' # not exist outside of this loop
```

**Exemplo: Loop em inteiros**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: ${{ [range(1; 6)] }}
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }} , Index : ${{ .steps.loopStep.loop.index }}'  # Element : [1, 2, 3, 4, 5] , Index : [0, 1, 2, 3, 4]
```

**Exemplo: Loop no mapa**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element : ${{ .steps.loopStep.loop.element }} , Index : ${{ .steps.loopStep.loop.index }}'  # Element: [{ "key1": "val1" }, { "key2": "val2"}] , Index : [0, 1]
```

**Exemplo: Pular dentro de um loop**

É permitido pular entre as etapas dentro do mesmo loop. Não é permitido pular para dentro/fora de loops, entre loops diferentes ou para loops pai/filho.

```yaml
  name: myWorkflow
  steps:
    - name: firstStep
      type: action
      action: example.messaging.sayHello
      version: '1.0.0'
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: step3                                 # Okay within the loop
          - name: step2
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.step1.outputs.greeting }}'
          - name: step3
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            next: firstStep                            # Not okay, first step is not in the loop context
```

**Exemplo: Interromper e continuar**

Use `next: break` ou `next: continue` para controlar o fluxo do loop. Estas são palavras-chave reservadas dentro de loops. Fora dos loops, eles saltam para o final do fluxo de trabalho. Observação: `end` se comporta como `break` dentro de loops.

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [range(1; 6)] }}'
        steps:
          - name: insideLoopStep1
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: continue
          - name: insideLoopStep2
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
    - name: loopStepAgain
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: switchStep
            type: switch
            switch:
              - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                next: break
          - name: insideLoopStepAgain
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.loopStepAgain.loop.element }}'
```

**Exemplo simples:**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: "${{ [range(1; 5)] }}"
        steps:
          - name: step1
            type: action
            action: newrelic.ingest.sendLogs
            version: 1
            inputs:
              logs:
                - message: "Loop: ${{ .steps.loopStep.loop.element }}"
```

### Trocar [#switch]

* Uma etapa que verifica várias condições e executa o primeiro ramo que resulta em verdadeiro.

* Um switch pode conter qualquer número de `condition` elementos em uma lista. O sistema verificará as condições em ordem e processará a primeira que for avaliada como verdadeira. Se nenhuma for avaliada como verdadeira, executará sua etapa `next` conforme definido em `steps[*].next`.

  * **`steps[*].switch`** (Obrigatório)

    * **Tipo**: matriz
    * **Descrição**: Uma matriz de casos de alternância, especificando a lista ordenada de condições a serem avaliadas.

  * **`steps[*].switch[*].condition`** (Obrigatório)

    * **Tipo**: String ([expressão](#expression-strings))
    * **Descrição**: O estado da caixa do interruptor. Se avaliado como verdadeiro, o passo do caso `next` será executado.
    * Consulte a seção [Cadeias de expressão](#expression-strings) para obter detalhes.

  * **`steps[*].switch[*].next`** (Obrigatório)

    * **Tipo**: String (em conformidade com [o padrão de segurança de expressão](#expression-safe-pattern))
    * **Descrição**: O nome da etapa a ser executada se a condição do caso for avaliada como verdadeira. A palavra-chave especial `end` pode ser usada para indicar que esta etapa deve ser a última a ser executada.

  ```yaml
    - name: hasCompleted
      type: switch
      switch:
        - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Failed" }}
          next: displayError
        - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Success" }}
          next: displaySuccess
      next: displayUnexpected
  ```

### Espere [#wait]

Uma etapa que pausa a execução do fluxo de trabalho por um número específico de segundos antes de continuar.

A etapa de espera também pode ficar à escuta de um ou mais sinais. Cada sinal deve ter uma próxima etapa correspondente definida em uma lista. Se um sinal for recebido durante o período de espera, o primeiro sinal recebido será processado e o fluxo de trabalho executará a próxima etapa definida. Caso nenhum sinal seja recebido, o fluxo de trabalho continua normalmente após o término do período de espera.

O valor recebido de um sinal é armazenado na saída da etapa de espera e pode ser usado em etapas subsequentes para lógica ou processamento.

**Exemplo**:

```yaml
  name: waitSignalExample
  workflowInputs:
  steps:
    - name: waitStep
      type: wait
      seconds: 300
      signals: [{name: 'mySignalName', next: 'firstStep'}]
    - name: endStep
      type: action
      action: newrelic.instrumentation.log
      version: 1
      inputs:
        message: "didn't get signal"
      next: end
    - name: firstStep
      type: action
      action: newrelic.instrumentation.log
      version: 1
      inputs:
        message: ${{ .steps.waitStep.outputs.signalInputs.myString }}
```

* **`steps[*].seconds`** (Obrigatório)

  * **Tipo**: Número
  * **Descrição**: O número de segundos a aguardar antes de continuar a execução do fluxo de trabalho.

* **`steps[*].signals`**

  * **Tipo**: matriz
  * **Descrição**: Os sinais que, quando recebidos, irão desviar o fluxo do programa.

* **`steps[*].signals[*].name`**

  * **Tipo**: String
  * **Descrição**: O nome do sinal a ser monitorado.

* **`steps[*].signals[*].next`**

  * **Tipo**: String
  * **Descrição**: O passo a ser executado se o sinal especificado for recebido.

### Atribuir [#assign]

Uma etapa que define variáveis para uso em todo o fluxo de trabalho. Esta etapa atribui valores a variáveis que podem ser referenciadas em etapas subsequentes. Ao definir todas as variáveis em um só lugar, esse tipo de etapa torna o fluxo de trabalho mais legível e otimizado.

**Exemplo de fluxo de trabalho**:

```yaml
  name: sampleWorkflowWithAssign
  description: WorkflowAssignDemo

  workflowInputs:
    initialValue:
      type: String
    anotherValue:
      type: Int

  steps:
    - name: runAction
      type: action
      action: internal.http.post
      version: 1
      inputs:
        url: 'http://localhost:8505/tasks/gc' # temporal-activity-worker-java service port
        selectors:
          - name: statusCode
            expression: '.statusCode'
          - name: responseBody
            expression: '.responseBody'
    - name: variableInitialization
      type: assign
      inputs:
        stringVar: "${{ .workflowInputs.initialValue }}"
        intVar: "${{ .workflowInputs.anotherValue }}"
        concatenationVar: "${{ .workflowInputs.initialValue }} - concatenated"
        booleanVar: true
        mapVar:
          key1: "value1"
          key2: "${{ .workflowInputs.initialValue }}"
        listVar:
          - "listItem1"
          - "${{ .workflowInputs.initialValue }}"
          - "${{ .workflowInputs.anotherValue }}"
        statusCode: ${{ .steps.runAction.outputs.statusCode }}

    - name: wait
      type: wait
      seconds: 2

    - name: logVariables
      type: action
      action: newrelic.ingest.sendLogs
      version: 1
      inputs:
        logs:
          - message: "stringVar: ${{ .steps.variableInitialization.outputs.stringVar }}"
          - message: "intVar: ${{ .steps.variableInitialization.outputs.intVar }}"
          - message: "concatenationVar: ${{ .steps.variableInitialization.outputs.concatenationVar }}"
          - message: "booleanVar: ${{ .steps.variableInitialization.outputs.booleanVar }}"
          - message: "mapVar: ${{ .steps.variableInitialization.outputs.mapVar | tojson }}"
          - message: "listVar: ${{ .steps.variableInitialization.outputs.listVar | tojson }}"
          - message: "statusCode: ${{ .steps.variableInitialization.outputs.statusCode }}"
```

* **`steps[*].inputs`** (Obrigatório)

  * **Tipo**: Mapa de valores (inclui [expressões](#expression-strings))
  * **Descrição**:
    * As entradas consistem em um mapa de nomes de variáveis e seus respectivos valores atribuídos. Quando referências secretas são atribuídas a variáveis, elas permanecem como referências secretas e não são convertidas em seus valores reais. No entanto, outras expressões (como entradas de fluxo de trabalho) são avaliadas e convertidas em seus valores reais.
  * Tipos de entrada permitidos: `Integer`, `Double`, `Boolean`, `String`, `Array`, `Map`

## Exemplo completo [#examples]

### Demonstração do calendário

Um exemplo completo de fluxo de trabalho que demonstra vários recursos de fluxo de trabalho, incluindo entradas de fluxo de trabalho, ações HTTP, seletores, etapas de espera, consulta NRQL, instruções switch e notificação Slack.

```yaml
  name: calendar_demo

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'
    accountId:
      type: Int

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'
        selectors:
          - name: timezone
            expression: '.responseBody | fromjson.abbreviation'
          - name: datetime
            expression: '.responseBody | fromjson.datetime'

    - name: logTime
      type: action
      action: newrelic.instrumentation.log
      version: 1
      inputs:
        message: 'DEMO: In the ${{ .steps.getCurrentTime.outputs.timezone }} timezone, the current time is ${{ .steps.getCurrentTime.outputs.datetime }}'
        licenseKey: ${{ :secrets:STAGING_NEW_RELIC_LICENSE_KEY }}

    - name: wait
      type: wait
      seconds: 1

    - name: queryForLog
      type: action
      action: newrelic.nrql.query
      version: 1
      inputs:
        accountIds: ['${{ .workflowInputs.accountId }}']
        query: FROM Log SELECT * WHERE message LIKE 'DEMO:%${{ .steps.getCurrentTime.outputs.datetime }}'

    - name: checkQuery
      type: switch
      switch:
        - condition: ${{ .steps.queryForLog.outputs.results | length > 0 }}
          next: postResultsMessage

    - name: postWaitingMessage
      type: action
      action: slack.chat.postMessage
      version: 1
      inputs:
        channel: test-channel-workflow
        text: Waiting for log message...
        token: ${{ :secrets:dn_staging_slack_token }}
      next: wait

    - name: postResultsMessage
      type: action
      action: slack.chat.postMessage
      version: 1
      inputs:
        channel: test-channel-workflow
        text: 'Found log message! ${{ .steps.queryForLog.outputs.results[0].message }}'
        token: ${{ :secrets:dn_staging_slack_token }}
```