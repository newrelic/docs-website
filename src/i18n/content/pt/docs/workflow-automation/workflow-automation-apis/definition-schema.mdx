---
title: Esquema de definição de fluxo de trabalho
tags:
  - workflow automation
  - workflow schems
  - workflow automation API
metaDescription: Workflow definitions are written in YAML. Keys use a camelCase naming convention.
freshnessValidatedDate: never
translationType: machine
---

<Callout title="visualização">
  Ainda estamos trabalhando nesse recurso, mas adoraríamos que você experimentasse!

  Atualmente, esse recurso é fornecido como parte de um programa de visualização de acordo com nossas [políticas de pré-lançamento](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy).
</Callout>

## Esquema

As definições de fluxo de trabalho são escritas em YAML. As chaves usam a convenção de nomenclatura `camelCase`.

### **nome** (obrigatório)

* **Tipo**: String
* **Formato**: Deve estar em conformidade com a expressão regular `^[A-Za-z_][A-Za-z0-9_-]*$`.
* **Comprimento máximo**: 100
* **Descrição**: Os valores `name` não diferenciam maiúsculas de minúsculas. Por exemplo, `ExampleWorkflow`, `exampleworkflow` e `EXAMPLEWORKFLOW` são todos considerados como representando a mesma definição de fluxo de trabalho.

### **Descrição** (Opcional)

* **Tipo**: String
* **Formato**: Deve estar em conformidade com a expressão regular `^[A-Za-z0-9 _-]*$`.
* **Comprimento máximo**: 200
* **Descrição**: Um `description` do fluxo de trabalho que explica seu propósito.

### **workflowInputs** (Opcional)

* **Tipo**: Mapa de mapas
* **Tamanho máximo**: 100
* **Descrição**: Um mapa das entradas de fluxo de trabalho que o fluxo de trabalho aceita.
* **Exemplo**:

```java
  workflowInputs:
    myInput1:
      type: String
    myInput2:
      type: Number
      defaultValue: 42
```

* **`workflowInputs.<inputName>`** (Obrigatório)

  * **Tipo**: String (em conformidade com [o padrão de segurança de expressão]())
  * **Comprimento mínimo**: 1
  * **Comprimento máximo**: 50
  * **Descrição**: O nome da entrada do fluxo de trabalho.

* **`workflowInputs.<inputName>.type`** (Obrigatório)

  * **Tipo**: Enum (Booleano, Lista, Mapa, String, Inteiro, ponto flutuante)
  * **Descrição**: O tipo de dados da entrada do fluxo de trabalho.

* **`workflowInputs.<inputName>.defaultValue`** (Opcional)

  * **Tipo**: Qualquer; deve estar em conformidade com `type`.
  * **Descrição**: O valor padrão para a entrada do fluxo de trabalho.

* **Etapas** (Obrigatórias)

  * **Tipo**: matriz de mapas
  * **Descrição**: Os passos a serem executados quando a definição do fluxo de trabalho for acionada. Deve haver pelo menos um passo.

  <Callout variant="important">
    Os passos serão executados na ordem em que são definidos na matriz `steps`.

    Se uma ordem diferente for desejada, um &quot;salto&quot; pode ser realizado definindo a propriedade `steps[*].next` com o nome da etapa desejada para a qual se deseja pular.
  </Callout>

  * **`steps[*].name`** (Obrigatório)

    * **Tipo**: String (em conformidade com [o padrão seguro para expressões](); não pode ser `end`)
    * **Comprimento máximo**: 100
    * **Descrição**: O nome da etapa a ser referenciada por `steps[*].next`. Não podem ser as palavras-chave especiais `end`, `continue` ou `break`, pois estas são usadas para indicar uma etapa de término, uma continuação de um loop ou para sair de um loop.

  * **`steps[*].type`** (Obrigatório)

    * **Tipo**: String
    * **Descrição**: O tipo da etapa, indicando o que a etapa faz quando executada. Consulte a [seção Tipos de Etapas]() para ver as opções disponíveis.

  * [**`steps[*].next`**](#steps-next) (Opcional)

    * **Tipo**: String (em conformidade com [o padrão de segurança de expressão]())

    * **Descrição**:

      * O nome da próxima etapa a ser executada quando esta etapa for concluída com sucesso. A palavra-chave especial `end` pode ser usada para indicar que esta etapa deve ser a última a ser executada.
      * Se `next` for omitido, a entrada seguinte na matriz `steps` da definição será usada como o próximo passo implícito. Caso não haja nenhuma entrada subsequente, o fluxo de trabalho será concluído.

## Tipos de etapas

### **Ação**

Uma etapa que executa uma ação específica. Consulte o [Catálogo de Ações](/docs/workflow-automation/setup-and-configuration/actions-catalog/actions-catalog) para ver as opções disponíveis.

* **`steps[*].action`** (Obrigatório)

  * **Tipo**: String

  * **Descrição**: O nome completo da função de ação a ser executada. Deve seguir a seguinte convenção:

    `<company domain>.<category of work>.<action name in camelCase>`

  * **Exemplo**:

    * Ação utilizando os serviços do New Relic (por exemplo, através do NerdGraph): `newrelic.dashboards.getDashboard`
    * Ação usando o Slack: `slack.chat.postMessage`

* **`steps[*].version`** (Obrigatório)

  * **Tipo**: String
  * **Descrição**: A versão da função de ação a ser executada.

* **`steps[*].inputs`** (Opcional)

  * **Tipo**: Mapa de valores (inclui [expressões]())

  * **Descrição**:

    * Os parâmetros a serem passados para a função de ação. As entradas específicas aceitas são definidas por cada ação.
    * As entradas podem usar expressões. Consulte a seção [Cadeias de Expressões]() para obter detalhes.

  <Callout variant="important">
    Não devem ser passados dados sensíveis (nenhuma chave de API ou segredos, nenhum dado PII, PHI ou qualquer dado de identificação pessoal) como argumentos.
  </Callout>

* **`steps[*].inputs.selectors`** (Opcional)

  * **Tipo**: lista de mapas no formato `name` com `expression`.

  * **Descrição**:

    * A entrada `selectors` permite redefinir a saída para retornar apenas os elementos especificados.
    * A expressão pode ser usada. Consulte a seção [Cadeias de Expressões]() para obter detalhes.

  * **Exemplo**

    * No exemplo dado, estamos recebendo `pageUrl` e `statusDescription` como resposta da ação http.get.

    ```yaml
        name: status
        description: A workflow for checking the status of New Relic components

        steps:
          - name: query1
            type: action
            action: http.get
            version: 1
            inputs:
              url: "https://status.newrelic.com/api/v2/status.json"
              selectors:
                - name: statusCode
                  expression: '.statusCode'
                - name: pageUrl
                  expression: '.responseBody | fromjson | .page.url'
                - name: statusDescription
                  expression: '.responseBody | fromjson | .status.description'

          - name: logOutput1
            type: action
            action: newrelic.ingest.sendLogs
            version: 1
            inputs:
              logs:
                - message: "status is '${{ .steps.query1.outputs.statusDescription }}' details at ${{ .steps.query1.outputs.pageUrl }}"
    ```

### **laço**

Um laço irá iterar sobre uma coleção dada definida por `in` e criar variáveis de laço `index` e `element` para cada uma de suas iterações. Essas variáveis de loop são acessíveis dentro do loop apenas com a expressão `${{ .steps.<loopStepName>.loop.element }}` ou `${{ .steps.<loopStepName>.loop.index }`

Para mais detalhes, veja abaixo:

<CollapserGroup>
  <Collapser id="moreforloop" title="Loop para iterar por uma lista, mapa ou coleção.">
    Você pode usar o loop para iterar por uma lista, mapa ou coleção.

    * `for` (Obrigatório)

      * **Tipo**: Constante
      * **Descrição**: Sinal de início de um loop.

    * `in` (Obrigatório)

      * **Tipo**: string (expressão)
      * **Descrição**: Uma expressão que precisa ser avaliada em relação a uma coleção de elementos.

    * `steps` (Obrigatório)

      * **Descrição**: Etapas a serem executadas em cada iteração do loop. Um passo pode ser qualquer tipo de passo, incluindo outro loop.

      * **Exemplos**: O exemplo a seguir mostra como executar o fluxo de trabalho de loop workflowInputs. Note que o resultado deve ser um tipo de coleção.

        ```yaml
            name: myWorkflow
            steps:
              - name: loopStep
                type: loop
                for:
                  in: '${{ .workflowInputs.count }}'
                  steps:
                    - name: step1
                      type: action
                      action: example.messaging.sayHello
                      version: '1.0.0'
                      inputs:
                        name: '${{ .steps.loopStep.loop.element }}' # not exist outside of this loop
                        index: '${{ .steps.loopStep.loop.index }}' # not exist outside of this loop
        ```

    <Callout variant="important">
      * `element` e `index` são atribuídos automaticamente como parte do loop.
      * `Index` é de base zero.
      * O `element` pode ser um tipo complexo se você tiver uma coleção de elementos complexos.
      * Todas as variáveis de loop e as saídas das etapas dentro do loop têm escopo de nível de loop. Essas variáveis são zeradas após o término do loop e acessá-las fora do loop resultará em um valor nulo. Um loop pode acessar variáveis que estão fora do loop se elas tiverem sido definidas previamente.
    </Callout>

    **Laço for simples em números inteiros**

    ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: ${{ [range(1; 6)] }}
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'  # [1, 2, 3, 4, 5]
                    index: '${{ .steps.loopStep.loop.index }}' # [0, 1, 2, 3, 4]
    ```

    **Loop simples para mapa**

    ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'  # [{ "key1": "val1" }, { "key2": "val2"}]
                    index: '${{ .steps.loopStep.loop.index }}' # [0, 1]
    ```

    **Saltar dentro de um loop**

    Só é permitido saltar entre etapas nomeadas pertencentes ao mesmo laço \`for\`. Não é permitido entrar ou sair de um laço \`for\`, de um laço interno/externo ou entre dois laços \`for\` diferentes.

    ```yaml
        name: myWorkflow
        steps:
          - name: firstStep
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
          - name: loopStep
            type: loop
            for:
              in: '${{ .workflowInputs.count }}'
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'
                  next: step3                                 # Okay within the loop
                - name: step2
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.step1.outputs.greeting }}'
                - name: step3
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  next: firstStep                            # Not okay, first step is not in the loop context
    ```

    **Use break/continue em um loop.**

    Para alterar o fluxo de um loop for, você pode usar `next: break` ou `next: continue`. Observe que `break` e `continue` são destinos de salto reservados definidos implicitamente dentro de um loop. Usar `next: break` ou `next: continue` fora de um loop fará com que você pule para o final das etapas do fluxo de trabalho.

    * O `end` tem a mesma função que `break` se usado dentro de um loop.
    * O comando &quot;next&quot; pode ser usado tanto em etapas de comutação quanto em qualquer tipo de etapa.

    ```yaml
      name: myWorkflow
      steps:
        - name: loopStep
          type: loop
          for:
            in: '${{ [range(1; 6)] }}'
            steps:
              - name: insideLoopStep1
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
                next: continue
              - name: insideLoopStep2
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
        - name: loopStepAgain
          type: loop
          for:
            in: '${{ .workflowInputs.count }}'
            steps:
              - name: switchStep
                type: switch
                switch:
                  - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                    next: break
              - name: insideLoopStepAgain
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStepAgain.loop.element }}'
    ```
  </Collapser>
</CollapserGroup>

* **`steps[*].for`** (Obrigatório)

  * **Tipo**: constante
  * **Descrição**: Sinal de início de um loop

* **`steps[*].in`** (Obrigatório)

  * **Tipo**: string (expressão)

  * **Descrição**: Uma expressão que precisa ser avaliada como uma coleção de elementos.

  * **`steps[*].steps`** (Opcional)

    * **Descrição**: Etapas a serem executadas em cada iteração do loop. Veja a definição das etapas acima.

    * **Exemplo**:

      ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: "${{ [range(1; 5)] }}""
              steps:
                - name: step1
                  type: action
                  action: newrelic.ingest.sendLogs
                  version: 1
                  inputs:
                    logs:
                      - message: "Loop: ${{ .steps.loopStep.loop.element }}"
      ```

### **trocar**

* Uma etapa que verifica várias condições e executa o primeiro ramo que resulta em verdadeiro.

* Um switch pode conter qualquer número de elementos de condição em uma lista. O sistema verificará as condições em ordem e processará a primeira que for avaliada como verdadeira. Se nenhuma avaliação for verdadeira, o próximo passo será executado conforme definido em steps\[\*].next.

* **`steps[*].switch`** (Obrigatório)

  * **Tipo**: matriz
  * **Descrição**: Uma matriz de casos de alternância, especificando a lista ordenada de condições a serem avaliadas.

* **`steps[*].switch[*].condition`** (Obrigatório)

  * **Tipo**: string (expressão)
  * **Descrição**: O estado da caixa do interruptor. Se avaliada como verdadeira, a próxima etapa do caso será executada.

* **`steps[*].switch[*].next`** (Obrigatório)

  * **Tipo**: string (em conformidade com [o padrão de segurança de expressão]())
  * **Descrição**: O nome da etapa a ser executada se a condição do caso for avaliada como verdadeira. A palavra-chave especial &quot;end&quot; pode ser usada para indicar que esta etapa deve ser a última a ser executada.

  ```yaml
  - name: hasCompleted
    type: switch
    switch:
      - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Failed" }}
        next: displayError
      - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Success" }}
        next: displaySuccess
    next: displayUnexpected
  ```

### espere

Uma etapa que faz com que o fluxo de trabalho aguarde um determinado número de segundos antes de continuar. Ele também pode captar um ou mais sinais. Se nenhum sinal for recebido durante a espera, o processo prosseguirá normalmente. Os sinais são definidos em uma lista. Cada sinal deve ter uma próxima etapa correspondente definida. O primeiro sinal a ser recebido será o processado. O valor recebido para o sinal será armazenado na saída da etapa de espera e poderá ser usado para processamento lógico em etapas posteriores.

* Exemplo:

  ```yaml
    name: waitSignalExample
    workflowInputs:
    steps:
      - name: waitStep
        type: wait
        seconds: 300
        signals: [{name: 'mySignalName', next: 'firstStep'}]
      - name: endStep
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: "didn't get signal"
        next: end
      - name: firstStep
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: ${{ .steps.waitStep.outputs.signalInputs.myString }}
  ```

* **`steps[*].seconds`** (Obrigatório)

  * **Tipo**: número
  * **Descrição**: O número de segundos a aguardar antes de continuar a execução do fluxo de trabalho.

* **`steps[*].signals`**

  * **Tipo**: matriz
  * **Descrição**: Os sinais que, quando recebidos, irão desviar o fluxo do programa.

* **`steps[*].signals[*].name`**

  * **Tipo**: string
  * **Descrição**: O nome do sinal a ser monitorado.

* **`steps[*].signals[*].next`**

  * **Tipo**: string
  * **Descrição**: O passo a ser executado se o sinal especificado for recebido.

## Tipos Compartilhados

### Cadeias de expressões

Diversas propriedades aceitam valores de string com expressões incorporadas que são avaliadas durante a execução do fluxo de trabalho, permitindo que valores dinâmicos sejam usados dentro das definições do fluxo de trabalho. As cadeias de expressões podem conter uma ou várias expressões, cada uma delas delimitada por chaves duplas. O conteúdo entre chaves é avaliado usando jq.

O jq oferece a capacidade de acessar e manipular valores de diversas maneiras. Por exemplo, o comprimento de uma string de entrada de fluxo de trabalho pode ser obtido da seguinte forma: `${{ .workflowInputs.myString | length }}`

Para construir e [testar expressões JQ,](https://play.jqlang.org/) esta ferramenta pode ser utilizada.

### Propriedades de expressão

Diversas propriedades podem ser acessadas por meio de expressões. Essas propriedades residem em um objeto de &quot;escopo&quot;, portanto, as expressões devem começar com um ponto (.) para acessar essas propriedades do objeto de escopo.

Os imóveis disponíveis são:

* `workflowInputs` - Objeto contendo as entradas passadas para o fluxo de trabalho no início.
  * Exemplo: `${{ .workflowInputs.myInput }}`
* `steps` - objeto contendo uma propriedade para cada etapa do fluxo de trabalho
  * `steps.<stepName>` - objeto contendo propriedades para uma etapa específica
    * `steps.<stepName>.outputs` - Objeto contendo propriedades de resultado, específicas para a etapa/ação.
      * Exemplo: `${{ .steps.myStep.outputs.myResult }}`

### Resultados da avaliação da expressão

Uma única expressão jq pode resultar em qualquer tipo JSON, mas é importante notar que o resultado final de uma string de expressão completa dependerá do conteúdo da string (se houver) que a envolve.

Se toda uma string de expressão consistir em uma única expressão, ela será avaliada de acordo com o resultado da expressão jq, mantendo o tipo JSON do resultado. Por exemplo, se um fluxo de trabalho receber uma matriz como entrada, a string `${{ .workflowInputs.myArray }}` será avaliada como uma matriz. Isso pode ser útil para transmitir dados complexos dentro de um fluxo de trabalho.

Se a expressão contiver conteúdo além de uma única expressão, ela será avaliada como uma string resultante. Por exemplo, isso ocorre quando uma expressão tem conteúdo antes/depois dela ou se a string contém várias expressões. Cada expressão dentro da string é avaliada e convertida em uma representação em string.

Exemplo:

Para os exemplos a seguir, suponha que myArray tenha o valor \[1, 2, 3].

<table>
  <thead>
    <tr>
      <th>
        string de expressão
      </th>

      <th>
        Dados de resultados
      </th>

      <th>
        Tipo de resultado
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `${{ .workflowInputs.myArray }}`
      </td>

      <td>
        \[1, 2, 3]
      </td>

      <td>
        matriz de números
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        3
      </td>

      <td>
        número
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        verdadeiro
      </td>

      <td>
        boleano
      </td>
    </tr>

    <tr>
      <td>
        `Input is not empty: ${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        &quot;A entrada não está vazia: verdadeiro&quot;
      </td>

      <td>
        corda
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray }} has length ${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        &quot;tem comprimento 3&quot;
      </td>

      <td>
        corda
      </td>
    </tr>
  </tbody>
</table>

### Padrão seguro para expressões [#expression-safe-pattern]

As propriedades que podem ser usadas em expressões devem estar em conformidade com a seguinte expressão regular: `^[A-Za-z_][A-Za-z0-9_]*$`

### Referências secretas

Os valores secretos podem ser usados em ações por meio de strings de referência que especificam o nome de um segredo a ser pesquisado no Serviço de Segredos. Para referenciar um segredo em uma definição de fluxo de trabalho, use a seguinte sintaxe:

* `${{ :secrets:<SECRET_NAME> }}` para um segredo que não está em um `namespace`
* `${{ :secrets:<NAMESPACE>:<SECRET_NAME> }}` para um segredo em um `namespace`

Uma string de expressão pode conter uma combinação de referências secretas e expressões JQ e/ou múltiplas referências secretas.

Exemplos:

```yaml
  steps:
  - name: bearer_auth
    type: action
    action: http.post
    inputs:
      headers:
        Authorization: Bearer ${{ :secrets:<SECRET_NAME> }}
```

## Exemplos

* Olá Mundo

```yaml
name: helloWorld
description: 'A hello world workflow'

workflowInputs:
  name:
    type: String
    defaultValue: World
    required: false
    validations:
      - type: maxLength
        errorMessage: "name must be at most 100 characters"
        length: 100
  slackTokenSecret:
    type: String
    defaultValue: "${{ :secrets:SLACK_TOKEN }}"
  slackChannel:
    type: String
    defaultValue: my-channel
    validations:
      - type: regex
        errorMessage: "A slack channel name must be lowercase and can only contain letters, numbers, and hyphens"
        pattern: "^[a-z0-9\\-]+$"
    required: true

steps:
  - name: init1
    type: assign
    inputs:
      greeting: Hello ${{ .workflowInputs.name }}

  - name: logName
    type: action
    action: newrelic.ingest.sendLogs
    version: 1
    inputs:
      logs:
        - message: ${{ .steps.init1.outputs.greeting }}

  - name: waiting1
    type: wait
    seconds: 1

  - name: queryForLog
    type: action
    action: newrelic.nrdb.query
    version: 1
    inputs:
      query: >-
        FROM Log SELECT * WHERE message LIKE '${{ .steps.init1.outputs.greeting
        }}'

  - name: checkResult
    type: switch
    switch:
      - condition: ${{ .steps.queryForLog.outputs.results | length > 0 }}
        next: FoundMessage

  - name: waitingMessage
    type: action
    action: slack.chat.postMessage
    version: 1
    inputs:
      channel: ${{ .workflowInputs.slackChannel }}
      text: Waiting for log message...
      token: ${{ .workflowInputs.slackTokenSecret }}
    next: waiting1

  - name: FoundMessage
    type: action
    action: slack.chat.postMessage
    version: 1
    inputs:
      channel: ${{ .workflowInputs.slackChannel }}
      text: Found message! ${{ .steps.queryForLog.outputs.results[0].message }}
      token: ${{ .workflowInputs.slackTokenSecret }}
```