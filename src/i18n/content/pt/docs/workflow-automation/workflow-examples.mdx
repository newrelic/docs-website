---
title: Exemplos de fluxo de trabalho
tags:
  - workflow automation
  - workflow
  - automation
  - examples
metaDescription: 'Common workflow automation scenarios and examples for incident response, infrastructure management, and integrations.'
freshnessValidatedDate: never
translationType: machine
---

Esta página mostra cenários comuns de automação que você pode criar com o fluxo de trabalho Automation. Utilize esses exemplos como ponto de partida para seu próprio fluxo de trabalho ou explore a [biblioteca de modelos](/docs/workflow-automation/create-a-workflow-automation/use-a-template) para soluções prontas para implantação.

## Reversão do gateway de API

Reverter as configurações do gateway de API para um estado anterior permite corrigir erros e configurações incorretas.

**O que este fluxo de trabalho faz:**

* Detecta implantação recente relacionada a um problema usando o Monitoramento de Alterações New Relic
* Envia notificação do Slack com botões de aprovação `(:+1: or :-1:)`
* Após a aprovação, cria um documento do AWS Systems Manager para automatizar o rollback.
* Reverte a integração do API Gateway para a versão anterior do Lambda.
* Cria uma nova implantação para aplicar o rollback.
* Envia notificação de sucesso ou falha para o Slack
* Limpa o documento SSM após a conclusão.

**Requisitos:**

* Credenciais da AWS com permissões para API Gateway e Systems Manager.
* Um aplicativo Slack configurado para receber notificações e aprovações
* New Relic entidade monitoramento com Monitoramento de Alterações

**Ações principais**: `newrelic.nerdgraph.execute`, `slack.chat.postMessage`, `slack.chat.getReactions`, `aws.systemsManager.writeDocument`, `aws.systemsManager.startAutomation`, `aws.systemsManager.waitForAutomationStatus`, `aws.systemsManager.deleteDocument`

## Óbvias de gestão EC2

Automatize o provisionamento, o dimensionamento e o encerramento de instâncias do EC2 para obter desempenho e custo ideais.

**O que este fluxo de trabalho faz:**

* Recebe alertas de alta utilização da CPU do New Relic.
* Recupera detalhes de alerta e identifica as instâncias impactadas do EC2.
* Envia notificação ao Slack com detalhes da instância e requests aprovação para redimensionamento.
* Após a aprovação, cria um documento SSM para automatizar o redimensionamento da instância.
* Interrompe a instância, modifica o tipo de instância e a reinicia.
* Envia atualizações de progresso para o Slack durante o processo de redimensionamento.
* Aguarda a conclusão e envia o status de sucesso ou falha.
* Revisa o documento SSM e envia a confirmação final.

**Requisitos:**

* Credenciais da AWS com permissões para EC2 e Systems Manager
* Uma condição de alerta ativa New Relic para a métrica EC2
* Um aplicativo Slack configurado para receber notificações e aprovações

**Ações principais**: `newrelic.nerdgraph.execute`, `newrelic.nrdb.query`, `slack.chat.postMessage`, `slack.chat.getReactions`, `aws.systemsManager.writeDocument`, `aws.systemsManager.startAutomation`, `aws.systemsManager.waitForAutomationStatus`, `aws.systemsManager.deleteDocument`, `utils.datetime.fromEpoch`, `utils.uuid.generate`

## Reversão da implantação

Reverter a implantação caso a entidade apresente problemas e notificar o usuário por meio do AWS SQS ou HTTP.

**O que este fluxo de trabalho faz:**

* Monitora a gravidade dos alertas de uma entidade durante um período específico (30 minutos por padrão).
* Verifica a integridade da entidade a cada minuto.
* Se a entidade entrar em estado CRÍTICO ou de AVISO, o status de não integridade será registrado.
* Envia notificação de rollback via AWS SQS (se configurado) com detalhes da entidade
* Envia notificação de rollback via webhook HTTP (se configurado)
* Se a entidade permanecer íntegra durante todo o período, registra o sucesso.
* Interrompe o monitoramento se a entidade não for encontrada.

**Requisitos:**

* Organização New Relic com alerta de monitoramento de severidade
* (Opcional) Fila e função AWS SQS para receber notificação de reversão
* (Opcional) endpoint HTTP para receber notificação de reversão

**Ações principais**: `newrelic.nerdgraph.execute`, `newrelic.ingest.sendLogs`, `aws.execute.api`, `(sqs.send_message)`, `http.post`

## Mensagens AWS SQS

Enviar mensagens para uma fila do AWS SQS para processamento subsequente ou sistemas de notificação.

**O que este fluxo de trabalho faz:**

* Envia uma mensagem para uma fila SQS específica.
* Utiliza a autenticação de função do AWS IAM para acesso seguro.
* Retorna o ID da mensagem e o status de sucesso para verificação.

**Requisitos:**

* Credenciais da AWS com permissão `sqs:SendMessage`
* URL da fila SQS
* Função do IAM configurada para automação de fluxo de trabalho (consulte [Configurar credenciais da AWS](/docs/workflow-automation/setup-and-configuration/set-up-aws-credentials))

**Ações principais**: `aws.execute.api`, `(sqs.send_message)`

```yaml
  name: aws_execute_api_sqs_example

  workflowInputs:
    awsRoleArn:
      type: String
    awsRegion:
      type: String
      defaultValue: us-west-2
    awsQueueUrl:
      type: String

  steps:
    - name: sendSqsMessage
      type: action
      action: aws.execute.api
      version: 1
      inputs:
        awsRoleArn: ${{ .workflowInputs.awsRoleArn }}
        region: ${{ .workflowInputs.awsRegion }}
        service: sqs
        api: send_message
        parameters:
          QueueUrl: "${{ .workflowInputs.awsQueueUrl }}"
          MessageBody: |
            {
              "message": "deployment is bad",
              "status": "not good"
            }
        selectors:
          - name: success
            expression: '.success'
          - name: messageId
            expression: '.response.MessageId'
```

## Alertas NRQL complexos

Lidar com consultas NRQL complexas que os alertas padrão não suportam, como comparar dados em diferentes intervalos de tempo ou aplicar lógica personalizada antes de disparar uma notificação.

**O que este fluxo de trabalho faz:**

* Executa duas consultas NRQL comparando diferentes janelas de tempo (de 10 minutos atrás até 5 minutos atrás versus os últimos 5 minutos).
* Compara os resultados da consulta para detectar se a contagem aumentou.
* Utiliza uma etapa de comutação para enviar notificações condicionalmente apenas quando novos eventos forem detectados.
* Envia notificação por e-mail com os resultados da consulta e anexo CSV.
* Pode ser programado para ser executado a cada 10 minutos para monitoramento contínuo.

**Requisitos:**

* Conta New Relic com dados para consulta
* Destino de e-mail configurado no New Relic (veja [Enviar notificação do fluxo de trabalho](/docs/workflow-automation/setup-and-configuration/create-destinations))
* fluxo de trabalho agendado usando [APICreateSchedule](/docs/workflow-automation/workflow-automation-apis/create-schedule)

**Ações principais**: `newrelic.nrdb.query`, `newrelic.notification.sendEmail`

**Caso de uso**: Este padrão é útil quando os alertas padrão do New Relic não conseguem atender às suas necessidades, como:

* Comparando a Métrica em múltiplas janelas de tempo.
* Aplicar operações matemáticas personalizadas aos resultados da consulta
* Acionado somente quando limites ou padrões específicos são detectados.
* Combinar dados de múltiplas consultas com lógica condicional.

```yaml
  name: Complex_Alert_Workflow
  description: 'Compares NRQL results across time windows and sends alerts when new events are detected'

  workflowInputs:
    destinationId:
      type: String
    query:
      type: String
      defaultValue: 'FROM Span SELECT count(*)'

  steps:
    - name: query1
      type: action
      action: newrelic.nrdb.query
      version: 1
      inputs:
        query: "${{ .workflowInputs.query }} SINCE 10 minutes ago UNTIL 5 minutes ago"
        accountIds:
          - 7401815
        selectors:
          - name: length
            expression: '[ .results[] | length ]'
          - name: count
            expression: '[ .results[0].count ]'

    - name: query2
      type: action
      action: newrelic.nrdb.query
      version: 1
      inputs:
        query: "${{ .workflowInputs.query }} SINCE 5 minutes ago"
        accountIds:
          - 7401815
        selectors:
          - name: length
            expression: '[ .results[] | length ]'
          - name: count
            expression: '[ .results[0].count ]'

    - name: CheckForNewEvents
      type: switch
      switch:
        - condition: >-
            ${{ (.steps.query2.outputs.count - .steps.query1.outputs.count) > 0 }}
          next: sendEmail
      next: end

    - name: sendEmail
      type: action
      action: newrelic.notification.sendEmail
      version: 1
      inputs:
        destinationId: ${{ .workflowInputs.destinationId }}
        subject: Hello there!
        message: >-
          More spans incoming!!!
          There are --- ${{ (.steps.query2.outputs.count - .steps.query1.outputs.count) }} ---
          new Spans that were ingested in the last 5 minutes
        attachments:
          - type: QUERY
            query: ${{ .workflowInputs.query }} SINCE 5 minutes ago
            format: CSV
            filename: span_count.csv
      next: end
```

**Para agendar esse fluxo de trabalho**, use a [API CreateSchedule](/docs/workflow-automation/create-a-workflow-automation/start-schedule#scheduled) com uma expressão cron como `*/10 * * * *` (a cada 10 minutos). Lembre-se que o intervalo mínimo de agendamento é de 10 minutos. Consulte [os limites do fluxo de trabalho](/docs/workflow-automation/limitations-and-faq/workflow-limits) para obter detalhes.

## Enviar um relatório para o Slack

Envie o resultado de uma consulta NRQL como um arquivo CSV no Slack.

**O que este fluxo de trabalho faz:**

* Executa uma consulta NRQL na conta New Relic especificada.
* Gera um arquivo CSV a partir dos resultados da consulta.
* Publica o arquivo CSV em um canal específico do Slack com uma mensagem.

**Requisitos:**

* Uma credencial do New Relic e uma consulta NRQL funcional.
* Um aplicativo Slack configurado com um token e um canal de destino.

**Ações principais**: `newrelic.nrdb.query`, `utils.transform.toCSV`, `slack.chat.postMessage`

## Análise de JSON

Analisa o JSON (HTTP) da API de status público do New Relic e, opcionalmente, registra componentes operacionais e não operacionais.

**O que este fluxo de trabalho faz:**

* Obtém dados JSON da API de status do New Relic.
* Extrai e categoriza os componentes de acordo com seu status operacional.
* Registra condicionalmente os componentes operacionais (se ativado).
* Registra condicionalmente componentes não operacionais (se ativado)
* Lida com erros HTTP e registra mensagem de erro

**Requisitos:**

* Acesso à API de status do New Relic (`summary.json`)
* Permissões para enviar logs via newrelic.ingest.sendLogs

**Ações principais**: `http.get`, `newrelic.ingest.sendLogs`

## API REST: sondagem e logging de logs

Consultar um endpointREST da API, percorrer os resultados e registrar os dados no New Relic.

<Callout variant="important">
  Você não precisa usar seletores se quiser a carga útil completa. A maioria das ferramentas de fluxo de trabalho permite que você faça referência diretamente ao objeto de resposta completo.
</Callout>

### Requisição GET simples e logs.

Para um caso de uso básico de consulta a uma API e logging da resposta completa:

**O que este fluxo de trabalho faz:**

* Gatilho: Agendamento (por exemplo, a cada 5 minutos) ou você pode usar Executar para execução manual.

* Etapa de solicitação HTTP:

  * Método: GET
  * URL: [https://pokeapi.co/api/v2/pokemon](https://pokeapi.co/api/v2/pokemon)
  * Salvar o corpo completo da resposta em uma variável (ex: `{{.http_response}}`)

* Etapa de registro/criação de evento:

  * Envie o `{{.http_response.body}}` inteiro como carga útil.
  * Não são necessários seletores - basta passar o JSON bruto.

### API REST com loops e seletores

Este exemplo coleta todos os resultados de uma API, percorre-os em um loop, faz chamadas HTTP individuais e registra os dados extraídos.

**O que este fluxo de trabalho faz:**

* Recupera todos os resultados de um endpointREST da API
* Percorre cada resultado na resposta.
* Faz chamadas de API individuais para cada item usando dados do loop.
* Extrai campos específicos de cada resposta usando seletores.
* Registra os dados extraídos no New Relic com atributo personalizado.

**Requisitos:**

* Acesso a um endpointREST de API
* Permissões para enviar logs via `newrelic.ingest.sendLogs`

**Ações principais**: `http.get`, `newrelic.ingest.sendLogs`

```yaml
  name: pokemon_workflow
  description: ''
  steps:
    - name: get_all_pokemons
      type: action
      action: http.get
      version: '1'
      inputs:
        url: https://pokeapi.co/api/v2/pokemon
        selectors:
          - name: pokemons
            expression: .responseBody | fromjson.results
    - name: pokemon_loop
      type: loop
      for:
        in: ${{ .steps.get_all_pokemons.outputs.pokemons }}
        steps:
          - name: get_individual_pokemon
            type: action
            action: http.get
            version: '1'
            inputs:
              url: ${{ .steps.pokemon_loop.loop.element.url }}
              selectors:
                - name: pokemon_name
                  expression: .responseBody | fromjson.name
                - name: pokemon_id
                  expression: .responseBody | fromjson.id
                - name: pokemon_stats
                  expression: .responseBody | fromjson.stats
          - name: log_pokemon_info
            type: action
            action: newrelic.ingest.sendLogs
            version: '1'
            inputs:
              logs:
                - message: >-
                    Pokemon name is: ${{
                    .steps.get_individual_pokemon.outputs.pokemon_name}}, Id: ${{
                    .steps.get_individual_pokemon.outputs.pokemon_id}}
                  attributes:
                    pokemon_stats: ${{ .steps.get_individual_pokemon.outputs.pokemon_stats}}
            next: continue
      next: end
```

### Conversão de API REST para CSV

Este exemplo ilustra como usar a resposta completa sem seletores, converter dados da API em CSV e compartilhá-los via Slack.

**O que este fluxo de trabalho faz:**

* Obtém os dados de hora atual da API World Time com base no fuso horário inserido.
* Converte a resposta JSON completa para o formato CSV.
* Registra os dados CSV no New Relic.
* Publica o arquivo CSV em um canal do Slack.

**Requisitos:**

* Acesso a um endpointREST de API
* Permissões para enviar logs via newrelic.ingest.sendLogs
* Um aplicativo Slack configurado com um token e um canal de destino.

**Ações principais**: `http.get`, `utils.transform.toCSV`, `newrelic.ingest.sendLogs`, `slack.chat.postMessage`

```yaml
  name: jsontocsv

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'

    - name: csv1
      type: action
      action: utils.transform.toCSV
      version: 1
      inputs:
        json: ${{ .steps.getCurrentTime.outputs.responseBody }}

    - name: logOutput
      type: action
      action: newrelic.ingest.sendLogs
      version: 1
      inputs:
        logs:
          - message: 'CSV: ${{ .steps.csv1.outputs.csv }}'

    - name: postCsv
      type: action
      action: slack.chat.postMessage
      version: 1
      inputs:
        channel: test-channel-workflow
        text: "Current Date details"
        attachment:
          filename: 'file.csv'
          content: ${{ .steps.csv1.outputs.csv }}
        token: ${{ :secrets:dn_staging_slack_token }}
```

## Modelo disponível de fluxo de trabalho

Os modelos listados acima estão disponíveis diretamente na interface de Automação de Fluxo de Trabalho New Relic. Para acessá-los:

1. Acesse **All Capabilities &gt; Workflow Automation**
2. Clique em **Create workflow**
3. Selecione **Use a template**
4. Navegue pela biblioteca de modelos e escolha um fluxo de trabalho que corresponda ao seu caso de uso.

Cada modelo inclui:

* Etapas e lógica de fluxo de trabalho pré-configuradas
* Exemplo de entrada (parâmetro)
* Credenciais e integração necessárias
* Documentação dos resultados esperados

Você pode usar os modelos tal como estão ou personalizá-los para atender às suas necessidades específicas.

## Passando dados entre etapas

Todo fluxo de trabalho pode referenciar resultados de etapas anteriores usando a sintaxe de modelo. Isso permite encadear ações e construir uma lógica de automação complexa.

### Utilizando entradas de fluxo de trabalho

Você pode usar a sintaxe `${{ .workflowInputs.variableName }}` para passar valores dinâmicos em tempo de execução. Essa sintaxe funciona em URLs endpoint e outros campos de entrada.

**Exemplo:**

```json
  {
    "inputs": [
      {
        "key": "urlParams",
        "value": "{\"filter\": \"active\"}"
      },
      {
        "key": "headers",
        "value": "{\"Api-Key\": \"your-api-key\"}"
      }
    ]
  }
```

### Passagem básica de dados

Este exemplo consulta alertas de problemas do New Relic e envia uma notificação para o Slack para cada problema ativo.

```yaml
  name: alertSlack
  description: "query Alert Issues and send notifications to Slack"

  workflowInputs:
    accountId:
      type: Int

  steps:
    - name: getAlert
      type: action
      action: newrelic.nerdgraph.execute
      version: 1
      inputs:
        graphql: |
          query GetAlertIssues($accountId: Int!) {
            actor {
              account(id: $accountId) {
                aiIssues {
                  issues(filter: {states: ACTIVATED}) {
                    issues {
                      issueId
                      priority
                      state
                      title
                    }
                  }
                }
              }
            }
          }
        variables:
          accountId: ${{ .workflowInputs.accountId }}

    - name: loopStep
      type: loop
      for:
        in: ${{ .steps.getAlert.outputs.data.actor.account.aiIssues.issues.issues }}
        steps:
          - name: sendToSlack
            type: action
            action: slack.chat.postMessage
            version: 1
            inputs:
              token: ${{ :secrets:your_slack_token }}
              channel: incident-channel
              text: >
                issueId: ${{ .steps.loopStep.loop.element.issueId }}
                priority: ${{ .steps.loopStep.loop.element.priority }}
                state: ${{ .steps.loopStep.loop.element.state }}
                title: ${{ .steps.loopStep.loop.element.title | tostring }}
```

### Estrutura de loop

Você pode usar o loop para iterar por uma lista, mapa ou coleção.

Um loop itera sobre uma coleção dada definida por `in`. Ele cria automaticamente as variáveis de loop `index` e `element` para cada uma de suas iterações. Essas variáveis de loop são acessíveis dentro do loop com [a expressão JQ](https://play.jqlang.org/) `${{ .steps.<loopStepName>.loop.element }}` ou `${{ .steps.<loopStepName>.loop.index }}`.

**Parâmetro:**

* **`for`** (Obrigatório): Sinaliza o início de um loop
* **`in`** (Obrigatório, expressão de string): Uma expressão que precisa ser avaliada em uma coleção de elementos.
* **`steps`** (Obrigatório): Etapas a serem executadas em cada iteração do loop. Um passo pode ser qualquer tipo de passo, incluindo outro loop.

**Loop com entradas de fluxo de trabalho:**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
```

**Observações importantes:**

* `for`: obrigatório. Este é o elemento de nível superior que indica o início de um loop for.
* `in`: obrigatório. Para que a coleção de entrada seja iterada, ela deve ser convertível em uma matriz Java
* `steps`: obrigatório. Em cada iteração, as etapas serão executadas.
* `element` e `index` são atribuídos automaticamente como parte do loop.
* `index` é de base zero
* O tipo `element` pode ser complexo se você tiver uma coleção de elementos complexos.
* As variáveis criadas dentro do loop (variáveis do loop e saídas de cada etapa) só são acessíveis dentro do próprio loop.
* Essas variáveis são zeradas quando o loop termina e serão nulas se acessadas fora do loop.
* Os loops podem acessar variáveis definidas fora do loop.

**Laço simples em números inteiros:**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: ${{ [range(1; 6)] }}
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
```

**Loop simples para mapa:**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
```

**Saltar dentro de um loop:**

Só é permitido saltar entre etapas nomeadas pertencentes ao mesmo laço \`for\`. Não é permitido entrar ou sair de um laço \`for\`, de um laço interno/externo ou entre dois laços \`for\` diferentes.

```yaml
  name: myWorkflow
  steps:
    - name: firstStep
      type: action
      action: internal.example.sayHello
      version: '1'
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: step3  # Okay within the loop
          - name: step2
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.step1.outputs.greeting }}'
          - name: step3
            type: action
            action: internal.example.sayHello
            version: '1'
            next: firstStep  # Not okay, first step is not in the loop context
```

**Use break/continue em um loop:**

Para alterar o fluxo de um loop for, você pode usar `next: break` ou `next: continue`. Observe que `break` e `continue` são destinos de salto reservados definidos implicitamente dentro de um loop. Usar `next: break` ou `next: continue` fora de um loop fará com que você pule para o final das etapas do fluxo de trabalho.

O `end` tem a mesma função que `break` se for usado dentro de um loop. O comando &quot;next&quot; pode ser usado tanto em etapas de comutação quanto em qualquer tipo de etapa.

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [range(1; 6)] }}'
        steps:
          - name: insideLoopStep1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: continue
          - name: insideLoopStep2
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
    - name: loopStepAgain
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: switchStep
            type: switch
            switch:
              - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                next: break
          - name: insideLoopStepAgain
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStepAgain.loop.element }}'
```

### Lógica condicional com dados

```yaml
  steps:
    - name: checkCPU
      type: action
      action: newrelic.nerdgraph.execute
      version: 1
      # ... query configuration

    - name: decideAction
      type: switch
      switch:
        - condition: "${{ .steps.checkCPU.outputs.data.actor.account.nrql.results[0].average > 90 }}"
          next: resizeInstance
        - condition: "${{ .steps.checkCPU.outputs.data.actor.account.nrql.results[0].average > 70 }}"
          next: sendWarning
      next: normalOperation

    - name: resizeInstance
      type: action
      action: aws.ec2.modifyInstanceAttribute
      version: 1
      # ... resize configuration

    - name: sendWarning
      type: action
      action: slack.chat.postMessage
      version: 1
      # ... warning message

    - name: normalOperation
      type: action
      action: newrelic.ingest.sendLogs
      version: 1
      # ... log normal status
```

## Qual é o próximo

* **[Resolução de problemas](/docs/workflow-automation/troubleshooting)**: corrija erros de credenciais, problemas de integração e falhas de fluxo de trabalho.
* **[Práticas recomendadas](/docs/workflow-automation/limitations-and-faq/workflow-best-practices)**: Tratamento de erros, otimização de desempenho, estratégias de teste.
* **[Limites do workflow](/docs/workflow-automation/limitations-and-faq/workflow-limits)**: Compreenda os tempos limite, os limites de taxa e as restrições.