---
title: Referência do navegador com script Sintético (Chrome e Firefox)
tags:
  - Synthetics
  - Synthetic monitoring
  - Scripting monitors
metaDescription: Description of every function available for synthetic scripted browser monitors.
freshnessValidatedDate: never
translationType: machine
---

Para executar o script com do monitor do navegador usando [Selenium Webdriver 4.1 API](https://www.selenium.dev/documentation/webdriver/), certifique-se de que script a sintaxe do seu use as variáveis `$selenium` e `$webDriver`. Para acessar Selenium Webdriver API 3.6.0, use as variáveis `$driver` e `$browser` conforme descrito na [documentação de referência do navegador 0.5.0+](/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050/).

Em particular:

* `$selenium` fornece todas as exportações do módulo `selenium-webdriver` (por exemplo, `ActionSequence`, `Button`, `By` ou `WebElement`). Isso mapeia o uso de `$driver` em tempos de execução mais antigos.
* `$webDriver` é uma instância de monitoramento sintético de `selenium-webdriver.WebDriver()`. Ele expõe as principais API básicas do `WebDriver` como `get()` e `findElement()`, bem como algumas API personalizadas do Sintético. Isso mapeia o uso de `$browser` em tempos de execução mais antigos.
* `$headers` fornece a capacidade de modificar cabeçalhos de solicitação. Esse recurso estava disponível em ambientes de execução mais antigos em vários métodos `$browser`
* `$urlFilter` fornece a capacidade de criar listas de permissão e negação para limitar solicitações a determinados domínios. Esse recurso estava disponível em ambientes de execução mais antigos em vários métodos `$browser`

Se você estiver usando uma versão de monitor mais antiga, consulte a [documentação do monitor versão 0.5.0 e 0.6.0](/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050) ou a [documentação do monitor versão 0.4.0 e inferior](/docs/synthetics/new-relic-synthetics/scripting-monitors/synthetics-scripted-browser-reference).

Para obter mais informações sobre versões de monitor e diferenças de tempo de execução, consulte [Ambientes de tempo de execução](/docs/synthetics/new-relic-synthetics/scripting-monitors/scripted-monitor-runtime-environment).

<Callout variant="important">
  O gerenciador de promessas/fluxo de controle do Selenium Webdriver permitiu que algumas funções fossem executadas em ordem, sem gerenciar manualmente promessas/funções assíncronas. Isso foi removido no Selenium Webdriver 4.0 e não está mais disponível em tempo de execução. Todas as funções e promessas assíncronas precisam ser gerenciadas com `await` ou com `.then` cadeia de promessas. Isso garantirá que as funções do script sejam executadas na ordem esperada.
</Callout>

Para alguns exemplos de uso comum, consulte [Introdução ao script com monitor do browser](/docs/synthetics/synthetic-monitoring/scripting-monitors/introduction-scripted-browser-monitors).

## Funções de nível superior: crie seu script [#structure]

O New Relic chama funções de nível superior diretamente da sua instância `$webDriver` . Eles fornecem uma ampla gama de funcionalidades que abrangem muitas ações básicas programáveis.

Os métodos `waitForAndFindElement(locator, timeout)` e `waitForPendingRequests(timeout)` foram removidos do tempo de execução e não estão disponíveis por meio de `$webDriver`. A compatibilidade com versões anteriores está disponível, mas elas são consideradas obsoletas e podem ser removidas de tempos de execução futuros. Use o trecho de código a seguir para substituir sua funcionalidade:

<CollapserGroup>
  <Collapser
    id="waitForAndFindElement"
    title="Método waitForAndFindElement (localizador, tempo limite)"
  >
    ```js
    const element = await $webDriver.wait($selenium.until.elementLocated(locator), timeout, 'Timed-out waiting for element to be located using: '+locator);
    await $webDriver.wait($selenium.until.elementIsVisible(element), timeout, 'Timed-out waiting for element to be visible using ${element}');
    return await $webDriver.findElement(locator);
    ```
  </Collapser>

  <Collapser
    id="waitForPendingRequests"
    title="Método waitForPendingRequests (tempo limite)"
  >
    ```js
    await $webDriver.wait($webDriver.executeScript('return document.readyState == \'complete\''), optTimeoutMs, 'waitForPendingRequests');
    ```
  </Collapser>
</CollapserGroup>

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Função
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="webDriver-actions">
      <td>
        `$webDriver.actions()`
      </td>

      <td>
        Cria uma nova sequência de ações usando este driver. Para obter uma lista de ações disponíveis, consulte [ActionSequence](#actionsequence).

        Valor de retorno: nulo
      </td>
    </tr>

    <tr id="headers-add">
      <td>
        `$headers.add(headerKey: string, headerValue: string)`
      </td>

      <td>
        Adiciona o cabeçalho `headerKey` com valor `headerValue` ao tempo de execução.

        Valor de retorno: nulo
      </td>
    </tr>

    <tr id="headers-addMultiple">
      <td>
        `$headers.addMultiple(headers: {key:value...})`
      </td>

      <td>
        Adiciona vários cabeçalhos ao tempo de execução.

        Valor de retorno: nulo
      </td>
    </tr>

    <tr id="headers-get">
      <td>
        `$headers.get(headerKey: string)`
      </td>

      <td>
        Retorna um mapa dos cabeçalhos atualmente configurados.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="headers-getAll">
      <td>
        `$headers.getAll()`
      </td>

      <td>
        Retorna um mapa dos cabeçalhos atualmente configurados.

        Valor de retorno: mapa
      </td>
    </tr>

    <tr id="headers-getKeys">
      <td>
        `$headers.getKeys()`
      </td>

      <td>
        Retorna uma matriz de chaves de cabeçalho atualmente configuradas.

        Valor de retorno: matriz
      </td>
    </tr>

    <tr id="headers-has">
      <td>
        `$headers.has(headerKey: string)`
      </td>

      <td>
        Retorna um bool indicando se este cabeçalho existe.

        Valor de retorno: bool
      </td>
    </tr>

    <tr id="headers-remove">
      <td>
        `$headers.remove(header: string)`
      </td>

      <td>
        Exclui um cabeçalho específico do tempo de execução.

        Valor de retorno: nulo
      </td>
    </tr>

    <tr id="headers-removeMultiple">
      <td>
        `$headers.removeMmultiple(headers: {key:value...})`
      </td>

      <td>
        Exclui todos os cabeçalhos do argumento do tempo de execução.

        Valor de retorno: nulo
      </td>
    </tr>

    <tr id="headers-clear">
      <td>
        `$headers.clear()`
      </td>

      <td>
        Exclui todos os cabeçalhos do tempo de execução.

        Valor de retorno: nulo
      </td>
    </tr>

    <tr id="urlFilter-addToDenyList">
      <td>
        `$urlFilter.addToDenyList(hostnameArr: [string])`
      </td>

      <td>
        Adiciona todos os nomes do host em uma matriz de argumentos à sua lista de negação. Permite o uso [de curingas](#wildcard-use).

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="urlFilter-addToAllowList">
      <td>
        `$urlFilter.addToAllowList(hostnameArr: [string])`
      </td>

      <td>
        Adiciona todos os nomes do host em uma matriz de argumentos à sua lista de permissões. Permite o uso [de curingas](#wildcard-use).

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="urlFilter-removeFromDenyList">
      <td>
        `$urlFilter.removeFromDenyList(hostnameArr: [string])`
      </td>

      <td>
        Remove todos os nomes do host no argumento da sua lista de negações.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="urlFilter-removeFromAllowList">
      <td>
        `$urlFilter.removeFromAllowList(hostnameArr: [string])`
      </td>

      <td>
        Remove todos os nomes do host no argumento da sua lista de permissões.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-executeAsyncScript">
      <td>
        `$webDriver.executeAsyncScript(script: ?, var_args: ?)`
      </td>

      <td>
        Agenda um comando para executar JavaScript assíncrono no contexto do quadro ou janela atualmente selecionado.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-executeScript">
      <td>
        `$webDriver.executeScript(script: ?, var_args: ?)`
      </td>

      <td>
        Agenda um comando para executar JavaScript no contexto do quadro ou janela atualmente selecionado.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-findElement">
      <td>
        `$webDriver.findElement(locator: $selenium.Locator)`
      </td>

      <td>
        Agende um comando para [localizar um elemento na página](#locators). Se não for encontrado, o monitoramento sintético retornará um erro.

        Valor de retorno: WebElementPromise
      </td>
    </tr>

    <tr id="webDriver-findElements">
      <td>
        `$webDriver.findElements(locator: $selenium.Locator)`
      </td>

      <td>
        Agende um comando para [pesquisar vários elementos na página](#locators).

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-get">
      <td>
        `$webDriver.get(url: string)`
      </td>

      <td>
        Carrega uma página web em um browser Sintético.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-getAllWindowHandles">
      <td>
        `$webDriver.getAllWindowHandles()`
      </td>

      <td>
        Agenda um comando para recuperar a lista atual de identificadores de janela disponíveis.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-getCapabilities">
      <td>
        `$webDriver.getCapabilities()`
      </td>

      <td>
        Uma promessa que será resolvida com as capacidades da instância.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-getCurrentUrl">
      <td>
        `$webDriver.getCurrentUrl()`
      </td>

      <td>
        Agenda um comando para recuperar a URL da página atual.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-getPageSource">
      <td>
        `$webDriver.getPageSource()`
      </td>

      <td>
        Agenda um comando para recuperar a origem da página atual. A origem da página retornada é uma representação do DOM subjacente. Não espere que ele seja formatado ou escapado da mesma forma que a resposta enviada do servidor web.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-getSession">
      <td>
        `$webDriver.getSession()`
      </td>

      <td>
        Uma promessa para a sessão deste cliente.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-getTitle">
      <td>
        `$webDriver.getTitle()`
      </td>

      <td>
        Agenda um comando para recuperar o título da página atual.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-getWindowHandle">
      <td>
        `$webDriver.getWindowHandle()`
      </td>

      <td>
        Agenda um comando para recuperar o identificador da janela atual.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-manage">
      <td>
        `$webDriver.manage()`
      </td>

      <td>
        A interface de opções para esta instância. Você pode gerenciar [cookies, tempos limite e outras opções de janela](#options).

        Valor de retorno: nulo
      </td>
    </tr>

    <tr id="webDriver-navigate">
      <td>
        `$webDriver.navigate()`
      </td>

      <td>
        A [interface de navegação (histórico das funções do browser)](#navigate) para esta instância.

        Valor de retorno: nulo
      </td>
    </tr>

    <tr id="webDriver-sleep">
      <td>
        `$webDriver.sleep()`
      </td>

      <td>
        Agenda um comando para fazer o driver dormir por um determinado período de tempo.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-switchTo">
      <td>
        `$webDriver.switchTo()`
      </td>

      <td>
        A interface do localizador de destino para esta instância.

        Valor de retorno: nulo
      </td>
    </tr>

    <tr id="webDriver-takeScreenshot">
      <td>
        `$webDriver.takeScreenshot()`
      </td>

      <td>
        Agenda um comando para fazer uma captura de tela.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webDriver-wait">
      <td>
        `$webDriver.wait(fn: $driver.Condition, timeout: number, opt_message: string)`
      </td>

      <td>
        Agenda um [comando para aguardar que uma condição seja mantida](#until), conforme definido pela função fornecida.

        Valor de retorno: WebElement
      </td>
    </tr>

    <tr id="browser-waitforpending">
      <td>
        `$browser.waitForPendingRequests(timeout: number)`
      </td>

      <td>
        Faz com que o script aguarde o retorno das solicitações iniciadas, até o tempo limite. Útil para rastrear recursos sem bloqueio.

        Valor de retorno: promessa
      </td>
    </tr>
  </tbody>
</table>

## Lista de negações: uso de curinga [#wildcard-use]

Se você quiser adicionar domínio à lista de negações da instância do seu browser, os curingas deverão corresponder à sintaxe do URL a ser bloqueado.

Uma lista de negações `.com` geral deve conter estas funções:

<table>
  <thead>
    <tr>
      <th>
        Função
      </th>

      <th style={{ width: "200px" }}>
        Ação de bloqueio
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="deny-list-wildcard-examples">
      <td>
        `$urlFilter.addToDenyList(['*.com']);`
      </td>

      <td>
        `a.com`
      </td>
    </tr>

    <tr>
      <td>
        `$urlFilter.addToDenyList([*.*.com']);`
      </td>

      <td>
        `a.b.com`
      </td>
    </tr>

    <tr>
      <td>
        `$urlFilter.addToDenyList([*.*.*.com']);`
      </td>

      <td>
        `a.b.c.com`
      </td>
    </tr>

    <tr>
      <td>
        `$urlFilter.addToDenyList([www.*.com']);`
      </td>

      <td>
        `www.a.com`
      </td>
    </tr>

    <tr>
      <td>
        `$urlFilter.addToDenyList([www.*.*.com']);`
      </td>

      <td>
        `www.a.b.com`
      </td>
    </tr>

    <tr>
      <td>
        `$urlFilter.addToDenyList(['www.*.*.*.com']);`
      </td>

      <td>
        `www.a.b.c.com`
      </td>
    </tr>
  </tbody>
</table>

## Opções: Gerenciar a instância do browser [#options]

Essas funções gerenciam opções para a instância do seu browser, como cookies, tempos limite e tamanho da janela. Acesse essas opções por meio da função [`$webDriver.manage()`](#webDriver-manage) .

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Função
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="options-manage-addCookie">
      <td>
        `$webDriver.manage().addCookie(spec: object)`
      </td>

      <td>
        Agenda um comando para adicionar um cookie.

        `spec` é um objeto de registro que descreve um cookie do browser. Para obter mais informações, consulte a [documentação do Selenium](http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/lib/webdriver_exports_Options.Cookie.html).

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="options-manage-deleteAllCookies">
      <td>
        `$webDriver.manage().deleteAllCookies()`
      </td>

      <td>
        Agenda um comando para excluir todos os cookies visíveis na página atual.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="options-manage-deleteCookie">
      <td>
        `$webDriver.manage().deleteCookie(name: string)`
      </td>

      <td>
        Agenda um comando para excluir o cookie com o nome fornecido. Este comando é autônomo se não houver nenhum cookie com o nome fornecido visível na página atual.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="options-manage-getCookie">
      <td>
        `$webDriver.manage().getCookie(name: string)`
      </td>

      <td>
        Agenda um comando para recuperar o cookie com o nome fornecido. Retorna nulo se esse cookie não existir. O cookie será retornado como um objeto JSON conforme descrito pelo protocolo de ligação Webdriver .

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="options-manage-getCookies">
      <td>
        `$webDriver.manage().getCookies()`
      </td>

      <td>
        Agenda um comando para recuperar todos os cookies visíveis na página atual. New Relic Syntheticcs retorna cada cookie como um objeto JSON conforme descrito pelo protocolo de ligação Webdriver .

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="options-manage-get-timeouts">
      <td>
        `$webDriver.manage().getTimeouts()`
      </td>

      <td>
        Retorna o script atual, pageLoad e tempos limite implícitos.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="options-manage-set-timeouts-implicit">
      <td>
        `$webDriver.manage().setTimeouts({implicit: numberMS})`
      </td>

      <td>
        Especifica quanto tempo o driver deverá esperar ao procurar um elemento se ele não estiver presente imediatamente. Definir o tempo limite de espera como `0` desativa a espera implícita.

        Tenha cuidado ao aumentar o tempo limite de espera, pois isso aumentará o tempo de execução do teste, especialmente com estratégias de localização mais lentas, como XPath. O padrão é 10 segundos.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="options-manage-set-timeouts-pageLoad">
      <td>
        `$webDriver.manage().setTimeouts({pageLoad: numberMS})`
      </td>

      <td>
        Define o tempo de espera para a conclusão do carregamento da página antes de retornar um erro. Se o tempo limite for negativo, o carregamento da página poderá durar até 180 segundos. O padrão é 60 segundos.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="options-manage-set-timeouts-script">
      <td>
        `$webDriver.manage().setTimeouts({script: numberMS})`
      </td>

      <td>
        Define o tempo de espera, em milissegundos, para que um script assíncrono termine a execução antes de retornar um erro. O padrão é 30 segundos.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="options-manage-window-getRect">
      <td>
        `$webDriver.manage().window().getRect()`
      </td>

      <td>
        Recupera a posição atual da janela (como x e y), em relação ao canto superior esquerdo da tela e ao tamanho da janela (como largura e altura).

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="options-manage-window-maximize">
      <td>
        `$webDriver.manage().window().maximize()`
      </td>

      <td>
        Maximiza a janela atual.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="options-manage-window-setRect">
      <td>
        `$webDriver.manage().window().setRect({x: number|undefined, y: number|undefined, width: number|undefined, height: number|undefined})`
      </td>

      <td>
        Defina a posição atual da janela (como xey), em relação ao canto superior esquerdo da tela e o tamanho da janela (como largura e altura).

        Valor de retorno: promessa
      </td>
    </tr>
  </tbody>
</table>

## Localizador: Localizar elemento da página [#locators]

Localizador são uma coleção de funções de fábrica para criar `locator` instância. localizador encontra elementos DOM, que podem ser passados para funções como [`$webDriver.findElement`](#webDriver-findElement). Ligue para eles através de `$selenium.By`.

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Função
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="selenium-by-className">
      <td>
        `$selenium.By.className(className: string)`
      </td>

      <td>
        Localiza um elemento que possui um nome de classe específico. O localizador retornado é equivalente a procurar elementos com o seletor CSS `.class`.

        Valor de retorno: localizador
      </td>
    </tr>

    <tr id="selenium-by-css">
      <td>
        `$selenium.By.css(cssName: string)`
      </td>

      <td>
        Localiza um elemento usando um seletor CSS.

        Valor de retorno: localizador
      </td>
    </tr>

    <tr id="selenium-by-id">
      <td>
        `$selenium.By.id(id: string)`
      </td>

      <td>
        Localiza um elemento pelo seu ID.

        Valor de retorno: localizador
      </td>
    </tr>

    <tr id="selenium-by-linkText">
      <td>
        `$selenium.By.linkText(linkText: string)`
      </td>

      <td>
        Localiza elementos de link cujo texto visível corresponde à string fornecida.

        Valor de retorno: localizador
      </td>
    </tr>

    <tr id="selenium-by-js">
      <td>
        `$selenium.By.js(js: string)`
      </td>

      <td>
        Localiza um elemento avaliando uma expressão JavaScript.

        Valor de retorno: localizador
      </td>
    </tr>

    <tr id="selenium-by-name">
      <td>
        `$selenium.By.name(name: string)`
      </td>

      <td>
        Localiza elementos cujo atributo name possui o valor fornecido.

        Valor de retorno: localizador
      </td>
    </tr>

    <tr id="selenium-by-partialLinkText">
      <td>
        `$selenium.By.partialLinkText(partialLinkText: string)`
      </td>

      <td>
        Localiza elementos de link cujo [getText](#webElement-getText) visível contém a substring fornecida.

        Valor de retorno: localizador
      </td>
    </tr>

    <tr id="selenium-by-tagName">
      <td>
        `$selenium.By.tagName(tagName: string)`
      </td>

      <td>
        Localiza elementos com um determinado nome de tag. O localizador retornado é equivalente ao uso da função DOM `getElementsByTagName` .

        Valor de retorno: localizador
      </td>
    </tr>

    <tr id="selenium-by-xpath">
      <td>
        `$selenium.By.xpath(xpath: string)`
      </td>

      <td>
        Localiza elementos que correspondem a um seletor XPath.

        Valor de retorno: localizador
      </td>
    </tr>
  </tbody>
</table>

## WebElement: Interaja com o elemento da página [#webelement]

Quando uma função como [`$webDriver.findElement`](#webDriver-findElement) retorna uma referência WebElement, essas funções podem ser usadas para interagir com esse elemento. Por exemplo, você pode clicar em botões, enviar texto para entradas do formulário e obter um atributo de elementos para testar.

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Função
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="webElement-click">
      <td>
        `click()`
      </td>

      <td>
        Clica neste elemento.

        Valor de retorno: auto-referência
      </td>
    </tr>

    <tr id="webElement-sendKeys">
      <td>
        `sendKeys(var_args: ?)`
      </td>

      <td>
        Agenda um comando para digitar uma sequência no elemento DOM representado por esta instância.

        Valor de retorno: WebElement
      </td>
    </tr>

    <tr id="webElement-getTagName">
      <td>
        `getTagName()`
      </td>

      <td>
        Agenda um comando para consultar o nome da tag/nó deste elemento.

        Valor de retorno: WebElement
      </td>
    </tr>

    <tr id="webElement-getCssValue">
      <td>
        `getCssValue(name: string)`
      </td>

      <td>
        Agenda um comando para consultar o estilo computacional do elemento representado por esta instância. Se o elemento herdar o estilo nomeado de seu pai, o pai será consultado quanto ao seu valor. Sempre que possível, os valores das cores serão convertidos em sua representação hexadecimal (por exemplo, `#00ff00` em vez de `rgb(0, 255, 0)`).

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webElement-getAttribute">
      <td>
        `getAttribute(name: string)`
      </td>

      <td>
        Agenda um comando para consultar o valor de um determinado atributo do elemento.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webElement-getText">
      <td>
        `getText()`
      </td>

      <td>
        Obtenha o `innerText` visível (não oculto pelo CSS) deste elemento, incluindo subelementos, sem nenhum espaço em branco à esquerda ou à direita.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webElement-isEnabled">
      <td>
        `isEnabled()`
      </td>

      <td>
        Agenda um comando para consultar se o elemento DOM representado por esta instância está habilitado, conforme ditado pelo atributo desabilitado.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webElement-isSelected">
      <td>
        `isSelected()`
      </td>

      <td>
        Agenda um comando para consultar se este elemento está selecionado.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webElement-submit">
      <td>
        `submit()`
      </td>

      <td>
        Programa um comando para enviar o formulário que contém este elemento (ou este elemento se for um elemento `FORM` ). Este comando não é operacional se o elemento não estiver contido em um formulário.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webElement-clear">
      <td>
        `clear()`
      </td>

      <td>
        Agenda um comando para limpar o valor deste elemento.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="webElement-isDisplayed">
      <td>
        `isDisplayed()`
      </td>

      <td>
        Agenda um comando para testar se este elemento está sendo exibido no momento.

        Valor de retorno: promessa
      </td>
    </tr>
  </tbody>
</table>

## ActionSequence: vincular várias ações [#actionsequence]

As sequências de ação podem criar interações complexas do usuário com o seu site.

* Para criar uma nova sequência de ação, use [`$webDriver.actions()`](#webDriver-actions).
* Para vincular diversas ações em uma sequência, inclua [`perform()`](#actionSequence-perform) após cada uma. Isso executa e finaliza sequências individuais, incluindo sequências de ação única.

A tabela a seguir contém uma lista de ações disponíveis. Para obter mais informações, consulte a [documentação doWebdriver ActionSequence no GitHub](https://github.com/browserstack/selenium-webdriver-nodejs/blob/master/docs/class_webdriver_ActionSequence.html).

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Função
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="actionSequence-click">
      <td>
        `click(opt_elementOrButton: ?, opt_button: ?)`
      </td>

      <td>
        Clica em um botão do mouse. Se um elemento for fornecido, o mouse será primeiro movido para o centro desse elemento. Isso é equivalente a [`WebElement.click()`](#webElement-click).

        Valor de retorno: sequência de ações
      </td>
    </tr>

    <tr id="actionSequence-doubleClick">
      <td>
        `doubleClick(opt_elementOrButton: ?, opt_button: ?)`
      </td>

      <td>
        Clique duas vezes em um botão do mouse. Se um elemento for fornecido, o mouse será primeiro movido para o centro desse elemento.

        Valor de retorno: sequência de ações
      </td>
    </tr>

    <tr id="actionSequence-dragAndDrop">
      <td>
        `dragAndDrop(element: ?, location: ?)`
      </td>

      <td>
        Função de conveniência para realizar uma manobra de arrastar e soltar. O elemento alvo pode ser movido para a localização de outro elemento ou por um deslocamento (em pixels). A localização é um objeto com duas propriedades `x` e `y`: `{x: x_offset, y: y_offset}`.

        Valor de retorno: sequência de ações
      </td>
    </tr>

    <tr id="actionSequence-keyDown">
      <td>
        `keyDown(key: ?)`
      </td>

      <td>
        Executa um pressionamento de tecla modificadora. Deve ser um de `ALT`, `CONTROL`, `SHIFT`, `COMMAND` ou `META`. A tecla modificadora não é liberada até que [`keyUp()`](#actionSequence-keyUp) ou [`sendKeys()`](#actionSequence-sendKeys) seja chamado. O pressionamento da tecla será destino no elemento atualmente em foco.

        Valor de retorno: sequência de ações
      </td>
    </tr>

    <tr id="actionSequence-keyUp">
      <td>
        `keyUp(key: ?)`
      </td>

      <td>
        Executa uma liberação de tecla modificadora. O lançamento é destino no elemento atualmente em foco.

        Valor de retorno: sequência de ações
      </td>
    </tr>

    <tr id="actionSequence-mouseDown">
      <td>
        `press(opt_elementOrButton: ?, opt_button: ?)`
      </td>

      <td>
        Pressiona um botão do mouse. O botão do mouse não será liberado até que [`release`](#actionSequence-mouseUp) seja chamado, independentemente de a chamada ser feita nesta sequência ou em outra. O comportamento para eventos fora de ordem (como chamar `press()` ou `click()` quando o botão já está pressionado) é indefinido.

        Valor de retorno: sequência de ações
      </td>
    </tr>

    <tr id="actionSequence-mouseUp">
      <td>
        `release(opt_elementOrButton: ?, opt_button: ?)`
      </td>

      <td>
        Libera um botão do mouse. O comportamento é indefinido para chamar esta função sem uma chamada anterior para [`press()`](#actionSequence-mouseDown).

        Valor de retorno: sequência de ações
      </td>
    </tr>

    <tr id="actionSequence-mouseMove">
      <td>
        `move(location: ?, offset: ?)`
      </td>

      <td>
        Move o mouse. A localização para a qual mover pode ser especificada em termos da localização atual do mouse, um deslocamento relativo ao canto superior esquerdo de um elemento ou um elemento (nesse caso, o meio do elemento é usado).

        Valor de retorno: sequência de ações
      </td>
    </tr>

    <tr id="actionSequence-perform">
      <td>
        `perform()`
      </td>

      <td>
        Executa esta sequência de ação.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="actionSequence-sendKeys">
      <td>
        `sendKeys(args: ?)`
      </td>

      <td>
        Simula a digitação de várias teclas. Cada tecla modificadora encontrada na sequência não será liberada até que seja encontrada novamente. Todos os eventos principais serão destino no elemento atualmente em foco. Para obter uma lista completa de chaves não alfanuméricas suportadas, consulte a [documentação da chave enumWebdriver no GitHub](https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/Keys.html).

        Valor de retorno: sequência de ações
      </td>
    </tr>
  </tbody>
</table>

## Promessas: vincular ações em sequências [#promises]

Você também pode executar funções diretamente nas promessas. O monitoramento sintético é um ambiente nativo do Node.js e usa promessas padrão do Node.js.

Essas funções avaliam o status das promessas, cancelam-nas e muito mais. Em particular, você pode criar sequências de ações com a função [`then()`](#promises-then) e suas irmãs, [`finally()`](#promises-thenFinally) e [`catch()`](#promises-thenCatch). Para obter mais informações, consulte [Sequenciar ações](/docs/synthetics/new-relic-synthetics/scripting-monitors/write-scripted-browsers#sequence).

<Callout variant="tip">
  Além de oferecer suporte à cadeia de promessas usando .then sintaxe, esse tempo de execução também oferece suporte à sintaxe async-await.
</Callout>

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Função
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="promises-isPending">
      <td>
        `isPending()`
      </td>

      <td>
        Se o valor desta promessa ainda está sendo computado.

        Valor de retorno: booleano
      </td>
    </tr>

    <tr id="promises-then">
      <td>
        `then(opt_callback: fn(T: ?), opt_errback: fn())`
      </td>

      <td>
        Registra ouvintes para quando esta instância for resolvida. Esta é a função básica usada para vincular ações síncronas em seu script.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="promises-thenFinally">
      <td>
        `finally(callback: fn())`
      </td>

      <td>
        Registra um ouvinte para invocar quando esta promessa for resolvida, independentemente de o valor da promessa ter sido computado com sucesso.

        Valor de retorno: promessa
      </td>
    </tr>

    <tr id="promises-thenCatch">
      <td>
        `catch(callback: fn())`
      </td>

      <td>
        Registra um ouvinte para quando esta promessa for rejeitada.

        Valor de retorno: promessa
      </td>
    </tr>
  </tbody>
</table>

## Navegar: percorrer o histórico do browser [#promises]

A função `$webDriver.navigate()` expõe diversas funções que permitem retroceder e avançar no histórico do browser, atualizar sua página e navegar para novas páginas.

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Função
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="navigate-back">
      <td>
        `back()`
      </td>

      <td>
        Volte um passo no histórico do browser.

        Valor de retorno: nulo
      </td>
    </tr>

    <tr id="navigate-forward">
      <td>
        `forward()`
      </td>

      <td>
        Avance um passo no histórico do browser.

        Valor de retorno: nulo
      </td>
    </tr>

    <tr id="navigate-refresh">
      <td>
        `refresh()`
      </td>

      <td>
        Atualize a página atual.

        Valor de retorno: nulo
      </td>
    </tr>

    <tr id="navigate-to">
      <td>
        `to(string: url)`
      </td>

      <td>
        Carregue uma nova página da web na janela atual do browser. `$webDriver.navigate().to()` é equivalente a `$webDriver.get()`.

        Valor de retorno: nulo
      </td>
    </tr>
  </tbody>
</table>

## Condições: Faça uma pausa e aguarde as condições [#until]

<Callout variant="tip">
  Você pode aprender mais sobre esperas no Selenium [em sua documentação oficial](https://www.selenium.dev/documentation/en/webdriver/waits/).
</Callout>

Usado com `$webDriver.wait`, `until` pausa a execução do script até que a condição seja atendida. Para obter mais informações, consulte [a documentação Webdriver `until` do Selenium](http://www.seleniumhq.org/docs/04_webdriver_advanced.jsp).

A seguir estão as funções disponíveis para `$selenium.until.Condition`:

<table>
  <thead>
    <tr>
      <th style={{ width: "400px" }}>
        Função
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr id="conditions-ableToSwitchToFrame">
      <td>
        `ableToSwitchToFrame(frame: ?)`
      </td>

      <td>
        Cria uma condição que aguardará até que o driver de entrada consiga alternar para o quadro designado. O quadro de destino pode ser especificado como:

        * Um índice numérico em `window.frames` para o quadro atual
        * Um `webdriver.WebElement`, que deve fazer referência a um elemento `FRAME` ou `IFRAME` na página atual
        * Um localizador que pode ser usado para localizar primeiro um `FRAME` ou `IFRAME` na página atual antes de tentar mudar para ele

          Após a resolução bem-sucedida desta condição, o driver permanecerá focado no novo quadro.

          Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-alertIsPresent">
      <td>
        `alertIsPresent()`
      </td>

      <td>
        Cria uma condição que aguarda a abertura de um alerta. Após sucesso, a promessa retornada será cumprida com o identificador do alerta aberto.

        Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-elementIsDisabled">
      <td>
        `elementIsDisabled(element: $selenium.WebElement)`
      </td>

      <td>
        Cria uma condição que aguardará que determinado elemento seja desabilitado.

        Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-elementIsEnabled">
      <td>
        `elementIsEnabled(element: $selenium.WebElement)`
      </td>

      <td>
        Cria uma condição que aguardará a habilitação de um determinado elemento.

        Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-elementIsNotVisible">
      <td>
        `elementIsNotVisible(element: $selenium.WebElement)`
      </td>

      <td>
        Cria uma condição que aguardará que determinado elemento esteja no DOM, mas não visível para o usuário.

        Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-elementIsVisible">
      <td>
        `elementIsVisible(element: $selenium.WebElement)`
      </td>

      <td>
        Cria uma condição que aguardará até que determinado elemento se torne visível.

        Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-elementIsSelected">
      <td>
        `elementIsSelected(element: $selenium.WebElement)`
      </td>

      <td>
        Cria uma condição que aguardará a seleção de determinado elemento.

        Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-elementLocated">
      <td>
        `elementLocated(element: $selenium.Locator)`
      </td>

      <td>
        Cria uma condição que fará um loop até que um elemento seja encontrado com o localizador fornecido.

        Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-elementsLocated">
      <td>
        `elementsLocated(element: $selenium.Locator)`
      </td>

      <td>
        Cria uma condição que fará um loop até que pelo menos um elemento seja encontrado com o localizador fornecido.

        Valor de retorno: condição

        n
      </td>
    </tr>

    <tr id="conditions-elementTextContains">
      <td>
        `elementTextContains(element: $selenium.WebElement, substr: string)`
      </td>

      <td>
        Cria uma condição que aguardará que o texto visível do elemento fornecido contenha a substring especificada.

        Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-elementTextIs">
      <td>
        `elementTextIs(element: $selenium.WebElement, text: string)`
      </td>

      <td>
        Maiúsculas e minúsculas. Cria uma condição que aguardará que o texto visível do elemento fornecido corresponda exatamente ao texto fornecido.

        Valor de retorno: condição

        n
      </td>
    </tr>

    <tr id="conditions-elementTextMatches">
      <td>
        `elementTextMatches(element: $selenium.WebElement, regex: string)`
      </td>

      <td>
        Cria uma condição que aguardará que o texto visível do elemento fornecido corresponda a uma expressão regular.

        Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-stalenessOf">
      <td>
        `stalenessOf(element: $selenium.WebElement)`
      </td>

      <td>
        Cria uma condição que aguardará que o elemento determinado fique obsoleto. Um elemento é considerado obsoleto quando é removido do DOM ou quando uma nova página é carregada.

        Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-titleContains">
      <td>
        `titleContains(substr: string)`
      </td>

      <td>
        Cria uma condição que aguardará que o título da página atual contenha a substring fornecida.

        Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-titleIs">
      <td>
        `titleIs(title: string)`
      </td>

      <td>
        Cria uma condição que aguardará que o título da página atual corresponda ao valor fornecido.

        Valor de retorno: condição
      </td>
    </tr>

    <tr id="conditions-titleMatches">
      <td>
        `titleMatches(regex: string)`
      </td>

      <td>
        Cria uma condição que aguardará que o título da página atual corresponda à expressão regular fornecida.

        Valor de retorno: condição
      </td>
    </tr>
  </tbody>
</table>

## Exemplo avançado [#example]

O exemplo a seguir separa o código em seções funcionais: Constantes, dependência, configuração, elemento de página, funções e início do script. Ele demonstra como você pode:

* Configure tempos limite para minimizar as durações das falhas e obter melhor desempenho.
* Localize elementos por CSS ou ID.
* Defina `waitForAndFindElement`.
* Use `console.log()` para organizar o script log e identificar problemas com falhas de declaração ou tempos limite.
* Trate os erros com um bloco try/catch que lança uma mensagem de erro útil identificando a etapa de falha.

```js
/**
 * Script Name: Advanced Example
 * Author:      New Relic
 * Version:     1.6
 */

// -------------------- CONSTANTS
const SCRIPT_NAME = "Best Practices - Chrome 100"                        // name to record in script log
const IMPLICIT_TIMEOUT = 3000                                            // default implicit timeout is 10 seconds
const PAGE_LOAD_TIMEOUT = 60000                                          // default page load timeout is 60 seconds, fail early to prevent long duration timeouts
const SCRIPT_TIMEOUT = 20000                                             // default script timeout is 30 seconds
const USER_AGENT = "default"                                             // set the user agent for Chrome
const PROTOCOL = "https://"                                              // set the protocol
const USERNAME = ""                                                      // username:
const PASSWORD = ""                                                      // password@
const DOMAIN = "docs.newrelic.com"                                       // your domain
const PATH = "/docs/new-relic-solutions/get-started/intro-new-relic/"    // path to main page
const CHECK = "Get started with New Relic"                               // text to match on page
const AUTH = USERNAME + PASSWORD                                         // could be stored as secure credentials
const MAIN_URL = PROTOCOL + AUTH + DOMAIN + PATH

// -------------------- DEPENDENCIES
const assert = require("assert")

// -------------------- CONFIGURATION
await $webDriver.manage().setTimeouts({
  implicit: IMPLICIT_TIMEOUT,  // sets element load timeout
  pageLoad: PAGE_LOAD_TIMEOUT, // sets page load timeout
  script: SCRIPT_TIMEOUT       // sets script timeout
})

// -------------------- ELEMENTS
const By = $selenium.By
const loc = {
  title: By.css("#gatsby-focus-wrapper > div.css-1uz5ayg > div > main > div > h1"),
  start: [
    { step: 'signup',     selector: By.id("sign-up-for-new-relic-if-you-havent-already") },
    { step: 'add',        selector: By.id("add-your-data") },
    { step: 'explore',    selector: By.id("explore-your-data") },
    { step: 'query',      selector: By.id("query-your-data") },
    { step: 'dashboard',  selector: By.id("set-up-a-dashboard") },
    { step: 'alerts',     selector: By.id("configure-alerts") }
  ]
}

// -------------------- FUNCTIONS
// for backwards compatibility with legacy runtimes
async function waitForAndFindElement(locator, timeout) {
  const element = await $webDriver.wait(
    $selenium.until.elementLocated(locator),
    timeout,
    "Timed-out waiting for element to be located using: " + locator
  )
  await $webDriver.wait(
    $selenium.until.elementIsVisible(element),
    timeout,
    "Timed-out waiting for element to be visible using ${element}"
  )
  return await $webDriver.findElement(locator)
}

// -------------------- START OF SCRIPT
// Start logging
const start_time = new Date()
console.log("Starting synthetics script: " + SCRIPT_NAME)

// confirm timeouts are set
const {implicit, pageLoad, script} = await $webDriver.manage().getTimeouts()
console.log("Timeouts are set to:")
console.log("  IMPLICIT: " + implicit / 1000 + "s")
console.log("  PAGE LOAD: " + pageLoad / 1000 + "s")
console.log("  SCRIPT: " + script / 1000 + "s")

// Setting User Agent is not then-able, so we do this first (if defined and not default)
if (USER_AGENT && 0 !== USER_AGENT.trim().length && USER_AGENT != "default") {
  $headers.add("User-Agent", USER_AGENT)
  console.log("Setting User-Agent to " + USER_AGENT)
}

// if an error happens at any step, script execution is halted and a failed result is returned
console.log("1. get: " + MAIN_URL)
await $webDriver.get(MAIN_URL)

console.log("2. waitForAndFindElement: " + loc.title)
const textBlock = await waitForAndFindElement(loc.title, IMPLICIT_TIMEOUT)

console.log("3. getText: " + CHECK)
const text1 = await textBlock.getText()

console.log("4. assert.equal: " + text1)
assert.equal(text1, CHECK, "title validation text not found")

console.log("5. takeScreenshot")
await $webDriver.takeScreenshot()

console.log("6. findElement")
loc.start.forEach(async function (nr, i) {
  let n = i + 1
  try{
    // verify each asset has loaded
    console.log("  " + n + ". " + nr.step + ": " + nr.selector)
    await $webDriver.findElement(nr.selector)
  }catch(exception){
    console.error("Failure in Step 6." + n)
    throw exception
  }
})

// End logging
const end_time = new Date()

// Calculate the duration
const script_duration = (end_time - start_time) / 1000

// Log the times
console.log("Start time: " + start_time)
console.log("End time: " + end_time)
console.log("Duration: " + script_duration + "s")
```

## Shadow DOM: Encontrando elementos [#shadow]

O tempo de execução também oferece suporte ao acesso a elementos shadow DOM usando o novo método Selenium Webdriver `getShadowRoot()`.

1. Use `findElement` ou uma [função de nível superior](#structure) semelhante para localizar o host sombra. Este é o elemento no qual o shadow-root está montado.
2. Use o método `getShadowRoot()` no elemento encontrado na etapa 1 para obter a raiz sombria.
3. Usando a raiz sombra, agora você pode usar findElement ou funções semelhantes para localizar elementos dentro da raiz sombra. Se vários níveis de shadow DOM forem usados, essas etapas precisarão ser repetidas até você acessar o objeto raiz shadow que contém o elemento com o qual você precisa interagir.

<Callout variant="tip">
  O Chrome não oferece suporte ao uso do localizador XPath dentro de um objeto raiz de sombra. Use uma [opção de localizador](#locators) diferente para localizar elementos dentro de um objeto raiz de sombra.
</Callout>

Exemplo:

```js
// Find the shadow host
let myShadowHost = await $webDriver.findElement($selenium.By.id('exampleShadowHost'));
// Get the shadow root
let myShadowRoot = await myShadowHost.getShadowRoot();
// Interact with an element inside the shadow root
let el = await myShadowRoot.findElement($selenium.By.id('myButton'));
await el.click();
```
