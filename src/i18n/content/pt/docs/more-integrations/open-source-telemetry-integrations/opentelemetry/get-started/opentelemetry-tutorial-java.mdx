---
title: 'Tutoriais OpenTelemetry: instrumento um exemplo de aplicativo Java'
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: 'To test out OpenTelemetry on a sample app instead of your own app, consider these three tutorials.'
freshnessValidatedDate: never
translationType: machine
---

import opentelemetrySpringBootASCIIDisplay from 'images/opentelemetry_screenshot-crop_Spring-Boot-ASCII-display.webp'

import opentelemetryMainDistributedTracingPage from 'images/opentelemetry_screenshot-crop_main-distributed-tracing-page.webp'

import opentelemetryDistributedTracingError from 'images/opentelemetry_screenshot-crop_distributed-tracing-error.webp'

import opentelemetryInProcessSpans from 'images/opentelemetry_screenshot-crop_in-process-spans.webp'

import opentelemetryExceptiononSpanEvent from 'images/opentelemetry_screenshot-crop_exception-on-span-event.webp'

import opentelemetryAttributesTab from 'images/opentelemetry_screenshot-crop_attributes-tab.webp'

import opentelemetryMetricsExplorerMain from 'images/opentelemetry_screenshot-crop_metrics-explorer-main.webp'

import opentelemetryMetricsExplorerDimensions from 'images/opentelemetry_screenshot-crop_metrics-explorer-dimensions.webp'

import opentelemetryJvmsPageMain from 'images/opentelemetry_screenshot-crop_jvms-page-main.webp'

import opentelemetryCompareJvmInstances from 'images/opentelemetry_screenshot-full_compare-jvm-instances.webp'

import opentelemetryJvmColorCodedComparison from 'images/opentelemetry_screenshot-full_jvm-color-coded-comparison.webp'

import opentelemetryMainLogsPage from 'images/opentelemetry_screenshot-full_main-logs-page.webp'

import opentelemetryLogsinTerminal from 'images/opentelemetry_screenshot-full_logs-in-terminal.webp'

import opentelemetryLogDetailsWithTrace from 'images/opentelemetry_screenshot-full_log-details-with-trace.webp'

import opentelemetryTraceRelatedtoLog from 'images/opentelemetry_screenshot-full_trace-related-to-log.webp'

import opentelemetryTraceWaterfallFromLog from 'images/opentelemetry_screenshot-full_trace-waterfall-from-log.webp'

import opentelemetryLogCapturedinTraceSpan from 'images/opentelemetry_screenshot-full_log-captured-in-trace-span.webp'

import opentelemetryTraceDurationDemoChart from 'images/opentelemetry_screenshot-crop_jvm-metric-charts.webp'

Experimente estes tutoriais Java para ver o que a plataforma New Relic pode fazer com seus dados OTLP. Temos três tutoriais para você escolher, cada um usando o mesmo aplicativo Spring de demonstração. O aplicativo irá calcular o enésimo número na sequência de Fibonacci e gerar rastreamento, métrica e log.

Ao trabalhar com esses tutoriais, você pode aprender habilidades para ajudá-lo a configurar seu próprio aplicativo com OpenTelemetry e New Relic.

<img
  title="Screenshot showing various JVM metric charts"
  alt="Screenshot showing various JVM metric charts"
  src={opentelemetryTraceDurationDemoChart}
/>

<figcaption>
  Depois de concluir qualquer um desses tutoriais, você poderá visualizar as métricas da JVM em gráficos como estes.
</figcaption>

## Requisitos [#requirements]

Para começar, certifique-se de ter o seguinte:

* Uma conta New Relic: Cadastre-se para obter uma [conta gratuita](https://newrelic.com/signup) se ainda não tiver uma.
* Java 17 ou superior: se você ainda não o possui, consulte [estas opções de download](https://www.java.com/en/download/manual.jsp).

## Tutoriais [#tutorials]

Embora cada tutorial use o mesmo aplicativo de demonstração, eles têm abordagens diferentes para ajudá-lo a se familiarizar com o OpenTelemetry e o New Relic.

* [Aplicativo de pré-instrumento](#pre-instrumented-tutorial): Execute nosso aplicativo de demonstração de pré-instrumento para ver rapidamente os dados em nossa interface.
* [OpenTelemetry agente Java](#java-agent-tutorial): monitor nosso aplicativo de demonstração com o agente OpenTelemetry Java.
* [Configuração manual](#manual-setup-tutorial): instrumento nosso aplicativo de demonstração manualmente.

Clique na guia abaixo do tutorial que deseja concluir.

<Callout variant="tip">
  Ao usar o OpenTelemetry, você terá duas opções para exportar dados do seu aplicativo para o New Relic via OTLP:

  * Diretamente do seu aplicativo para o New Relic
  * Seu aplicativo envia dados para um coletor OpenTelemetry, onde são exportados para o New Relic

  Esses tutoriais cobrem a primeira opção. Se você deseja exportar seus dados por meio de um coletor, consulte a [documentação do coletor](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/collector/opentelemetry-collector-basic/) para obter detalhes.
</Callout>

<Tabs>
  <TabsBar>
    <TabsBarItem id="pre-instrumented-tutorial">
      Aplicativo pré-instrumento
    </TabsBarItem>

    <TabsBarItem id="java-agent-tutorial">
      Agente OpenTelemetry Java
    </TabsBarItem>

    <TabsBarItem id="manual-setup-tutorial">
      Configuração manual
    </TabsBarItem>
  </TabsBar>

  <TabsPages>
    <TabsPageItem id="pre-instrumented-tutorial">
      ### Execute o aplicativo de demonstração pré-instrumento [#pre-instrum]

      Esta é uma ótima opção se você deseja que façamos a instrumentação para que possa ver rapidamente como é enviar dados para o New Relic e visualizá-los em nossa interface.

      1. Em seu terminal, execute o seguinte para clonar o aplicativo de demonstração e navegue até o diretório `java` dos Guias de primeiros passos.

         ```bash
         git clone https://github.com/newrelic/newrelic-opentelemetry-examples.git
         cd newrelic-opentelemetry-examples/getting-started-guides/java
         ```

      2. Defina estas duas variáveis de ambiente para enviar dados para sua conta New Relic:

         * Certifique-se de usar seu <InlinePopover type="licenseKey"/>.

         * Se a região do seu data center New Relic for a UE e não os EUA, defina o endpoint como: `https://otlp.eu01.nr-data.net`

           * `OTEL_EXPORTER_OTLP_HEADERS=api-key=INSERT_YOUR_NEW_RELIC_LICENSE_KEY`
           * `OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.nr-data.net`
           * `OTEL_EXPORTER_OTLP_PROTOCOL=http/protobuf`

      3. Defina a primeira variável de ambiente abaixo para nomear o serviço, depois defina a segunda para o ID da instância do serviço, que ativa determinado recurso da plataforma. Por fim, habilite os logs, já que o log está desativado por padrão:

         * `OTEL_SERVICE_NAME=getting-started-java`

         * `OTEL_RESOURCE_ATTRIBUTES=service.instance.id=INSERT_YOUR_ID_HERE`

           * Substitua `INSERT_YOUR_OWN_ID_HERE` por um ID de instância exclusivo. Por exemplo, você poderia usar 1234.

         * `OTEL_LOGS_EXPORTER=otlp`

      4. No mesmo diretório `getting-started-guides/java` , crie e execute o aplicativo:

         * Mac OS:

           ```bash
           ./gradlew bootRun
           ```

         * PowerShell:

           ```bash
           .\gradlew.bat build
           ```

      5. Abra uma nova guia do terminal, alterne para o diretório `getting-started-guides/java/Instrumented` e execute o seguinte comando para gerar tráfego para o aplicativo:

         * Mac OS:

           ```bash
           ./load-generator.sh
           ```

         * PowerShell:

           ```bash
           .\load-generator.ps1
           ```

         <Callout variant="tip">
           Alternativamente, você pode acessar o endpoint no browser neste URL: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE`. Substitua `INSERT_A_VALUE` por um valor de 1 a 90. Para gerar um erro, insira um número inteiro fora do intervalo válido.
         </Callout>

      6. Vá para <DoNotTranslate>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > APM & services**</DoNotTranslate>.

      7. Clique na sua nova entidade (serviço) chamada `getting-started-java` e explore a interface. Para obter mais dicas sobre o que procurar na interface, consulte [Visualizar seus dados no New Relic](#view-data).

      8. Quando terminar de visualizar seus dados na interface, encerre o aplicativo pressionando CONTROL+C em ambas as sessões do terminal.
    </TabsPageItem>

    <TabsPageItem id="java-agent-tutorial">
      ### Monitor o aplicativo de demonstração com o agente OpenTelemetry Java [#java-agent]

      Aqui está um tutorial diferente que também usa o mesmo aplicativo de demonstração. Nesse caso, você usará o agente OpenTelemetry Java para monitor automaticamente o aplicativo de demonstração. Você não precisa modificar o código-fonte Java. Ao usar o agente, você pode começar rapidamente a exportar dados de amostra para o New Relic.

      O agente de instrumentação automática é um arquivo JAR que injeta bytecode dinamicamente para capturar telemetria de bibliotecas e estruturas populares. Você também pode usá-lo para capturar dados como solicitações de entrada, chamadas HTTP de saída e chamadas de banco de dados. Ele pode ser anexado a qualquer aplicativo Java 8+.

      <Callout variant="tip">
        Consulte a [documentação oficial do agente Java](https://opentelemetry.io/docs/instrumentation/java/automatic/) para opções de configuração adicionais.
      </Callout>

      Para monitor nosso aplicativo de demonstração com o agente OpenTelemetry Java:

      1. Faça download do [arquivo JAR do agente](https://github.com/open-telemetry/opentelemetry-java-instrumentation/releases/latest/download/opentelemetry-javaagent.jar), que contém a biblioteca de agente e instrumentação. Coloque-o no diretório de sua preferência e anote o caminho que você usará posteriormente.

      2. Caso ainda não tenha feito isso, baixe o repositório do aplicativo de demonstração e mude para o seguinte diretório:

         ```bash
         git clone https://github.com/newrelic/newrelic-opentelemetry-examples.git
         cd newrelic-opentelemetry-examples/getting-started-guides/java
         ```

      3. Crie o aplicativo de demonstração com este comando:

         * Mac OS:

           ```bash
           ./gradlew build
           ```

         * PowerShell:

           ```bash
           .\gradlew.bat build
           ```

           <Callout variant="tip">
             Após uma compilação bem-sucedida, você encontrará o arquivo JAR do aplicativo resultante em `Uninstrumented/build/libs`, chamado `uninstrumented.jar`.
           </Callout>

      4. Vá para nossa [seção de referência de variáveis de ambiente](#ref-env-vars) abaixo para ver quais variáveis você precisa exportar e depois retorne a estas etapas.

      5. Continue em `getting-started-guides/java/Uninstrumented` para lançar o agente com o aplicativo:

         <Callout variant="important">
           Substitua `path/to` pelo local do arquivo JAR que você baixou anteriormente.
         </Callout>

         ```bash
         java -javaagent:path/to/opentelemetry-javaagent.jar \
              -jar ./build/libs/uninstrumented.jar
         ```

      6. Gere tráfego para o aplicativo abrindo um novo terminal no diretório `getting-started-guides/java/Uninstrumented` e executando o gerador de carga:

         * Mac OS:

           ```bash
           ./load-generator.sh
           ```

         * PowerShell:

           ```bash
           .\load-generator.ps1
           ```

         <Callout variant="tip">
           Alternativamente, você pode acessar o endpoint no browser neste URL: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE`. Substitua `INSERT_A_VALUE` por um valor de 1 a 90. Para gerar um erro, insira um número inteiro fora do intervalo válido.
         </Callout>

      7. Agora que você enviou alguns dados para o New Relic, veja nossas [instruções sobre como visualizar os dados na interface](#view-data).

      8. Quando terminar de visualizar seus dados na interface, encerre o aplicativo pressionando CONTROL+C em ambas as sessões do terminal.
    </TabsPageItem>

    <TabsPageItem id="manual-setup-tutorial">
      ### Configure o aplicativo de demonstração manualmente [#manual-instrum]

      O tutorial anterior ajudou você a explorar a instrumentação automática com o agente OpenTelemetry Java. Este tutorial mostrará como usar instrumentação personalizada para ter mais controle sobre a telemetria coletada. Você inserirá manualmente a instrumentação em nosso aplicativo de demonstração para capturar telemetria e, em seguida, configurará o SDK para exportar esses dados para o New Relic.

      <Callout variant="tip">
        Embora você possa configurar manualmente o SDK, mostraremos como configurá-lo usando a [opção autoconfigure](https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions/autoconfigure), que simplifica o processo usando variáveis de ambiente e propriedades do sistema.
      </Callout>

      <Steps>
        <Step>
          #### Baixe o aplicativo de demonstração [#download]

          Se você ainda não baixou nosso aplicativo de demonstração, execute o seguinte:

          ```bash
          git clone https://github.com/newrelic/newrelic-opentelemetry-examples.git
          ```
        </Step>

        <Step>
          #### Instalar dependência [#dependencies]

          Para adicionar dependência:

          1. Vá para o diretório do aplicativo.

             ```bash
             cd newrelic-opentelemetry-examples/getting-started-guides/java/uninstrumented
             ```

          2. Abra `build.gradle`.

          3. Adicione os seguintes itens destacados ao bloco `dependencies` (talvez seja necessário rolar para baixo dentro do bloco de código):

             ```gradle lineHighlight=29-42
             plugins {
                 id 'org.springframework.boot' version '2.7.5'
                 id 'io.spring.dependency-management' version '1.1.0'
                 id 'java'
             }

             java {
                 toolchain {
                     languageVersion = JavaLanguageVersion.of(17)
                 }
             }

             repositories {
                 mavenCentral()
             }

             bootRun {
                 mainClass.set 'com.example.demo.Application'
             }

             configurations.all {
                 exclude module: 'spring-boot-starter-logging'
             }

             dependencies {
                 implementation 'org.springframework.boot:spring-boot-starter-web'
                 implementation 'org.springframework.boot:spring-boot-starter-log4j2'

                 // OpenTelemetry core
                 implementation platform('io.opentelemetry:opentelemetry-bom:1.22.0')
                 implementation platform('io.opentelemetry:opentelemetry-bom-alpha:1.22.0-alpha')
                 implementation 'io.opentelemetry:opentelemetry-api'
                 implementation 'io.opentelemetry:opentelemetry-sdk'
                 implementation 'io.opentelemetry:opentelemetry-exporter-otlp'
                 implementation 'io.opentelemetry:opentelemetry-exporter-otlp-logs'
                 implementation 'io.opentelemetry:opentelemetry-sdk-extension-autoconfigure'

                 // OpenTelemetry instrumentation
                 implementation platform('io.opentelemetry.instrumentation:opentelemetry-instrumentation-bom-alpha:1.22.1-alpha')
                 implementation 'io.opentelemetry.instrumentation:opentelemetry-runtime-metrics'
                 implementation 'io.opentelemetry.instrumentation:opentelemetry-log4j-appender-2.17'
                 implementation 'io.opentelemetry.instrumentation:opentelemetry-spring-webmvc-6.0'
             }
             ```

          Notas:

          * A dependência `bom` (lista de materiais) é usada para sincronizar versões de dependência para um ecossistema específico. Como o OpenTelemetry publica muitos componentes Java, eles ajudam a garantir que todas as versões sejam sincronizadas, quer você use apenas algumas ou muitas delas.
          * As dependências restantes fornecem acesso ao SDK, API, exportador OTLP e biblioteca de instrumentação.
          * Há uma configuração adicional para excluir o módulo spring-boot-starter-logging. Isso evita uma mensagem de erro de compilação relacionada a `log4j-slf4j-impl cannot be present with log4j-to-slf4j`.
        </Step>

        <Step>
          #### Configure o SDK com a extensão autoconfigure [#auto-config-ext]

          Embora você possa configurar o SDK manualmente, recomendamos usar a extensão autoconfigure, pois ela agiliza o processo.

          1. Vá para o diretório do código-fonte do aplicativo:

             ```bash
             cd newrelic-opentelemetry-examples/getting-started-guides/java/uninstrumented/src/main/java/com/example/demo
             ```

          2. Abra `Application.java`.

          3. Insira as linhas destacadas:

             ```java lineHighlight=7-12,17-20
             @SpringBootApplication
             public class Application {

                 private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

                 public static void main(String[] args) {
                     // Build the SDK auto-configuration extension module
                     OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                             .setResultAsGlobal(false)
                             .build()
                             .getOpenTelemetrySdk();
                     Application.openTelemetry = openTelemetrySdk;

                     SpringApplication.run(Application.class, args);
                 }

                 @Bean
                 public OpenTelemetry openTelemetry() {
                     return openTelemetry;
                 }
             }
             ```

          4. Vá para nossa [seção de referência de variáveis de ambiente](#ref-env-vars) abaixo para ver quais variáveis você precisa exportar e depois retorne a estas etapas.
        </Step>

        <Step>
          #### Adicionar biblioteca de instrumentação: trace [#library-traces]

          Em `Application.java`, adicione a instrumentação destacada para Spring Web MVC registrando um filtro de rastreamento:

          ```java lineHighlight=22-26
          @SpringBootApplication
          public class Application {

              private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

              public static void main(String[] args) {
                  // Build the SDK auto-configuration extension module
                  OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                          .setResultAsGlobal(false)
                          .build()
                          .getOpenTelemetrySdk();
                  Application.openTelemetry = openTelemetrySdk;

                  SpringApplication.run(Application.class, args);
              }

              @Bean
              public OpenTelemetry openTelemetry() {
                  return openTelemetry;
              }

              // Add Spring WebMVC instrumentation by registering a tracing filter
              @Bean
              public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
                  return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
              }
          }
          ```
        </Step>

        <Step>
          #### Adicionar biblioteca de instrumentação: métrica [#library-metrics]

          Gere e colete métricas sobre seu tempo de execução Java registrando o seguinte no arquivo `Application.java` . Insira as linhas destacadas abaixo:

          ```java lineHighlight=14-20
          @SpringBootApplication
          public class Application {

              private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

              public static void main(String[] args) {
                  // Build the SDK auto-configuration extension module
                  OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                          .setResultAsGlobal(false)
                          .build()
                          .getOpenTelemetrySdk();
                  Application.openTelemetry = openTelemetrySdk;

                  // Register runtime metrics instrumentation
                  BufferPools.registerObservers(openTelemetrySdk);
                  Classes.registerObservers(openTelemetrySdk);
                  Cpu.registerObservers(openTelemetrySdk);
                  GarbageCollector.registerObservers(openTelemetrySdk);
                  MemoryPools.registerObservers(openTelemetrySdk);
                  Threads.registerObservers(openTelemetrySdk);

                  SpringApplication.run(Application.class, args);
              }

              @Bean
              public OpenTelemetry openTelemetry() {
                  return openTelemetry;
              }

              // Add Spring WebMVC instrumentation by registering a tracing filter
              @Bean
              public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
                  return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
              }
          }
          ```
        </Step>

        <Step>
          #### Adicionar biblioteca de instrumentação: log [#library-logs]

          Este aplicativo de demonstração está configurado para usar o `OpenTelemetryAppender` (via `log4j.xml`), que usa `GlobalLoggerProvider`. A configuração de `GlobalLoggerProvider` conecta o `OpenTelemetryAppender` ao SDK log que é configurado usando autoconfigure aqui:

          1. Abra `Application.java`.

          2. Insira as seguintes linhas destacadas.

             ```java lineHighlight=14-15
             @SpringBootApplication
             public class Application {

                 private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

                 public static void main(String[] args) {
                     // Build the SDK auto-configuration extension module
                     OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                             .setResultAsGlobal(false)
                             .build()
                             .getOpenTelemetrySdk();
                     Application.openTelemetry = openTelemetrySdk;

                     // Set GlobalLoggerProvider, which is used by Log4j2 appender
                     GlobalLoggerProvider.set(openTelemetrySdk.getSdkLoggerProvider());

                     // Register runtime metrics instrumentation
                     BufferPools.registerObservers(openTelemetrySdk);
                     Classes.registerObservers(openTelemetrySdk);
                     Cpu.registerObservers(openTelemetrySdk);
                     GarbageCollector.registerObservers(openTelemetrySdk);
                     MemoryPools.registerObservers(openTelemetrySdk);
                     Threads.registerObservers(openTelemetrySdk);

                     SpringApplication.run(Application.class, args);
                 }

                 @Bean
                 public OpenTelemetry openTelemetry() {
                     return openTelemetry;
                 }

                 // Add Spring WebMVC instrumentation by registering a tracing filter
                 @Bean
                 public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
                     return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
                 }
             }
             ```

          3. Crie um diretório chamado `resources` em `Uninstrumented/src/main`.

          4. Neste novo diretório, crie um arquivo chamado `log4j2.xml` com o seguinte conteúdo:

             ```xml
             <?xml version="1.0" encoding="UTF-8"?>
             <Configuration status="WARN" packages="io.opentelemetry.instrumentation.log4j.appender.v2_17">
               <Appenders>
                 <Console name="ConsoleAppender" target="SYSTEM_OUT" follow="true">
                   <PatternLayout pattern="%d{yyyy-mm-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
                 </Console>
                 <OpenTelemetry name="OpenTelemetryAppender" />
               </Appenders>
               <Loggers>
                 <Root level="info">
                   <AppenderRef ref="OpenTelemetryAppender" />
                   <AppenderRef ref="ConsoleAppender" />
                 </Root>
               </Loggers>
             </Configuration>
             ```

             <Callout variant="tip">
               A seção `packages=...` desta linha permite que o Log4J encontre e configure o `OpenTelemetryAppender`. O código-fonte está [no repositório OpenTelemetry](https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/instrumentation/log4j/log4j-appender-2.17/library) e foi adicionado como uma dependência via `io.opentelemetry.instrumentation:opentelemetry-log4j-appender-2.17`)
             </Callout>
        </Step>

        <Step>
          #### Instrumentação trace customizada: Criar constantes de atributo de span [#custom-attribs]

          Cada trace é composto por spans, que representam uma unidade lógica de trabalho ou uma operação dentro de uma solicitação específica. O código abaixo demonstra:

          * Constantes estáticas para armazenar chaves de atributo que podem ser usadas para fornecer insights em nível de solicitação em seus períodos
          * Como inicializar um [Tracer](https://opentelemetry.io/docs/concepts/signals/traces/#tracer), que cria spans

          Insira as seguintes linhas destacadas em `Controller.java`:

          ```java lineHighlight=4-14
          @RestController
          public class Controller {

              // Attribute constants
              private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
              private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");

              private final Tracer tracer;

              @Autowired
              Controller(OpenTelemetry openTelemetry) {
                  // Initialize tracer
                  tracer = openTelemetry.getTracer(Controller.class.getName());
              }

              @GetMapping(value = "/fibonacci")
              . . .
          }
          ```
        </Step>

        <Step>
          #### Instrumentação trace customizada: Crie um intervalo customizado [#cust-span]

          Você pode criar os spans que desejar e cabe a você anotar seus spans com atributos em operações específicas. O atributo definido fornecerá contexto adicional sobre a operação específica que você está acompanhando, como resultados ou propriedades da operação.

          1. Em `Controller.java`, insira essas linhas destacadas para iniciar um novo intervalo chamado `fibonacci` que faz o seguinte:

             * Captura dados sobre a execução deste método
             * Define um atributo que armazena o valor de n da solicitação do usuário

             ```java lineHighlight=2-3
             private long fibonacci(long n) {
                 // Start a new span and set your first attribute
                 var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();
                 . . .
             }
             ```

          2. Adicione detalhes granulares ao seu código adicionando um atributo ao seu intervalo para armazenar informações sobre solicitações bem-sucedidas:

             ```java lineHighlight=20-21
             private long fibonacci(long n) {
                 // Start a new span and set your first attribute
                 var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();

                 try {
                     if (n < 1 || n > 90) {
                         throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                     }

                     long result = 1;
                     if (n > 2) {
                     long a = 0;
                     long b = 1;

                     for (long i = 1; i < n; i++) {
                         result = a + b;
                         a = b;
                         b = result;
                     }
                     // Set a span attribute to capture information about successful requests
                     span.setAttribute(ATTR_RESULT, last);
                     return last;
                 } catch (IllegalArgumentException e) {
                     throw e;
                 }
             }
             ```
        </Step>

        <Step>
          #### Instrumentação trace customizada: Registrar uma exceção [#span-exception]

          Você pode querer registrar as exceções à medida que elas acontecem. Recomendamos que você faça isso em conjunto com a configuração do status do intervalo. Primeiro, defina seu intervalo como o intervalo atual, defina o código de status como erro no caso de uma exceção e, em seguida, encerre o intervalo:

          ```java lineHighlight=5-6,26-27,29-32
          private long fibonacci(long n) {
              // Start a new span and set your first attribute
              var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();

              // Set the span as the current span
              try (var scope = span.makeCurrent()) {
                  if (n < 1 || n > 90) {
                      throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                  }

                  long result = 1;
                  if (n > 2) {
                      long a = 0;
                      long b = 1;

                      for (long i = 1; i < n; i++) {
                          result = a + b;
                          a = b;
                          b = result;
                      }
                  }
                  // Set a span attribute to capture information about successful requests
                  span.setAttribute(ATTR_RESULT, result);
                  return result;
              } catch (IllegalArgumentException e) {
                  // Record the exception and set the span status
                  span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
                  throw e;
              } finally {
                  // End the span
                  span.end();
              }
          }
          ```

          Este método gera um `IllegalArgumentException` se um usuário fornecer uma entrada inválida. Quando isso acontece, a exceção é registrada como um evento no intervalo e o status do intervalo será definido como `ERROR`. A mensagem de exceção é capturada como a descrição do status. A exceção será registrada como um evento no intervalo onde ocorre.

          Por fim, em `handleException()` na classe `ErrorHandler` , defina o status do intervalo como `ERROR` com estas linhas destacadas:

          ```java lineHighlight=10-11
          @ControllerAdvice
          private static class ErrorHandler {

              @ExceptionHandler({
                  IllegalArgumentException.class,
                  MissingServletRequestParameterException.class,
                  HttpRequestMethodNotSupportedException.class
              })
              public ResponseEntity<Object> handleException(Exception e) {
                  // Set the span status and description
                  Span.current().setStatus(StatusCode.ERROR, e.getMessage());
                  return new ResponseEntity<>(Map.of("message", e.getMessage()), HttpStatus.BAD_REQUEST);
              }
          }
          ```

          Como na etapa anterior, isso define o código de status do intervalo se o usuário inserir um número inválido. No entanto, como isso acontece no manipulador de exceções, e não em `fibonacci()`, o intervalo atual é o intervalo pai da solicitação. Esse span pai vem da instrumentação Spring Web MVC adicionada por meio do filtro na classe aplicativo. Agora, quando o endpoint do seu aplicativo gerar uma exceção, tanto o span pai quanto o span filho terão um status de span de `ERROR`.
        </Step>

        <Step>
          #### Instrumentação métrica personalizada: Adicionar um contador de métrica personalizado [#metrics-cust]

          Métricas são um tipo de dados de telemetria realmente úteis porque combinam medições individuais em agregações e produzem dados constantes em função da carga do sistema. Você pode usar esses dados em conjunto com períodos para ajudar a identificar tendências e fornecer telemetria de tempo de execução do aplicativo. Você também pode anotar qualquer métrica com um atributo para ajudar a descrever qual subdivisão das medidas a métrica representa.

          A API OpenTelemetry métrica define uma série de instrumentos, que registram medidas que são agregadas pelo SDK métrica e exportadas fora do processo. Existem dois tipos de instrumento:

          * Síncrono: Este instrumento registra as medições à medida que ocorrem
          * Assíncrono: Este instrumento registra um retorno de chamada, que é invocado apenas uma vez por coleta e não possui contexto associado

          <Callout variant="tip">
            Se você tiver alguma dúvida sobre o status da métrica no projeto OpenTelemetry, consulte os [status do sinal](https://opentelemetry.io/docs/instrumentation/java/#status-and-releases).
          </Callout>

          Conclua o seguinte para adicionar um contador personalizado:

          1. Instancie um atributo booleano para sua métrica personalizada e inicialize um instrumento métrico. <Callout variant="tip">Nesse caso, estamos usando um [LongCounter](https://opentelemetry.io/docs/instrumentation/java/manual/#metrics), que registra apenas valores positivos e é útil para contar coisas, como o número de bytes enviados por uma rede. Por padrão, as medidas do contador são agregadas em somas monotônicas (sempre crescentes).</Callout>

             ```java lineHighlight=7,10,16-21
             @RestController
             public class Controller {

                 // Attribute constants
                 private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
                 private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");
                 private static final AttributeKey<Boolean> ATTR_VALID_N = AttributeKey.booleanKey("fibonacci.valid.n");

                 private final Tracer tracer;
                 private final LongCounter fibonacciInvocations;

                 @Autowired
                 Controller(OpenTelemetry openTelemetry) {
                     // Initialize tracer
                     tracer = openTelemetry.getTracer(Controller.class.getName());
                     // Initialize instrument
                     Meter meter = openTelemetry.getMeter(Controller.class.getName());
                     fibonacciInvocations = meter
                         .counterBuilder("fibonacci.invocations")
                         .setDescription("Measures the number of times the fibonacci method is invoked.")
                         .build();
                 }
                 . . .
             }
             ```

          2. Insira as seguintes linhas destacadas para que seu contador personalizado possa capturar entradas válidas e inválidas, bem como o número de vezes que cada uma ocorre.

             ```java lineHighlight=24-25,30-31
             private long fibonacci(long n) {
                 // Start a new span and set your first attribute
                 var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();

                 // Set the span as the current span
                 try (var scope = span.makeCurrent()) {
                     if (n < 1 || n > 90) {
                         throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                     }

                     long result = 1;
                     if (n > 2) {
                         long a = 0;
                         long b = 1;

                         for (long i = 1; i < n; i++) {
                             result = a + b;
                             a = b;
                             b = result;
                         }
                     }
                     // Set a span attribute to capture information about successful requests
                     span.setAttribute(ATTR_RESULT, result);
                     // Counter to increment the number of times a valid input is recorded
                     fibonacciInvocations.add(1, Attributes.of(ATTR_VALID_N, true));
                     return result;
                 } catch (IllegalArgumentException e) {
                     // Record the exception and set the span status
                     span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
                     // Counter to increment the number of times an invalid input is recorded
                     fibonacciInvocations.add(1, Attributes.of(ATTR_VALID_N, false));
                     throw e;
                 } finally {
                     // End the span
                     span.end();
                 }
             }
             ```
        </Step>

        <Step>
          #### Instrumentação de log customizada [#cust-log]

          O status do sinal de log no OpenTelemetry Java é atualmente [experimental](https://opentelemetry.io/docs/instrumentation/java/#status-and-releases). mensagem do log são gerenciados pelo manipulador raiz em seu aplicativo, que enviará log de nível `INFO` e superior para o console por padrão. No entanto, você pode modificar o comportamento do agente alterando o nível de log, inclusive para classes específicas, ou instalando um manipulador ou filtro customizado.

          ##### Inicialize o agente [#initialize-logger]

          Conforme afirmado anteriormente, isso é da biblioteca `java.util.logging` . O agente não é um componente do OpenTelemetry, mas o aplicativo foi configurado para enviar o Log4j para o SDK log do OpenTelemetry:

          ```java lineHighlight=4-5
          @RestController
          public class Controller {

              // Logger (note that this is not an OTel component)
              private static final Logger LOGGER = LogManager.getLogger(Controller.class);

              // Attribute constants
              private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
              private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");
              private static final AttributeKey<Boolean> ATTR_VALID_N = AttributeKey.booleanKey("fibonacci.valid.n");
              . . .
          }
          ```

          ##### Adicionar mensagem personalizada do log [#cust-log-messages]

          Depois de inicializar o agente, você poderá usá-lo para registrar:

          * O resultado de uma entrada válida, juntamente com o valor desse resultado
          * Quando nenhuma saída foi gravada

          Insira as seguintes linhas destacadas:

          ```java lineHighlight=26-27,34-35
          private long fibonacci(long n) {
              // Start a new span and set your first attribute
              var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();

              // Set the span as the current span
              try (var scope = span.makeCurrent()) {
                  if (n < 1 || n > 90) {
                      throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                  }

                  long result = 1;
                  if (n > 2) {
                      long a = 0;
                      long b = 1;

                      for (long i = 1; i < n; i++) {
                          result = a + b;
                          a = b;
                          b = result;
                      }
                  }
                  // Set a span attribute to capture information about successful requests
                  span.setAttribute(ATTR_RESULT, result);
                  // Counter to increment the number of times a valid input is recorded
                  fibonacciInvocations.add(1, Attributes.of(ATTR_VALID_N, true));
                  // Log the result of a valid input
                  LOGGER.info("Compute fibonacci(" + n + ") = " + result);
                  return result;
              } catch (IllegalArgumentException e) {
                  // Record the exception and set the span status
                  span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
                  // Counter to increment the number of times an invalid input is recorded
                  fibonacciInvocations.add(1, Attributes.of(ATTR_VALID_N, false));
                  // Log when no output was recorded
                  LOGGER.info("Failed to compute fibonacci(" + n + ")");
                  throw e;
              } finally {
                  // End the span
                  span.end();
              }
          }
          ```
        </Step>

        <Step>
          #### Exercite o aplicativo para gerar algum tráfego [#exercise-app]

          Você está pronto para enviar alguns dados para a New Relic!

          1. Vá para o diretório `getting-started-guides/java` e crie e execute o aplicativo com este comando:

             * Mac OS:

               ```bash
               ./gradlew bootRun
               ```

             * PowerShell:

               ```bash
               .\gradlew.bat build
               ```

               <Callout variant="tip">
                 Se o seu terminal exibir o Spring ASCII, significa que seu aplicativo foi compilado com sucesso e está em execução:

                 <img
                   alt="Screenshot showing Spring Boot ASCII logo"
                   title="Screenshot showing Spring Boot ASCII logo"
                   src={opentelemetrySpringBootASCIIDisplay}
                 />
               </Callout>

          2. Gere tráfego do aplicativo abrindo um novo terminal no diretório `getting-started-guides/java/Uninstrumented` e executando o gerador de carga:

             * Mac OS:

               ```bash
               ./load-generator.sh
               ```

             * PowerShell:

               ```bash
               .\load-generator.ps1
               ```

             <Callout variant="tip">
               Alternativamente, você pode acessar o endpoint no browser neste URL: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE`. Substitua `INSERT_A_VALUE` por um valor de 1 a 90. Para gerar um erro, insira um número inteiro fora do intervalo válido.
             </Callout>

          3. Agora que você enviou alguns dados para o New Relic, veja nossas [instruções sobre como visualizar os dados na interface](#view-data).
        </Step>
      </Steps>
    </TabsPageItem>
  </TabsPages>
</Tabs>

## Veja seus dados de demonstração no New Relic [#view-data]

Não importa qual tutorial você concluiu, você pode seguir as dicas abaixo para encontrar seus dados na interface do New Relic.

1. Vá para

   <DoNotTranslate>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > APM & services**</DoNotTranslate>

   .

2. Clique na sua nova entidade (serviço) chamada `getting-started-java` (ou qualquer nome que você forneceu).

3. Confira os detalhes nas seções de cada tipo de dados.

<Callout variant="tip">
  Se você estiver usando o Windows e não vir os dados em sua conta New Relic, verifique se permitiu o tráfego através do firewall.
</Callout>

### Traces [#traces]

Depois de chegar à entidade `getting-started-java` no New Relic:

1. Na seção

   <DoNotTranslate>**Monitor**</DoNotTranslate>

   do painel esquerdo, clique em

   <DoNotTranslate>**Distributed tracing**</DoNotTranslate>

   e depois clique no grupo trace

   <DoNotTranslate>**Fibonacci**</DoNotTranslate>

   .

   <img alt="Screenshot showing the main distributed tracing page" title="Screenshot showing the main distributed tracing page" src={opentelemetryMainDistributedTracingPage}/>

2. A partir daí, encontre um trace com erro e clique para abri-lo.

   <Callout variant="tip">Com o agente Java OpenTelemetry , você poderá ver resultados diferentes dos que veria com o agente Java New Relic APM . Isso ocorre porque há uma diferença no tratamento de erros entre os dois tipos de agentes. Para obter mais informações, consulte [Tratamento de taxa de erros no OpenTelemetry e New Relic](https://newrelic.com/blog/how-to-relic/error-rate-opentelemetry-and-new-relic).</Callout>

   <img alt="Screenshot showing an error in distributed tracing" title="Screenshot showing an error in distributed tracing" src={opentelemetryDistributedTracingError}/>

3. Depois de abrir o trace , clique em `Show in-process spans` e, em seguida, clique no intervalo resultante, o que abrirá um painel de detalhes à direita. Para ver a exceção que você registrou quando uma entrada do usuário é inválida, clique em `View span events`:

   <img title="Screenshot of in-process spans" alt="Screenshot of in-process spans" src={opentelemetryInProcessSpans}/>

Se você concluiu o tutorial de instrumentação manual, veja como será a aparência da exceção registrada como um intervalo no New Relic:

<img
  title="Screenshot showing an exception as a span event"
  alt="Screenshot showing an exception as a span event"
  src={opentelemetryExceptiononSpanEvent}
/>

Para visualizar detalhes adicionais definidos, como o atributo do intervalo, o nome do intervalo e o código de status, clique na guia <DoNotTranslate>**Attributes**</DoNotTranslate> . Este painel também é onde você pode visualizar metadados adicionais que são coletados automaticamente pela biblioteca de instrumentação usada neste guia, bem como metadados anexados pela New Relic:

<img
  title="Screenshot of the attributes tab"
  alt="Screenshot of the attributes tab"
  src={opentelemetryAttributesTab}
/>

Para obter mais detalhes sobre como visualizar seus dados, consulte [OpenTelemetry na interface do New Relic](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page)

### Métrica [#metrics]

Depois de chegar à entidade `getting-started-java` no New Relic, você poderá ver uma lista de todas as métricas coletadas, como métricas de tempo de execução (JVMs) e seu atributo de contador personalizado.

#### Explorador de métricas [#metrics-explorer]

Esta é uma ferramenta que permite ver uma lista das suas métricas.

1. No painel esquerdo, selecione <DoNotTranslate>**Data > Metrics explorer**</DoNotTranslate> e selecione `fibonacci.invocations`.

   <img
     title="Screenshot showing metrics explorer"
     alt="Screenshot showing metrics explorer"
     src={opentelemetryMetricsExplorerMain}
   />

2. Em <DoNotTranslate>**Dimensions**</DoNotTranslate>, visualize o atributo que você coletou junto com sua métrica personalizada e clique em <DoNotTranslate>**fibonacci.valid.n**</DoNotTranslate>.

   <img
     title="Screenshot showing the total number of invocations of fibonacci function"
     alt="Screenshot showing the total number of invocations of fibonacci function"
     src={opentelemetryMetricsExplorerDimensions}
   />

Saiba mais em nossa documentação sobre a [visualização do explorador métrico](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-metrics-explorer-page).

#### JVMs [#jvms]

Você também pode visualizar visualizações de suas métricas de tempo de execução Java, incluindo taxas de transferência, uso de memória e tempo de coleta de lixo por minuto, acessando a página da JVM:

<img
  title="Screenshot of the main JVMs page"
  alt="Screenshot of the main JVMs page"
  src={opentelemetryJvmsPageMain}
/>

Você pode visualizar a métrica para uma única instância ou selecionar múltiplas instâncias para compará-las:

<img
  title="Screenshot of how to compare JVM instances"
  alt="Screenshot of how to compare JVM instances"
  src={opentelemetryCompareJvmInstances}
/>

Aqui está o que você verá após selecionar suas instâncias e clicar em <DoNotTranslate>**Compare**</DoNotTranslate>, onde cada instância é codificada por cores para facilitar a identificação:

<img
  title="Screenshot showing the color-coded JVM comparison"
  alt="Screenshot showing the color-coded JVM comparison"
  src={opentelemetryJvmColorCodedComparison}
/>

Para saber mais, consulte nossa documentação sobre a [visualização de JVMs](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-jvms-page/).

### Registro [#logs]

Aqui é onde acessar seu log:

<img
  title="Screenshot showing the main logs page"
  alt="Screenshot showing the main logs page"
  src={opentelemetryMainLogsPage}
/>

Você também verá o login em seu terminal:

<img
  title="Screenshot showing logs in a terminal"
  alt="Screenshot showing logs in a terminal"
  src={opentelemetryLogsinTerminal}
/>

De volta à sua visualização de logs, selecione um log e você verá um painel aberto com a mensagem do log e atributos adicionais que foram coletados, como os span e trace ids associados, bem como os metadados injetados pelo New Relic:

<img
  title="Screenshot showing log details with trace"
  alt="Screenshot showing log details with trace"
  src={opentelemetryLogDetailsWithTrace}
/>

Você pode navegar até o distributed trace correlacionado clicando neste pequeno ícone azul:

<img
  title="Screenshot showing how to find correlated trace"
  alt="Screenshot showing how to find correlated trace"
  src={opentelemetryTraceRelatedtoLog}
/>

Isso abrirá um painel que exibe o trace correlacionado, onde você poderá visualizar mais detalhes sobre o trace. Para obter mais informações sobre esta página, consulte [OpenTelemetry na interface: página distributed tracing ](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page/)e [Compreenda e use a interface distributed tracing ](/docs/distributed-tracing/ui-data/understand-use-distributed-tracing-ui/):

<img
  title="Screenshot showing the trace waterfall from the logs section"
  alt="Screenshot showing the trace waterfall from the logs section"
  src={opentelemetryTraceWaterfallFromLog}
/>

Você também pode localizar o log correlacionado na visualização de rastreio distribuído. Ao selecionar um trace que possui um log correspondente, você o verá indicado como uma guia e poderá visualizar o log diretamente do trace sem precisar alternar as visualizações:

<img
  title="Screenshot showing how to see log details from a trace span"
  alt="Screenshot showing how to see log details from a trace span"
  src={opentelemetryLogCapturedinTraceSpan}
/>

Saiba mais sobre a visualização de log [aqui](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-logs-page).

## Referência: Variáveis de ambiente [#ref-env-vars]

Esta é uma lista de variáveis de ambiente que você deve exportar se estiver fazendo o tutorial 2 ou 3. Após terminar de exportar as variáveis, retorne aos tutoriais usando os links que seguem a lista de variáveis:

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="env-vars-table"
    title="Clique aqui para abrir a lista de variáveis de ambiente"
  >
    <table>
      <tbody>
        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_HEADERS=api-key=YOUR_LICENSE_KEY`

            * Cabeçalhos: determina para qual conta New Relic seus dados serão enviados. Substitua `YOUR_LICENSE_KEY` pelo seu

              <InlinePopover type="licenseKey"/>

              .
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.nr-data.net` (Para os EUA) `OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.eu01.nr-data.net` (Para a UE)

            * Este é o endpoint para o qual a telemetria do seu aplicativo será exportada. Exporte dados para o endpoint OTLP da New Relic.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_PROTOCOL=http/protobuf`

            * Especifica que OTLP `http/protobuf` deve ser usado, o que é preferido pela New Relic.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_SERVICE_NAME=getting-started-java`

            * Este é o nome que associa a telemetria do seu aplicativo a uma entidade no New Relic. Neste tutorial vamos chamá-lo de `getting-started-java`, mas você pode chamá-lo do que quiser.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_RESOURCE_ATTRIBUTES=service.instance.id=INSERT_YOUR_OWN_ID_HERE`

            * Substitua `INSERT_YOUR_OWN_ID_HERE` por um ID de instância exclusivo. Por exemplo, você poderia usar `1234`. Para obter mais detalhes, consulte [Convenções semânticas de recursos](https://github.com/open-telemetry/semantic-conventions/blob/main/docs/resource/README.md#service-experimental) do OpenTelemetry.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT=4095`

            * Definir um limite para o comprimento máximo do valor do atributo impedirá que os dados do intervalo sejam descartados se excederem o [limite do New Relic](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/best-practices/opentelemetry-best-practices-attributes/).
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE=DELTA`

            * A New Relic suporta métrica na temporalidade delta em vez do padrão cumulativo.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_METRICS_DEFAULT_HISTOGRAM_AGGREGATION=BASE2_EXPONENTIAL_BUCKET_HISTOGRAM`

            * Agregação de histograma (recomendada): use o histograma exponencial em vez do histograma de intervalo explícito padrão para melhor compactação de dados.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_LOGS_EXPORTER=otlp`

            * Habilite a exportação de log por OTLP. A exportação de log está desabilitada por padrão.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_COMPRESSION=gzip`

            * (Recomendado) Definir a compactação gzip permite maximizar a quantidade de dados que você pode enviar por solicitação. Nosso tamanho máximo de carga útil permitido é 1 MB (10 ^ 6 bytes). A compactação Gzip tem bom desempenho e reduz a saída de dados.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPERIMENTAL_EXPORTER_OTLP_RETRY_ENABLED=true`

            * (Recomendado) Ative a nova tentativa de exportação experimental para ajudar a lidar com a falta de confiabilidade da Internet.
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPERIMENTAL_RESOURCE_DISABLED_KEYS=process.command_line`

            * (Recomendado) Isso desativa o atributo de recurso `process.command_line` , que geralmente excede o limite máximo de comprimento do atributo New Relic e pode conter informações confidenciais.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

Depois de criar as variáveis de ambiente listadas no recolhido acima, retorne ao tutorial e conclua a configuração:

* [Tutorial 2 (monitor o aplicativo de demonstração com o agente OpenTelemetry Java)](#java-agent)
* [Tutorial 3 (Configurar o aplicativo de demonstração manualmente)](#auto-config-ext)

## Qual é o próximo? [#what-next]

Agora que você experimentou a instrumentação do OpenTelemetry e a configuração do SDK, você pode aplicar o que aprendeu para configurar seu próprio aplicativo ou serviço com o OpenTelemetry e o New Relic. Para saber mais, consulte [Configurar seu próprio aplicativo ou serviço com OpenTelemetry](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/get-started/opentelemetry-set-up-your-app).