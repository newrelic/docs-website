---
title: Processador de transformação
metaDescription: 'Use the transform processor to modify, enrich, and parse telemetry data using OTTL (OpenTelemetry Transformation Language).'
freshnessValidatedDate: never
translationType: machine
---

O processador de transformação modifica, enriquece ou analisa dados de telemetria usando a OTTL (OpenTelemetry Transformation Language). Utilize-o para adicionar contexto, normalizar esquemas, analisar dados não estruturados ou ofuscar informações sensíveis antes que os dados saiam da sua rede.

## Quando usar o processador transform

Use o processador de transformação quando você precisar:

* **Enriqueça a telemetria com metadados organizacionais**: Adicione tags de ambiente, região, equipe ou centro de custo
* **Analise mensagens de log não estruturadas**: Extraia atributos estruturados usando regex, padrões Grok ou análise de JSON
* **Normalize nomes de atributos e esquemas de valores**: Padronize diferentes convenções de nomenclatura em serviços ou agentes (`level` → `severity.text`, `env` → `environment`)
* **Gere hash ou oculte dados sensíveis**: Remova PII, credenciais ou outras informações sensíveis antes que saiam da sua rede
* **Extrair valores de strings**: Obtenha códigos de status HTTP, durações ou outros dados de mensagens de log
* **Agregar ou escalar métricas**: Modifique valores de métricas ou combine múltiplas métricas

## Contextos OTTL

A OTTL opera em diferentes contextos dependendo do tipo de telemetria:

* **Logs**: contexto `log` - corpo do log de acesso, atributos, gravidade
* **Traces**: contexto de `trace` - acesse atributos de span, duração, status
* **Métricas**: contextos `metric` e `datapoint` - acesse o nome da métrica, valor, atributos

## Configuração

Adicione um processador de transformação ao seu pipeline:

```yaml
transform/Logs:
  description: Transform and process logs
  config:
    log_statements:
      - context: log
        name: add new field to attribute
        description: for otlp-test-service application add otlp source type field
        conditions:
          - resource.attributes["service.name"] == "otlp-java-test-service"
        statements:
          - set(resource.attributes["source.type"],"otlp")
```

**Campos de configuração**:

* `log_statements`: Array de instruções OTTL para transformações de log (contexto: log)
* `metric_statements`: Array de instruções OTTL para transformações de métricas (contexto: métrica)
* `trace_statements`: Array de instruções OTTL para transformações de rastreamento (contexto: rastreamento)

/\* - \`conditions\`: Array de condições OTTL booleanas que determinam se as instruções são avaliadas \*/

## Principais funções OTTL

### set()

Define um valor de atributo.

```yaml
- set(attributes["environment"], "production")
- set(attributes["team"], "platform")
- set(severity.text, "ERROR") where severity.number >= 17
```

### delete\_key()

Remove um atributo.

```yaml
- delete_key(attributes, "internal_debug_info")
- delete_key(attributes, "temp_field")
```

### replace\_pattern()

Substitui texto que corresponde a um padrão regex.

```yaml
  # Redact email addresses
- replace_pattern(attributes["user_email"], "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}", "[REDACTED_EMAIL]")

  # Mask passwords
- replace_pattern(attributes["password"], ".+", "password=***REDACTED***")

  # Obfuscate all non-whitespace (extreme)
- replace_pattern(body, "[^\\s]*(\\s?)", "****")
```

### Hash()

Gera um hash de um valor para pseudonimização.

```yaml
- set(attributes["user_id_hash"], Hash(attributes["user_id"]))
- delete_key(attributes, "user_id")
```

### ParseJSON()

Extrai atributos de strings JSON.

```yaml
  # Parse JSON body into attributes
- merge_maps(attributes, ParseJSON(body), "upsert") where IsString(body)
```

### ExtractGrokPatterns()

Analisa dados estruturados usando padrões Grok.

```yaml
  # Parse JSON log format
- ExtractGrokPatterns(body, "\\{\"timestamp\":\\s*\"%{TIMESTAMP_ISO8601:extracted_timestamp}\",\\s*\"level\":\\s*\"%{WORD:extracted_level}\",\\s*\"message\":\\s*\"Elapsed time:\\s*%{NUMBER:elapsed_time}ms\"\\}")

  # Parse custom format with custom pattern
- ExtractGrokPatterns(attributes["custom_field"], "%{USERNAME:user.name}:%{PASSWORD:user.password}", true, ["PASSWORD=%{GREEDYDATA}"])
```

### flatten()

Achata atributos de mapa aninhados.

```yaml
  # Flatten nested map to top-level attributes
- flatten(attributes["map.attribute"])
```

### limit()

Limita o número de atributos, mantendo as chaves de prioridade especificadas.

```yaml
  # Keep only 3 attributes, prioritizing "array.attribute"
- limit(attributes, 3, ["array.attribute"])
```

## Exemplos completos

### Exemplo 1: Adicionar metadados do ambiente

```yaml
transform/Logs:
  description: "Enrich logs with environment context"
  config:
    log_statements:
      - context: log
        name: enrich-with-environment-metadata
        description: Add environment, region, team, and cost center metadata to all logs
        statements:
          - set(attributes["environment"], "production")
          - set(attributes["region"], "us-east-1")
          - set(attributes["team"], "platform-engineering")
          - set(attributes["cost_center"], "eng-infra")
```

### Exemplo 2: Normalizar níveis de severidade

Diferentes serviços usam diferentes convenções de gravidade. Padronize-os:

```yaml
transform/Logs:
  description: "Normalize severity naming"
  config:
    log_statements:
      - context: log
        name: convert-level-to-severity
        description: Convert custom level attribute to severity_text
        conditions:
          - attributes["level"] != nil
        statements:
          - set(severity_text, attributes["level"])
      
      - context: log
        name: delete-level-attribute
        description: Remove the redundant level attribute after conversion
        statements:
          - delete_key(attributes, "level")
      
      - context: log
        name: normalize-error-case
        description: Normalize error severity to uppercase ERROR
        conditions:
          - severity_text == "error"
        statements:
          - set(severity_text, "ERROR")
      
      - context: log
        name: normalize-warning-case
        description: Normalize warning severity to uppercase WARN
        conditions:
          - severity_text == "warning"
        statements:
          - set(severity_text, "WARN")
      
      - context: log
        name: normalize-info-case
        description: Normalize info severity to uppercase INFO
        conditions:
          - severity_text == "info"
        statements:
          - set(severity_text, "INFO")
```

### Exemplo 3: Analisar corpos de log JSON

Extraia atributos estruturados de mensagens de log formatadas em JSON:

```yaml
transform/Logs:
  description: "Parse JSON logs into attributes"
  config:
    log_statements:
      - context: log
        name: parse-json-body-to-attributes
        description: Parse JSON log body and merge into attributes
        conditions:
          - IsString(body)
        statements:
          - merge_maps(attributes, ParseJSON(body), "upsert")
```

**Antes**: `body = '{"timestamp": "2025-03-01T12:12:14Z", "level":"INFO", "message":"Elapsed time: 10ms"}'`

**Depois**: Atributos extraídos: `timestamp`, `level`, `message`

### Exemplo 4: Extrair códigos de status HTTP

Extraia códigos de status de mensagens de log:

```yaml
transform/Logs:
  description: "Extract HTTP status from message"
  config:
    log_statements:
      - context: log
        name: extract-http-status-code
        description: Extract HTTP status code from log body using regex pattern
        statements:
          - ExtractPatterns(body, "status=(\\d+)")
          - set(attributes["http.status_code"], body)
```

### Exemplo 5: Ocultar PII

Remova informações sensíveis antes que os dados saiam da sua rede:

```yaml
transform/Logs:
  description: "Redact PII for compliance"
  config:
    log_statements:
      - context: log
        name: redact-email-addresses
        description: Redact email addresses from user_email attribute
        conditions:
          - attributes["user_email"] != nil
        statements:
          - replace_pattern(attributes["user_email"], "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}", "[REDACTED_EMAIL]")
      
      - context: log
        name: mask-passwords
        description: Mask password attribute values
        conditions:
          - attributes["password"] != nil
        statements:
          - replace_pattern(attributes["password"], ".+", "***REDACTED***")
      
      - context: log
        name: hash-user-ids
        description: Hash user IDs and remove original value
        conditions:
          - attributes["user_id"] != nil
        statements:
          - set(attributes["user_id_hash"], SHA256(attributes["user_id"]))
          - delete_key(attributes, "user_id")
      
      - context: log
        name: mask-credit-cards-in-body
        description: Mask credit card numbers in log body
        statements:
          - replace_pattern(body, "\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}", "****-****-****-****")
```

### Exemplo 6: Analisar logs de acesso do NGINX

Extraia campos estruturados do formato de log combinado do NGINX:

```yaml
transform/Logs:
  description: "Parse and enrich NGINX access logs"
  config:
    log_statements:
      - context: log
        name: extract-nginx-fields
        description: Parse NGINX access log format into structured attributes
        statements:
          - ExtractGrokPatterns(body, "%{IPORHOST:client.ip} - %{USER:client.user} \\[%{HTTPDATE:timestamp}\\] \"%{WORD:http.method} %{URIPATHPARAM:http.path} HTTP/%{NUMBER:http.version}\" %{NUMBER:http.status_code} %{NUMBER:http.response_size}")
      
      - context: log
        name: set-severity-for-server-errors
        description: Set severity to ERROR for 5xx server errors
        conditions:
          - attributes["http.status_code"] >= "500"
        statements:
          - set(severity_text, "ERROR")
      
      - context: log
        name: set-severity-for-client-errors
        description: Set severity to WARN for 4xx client errors
        conditions:
          - attributes["http.status_code"] >= "400"
          - attributes["http.status_code"] < "500"
        statements:
          - set(severity_text, "WARN")
      
      - context: log
        name: set-severity-for-success
        description: Set severity to INFO for successful requests
        conditions:
          - attributes["http.status_code"] >= "200"
          - attributes["http.status_code"] < "400"
        statements:
          - set(severity_text, "INFO")
```

### Exemplo 7: Linearizar atributos aninhados

Converter estruturas aninhadas em atributos planos:

```yaml
transform/Logs:
  description: "Flatten nested map attributes"
  config:
    log_statements:
      - context: log
        name: flatten-kubernetes-attributes
        description: Flatten nested kubernetes attributes into dot notation
        conditions:
          - attributes["kubernetes"] != nil
        statements:
          - flatten(attributes["kubernetes"])
      
      - context: log
        name: flatten-cloud-provider-attributes
        description: Flatten nested cloud provider attributes into dot notation
        conditions:
          - attributes["cloud.provider"] != nil
        statements:
          - flatten(attributes["cloud.provider"])
```

**Antes**: `attributes["kubernetes"] = {"pod": {"name": "my-app-123", "uid": "abc-xyz"},"namespace": {"name": "production"}}`

**Depois**: Atributos achatados: `kubernetes.pod.name`, `kubernetes.pod.uid`, `kubernetes.namespace.name`

### Exemplo 8: Transformações condicionais

Aplique transformações somente quando as condições forem atendidas:

```yaml
transform/Logs:
  description: "Conditional enrichment"
  config:
    log_statements:
      - context: log
        name: tag-critical-services
        description: Add business criticality tag for checkout and payment services
        conditions:
          - resource.attributes["service.name"] == "checkout" or resource.attributes["service.name"] == "payment"
        statements:
          - set(attributes["business_criticality"], "HIGH")
      
      - context: log
        name: normalize-production-environment
        description: Normalize production environment names to standard format
        conditions:
          - attributes["env"] == "prod" or attributes["environment"] == "prd"
        statements:
          - set(attributes["deployment.environment"], "production")
      
      - context: log
        name: normalize-staging-environment
        description: Normalize staging environment names to standard format
        conditions:
          - attributes["env"] == "stg" or attributes["environment"] == "stage"
        statements:
          - set(attributes["deployment.environment"], "staging")
      
      - context: log
        name: cleanup-legacy-env-fields
        description: Remove old environment attribute fields after normalization
        statements:
          - delete_key(attributes, "env")
          - delete_key(attributes, "environment")
```

### Exemplo 9: Conversão de tipo de dados

Converta atributos para tipos diferentes:

```yaml
transform/Logs:
  description: "Convert data types"
  config:
    log_statements:
      - context: log
        name: convert-error-flag-to-boolean
        description: Convert string error_flag to boolean is_error attribute
        conditions:
          - attributes["error_flag"] != nil
        statements:
          - set(attributes["is_error"], Bool(attributes["error_flag"]))
      
      - context: log
        name: set-success-boolean
        description: Set success attribute to boolean true
        statements:
          - set(attributes["success"], Bool("true"))
      
      - context: log
        name: convert-retry-count-to-int
        description: Convert retry_count_string to integer retry_count
        conditions:
          - attributes["retry_count_string"] != nil
        statements:
          - set(attributes["retry_count"], Int(attributes["retry_count_string"]))
```

### Exemplo 10: Limitar a cardinalidade

Reduza a cardinalidade de atributos para gerenciar custos:

```yaml
transform/Logs:
  description: "Limit high-cardinality attributes"
  config:
    log_statements:
      - context: log
        name: limit-attribute-cardinality
        description: Keep only the 5 most important attributes
        statements:
          - limit(attributes, 5, ["service.name", "environment", "severity_text"])
      
      - context: log
        name: generalize-user-api-paths
        description: Replace user ID in path with wildcard to reduce cardinality
        conditions:
          - IsMatch(attributes["http.path"], "/api/users/\\d+")
        statements:
          - set(attributes["http.path"], "/api/users/*")
```

## Referência de funções OTTL

Para a lista completa de funções, operadores e sintaxe da OTTL:

* [Referência de funções OTTL](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/pkg/ottl/ottlfuncs/README.md)
* [Documentação do processador de transformação](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/transformprocessor)

## Próximos passos

* Saiba mais sobre o [processador de filtro](/docs/new-relic-control/pipeline-control/gateway/filter-processor) para descartar dados indesejados
* Consulte [Processador de amostragem](/docs/new-relic-control/pipeline-control/gateway/sampling-processor) para redução de volume
* Consulte a [referência de configuração YAML](/docs/new-relic-control/pipeline-control/gateway/yaml-overview) para a sintaxe completa