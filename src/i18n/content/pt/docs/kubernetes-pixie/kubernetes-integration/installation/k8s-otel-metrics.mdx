---
title: Mapeamento métrico New Relic OTel K8s
tags:
  - Kubernetes integration
  - OpenTelemetry
metaDescription: Learn how to monitor your Kubernetes Cluster using OpenTelemetry
freshnessValidatedDate: never
translationType: machine
---

<Callout title="visualização">
  Ainda estamos trabalhando nesse recurso, mas adoraríamos que você experimentasse!

  Atualmente, esse recurso é fornecido como parte de um programa de visualização de acordo com nossas [políticas de pré-lançamento](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy).
</Callout>

As métricas Kubernetes OpenTelemetry são coletadas pelo OpenTelemetry Collector e enviadas ao New Relic usando a integração do New Relic Kubernetes .

Este documento fornece um mapeamento da métrica Kubernetes OpenTelemetry para a métrica New Relic Kubernetes . Este mapeamento ajuda você a entender a métrica e o atributo que estão disponíveis para monitorar seu cluster do Kubernetes.

<CollapserGroup>
  <Collapser id="for-api-server" title="Para servidor de API">
    A tabela a seguir mapeia Kubernetes OpenTelemetry métrica para o New Relic Kubernetes métrica. Essas métricas são originadas do `API server` configurado com o `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nome do evento New Relic
          </th>

          <th>
            Tipo: Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `apiserver_storage_objects`
          </td>

          <td>
            `apiserverStorageObjects_resource_RESOURCE-KIND`
          </td>

          <td>
            `K8sApiServerSample`
          </td>

          <td>
            **Medida:**

             Número de objetos armazenados no servidor API .
          </td>
        </tr>

        <tr>
          <td>
            `go_goroutines`
          </td>

          <td>
            `goGoroutines`
          </td>

          <td>
            `K8sApiServerSample`
          </td>

          <td>
            **Medida:**

             Número de 

            `goroutines`

             que existem atualmente.
          </td>
        </tr>

        <tr>
          <td>
            `go_threads`
          </td>

          <td>
            `goThreads`
          </td>

          <td>
            `K8sApiServerSample`

            , 

            `K8sControllerManagerSample`

            , 

            `K8sEtcdSample`

            , 

            `K8sSchedulerSample`
          </td>

          <td>
            **Medida:**

             Número de threads do SO criados.
          </td>
        </tr>

        <tr>
          <td>
            `process_resident_memory_bytes`
          </td>

          <td>
            `processResidentMemoryBytes`
          </td>

          <td>
            `K8sApiServerSample`
          </td>

          <td>
            **Medida:**

             Tamanho da memória residente em bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-cAdvisor" title="Para cAdvisor">
    A tabela a seguir mapeia Kubernetes OpenTelemetry métrica para o New Relic Kubernetes métrica. Essas métricas são originadas do `cAdvisor` configurado com o `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nome do evento New Relic
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `container_cpu_cfs_periods_total`
          </td>

          <td>
            `containerCpuCfsPeriodsTotal`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Contador:**

             Número total de intervalos de período de execução decorridos.
          </td>
        </tr>

        <tr>
          <td>
            `container_cpu_cfs_throttled_periods_total`
          </td>

          <td>
            `containerCpuCfsThrottledPeriodsTotal`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Contador:**

             Número total de intervalos de período limitados.
          </td>
        </tr>

        <tr>
          <td>
            `container_cpu_usage_seconds_total`
          </td>

          <td>
            `cpuUsedCores`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Contador:**

             Tempo total de CPU consumido.
          </td>
        </tr>

        <tr>
          <td>
            `container_memory_working_set_bytes`
          </td>

          <td>
            `memoryWorkingSetBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             Tamanho do conjunto de trabalho da memória em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `container_network_receive_bytes_total`
          </td>

          <td>
            `net.rxBytesPerSecond`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Contador:**

             Contagem cumulativa de bytes recebidos.
          </td>
        </tr>

        <tr>
          <td>
            `container_network_receive_errors_total`
          </td>

          <td>
            `net.txBytesPerSecond`
          </td>

          <td>
            `memoryRequestedBytes`
          </td>

          <td>
            **Contador:**

             Contagem cumulativa de erros de recebimento encontrados.
          </td>
        </tr>

        <tr>
          <td>
            `container_network_transmit_bytes_total`
          </td>

          <td>
            `net.errorsPerSecond`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Contador:**

             Contagem cumulativa de bytes transmitidos.
          </td>
        </tr>

        <tr>
          <td>
            `container_network_transmit_errors_total`
          </td>

          <td>
            `net.errorsPerSecond`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Contador:**

             Contagem cumulativa de erros de transmissão encontrados.
          </td>
        </tr>

        <tr>
          <td>
            `container_spec_memory_limit_bytes`
          </td>

          <td>
            `memoryLimitBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             limite de memória do contêiner em bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-controller-manager" title="Para gerente de controlador">
    A tabela a seguir mapeia Kubernetes OpenTelemetry métrica para o New Relic Kubernetes métrica. Essas métricas são originadas do `controller manager` configurado com o `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nome do evento New Relic
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `go_goroutines`
          </td>

          <td>
            `goGoroutines`
          </td>

          <td>
            `K8sControllerManagerSample`
          </td>

          <td>
            **Medida:**

             Número de 

            `goroutines`

             que existem atualmente.
          </td>
        </tr>

        <tr>
          <td>
            `process_resident_memory_bytes`
          </td>

          <td>
            `processResidentMemoryBytes`
          </td>

          <td>
            `K8sControllerManagerSample`
          </td>

          <td>
            **Medida:**

             Tamanho da memória residente em bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-kubelet" title="Para kubelet">
    A tabela a seguir mapeia Kubernetes OpenTelemetry métrica para o New Relic Kubernetes métrica. Essas métricas são originadas do `kubelet` configurado com o `KubeletStats Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "150px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nome do evento New Relic
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `container.cpu.utilization`
          </td>

          <td>
            `cpuCoresUtilization`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             percentual de utilização da CPU do contêiner.
          </td>
        </tr>

        <tr>
          <td>
            `container.filesystem.capacity`
          </td>

          <td>
            `fsCapacityBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             Capacidade total do sistema de arquivos do contêiner.
          </td>
        </tr>

        <tr>
          <td>
            `container.filesystem.usage`
          </td>

          <td>
            `fsUsedBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             Espaço de sistema de arquivos utilizado para o contêiner.
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.usage`
          </td>

          <td>
            `memoryUsedBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             Total de utilização de memória do contêiner.
          </td>
        </tr>

        <tr>
          <td>
            `go_goroutines`
          </td>

          <td>
            `goGoroutines`
          </td>

          <td>
            `K8sEtcdSample`
          </td>

          <td>
            **Medida:**

             Número de 

            `goroutines`

             que existem atualmente.
          </td>
        </tr>

        <tr>
          <td>
            `go_threads`
          </td>

          <td>
            `goThreads`
          </td>

          <td>
            `K8sApiServerSample`

            , 

            `K8sControllerManagerSample`

            , 

            `K8sEtcdSample`

            , 

            `K8sSchedulerSample`
          </td>

          <td>
            **Medida:**

             Número de threads do SO criados.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.cpu.time`
          </td>

          <td>
            `cpuUsedCoreMilliseconds`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Medida:**

             Tempo total de CPU usado pelo nó.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.cpu.utilization`
          </td>

          <td>
            `allocatableCpuCoresUtilization`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Medida:**

             Porcentagem de utilização da CPU do nó.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.filesystem.capacity`
          </td>

          <td>
            `fsCapacityBytes`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Medida:**

             Capacidade total do sistema de arquivos para o nó.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.filesystem.usage`
          </td>

          <td>
            `fsUsedBytes`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Medida:**

             Espaço de sistema de arquivos usado para o nó.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.memory.available`
          </td>

          <td>
            `memoryAvailableBytes`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Medida:**

             Memória disponível para o nó.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.node.memory.working_set`
          </td>

          <td>
            `memoryWorkingSetBytes`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Medida:**

             Tamanho do conjunto de trabalho do nó memória.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.pod.filesystem.available`
          </td>

          <td>
            `fsAvailableBytes`
          </td>

          <td>
            `K8sVolumeSample`
          </td>

          <td>
            **Medida:**

             Espaço disponível no sistema de arquivos para o pod.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.pod.filesystem.capacity`
          </td>

          <td>
            `fsCapacityBytes`
          </td>

          <td>
            `K8sVolumeSample`
          </td>

          <td>
            **Medida:**

             Capacidade total do sistema de arquivos para o pod.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.pod.filesystem.usage`
          </td>

          <td>
            `fsUsedBytes`
          </td>

          <td>
            `K8sVolumeSample`
          </td>

          <td>
            **Medida:**

             Espaço de sistema de arquivos usado para o pod.
          </td>
        </tr>

        <tr>
          <td>
            `k8s.pod.memory.working_set`
          </td>

          <td>
            `memoryWorkingSetBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             Tamanho do conjunto de trabalho do pod memória.
          </td>
        </tr>
      </tbody>
    </table>

    A tabela a seguir mapeia Kubernetes OpenTelemetry métrica para o New Relic Kubernetes métrica. Essas métricas são originadas do `kubelet` configurado com o `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nome do evento New Relic
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `process_resident_memory_bytes`
          </td>

          <td>
            `processResidentMemoryBytes`
          </td>

          <td>
            `K8sApiServerSample`
          </td>

          <td>
            **Medida:**

             Tamanho da memória residente em bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-kube-state-metrics" title="Para estado de cubo métrico">
    A tabela a seguir mapeia Kubernetes OpenTelemetry métrica para o New Relic Kubernetes métrica. Essas métricas são originadas do `kubeStateMetrics` configurado com o `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nome do evento New Relic
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `kube_cronjob_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sCronjobSample`
          </td>

          <td>
            **Medida:**

             timestamp de criação do CronJob.
          </td>
        </tr>

        <tr>
          <td>
            `kube_cronjob_spec_suspend`
          </td>

          <td>
            `isSuspended`
          </td>

          <td>
            `K8sCronjobSample`
          </td>

          <td>
            **Medida:**

             Suspender sinalizador do CronJob.
          </td>
        </tr>

        <tr>
          <td>
            `kube_cronjob_status_active`
          </td>

          <td>
            `isActive`
          </td>

          <td>
            `K8sCronjobSample`
          </td>

          <td>
            **Medida:**

             Número de instâncias CronJob ativas.
          </td>
        </tr>

        <tr>
          <td>
            `kube_cronjob_status_last_schedule_time`
          </td>

          <td>
            `lastScheduledTime`
          </td>

          <td>
            `K8sCronjobSample`
          </td>

          <td>
            **Medida:**

             Último horário de agendamento do CronJob.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Medida:**

             timestamp de criação do DaemonSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_desired_number_scheduled`
          </td>

          <td>
            `podsScheduled`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Medida:**

             Número desejado de instâncias agendadas do DaemonSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_number_misscheduled`
          </td>

          <td>
            `podsMisscheduled`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Medida:**

             Número de instâncias DaemonSet mal programadas.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_number_ready`
          </td>

          <td>
            `podsReady`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Medida:**

             Número de instâncias DaemonSet prontas.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_number_unavailable`
          </td>

          <td>
            `podsUnavailable`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Medida:**

             Número de instâncias DaemonSet indisponíveis.
          </td>
        </tr>

        <tr>
          <td>
            `kube_daemonset_status_updated_number_scheduled`
          </td>

          <td>
            `podsUpdatedScheduled`
          </td>

          <td>
            `K8sDaemonsetSample`
          </td>

          <td>
            **Medida:**

             Número atualizado de instâncias agendadas do DaemonSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Medida:**

             timestamp de criação da implantação.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_metadata_generation`
          </td>

          <td>
            `metadataGeneration`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Medida:**

             Número de geração da implantação metadados.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_spec_replicas`
          </td>

          <td>
            `podsDesired`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Medida:**

             Quantidade de réplicas desejadas para a implantação.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_spec_strategy_rollingupdate_max_surge`
          </td>

          <td>
            `rollingUpdateMaxPodsSurge`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Medida:**

             pico máximo permitido durante atualização contínua.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_condition`
          </td>

          <td>
            `conditionAvailable`

            , 

            `conditionProgressing`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Medida:**

             condições de situação de implantação.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_observed_generation`
          </td>

          <td>
            `observedGeneration`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Medida:**

             A geração mais recente observada para esta implantação.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas`
          </td>

          <td>
            `podsTotal`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Medida:**

             Quantidade de réplicas da implantação.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas_available`
          </td>

          <td>
            `podsAvailable`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Medida:**

             Número de réplicas disponíveis para a implantação.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas_ready`
          </td>

          <td>
            `podsReady`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Medida:**

             Quantidade de réplicas prontas para implantação.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas_unavailable`
          </td>

          <td>
            `podsUnavailable`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Medida:**

             Número de réplicas indisponíveis para a implantação.
          </td>
        </tr>

        <tr>
          <td>
            `kube_deployment_status_replicas_updated`
          </td>

          <td>
            `podsUpdated`
          </td>

          <td>
            `K8sDeploymentSample`
          </td>

          <td>
            **Medida:**

             Quantidade de réplicas atualizadas da implantação.
          </td>
        </tr>

        <tr>
          <td>
            `kube_horizontalpodautoscaler_spec_min_replicas`
          </td>

          <td>
            `minReplicas`
          </td>

          <td>
            `K8sHpaSample`
          </td>

          <td>
            **Medida:**

             Número mínimo de réplicas para o HorizontalPodAutoscaler.
          </td>
        </tr>

        <tr>
          <td>
            `kube_horizontalpodautoscaler_status_condition`
          </td>

          <td>
            `isActive`
          </td>

          <td>
            `K8sHpaSample`
          </td>

          <td>
            **Medida:**

             Condições de status do HorizontalPodAutoscaler.
          </td>
        </tr>

        <tr>
          <td>
            `kube_horizontalpodautoscaler_status_current_replicas`
          </td>

          <td>
            `currentReplicas`
          </td>

          <td>
            `K8sHpaSample`
          </td>

          <td>
            **Medida:**

             Número atual de réplicas para o HorizontalPodAutoscaler.
          </td>
        </tr>

        <tr>
          <td>
            `kube_horizontalpodautoscaler_status_desired_replicas`
          </td>

          <td>
            `desiredReplicas`
          </td>

          <td>
            `K8sHpaSample`
          </td>

          <td>
            **Medida:**

             Número desejado de réplicas para o HorizontalPodAutoscaler.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_complete`
          </td>

          <td>
            `isComplete`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Medida:**

             Se o trabalho está completo 

            `(1)`

             ou não 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Medida:**

             timestamp de criação do Job.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_failed`
          </td>

          <td>
            `failed`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Medida:**

             Se o trabalho falhou 

            `(1)`

             ou não 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_spec_active_deadline_seconds`
          </td>

          <td>
            `specActiveDeadlineSeconds`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Medida:**

             Número de segundos que o trabalho pode ser executado antes de ser encerrado.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_spec_completions`
          </td>

          <td>
            `specCompletions`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Medida:**

             Número desejado de pods finalizados com sucesso para o trabalho.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_spec_parallelism`
          </td>

          <td>
            `specParallelism`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Medida:**

             Número máximo desejado de pods em execução em paralelo para o trabalho.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_active`
          </td>

          <td>
            `activePods`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Medida:**

             Número de pods ativos para o trabalho.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_completion_time`
          </td>

          <td>
            `completedAt`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Medida:**

             Tempo de conclusão do trabalho.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_failed`
          </td>

          <td>
            `failedPods`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Medida:**

             Número de pods com falha para o trabalho.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_start_time`
          </td>

          <td>
            `startedAt`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Medida:**

             Hora de início do trabalho.
          </td>
        </tr>

        <tr>
          <td>
            `kube_job_status_succeeded`
          </td>

          <td>
            `succeededPods`
          </td>

          <td>
            `K8sJobSample`
          </td>

          <td>
            **Medida:**

             Número de pods bem-sucedidos para o trabalho.
          </td>
        </tr>

        <tr>
          <td>
            `kube_node_status_allocatable`
          </td>

          <td>
            `memoryWorkingSetUtilization`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             Recursos alocáveis do nó.
          </td>
        </tr>

        <tr>
          <td>
            `kube_node_status_condition`
          </td>

          <td>
            `condition.CONDITION_NAME=CONDITION_VALUE`
          </td>

          <td>
            `K8sNodeSample`
          </td>

          <td>
            **Medida:**

             Condição do status do nó.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolume_capacity_bytes`
          </td>

          <td>
            `capacityBytes`
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Medida:**

             Capacidade do PersistentVolume em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolume_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Medida:**

             timestamp de criação do PersistentVolume.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolume_info`
          </td>

          <td />

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Medida:**

             Informações sobre o PersistentVolume.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolume_status_phase`
          </td>

          <td>
            `statusPhase`
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Medida:**

             Fase do PersistentVolume.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolumeclaim_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Medida:**

             timestamp de criação do PersistentVolumeClaim.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolumeclaim_info`
          </td>

          <td>
            Todos os atributos que descrevem o volume
          </td>

          <td>
            `K8sPersistentVolumeSample`
          </td>

          <td>
            **Medida:**

             Informações sobre o PersistentVolumeClaim.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolumeclaim_resource_requests_storage_bytes`
          </td>

          <td>
            `requestedStorageBytes`
          </td>

          <td>
            `K8sPersistentVolumeClaimSample`
          </td>

          <td>
            **Medida:**

             requests de recursos de armazenamento do PersistentVolumeClaim em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `kube_persistentvolumeclaim_status_phase`
          </td>

          <td>
            `statusPhase`
          </td>

          <td>
            `K8sPersistentVolumeClaimSample`
          </td>

          <td>
            **Medida:**

             Fase do PersistentVolumeClaim.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_resource_limits`
          </td>

          <td>
            `cpuLimitCores`

            , 

            `memoryLimitBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             Limites de recursos do pod contêiner.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_resource_requests`
          </td>

          <td>
            `cpuRequestedCores`

            , 

            `memoryRequestedBytes`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             requests de recursos do pod contêiner.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_status_phase`
          </td>

          <td>
            `status`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             Fase atual do pod contêiner.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_status_ready`
          </td>

          <td>
            `isReady`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             Se o pod contêiner está pronto 

            `(1)`

             ou não 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_status_restarts_total`
          </td>

          <td>
            `restartCount`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Contador:**

             Número total de reinicializações do pod contêiner.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_container_status_waiting_reason`
          </td>

          <td>
            `reason`
          </td>

          <td>
            `K8sContainerSample`
          </td>

          <td>
            **Medida:**

             Motivo do estado de espera do contêiner.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Medida:**

             timestamp de criação do pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_info`
          </td>

          <td>
            Todos os atributos que descrevem o pod
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Medida:**

             Informações sobre o pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_phase`
          </td>

          <td>
            `status`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Medida:**

             Fase atual do status do pod.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_ready`
          </td>

          <td>
            `isReady`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Medida:**

             Se o pod está pronto 

            `(1)`

             ou não 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_ready_time`
          </td>

          <td>
            `startTime`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Medida:**

             Horário em que o status do pod ficou pronto.
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_scheduled`
          </td>

          <td>
            `isScheduled`
          </td>

          <td>
            `K8sPodSample`
          </td>

          <td>
            **Medida:**

             Se o pod está agendado 

            `(1)`

             ou não 

            `(0)`

            .
          </td>
        </tr>

        <tr>
          <td>
            `kube_pod_status_scheduled_time`
          </td>

          <td />

          <td />

          <td>
            **Medida:**

             Horário em que o pod foi agendado.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_annotations`
          </td>

          <td>
            `selector.ANNOTATIONS`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Medida:**

             Anotações aplicadas ao Serviço.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Medida:**

             timestamp de criação do Serviço.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_info`
          </td>

          <td>
            Todos os atributos que descrevem o Serviço
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Medida:**

             Informações sobre o Serviço.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_labels`
          </td>

          <td>
            `label.LABEL_NAME`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Medida:**

             Rótulos aplicados ao Serviço.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_spec_type`
          </td>

          <td>
            `specType`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Medida:**

             Tipo de especificação do serviço.
          </td>
        </tr>

        <tr>
          <td>
            `kube_service_status_load_balancer_ingress`
          </td>

          <td>
            filtrar com 

            `WHERE specType = 'LoadBalancer'`
          </td>

          <td>
            `K8sServiceSample`
          </td>

          <td>
            **Medida:**

             Status da entrada do balanceador de carga para o Serviço.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_created`
          </td>

          <td>
            `createdAt`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Medida:**

             timestamp de criação do StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_persistentvolumeclaim_retention_policy`
          </td>

          <td>
            `filter with WHERE persistent = 'true'`
          </td>

          <td>
            `K8sVolumeSample`
          </td>

          <td>
            **Medida:**

             Política de retenção de PersistentVolumeClaims para o StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_replicas`
          </td>

          <td>
            `podsDesired`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Medida:**

             Número desejado de réplicas para o StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_current_revision`
          </td>

          <td>
            `currentRevision`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Medida:**

             Revisão atual do StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas`
          </td>

          <td>
            `podsTotal`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Medida:**

             Número de réplicas para o StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas_available`
          </td>

          <td>
            `podsTotal - podsCurrent`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Medida:**

             Número de réplicas disponíveis para o StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas_current`
          </td>

          <td>
            `podsCurrent`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Medida:**

             Número de réplicas atuais para o StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas_ready`
          </td>

          <td>
            `podsReady`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Medida:**

             Número de réplicas prontas para o StatefulSet.
          </td>
        </tr>

        <tr>
          <td>
            `kube_statefulset_status_replicas_updated`
          </td>

          <td>
            `podsUpdated`
          </td>

          <td>
            `K8sStatefulsetSample`
          </td>

          <td>
            **Medida:**

             Número de réplicas atualizadas para o StatefulSet.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="k8s-otel" title="Para Nó">
    A tabela a seguir mapeia Kubernetes OpenTelemetry métrica para o New Relic Kubernetes métrica. Essas métricas são originadas do `node` configurado com o `HostMetric Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "100px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nome do evento New Relic
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `process.cpu.utilization`
          </td>

          <td>
            `cpuPercent`
          </td>

          <td>
            `ProcessSample`
          </td>

          <td>
            **Medida:**

             utilização da CPU do processo em porcentagem.
          </td>
        </tr>

        <tr>
          <td>
            `process.disk.io`
          </td>

          <td>
            `ioTotalReadCount+ioTotalWriteCount`
          </td>

          <td>
            `ProcessSample`
          </td>

          <td>
            **Contador:**

             Número de operações I/O de disco executadas pelo processo.
          </td>
        </tr>

        <tr>
          <td>
            `process.memory.usage`
          </td>

          <td>
            `memoryResidentSizeBytes`
          </td>

          <td>
            `ProcessSample`
          </td>

          <td>
            **Medida:**

             uso de memória do processo em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `process.memory.virtual`
          </td>

          <td>
            `memoryVirtualSizeBytes`
          </td>

          <td>
            `ProcessSample`
          </td>

          <td>
            **Medida:**

             Uso de memória virtual do processo em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `system.cpu.load_average.15m`
          </td>

          <td>
            `loadAverageFifteenMinute`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Medida:**

             Média de carga do sistema nos últimos 15 minutos.
          </td>
        </tr>

        <tr>
          <td>
            `system.cpu.load_average.1m`
          </td>

          <td>
            `loadAverageOneMinute`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Medida:**

             Média de carga do sistema no último minuto.
          </td>
        </tr>

        <tr>
          <td>
            `system.cpu.load_average.5m`
          </td>

          <td>
            `loadAverageFiveMinute`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Medida:**

             Média de carga do sistema nos últimos 5 minutos.
          </td>
        </tr>

        <tr>
          <td>
            `system.cpu.utilization`
          </td>

          <td>
            `cpuPercent`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Medida:**

             Porcentagem total de utilização da CPU.
          </td>
        </tr>

        <tr>
          <td>
            `system.disk.io`
          </td>

          <td>
            `readBytesPerSecond+writeBytesPerSecond`
          </td>

          <td>
            `StorageSample`
          </td>

          <td>
            **Contador:**

             Número de operações de I/O de disco realizadas.
          </td>
        </tr>

        <tr>
          <td>
            `system.disk.io_time`
          </td>

          <td>
            `diskReadsPerSecond+diskWritesPerSecond`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Contador:**

             Tempo gasto em operações de I/O de disco em segundos.
          </td>
        </tr>

        <tr>
          <td>
            `system.disk.operation_time`
          </td>

          <td>
            `diskWriteUtilizationPercent`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Contador:**

             Tempo total gasto em operações de disco em segundos.
          </td>
        </tr>

        <tr>
          <td>
            `system.disk.operations`
          </td>

          <td>
            `readIoPerSecond`
          </td>

          <td>
            `StorageSample`
          </td>

          <td>
            **Contador:**

             Número de operações de disco realizadas.
          </td>
        </tr>

        <tr>
          <td>
            `system.filesystem.usage`
          </td>

          <td>
            `diskUsedBytes`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Medida:**

             Uso de espaço do sistema de arquivos em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `system.filesystem.utilization`
          </td>

          <td>
            `diskUsedPercent`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Medida:**

             Utilização do sistema de arquivos em porcentagem.
          </td>
        </tr>

        <tr>
          <td>
            `system.memory.usage`
          </td>

          <td>
            `memoryUsedBytes`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Medida:**

             uso total de memória em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `system.memory.utilization`
          </td>

          <td>
            `memoryUsedPercent`
          </td>

          <td>
            `SystemSample`
          </td>

          <td>
            **Medida:**

             utilização de memória em percentual.
          </td>
        </tr>

        <tr>
          <td>
            `system.network.errors`
          </td>

          <td>
            `transmitErrorsPerSecond`
          </td>

          <td>
            `NetworkSample`
          </td>

          <td>
            **Contador:**

             Número de erros de rede.
          </td>
        </tr>

        <tr>
          <td>
            `system.network.io`
          </td>

          <td>
            `receiveBytesPerSecond`

            , 

            `transmitBytesPerSecond`
          </td>

          <td>
            `NetworkSample`
          </td>

          <td>
            **Contador:**

             Número de operações de I/O de rede.
          </td>
        </tr>

        <tr>
          <td>
            `system.network.packets`
          </td>

          <td>
            `transmitPacketsPerSecond+receivePacketsPerSecond`
          </td>

          <td>
            `NetworkSample`
          </td>

          <td>
            **Contador:**

             Número de pacotes de rede transmitidos e recebidos.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="for-scheduler" title="Para o Agendador">
    A tabela a seguir mapeia Kubernetes OpenTelemetry métrica para o New Relic Kubernetes métrica. Essas métricas são originadas do `scheduler` configurado com o `Prometheus Receiver`:

    <table>
      <thead>
        <tr>
          <th style={{ width: "100px" }}>
            OTel métrica
          </th>

          <th>
            New Relic métrica
          </th>

          <th>
            Nome do evento New Relic
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `go_goroutines`
          </td>

          <td>
            `goGoroutines`
          </td>

          <td>
            `K8sSchedulerSample`
          </td>

          <td>
            **Medida:**

             Número de 

            `goroutines`

             que existem atualmente.
          </td>
        </tr>

        <tr>
          <td>
            `process_resident_memory_bytes`
          </td>

          <td>
            `processResidentMemoryBytes`
          </td>

          <td>
            `K8sSchedulerSample`
          </td>

          <td>
            **Medida:**

             Tamanho da memória residente em bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>