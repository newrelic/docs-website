---
title: Instale a integração do Kubernetes
tags:
  - Integrations
  - Kubernetes integration
  - Installation
metaDescription: 'New Relic''s Kubernetes integration: How to install and activate the integration, and what data is reported.'
signupBanner: null
text: Monitor and improve your entire stack. 100GB free. Forever.
freshnessValidatedDate: never
translationType: machine
---

import kubernetesAks from 'images/kubernetes_logo_aks.webp'

import kubernetesOpenshift from 'images/kubernetes_logo_openshift.webp'

import kubernetesCke from 'images/kubernetes_logo_cke.webp'

import kubernetesEks from 'images/kubernetes_logo_eks.webp'

import pixieLiveDebugging from 'images/pixie_screenshot-full_live-debugging.webp'

import pixieServiceOtelMap from 'images/pixie_screenshot-full_service-otel-map.webp'

import kubernetesFargateOverview from 'images/kubernetes_diagram_fargate-overview.svg'

import kubernetesFargateWorkflow from 'images/kubernetes_diagram_fargate-workflow.svg'

import kubernetesFargateUi from 'images/kubernetes_screenshot-crop_fargate-ui.webp'

A integração New Relic Kubernetes oferece total observabilidade da integridade e do desempenho do seu ambiente, aproveitando o agente New Relic Infrastructure . Este agente coleta dados de telemetria do seu cluster usando diversas integrações New Relic , como o [Kubernetes evento integração](/docs/integrations/kubernetes-integration/kubernetes-events/install-kubernetes-events-integration), o [agente Prometheus](/docs/infrastructure/prometheus-integrations/install-configure-prometheus-agent/install-prometheus-agent/) e o [plug-in New Relic Logs Kubernetes ](/docs/logs).

## Opções de instalação

Para instalar nossa integração com Kubernetes, recomendamos que você siga as instruções aqui para nossa experiência de instalação guiada. Recomendamos esta ferramenta de instalação interativa para servidores, VM e ambientes [sem privilégios](/docs/infrastructure/install-infrastructure-agent/linux-installation/linux-agent-running-modes) .

<Tabs>
  <TabsBar>
    <TabsBarItem id="guided-install">
      Instalação guiada (recomendada)
    </TabsBarItem>

    <TabsBarItem id="windows-install">
      No Windows
    </TabsBarItem>

    <TabsBarItem id="eks-fargate">
      Em EKS Fargate
    </TabsBarItem>

    <TabsBarItem id="man-helm">
      Leme manual
    </TabsBarItem>

    <TabsBarItem id="gke-autopilot">
      No piloto automático do GKE
    </TabsBarItem>
  </TabsBar>

  <TabsPages>
    <TabsPageItem id="guided-install">
      A experiência de instalação guiada simplifica o processo de instalação da integração New Relic Kubernetes e oferece controle sobre quais recursos estão habilitados e quais dados são coletados. Ele também oferece uma opção de início rápido que inclui alguns recursos opcionais pré-construídos, como painel e alertas junto com a integração Kubernetes para que você possa obter visibilidade instantânea do seu cluster do Kubernetes.

      Você pode escolher uma das três opções a seguir:

      1. CLI New Relic
      2. Um comando Helm com valores obrigatórios pré-preenchidos
      3. Um manifesto simples

      ## Navegando na instalação guiada de integração do Kubernetes [#kubernetes-install-navigation]

      Depois de iniciar a instalação guiada, utilize as informações a seguir para ajudá-lo a tomar decisões sobre a configuração.

      <Callout variant="tip">
        As etapas a seguir ignoram as etapas preliminares do início rápido. Se você escolheu a instalação guiada com o início rápido, basta clicar nas páginas <DoNotTranslate>**Confirm your Kubernetes quickstart installation**</DoNotTranslate> e <DoNotTranslate>**Installation plan**</DoNotTranslate> para acessar as principais páginas de instalação guiada descritas abaixo.
      </Callout>

      <Steps>
        <Step>
          ## Prepare-se para instalar

          Prepare seu sistema Kubernetes para a instalação guiada:

          * Se manifestos personalizados tiverem sido usados em vez do Helm, você precisará primeiro remover a instalação antiga usando `kubectl delete -f previous-manifest-file.yml` e, em seguida, prosseguir novamente com o instalador guiado. Isso gerará um conjunto atualizado de manifestos que podem ser implantados usando `kubectl apply -f manifest-file.yml`.

          * Certifique-se de usar as versões suportadas Kubernetes e verifique as notas preliminares para seus serviços gerenciados ou plataforma em nossa [página de compatibilidade e requisitos](/docs/kubernetes-pixie/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements).

          * Certifique-se de ter sua New Relic <InlinePopover type="licenseKey"/>. Você pode configurar uma conta gratuita – sem necessidade de cartão de crédito.

          * Certifique-se de que o domínio newrelic Dockerhub (`https://hub.docker.com/u/newrelic`) e o registro do Google (`registry.k8s.io`) sejam adicionados à sua lista de permissões. É daqui que a instalação extrairá as imagens do contêiner. Observe que pode ser necessário seguir os [comandos](https://kubernetes.io/blog/2023/03/10/image-registry-redirect/#how-can-i-check-if-i-am-impacted) para identificar o domínio de registro adicional do Google a ser adicionado à sua lista branca, porque `registry.k8s.io` normalmente redireciona para o domínio de registro local (por exemplo, `asia-northeast1-docker.pkg.dev`) com base na sua região.

            Se você estiver instalando nossa integração em uma nuvem gerenciada, dê uma olhada nestas [notas preliminares](#cloud-platforms) antes de continuar:

            <CollapserGroup>
              <Collapser
                className="freq-link"
                id="install-amazon-eks"
                title={<><img src={kubernetesEks} alt="EKS" style={{ verticalAlign: 'middle' }}>Amazon EKS/EKS Anywhere/EKS Anywhere em bare metal</img></>}
              >
                A integração Kubernetes monitora apenas nós de trabalho no Amazon EKS, pois a Amazon abstrai o gerenciamento de nós mestres da plataforma Kubernetes .

                Antes de usar nossa instalação guiada para implantar a integração Kubernetes no Amazon EKS, certifique-se de instalar `eksctl`, a [ferramenta de linha de comando](https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html) para gerenciamento de cluster do Kubernetes no Amazon EKS.
              </Collapser>

              <Collapser
                className="freq-link"
                id="install-google-kubernetes-engine"
                title={<><img src={kubernetesCke} alt="CKE" style={{ verticalAlign: 'middle' }}>Google Kubernetes Engine (padrão GKE)</img></>}
              >
                A integração do Kubernetes monitora apenas nós de trabalho no GKE, pois o Google abstrai o gerenciamento de nós mestres da plataforma Kubernetes .

                Antes de iniciar nossa instalação guiada para implantar a integração do Kubernetes no GKE, verifique se você tem permissões suficientes:

                1. Acesse [console.cloud.google.com/iam-admin/iam](https://console.cloud.google.com/iam-admin/iam) e encontre seu nome de usuário.

                2. Clique em

                   <DoNotTranslate>**edit**</DoNotTranslate>

                   .

                3. Certifique-se de ter permissões para criar `Roles` e `ClusterRoles`: se não tiver certeza, adicione a função

                   <DoNotTranslate>**Kubernetes Engine Cluster Admin**</DoNotTranslate>

                   . Caso você não consiga editar seu perfil de usuário, peça ao proprietário do projeto GCP que lhe conceda as permissões necessárias.
              </Collapser>

              <Collapser
                className="freq-link"
                id="install-openshift-container-platform"
                title={<><img src={kubernetesOpenshift} alt="OpenShift" style={{ verticalAlign: 'middle' }}>Plataforma de contêiner OpenShift</img></>}
              >
                Para implantar a integração do Kubernetes com [OpenShift](https://learn.openshift.com):

                1. Adicione as contas de serviço usadas pela integração às suas [restrições de contexto de segurança](https://docs.openshift.com/enterprise/3.0/admin_guide/manage_scc.html) privilegiadas:

                   ```
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-newrelic-infrastructure
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-nrk8s-controlplane
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-kube-state-metrics
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-newrelic-logging
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-nri-kube-events
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-nri-metadata-injection-admission
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-nrk8s-controlplane
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:default
                   ```

                   <Callout variant="tip">
                     O instalador fornece `newrelic-bundle` como padrão `release_name` e `newrelic` como padrão `namespace`.
                   </Callout>

                2. Conclua as etapas em nossa [instalação guiada](https://one.newrelic.com/nr1-core?state=51fbbd48-c8ca-ead9-bb90-af96e18d82a7).

                3. Se você estiver usando certificados assinados, verifique se eles estão configurados corretamente usando as seguintes variáveis na parte `DaemonSet` do seu manifesto. Defina o arquivo `.pem` :

                   ```yaml
                   env:
                     - name: NRIA_CA_BUNDLE_DIR
                       value: YOUR_CA_BUNDLE_DIR
                     - name: NRIA_CA_BUNDLE_FILE
                       value: YOUR_CA_BUNDLE_NAME
                   ```

                4. Defina o caminho da chave YAML como `spec.template.spec.containers.name.env`.

                5. Salve suas alterações.
              </Collapser>

              <Collapser
                className="freq-link"
                id="install-azure-aks"
                title={<><img src={kubernetesAks} alt="AKS" style={{ verticalAlign: 'middle' }}>Serviço Kubernetes do Azure (AKS)</img></>}
              >
                A integração do Kubernetes monitora apenas nós de trabalho no Serviço Azure Kubernetes , pois o Azure abstrai o gerenciamento de nós mestres da plataforma Kubernetes .
              </Collapser>
            </CollapserGroup>
        </Step>

        <Step>
          ## Comece a instalação guiada

          Comece sua instalação guiada clicando em uma das opções abaixo:

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Opção de instalação guiada
                </th>

                <th>
                  Descrição
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  [Instalação guiada](https://onenr.io/0oR861DvMQG)
                </td>

                <td>
                  Use-o se a sua New Relic organização **não** usar o [da UE](/docs/using-new-relic/welcome-new-relic/get-started/our-eu-us-region-data-centers) data center e você não precisar do painel de bônus e dos alertas do início rápido.
                </td>
              </tr>

              <tr>
                <td>
                  [Instalação guiada (EU)](https://onenr.io/0VwgOqNAZwJ)
                </td>

                <td>
                  Use-o se a sua organização New Relic usar o data center [da UE](/docs/using-new-relic/welcome-new-relic/get-started/our-eu-us-region-data-centers) e você não precisar do painel de bônus e do alerta do início rápido.
                </td>
              </tr>

              <tr>
                <td>
                  [Instalação guiada com início rápido](https://one.newrelic.com/launcher/catalog-pack-details.launcher/?pane=eyJuZXJkbGV0SWQiOiJjYXRhbG9nLXBhY2stZGV0YWlscy5jYXRhbG9nLXBhY2stY29udGVudHMiLCJxdWlja3N0YXJ0SWQiOiI4OGE3OWY1Mi04MWMxLTRmYTItOTlmOC0zY2I1YjAxMmYxNjAifQ==)
                </td>

                <td>
                  Use esta opção se sua organização New Relic **não** usar o data center [da UE](/docs/using-new-relic/welcome-new-relic/get-started/our-eu-us-region-data-centers) e você também quiser instalar algum painel de bônus e alerta do início rápido.
                </td>
              </tr>
            </tbody>
          </table>
        </Step>

        <Step>
          ## Configure sua instalação

          Na página <DoNotTranslate>**Configure the Kubernetes Integration**</DoNotTranslate> preencha os seguintes campos:

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Campo
                </th>

                <th>
                  Descrição
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  Enviaremos seus dados para esta conta
                </td>

                <td>
                  Escolha a conta New Relic na qual você deseja gravar seus dados do Kubernetes.
                </td>
              </tr>

              <tr>
                <td>
                  Nome do cluster
                </td>

                <td>
                  Nome cluster é o nome que usaremos para tag seus dados Kubernetes para que você possa filtrar os dados específicos do cluster no qual está instalando esta integração. Isso é importante se você optar por conectar vários clusters à sua conta New Relic , portanto escolha um nome que você reconheça.
                </td>
              </tr>

              <tr>
                <td>
                  Namespace para a integração
                </td>

                <td>
                  Namespace for the integração é o namespace que usaremos para hospedar a integração do Kubernetes em seu cluster. Recomendamos usar o namespace padrão `newrelic`.
                </td>
              </tr>
            </tbody>
          </table>
        </Step>

        <Step>
          ## Selecione dados adicionais

          Na página <DoNotTranslate>**Select the additional data you want to gather**</DoNotTranslate>, escolha as opções certas para você:

          ### Raspe o endpoint do Prometheus [#scrape-endpoints]

          Ao selecionar esta opção, instalaremos o Prometheus em modo agente para coletar métricas do endpoint do Prometheus exposto em seu cluster. Expanda os recolhedores para ver detalhes sobre cada opção:

          <CollapserGroup>
            <Collapser
              className="freq-link"
              id="scrape-all-except-ksm"
              title="Raspe todos os endpoints do Prometheus, exceto a métrica principal do sistema Kubernetes (recomendado)"
            >
              Recomendamos esta configuração porque vários outros componentes da integração do Kubernetes , como [`kube-state-metrics`, `newrelic-infrastructure` e `nri-prometheus`](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle#bundled-charts) já coletarão essas métricas e configurar o Prometheus para excluir essas métricas economizará seus custos de ingestão de dados, removendo quaisquer redundâncias métricas .

              Esta configuração filtrará qualquer métrica prefixada com [`kube_`, `container_`, `machine_` e `cadvisor_`](https://github.com/newrelic/newrelic-prometheus-configurator/blob/64af9453f4b20d4aab88a4d1afda55cf9a6e63c4/charts/newrelic-prometheus-agent/static/lowdatamodedefaults.yaml).

              Aqui está um exemplo de `newrelic-prometheus-configurator/charts/newrelic-prometheus-agent/static/lowdatamodedefaults.yaml`:

              ```yaml
              low_data_mode:
              - action: drop
                source_labels: [__name__]
                regex: "kube_.+|container_.+|machine_.+|cadvisor_.+"
              ```
            </Collapser>

            <Collapser
              className="freq-link"
              id="scrape-all-endpoints"
              title="Raspe todos os endpoints do Prometheus"
            >
              Selecione <DoNotTranslate>**Scrape all Prometheus endpoints**</DoNotTranslate> se preferir preservar as convenções de nomenclatura métricas do Prometheus em todas as métricas do Prometheus, independentemente de quaisquer redundâncias métricas.
            </Collapser>

            <Collapser
              className="freq-link"
              id="scrape-with-quickstarts"
              title="Raspe apenas o endpoint do Prometheus com guias de início rápido"
            >
              New Relic fornece [quickstarts](https://newrelic.com/instant-observability/?category=prometheus&search=), que são dashboards, alertas e entidades pré-fabricados para diversos serviços. Selecione esta opção para que o Prometheus procure apenas [serviços que tenham um início rápido pré-fabricado](https://github.com/newrelic/newrelic-prometheus-configurator/blob/main/charts/newrelic-prometheus-agent/values.yaml#L214-L228) e estejam prontos para observação instantânea.

              Aqui está um exemplo de `newrelic-prometheus-configurator/charts/newrelic-prometheus-agent/values.yaml` mostrando no campo `app_values` quais serviços serão copiados para a opção de início rápido do Prometheus:

              ```yaml
              kubernetes:
                  # NewRelic provides a list of Dashboards, alerts and entities for several Services. The integrations_filter configuration
                  # allows to scrape only the targets having this experience out of the box.
                  # If integrations_filter is enabled, then the jobs scrape merely the targets having one of the specified labels matching
                  # one of the values of app_values.
                  # Under the hood, a relabel_configs with 'action=keep' are generated, consider it in case any custom extra_relabel_config is needed.
                  integrations_filter:
                    # -- enabling the integration filters, merely the targets having one of the specified labels matching
                    #    one of the values of app_values are scraped. Each job configuration can override this default.
                    enabled: true
                    # -- source_labels used to fetch label values in the relabel config added by the integration filters configuration
                    source_labels: ["app.kubernetes.io/name", "app.newrelic.io/name", "k8s-app"]
                    # -- app_values used to create the regex used in the relabel config added by the integration filters configuration.
                    # Note that a single regex will be created from this list, example: '.*(?i)(app1|app2|app3).*'
                    app_values: ["redis", "traefik", "calico", "nginx", "coredns", "kube-dns", "etcd", "cockroachdb", "velero", "harbor", "argocd"]
              ```
            </Collapser>

            <Collapser
              className="freq-link"
              id="custom-app-labels"
              title="Raspe apenas alguns rótulos"
            >
              Você achará esta opção útil se você for um usuário avançado que tem uma boa ideia de quais serviços deseja ver as métricas do Prometheus. Insira uma lista separada por vírgula de serviços que você deseja que o Prometheus extraia e o Prometheus executará uma correspondência curinga no nome do serviço para encontrar sua métrica do endpoint desejado.

              Esta opção fornecerá _apenas_ métricas dos serviços que correspondam à lista submetida, por isso tome cuidado para validar a correção da entrada. Para saber mais sobre rótulos de aplicativos personalizados, consulte [Configuração avançada para o agente Prometheus](/docs/infrastructure/prometheus-integrations/install-configure-prometheus-agent/advanced-configuration/#enable-disable-integrations).

              Os serviços que você adicionar à lista enviada substituirão os dados em `app_values` abaixo e o Prometheus <DoNotTranslate>**only**</DoNotTranslate> extrairá métricas desses serviços.

              Aqui está um exemplo de `newrelic-prometheus-configurator/charts/newrelic-prometheus-agent/values.yaml`:

              ```yaml
              kubernetes:
                  # NewRelic provides a list of Dashboards, alerts and entities for several Services. The integrations_filter configuration
                  # allows to scrape only the targets having this experience out of the box.
                  # If integrations_filter is enabled, then the jobs scrape merely the targets having one of the specified labels matching
                  # one of the values of app_values.
                  # Under the hood, a relabel_configs with 'action=keep' are generated, consider it in case any custom extra_relabel_config is needed.
                  integrations_filter:
                    # -- enabling the integration filters, merely the targets having one of the specified labels matching
                    #    one of the values of app_values are scraped. Each job configuration can override this default.
                    enabled: true
                    # -- source_labels used to fetch label values in the relabel config added by the integration filters configuration
                    source_labels: ["app.kubernetes.io/name", "app.newrelic.io/name", "k8s-app"]
                    # -- app_values used to create the regex used in the relabel config added by the integration filters configuration.
                    # Note that a single regex will be created from this list, example: '.*(?i)(app1|app2|app3).*'
                    app_values: ["redis", "traefik", "calico", "nginx", "coredns", "kube-dns", "etcd", "cockroachdb", "velero", "harbor", "argocd"]
              ```
            </Collapser>
          </CollapserGroup>

          ### Reúna dados log [#gather-logs]

          Você pode personalizar os detalhes dos dados log na interface de instalação:

          <CollapserGroup>
            <Collapser
              className="freq-link"
              id="full-enrichment"
              title="Encaminhar todos os logs com enriquecimento total"
            >
              Se você preferir dados mais robustos, selecione esta opção para enriquecer totalmente seu log adicionando dados de rótulo e anotação.

              Aqui está um exemplo de log com enriquecimento total de dados:

              ```json
              [
                {
                  "cluster_name": "api-test",
                  "kubernetes": {
                    "annotations": {
                      "kubernetes.io/psp": "eks.privileged"
                    },
                    "container_hash": "fryckbos/test@sha256:5b098eaf3c7d5b3585eb10cebee63665b6208bea31ef31a3f0856c5ffdda644b",
                    "container_image": "fryckbos/test:latest",
                    "container_name": "newrelic-logging",
                    "docker_id": "134e1daf63761baa15e035b08b7aea04518a0f0e50af4215131a50c6a379a072",
                    "host": "ip-192-168-17-123.ec2.internal",
                    "labels": {
                      "app": "newrelic-logging",
                      "app.kubernetes.io/name": "newrelic-logging",
                      "controller-revision-hash": "84db95db86",
                      "pod-template-generation": "1",
                      "release": "nri-bundle"
                    },
                    "namespace_name": "nrlogs",
                    "pod_id": "54556e3e-719c-46b5-af69-020b75d69bf1",
                    "pod_name": "nri-bundle-newrelic-logging-jxnbj"
                  },
                  "message": "[2021/09/14 12:30:49] [ info] [engine] started (pid=1)\n",
                  "plugin": {
                    "source": "kubernetes",
                    "type": "fluent-bit",
                    "version": "1.8.1"
                  },
                  "stream": "stderr",
                  "time": "2021-09-14T12:30:49.138824971Z",
                  "timestamp": 1631622649138
                }
              ]
              ```
            </Collapser>

            <Collapser
              className="freq-link"
              id="min-enrichment"
              title="Encaminhar todos os logs com enriquecimento mínimo (modo de baixo consumo de dados)"
            >
              Se quiser priorizar os custos de ingestão de dados, você poderá optar por coletar dados de log com enriquecimento mínimo, também conhecido como modo de dados baixos. Esta opção descarta rótulos e anotações do seu log e compartilha apenas Kubernetes log dados padrão , como nome do cluster, contêiner, namespace e pod, junto com a mensagem e o timestamp.

              Ao selecionar o modo de enriquecimento mínimo, apenas os seguintes atributos log são retidos: `cluster_name`, `container_name`, `namespace_name`, `pod_name`, `stream`, `message` e `log`.

              Aqui está um exemplo de log com enriquecimento mínimo de dados:

              ```json
              [
                {
                  "cluster_name": "api-test",
                  "container_name": "newrelic-logging",
                  "namespace_name": "nrlogs",
                  "pod_name": "nri-bundle-newrelic-logging-jxnbj",
                  "message": "[2021/09/14 12:30:49] [ info] [engine] started (pid=1)\n",
                  "stream": "stderr",
                  "timestamp": 1631622649138
                }
              ]
              ```
            </Collapser>
          </CollapserGroup>

          ### Habilite insights de nível de serviço, solicitações de corpo inteiro e perfis de aplicativos por meio do Pixie [#enable-pixie]

          [Pixie](https://docs.px.dev/about-pixie/what-is-pixie/) é uma ferramenta de observação de código aberto para aplicativo Kubernetes que utiliza eBPF para coletar automaticamente dados de telemetria. Se você não tem o Pixie instalado em seu cluster, mas deseja aproveitar a poderosa coleta e visualização de dados de telemetria do Pixie na [plataforma New Relic](/docs/kubernetes-pixie/auto-telemetry-pixie/get-started-auto-telemetry-pixie/), verifique <DoNotTranslate>**Enable service-level insights, full-body requests, and application profiles through Pixie**</DoNotTranslate>.

          Se você já estiver usando o Community Cloud, selecione <DoNotTranslate>**Community Cloud hosted Pixie is already running on this cluster**</DoNotTranslate>. Tenha em mente o seguinte sobre as diferentes maneiras pelas quais [o Pixie pode ser hospedado](https://docs.px.dev/installing-pixie/install-guides/#title). A New Relic oferece um nível diferente de suporte de integração para cada opção de hospedagem Pixie.

          <CollapserGroup>
            <Collapser
              className="freq-link"
              id="community-cloud-pixie"
              title="Comunidade Cloud Pixie"
            >
              Se você já estiver aproveitando o Community Cloud do Pixie, poderá fornecer uma chave de API para conectar o Pixie ao New Relic. Essa abordagem incorporará a interface ao vivo do Pixie em sua New Relic conta para fácil acesso (por meio da ferramenta Live Debugging do Pixie), bem como gravará dados do Pixie no New Relic por meio do New Relic OpenTelemetry endpoint.

              <img
                title="service graph in live debugger"
                alt="service-graph"
                src={pixieLiveDebugging}
              />
            </Collapser>

            <Collapser
              className="freq-link"
              id="self-hosted-pixie"
              title="Pixie auto-hospedado"
            >
              Se estiver usando o Pixie com um Pixie Cloud auto-hospedado, você também pode conectar o Pixie ao New Relic. Essa abordagem permitirá a exportação de dados de telemetria Pixie para New Relic por meio do OpenTelemetry endpoint para retenção de dados e visibilidade de longo prazo. Infelizmente, se você auto-hospedar seu Pixie Cloud, New Relic não oferece suporte à incorporação da interface Live do Pixie.

              Se você auto-hospedar o Pixie Cloud e quiser ativar a exportação de dados de telemetria do Pixie para o New Relic, basta ativar o Pixie na integração do Kubernetes sem verificar o <DoNotTranslate>**Community Cloud hosted Pixie option**</DoNotTranslate>. A integração do Kubernetes detectará que o Pixie está sendo executado em seu cluster e permitirá a exportação de dados para visibilidade e insights instantâneos de dados.

              <img
                title="The OpenTelemetry <DoNotTranslate>**Service map**</DoNotTranslate> view shows helps visualize your application's dependencies."
                alt="The OpenTelemetry <DoNotTranslate>**Service map**</DoNotTranslate> view shows helps visualize your application's dependencies."
                src={pixieServiceOtelMap}
              />
            </Collapser>
          </CollapserGroup>
        </Step>

        <Step>
          ## Conclua sua instalação

          Finalize a configuração da instalação do Kubernetes escolhendo um dos seguintes métodos de instalação na última etapa da instalação guiada:

          * <DoNotTranslate>**Guided Install (recommended)**</DoNotTranslate>: esta opção fará download e usará automaticamente a CLI [`newrelic-cli`](https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/) para instalar e configurar a integração do Kubernetes.

          * <DoNotTranslate>**Helm 3**</DoNotTranslate>: use esta opção se preferir usar [o Helm](https://helm.sh/) para instalar e configurar a integração do Kubernetes. Esta opção instala o [gráfico Helm`nri-bundle` ](/docs/kubernetes-pixie/kubernetes-integration/installation/install-kubernetes-integration-using-helm/#install-k8-helm), que você pode configurar posteriormente com as opções descritas [aqui](/docs/kubernetes-pixie/kubernetes-integration/installation/install-kubernetes-integration-using-helm/#configure).

          * <DoNotTranslate>**Manifest**</DoNotTranslate>: selecione esta opção se preferir gerar um manifesto do Kubernetes no formato YAML e instalá-lo manualmente com [`kubectl`](https://kubernetes.io/docs/reference/kubectl/).

            <Callout variant="tip">
              Não está vendo dados? Se você completou as etapas acima e ainda não está vendo os dados, confira [esta página de resolução de problemas](/docs/kubernetes-pixie/kubernetes-integration/troubleshooting/kubernetes-integration-troubleshooting-not-seeing-data/).
            </Callout>
        </Step>
      </Steps>
    </TabsPageItem>

    <TabsPageItem id="windows-install">
      Use esta opção quando você tiver um sistema Kubernetes baseado em Windows. Observe que existem [várias limitações](/docs/kubernetes-pixie/kubernetes-integration/installation/install-version2-kubernetes-integration-windows/#k8-windows-limitations) para a integração do Windows.

      <Callout title="visualização">
        Este recurso está atualmente em versão prévia.
      </Callout>

      ## Compatibilidade e requisitos [#k8-windows-req]

      Antes de instalar a [integração do Kubernetes](/docs/integrations/kubernetes-integration/get-started/introduction-kubernetes-integration), revise a [compatibilidade e os requisitos](/docs/integrations/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements).

      <Callout variant="important">
        Ao utilizar contêiner no Windows, a versão do host do contêiner e a versão da imagem do contêiner devem ser iguais. Nossa integração com Kubernetes pode ser executada nas versões Windows LTSC 2019 (1809), 20H2 e LTSC 2022.
      </Callout>

      Para verificar sua versão do Windows:

      1. Abra uma janela de comando.

      2. Execute o seguinte comando:

         ```shell
         Reg Query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v
         ReleaseIdcmd.exe
         ```

      ### Exemplo: Obtenha o Kubernetes para Windows de um contêiner BusyBox [#example-k8s-windows-busybox]

      Execute este comando:

      ```shell
      kubectl exec -it busybox1-766bb4d6cc-rmsnj -- Reg Query
      "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v ReleaseId
      ```

      Você deverá ver algo assim:

      ```shell
      HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion
      ReleaseId	REG_SZ	1809
      ```

      Para um mapeamento útil entre IDs de lançamento e versões do sistema operacional, veja [aqui](https://hub.docker.com/_/microsoft-windows-servercore).

      ## Instalar [#k8-windows-install]

      Você pode instalar a integração do Kubernetes para Windows usando Helm. Veja um exemplo de como instalar a integração em um cluster com nós com diferentes versões de build do Windows (1809 e 2004):

      1. Adicione o repositório de gráficos do New Relic Helm:

         ```shell
         helm repo add newrelic https://helm-charts.newrelic.com
         ```

      2. Crie um namespace para newrelic:

         ```shell
         kubectl create namespace newrelic
         ```

      3. Instale o kube-state-métrica.

         ```shell
         helm repo add ksm https://kubernetes.github.io/kube-state-metrics
         helm install ksm ksm/kube-state-metrics --version 2.13.2
         ```

         <Callout variant="important">
           Este comando serve para instalar o kube-state-métrica, uma dependência obrigatória da integração, num nó Linux. Não oferecemos suporte à instalação para nós não Linux e, se você instalá-lo em um nó não Linux, a implantação poderá falhar. Recomendamos usar `nodeSelector` para escolher um nó Linux. Isto pode ser feito editando a implantação kube-state-métrica.
         </Callout>

      4. Crie um arquivo `values-newrelic.yaml` com os seguintes dados a serem usados pelo Helm:

         ```yaml
         global:
           licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
           cluster: _K8S_CLUSTER_NAME_

         enableLinux: true        # Set to true if your cluster also has linux nodes
         enableWindows: true
         windowsOsList:
           - version: 2019            # Human-readable version identifier
             imageTag: 2-windows-1809-alpha  # Tag to be used for nodes running the windows version above
             buildNumber: 10.0.17763         # Build number for your nodes running the version above. Used as a selector.
           - version: 20h2
             imageTag: 2-windows-20H2-alpha
             buildNumber: 10.0.19042
           - version: 2022
             imageTag: 2-windows-ltsc2022-alpha
             buildNumber: 10.0.20348
         nodeSelector:
           kubernetes.io/os: linux         # Selector for Linux installation.
         windowsNodeSelector:
           kubernetes.io/os: windows       # Selector for Windows installation.
         ```

      5. Instale a integração com:

         ```shell
         helm upgrade --install newrelic newrelic/newrelic-infrastructure \
         --namespace newrelic --create-namespace \
         --version 2.7.2 \
         -f values-newrelic.yaml
         ```

      6. Verifique se o pod está sendo implantado e atinge um estado estável:

         ```shell
         kubectl -n newrelic get pods -w
         ```

      O gráfico do Helm criará um DaemonSet para cada versão do Windows que estiver na lista e usará o NodeSelector para implantar o pod correspondente por nó.

      ## Limitações [#k8-windows-limitations]

      As seguintes limitações se aplicam à integração do Kubernetes para Windows:

      * O agente do Windows envia apenas as [amostras do Kubernetes](/docs/integrations/kubernetes-integration/understand-use-data/understand-use-data#event-types) (`K8sNodeSample`, `K8sPodSample`, etc.)

        * `SystemSample`, `StorageSample`, `NetworkSample` e `ProcessSample` não são gerados.
        * Algumas [métricasKubernetes ](/docs/integrations/kubernetes-integration/understand-use-data/understand-use-data#metrics)estão faltando porque o kubelet do Windows não as possui:

      * Nó:

        * `fsInodes`: não enviado
        * `fsInodesFree`: não enviado
        * `fsInodesUsed`: não enviado
        * `memoryMajorPageFaultsPerSecond`: sempre retorna zero como valor
        * `memoryPageFaults`: sempre retorna zero como valor
        * `memoryRssBytes`: sempre retorna zero como valor
        * `runtimeInodes`: não enviado
        * `runtimeInodesFree`: não enviado
        * `runtimeInodesUsed`: não enviado

      * Pod:

        * `net.errorsPerSecond`: não enviado
        * `net.rxBytesPerSecond`: não enviado
        * `net.txBytesPerSecond`: não enviado

      * Contêiner:

        * `containerID`: não enviado
        * `containerImageID`: não enviado
        * `memoryUsedBytes`: na interface, isso é exibido no cartão pod que aparece quando você clica em um pod e não mostra dados. Em breve corrigiremos isso atualizando nossos gráficos para usar `memoryWorkingSetBytes` .

      * Volume:

        * `fsUsedBytes`: zero, então `fsUsedPercent` é zero

      ## Problemas conhecidos com o Windows Kubelet [#k8-windows-limitations]

      Existem alguns problemas com a versão Windows do Kubelet que podem impedir a integração de buscar dados:

      * [Problema 90554:](https://github.com/kubernetes/kubernetes/pull/90554) esse problema faz com que o Kubelet retorne 500 erros quando a integração faz uma solicitação ao endpoint `/stats/summary` . Ele será incluído na versão 1.19 do Kubernetes e foi portado para as versões 1.16.11, 1.17.7 e 1.18.4. Não há solução do lado da integração para este problema, aconselhamos que você atualize para uma das versões do patch o mais rápido possível. Você pode ver se está sendo afetado por esse problema [ativando o log detalhado](/docs/integrations/kubernetes-integration/troubleshooting/get-logs-version#verbose) e procurando mensagens do tipo:

      ```shell
      error querying Kubelet. Get "https://<KUBELET_IP>/stats/summary": error calling kubelet endpoint. Got status code: 500
      ```

      * [Problema 87730:](https://github.com/kubernetes/kubernetes/pull/87730) esse problema torna a métrica do Kubelet muito lenta ao executar carga mínima. Isso faz com que a integração falhe com um erro de tempo limite. Um patch para esse problema foi adicionado ao Kubernetes 1.18 e portado para 1.15.12, 1.16.9 e 1.17.5. Aconselhamos você a atualizar para uma das versões de patch o mais rápido possível. Para atenuar esse problema, você pode aumentar o tempo limite de integração com a [opção de configuração`TIMEOUT` ](/docs/integrations/kubernetes-integration/installation/kubernetes-integration-install-configure#kube-state-metrics-timeout-change). Você pode ver se está sendo afetado por esse problema [ativando o log detalhado](/docs/integrations/kubernetes-integration/troubleshooting/get-logs-version#verbose) e procurando mensagens do tipo:

      ```shell
      error querying Kubelet. Get "https://<KUBELET_IP>/stats/summary": context deadline exceeded (Client.Timeout exceeded while awaiting headers)
      ```
    </TabsPageItem>

    <TabsPageItem id="eks-fargate">
      Use esta opção ao monitorar a carga de trabalho Kubernetes no EKS Fargate. Esta integração injeta automaticamente um sidecar contendo o agente de infraestrutura e a integração nri-Kubernetes em cada pod que precisa ser monitorado.

      <Callout title="Visualização">
        Este recurso está atualmente em versão prévia.
      </Callout>

      New Relic suporta monitoramento de carga de trabalho Kubernetes no EKS Fargate injetando automaticamente um sidecar contendo o agente de infraestrutura e a `nri-kubernetes` integração em cada pod que precisa ser monitorado.

      Caso o mesmo cluster do Kubernetes também contenha nós EC2, nossa solução também será implantada como `DaemonSet` em todos eles. Nenhum sidecar será injetado em pods programados em nós EC2 e nenhum `DaemonSet` será implantado em nós Fargate. Aqui está um exemplo de instância híbrida com nós Fargate e EC2:

      <img
        title="Diagram showing an EKS cluster with Fargate and EC2 nodes"
        alt="Diagram showing an EKS cluster with Fargate and EC2 nodes"
        src={kubernetesFargateOverview}
      />

      <figcaption>
        Em um ambiente misto, a integração usa apenas um arquivo secundário para nós do Fargate.
      </figcaption>

      New Relic coleta todas as métricas suportadas para todos os objetos Kubernetes , independentemente de onde eles estão agendados, sejam nós Fargate ou EC2. Observe que, devido às limitações impostas pelo Fargate, a integração do New Relic está limitada à execução em modo [sem privilégios](/docs/integrations/kubernetes-integration/installation/kubernetes-integration-install-configure/#unprivileged) nos nós do Fargate. Isso significa que as métricas que geralmente são buscadas diretamente do host, como processos em execução, não estarão disponíveis para nós Fargate.

      O agente em ambos os cenários extrairá dados da Kube State métrica (KSM), Kubelet e cAdvisor e enviará os dados no mesmo formato.

      <Callout variant="important">
        Assim como para qualquer outro cluster do Kubernetes, nossa solução ainda requer que você implante e monitor uma instância Kube State métrica (KSM). Nosso Helm Chart e/ou instalador fará isso automaticamente por padrão, embora esse comportamento possa ser desabilitado se o seu cluster já tiver uma instância funcional do KSM. Esta instância KSM será monitorada como qualquer outra workload: injetando um arquivo secundário se for agendado em um nó Fargate ou com a instância local do `DaemonSet` se for agendado em um nó EC2.
      </Callout>

      Outros componentes da solução New Relic para Kubernetes, como `nri-prometheus`, `nri-metadata-injection` e `nri-kube-events`, não possuem particularidades e serão implantados pelo nosso Helm Chart normalmente como seriam em ambientes não Fargate.

      ## instalação [#installation]

      Você pode escolher entre duas alternativas para instalar a observabilidade completa do New Relic em seu cluster EKS Fargate:

      * [Injeção automática (recomendada)](#automatic)
      * [Injeção manual](#manual)

      Independentemente da abordagem escolhida, a experiência é exatamente a mesma depois de instalada. A única diferença é como o contêiner é injetado. Recomendamos configurar a injeção automática com o operador de monitoramento de infraestrutura New Relic porque isso eliminará a necessidade de editar manualmente cada implantação que você deseja monitor.

      ### Injeção automática (recomendada) [#automatic]

      Por padrão, quando o suporte do Fargate estiver ativado, o New Relic implantará um operador no cluster (`newrelic-infra-operator`). Uma vez implantado, este operador injetará automaticamente o sidecar de monitoramento nos pods que estão programados nos nós Fargate, ao mesmo tempo que gerencia a criação e a atualização de `Secrets`, `ClusterRoleBindings`, e quaisquer outros recursos relacionados.

      Este operador aceita uma variedade de opções avançadas de configuração que podem ser usadas para restringir ou ampliar o escopo da injeção, através do uso de seletores de rótulos para pod e namespace.

      #### O que a operadora faz [#what-operator-does]

      Nos bastidores, o operador configura um `MutatingWebhookConfiguration`, que permite modificar os objetos pod que estão prestes a ser criados no cluster. Neste evento, e quando o pod que está sendo criado corresponder à configuração do usuário, o operador irá:

      1. Adicione um contêiner secundário ao pod que contém a integração do New Relic Kubernetes.

      2. Se um segredo não existir, crie um no mesmo namespace do pod que contém a New Relic

         <InlinePopover type="licenseKey"/>

         , que é necessário para que o arquivo secundário relate dados.

      3. Adicione a conta de serviço do pod a um `ClusterRoleBinding` previamente criado pelo gráfico do operador, que concederá a este sidecar as permissões necessárias para atingir o endpoint métrico Kubernetes .

      O `ClusterRoleBinding` concede as seguintes permissões ao pod que está sendo injetado:

      ```yml

      rules:
      - apiGroups: [""]
        resources:
        - "nodes"
        - "nodes/metrics"
        - "nodes/stats"
        - "nodes/proxy"
        - "pods"
        - "services"
        - "namespaces"
        verbs: ["get", "list"]
      - nonResourceURLs: ["/metrics"]
        verbs: ["get"]

      ```

      <Callout variant="tip">
        Para que o sidecar seja injetado e, portanto, obtenha a métrica do pod implantado antes da instalação do operador, é necessário realizar manualmente um rollout (restart) da implantação afetada. Desta forma, quando o pod for criado, o operador poderá injetar o sidecar de monitoramento. A New Relic optou por não fazer isso automaticamente para evitar interrupções inesperadas de serviço e picos de uso de recursos.
      </Callout>

      <Callout variant="important">
        Lembre-se de criar um perfil do Fargate com um seletor que declare o namespace `newrelic` (ou o namespace que você escolher para a instalação).
      </Callout>

      Aqui está o fluxo de trabalho de injeção:

      <img
        title="Diagram showing the workflow of sidecar injection"
        alt="Diagram showing the workflow of sidecar injection"
        src={kubernetesFargateWorkflow}
      />

      #### Instalação de injeção automática [#auto-injection-install]

      <Callout variant="tip">
        As etapas a seguir são para uma configuração padrão. Antes de concluí-los, sugerimos que você dê uma olhada na seção [de configuração](#config-auto) abaixo para ver se deseja modificar algum aspecto da injeção automática.
      </Callout>

      Primeiro, adicione o repositório New Relic Helm, caso ainda não tenha feito isso:

      ```shell
      helm repo add newrelic https://helm-charts.newrelic.com
      ```

      Então, para instalar o operador responsável por injetar o sidecar da infraestrutura, crie um arquivo chamado `values.yaml`, que será utilizado para definir sua configuração:

      ```yaml
      ## Global values
      global:
        # -- The cluster name for the Kubernetes cluster.
        cluster: "_YOUR_K8S_CLUSTER_NAME_"

        # -- The license key for your New Relic Account. This will be preferred configuration option if both `licenseKey` and `customSecret` are specified.
        licenseKey: "_YOUR_NEW_RELIC_LICENSE_KEY_"

        # -- (bool) In each integration it has different behavior. Enables operating system metric collection on each EC2 K8s node. Not applicable to Fargate nodes.
        # @default -- false
        privileged: true

        # -- (bool) Must be set to `true` when deploying in an EKS Fargate environment
        # @default -- false
        fargate: true

      ## Enable nri-bundle sub-charts

      newrelic-infra-operator:
        # Deploys the infrastructure operator, which injects the monitoring sidecar into Fargate pods
        enabled: true
        tolerations: 
        - key: "eks.amazonaws.com/compute-type"
          operator: "Equal"
          value: "fargate"
          effect: "NoSchedule"
        config:
          ignoreMutationErrors: true
          infraAgentInjection:
            # Injection policies can be defined here.  See [values file](https://github.com/newrelic/newrelic-infra-operator/blob/main/charts/newrelic-infra-operator/values.yaml#L114-L125) for more detail.
            policies:
            - namespaceName: namespace-a
            - namespaceName: namespace-b

      newrelic-infrastructure:
        # Deploys the Infrastructure Daemonset to EC2 nodes.  Disable for Fargate-only clusters.
        enabled: true

      nri-metadata-injection:
        # Deploy our mutating admission webhook to link APM and Kubernetes entities
        enabled: true

      kube-state-metrics:
        # Deploys Kube State Metrics.  Disable if you are already running KSM in your cluster.
        enabled: true

      nri-kube-events:
        # Deploy the Kubernetes events integration.
        enabled: true

      newrelic-logging:
        # Deploys the New Relic's Fluent Bit daemonset to EC2 nodes.  Disable for Fargate-only clusters.
        enabled: true

      newrelic-prometheus-agent:
        # Deploys the Prometheus agent for scraping Prometheus endpoints.
        enabled: true
        config:
          kubernetes:
            integrations_filter:
              enabled: true
              source_labels: ["app.kubernetes.io/name", "app.newrelic.io/name", "k8s-app"]
              app_values: ["redis", "traefik", "calico", "nginx", "coredns", "kube-dns", "etcd", "cockroachdb", "velero", "harbor", "argocd", "istio"]
      ```

      Finalmente, depois de criar e ajustar o arquivo, você pode implantar a solução usando o seguinte comando do Helm:

      ```shell
      helm upgrade --install newrelic-bundle newrelic/nri-bundle -n newrelic --create-namespace -f values.yaml
      ```

      <Callout variant="important">
        Ao implantar a solução em um cluster híbrido (com nós EC2 e Fargate), certifique-se de que a solução não esteja selecionada por nenhum perfil Fargate; caso contrário, a instância `DaemonSet` ficará presa em um estado pendente. Para ambientes somente fargate, isso não é uma preocupação porque nenhuma instância `DaemonSet` é criada.
      </Callout>

      #### Configuração [#config-auto]

      Você pode configurar diferentes aspectos da injeção automática. Por padrão, o operador injetará o sidecar de monitoramento em todos os pods implantados em nós Fargate que não fazem parte de um `Job` ou de um `BatchJob`.

      Este comportamento pode ser alterado através de opções de configuração. Por exemplo, você pode definir seletores para restringir ou ampliar a seleção de pods injetados, atribuir recursos ao operador e ajustar o arquivo secundário. Além disso, você pode adicionar outros atributos, rótulos e variáveis de ambiente. Consulte o gráfico [README.md](https://github.com/newrelic/helm-charts/blob/master/charts/newrelic-infra-operator/README.md) e [values.yaml](https://github.com/newrelic/helm-charts/blob/master/charts/newrelic-infra-operator/values.yaml).

      <Callout variant="important">
        Especificar suas próprias regras de injeção personalizadas descartará o conjunto de regras padrão que impede a injeção de sidecar em pods que não estão programados no Fargate. Certifique-se de que suas regras personalizadas tenham o mesmo efeito; caso contrário, no cluster híbrido que também possui o `DaemonSet` implantado, o pod programado no EC2 será monitorado duas vezes, levando a dados incorretos ou duplicados.
      </Callout>

      #### Atualize para a versão mais recente ou para uma nova configuração [#update-auto-install-version]

      Para atualizar para a versão mais recente da integração do EKS Fargate, atualize o repositório Helm usando `helm repo update newrelic` e reinstale o pacote simplesmente executando novamente o comando acima.

      Para atualizar a configuração do agente de infraestrutura injetado ou do próprio operador, modifique o `values-newrelic.yaml` e faça upgrade da versão do Helm com a nova configuração. O operador é atualizado imediatamente e sua carga de trabalho será instrumentada com a nova versão na próxima reinicialização. Se desejar atualizá-los imediatamente, você pode forçar a reinicialização da sua carga de trabalho executando:

      ```shell
      kubectl rollout restart deployment YOUR_APP
      ```

      #### Desinstale a integração do Fargate [#uninstall-auto-injection]

      Para desinstalar o sidecar realizando a injeção automática, mas manter o restante da solução New Relic, usando Helm, desative o infra-operador configurando `infra-operator.enabled` como `false`, no arquivo `values.yaml` ou na linha de comando (`--set`) e execute novamente o comando de instalação acima.

      É altamente recomendável manter o sinalizador `--set global.fargate=true` , pois ele não permite a injeção automática, mas torna outros componentes da instalação cientes do Fargate, evitando comportamentos indesejados.

      Para desinstalar toda a solução:

      1. Desinstale completamente a versão do Helm.

      2. Abra o pod para remover o sidecar:

         ```shell
         kubectl rollout restart deployment YOUR_APP
         ```

      3. Lixo colete os segredos:

         ```shell
         kubectl delete secrets -n YOUR_NAMESPACE -l newrelic/infra-operator-created=true
         ```

      #### Limitações conhecidas: injeção automática [#known-limitations]

      Aqui estão alguns problemas que você deve estar ciente ao usar a injeção automática:

      1. Atualmente não há nenhum controlador que monitore todo o cluster para garantir que os segredos que não são mais necessários sejam coletados como lixo. No entanto, todos os objetos compartilham o mesmo rótulo que pode ser usado para remover todos os recursos, se necessário. Injetamos o rótulo `newrelic/infra-operator-created: true`, que você pode usar para excluir recursos com um único comando.
      2. No momento, não é possível usar o sidecar injetado para monitor serviços em execução no pod. O sidecar monitor apenas o próprio Kubernetes . Porém, o usuário avançado pode querer excluir esses pods da injeção automática e injetar manualmente uma versão customizada do sidecar com integração no host habilitada, configurando-os e montando sua configuração no local apropriado. Para obter ajuda, consulte este [tutorial](/docs/integrations/kubernetes-integration/link-apps-services/tutorial-monitor-redis-running-kubernetes/).

      ### Injeção manual [#manual]

      Se você tiver alguma dúvida sobre a injeção automática, poderá injetar o sidecar manualmente diretamente, modificando os manifestos da carga de trabalho agendada que será agendada nos nós Fargate. Observe que adicionar o sidecar à implantação agendada em nós EC2 pode levar a dados incorretos ou duplicados, especialmente se esses nós já estiverem sendo monitorados com o `DaemonSet`.

      Os seguintes objetos são necessários para que o arquivo secundário relate dados com êxito:

      * O `ClusterRole` fornece a permissão necessária para a integração `nri-kubernetes`
      * Um `ClusterRoleBinding` vinculando o `ClusterRole` e a conta de serviço do pod
      * O segredo que armazena a New Relic `licenseKey` em cada namespaceFargate
      * O contêiner sidecar no modelo de especificação da workloaddo monitor

      #### Instalação de injeção manual [#manual-injection-install]

      <Callout variant="tip">
        Estas etapas de configuração manual são para uma instalação genérica. Antes de concluí-los, dê uma olhada na seção [de configuração](#config-manual) abaixo para ver se deseja modificar algum aspecto da injeção automática.
      </Callout>

      Complete o seguinte para injeção manual:

      1. Se `ClusterRole` não existir, crie-o e conceda as permissões necessárias para atingir o endpoint métrico. Isso só precisa ser feito uma vez, mesmo para monitoramento de vários aplicativos no mesmo cluster.

         <CollapserGroup>
           <Collapser
             id="cluster-role"
             title="Função do Cluster"
           >
             Você pode usar este trecho conforme aparece abaixo, sem nenhuma alteração:

             ```yml
             apiVersion: rbac.authorization.k8s.io/v1
             kind: ClusterRole
             metadata:
               labels:
                 app: newrelic-infrastructure
               name: newrelic-newrelic-infrastructure-infra-agent
             rules:
             - apiGroups:
               - ""
               resources:
               - nodes
               - nodes/metrics
               - nodes/stats
               - nodes/proxy
               - pods
               - services
               verbs:
               - get
               - list
             - nonResourceURLs:
               - /metrics
               verbs:
               - get
             ```
           </Collapser>
         </CollapserGroup>

      2. Para cada workload que você deseja monitor, adicione um contêiner secundário adicional para a imagem `newrelic/infrastructure-k8s`. Aqui está um exemplo de um sidecar injetado.

         <CollapserGroup>
           <Collapser
             id="container-to-inject"
             title="ContainerToInject"
           >
             Pegue o contêiner do trecho a seguir e injete-o na workload que deseja monitor, especificando o nome do seu `FargateProfile` na variável `customAttributes`. Observe que os volumes podem ser definidos como `emptyDir: {}`.

             <Callout variant="tip">
               No caso especial de uma implantação KSM, você também precisa remover a variável de ambiente `DISABLE_KUBE_STATE_METRICS` e aumentar as solicitações e limites de recursos.
             </Callout>

             ```yml
             apiVersion: apps/v1
             kind: Deployment
             spec:
             template:
             spec:
             containers:
             - name: newrelic-infrastructure
               env:
               - name: NRIA_LICENSE_KEY
                 valueFrom:
                   secretKeyRef:
                     key: license
                     name: newrelic-newrelic-infrastructure-config
               - name: NRIA_VERBOSE
                 value: "1"
               - name: DISABLE_KUBE_STATE_METRICS
                 value: "true"
               - name: CLUSTER_NAME
                 value: testing-injection
               - name: COMPUTE_TYPE
                 value: serverless
               - name: NRK8S_NODE_NAME
                 valueFrom:
                   fieldRef:
                     apiVersion: v1
                     fieldPath: spec.nodeName
               - name: NRIA_DISPLAY_NAME
                 valueFrom:
                   fieldRef:
                     apiVersion: v1
                     fieldPath: spec.nodeName
               - name: NRIA_CUSTOM_ATTRIBUTES
                 value: '{"clusterName":"$(CLUSTER_NAME)", "computeType":"$(COMPUTE_TYPE)", "fargateProfile":"[YOUR FARGATE PROFILE]"}'
               - name: NRIA_PASSTHROUGH_ENVIRONMENT
                 value: KUBERNETES_SERVICE_HOST,KUBERNETES_SERVICE_PORT,CLUSTER_NAME,CADVISOR_PORT,NRK8S_NODE_NAME,KUBE_STATE_METRICS_URL,KUBE_STATE_METRICS_POD_LABEL,TIMEOUT,ETCD_TLS_SECRET_NAME,ETCD_TLS_SECRET_NAMESPACE,API_SERVER_SECURE_PORT,KUBE_STATE_METRICS_SCHEME,KUBE_STATE_METRICS_PORT,SCHEDULER_ENDPOINT_URL,ETCD_ENDPOINT_URL,CONTROLLER_MANAGER_ENDPOINT_URL,API_SERVER_ENDPOINT_URL,DISABLE_KUBE_STATE_METRICS,DISCOVERY_CACHE_TTL
               image: newrelic/infrastructure-k8s:2.4.0-unprivileged
               imagePullPolicy: IfNotPresent
               resources:
                 limits:
                   memory: 100M
                   cpu: 200m
                 requests:
                   cpu: 100m
                   memory: 50M
               securityContext:
                 allowPrivilegeEscalation: false
                 readOnlyRootFilesystem: true
                 runAsUser: 1000
               terminationMessagePath: /dev/termination-log
               terminationMessagePolicy: File
               volumeMounts:
               - mountPath: /var/db/newrelic-infra/data
                 name: tmpfs-data
               - mountPath: /var/db/newrelic-infra/user_data
                 name: tmpfs-user-data
               - mountPath: /tmp
                 name: tmpfs-tmp
               - mountPath: /var/cache/nr-kubernetes
                 name: tmpfs-cache
             [...]
             ```
           </Collapser>
         </CollapserGroup>

      3. Crie um `ClusterRoleBinding`, ou adicione a um já criado o `ServiceAccount` do aplicativo que será monitorado. Toda a carga de trabalho pode compartilhar o mesmo `ClusterRoleBinding`, mas o `ServiceAccount` de cada uma deve ser adicionado a ela.

         <CollapserGroup>
           <Collapser
             id="cluster-role-binding"
             title="ClusterRoleBinding"
           >
             Crie o seguinte `ClusterRoleBinding` que tenha como assuntos a conta de serviço do pod que você deseja monitor.

             <Callout variant="tip">
               Você não precisa repetir a mesma conta de serviço duas vezes. Cada vez que você quiser monitor um pod com uma conta de serviço que ainda não esteja incluída, basta adicioná-lo à lista.
             </Callout>

             ```yml
             apiVersion: rbac.authorization.k8s.io/v1
             kind: ClusterRoleBinding
             metadata:
               name: newrelic-newrelic-infrastructure-infra-agent
             roleRef:
               apiGroup: rbac.authorization.k8s.io
               kind: ClusterRole
               name: newrelic-newrelic-infrastructure-infra-agent
             subjects:
             - kind: ServiceAccount
               name: [INSERT_SERVICE_ACCOUNT_NAME_OF_WORKLOAD]
               namespace: [INSERT_SERVICE_ACCOUNT_NAMESPACE_OF_WORKLOAD]
             ```
           </Collapser>
         </CollapserGroup>

      4. Crie um segredo contendo a New Relic <InlinePopover type="licenseKey"/>. Cada namespace precisa de seu próprio segredo.

         <CollapserGroup>
           <Collapser
             id="secret"
             title="Segredo"
           >
             Crie o seguinte `Secret` que tenha uma licença com o valor codificado em Base64 do seu <InlinePopover type="licenseKey"/>. É necessário um segredo em cada namespace onde um pod que você deseja monitor está em execução.

             ```yml
             apiVersion: v1
             data:
               license: INSERT_YOUR_NEW_RELIC_LICENSE_ENCODED_IN_BASE64
               kind: Secret
             metadata:
               name: newrelic-newrelic-infrastructure-config
               namespace: [INSERT_NAMESPACE_OF_WORKLOAD]
               type: Opaque
             ```
           </Collapser>
         </CollapserGroup>

      #### Configuração [#config-manual]

      Ao adicionar manualmente o manifesto do agente secundário, você pode usar qualquer opção de configuração do agente para configurar o comportamento do agente. Para obter ajuda, consulte [Definições de configuração do agente de infraestrutura](/docs/infrastructure/install-infrastructure-agent/configuration/infrastructure-agent-configuration-settings/).

      #### Atualize para a versão mais recente [#manual-update-version]

      Para atualizar qualquer um dos componentes, basta modificar o yaml implantar.

      Atualizar qualquer um dos campos do contêiner injetado fará com que o pod seja recriado.

      <Callout variant="important">
        O agente não pode carregar a quente a New Relic <InlinePopover type="licenseKey"/>. Após atualizar o segredo, é necessário implantar novamente a implantação.
      </Callout>

      #### Desinstale a integração do Fargate [#manual-uninstall]

      Para remover o contêiner injetado e os recursos relacionados, basta remover o seguinte:

      * O sidecar da carga de trabalho que não deve mais ser monitorado.
      * Todos os segredos que contêm a licença newrelic.
      * `ClusterRole` e `ClusterRoleBinding` objetos.

      Observe que a remoção do contêiner secundário fará com que o pod seja recriado.

      ## Exploração madeireira [#fargate-logging]

      O registro em log do New Relic não está disponível em nós do Fargate devido a restrições de segurança impostas pela AWS, mas aqui estão algumas opções de registro:

      * Se você estiver usando o Fluentbit para registro, consulte [Plug-inKubernetes para encaminhamento de logs](/docs/logs/forward-logs/kubernetes-plugin-log-forwarding/).
      * Se seus dados log já estiverem sendo monitorados pelo AWS FireLens, consulte [Plug-in AWS FireLens para encaminhamento de logs](/docs/logs/forward-logs/aws-firelens-plugin-log-forwarding/).
      * Se os dados log já estiverem sendo monitorados pelo log do Amazon CloudWatch, consulte [Transmitir log usando o Kinesis Data Firehose](/docs/logs/forward-logs/stream-logs-using-kinesis-data-firehose/).
      * Consulte [AWS Lambda para enviar log do CloudWatch](/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/).
      * Consulte [Três maneiras de encaminhar log do Amazon ECS para New Relic](https://newrelic.com/blog/how-to-relic/forward-logs-from-amazon-ecs-to-new-relic).

      ## Resolução de problemas [#troubleshooting]

      ### Réplicas do DaemonSet estão sendo implantadas em nós Fargate

      Se você notar que alguma réplica do Infra `DaemonSet` está sendo programada em nós do Fargate, pode ser porque as regras `nodeAffinity` não estão configuradas corretamente.

      Verifique novamente se a solução foi instalada com a opção `global.fargate` para `true`, por meio da linha de comando (`--set global.fargate=true`) ou no arquivo `values.yaml` . Se o método de instalação não for Helm, você precisará adicionar manualmente `nodeAffinity` regras para excluir nós do Fargate.

      ### Evento `FailedScheduling` devido a contaminação não tolerada

      Lembre-se de adicionar no arquivo `values.yaml` o `tolerations` descrito em [Instalação de injeção automática](#auto-injection-install) se você receber o seguinte evento ao tentar criar um pod:

      ```
      LAST SEEN | TYPE | REASON | OBJECT | MESSAGE
      :--|:--|:--|:--|:--
      3m9s (x2 over 8m10s) | Warning | FailedScheduling | Pod/no-fargate-deploy-cbddd6ccf-8f9x4 | 0/2 nodes are available: 2 node(s) had untolerated taint {eks.amazonaws.com/compute-type: fargate}. preemption: 0/2 nodes are available: 2 Preemption is not helpful for scheduling..
      ```

      ### Evento `FailedScheduling` devido a muitos pods

      Verifique se há um perfil do Fargate com um seletor que nomeie o namespace onde a instalação está ocorrendo se você receber o seguinte evento ao tentar criar um pod:

      ```
      LAST SEEN | TYPE | REASON | OBJECT | MESSAGE
      :--|:--|:--|:--|:--
      61s | Warning | FailedScheduling | Pod/newrelic-bundle-newrelic-infra-operator-admission-create-d8ggt | 0/2 nodes are available: 2 Too many pods. preemption: 0/2 nodes are available: 2 No preemption victims found for incoming pod..
      ```

      ## Veja seus dados EKS [#view-data]

      Aqui está um exemplo da aparência de um nó Fargate na interface New Relic :

      <img
        title="Screenshot showing the Kubernetes explorer with a Fargate node"
        alt="Screenshot showing the Kubernetes explorer with a Fargate node"
        src={kubernetesFargateUi}
      />

      Para visualizar seus dados da AWS:

      1. Vá para

         <DoNotTranslate>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Infrastructure > Kubernetes**</DoNotTranslate>

         e siga um destes procedimentos:

         * Selecione um nome de integração para visualizar os dados.
         * Selecione o ícone Explorar dados para visualizar os dados da AWS.

      2. Filtre seus dados usando duas tags Fargate:

         * `computeType=serverless`
         * `fargateProfile=[name of the Fargate profile to which the workload belongs]`
    </TabsPageItem>

    <TabsPageItem id="man-helm">
      Se quiser usar o Helm para instalar a integração, você tem duas opções:

      1. Nossa experiência de instalação guiada, que fornecerá um comando Helm com os campos obrigatórios pré-preenchidos. Esta opção também permite instalar nossa integração como manifestos simples, em vez de uma versão do Helm.
      2. Configuração manual através do arquivo `values.yaml` . Esta guia irá guiá-lo sobre como fazer isso.

      [Helm](https://helm.sh/) é um gerenciador de pacotes baseado no Kubernetes. Facilita a instalação, atualizações ou rastreamento de revisão e gerencia a dependência dos serviços que você instala no Kubernetes. Se ainda não o fez, crie sua conta New Relic gratuita abaixo para começar a monitorar seus dados hoje mesmo.

      <ButtonLink
        role="button"
        to="https://onenr.io/0Y8wpoYJJQO"
        variant="primary"
      >
        Inicie o instalador
      </ButtonLink>

      ## Compatibilidade e requisitos [#compatibility]

      Certifique-se de que [o Helm](https://github.com/helm/helm#install) esteja instalado em sua máquina. A versão 3 da integração do Kubernetes requer a versão 3 do Helm.

      Para instalar a integração do Kubernetes usando Helm, você precisará do New Relic <InlinePopover type="licenseKey"/>e do nome do cluster do Kubernetes:

      1. Encontre e copie seu <InlinePopover type="licenseKey"/>.

      2. Escolha um nome de exibição para seu cluster. Por exemplo, você poderia usar a saída de:

         ```shell
         kubectl config current-context
         ```

      <Callout variant="important">
        Mantenha esses valores em um local seguro, pois você precisará deles posteriormente durante o processo de instalação.
      </Callout>

      ## Instale a integração do Kubernetes com Helm [#install-k8-helm]

      New Relic possui vários gráficos Helm para os diferentes componentes que oferecem diferentes recursos para a plataforma:

      * [`newrelic-infrastructure`](https://github.com/newrelic/nri-kubernetes/tree/main/charts/newrelic-infrastructure): contém a integração principal do Kubernetes e o agente de infraestrutura. Este é o componente principal da New Relic Kubernetes experiência do , responsável por relatar a maioria dos dados que aparecem no Kubernetes dashboard e no cluster do Kubernetes Explorer.
      * [`newrelic-logging`](https://github.com/newrelic/helm-charts/tree/master/charts/newrelic-logging): Fornece um DaemonSet com o New Relic [plug-in](https://github.com/newrelic/newrelic-fluent-bit-output) de saída [Fluent Bit](https://fluentbit.io/) da para encaminhar facilmente seu log para [New Relic](/docs/logs/new-relic-logs/get-started/introduction-new-relic-logs).
      * [`nri-kube-events`](https://github.com/newrelic/nri-kube-events/tree/main/charts/nri-kube-events): coleta e relata eventos cluster (como `kubectl get events`) para New Relic.
      * [`newrelic-prometheus-agent`](https://github.com/newrelic/newrelic-prometheus-configurator/tree/main/charts/newrelic-prometheus-agent): O Prometheus Configurator do New Relic configura um [Prometheus no modo agente](/docs/infrastructure/prometheus-integrations/install-configure-prometheus-agent/install-prometheus-agent) e usa nosso endpoint de gravação remota para [relatar métricas para New Relic](/docs/infrastructure/prometheus-integrations/get-started/send-prometheus-metric-data-new-relic/#remote-write).
      * [`nri-metadata-injection`](https://github.com/newrelic/k8s-metadata-injection/tree/main/charts/nri-metadata-injection): configura um `MutatingAdmissionWebhook` mínimo que injeta algumas variáveis de ambiente no contêiner. Estes contêm metadados sobre o cluster e instalação New Relic e serão posteriormente captados pelo aplicativo instrumentado usando APM, permitindo [correlacionar dados APM e infraestrutura](/docs/integrations/kubernetes-integration/link-your-applications/link-your-applications-kubernetes/).
      * [`nri-statsd`](https://github.com/newrelic/helm-charts/tree/master/charts/nri-statsd): Integração New Relic StatsD.

      Embora você possa instalar esses componentes separadamente, recomendamos fortemente que você use a tabela [`nri-bundle`](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle) . A New Relic fornece este gráfico, que atua como um wrapper ou metapacote para os gráficos individuais mencionados acima. O uso deste gráfico permite estas vantagens:

      * Ele fornece controle total sobre quais componentes estão instalados. Cada componente é instalado como uma [dependência separada do Helm](https://helm.sh/docs/chart_template_guide/subcharts_and_globals/#overriding-values-from-a-parent-chart). Você pode configurá-los individualmente usando o parâmetro mencionado [aqui](#configure).
      * Ele garante que as versões instaladas sejam compatíveis entre si.
      * Ele garante que seus valores de configuração sejam consistentes nos gráficos instalados.

      O gráfico `nri-bundle` é aquele instalado e configurado por nossa [instalação guiada do Kubernetes](/docs/kubernetes-pixie/kubernetes-integration/installation/kubernetes-integration-install-configure#guided-install).

      ### Instalando e configurando `nri-bundle` com Helm

      1. Certifique-se de usar o contexto apropriado na máquina onde executará o Helm e `kubectl`:

         Você pode verificar os contextos disponíveis com:

         ```shell
         kubectl config get-contexts
         ```

         E mude para o contexto desejado usando:

         ```shell
         kubectl config use-context _CONTEXT_NAME_
         ```

      2. Adicione o repositório de gráficos do New Relic Helm:

         ```shell
         helm repo add newrelic https://helm-charts.newrelic.com
         ```

      3. Crie um arquivo chamado `values-newrelic.yaml`, que será usado para definir sua configuração:

         ```yaml
         global:
           licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
           cluster: _K8S_CLUSTER_NAME_

         newrelic-prometheus-agent:
           # Automatically scrape prometheus metrics for annotated services in the cluster
           # Collecting prometheus metrics for large clusters might impact data usage significantly
           enabled: true
         nri-metadata-injection:
           # Deploy our webhook to link APM and Kubernetes entities
           enabled: true
         nri-kube-events:
           # Report Kubernetes events
           enabled: true
         newrelic-logging:
           # Report logs for containers running in the cluster
           enabled: true
         kube-state-metrics:
           # Deploy kube-state-metrics in the cluster.
           # Set this to true unless it is already deployed.
           enabled: true
         ```

      4. Certifique-se de que tudo esteja configurado corretamente no gráfico executando o seguinte comando. Observe que estamos especificando `--dry-run` e `--debug`, portanto nada será instalado nesta etapa:

         ```shell
         helm upgrade --install newrelic-bundle newrelic/nri-bundle \
         --namespace newrelic --create-namespace \
         -f values-newrelic.yaml \
         --dry-run \
         --debug
         ```

         Observe e ajuste os seguintes sinalizadores:

         * `global.licenseKey=YOUR_NEW_RELIC_LICENSE_KEY`: deve ser definido como um

           <InlinePopover type="licenseKey"/>

           válido para sua conta.

         * `global.cluster=K8S_CLUSTER_NAME`: É usado para identificar o cluster na interface New Relic , portanto deve ser um valor descritivo não usado por nenhum outro cluster do Kubernetes configurado em sua conta New Relic .

         * `kube-state-metrics.enabled=true`: Definir como `true` instalará automaticamente a Kube State métrica (KSM) para você, que é necessária para o funcionamento de nossa integração. Você pode definir isso como falso se o KSM já estiver presente em seu cluster, mesmo que esteja em um namespace diferente.

         * `newrelic-prometheus-agent.enabled=true`: Iremos implantar nosso agente Prometheus, que coleta automaticamente dados do endpoint Prometheus presente no cluster.

         * `nri-metadata-injection.enabled=true`: instalará nosso webhook mínimo, que adiciona variáveis de ambiente que, por sua vez, permite [vincular o aplicativo instrumentado com New Relic APM ao Kubernetes](/docs/kubernetes-pixie/kubernetes-integration/link-your-applications/link-your-applications-kubernetes).

         Nossos gráficos do Kubernetes possuem um conjunto abrangente de sinalizadores e ajustes que podem ser editados para melhor atender às suas necessidades específicas. Por favor, verifique a seção [Configurar a integração](#configure) abaixo para ver o que pode ser alterado.

      5. Instale a integração do Kubernetes executando o comando sem `--debug` e `--dry-run`:

         ```shell
         helm upgrade --install newrelic-bundle newrelic/nri-bundle \
         --namespace newrelic --create-namespace \
         -f values-newrelic.yaml
         ```

         <Callout variant="important">
           Verifique se você está usando o Kubernetes versão 1.27.x ou [uma versão inferior compatível com](/docs/kubernetes-pixie/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements).
         </Callout>

      6. Verifique se o pod está sendo implantado e atinge um estado estável:

         ```shell
         kubectl -n newrelic get pods -w
         ```

      Você deveria ver:

      * `newrelic-nrk8s-ksm` pod.
      * `newrelic-nrk8s-kubelet` pod para cada nó em seu cluster.
      * `newrelic-nrk8s-control-plane` pod para cada nó mestre em seu cluster, se houver.
      * `newrelic-kube-state-metrics` pod, se você incluiu o KSM em nossa instalação.
      * `newrelic-nri-kube-events` pod, se você ativou o relatório de eventos Kubernetes .
      * `prometheus-agent` pod, se você ativou a integração do [agente Prometheus](/docs/infrastructure/prometheus-integrations/install-configure-prometheus-agent/install-prometheus-agent) .
      * `newrelic-newrelic-logging` pod para cada nó em seu cluster, se você ativou a integração de criação de log.

      <InstallFeedback/>

      ## Configurar a integração [#configure]

      Nosso gráfico `nri-bundle` . cujas instruções de instalação podem ser encontradas acima, atua como um wrapper ou meta-pacote para alguns outros gráficos, que contêm os componentes de nossa solução. Ao oferecer esse wrapper, podemos fornecer um conjunto controlado de nossos componentes com versões que sabemos serem compatíveis entre si, mantendo os gráficos dos componentes relativamente simples.

      O gráfico [`nri-bundle`](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle) agrupa [vários gráficos individuais](#install-k8-helm) para coletar diferentes dados de telemetria e enviá-los para o New Relic. O pacote permite ativar seletivamente os gráficos secundários desejados, dependendo de suas necessidades. Para configurar cada componente individual, você deve usar [o sistema de dependência do Helm](https://helm.sh/docs/chart_template_guide/subcharts_and_globals/#overriding-values-from-a-parent-chart), o que, resumidamente, significa que a configuração de cada gráfico filho deve ser colocada em uma seção separada (nomeada após cada gráfico filho) no [arquivo values-newrelic.yml](https://helm.sh/docs/chart_template_guide/values_files/). Por exemplo, para configurar o gráfico `newrelic-infrastructure` , você adicionaria o seguinte ao `values-newrelic.yaml`:

      ```yaml
      # General settings that apply to all the child charts
      global:
        licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
        cluster: _K8S_CLUSTER_NAME_

      # ... Other settings as shown above

      # Specific configuration for the newrelic-infrastructure child chart
      newrelic-infrastructure:
        verboseLog: true  # Enable debug logs
        privileged: false  # Install with minimal privileges
        # Other options from https://github.com/newrelic/helm-charts/tree/master/charts/newrelic-infrastructure-v3

      # Specific configuration for the newrelic-logging child chart
      newrelic-logging:
        fluentBit:
        retryLimit: 10
      ```

      Você também pode passar opções de gráfico filho por meio da linha de comando, prefixando-as com o nome do gráfico filho e substituindo o aninhamento por pontos:

      ```
      helm upgrade --install newrelic-bundle newrelic/nri-bundle \
      --namespace=newrelic \
      --set global.licenseKey=_YOUR_NEW_RELIC_LICENSE_KEY_ \
      --set global.cluster=_K8S_CLUSTER_NAME_ \
      --set newrelic-infrastructure.privileged=false \
      --set newrelic-infrastructure.verboseLog=true \
      --set newrelic-logging.fluentBit.retryLimit=10
      ```

      A lista completa de flags que você pode ajustar (como [scrape-interval](/docs/new-relic-solutions/observability-maturity/operational-efficiency/data-governance-optimize-ingest-guide#k8s-integration)) para cada gráfico filho pode ser encontrada em seus respectivos repositórios:

      * [`newrelic-infrastructure`](https://github.com/newrelic/nri-kubernetes/tree/main/charts/newrelic-infrastructure)
      * Configurar log de depuração, modo de privilégio, monitoramento do plano de controle, etc.
      * [`nri-kube-events`](https://github.com/newrelic/nri-kube-events/tree/main/charts/nri-kube-events)
      * [`nri-metadata-injection`](https://github.com/newrelic/k8s-metadata-injection/tree/main/charts/nri-metadata-injection)
      * Configure como o webhook para ligação APM é implantado.
      * Configure quais endpoints do Prometheus serão copiados.
      * [`newrelic-logging`](https://github.com/newrelic/helm-charts/tree/master/charts/newrelic-logging)
      * Configure qual log ou atributo log será enviado para New Relic.

      <Callout variant="tip">
        Ao especificar opções de configuração para os gráficos secundários, você deve colocá-los em uma seção com o nome do gráfico em seu `values-newrelic.yaml`.
      </Callout>

      <Callout variant="tip">
        Para passar opções de gráfico filho por meio da linha de comando, você precisa prefixá-las com o nome do gráfico filho e substituir o aninhamento por pontos.
      </Callout>
    </TabsPageItem>

    <TabsPageItem id="gke-autopilot">
      Há três maneiras de instalar a integração do Kubernetes no cluster do GKE Autopilot:

      * A CLI do New Relic encontrada em nossa instalação guiada
      * Um comando Helm com valores obrigatórios pré-preenchidos
      * Um manifesto simples com valores obrigatórios pré-preenchidos

      <CollapserGroup>
        <Collapser
          id="guided-gke"
          title="Instalação guiada (recomendada)"
        >
          Você pode instalar no piloto automático do GKE usando o mesmo fluxo de instalação da nossa guia [de instalação guiada](/docs/kubernetes-pixie/kubernetes-integration/installation/kubernetes-integration-install-configure/#guided-install) .
        </Collapser>

        <Collapser
          id="helm-gke"
          title="Leme manual"
        >
          Seu comando completo do Helm deve ser semelhante ao seguinte:

          ```shell
          KSM_IMAGE_VERSION="v2.10.0" && \
          helm repo add newrelic https://helm-charts.newrelic.com && helm repo update && \
          kubectl create namespace newrelic ; helm upgrade --install newrelic-bundle newrelic/nri-bundle \
          --set global.licenseKey=<Your License Key> \
          --set global.cluster=<Your Cluster Name> \
          --namespace=newrelic \
          --set newrelic-infrastructure.privileged=false \
          --set newrelic-infrastructure.controlPlane.enabled=false \
          --set newrelic-infrastructure.kubelet.config.scheme=http \
          --set newrelic-infrastructure.kubelet.config.port=10255 \
          --set global.lowDataMode=true \
          --set kube-state-metrics.image.tag=${KSM_IMAGE_VERSION} \
          --set kube-state-metrics.enabled=true \
          --set kubeEvents.enabled=true \
          --set newrelic-prometheus-agent.enabled=true \
          --set newrelic-prometheus-agent.lowDataMode=true \
          --set newrelic-prometheus-agent.config.kubernetes.integrations_filter.enabled=false \
          --set newrelic-pixie.enabled=false
          --set logging.enabled=true 
          --set newrelic-logging.lowDataMode=true 
          --set newrelic-logging.fluentBit.linuxMountPath=/var/log  
          --set newrelic-logging.fluentBit.persistence.mode=persistentVolume 
          --set newrelic-logging.fluentBit.persistence.persistentVolume.storageClass=standard-rwx
          ```

          [O Fluent Bit](https://fluentbit.io/) pode usar um volume FileStore para evitar perda de dados ou log duplicado durante reinicializações ou reimplantações pod do Fluent Bit. O uso do FileStore acarreta custos adicionais, cobrados pelo Google. Recomendamos consultar seu administrador do Google Cloud ou visitar [a documentação do FileStore](https://cloud.google.com/filestore/pricing) para obter detalhes. A API Google FileStore precisa estar ativada no seu projeto do GKE. Verifique este [documento](https://support.google.com/googleapi/answer/6158841) para saber mais sobre como ativar API.

          Se você não quiser usar o FileStore, adicione o seguinte:

          * Defina `"newrelic-logging.fluentBit.persistence.mode"` como `"none"`
          * Remover `"newrelic-logging.fluentBit.persistence.persistentVolume.storageClass"`

          Verifique nossos [documentos do gráfico Helm](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle) para obter mais informações.
        </Collapser>

        <Collapser
          id="manifest-gke"
          title="Manifesto"
        >
          Atualize seu comando de manifesto com os seguintes sinalizadores:

          * Defina `"newrelic-infrastructure.privileged"`, `"newrelic-infrastructure.controlPlane.enabled"` como `false`.
          * Adicionar `"newrelic-infrastructure.kubelet.config.scheme":"http"`
          * Adicionar `"newrelic-infrastructure.kubelet.config.port":"10255"`
          * Adicionar `"logging.enabled":"true"`
          * Adicionar `"newrelic-logging.lowDataMode":"true"`
          * Adicionar `"newrelic-logging.fluentBit.linuxMountPath":"/var/log"`
          * Adicionar `"newrelic-logging.fluentBit.persistence.mode":"persistentVolume"`
          * Adicionar `"newrelic-logging.fluentBit.persistence.persistentVolume.storageClass":"standard-rwx"`
          * Remova o Pixie carga do comando, pois o Pixie não é compatível no momento com o GKE Autopilot.

          [O Fluent Bit](https://fluentbit.io/) pode usar um volume FileStore para evitar perda de dados ou log duplicado durante reinicializações ou reimplantações pod do Fluent Bit. O uso do FileStore acarreta custos adicionais, cobrados pelo Google. Recomendamos consultar seu administrador do Google Cloud ou visitar [a documentação do FileStore](https://cloud.google.com/filestore/pricing) para obter detalhes. A API Google FileStore precisa estar ativada no seu projeto do GKE. Verifique este [documento](https://support.google.com/googleapi/answer/6158841) para saber mais sobre como ativar API.

          Se você não quiser usar o FileStore, adicione o seguinte:

          * Defina `"newrelic-logging.fluentBit.persistence.mode"` como `"none"`
          * Remover `"newrelic-logging.fluentBit.persistence.persistentVolume.storageClass"`

          Aqui está um comando que cria um arquivo de manifesto e o aplica ao cluster:

          ```shell
          KSM_IMAGE_VERSION="v2.10.0" && \
          curl -X POST https://k8s-config-generator.service.newrelic.com/generate -H 'Content-Type: application/json' -d '{"global.cluster":"<Your Cluster Name>","global.namespace":"newrelic","newrelic-infrastructure.privileged":"false","newrelic-infrastructure.controlPlane.enabled":"false","newrelic-infrastructure.kubelet.config.scheme":"http","newrelic-infrastructure.kubelet.config.port":"10255","global.lowDataMode":"true","kube-state-metrics.image.tag":"'${KSM_IMAGE_VERSION}'","kube-state-metrics.enabled":"true","kubeEvents.enabled":"true","newrelic-prometheus-agent.enabled":"true","newrelic-prometheus-agent.lowDataMode":"true","newrelic-prometheus-agent.config.kubernetes.integrations_filter.enabled":"false","logging.enabled":"true", "newrelic-logging.lowDataMode":"true", "newrelic-logging.fluentBit.linuxMountPath":"/var/log", "newrelic-logging.fluentBit.persistence.mode":"persistentVolume", "newrelic-logging.fluentBit.persistence.persistentVolume.storageClass":"standard-rwx","global.licenseKey":"<Your License Key"}'  > newrelic.yaml && (kubectl create namespace newrelic ; kubectl apply -f newrelic.yaml)
          ```
        </Collapser>
      </CollapserGroup>
    </TabsPageItem>
  </TabsPages>
</Tabs>

## Use seus dados do Kubernetes

Aprender mais sobre:

* [Modos sem privilégios e privilegiados](/docs/infrastructure/install-infrastructure-agent/linux-installation/linux-agent-running-modes)
* [Explorando seus dados Kubernetes na interface](/docs/kubernetes-pixie/kubernetes-integration/understand-use-data/kubernetes-cluster-explorer)
* [Utilizando seus dados Kubernetes ](/docs/kubernetes-pixie/kubernetes-integration/understand-use-data/find-use-your-kubernetes-data)com consultas, em gráficos, para alertas, etc.

<InstallFeedback/>