---
title: Configurar a lógica de correlação com decisões
metaDescription: 'For New Relic''s alerts, how to configure the correlation logic using decisions.'
freshnessValidatedDate: never
translationType: machine
---

Com a lógica de correlação de alertas, os problemas relacionados são agrupados para reduzir alertas distrativos e redundantes. À medida que entram no seu sistema, eles são elegíveis para nossa lógica de correlação. Os problemas elegíveis são avaliados com base no tempo, no contexto do alerta e nos dados de relacionamento. Se vários problemas estiverem relacionados, nossa lógica de correlação agrupará o incidente relacionado em um [problema](/docs/alerts-applied-intelligence/overview/#concepts-terms) único e abrangente.

Chamamos essa lógica de correlação <DNT>**decisions**</DNT>. Temos decisões integradas, mas você também pode criar e personalizar as suas próprias na página de decisões. Para encontrar a página de decisões, acesse <DNT>**[one.newrelic.com &gt; All capabilities](https://one.newrelic.com/all-capabilities) &gt; Alerts &gt; Decisions**</DNT>. Quanto mais você configurar suas decisões para melhor atender às suas necessidades, melhor o New Relic poderá correlacionar seu incidente, reduzir o ruído e fornecer maior contexto para as equipes de plantão.

<img title="NRAI_Decisions_Page.png" alt="A screenshot that shows the alert decisions UI." src="/images/alerts_screenshot-full_new-relic-decisions-page.webp" />

<figcaption>
  <DNT>**[one.newrelic.com &gt; All capabilities](https://one.newrelic.com/all-capabilities) &gt; Alerts &gt; Incident intelligence &gt; Decisions**</DNT>: Nossa interface mostra como cada decisão se correlaciona com o incidente.
</figcaption>

## O que é correlação e como funciona? [#what-is-correlaton]

Seus incidentes mais recentes e ativos estão disponíveis para nossa lógica de correlação. Por exemplo, digamos que seu sistema recebeu dois alertas informando que um monitor Sintético está falhando na Austrália e em Londres. Estes dois alertas terão criado o seu próprio incidente único. Esses incidentes gerarão seus próprios problemas exclusivos com base na [política de criação de incidentes](/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/specify-when-alerts-create-incidents/#preference-target) existente em sua equipe. A lógica de correlação da New Relic irá então testar esses incidentes entre si para encontrar semelhanças. Nesse caso, é o mesmo monitor que está falhando em vários locais, então a New Relic mesclará ambos os incidentes em um único problema que contém cada evento relevante.

Quando correlacionamos um evento, comparamos cada par de combinações entre si e combinamos o maior número possível. Por exemplo:

* Nosso algoritmo correlaciona os incidentes A e B (chame-o de &quot;AB&quot;).
* Nosso algoritmo correlaciona os incidentes B e C (chame-o de &quot;BC&quot;).
* Como B está presente em ambos os problemas, o algoritmo correlaciona todos os três incidentes em um único problema.

## Configurar política de correlação [#configure-correlation]

Para ativar a correlação em problemas baseados em [alertas](/docs/alerts-applied-intelligence/overview/#concepts-terms) , você precisará conectar-se à correlação para a respectiva [política de alertas](/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/create-edit-or-find-alert-policy/#alert-policy-name).

<img title="Decision - enable correlation for alert policy" alt="A screenshot of how to enable correlation for an alert policy." src="/images/alerts_screenshot-full_decision-policy-.webp" />

<figcaption>
  Marque a caixa <DNT>**Correlate and suppress noise**</DNT> para ativar a correlação para a política de alertas.
</figcaption>

## Tipos de decisão [#decision-types]

As decisões determinam como a inteligência do incidente correlaciona os problemas. A lógica de correlação do New Relic está disponível para sua equipe em três tipos de decisão diferentes:

* <DNT>**Global decision**</DNT>: um amplo conjunto de decisões padrão é ativado automaticamente quando você começa a usar alertas.
* <DNT>**Suggested decision**</DNT>: o mecanismo de correlação do New Relic avalia constantemente os dados do evento para sugerir decisões que capturem padrões de correlação para reduzir o ruído. Você pode visualizar os resultados da simulação de uma decisão sugerida e optar por ativá-la.
* <DNT>**Custom decision**</DNT>: sua equipe pode personalizar decisões com base no seu caso de uso para aumentar a eficácia da correlação. A interface de decisão do New Relic oferece flexibilidade para configurar todas as dimensões em uma decisão.

## Revise suas decisões ativas [#decisions]

Para revisar as decisões existentes de sua equipe:

1. Vá para <DNT>**[one.newrelic.com](https://one.newrelic.com/all-capabilities)&gt; Alerts &gt; Incident intelligence &gt; Decisions**</DNT>.
2. Revise a lista de decisões ativas. Para ver a lógica da regra que cria correlações entre seus problemas, clique na decisão.
3. Para ver exemplos de incidentes correlacionados à decisão, clique na guia <DNT>**Recent correlations**</DNT> .
4. Você tem a opção de ativar ou desativar essas decisões globais.

## Configurar fontes [#configure-sources]

Antes de configurar suas decisões, é importante determinar as fontes que você gostaria de correlacionar. Fontes são suas entradas de dados.

Você pode obter dados de qualquer uma das seguintes fontes:

<CollapserGroup>
  <Collapser className="freq-link" id="configure-source-nr-alerts" title="alerta">
    Ao habilitar a inteligência de incidentes para suas <InlinePopover type="alerts" />políticas, você pode obter contexto e correlações do que está monitorando. Para obter dados do alerta:

    1. Em <DNT>**[one.newrelic.com](https://one.newrelic.com/all-capabilities)**</DNT>, clique em <DNT>**Alerts**</DNT>.

    2. À esquerda, em <DNT>**Alerts**</DNT>, clique em <DNT>**Sources**</DNT> e, em seguida, clique em <DNT>**Alerts**</DNT>.

    3. Selecione as políticas que você deseja conectar aos alertas e clique em <DNT>**Connect**</DNT>.

       Você pode adicionar políticas de alertas adicionais ou remover políticas que você já conectou em <DNT>**Sources &gt; Alerts**</DNT>.

       <Callout variant="tip">
         Adicionar alerta como fonte não afetará sua configuração ou notificação atual.
       </Callout>
  </Collapser>

  <Collapser className="freq-link" id="configure-aporia" title="Aporia (MLOps)">
    Ao integrar a inteligência de incidentes aos seus modelos de aprendizado de máquina Aporia, você pode monitor o desempenho do seu modelo de aprendizado de máquina. Para configurar nossa integração Aporia, consulte nossa [documentação](/docs/integrations/mlops-integrations/aporia-mlops-integration/).
  </Collapser>

  <Collapser className="freq-link" id="configure-aporia" title="Supersábio (MLOps)">
    Ao integrar a inteligência de incidentes aos seus modelos de aprendizado de máquina Superwise, você pode monitor o desempenho do seu modelo de aprendizado de máquina. Para configurar nossa integração Superwise, consulte nossa [documentação](/docs/alerts-applied-intelligence/mlops/integrations/superwise-mlops-integration/).
  </Collapser>

  <Collapser className="freq-link" id="configure-source-rest-api" title="API REST">
    A inteligência oferece suporte a uma interface API REST dedicada que permite a integração com sistemas adicionais. A interface permite a instrumentação do seu código ou outras soluções de monitoramento para relatar qualquer tipo de métrica ou evento.

    * Uma métrica pode ser um ponto de dados brutos, como CPU, memória, utilização de disco ou KPI de negócios.

    * Um evento pode ser um alerta de monitoramento, um evento de implantação, um incidente, exceções ou qualquer outra alteração de estado que você queira descrever.

      Você também pode enviar qualquer tipo de dado para inteligência de incidentes direto de seus próprios sistemas ou aplicativos. A API REST oferece suporte à autenticação segura baseada em token e aceita conteúdo JSON como entrada.

      Para obter mais informações sobre autenticação e a referência completa da API, consulte [API REST para alertas New Relic](/docs/rest-api-new-relic-ai).
  </Collapser>
</CollapserGroup>

### Decisões globais [#global-decisions]

As decisões globais são ativadas automaticamente quando sua equipe começa a usar alertas. Eles não requerem configuração e estão imediatamente disponíveis para sua equipe. As decisões globais abrangem uma variedade de cenários de correlação.

A tabela abaixo fornece descrições de todas as decisões globais que são habilitadas automaticamente.

<table id="global-decision-descriptions">
  <thead>
    <tr>
      <th style={{ width: "250px" }}>
        Nome da decisão
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        Mesmo nome de destino New Relic (NRQL)
      </td>

      <td>
        A correlação é ativada quando o nome da entidade com limite excedido e a consulta NRQL são iguais. Será identificado evento relevante do mesmo [NRQL condição do alerta](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions) . Esta decisão ajuda a relacionar questões que possuem a mesma latência de consulta de transação do Desvio, por exemplo.
      </td>
    </tr>

    <tr>
      <td>
        Mesmo nome de destino New Relic (não NRQL)
      </td>

      <td>
        A correlação é ativada porque o limite de alerta não NRQL do New Relic é o mesmo. Não se aplica à origem REST. Entidade não NRQL refere-se a [entidade](/docs/new-relic-solutions/new-relic-one/core-concepts/what-entity-new-relic/), normalmente aplicativo, tipos HOST, consulte [o repositório New Relic GitHub na síntese de entidade](https://github.com/newrelic/entity-definitions#entity-definitions). Com esta decisão serão identificadas questões relevantes da mesma entidade. Por exemplo, problemas de alta memória do host e problemas de não relatório do host podem ser altamente possíveis devido à mesma causa.
      </td>
    </tr>

    <tr>
      <td>
        Mesmo ID de destino New Relic
      </td>

      <td>
        A correlação é ativada porque o limite de alerta não NRQL do New Relic é o mesmo. Não se aplica à origem REST. Use o ID da entidade para identificar exclusivamente uma instância da entidade. Saiba mais sobre [entity.guid](/docs/new-relic-solutions/new-relic-one/core-concepts/what-entity-new-relic#reserved-attributes).
      </td>
    </tr>

    <tr>
      <td>
        Mesma condição New Relic
      </td>

      <td>
        A correlação é ativada porque os [IDs de condição](/docs/new-relic-solutions/get-started/glossary/#condition_id) do New Relic são iguais. Por exemplo, o aumento do uso da CPU com serviços relacionados desencadeará um incidente da mesma condição de uso da CPU e, portanto, será identificado. Essa lógica é valiosa além [da opção de preferência de criação de problemas de política de alertas](/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/specify-when-alerts-create-incidents/#preference-options) para um problema por condição, devido à granularidade em nível de condição e à flexibilidade na definição da janela de tempo de correlação.
      </td>
    </tr>

    <tr>
      <td>
        Mesma condição New Relic e URL de link direto
      </td>

      <td>
        A correlação é ativada porque os [IDs de condição](/docs/new-relic-solutions/get-started/glossary/#condition_id) do New Relic e o URL do link direto são iguais. O URL do link direto fornece informações sobre séries temporais e intervalos de tempo, além da [condição do alerta](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-alert-conditions/). A correlação dessas questões facilita a visualização dos incidentes relacionados no fluxo de resposta a incidentes com métricas com escopo de tempo e a realização de análises profundas. O URL do link direto pode ser gerado automaticamente se os incidentes forem acionados pela condição de alerta do New Relic , enquanto para a fonte REST [o deepLinkUrl](/docs/data-apis/ingest-apis/event-api/incident-event-rest-api/#api-specs) deve ser definido pelo usuário.
      </td>
    </tr>

    <tr>
      <td>
        Mesma condição e título New Relic
      </td>

      <td>
        A correlação é ativada porque [os nomes e títulos das condições](/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/incident-event-attributes/#attributes) do New Relic são iguais. Esta é uma opção refinada, comparando títulos e condições para revelar maior relevância com a mesma mensagem de alerta.
      </td>
    </tr>

    <tr>
      <td>
        Mesma implantação k8s
      </td>

      <td>
        A lógica de correlação está ativada porque a implantação de kubernetes é a mesma. Muitos incidentes são decorrentes de alterações de implantação única. Esta decisão visa reduzir os problemas da mesma implantação problemática da entidade Kubernetes.
      </td>
    </tr>

    <tr>
      <td>
        Mesmo nome de aplicativo, política e ID
      </td>

      <td>
        A lógica de correlação é ativada porque o nome do aplicativo customizado, a política e o ID customizado são iguais. Correlacionamos problemas com esses elementos para reduzir problemas de aplicativos, principalmente para atender a tag personalizadas do usuário. Saiba mais sobre [etiqueta](/docs/new-relic-solutions/new-relic-one/core-concepts/use-tags-help-organize-find-your-data/). O ID da tag personalizada pode ser definido pelo ID da família de condições ou outros valores de ID usados como chave para identificar conexões entre dados.
      </td>
    </tr>

    <tr>
      <td>
        Mensagem de alerta semelhante
      </td>

      <td>
        A correlação é ativada porque os incidentes possuem títulos semelhantes e são da mesma entidade. Isto visa reduzir problemas da mesma entidade causados por [condições de alerta](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-alert-conditions/) semelhantes.
      </td>
    </tr>

    <tr>
      <td>
        Mesma credencial segura, localização pública e tipo
      </td>

      <td>
        A correlação é ativada porque a credencial segura, a localização pública e o tipo personalizado são iguais, respectivamente. Isso serve para correlacionar problemas da mesma localização/região geográfica com as mesmas credenciais de segurança que normalmente são acionadas por uma única causa raiz (por exemplo, falha no monitor Sintético) e podem ser altamente prováveis de serem resolvidas com a mesma solução. [Adicione tag](/docs/new-relic-solutions/new-relic-one/core-concepts/use-tags-help-organize-find-your-data/#add-tags) para se beneficiar desta decisão.
      </td>
    </tr>

    <tr>
      <td>
        Estrutura de problema semelhante
      </td>

      <td>
        A correlação é ativada porque ambos os incidentes possuem estrutura de atributos e conteúdos de dados semelhantes. Esta é uma versão mais simples do cluster, que adota algoritmos avançados de similaridade na computação matricial para reduzir problemas altamente relacionados.
      </td>
    </tr>

    <tr>
      <td>
        Topologicamente Dependente
      </td>

      <td>
        A correlação está ativada porque os incidentes são gerados a partir de instâncias que possuem relacionamentos dependentes. Saiba mais sobre [a correlação de topologia pronta para uso](#topology-requirements).
      </td>
    </tr>
  </tbody>
</table>

### Use decisões sugeridas [#suggested-decisions]

Os dados das fontes selecionadas são continuamente inspecionados em busca de padrões para ajudar a reduzir o ruído. Depois que os padrões forem observados em seus dados, nossa lógica de correlação sugerirá decisões exclusivas que permitiriam que esses tipos de eventos se correlacionassem no futuro.

Para começar, clique na guia <DNT>**Suggested decisions**</DNT> no tópico da página de interface <DNT>**Decisions**</DNT> . Você pode ver a lógica por trás da decisão sugerida e a taxa de correlação estimada clicando em cada decisão sugerida.

<img title="Suggested decision block" alt="A screenshot of a suggested decision block" src="/images/alerts_screenshot-full_suggested-decisions.webp" />

<figcaption>
  <DNT>**[one.newrelic.com &gt; All capabilities](https://one.newrelic.com/all-capabilities) &gt; Alerts &gt; Decisions**</DNT>: alguns exemplos de estatísticas da interface de decisões.
</figcaption>

Para ativar uma decisão sugerida, clique em <DNT>**Add to your decisions**</DNT>. Uma vez ativada, a decisão aparecerá na tabela de decisão principal da sua equipe. Todas as decisões sugeridas mostrarão o criador como New Relic AI (isso se refere aos alertas da New Relic).

Se a decisão sugerida não for relevante para suas necessidades, clique em <DNT>**Dismiss**</DNT>.

## Crie decisões personalizadas [#customize]

Você pode reduzir o ruído e melhorar a correlação criando suas próprias decisões personalizadas. Para começar a tomar uma decisão, vá para <DNT>**[one.newrelic.com &gt; All capabilities](https://one.newrelic.com/all-capabilities) &gt; Alerts &gt; Decisions**</DNT> e clique em <DNT>**Create new decision**</DNT>.

Existem duas versões do construtor de decisão:

* Construtor de decisão básico (em versão prévia)
* Construtor de decisão avançado

Para saber mais sobre como usar esses construtores de decisão, continue lendo.

### Elementos de decisão [#decision-elements]

Uma decisão é composta por estes elementos:

* Correlacionar por atributo: Correlacionar todos os incidentes por semelhanças ou diferenças em seu atributo.
* Filtrar por valores específicos: restrinja o incidente àqueles com valores específicos.
* Filtrar por entidade relacionada: Selecione os tipos de conexões compartilhadas ou dependência que deseja que procuremos.
* Intervalo de tempo de correlação: Define a diferença de tempo máxima permitida entre os tempos de criação de dois incidentes para que sejam considerados para correlação.

Uma vez estabelecidas as conexões entre o incidente, nossos grupos [de algoritmos](#what-is-correlaton) correlacionaram o incidente em um único problema.

### Construtor de decisão básico [#basic-decision-builder]

<DNT>**This feature is currently in preview and available for only some customers.**</DNT> Se você não tiver acesso, consulte as instruções do [construtor de decisão avançado](#advanced-decision-builder).

Aqui está um pequeno vídeo (3:25 minutos) mostrando como usar o construtor de decisão básico:

<Video type="wistia" id="xmbcv8rhuu" />

O construtor de decisão básico cobre a maioria dos casos de uso e concentra-se na &quot;correlação por atributo&quot;, onde é possível especificar condições de filtro para correspondências de correlação. Você também pode aplicar a mesma lógica de filtro para valores específicos para ambos os incidentes que estão sendo correlacionados. Por exemplo, você pode correlacionar o incidente se o nome da entidade for `host 1` para ambos.

Para criar sua própria decisão customizada usando o construtor de decisão básico, conclua as etapas a seguir. Tenha em mente que as etapas 1, 2 e 3 são opcionais por si só, mas pelo menos uma das três deve ser definida para que se possa tomar uma decisão.

#### Passo 1: Correlacionar por atributo [#basic-correlate-attributes]

Escolha um atributo no menu dropdown . O operador `equal` , a opção mais popular, está pré-selecionado ou você pode escolher outro [operador](#operators).

O segundo atributo geralmente corresponde ao primeiro, por isso é preenchido automaticamente. Você pode manter a opção de preenchimento automático ou escolher outra operadora.

Quando terminar, uma [simulação](#simulations) será executada automaticamente.

Você pode repetir essas etapas para adicionar até oito filtros lógicos.

<CollapserGroup>
  <Collapser id="basic-correlate-attributes-ui" title="Veja uma captura de tela da interface">
    <img title="A screenshot of the basic decision builder, correlating with attributes." alt="A screenshot of the basic decision builder, correlating with attributes." src="/images/alerts_screenshot-crop_basic-decision-builder-correlate-attributes.webp" />
  </Collapser>
</CollapserGroup>

#### Etapa 2: filtrar por valores específicos [#basic-filter-values]

1. Para abrir a seção `Filter by specific values` e ver filtros adicionais, clique em <DNT>**See more options**</DNT>.
2. Escolha um atributo.
3. O operador `equal` está pré-selecionado ou você pode selecionar outro [operador](#operators).
4. Selecione os valores esperados para o atributo escolhido, com suporte para múltiplas seleções.

Quando concluída, a [simulação](#simulations) será executada automaticamente.

Você pode repetir essas etapas para adicionar até oito filtros lógicos.

<CollapserGroup>
  <Collapser id="basic-builder-filer-values-ui" title="Veja uma captura de tela da interface">
    <img title="A screenshot of the basic decision builder, filtering by values." alt="A screenshot of the basic decision builder, filtering by values." src="/images/alerts_screenshot-crop_basic-decision-builder-filter-values.webp" />
  </Collapser>
</CollapserGroup>

#### Passo 3: Filtrar por entidade relacionada [#basic-filter-related-entities]

Clique em <DNT>**Filter by related entities**</DNT> e escolha as classes de entidade.

Quando seus dados são coletados pelo [agente New Relic](/docs/new-relic-solutions/new-relic-one/install-configure/compatibility-requirements-new-relic-agents-products/), você obtém correlação automática de topologia. [Saiba mais sobre nossa correlação de topologia padrão](#topology-requirements).

Você também pode definir [configurações de topologia usando nossa API NerdGraph](/docs/apis/nerdgraph/examples/topology-nerdgraph-tutorial). Isso permite que qualquer decisão relacionada à topologia seja combinada com seus dados de topologia. [Saiba mais sobre como configurar a correlação de topologia](#topology).

<CollapserGroup>
  <Collapser id="basic-builder-related-entities-ui" title="Veja uma captura de tela da interface">
    <img title="A screenshot of the basic decision builder, filtering by entities." alt="A screenshot of the basic decision builder, filtering by entities." src="/images/alerts_screenshot-crop_basic-decision-builder-filter-related-entities.webp" />
  </Collapser>
</CollapserGroup>

#### Etapa 4: definir o intervalo de tempo de correlação [#basic-set-time-range]

Isto define a diferença de tempo máxima permitida entre os tempos de criação de dois incidentes para que sejam considerados para correlação. Os incidentes dentro deste intervalo serão avaliados com base em regras específicas, enquanto aqueles fora do intervalo não serão correlacionados.

O intervalo de tempo é definido como 20 minutos por padrão. Você pode ajustá-lo entre 1-120 minutos.

<CollapserGroup>
  <Collapser id="basic-builder-time-range" title="Veja uma captura de tela da interface">
    <img title="A screenshot of the basic decision builder, setting a correlation time range." alt="A screenshot of the basic decision builder, setting a correlation time range." src="/images/alerts_screenshot-crop_basic-decision-builder-time-range.webp" />
  </Collapser>
</CollapserGroup>

#### Passo 5: Testando sua decisão usando uma simulação [#basic-test-with-simulation]

Após adicionar a lógica de filtro, o sistema executa automaticamente uma [simulação](#simulations) usando os dados de incidentes dos últimos 7 dias para ajudar você a validar a decisão antes de aplicá-la.

Você também pode acionar manualmente a simulação clicando em <DNT>**Simulate**</DNT>, o que você pode fazer se algo for alterado na decisão.

<CollapserGroup>
  <Collapser id="basic-builder-test-with-simulation-ui" title="Veja uma captura de tela da interface">
    <img title="A screenshot of the basic decision builder, testing with a simulation." alt="A screenshot of the basic decision builder, testing with a simulation." src="/images/alerts_screenshot-crop_basic-decision-builder-run-simulation.webp" />
  </Collapser>
</CollapserGroup>

#### Etapa 6: nomeie e salve sua decisão [#basic-name-save-decision]

Para acessar o painel de nome e descrição, clique em <DNT>**Create decision**</DNT>. O sistema gera um nome com base na sua decisão. Personalize o nome e a descrição conforme desejado.

<CollapserGroup>
  <Collapser id="basic-builder-save-decision-ui" title="Veja uma captura de tela da interface">
    <img title="A screenshot of the basic decision builder: naming and saving the decision" alt="A screenshot of the basic decision builder: naming and saving the decision" src="/images/alerts_screenshot-crop_basic-decision-builder-name-describe.webp" />
  </Collapser>
</CollapserGroup>

### Construtor de decisão avançado [#advanced-decision-builder]

O construtor de decisão avançado permite a criação de decisões mais complexas, aplicando diferentes filtros lógicos aos dois incidentes que estão sendo correlacionados. Por exemplo, você pode correlacionar o incidente se um tiver o nome de entidade `host 1` e o outro tiver o nome de entidade `host 2`. Existem também configurações mais avançadas além de poder configurar apenas a janela de tempo.

Para usar o construtor de decisão avançado:

1. Vá para <DNT>**[one.newrelic.com &gt; All capabilities](https://one.newrelic.com/all-capabilities) &gt; Alerts &gt; Decisions**</DNT>.
2. Clique em <DNT>**Create new decision**</DNT> e, em seguida, clique em <DNT>**Use advanced builder**</DNT>.

Para obter detalhes sobre as opções disponíveis, continue lendo.

Termos importantes:

* Filtro lógico: Condição lógica definida com um [operador](#operators) em um [atributo](/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/incident-event-attributes/#attributes).
* Segmento: Um grupo de incidentes que satisfaz uma combinação de filtros lógicos.

Para criar sua própria decisão customizada, conclua as etapas a seguir. Tenha em mente que as etapas 1, 2 e 3 são opcionais por si só, mas pelo menos uma das três deve ser definida para que se possa tomar uma decisão.

#### Etapa 1: Filtre seus dados [#filter-data]

A correlação ocorre entre quaisquer dois incidentes. Se nenhum filtro for definido, todos os incidentes recebidos serão considerados na decisão. Quanto mais você configurar suas decisões para atender às suas necessidades, melhor poderemos correlacionar seu incidente, reduzir o ruído e fornecer maior contexto para as equipes de plantão.

Sua equipe pode definir seus filtros para o primeiro segmento de incidente e para o segundo segmento de incidente. [Os operadores](#operators) de filtro variam de correspondência de substring a [correspondência de regex](#regex) para ajudá-lo a definir o incidente que deseja e excluir aqueles que não deseja.

<CollapserGroup>
  <Collapser id="advanced-decision-builder-filter-data-ui" title="Veja uma captura de tela da interface">
    <img title="A screenshot of the advanced decision builder: filter your data" alt="A screenshot of the basic decision builder: filter your data" src="/images/alerts_screenshot-crop_advanced-decision-builder-filter-data.webp" />
  </Collapser>
</CollapserGroup>

#### Passo 2: Correlacionar por atributo [#correlate-context]

Depois de filtrar seus dados, defina a lógica utilizada na comparação do contexto do incidente. Você pode correlacionar eventos com base nos seguintes métodos:

* Comparações de valor de atributo com operadores padrão
* Atributo valor similaridade usando [algoritmos de similaridade](#algorithms)
* Atributo value [regex com grupos de captura](#regex)
* Comparações de incidentes inteiros usando algoritmos de similaridade ou cluster

<CollapserGroup>
  <Collapser id="advanced-decision-builder-correlate-attributes-ui" title="Veja uma captura de tela da interface">
    <img title="A screenshot of the advanced decision builder: correlate by attributes" alt="A screenshot of the basic decision builder: correlate by attributes" src="/images/alerts_screenshot-crop_advanced-decision-builder-correlate-attributes.webp" />
  </Collapser>
</CollapserGroup>

#### Passo 3: Correlacionar por entidade relacionada [#topology-correlation]

Para correlação automática de topologia, certifique-se de que seus dados de telemetria sejam coletados pelo [agente New Relic](/docs/new-relic-solutions/new-relic-one/install-configure/compatibility-requirements-new-relic-agents-products/). Saiba mais sobre [a correlação de topologia pronta para uso](#topology-requirements).

Você também pode definir [configurações de topologia usando nossa API NerdGraph](/docs/apis/nerdgraph/examples/topology-nerdgraph-tutorial). Isso permite que qualquer decisão relacionada à topologia seja combinada com seus dados de topologia. [Saiba mais sobre como configurar a correlação de topologia](#topology).

<CollapserGroup>
  <Collapser id="advanced-builder-related-entities-ui" title="Veja uma captura de tela da interface">
    <img title="A screenshot of the advanced decision builder: correlate by related entities" alt="A screenshot of the basic decision builder: correlate by related entities" src="/images/alerts_screenshot-crop_advanced-decision-builder-related-entities.webp" />
  </Collapser>
</CollapserGroup>

#### Etapa 4: dê um nome a ele [#name-your-decision]

Depois de configurar sua lógica de decisão, forneça a ela um nome reconhecível e uma descrição.

<Callout variant="tip">
  Minimize as preocupações de segurança garantindo não adicionar informações confidenciais ou pessoais a esses campos de texto abertos.
</Callout>

Isto é usado em notificações e outras áreas da interface para indicar qual decisão fez com que um par de incidentes fosse correlacionado. Se não quiser atualizar as configurações avançadas padrão na próxima etapa, clique em <DNT>**Create decision**</DNT> para finalizar a criação.

<CollapserGroup>
  <Collapser id="advanced-builder-name-decision" title="Veja uma captura de tela da interface">
    <img title="A screenshot of the advanced decision builder: name decision" alt="A screenshot of the basic decision builder: name decision" src="/images/alerts_screenshot-crop_advanced-decision-builder-name-decision.webp" />
  </Collapser>
</CollapserGroup>

#### Etapa 5: use configurações avançadas [#advanced-settings]

Use a área de configurações avançadas para personalizar ainda mais como sua decisão se comporta ao correlacionar eventos. Cada configuração possui um valor padrão, portanto a personalização é opcional.

* <DNT>**Time window**</DNT>: Define o tempo máximo entre dois incidentes criados para que eles sejam elegíveis para correlação.
* <DNT>**Issue priority**</DNT>: substitui a configuração de prioridade padrão (`inherit priority`) para adicionar prioridade mais alta ou mais baixa se os incidentes estiverem correlacionados.
* <DNT>**Frequency**</DNT>: modifica o número mínimo de incidentes que precisam atender à lógica de decisão para que a decisão seja acionada.
* <DNT>**Similarity**</DNT>: se você estiver usando operadores `similar to` em sua lógica de decisão, poderá escolher em uma lista de algoritmos e definir sua sensibilidade. Isso se aplicará a todos os `similar to` operadores na sua decisão.

<CollapserGroup>
  <Collapser id="advanced-builder-advanced-settings-ui" title="Veja uma captura de tela da interface">
    <img title="Decision - advanced settings" alt="A screenshot of the decision builder showing how to configure advanced settings." src="/images/alerts_screenshot-full_decision-builder-settings.webp" />
  </Collapser>
</CollapserGroup>

## Operadores lógicos [#operators]

O Decision fornece um conjunto de operadores para ajudá-lo a definir com flexibilidade como o valor do atributo de um incidente é avaliado em um filtro lógico. Os básicos são <DNT>**equals**</DNT>, <DNT>**contains**</DNT>, <DNT>**starts with**</DNT>, <DNT>**ends with**</DNT>, <DNT>**exists**</DNT> e seus operadores de negação de acordo. Por exemplo, <DNT>**does not equal**</DNT>.

Existe um operador de similaridade <DNT>**is similar to**</DNT>, o [algoritmo de similaridade](#algorithms) subjacente pode ser especificado para este operador. Por padrão, ele usa Distância Levenshtein.

O operador <DNT>**contains (regex)**</DNT> permite definir a condição [regex](#regex) . Poderoso para combinar valores de dados arbitrários.

### Algoritmos de similaridade [#algorithms]

Aqui estão os detalhes técnicos sobre os algoritmos de similaridade que usamos:

<CollapserGroup>
  <Collapser id="levenshtein-distance" title="Distância Levenshtein">
    Esta medida é útil para comparar strings curtas com esquema estático e comprimento fixo, como nomes de host. A distância de Levenshtein também é conhecida como distância de edição.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Detalhes
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            Como funciona
          </td>

          <td>
            A distância Levenshtein entre duas strings é o número mínimo de edições de um único caractere para passar de uma string para outra. As operações de edição permitidas são exclusão, inserção e substituição.

            O limite de similaridade padrão para decisões de alerta é uma distância de edição de 3. Você pode alterar isso no <DNT>**Advanced mode**</DNT> do criador de decisões.
          </td>
        </tr>

        <tr>
          <td>
            Quando usar
          </td>

          <td>
            Esta medida é mais útil para comparar strings relativamente curtas com esquema estático e comprimento fixo. Os aplicativos comuns incluem corretores ortográficos, biologia computacional e reconhecimento de fala.
          </td>
        </tr>

        <tr>
          <td>
            Exemplos
          </td>

          <td>
            `number/bumble: 3 (number → bumber → bumblr → bumble)`

            `trying/lying: 2 (trying → rying → lying)`

            `strong/through: 4 (strong → htrong → throng → throug → through)`
          </td>
        </tr>

        <tr>
          <td>
            Potenciais desvantagens
          </td>

          <td>
            O algoritmo de distância de Levenshtein não é normalizado por padrão para levar em consideração o comprimento das strings.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="fuzzy-score" title="Pontuação difusa">
    Essa métrica é útil para comparar cadeias de caracteres do mesmo comprimento, nas quais o mesmo prefixo seria um bom indicador de correlação.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Detalhes
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            Como funciona
          </td>

          <td>
            O algoritmo de pontuação difusa funciona alocando &quot;pontos&quot; para correspondências de caracteres entre strings:

            * Um ponto para cada personagem correspondente

            * Dois pontos de bônus para partidas subsequentes

              Quanto maior a pontuação fuzzy, maior será a semelhança entre duas strings.
          </td>
        </tr>

        <tr>
          <td>
            Quando usar
          </td>

          <td>
            A pontuação difusa é mais útil para strings que possuem prefixos iguais e relativamente curtos (de preferência, menos de cinco caracteres). Uma pontuação mínima garantida seria `(length(expected prefix) * 3) - 2`.
          </td>
        </tr>

        <tr>
          <td>
            Exemplos
          </td>

          <td>
            Exemplo: `Decisions / dcsions`

            `d: 1`

            `c: 1`

            `i 1`

            `s: 2`

            `o: 1`

            `n: 1`

            `si: 2`

            `io: 2`

            `on: 2`

            `ns: 2`

            `= 15 points`
          </td>
        </tr>

        <tr>
          <td>
            Potenciais desvantagens
          </td>

          <td>
            Se o primeiro caractere da primeira string não for encontrado na segunda string, nenhum ponto será concedido.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="fuzzy-wuzzy-ratio" title="Proporção difusa e wuzzy">
    Essa métrica é útil para comparar strings de comprimento semelhante.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Detalhes
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            Como funciona
          </td>

          <td>
            A família <DNT>**fuzzy wuzzy**</DNT> de medidas de similaridade foi [desenvolvida pela SeatGeek](https://chairnerd.seatgeek.com/fuzzywuzzy-fuzzy-string-matching-in-python/) para ajudar a encontrar ingressos para o mesmo evento que possuem rótulos diferentes em diversas plataformas. A proporção difusa e wuzzy para duas strings é expressa como uma porcentagem, onde um número mais alto indica uma string mais semelhante. É baseado no [algoritmo SequenceMatcher](https://docs.python.org/3/library/difflib.html) no difflib do Python.
          </td>
        </tr>

        <tr>
          <td>
            Quando usar
          </td>

          <td>
            A proporção difusa e wuzzy é eficaz para strings muito curtas (como nome do host) ou strings muito longas (como descrição de evento), especialmente na comparação de strings de comprimento semelhante.
          </td>
        </tr>

        <tr>
          <td>
            Potenciais desvantagens
          </td>

          <td>
            Este algoritmo é muito sensível para ser usado com eficácia em sequências de 3 a 10 palavras. Uma das outras modificações do fuzzy wuzzy (veja abaixo) pode ser uma escolha melhor.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="fuzzzy-wuzzy-partial" title="Proporção parcial difusa e wuzzy">
    Essa métrica é útil para comparar strings de comprimentos diferentes. Esta modificação no algoritmo fuzzy wuzzy ajuda a resolver a limitação de comprimento efetivo.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Detalhes
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            Como funciona
          </td>

          <td>
            Com razão parcial fuzzy wuzzy, a string mais curta é comparada a cada substring do mesmo comprimento dentro da string mais longa. A pontuação da substring de &quot;melhor correspondência&quot; é usada para determinar a proporção parcial difusa e wuzzy.
          </td>
        </tr>

        <tr>
          <td>
            Quando usar
          </td>

          <td>
            A proporção parcial fuzzy wuzzy é especialmente eficaz para os tipos de comparações em que o algoritmo fuzzy wuzzy básico falha em: sequências de 3 a 10 palavras onde algumas substrings significativas provavelmente se sobrepõem.
          </td>
        </tr>

        <tr>
          <td>
            Exemplos
          </td>

          <td>
            Por exemplo, entre as seguintes strings:

            `DevOps and SRE teams`

            `DevOps`

            `DevOps` (a string mais curta, length = 6) seria comparada a cada substring com comprimento 6 dentro de `DevOps and SRE teams`. Como uma dessas substrings (`DevOps`) é uma correspondência perfeita, a proporção parcial difusa e wuzzy para essas duas strings será alta.
          </td>
        </tr>

        <tr>
          <td>
            Potenciais desvantagens
          </td>

          <td>
            Onde o fuzzy wuzzy pode ser muito conservador, a correspondência parcial do fuzzy wuzzy pode ser mais liberal do que o esperado com as correlações. Você pode ajustar o limite no construtor de decisão de acordo com suas necessidades.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="fuzzy-wuzzy-token" title="Proporção do conjunto token fuzzy wuzzy">
    Essa métrica é útil para comparar strings onde as informações podem não estar na mesma ordem e com possíveis comprimentos diferentes. Funciona melhor para frases como mensagens, descrições, etc.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Detalhes
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            Como funciona
          </td>

          <td>
            O algoritmo de proporção do conjunto token segue algumas etapas para comparar strings:

            1. Tokenizar cada string (por exemplo, “Equipes DevOps e SRE” para “DevOps” “e” “SRE” “equipes”; “Equipe SRE e DevOps engenheiro” para “SRE” “equipes” “e” “DevOps” “engenheiro” )

            2. Combine o token de interseção em uma nova string, deixando o token restante (por exemplo, interseção: &quot;DevOps&quot;, &quot;e&quot;, &quot;SRE&quot;; resto1: &quot;equipes&quot;; resto2: &quot;equipe&quot;, &quot;engenheiro&quot;)

            3. Coloque em ordem alfabética cada grupo token (por exemplo. “e, DevOps, SRE”, “equipes”, engenheiro, equipe”)

            4. Compare os seguintes pares de strings:

            5. Grupo de interseção

            6. Grupo de interseção + restante1

            7. Grupo de interseção + restante2

            A comparação desses pares (&quot;melhores correspondências&quot;) é a proporção do conjunto token fuzzy wuzzy.
          </td>
        </tr>

        <tr>
          <td>
            Quando usar
          </td>

          <td>
            Essa métrica é útil nos casos em que strings semelhantes podem ter palavras sobrepostas, mas com construções diferentes; por exemplo, descrições de eventos para problemas diferentes com o mesmo recurso.
          </td>
        </tr>

        <tr>
          <td>
            Potenciais desvantagens
          </td>

          <td>
            Onde o fuzzy wuzzy pode ser muito conservador, a correspondência do conjunto token fuzzy wuzzy pode ser mais liberal do que o esperado com as correlações. Você pode ajustar o limite no construtor de decisão de acordo com suas necessidades.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="Jaro-winkler-distance" title="Distância Jaro-winkler">
    Esta métrica é útil para cadeias curtas onde prefixos idênticos são uma forte indicação de correlação.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Detalhes
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            Como funciona
          </td>

          <td>
            Essa métrica usa uma escala de 0 a 1 para indicar a semelhança entre duas strings, onde 0 é nenhuma semelhança (0 caracteres correspondentes entre strings) e 1 é uma correspondência exata. A semelhança Jaro-Winkler leva em consideração:

            * `matching`: dois caracteres iguais e em posições semelhantes nas strings.
            * `transpositions`: caracteres correspondentes que estão em ordem de sequência diferente nas strings.
            * `prefix scale`: a distância Jaro-Winkler é ajustada favoravelmente se as strings corresponderem desde o início (um prefixo tem até 4 caracteres).
          </td>
        </tr>

        <tr>
          <td>
            Quando usar
          </td>

          <td>
            Essa métrica é bastante tolerante com transposições, mas transposições mais distantes na string são menos úteis.

            Um número geralmente seguro para usar para similaridade Jaro-Winkler em strings moderadas a longas é 0,9; você pode usar `{~}0.85` nos casos em que mais clemência é aceitável (por exemplo, se você tiver outra lógica mais específica na decisão).
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="cosine-distance" title="Distância cosseno">
    Esta medida é mais comumente usada para comparar grandes blocos de texto (por exemplo, descrições de incidentes) e fornece uma fácil visualização da similaridade.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Detalhes
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            Como funciona
          </td>

          <td>
            Para cada bloco de texto que você está comparando, um vetor é calculado para representar a contagem de cada palavra exclusiva no bloco. A distância cosseno dos vetores resultantes é seu produto escalar dividido pelo produto de suas magnitudes.
          </td>
        </tr>

        <tr>
          <td>
            Quando usar
          </td>

          <td>
            Esta medida é mais útil para comparar longos blocos de texto, especificamente quando a comparação pretende considerar o texto como um todo, e não diferenças ou erros ortográficos em palavras individuais.
          </td>
        </tr>

        <tr>
          <td>
            Exemplos
          </td>

          <td>
            ```
            It is not length of life, but depth of life.
            Depth of life does not depend on length.
            ```

            Aqui está a contagem de palavras para essas frases:

            `it 1 0`

            `is 0 1`

            `not 1 1`

            `length 1 1`

            `of 2 1`

            `life 2 1`

            `but 1 0`

            `depth 1 1`

            `does 0 1`

            `depend 0 1`

            `on 0 1`

            E aqui estão essas contagens representadas como um vetor:

            ```
            [1, 0, 1, 1, 2, 2, 1, 1, 0, 0, 0]
            [0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]
            ```

            A distância cosseno desses vetores é cerca de 0,9 (1 é a maior similaridade).
          </td>
        </tr>

        <tr>
          <td>
            Potenciais desvantagens
          </td>

          <td>
            A distância do cosseno é menos útil para situações em que pequenas diferenças de caracteres nas palavras são insignificantes. Além disso, a distância do cosseno ignora a ordem das palavras nos blocos de texto.
          </td>
        </tr>
      </tbody>
    </table>

    Para obter mais informações sobre a implementação da distância do cosseno, consulte o [passo a passo detalhado em blog.christianperone.com](http://blog.christianperone.com/2013/09/machine-learning-cosine-similarity-for-vector-space-models-part-iii/).
  </Collapser>

  <Collapser id="hamming-distance" title="Distância de Hamming">
    Esta medida é útil para textos mais curtos com esquema estático, mas funciona apenas para cadeias de caracteres do mesmo comprimento.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Detalhes
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            Quando usar
          </td>

          <td>
            A distância de Hamming exige que as cordas comparadas tenham o mesmo comprimento. Esta é uma métrica de similaridade útil para situações onde a diferença entre duas strings pode ser devido a erros de digitação, ou onde você deseja comparar dois atributos com comprimentos conhecidos. Por exemplo:

            ```
            Low Disk Space in application myapp in data center us01
            ```

            Se você quiser ser tolerante às mudanças no data center, a distância de Hamming deverá ser definida como 4. Um caso de uso médio para a distância de Hamming seria em torno de 2-3.
          </td>
        </tr>

        <tr>
          <td>
            Exemplos
          </td>

          <td>
            Uma versão mais simples da métrica de &quot;edição de distância&quot;, como a distância de Levenshtein, a distância de Hamming entre duas strings é o número de caracteres na string que não correspondem (na mesma posição). Por exemplo, nas strings abaixo, a distância de Hamming é 2:

            ```
            flowers / florets
            ```
          </td>
        </tr>

        <tr>
          <td>
            Potenciais desvantagens
          </td>

          <td>
            No exemplo acima, se o nome do aplicativo mudar em vez do data center, uma correlação também será criada. À medida que a distância aumenta, a utilidade da Distância de Hamming despenca. Por esse motivo, para qualquer coisa remotamente mais complicada do que ser tolerante a substituições de 1 a 2 caracteres (ou se os comprimentos das strings não corresponderem), use uma medida de similaridade diferente.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="Jaccard-distance" title="Distância Jaccard">
    Esta medida é útil para comparar grandes blocos de texto, como descrições ou incidentes inteiros.

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Detalhes
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            Como funciona
          </td>

          <td>
            A distância, indicada em percentagem (0 sendo completamente semelhante; 1 sendo totalmente diferente) é calculada com a seguinte fórmula:

            ```
            1 - [(# of characters in both sets) / (# of characters in either set) * 100]
            ```

            Em outras palavras, a distância Jaccard é o número de caracteres compartilhados dividido pelo número total de caracteres (compartilhados e não compartilhados). Uma distância Jaccard de 0,1 significa que 10% ou menos caracteres entre dois incidentes são diferentes.
          </td>
        </tr>

        <tr>
          <td>
            Quando usar
          </td>

          <td>
            A distância de Jaccard é muito fácil de interpretar e especialmente útil em casos com grande conjunto de dados. Por exemplo, ao comparar a semelhança entre dois incidentes inteiros (em oposição a um atributo).
          </td>
        </tr>

        <tr>
          <td>
            Potenciais desvantagens
          </td>

          <td>
            É menos eficaz para pequenos conjuntos de dados ou situações com dados ausentes. Além disso, diferentes permutações do conjunto de caracteres não afetam a distância de Jaccard, portanto, tome cuidado para evitar falso positivo.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

### Operadores Regex [#regex]

Ao [construir uma decisão](#customize), os operadores disponíveis incluem:

* `contains (regex)`: usado na [Etapa 1: Filtre seus dados](#customize).
* `regular expression match`: usado na [Etapa 2: Correlação contextual](#customize).

O construtor de decisões segue os padrões descritos [nestes documentos para expressões regulares](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html).

<CollapserGroup>
  <Collapser id="regex-step-1" title="Regex na Etapa 1">
    Para que seu regex seja testado como verdadeiro, todo o valor do atributo (os dados que você está avaliando) deve corresponder à expressão regular fornecida. Grupos capturados podem ser usados, mas não são avaliados explicitamente.

    Por exemplo, se o valor do atributo for `foobarbaz`, estes exemplos atenderiam aos critérios e seriam testados como verdadeiros:

    * `foo.*`
    * `^.*baz`
    * `\w+`
  </Collapser>

  <Collapser id="regex-step-2" title="Regex na Etapa 2">
    Para que seu regex seja testado como verdadeiro, todos os valores de atributo para o incidente 1 e o incidente 2 devem ser incluídos na correspondência. Além disso, cada grupo capturado (expressões entre `( )` parênteses) deve existir em ambos os valores (atributo incidente 1 e incidente 2) e ter o mesmo valor:

    * O número de grupos capturados deve ser igual para ambos os atributos do incidente.

    * Cada grupo deve ser igual ao grupo correspondente entre os valores do atributo: o valor do primeiro grupo capturado no valor do atributo do incidente 1 é igual ao valor do primeiro grupo capturado no atributo do incidente 2.

      Por exemplo, se o valor do atributo 1 for `abc-123-xyz` e o valor do atributo 2 for `abc-777-xyz`, então `(\w+)-(?:\w+)-(\w+)` atenderia aos critérios:

    * O valor inteiro é correspondido pela expressão.

    * O primeiro e o terceiro grupos capturados têm os mesmos valores respectivos.

    * O segundo grupo não é capturado usando `?:`, o que permite que todo o valor corresponda, mas não é usado na comparação do grupo de captura.
  </Collapser>

  <Collapser id="flags" title="Sobre bandeiras">
    Nenhum sinalizador está habilitado por padrão. Alguns sinalizadores úteis para incluir em expressões regulares no construtor de decisão são:

    * CASE\_INSENSITIVE: (?i)

    * MULTILINA: (?m)

    * DOTAL: (?s)

      Consulte [a documentação detalhada de campo da Oracle](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#field.detail) para obter mais notas sobre a função e implementação de cada um desses sinalizadores.
  </Collapser>
</CollapserGroup>

## Assistente de correlação [#assistant]

Você pode usar o assistente de correlação para analisar [incidentes](/docs/alerts-applied-intelligence/new-relic-alerts/get-started/alerts-ai-overview-page/#incidents) mais rapidamente, criar lógica de decisão e testar a lógica com uma simulação. Para usar o assistente de correlação:

1. Vá para a guia <DNT>**[one.newrelic.com &gt; All capabilities](https://one.newrelic.com/all-capabilities) &gt; Alerts &gt; Issues &amp; activity &gt; Incidents**</DNT> .
2. Marque as caixas do incidente que você deseja correlacionar. Em seguida, na parte inferior da lista de incidentes, clique em <DNT>**Correlate incidents**</DNT>.
3. Para obter melhores resultados de correlação de incidentes, selecione um atributo comum com percentual de frequência baixo. [Saiba mais sobre como usar frequência](#frequency-tips).
4. Clique em <DNT>**Simulate**</DNT> para ver o efeito provável da sua nova decisão na última semana dos seus dados.
5. Clique nos exemplos de pares de correlações para determinar quais correlações usar.
6. Se você gostou do que foi simulado, clique em <DNT>**Next**</DNT> e nomeie e descreva sua decisão.
7. Se o resultado da simulação mostrar muitos incidentes potenciais, você pode escolher um conjunto diferente de atributo e incidente para sua decisão e executar outra simulação. [Saiba mais sobre simulação](#simulations).

<CollapserGroup>
  <Collapser id="frequency-tips" title="Análise de atributos">
    Dois tipos de análise de atributo aparecem na interface:

    * <DNT>**Common attributes:**</DNT> Esta análise simplesmente destaca atributos e valores que são exatamente iguais entre todos os incidentes selecionados.

    * <DNT>**Similar attributes:**</DNT> A análise de similaridade utiliza o algoritmo de Levenshtein com distância 3 para encontrar um atributo cujos valores seriam os mesmos se fossem realizadas 3 ou menos mudanças de caracteres. Valores numéricos, bem como valores de caracteres únicos, são filtrados dos resultados. Atributos semelhantes requerem a seleção de dois incidentes, a análise de similaridade não é realizada quando são selecionados 3 ou mais incidentes.

      Para tomar as melhores decisões, recomendamos escolher atributos comuns que tenham menor frequência no seu incidente. Aqui estão algumas dicas para entender como a escolha de um atributo de baixa ou alta frequência afeta suas decisões:

    * <DNT>**Low frequency:**</DNT> Por exemplo, um atributo com 0% na coluna de frequência é provavelmente um identificador exclusivo ou um atributo que foi relatado apenas recentemente em seus dados no último mês. A escolha de um atributo de baixa frequência pode correlacionar poucos eventos.

    * <DNT>**High frequency:**</DNT> Por outro lado, um atributo com 100% de frequência seria aquele que está presente em todos os seus dados. A escolha desses atributos correlacionaria todos os seus eventos.

      Por padrão, os atributos são ordenados pela menor frequência. Clique na porcentagem de frequência de um atributo para obter informações sobre a distribuição dos valores relatados para esse atributo no último mês.
  </Collapser>
</CollapserGroup>

### Correlação entre simulação e tempo real [#simulation-vs-decisions]

É importante compreender a diferença entre simulação e correlação em tempo real na tomada de decisões:

* <DNT>**Simulation**</DNT>: A correlação de simulação envolve a análise de dois incidentes separados para compreender a sua relação em condições simuladas. Esses incidentes podem ter origem tanto no mesmo problema subjacente quanto em problemas diferentes. O foco está em determinar os potenciais fatores causadores ou características comuns entre incidentes individuais. A simulação ajuda você a testar e validar sua lógica de correlação com base em dados históricos antes de aplicá-la em tempo real.

* <DNT>**Real-time correlation (decisions)**</DNT>: Em contraste, a correlação real do tempo e o destino abordam questões distintas, com cada questão potencialmente abrangendo múltiplos incidentes. O monitoramento por IA tem como objetivo detectar e conectar padrões em múltiplos incidentes para identificar problemas subjacentes e, assim, obter uma correlação mais eficiente. A correlação tempo real aproveita fluxos de dados em tempo real, permitindo a identificação e resposta prompt a problemas emergentes.

### Usando simulação [#simulations]

A simulação testa sua lógica de correlação analisando dois incidentes distintos da última semana de seus dados, mostrando quantas correlações teriam ocorrido. Isso permite validar a lógica de decisão antes de aplicá-la à correlação de problemas em tempo real. Segue abaixo um resumo das informações de pré-visualização da decisão exibidas durante a simulação:

* <DNT>**Potential correlation rate:**</DNT> A porcentagem de incidentes testados que esta decisão teria afetado.
* <DNT>**Total created incidents:**</DNT> O número de incidentes testados por esta decisão.
* <DNT>**Total estimated correlated incidents:**</DNT> O número estimado de incidentes que esta decisão teria correlacionado.
* <DNT>**Incident examples:**</DNT> Uma lista de pares de incidentes que a decisão teria correlacionado, incluindo os atributos e valores da regra, bem como outros atributos populares em cada par. Clique no incidente para ver detalhes.

Execute a simulação com atributos diferentes quantas vezes precisar até ver os resultados desejados. Quando estiver pronto, siga as instruções da interface para salvar sua decisão.

## Correlação de topologia [#topology]

Para alertas da New Relic, a topologia é uma representação do seu mapa de serviços: como os serviços e recursos da sua infraestrutura se relacionam entre si.

Para decisões do usuário, uma [decisão de topologia padrão](#global-decisions) é adicionada e habilitada em sua conta. Você também tem a opção de [criar decisões personalizadas](#customize).

Nossa correlação de topologia encontra relacionamentos entre fontes de incidentes para determinar se [o incidente](/docs/alerts-applied-intelligence/new-relic-alerts/get-started/alerts-ai-overview-page/#incidents) e, portanto, seus respectivos problemas devem estar correlacionados. A correlação de topologia foi projetada para melhorar a qualidade de suas correlações e a velocidade com que elas são encontradas.

### Requisitos [#topology-requirements]

Para correlação automática de topologia (sem a necessidade de configurar explicitamente o gráfico de topologia), certifique-se de que seus dados de telemetria sejam coletados pelo [agente New Relic](/docs/new-relic-solutions/new-relic-one/install-configure/compatibility-requirements-new-relic-agents-products/). Quanto mais tipos de agente New Relic estiverem instalados em seus serviços e ambiente, mais oportunidades para decisões de topologia correlacionarem seu incidente.

### Como funciona a correlação de topologia? [#topology-explained]

<img title="topology-4.png" alt="A screenshot of New Relic topology explained" src="/images/alerts_diagram_topology-4.webp" />

<figcaption>
  Neste mapa de serviço, os hosts e aplicativos são os vértices e as linhas que mostram seus relacionamentos são as arestas.
</figcaption>

Para configurar sua topologia além da [entidade e relacionamentos](/docs/new-relic-solutions/new-relic-one/core-concepts/what-entity-new-relic/) coletados pelo [agente New Relic](/docs/new-relic-solutions/new-relic-one/install-configure/compatibility-requirements-new-relic-agents-products/), utilize nossa [API NerdGraph](#create-topology-graph).

A correlação de topologia personalizada depende de dois conceitos principais:

* <DNT>**Vertex:**</DNT> Um vértice representa uma entidade monitor. É a fonte de onde vem o seu evento ou descreve um sintoma problemático. Um vértice possui atributos (pares de valores principais) configurados para ele, como GUIDs de entidade ou outros IDs, que permitem que ele seja associado a um evento de incidente de entrada.
* <DNT>**Edges:**</DNT> Uma aresta é uma conexão entre dois vértices. As arestas descrevem o relacionamento entre os vértices.

Pode ser útil entender como a topologia é usada para correlacionar incidentes:

1. Primeiro, a New Relic reúne todos os incidentes relevantes. Isso inclui incidentes onde [as etapas 1 e 2 da lógica de decisão](#customize) são verdadeiras e que também estão dentro da janela de tempo definida nas configurações avançadas.

   <img title="topology-1.png" alt="A screenshot of New Relic topology explained" src="/images/alerts_diagram_topology-1.webp" />

2. A seguir, tentamos associar cada incidente a um vértice em seu [gráfico de topologia](#create-topology-graph), usando o atributo definidor de um vértice e o atributo disponível no incidente.

   <img title="topology-2.png" alt="A screenshot of New Relic topology explained" src="/images/alerts_diagram_topology-2.webp" />

   <figcaption>
     Um exemplo dos passos para associar o incidente às informações do gráfico de topologia.
   </figcaption>

3. Em seguida, os pares de vértices que foram associados ao incidente são testados usando o operador &quot;topologicamente dependente&quot; para determinar se esses vértices estão conectados entre si.

   <img title="topology-3.png" alt="A screenshot of New Relic topology explained" src="/images/alerts_diagram_topology-3.webp" />

   <figcaption>
     Este operador verifica se existe algum caminho no gráfico que conecte os dois vértices em cinco saltos.
   </figcaption>

   Os incidentes são então correlacionados e os problemas são mesclados.

### Adicionar atributo ao evento de incidente [#add-attributes]

Os incidentes são conectados aos vértices usando um atributo definidor do vértice. (No exemplo de topologia em [Topologia explicada](#topology-explained), cada vértice possui um atributo definidor &quot;CID&quot; com um valor exclusivo.) Em seguida, o sistema de alertas da New Relic encontra um vértice que corresponde ao atributo.

Se o atributo definidor que você gostaria de usar em seus vértices ainda não estiver no evento de incidente, use uma destas opções para adicioná-lo:

<CollapserGroup>
  <Collapser id="tag-entities" title="Tag sua entidade no New Relic">
    Ao [marcar sua entidade](/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data), essa tag enriquecerá o evento de incidente gerado pelo alerta. Por exemplo, se você marcou sua entidade com `CID` e seu valor exclusivo correspondente, então você pode definir atributo em seu vértice da seguinte forma: `'newrelic/tags/CID' : CID_VALUE`
  </Collapser>

  <Collapser id="facet-data" title="Tag sua entidade no New Relic">
    Criar [condição do alerta NRQL](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions) com uma ou mais [facetas](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions#syntax) definidas agrupará seus dados por atributo. Além disso, o evento emitido será enriquecido com esses atributos e valores. Para incidente, o atributo facetado segue o mesmo formato: `newrelic/tags/ATTRIBUTE_NAME`
  </Collapser>
</CollapserGroup>

### Criar ou visualizar topologia [#create-topology-graph]

Para configurar sua topologia ou visualizar a topologia existente, consulte o [tutorial de topologia do NerdGraph](/docs/apis/nerdgraph/examples/topology-nerdgraph-tutorial).