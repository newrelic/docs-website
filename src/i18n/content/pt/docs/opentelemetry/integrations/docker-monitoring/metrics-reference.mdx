---
title: Referência de métricas de contêineres Docker
tags:
  - Integrations
  - OpenTelemetry
  - Docker
  - Metrics
metaDescription: 'Complete reference of Docker container metrics collected by OpenTelemetry, including descriptions, types, and alerting recommendations.'
freshnessValidatedDate: never
translationType: machine
---

Esta página fornece uma referência abrangente para todas as métricas de contêiner Docker coletadas pelo [dockerstatsreceiver](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/dockerstatsreceiver) do OpenTelemetry. Use esta referência para entender quais dados estão disponíveis, criar consultas personalizadas e configurar alertas eficazes para suas aplicações em contêineres.

## Referência completa de métricas [#metrics-reference]

O [dockerstatsreceiver](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/dockerstatsreceiver) do OpenTelemetry Collector Contrib coleta as seguintes métricas da API Docker Stats:

<CollapserGroup>
  <Collapser id="docker-metrics" title="Métrica">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descrição
          </th>

          <th>
            Tipo
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `container.blockio.io_merged_recursive`
          </td>

          <td>
            Número de bios/solicitações mesclados em solicitações pertencentes a este cgroup e seus cgroups descendentes
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_queued_recursive`
          </td>

          <td>
            Número de solicitações enfileiradas para este cgroup e seus cgroups descendentes
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_service_bytes_recursive`
          </td>

          <td>
            Número de bytes transferidos para/do disco pelo grupo e grupos descendentes
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_service_time_recursive`
          </td>

          <td>
            Quantidade total de tempo em nanossegundos entre o despacho da solicitação e a conclusão da solicitação para as E/S realizadas por este cgroup e cgroups descendentes
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_serviced_recursive`
          </td>

          <td>
            Número de IOs (bio) emitidos para o disco pelo grupo e grupos descendentes
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_time_recursive`
          </td>

          <td>
            Tempo de disco alocado ao cgroup (e cgroups descendentes) por dispositivo em milissegundos
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.blockio.io_wait_time_recursive`
          </td>

          <td>
            Tempo total que as E/S para este cgroup (e cgroups descendentes) passaram aguardando nas filas do escalonador por serviço
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.kernelmode`
          </td>

          <td>
            Uso da CPU em modo kernel
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.percpu`
          </td>

          <td>
            Uso de CPU por núcleo pelo container (desativado por padrão)
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.system`
          </td>

          <td>
            Uso de CPU do sistema
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.total`
          </td>

          <td>
            Tempo total de CPU consumido pelo contêiner
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.usage.usermode`
          </td>

          <td>
            Uso da CPU em modo de usuário
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.percent`
          </td>

          <td>
            Porcentagem de CPU usada pelo contêiner (descontinuado, use container.cpu.utilization em vez disso)
          </td>

          <td>
            Medidor
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.utilization`
          </td>

          <td>
            Porcentagem de CPU usada pelo contêiner
          </td>

          <td>
            Medidor
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.throttling_data.periods`
          </td>

          <td>
            Número de períodos com limitação ativa
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.throttling_data.throttled_periods`
          </td>

          <td>
            Número de períodos em que o contêiner atingiu seu limite de estrangulamento
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.throttling_data.throttled_time`
          </td>

          <td>
            Tempo agregado em que o contêiner foi limitado
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.limit`
          </td>

          <td>
            Limite de CPU definido para o contêiner
          </td>

          <td>
            Medidor
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.logical.count`
          </td>

          <td>
            Número de núcleos disponíveis para o contêiner
          </td>

          <td>
            Medidor
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.shares`
          </td>

          <td>
            Compartilhamentos de CPU alocados ao contêiner
          </td>

          <td>
            Medidor
          </td>
        </tr>

        <tr>
          <td>
            `container.cpu.cores.used`
          </td>

          <td>
            Número de núcleos de CPU usados pelo contêiner
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.usage.limit`
          </td>

          <td>
            Limite de uso de memória
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.usage.max`
          </td>

          <td>
            Uso máximo de memória
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.usage.total`
          </td>

          <td>
            Uso de memória do contêiner. Isso exclui o cache
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.percent`
          </td>

          <td>
            Porcentagem de memória usada
          </td>

          <td>
            Medidor
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.active_anon`
          </td>

          <td>
            Quantidade de memória usada em mapeamentos anônimos, como brk(), sbrk() e mmap(MAP\_ANONYMOUS), que são usados ativamente
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.active_file`
          </td>

          <td>
            Quantidade de memória cache usada por arquivos que estão sendo usados ativamente
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.anon`
          </td>

          <td>
            Quantidade de memória usada em mapeamentos anônimos (páginas não apoiadas por arquivos)
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.cache`
          </td>

          <td>
            A quantidade de memória usada pelos processos deste grupo de controle que pode ser associada a um bloco em um dispositivo de bloco
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.dirty`
          </td>

          <td>
            Bytes aguardando para serem gravados no disco, deste cgroup
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.fails`
          </td>

          <td>
            Número de vezes que o limite de memória foi atingido
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.file`
          </td>

          <td>
            Quantidade de memória usada por arquivos (cache de arquivos)
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.hierarchical_memory_limit`
          </td>

          <td>
            A quantidade máxima de memória física que o cgroup pode usar
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.hierarchical_memsw_limit`
          </td>

          <td>
            A quantidade máxima de RAM + swap que o cgroup pode usar
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.inactive_anon`
          </td>

          <td>
            Quantidade de memória usada em mapeamentos anônimos, como brk(), sbrk() e mmap(MAP\_ANONYMOUS), que não estão sendo ativamente utilizados
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.inactive_file`
          </td>

          <td>
            Quantidade de memória cache usada por arquivos que não estão sendo usados ativamente
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.mapped_file`
          </td>

          <td>
            Indica a quantidade de memória mapeada pelos processos no grupo de controle
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.pgfault`
          </td>

          <td>
            Indica o número de vezes que um processo do cgroup acionou uma falha de página
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.pgmajfault`
          </td>

          <td>
            Indica o número de vezes que um processo do cgroup acionou uma falha grave
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.pgpgin`
          </td>

          <td>
            Número de páginas lidas do disco pelo cgroup
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.pgpgout`
          </td>

          <td>
            Número de páginas gravadas em disco pelo cgroup
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.rss`
          </td>

          <td>
            A quantidade de memória que não corresponde a nada em disco: pilhas, heaps e mapas de memória anônima
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.rss_huge`
          </td>

          <td>
            Número de bytes de hugepages transparentes anônimas neste cgroup
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.unevictable`
          </td>

          <td>
            A quantidade de memória que não pode ser recuperada
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.memory.writeback`
          </td>

          <td>
            Número de bytes de cache de arquivo/anônimo que estão na fila para sincronização com o disco neste cgroup
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.rx_bytes`
          </td>

          <td>
            Bytes recebidos pelo contêiner via sua interface de rede
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.rx_dropped`
          </td>

          <td>
            Número de pacotes recebidos descartados pelo contêiner
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.rx_errors`
          </td>

          <td>
            Erros recebidos pelo contêiner
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.rx_packets`
          </td>

          <td>
            Pacotes recebidos pelo contêiner via sua interface de rede
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.tx_bytes`
          </td>

          <td>
            Bytes enviados pelo contêiner via sua interface de rede
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.tx_dropped`
          </td>

          <td>
            Número de pacotes enviados descartados pelo contêiner
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.tx_errors`
          </td>

          <td>
            Erros de transmissão pelo contêiner
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.network.io.usage.tx_packets`
          </td>

          <td>
            Pacotes enviados pelo contêiner via sua interface de rede
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.pids.count`
          </td>

          <td>
            Número de PIDs no cgroup do contêiner
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.pids.limit`
          </td>

          <td>
            Número máximo de PIDs no cgroup do contêiner
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.restarts`
          </td>

          <td>
            Número de vezes que o contêiner foi reiniciado
          </td>

          <td>
            Soma
          </td>
        </tr>

        <tr>
          <td>
            `container.uptime`
          </td>

          <td>
            Tempo decorrido desde que o contêiner foi iniciado
          </td>

          <td>
            Medidor
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser id="docker-attributes" title="Atributo">
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Atributo
          </th>

          <th>
            Descrição
          </th>

          <th>
            Valores
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `collector.name`
          </td>

          <td>
            Atributo personalizado para identificação do coletor (se configurado no seu coletor)
          </td>

          <td>
            Corda
          </td>
        </tr>

        <tr>
          <td>
            `container.hostname`
          </td>

          <td>
            O nome do host do contêiner
          </td>

          <td>
            Corda
          </td>
        </tr>

        <tr>
          <td>
            `container.id`
          </td>

          <td>
            O ID completo do contêiner
          </td>

          <td>
            String (hexadecimal de 64 caracteres)
          </td>
        </tr>

        <tr>
          <td>
            `container.image.name`
          </td>

          <td>
            Nome da imagem do container
          </td>

          <td>
            Corda
          </td>
        </tr>

        <tr>
          <td>
            `container.name`
          </td>

          <td>
            Nome do contêiner
          </td>

          <td>
            Corda
          </td>
        </tr>

        <tr>
          <td>
            `container.runtime`
          </td>

          <td>
            Tempo de execução do contêiner
          </td>

          <td>
            `docker`
          </td>
        </tr>

        <tr>
          <td>
            `deployment.environment`
          </td>

          <td>
            Identificador do ambiente de implantação (se configurado no seu coletor)
          </td>

          <td>
            Corda
          </td>
        </tr>

        <tr>
          <td>
            `description`
          </td>

          <td>
            Descrição da métrica
          </td>

          <td>
            Corda
          </td>
        </tr>

        <tr>
          <td>
            `device_major`
          </td>

          <td>
            Número maior do dispositivo (para métricas de E/S de bloco)
          </td>

          <td>
            Inteiro
          </td>
        </tr>

        <tr>
          <td>
            `device_minor`
          </td>

          <td>
            Número menor do dispositivo (para métricas de E/S de bloco)
          </td>

          <td>
            Inteiro
          </td>
        </tr>

        <tr>
          <td>
            `entity.guid`
          </td>

          <td>
            GUID da entidade New Relic para o container
          </td>

          <td>
            Corda
          </td>
        </tr>

        <tr>
          <td>
            `entity.name`
          </td>

          <td>
            Nome da entidade New Relic (geralmente o nome do contêiner)
          </td>

          <td>
            Corda
          </td>
        </tr>

        <tr>
          <td>
            `entity.type`
          </td>

          <td>
            Tipo de entidade New Relic
          </td>

          <td>
            `CONTAINER`
          </td>
        </tr>

        <tr>
          <td>
            `instrumentation.provider`
          </td>

          <td>
            Identificador do provedor de instrumentação
          </td>

          <td>
            `opentelemetry`
          </td>
        </tr>

        <tr>
          <td>
            `interface`
          </td>

          <td>
            Nome da interface de rede (para métricas de rede)
          </td>

          <td>
            Corda
          </td>
        </tr>

        <tr>
          <td>
            `newrelic.source`
          </td>

          <td>
            Fonte da métrica no New Relic
          </td>

          <td>
            `api.metrics.otlp`
          </td>
        </tr>

        <tr>
          <td>
            `nr.entity_type`
          </td>

          <td>
            Tipo de entidade New Relic para correlação de entidades
          </td>

          <td>
            `CONTAINER`
          </td>
        </tr>

        <tr>
          <td>
            `operation`
          </td>

          <td>
            Tipo de operação de E/S de bloco
          </td>

          <td>
            `read`, `write`
          </td>
        </tr>

        <tr>
          <td>
            `otel.library.name`
          </td>

          <td>
            Nome da biblioteca/receptor OpenTelemetry
          </td>

          <td>
            `github.com/open-telemetry/opentelemetry-collector-contrib/receiver/dockerstatsreceiver`
          </td>
        </tr>

        <tr>
          <td>
            `otel.library.version`
          </td>

          <td>
            Versão da biblioteca OpenTelemetry
          </td>

          <td>
            String (por ex., `0.142.0`)
          </td>
        </tr>

        <tr>
          <td>
            `service.name`
          </td>

          <td>
            Nome do serviço configurado no coletor
          </td>

          <td>
            Corda
          </td>
        </tr>

        <tr>
          <td>
            `telemetry.sdk.name`
          </td>

          <td>
            Identificador do SDK de telemetria
          </td>

          <td>
            `opentelemetry`
          </td>
        </tr>

        <tr>
          <td>
            `unit`
          </td>

          <td>
            Unidade de medida da métrica
          </td>

          <td>
            String (ex.: `{cpus}`, `By`, `1`)
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

Para mais detalhes, consulte a [documentação do receiver Docker Stats](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/dockerstatsreceiver/documentation.md)

## Próximos passos [#next-steps]

Agora que você entende as métricas do Docker:

* [Configurar o monitoramento](/docs/opentelemetry/integrations/docker-monitoring/self-hosted) - Configure o monitoramento do Docker se ainda não o fez
* **Crie dashboards**: Construa [visualizações personalizadas](/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/) usando as métricas nesta referência