---
title: 'Caracterização do serviço: Otimize a telemetria do seu aplicativo'
tags:
  - Observability maturity
  - Operational efficiency
  - Service characterization
  - Implementation guide
metaDescription: Use service characterization to optimize application telemetry for issue detection and resolution
freshnessValidatedDate: never
translationType: machine
---

import omaOeScServiceDiagram from 'images/oma-oe_diagram_sc-service.webp'

import omaOeScTransactionBreakdown from 'images/oma-oe-sc_screenshot-full_transaction-breakdown.webp'

import omaOeScTransactionBreakdownWeighted from 'images/oma-oe-sc-transaction-breakdown-weighted.webp'

import omaOeScTransactionBreakdownHistogramNonNormal from 'images/oma-oe-sc_screenshot-full_transaction-breakdown-histogram-non-normal.webp'

import omaOeScTransactionBreakdownHistogramNormal from 'images/oma-oe-sc_screenshot-full_transaction-breakdown-histogram-normal.webp'

import omaOeScTransactionAttributes from 'images/oma-oe-sc_screenshot-full_transaction-attributes.webp'

import omaOeScErrorAttributes from 'images/oma-oe-sc_screenshot-crop_error-attributes.webp'

import omaOeScTransactionNrqlCustomAttribute from 'images/oma-oe-sc_screenshot-crop_transaction-nrql-custom-attributes.webp'

import omaOeScTransactionNrqlFeatureFlag from 'images/oma-oe-sc_screenshot-crop_transaction-nrql-feature-flag.webp'

import omaOeScSummaryComponents from 'images/oma-oe-sc_screenshot-full_summary-components.webp'

import omaOeScTransactionComponents from 'images/oma-oe-sc_screenshot-crop_transaction-components.webp'

import omaOeScSummaryClient from 'images/oma-oe-sc_screenshot-full_summary-client.webp'

import omaOeScExternalService from 'images/oma-oe-sc_screenshot-full_external-service.webp'

import omaOeScDatabases from 'images/oma-oe-sc_screenshot-full_databases.webp'

import omaOeScSyntheticsMenu from 'images/oma-oe-sc_screenshot-crop_synthetics-menu.webp'

Determine se você possui ou não a telemetria necessária para monitoramento e otimização dos serviços do seu aplicativo.

## Pré-requisitos [#prerequisites]

À medida que você segue as etapas do guia, mantenha os seguintes recursos de documentação à mão:

* Instalação e [configuração](/docs/new-relic-one/install-configure/configure-new-relic-agents) [do agente APM](/docs/new-relic-one/install-configure/install-new-relic/#apm-install)

* Guias de instrumentação:

  * [C-SDK](/docs/apm/agents/c-sdk/instrumentation/instrument-your-app-c-sdk)
  * [Go](/docs/apm/agents/go-agent/instrumentation)
  * [Java](/docs/apm/agents/java-agent/custom-instrumentation/java-custom-instrumentation)
  * [.NET](/docs/apm/agents/net-agent/custom-instrumentation/introduction-net-custom-instrumentation)
  * [Node.js](/docs/apm/agents/nodejs-agent/extend-your-instrumentation/nodejs-custom-instrumentation)
  * [PHP](/docs/apm/agents/php-agent/php-agent-api/)
  * [Python](/docs/apm/agents/python-agent/custom-instrumentation/python-custom-instrumentation/)
  * [Ruby](/docs/apm/agents/ruby-agent/api-guides/ruby-custom-instrumentation/)
  * [SDKs OpenTelemetry](https://opensource.newrelic.com/projects/open-telemetry)

* [Introdução ao monitoramento sintético New Relic](/docs/synthetics/)

## Estabeleça o estado atual [#current-state]

Para estabelecer o estado atual dos seus serviços, você seguirá duas etapas:

* [Determine suas necessidades de instrumentação](#instrumentation-needs)
* [Entenda os testes de endpoint](#endpoint-testing)

Estas estão descritas em mais detalhe abaixo.

### Determine suas necessidades de instrumentação [#instrumentation-needs]

Todo serviço que atenda a uma necessidade comercial deve ter instrumentação suficiente para responder às seguintes perguntas.

* Quantas solicitações recebo?
* Quantas mensagens e solicitações HTTP devo enviar?
* Quantas solicitações foram bem-sucedidas?
* Qual é o tempo de resposta para uma solicitação completa?
* Qual é o tempo de resposta para invocação de uma dependência?
* Quanto recurso esse processo deve consumir sob qual número de solicitações?
* Quais são todos os meus pontos de falha?

<DoNotTranslate>
  **Does the telemetry adequately describe the function and the purpose of my service?**
</DoNotTranslate>

Pense no que seu serviço faz. Talvez ele receba um pedido, precise validar a integridade do pedido, transmita esse pedido a um serviço de compensação e receba um código de confirmação que é retransmitido de volta ao solicitante. Este exemplo fornece um caminho claro para analisar a função do serviço e avaliar se temos telemetria e contexto suficientes para fazer avaliações informadas de como o serviço está funcionando.

<img
  src={omaOeScServiceDiagram}
  alt="Service Diagram"
  title="Service Diagram"
/>

<figcaption>
  Serviço conceitual que recebe e processa solicitações HTTP.
</figcaption>

Se estiver usando o agente da New Relic, você deverá ter todas as informações necessárias para responder às perguntas no início desta seção. No entanto, às vezes, implementações específicas requerem instrumentação adicional.

A tabela a seguir documenta situações adicionais em que você pode adicionar telemetria ou captura de metadados por meio de instrumentação. A seção [do processo de melhoria](#improvement-process) a seguir descreve como obter dados adicionais necessários para gerenciar seu serviço.

Considerações para instrumentação:

|                                                                              |                                                                                                                                                                                                                                                                      |
| ---------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Meus requisitos básicos de telemetria foram atendidos?                       | Caso contrário, documente as lacunas e avalie se elas podem ser eliminadas por meio de configuração personalizada ou técnicas de instrumentação adicionais.                                                                                                          |
| Posso isolar histórias discretas de usuários na telemetria?                  | Caso contrário, use os recursos trace do agente para capturar a invocação de uma história de usuário discreta com metadados de contexto adequados.                                                                                                                   |
| Tenho informações sobre os parâmetros que invocam as histórias dos usuários? | Caso contrário, use o atributo personalizado através do SDK do agente para adicionar contexto à transação e aos spans.                                                                                                                                               |
| Posso medir os principais componentes funcionais do software?                | Caso contrário, use SDKs de instrumentação para criar métricas baseline em um elemento funcional específico do código. (pesquisas de cache, rotinas de processamento ou funções utilitárias).                                                                        |
| Posso medir a interação do cliente do meu código com sistemas externos?      | Caso contrário, certifique-se de que as solicitações e respostas sejam encapsuladas pelo rastreamento no nível do componente. Se a invocação do cliente for assíncrono, considere implementar o recurso distributed trace para visualizar o processamento sucessivo. |

### Entenda os testes de endpoint [#endpoint-testing]

O teste de endpoint é uma abordagem simples e prática que agiliza muito a determinação da causa raiz de uma determinada falha do sistema. Ele permite que as equipes de operações e de suporte saibam rapidamente que há um problema real e isolem esse problema em um serviço específico.

Os sistemas de software modernos dependem de vários serviços para completar suas tarefas. Historicamente, o processo de monitoramento desses terminais de serviço era simples. A equipe de arquitetura produziria um mapa de dependência bem documentado para a equipe de operações. A equipe de operações criaria obedientemente uma verificação do endpoint detalhado.

Hoje, com processos de entrega contínua e pequenas alterações em lotes, novos endpoints e dependências podem ser criados e implantados a uma taxa que torna difícil para uma equipe de operações antecipar e definir proativamente verificações sintéticas. Ao dar aos desenvolvedores de serviços maior escopo de controle para definir testes de serviços de produção durante a fase de desenvolvimento, você aumentará bastante a cobertura de testes de endpoint para seu programa de observabilidade.

#### Matriz de decisão [#endpoint-testing-decision-matrix]

Determinar se deve ser criada uma verificação sintética é simples. Você vai querer saber a primeira ocorrência de falha em uma dependência. Se você responder “sim” a qualquer uma das perguntas a seguir, considere a criação de um relatório dedicado de verificações sintéticas:

* O endpoint é voltado para o cliente?
* O endpoint invoca nova dependência?
* O endpoint está em uma infraestrutura de rede diferente?
* O endpoint é compartilhado entre vários serviços?
* O endpoint é uma origem de conteúdo suportada por uma CDN?

## Processo de melhoria [#improvement-process]

Um processo de melhoria geralmente incluirá estas etapas principais:

* [Configure sua instrumentação](#config-based-instrumentation)
* [Isolar funções de serviço](#isolate-service-functions)
* [Definir nomes de transação personalizados](#custom-transaction-names)
* [Medir componentes de serviço](#component-measurement)
* [Certifique-se de que sua estrutura seja medida](#framework-measurement)
* [Rastreie todas as chamadas externas](#external-services)
* [Teste seu terminal](#endpoint-testing2)

Examinaremos isso com mais detalhes agora.

### Configure sua instrumentação [#config-based-instrumentation]

Cada agente New Relic oferece uma variedade de opções de configuração. Normalmente, você definirá uma abordagem padrão para incluir o agente em hosts de infraestrutura, tempos de execução de aplicativos e conexões com seu provedor de serviço em nuvem. A configuração padrão do agente é genérica e amplamente aplicável.

Uma das melhores maneiras para os desenvolvedores influenciarem a aplicabilidade da implantação é substituindo as opções de configuração padrão da sua instância de serviço. A seguir estão as opções de instrumentação padrão a serem consideradas.

#### Crie um nome de serviço eficaz [#service-naming]

<Callout variant="tip">
  O agente New Relic fornece uma variedade de mecanismos para definir o nome do tempo de execução do serviço. Consulte o [guia de nomenclatura de aplicativos](/docs/apm/agents/manage-apm-agents/app-naming) para encontrar os detalhes de implementação para seu ambiente de tempo de execução.
</Callout>

O nome que você dá a um serviço fornece o <DoNotTranslate>**namespace**</DoNotTranslate> (onde você encontrará os dados do agente). Uma das estratégias mais importantes que a New Relic usa para entender o comportamento de seus serviços é agregar coisas semelhantes e usar os pontos em comum derivados da agregação para isolar a variação.

Os serviços modernos são frequentemente implantados em múltiplos contextos para garantir o manejo da capacidade ou a segmentação funcional específica. Para aproveitar os benefícios da agregação, é muito importante que os tempos de execução do serviço agrupem instâncias com características operacionais idênticas. Portanto, ao implantar serviços, preste muita atenção aos três critérios a seguir para ajudá-lo a nomear seus serviços de implantação:

* Meu serviço destina-se a um público específico?
* Meu serviço está executando uma base de código diferente?
* Minha base de código está usando uma configuração de tempo de execução diferente?

Se você responder “sim” a alguma dessas perguntas, considere criar um nome exclusivo para o seu serviço.

<DoNotTranslate>
  **Audience criteria**
</DoNotTranslate>

Pense no público como o conjunto de usuários finais ou funções de serviço. Se o seu serviço estiver dividido entre implantação norte-americana e europeia, os tempos de execução nessas implantações deverão ser agrupados de acordo. Por exemplo:

```
newrelic.appname = PORTAL_AMER
```

e

```
newrelic.appname = PORTAL_EMEA
```

Isso agrupará a telemetria criada por esse público, permitindo entender melhor as semelhanças contextuais dos problemas de serviço relacionados a um público de usuário específico.

Às vezes a forma como implantamos aplicativos divide o contexto operacional de um serviço, como um aplicativo de portal com funções administrativas. Talvez as funções administrativas estejam integradas na base de código geral do portal, mas apenas uma instância em um cluster está manipulando as solicitações administrativas do portal. Nesse caso, você tem uma oportunidade funcional de segmentação de público, portanto, certifique-se de que ela seja nomeada de forma adequada. Por exemplo:

```
newrelic.appname = PORTAL_MAIN
```

e

```
newrelic.appname = PORTAL_ADMIN
```

<DoNotTranslate>
  **Codebase criteria**
</DoNotTranslate>

Se você estiver executando diferentes versões de código sob o disfarce de um serviço, considere segmentar essas instâncias de tempo de execução e incorporar a nomenclatura de versão como parte do seu esquema de nomenclatura. Ao agrupar o código como um nome de serviço que executa diferentes versões de serviço, você aumenta a relação ruído/sinal de qualquer métrica produzida.

Diferentes versões de código podem usar diferentes quantidades de recursos computacionais ou processar dados de maneira diferente. Torna-se muito difícil determinar se um serviço está se comportando normalmente quando os sinais obtidos da métrica são devidos a diferentes implementações funcionais.

Se você tiver várias versões em execução simultaneamente, considere adicionar um identificador numérico ao nome do serviço. Por exemplo:

```
newrelic.appname = PORTAL_MAIN_V112
```

e

```
newrelic.appname = PORTAL_MAIN_V115
```

Se você empregar uma framework de sinalização de recurso como LaunchDarkly ou Split, poderá ter várias versões de um aplicativo ou serviço em uma única base de código. Para resolver essas condições, consulte a seção sobre isolamento de funções de serviço.

<DoNotTranslate>
  **Runtime criteria**
</DoNotTranslate>

If an instance of a service is deployed to a system with different runtime constraints, it should be encapsulated in its own telemetry namespace. This can be a deployment to a different data center that offers network connectivity advantages to a shared resource, or perhaps the service is running on a separate compute tier with a different memory or thread configuration.

Essas características que afetam a operação do tempo de execução do código podem causar diferentes comportamentos que levam a diferentes comportamentos de operações. Por exemplo:

```
newrelic.appname = PORTAL_NYC_DC
```

e

```
newrelic.appname = PORTAL_REALLY_BIG_FOOTPRINT
```

#### Substituir a configuração padrão do agente [#override-default-agent-config]

<Callout variant="tip">
  O agente New Relic fornece uma variedade de opções para configuração de tempo de execução. Consulte a [documentação de configuração do agente APM](/docs/new-relic-one/install-configure/configure-new-relic-agents) para obter as opções específicas para seu tempo de execução.
</Callout>

Cada agente New Relic APM oferece uma variedade de opções para modificar a configuração padrão. O local mais abrangente e consistente é o arquivo de configuração que acompanha a instalação de cada agente. No entanto, os agentes New Relic também podem ser configurados passando parâmetros de linha de comando diretamente para o tempo de execução da instância de serviço, usando variáveis de ambiente ou chamando funções dentro do SDK do agente em tempo de execução.

Aqui estão as opções de configuração do agente .NET:

* [Usando a API do SDK .NET da New Relic](/docs/apm/agents/net-agent/net-agent-api/)
* [Variáveis ambientais](/docs/apm/agents/net-agent/configuration/net-agent-configuration/#environment-variables)
* [Opções de arquivo de configuração](/docs/apm/agents/net-agent/configuration/net-agent-configuration/#setup)

### Isolar funções de serviço [#isolate-service-functions]

Conforme indicado na seção [Criar um nome de serviço efetivo](#service-naming) , um dos principais objetivos da instrumentação é configurar o agente New Relic para agrupar restrições de tempo de execução semelhantes como uma única unidade nomeada. Sugerimos isso porque os sistemas de software devem se comportar de maneira determinística.

Para um conjunto específico de insumos, você deve obter uma gama esperada de resultados mensuráveis. O grau em que podemos conter confortavelmente essas restrições em componentes nomeados de tempo de execução de serviço nos ajuda muito a compreender o comportamento normal e a isolar o comportamento aberrante.

Depois de definir uma estratégia de nomenclatura de serviço eficaz, a próxima etapa é examinar a telemetria coletada para o serviço e determinar se ela isola adequadamente a funcionalidade do serviço. O padrão de implementação que encontramos com mais frequência é uma série de funções invocadas por uma solicitação da web. O recebimento e tratamento inicial de uma solicitação da web para um tempo de execução de serviço resulta na alocação de recursos de processamento. A New Relic define essa alocação de recursos e execução de código como uma transação.

O agente New Relic é configurado com um conjunto de suposições que criam namespace para transação à medida que são detectadas. Essas suposições diferem entre o tempo de execução da linguagem do agente. Por exemplo, um bom exemplo de como o agente Java da New Relic determina o nome da transação pode ser encontrado na [documentação de nomenclatura da transação do agente Java](/docs/apm/agents/java-agent/instrumentation/transaction-naming-protocol/).

No entanto, mesmo após a aplicação do protocolo de nomenclatura de transação do agente, você poderá obter um resultado insatisfatório. Ao adicionar instrumentação adicional para nomear a transação e melhorar seu contexto, isso pode melhorar muito sua compreensão do comportamento de execução do serviço.

O objetivo do naming de transação deve ser uma visão de transação de APM que proporcione uma boa segmentação das funções de serviços em uma abordagem que seja fácil de entender para quem não está envolvido.

<img
  src={omaOeScTransactionBreakdown}
  alt="Transaction Breakdown"
  title="Transaction Breakdown"
/>

<figcaption>
  Visualização detalhada da transação do serviço New Relic.
</figcaption>

A imagem detalhada da transação é um bom exemplo de segmentação da transação. Ele fornece rastreamento detalhado da quantidade de trabalho realizado por cada transação dentro da base de código mais ampla do serviço. Ele também exibe a transação com um nome simples e amigável ao usuário que oferece alguma dica de seu contexto de negócios (o que a transação faz). À medida que você aprende mais sobre nomenclatura e inclusão de atributo, certifique-se de tornar sua abordagem de nomenclatura acessível para observadores não técnicos dos dados.

<img
  src={omaOeScTransactionBreakdownWeighted}
  alt="Transaction Breakdown Weighted"
  title="Transaction Breakdown Weighted"
/>

<figcaption>
  Repartição da transação: as transações neste serviço parecem ser altamente ponderadas para um nome de transação com um nome bastante genérico. Avarias como esta levantam a questão: "Esta é uma boa representação do trabalho que o meu serviço realiza?"
</figcaption>

A imagem obtusa do detalhamento da transação demonstra um mau exemplo de segmentação de nomes de transações. Neste caso temos cerca de 60% do volume de transação sendo denominado `OperationHandler/handle`. Tanto a atribuição percentual do volume de transação quanto a natureza genérica do nome indicam que pode haver uma agregação excessivamente zelosa de transações sob esse namespace de transação.

Uma boa maneira de validar sua abordagem de nomenclatura de transação é revisar a distribuição do tempo de resposta de sua transação durante um período significativo de tempo no dashboard de serviço de transação do histograma da web.

<img
  src={omaOeScTransactionBreakdownHistogramNonNormal}
  alt="Transaction Histogram Non-normal"
  title="Transaction Histogram Non-normal"
/>

<figcaption>
  A visualização do histograma do serviço de transação mostra a contagem de transações que se enquadram em cada período de tempo de resposta. Uma boa estratégia de nomenclatura tende a exibir uma distribuição normal.
</figcaption>

A imagem da transação de serviço mostra uma ampla gama de taxas de resposta à transação. Embora a maior parte da transação esteja na faixa de 0 a 200 milissegundos, ela indica valores que variam de 200 a 1000 milissegundos. Quando você tem uma gama altamente distribuída de respostas para uma transação, você deve se perguntar:

<DoNotTranslate>
  **What information do I have during the transaction execution that can help me name this transaction?**
</DoNotTranslate>

Em muitos casos, distribuições não normais são um resultado direto do parâmetro sendo passado para uma solicitação ou do trabalho que a transação está sendo solicitada a realizar. É muito fácil considerar que uma transação de consulta de serviço pode usar um intervalo de dados como parâmetro. O intervalo de datas, quando pequeno, pode fornecer um tempo de pesquisa mais rápido. Portanto, talvez fornecer um esquema de significado derivado de algumas restrições de parâmetros esperados (> 1 dia, 1-5 dias, > 5 dias) possa fornecer uma segmentação mais significativa.

Seu objetivo é criar um nome de transação que facilite o agrupamento de transações com o menor número de características exclusivas.

<img
  src={omaOeScTransactionBreakdownHistogramNormal}
  alt="Transaction Histogram"
  title="Transaction Histogram"
/>

<figcaption>
  Uma distribuição mais normal da segmentação da transação, onde a transação individual relata um tempo de resposta mais consistente, com menos exceções.
</figcaption>

A imagem de distribuição normal demonstra transações nomeadas de forma mais proposital dentro de um serviço. Neste caso, as transações da web tempo de resposta são agrupadas de forma mais estreita, indicando características de execução consistentes.

Ao garantir que sua estratégia de nomenclatura de transação forneça um mecanismo consistente para agrupar as funções do seu serviço pelos tipos de operações que estão executando, você poderá isolar rapidamente o comportamento aberrante ou compreender melhor a causa raiz das variações. Isso permitirá refatorar seu aplicativo e aumentar a previsibilidade geral das funções do seu serviço.

### Definir nomes de transação personalizados [#custom-transaction-names]

<Callout variant="tip">
  Consulte o guia da API do seu [agente New Relic](/docs/apm/new-relic-apm/getting-started/introduction-apm) para revisar o procedimento de nomenclatura de transação para seu tempo de execução.
</Callout>

O serviço de nomenclatura de transação do agente New Relic requer a invocação de uma chamada de API semelhante a `SetName(String name)`para o SDK do agente New Relic. Cada agente de tempo de execução de linguagem possui sua própria sintaxe e opção para configurar o nome.

Por exemplo, para pegar o valor de um parâmetro de solicitação HTTP e usá-lo para nomear uma transação no agente Java New Relic, você pode usar um código semelhante a este:

```
com.newrelic.agent.Agent.LOG.finer("[my query handler] Renaming transaction based on an important query parameter");

com.newrelic.api.agent.NewRelic.setTransactionName("Query Handler_" + (javax.servlet.http.HttpServletRequest)_servletrequest_0).getParameter("important_query_parm"));
```

Observação: há uma capacidade máxima para nomes de transação da New Relic. Sua estratégia de nomenclatura de transação terá que compensar um certo grau de especificidade se houver milhares de nomes de transação em potencial.

Quando muitos nomes de transação estão sendo relatados, a New Relic tentará criar regras para agrupar esses nomes de transação. Mais detalhes podem ser encontrados no [guia de resolução de problemas de agentes](/docs/using-new-relic/cross-product-functions/troubleshooting/metric-grouping-issues) relacionados a questões de agrupamento métrico.

Caso você suspeite de um problema de agrupamento métrico, abra um caso de suporte com a New Relic e teremos prazer em trabalhar com você para isolar a causa do problema de nomenclatura da transação.

### Capture parâmetro com sua transação [#capture-parameters]

<Callout variant="tip">
  Consulte o [guia de atributo personalizado do agente New Relic](/docs/using-new-relic/data/customize-data/collect-custom-attributes/) para o idioma do seu agente para revisar as opções de aprimoramento de metadados para personalização de atributo.
</Callout>

O nome da transação é uma maneira poderosa de segmentar a funcionalidade do seu serviço para que você possa entender melhor seu comportamento. Isso permite isolar discretamente a funcionalidade diretamente na interface do usuário do New Relic.

No entanto, há muitas ocasiões em que você desejará obter algum contexto adicional sobre a função do seu serviço sem precisar isolar o nome da transação. Isso pode ser conseguido introduzindo a captura de atributo em seu serviço.

Você pode adicionar `name:value` pares de atributos para decorar os detalhes de cada transação. O atributo estará disponível em cada evento de transação através da interface de trace da transação e erros do APM, ou através de consulta direta de parâmetro do tipo de evento `Transaction` .

<img
  src={omaOeScTransactionAttributes}
  alt="Transaction Attributes"
  title="Transaction Attributes"
/>

<figcaption>
  Após selecionar um rastreamento da transação, você poderá visualizar o atributo personalizado que você definiu para a transação do seu serviço.
</figcaption>

Aqui está um exemplo dos detalhes do rastreamento da transação que você pode ver na interface de erros do APM.

<img
  src={omaOeScErrorAttributes}
  alt="Error Attributes"
  title="Error Attributes"
/>

<figcaption>
  Atributo personalizado exibido na interface de erros do APM.
</figcaption>

Se você desenvolveu uma segmentação de nome de transação útil, poderá usar o contexto adicional do atributo para entender melhor as entradas, coortes ou segmentos que levaram a um resultado inesperado.

Além de poder entender o contexto da sua transação dentro da interface do APM, a introdução do parâmetro é uma ferramenta extremamente útil para agregar e analisar transações consultando diretamente os dados da transação. atributo personalizado são adicionados a cada transação, facilitando o isolamento e a facetação em condições específicas.

<img
  src={omaOeScTransactionNrqlCustomAttribute}
  alt="NRQL Custom Attributes"
  title="NRQL Custom Attributes"
/>

<figcaption>
  Expressão de consulta NRQL que usa um atributo personalizado para definir a duração da chamada do banco de dados.
</figcaption>

A abordagem de captura de parâmetro também pode ser usada com sistemas de flag de recurso como Split ou LaunchDarkly. Nesse caso, ao implementar o manipulador de decisão para o sinalizador de recurso, considere capturar o contexto do sinalizador (por exemplo, `optimized_version = on`) que está sendo aplicado ao bloco de código que controla a versão ou recurso que os clientes veem.

<img
  src={omaOeScTransactionNrqlFeatureFlag}
  alt="NRQL Custom Attributes Feature Flags"
  title="NRQL Custom Attributes Feature Flags"
/>

<figcaption>
  Consulta NRQL que demonstra o resultado quando o estado de um sinalizador de recurso é capturado por um atributo personalizado de transação. O atributo feature flag state nos permite entender o impacto do caminho de execução do código no desempenho, taxas de transferência e utilização de dependência.
</figcaption>

Por exemplo, para pegar o valor de um parâmetro de solicitação HTTP e salvá-lo como um atributo personalizado com o agente Java New Relic, você pode usar um código semelhante a este:

```
com.newrelic.agent.Agent.LOG.finer("[my query handler] Adding an Attribute to transaction based on an important query parameter");

com.newrelic.api.agent.NewRelic.addCustomParameter("ImportantParm", (javax.servlet.http.HttpServletRequest)_servletrequest_0).getParameter("important_query_parm"));
```

### Medir componentes de serviço [#component-measurement]

O comportamento de uma transação específica no contexto de um serviço é uma forma poderosa de segregar funcionalidades e garantir que um sistema de software esteja operando de maneira eficaz. Entretanto, outra maneira de observar o comportamento de um sistema de software é revisar o modelo detalhado de execução dos componentes de sua implementação. Os componentes do código framework do aplicativo são compartilhados por todo o serviço, e a avaliação contínua do desempenho dos componentes pode fornecer insights sobre a integridade geral do serviço.

No New Relic, há dois lugares onde podemos observar detalhes de execução dos componentes. O dashboard de resumo de serviço no APM fornece uma visão da execução composta do serviço dividida por suas partes componentes (por exemplo, execução de coleta de lixo ou chamadas de banco de dados).

<img
  src={omaOeScSummaryComponents}
  alt="Summary Components"
  title="Summary Components"
/>

<figcaption>
  Este dashboard de resumo fornece uma análise dos principais tipos de componentes do aplicativo. Memcached, invocações externas da Web, MySQL e Dirac são exemplos de frameworks de código compartilhado que a transação coletiva do serviço está usando para executar sua lógica de negócios.
</figcaption>

Uma discriminação semelhante é fornecida transação por transação.

<img
  src={omaOeScTransactionComponents}
  alt="Transaction Components"
  title="Transaction Components"
/>

<figcaption>
  Essa visualização de resumo de transação única divide o tempo de execução contribuinte por componente. Isso ajuda você a ver o desempenho agregado dos componentes em uma transação.
</figcaption>

Os segmentos de componentes de transação tenderão a demonstrar um comportamento de desempenho consistente. Você pode usar essa consistência para detectar uma mudança em seu comportamento fundamental. Esta pode ser uma boa indicação de um problema subjacente. As restrições de recursos tendem a manifestar-se mais obviamente na estrutura dos componentes do que nos detalhes de transação individuais. Isso permite inferir características de dependência por meio das restrições comuns enfrentadas por todo o código em execução em um serviço.

### Certifique-se de que sua estrutura seja medida [#framework-measurement]

<Callout variant="tip">
  Para encontrar informações sobre como adicionar nomes de métricas à sua instrumentação, consulte os guias de instrumentação e SDK de um agente APM específico.
</Callout>

A sintaxe da instrumentação framework é específica para a linguagem em que seu serviço está escrito, mas a abordagem geral é consistente para todos. Considere os threads de execução em seus Serviços como uma analogia para a transação na telemetria New Relic. Cada execução de método ou função na stack é uma oportunidade para adicionar instrumentação adicional. Dessa forma, o New Relic mantém uma stack de invocação com anotação de tempo para a transação e usa esses tempos de início/parada de método/função para agregá-la em uma série de métricas de componentes.

<img
  src={omaOeScSummaryClient}
  alt="Service Summary Components"
  title="Service Summary Components"
/>

<figcaption>
  Um aplicativo Node.js simples fazendo uma chamada para um MongoDB. Os dois principais componentes do aplicativo são o recebimento da solicitação e as operações get/put no MongoDB.
</figcaption>

Se um segmento específico da lógica for crucial para o funcionamento do seu serviço ou transação, considere agrupar essa chamada com retorno de chamada para o agente New Relic para que o agente possa entender que inseriu um componente de código discreto e possa agregar o tempo consumido dentro desse componente adequadamente. Ao passar um nome de métrica para o retorno de chamada, você criará uma métrica de segmento de componente para seu serviço e transação.

A opção de nomenclatura de métrica é específica da linguagem de instrumentação, portanto, consulte a documentação específica da linguagem.

O agente New Relic permite especificar um nome métrico personalizado para a instrumentação. O `metricName` será usado para determinar a métrica agregada do componente. O exemplo a seguir demonstra o parâmetro `metricName` sendo transmitido para uma anotação `@Trace` do SDK do agente Java.

```
@Weave
public abstract class MQOutboundMessageContext implements OutboundTransportMessageContext {

    @Trace(dispatcher = true, metricName="MQTransport")
    public void send(final TransportSendListener listener) throws TransportException {
        try {
            NewRelic.getAgent().getTracedMethod().setMetricName("Message", "MQ", "Produce");
            MQHelper.processSendMessage(this, NewRelic.getAgent().getTracedMethod());
        } catch (Exception e) {
            NewRelic.getAgent().getLogger().log(Level.FINE, e, "Unable to set metadata on outgoing MQ message");
        }

        Weaver.callOriginal();
    }

}
```

### Rastreie todas as chamadas de serviço externas [#external-services]

<Callout variant="tip">
  Para encontrar os detalhes da instrumentação da biblioteca cliente, consulte os guias de instrumentação e SDK do agente APM relevante.
</Callout>

A instrumentação do cliente refere-se ao encapsulamento de uma chamada do seu serviço para um recurso externo. Geralmente, os agentes da New Relic conhecem clientes populares para protocolos HTTP, gRPC, mensagens e banco de dados e aplicarão o padrão de instrumentação apropriado para agregar chamadas a esses clientes como serviços externos.

<img
  src={omaOeScExternalService}
  alt="External Services"
  title="External Services"
/>

<figcaption>
  Detalhes dashboard de serviço externo no New Relic APM.
</figcaption>

Se você escreveu seu próprio manipulador de cliente para um protocolo ou está usando algo muito novo ou de nicho, o agente da New Relic pode não reconhecer o cliente e registrar o comportamento da chamada do cliente. Para tanto, você deve verificar os serviços externos e o banco de dados dentro do APM para representar todas as externalidades esperadas para o seu serviço.

<img
  src={omaOeScDatabases}
  alt="Databases"
  title="Databases"
/>

<figcaption>
  Detalhes dashboard de protocolo de banco de dados no New Relic APM.
</figcaption>

É importante validar que todas as dependências dos seus serviços estão aqui representadas. Se você não vir sua dependência de serviço, precisará introduzir uma nova instrumentação para interceptar a chamada externa para que seu agente APM possa rastreá-la adequadamente. O exemplo a seguir demonstra o encapsulamento de uma chamada externa em Golang para captura pelo agente.

```
package main

import (
	"net/http"

	"github.com/newrelic/go-agent/v3/newrelic"
)

func currentTransaction() *newrelic.Transaction {
	return nil
}

func main() {
	txn := currentTransaction()
	client := &http.Client{}
	request, _ := http.NewRequest("GET", "http://www.example.com", nil)
	segment := newrelic.StartExternalSegment(txn, request)
	response, _ := client.Do(request)
	segment.Response = response
	segment.End()
}
```

Exemplos de outro rastreamento de chamadas externas da API do agente:

* [Go `ExternalSegment`](https://pkg.go.dev/github.com/newrelic/go-agent/v3/newrelic#ExternalSegment)
* [Java `ExternalParameters`](https://newrelic.github.io/java-agent-api/javadoc/com/newrelic/api/agent/TracedMethod.html#reportAsExternal(com.newrelic.api.agent.ExternalParameters))
* [Python `external_trace`](/docs/apm/agents/python-agent/python-agent-api/externaltrace-python-agent-api/)

### Teste seu terminal [#endpoint-testing2]

O teste de endpoint oferece dois benefícios ao seu programa de instrumentação de serviço:

* <DoNotTranslate>**Defect detection:**</DoNotTranslate>

  Ao codificar um teste para um endpoint que produz um resultado simples de verdadeiro/falso, permite que a equipe de operações isole falhas discretas para determinar se a integridade da entrega do serviço foi comprometida.

* <DoNotTranslate>**Baselining:**</DoNotTranslate>

  Os testes sintéticos ou de máquina fornecem um conjunto previsível de condições que permitem avaliar a consistência da entrega do seu serviço a partir de uma perspectiva de controle.

O monitoramento sintético da New Relic oferece a capacidade de criar uma variedade de tipos de testes, empregando um SDK Selenium JavaScript aprimorado. Depois que um script de teste baseado em Selenium for definido, a New Relic gerenciará o local de execução do script, bem como sua frequência.

<img
  src={omaOeScSyntheticsMenu}
  alt="Synthetics"
  title="Synthetics"
/>

<figcaption>
  New Relic Synthetics dashboard de lançamento do Relic Synthetics.
</figcaption>

O teste sintético oferece uma variedade de opções de teste, cada uma com seu foco. Para obter mais informações, consulte nossa [documentação de monitoramento sintético](/docs/synthetics/).

Da perspectiva de um desenvolvedor de serviço, o tipo de monitor empregado com mais frequência é <DoNotTranslate>**Endpoint availability**</DoNotTranslate>. Esse tipo de monitor fornece a capacidade de script de condições de solicitação HTTP. Eles podem ser tão simples quanto POST ou GET para uma API acessível ou envolver várias etapas em que o script de monitoramento Selenium avalia sucessivamente as solicitações para verificar a integridade funcional de um processo de várias etapas.

Na prática, os desenvolvedores devem considerar a implementação do teste mais simples possível para avaliar a disponibilidade e integridade do endpoint. Por exemplo, você acabou de criar um novo endpoint de serviço que fornece a taxa de câmbio atual para um grupo de moedas. Este é um GET simples em um endpoint que retorna uma matriz de objetos JSON.

* Exemplo de solicitação: `http://example-ip:3000/exchange`
* Exemplo de resposta:

```
[
  {
    "status": [
      "quote"
    ],
    "_id": "5b9bf97f61c22f4fb5beb5c9",
    "name": "cdn",
    "Created_date": "2021-07-12T18:10:07.488Z",
    "__v": 1
  },
  {
    "status": [
      "quote"
    ],
    "_id": "5b9bfb2a61c22f4fb5beb5ca",
    "name": "usd",
    "Created_date": "2021-07-12T18:17:14.224Z",
    "__v": 0.80
  },
  {
    "status": [
      "quote"
    ],
    "_id": "5b9bfb3261c22f4fb5beb5cb",
    "name": "eur",
    "Created_date": "2021-07-12T18:17:22.476Z",
    "__v": 0.68
  },
  {
    "status": [
      "quote"
    ],
    "_id": "5b9bfb3761c22f4fb5beb5cc",
    "name": "mex",
    "Created_date": "2021-07-12T18:17:27.009Z",
    "__v": 15.97
  }
]
```

Para que este serviço seja considerado operacional, necessita de responder às solicitações, mas também de fornecer as respostas em quatro moedas. Não estamos preocupados com o conteúdo no momento, apenas com o fato de termos quatro elementos de volta na matriz um, para cada moeda CDN, USD, EUR e MEX.

Usando o monitoramento sintético da New Relic, um script de teste de API poderia ter a seguinte aparência:

```
/**
* This script checks to see if we get the currency data from the endpoint.
*/
var assert = require('assert');
var myQueryKey = 'secret_key';
var options = {
  uri: 'http://example_ip:3000/exchange',
  headers: {
    'X-Query-Key': myQueryKey,
    'Accept': 'application/json'
  }
};

function callback (err, response, body){
  var data = JSON.parse(body);
  var info = body;
  if (Array.isArray(data)) {
    if (data.length !== 4) {
      assert.fail('Unexpected results in API Call, result was ' + JSON.stringify(data));
    }
  }
}

$http.get(options, callback);
```

O script Sintético pode ser configurado diretamente na interface do New Relic, mas é altamente recomendável que você mantenha seus testes de endpoint dentro do sistema de repositório de origem e empregue automação. Isso ajudará a garantir que seus testes de endpoint acompanhem a nova dependência de endpoint que seus serviços introduzem na entrega de serviços de produção.

## Realização de valor [#value-realization]

O impacto da instrumentação de serviço estará diretamente relacionado ao nível de atenção que você deseja investir na supervisão do processo. Assim como o processo de serviços de monitoramento, seu programa de observabilidade se beneficiará por meio de uma equipe dedicada que pensa criticamente sobre suas expectativas de retorno pelo seu investimento em esforço. Aqui estão algumas orientações para pensar sobre o custo do investimento para sua organização e a expectativa de benefício.

A seção a seguir descreve uma abordagem para estimar os investimentos e retornos que você deve esperar ao incorporar a instrumentação de serviço em sua prática de observabilidade.

### Investimentos [#investments]

<CollapserGroup>
  <Collapser
    id="inv-training"
    title="Treinamento"
  >
    Certifique-se de que todos os desenvolvedores estejam familiarizados com os recursos do agente e da plataforma do SDK do New Relic.

    <DoNotTranslate>**Cost model:**</DoNotTranslate> Depende do modelo FTE dos desenvolvedores da sua empresa e da estimativa do projeto.

    <DoNotTranslate>**Estimation:**</DoNotTranslate> Normalmente, um número de horas para um desenvolvedor se tornar efetivo usando o recurso de instrumentação New Relic.

    * Inicial: 16 horas de treinamento/exploração
    * Recorrente: 4 horas/revisão Q
    * Para os desenvolvedores, um investimento anual de 16 a 40 horas de treinamento para desenvolver habilidades essenciais e manter a atualização das habilidades para a plataforma New Relic
  </Collapser>

  <Collapser
    id="inv-maintain"
    title="Desenvolvimento e manutenção"
  >
    O esforço de desenvolvimento necessário para implementar e manter a instrumentação dentro de um projeto de serviço.

    <DoNotTranslate>**Cost model:**</DoNotTranslate> Depende do modelo FTE dos desenvolvedores da sua empresa e da estimativa do projeto.

    <DoNotTranslate>**Estimation:**</DoNotTranslate> Isso tende a depender do escopo do projeto e da quantidade de trabalho de instrumentação necessária.

    * Inicial: 8 horas por desenvolvedor por serviço
    * Recorrente: 4 horas/manutenção Q
    * Por desenvolvedores, uma estimativa de projeto de 16 a 32 horas desenvolvendo e mantendo instrumentação de serviço
  </Collapser>
</CollapserGroup>

### Devoluções [#returns]

<CollapserGroup>
  <Collapser
    id="returns-aqm-impact"
    title="Impacto da GQA"
  >
    Nossa [prática de gerenciamento de qualidade de alerta](/docs/new-relic-solutions/observability-maturity/uptime-performance-reliability/aqm-implementation-guide) oferece benefícios significativos à equipe de operações, garantindo que as notificações de alerta do desempenho do sistema variante sejam tratadas rapidamente. Isto melhora a prestação de serviços e a alocação de recursos durante a remediação de incidentes.

    Uma prática de instrumentação eficaz integrada ao seu programa de observabilidade melhorará muito a capacidade da sua equipe de criar alertas significativos.

    <DoNotTranslate>
      **KPIs:**
    </DoNotTranslate>

    * Volume: contagem de incidentes
    * Volume: duração acumulada do incidente
    * Volume: tempo médio de fechamento (MTTC)
    * Engajamento do usuário: tempo médio para investigar

    <DoNotTranslate>
      **Outcomes:**
    </DoNotTranslate>

    * Menos ruído de alerta
    * Maior capacidade de resposta a alertas e incidentes
    * Causa raiz menos desconhecida
    * Aumento da produtividade das operações
    * Melhor prestação de serviços
  </Collapser>

  <Collapser
    id="returns-service-quality-improvement"
    title="Melhoria da qualidade do serviço"
  >
    Melhorar a qualidade do seu serviço terá um impacto direto na métrica financeira chave do seu serviço. Isso exigirá que você tenha um modelo financeiro bem racionalizado para o seu aplicativo. Normalmente, esse retorno pode ser projetado associando-se um valor monetário para cada percentual de melhoria em uma medida básica de qualidade de serviço, como erros ou atingimento de apdex.

    À medida que seu investimento em instrumentação de serviço aumenta, você deverá observar um melhor desempenho em suas medidas de qualidade de serviço.

    <DoNotTranslate>**KPI:**</DoNotTranslate> Qualidade do serviço (KPI de negócios)

    <DoNotTranslate>
      **Outcomes:**
    </DoNotTranslate>

    * Diminuição do número de erros que impactam o usuário
    * Componentes de serviço com mais desempenho e resiliência
  </Collapser>

  <Collapser
    id="returns-service-delivery-improvement"
    title="Melhoria na prestação de serviços"
  >
    Ao fornecer melhor telemetria da sua instância de serviço, sua organização de entrega deverá ser capaz de detectar volatilidade ou período de inatividade mais rapidamente e remediar mais rapidamente. Isso levará a melhores KPIs gerais de prestação de serviços e diminuirá os episódios de interrupção ou degradação.

    O custo pode estar associado ao tempo necessário para detectar, investigar e remediar um incidente. Isso pode estar relacionado ao valor que o Serviço oferece à sua organização, que será perdido durante um evento, ou pode estar relacionado ao custo geral para lidar com o mau comportamento do Serviço.

    <DoNotTranslate>
      **KPIs:**
    </DoNotTranslate>

    * Tempo médio para detecção (MTTD)
    * Tempo médio para identificar (MTTI)
    * Tempo médio de resolução (MTTR)

    <DoNotTranslate>
      **Outcomes:**
    </DoNotTranslate>

    * Tempo reduzido para detectar incidente
    * Diminuição do tempo para resolução do incidente
  </Collapser>
</CollapserGroup>

## Recursos [#resources]

* [New Relic University](https://learn.newrelic.com/).

* Instalação e [configuração](/docs/new-relic-one/install-configure/configure-new-relic-agents) [do agente APM](/docs/new-relic-one/install-configure/install-new-relic/#apm-install)

* Guias de instrumentação:

  * [C-SDK](/docs/apm/agents/c-sdk/instrumentation/instrument-your-app-c-sdk)
  * [Go](/docs/apm/agents/go-agent/instrumentation)
  * [Java](/docs/apm/agents/java-agent/custom-instrumentation/java-custom-instrumentation)
  * [.NET](/docs/apm/agents/net-agent/custom-instrumentation/introduction-net-custom-instrumentation)
  * [Node.js](/docs/apm/agents/nodejs-agent/extend-your-instrumentation/nodejs-custom-instrumentation)
  * [PHP](/docs/apm/agents/php-agent/php-agent-api/)
  * [Python](/docs/apm/agents/python-agent/custom-instrumentation/python-custom-instrumentation/)
  * [Ruby](/docs/apm/agents/ruby-agent/api-guides/ruby-custom-instrumentation/)
  * [SDKs OpenTelemetry](https://opensource.newrelic.com/projects/open-telemetry)

* [Introdução ao monitoramento sintético New Relic](/docs/synthetics/)