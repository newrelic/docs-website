---
title: Configuração avançada para monitoramento de rede
tags:
  - Integrations
  - Network monitoring
  - Advanced configuration
metaDescription: Advanced configuration options for network monitoring
freshnessValidatedDate: never
translationType: machine
---

Se você quiser explorar todas as opções que pode usar ao configurar o monitoramento da sua rede, consulte as seções a seguir.

## `snmp-base.yaml` arquivo de amostra [#snmp-base-yml-template]

Aqui está um exemplo das diversas opções de configuração disponíveis no arquivo `snmp-base.yaml` usado pela imagem Docker `ktranslate` para pesquisar dispositivos SNMP e de dados de fluxo. Você também pode ver um exemplo muito comentado no [repositório KTranslate no GitHub](https://github.com/kentik/ktranslate/blob/main/config/snmp.yaml.sample).

```yaml
# Configuration of every device monitored by this container
devices:
  # Sample of SNMP v2c device
  ups_snmpv2c__10.10.0.201:
    device_name: ups_snmpv2c
    device_ip: 10.10.0.201
    snmp_comm: $YOUR_COMMUNITY_STRING
    oid: .1.3.6.1.4.1.318.1.3.27
    description: "APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: apc_ups.yml
    provider: kentik-ups
    poll_time_sec: 300
    retries: 1
    timeout_ms: 5000
    user_tags:
      owning_team: dc_ops
    discovered_mibs:
    - PowerNet-MIB_UPS
    - TCP-MIB
    - UDP-MIB
    purge_after_num: 1
  # Sample of SNMP v3 device
  router_snmpv3__10.10.0.202:
    device_name: router_snmpv3
    device_ip: 10.10.0.202
    snmp_v3:
      user_name: $YOUR_USER_NAME
      authentication_protocol: $YOUR_AUTH_PROTOCOL
      authentication_passphrase: $YOUR_AUTH_PASSPHRASE
      privacy_protocol: $YOUR_PRIVACY_PROTOCOL
      privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
    oid: .1.3.6.1.4.1.9.1.544
    description: "Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version
      15.1(3)T4, RELEASE SOFTWARE (fc1)\r\nTechnical Support: http://www.cisco.com/techsupport\r\nCopyright
      (c) 1986-2012 by Cisco Systems, Inc.\r\nCompiled Thu 24-May-12 04:27 by prod_rel_team"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: cisco-asr.yml
    provider: kentik-router
    user_tags:
      owning_team: core-networking
    discovered_mibs:
    - BGP4-MIB
    - CISCO-MEMORY-POOL-MIB
    - CISCO-PROCESS-MIB
    - IF-MIB
    - OSPF-MIB
    engine_id: "80:00:01:01:0a:14:1e:28"
    match_attributes:
      if_interface_name: "^Ten.*|^Gig.*"
      "!if_Alias": "[Uu]plink"
  # Sample of SNMP v1 device
  netbotz_snmpv1__10.10.0.203:
    device_name: netbotz_snmpv1
    device_ip: 10.10.0.201
    snmp_comm: $YOUR_COMMUNITY_STRING
    use_snmp_v1: true
    oid: .1.3.6.1.4.1.5528.100.20.10.2013
    description: "Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: apc-netbotz.yml
    provider: kentik-netbotz
    user_tags:
      owning_team: sys_ops
    discovered_mibs:
    - IF-MIB
    - IP-MIB
    - TCP-MIB
    - UDP-MIB
    no_use_bulkwalkall: true
  # Sample of "flow only" device
  flow_only__10.10.0.210:
    device_name: flow_only
    device_ip: 10.10.0.210
    user_tags:
      owning_team: net_eng
    flow_only: true
  # Sample of "ping only" device
  ping_only__10.10.0.220:
    device_name: ping_only
    device_ip: 10.10.0.220
    provider: kentik-ping
    user_tags:
      owning_team: load_balancing
    ping_only: true
    ping_interval_sec: 5
  # Sample of Arista eAPI device
  arista_eapi_10.10.0.230:
    device_name: arista_eapi
    device_ip: 10.10.0.230
    snmp_comm: public
    oid: .1.3.6.1.4.1.30065.1.3011.7020.3735.24.2878.2
    description: "Arista Networks EOS version 4.22.9M running on an Arista
      Networks DCS-7020SR-24C2"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: arista-switch.yml
    provider: kentik-switch
    discovered_mibs:
    - ARISTA-BGP4V2-MIB
    - ARISTA-QUEUE-MIB
    - BGP4-MIB
    - HOST-RESOURCES-MIB
    - IF-MIB
    ext:
      ext_only: false
      eapi_config:
        username: $YOUR_ARISTA_API_USERNAME
        password: $YOUR_ARISTA_API_PASSWORD
        transport: https
        port: 443
  # Sample of Meraki Dashboard API device
  meraki_dashboard_api:
    device_name: meraki_controller
    device_ip: snmp.meraki.com
    provider: meraki-cloud-controller
    ext:
      ext_only: true
      meraki_config:
        api_key: $YOUR_MERAKI_API_KEY
        monitor_devices: true
        monitor_org_changes: true
        monitor_uplinks: true
        monitor_vpn_status: true
        organizations:
          - "Top Org.*"
        networks:
          - "Production"
          - "Guest"
        product_types:
          - appliance
        preferences:
          device_status_only: true
          hide_uplink_usage: false
          show_vpn_peers: true
          show_network_attr: true
# Configuration for receipt of SNMP Traps
trap:
  listen: 0.0.0.0:1620
  community: public
  version: ""
  transport: ""
  v3_config: null
  trap_only: false
  drop_undefined: false
# Configuration for the SNMP discovery job
discovery:
  cidrs:
  - 10.0.0.0/24
  - 10.0.0.202/32
  ignore_list:
  - 10.0.0.98
  - 10.0.0.99
  debug: false
  ports:
  - 161
  - 1161
  default_communities:
  - $YOUR_COMMUNITY_STRING_1
  - $YOUR_COMMUNITY_STRING_2
  - $YOUR_COMMUNITY_STRING_3
  use_snmp_v1: false
  default_v3: null
  add_mibs: true
  threads: 4
  add_devices: true
  replace_devices: true
  no_dedup_engine_id: false
  check_all_ips: true
global:
  poll_time_sec: 60
  drop_if_outside_poll: false
  mib_profile_dir: /etc/ktranslate/profiles
  mibs_db: /etc/ktranslate/mibs.db
  mibs_enabled:
  - ARISTA-BGP4V2-MIB
  - ARISTA-QUEUE-MIB
  - BGP4-MIB
  - CISCO-MEMORY-POOL-MIB
  - CISCO-PROCESS-MIB
  - HOST-RESOURCES-MIB
  - IF-MIB
  - OSPF-MIB
  - PowerNet-MIB_UPS
  timeout_ms: 3000
  retries: 0
  global_v3: null
  response_time: false
  user_tags:
    environment: production
  match_attributes:
    if_Description: ".*WAN.*"
  purge_devices_after_num: 0
```

<CollapserGroup>
  <Collapser
    id="devices"
    title="Seção de dispositivos"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nome da chave
          </th>

          <th>
            Obrigatório
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            device_name
          </td>

          <td>
            ✓
          </td>

          <td>
            Nome do dispositivo. Este é o identificador exclusivo do dispositivo no New Relic.
          </td>
        </tr>

        <tr>
          <td>
            device_ip
          </td>

          <td>
            ✓
          </td>

          <td>
            IP de destino do dispositivo.
          </td>
        </tr>

        <tr>
          <td>
            snmp_comm
          </td>

          <td>
            ✓ (Obrigatório para SNMPv1/2c)
          </td>

          <td>
            `SNMPv1/2c` string de comunidade a ser usada.
          </td>
        </tr>

        <tr>
          <td>
            use_snmp_v1
          </td>

          <td>
            ✓ (Obrigatório para SNMPv1)
          </td>

          <td>
            Indica se deve usar SNMPv1. Por padrão, está definido como `false`.
          </td>
        </tr>

        <tr>
          <td>
            snmp_v3
          </td>

          <td>
            ✓ (Obrigatório para SNMPv3)
          </td>

          <td>
            [Configuração SNMP v3](#snmpv3-config)
          </td>
        </tr>

        <tr>
          <td>
            depurar
          </td>

          <td/>

          <td>
            Indica se o log de nível de depuração deve ser ativado durante a sondagem SNMP. Por padrão, está definido como `false`.
          </td>
        </tr>

        <tr>
          <td>
            port
          </td>

          <td/>

          <td>
            Porta para onde enviar consulta SNMP. Por padrão, está definido como porta `161`.
          </td>
        </tr>

        <tr>
          <td>
            oid
          </td>

          <td>
            ✓ (Obrigatório para pesquisa SNMP)
          </td>

          <td>
            O `systemObjectID | sysObjectID | sysOID` descoberto para o dispositivo. Isso é usado para combinar o dispositivo com um perfil SNMP conhecido e definir o atributo `provider` . Se nenhuma correspondência for encontrada, isso define o `provider` como um dispositivo [padrão do Kentik](/docs/network-performance-monitoring/troubleshooting/snmp-discovery-kentik-default) .
          </td>
        </tr>

        <tr>
          <td>
            descrição
          </td>

          <td/>

          <td>
            O `sysDescr` descoberto do dispositivo. Este campo é informativo.
          </td>
        </tr>

        <tr>
          <td>
            last_checked
          </td>

          <td/>

          <td>
            Timestamp em que este dispositivo foi descoberto pela última vez pela imagem do Docker `ktranslate`. Este campo é informativo.
          </td>
        </tr>

        <tr>
          <td>
            mib_profile
          </td>

          <td>
            ✓ (Obrigatório para pesquisa SNMP)
          </td>

          <td>
            Arquivo de perfil SNMP que foi associado a este dispositivo durante a execução da descoberta com base em seu `sysOID`. <DNT>**If this starts with a bang (!) token, it will override the automatic matching from the `sysOID` and use a manual override.**</DNT> Ex: `"!cisco-asa.yml"` (aspas são obrigatórias).
          </td>
        </tr>

        <tr>
          <td>
            provider
          </td>

          <td>
            ✓ (Obrigatório para New Relic)
          </td>

          <td>
            Valor usado durante a síntese da entidade para New Relic. Isso é criado automaticamente com base no `mib_profile` correspondente e deve corresponder a uma das regras no repositório [de definições de entidade](https://github.com/newrelic/entity-definitions/search?q=%22attribute%3A+provider%22+filename%3Adefinition.yml) para que uma entidade seja criada. Se estiver adicionando dispositivos manualmente, você precisará tomar cuidado para garantir que esse valor seja válido.
          </td>
        </tr>

        <tr>
          <td>
            poll_time_sec
          </td>

          <td/>

          <td>
            Indica a frequência de pesquisa SNMP em segundos. Esta configuração é usada para substituir o atributo `global.poll_time_sec` .
          </td>
        </tr>

        <tr>
          <td>
            novas tentativas
          </td>

          <td/>

          <td>
            Indica o número de tentativas de tentar novamente a pesquisa de OIDs SNMP. Esta configuração é usada para substituir o atributo `global.retries` .
          </td>
        </tr>

        <tr>
          <td>
            timeout_ms
          </td>

          <td/>

          <td>
            Indica o tempo limite de sondagem SNMP em milissegundos. Esta configuração é usada para substituir o atributo `global.timeout_ms` .
          </td>
        </tr>

        <tr>
          <td>
            user_tags
          </td>

          <td/>

          <td>
            `key:value` pair atributo para dar mais contexto ao dispositivo. tag neste nível será anexada a qualquer tag aplicada no atributo `global.user_tags` .
          </td>
        </tr>

        <tr>
          <td>
            discovered_mibs
          </td>

          <td/>

          <td>
            Lista de MIBs extraídos de `mib_profile` correspondentes aos quais este dispositivo pode responder. Este campo é informativo.
          </td>
        </tr>

        <tr>
          <td>
            engine_id
          </td>

          <td/>

          <td>
            O ID exclusivo do mecanismo descoberto para o agente SNMP deste dispositivo. Geralmente encontrado durante a descoberta do SNMP v3. Este campo é informativo.
          </td>
        </tr>

        <tr>
          <td>
            match_attributes
          </td>

          <td/>

          <td>
            `attribute:regex` pares para adicionar métricas à lista de permissões. Os pares neste nível serão anexados a quaisquer pares aplicados no atributo `global.match_attributes` . Usa a sintaxe [RE2](https://github.com/google/re2/wiki/Syntax) e possui um operador `OR` padrão. Chave de prefixo com `!` para forçar os operadores `AND` .
          </td>
        </tr>

        <tr>
          <td>
            monitor_admin_shut
          </td>

          <td/>

          <td>
            Indica se as interfaces devem monitor no status `Administratively Shutdown`. Por padrão, está definido como `false`.
          </td>
        </tr>

        <tr>
          <td>
            no_use_bulkwalkall
          </td>

          <td/>

          <td>
            Desativa a ação de solicitação SNMP `GETBULK` quando `true`. Por padrão, está definido como `false`.
          </td>
        </tr>

        <tr>
          <td>
            response_time
          </td>

          <td/>

          <td>
            Indica se a sondagem [do tempo de resposta](#response_time-attribute) está habilitada para este dispositivo. Por padrão, está definido como `false`.
          </td>
        </tr>

        <tr>
          <td>
            ping_only
          </td>

          <td/>

          <td>
            Desativa todas as pesquisas SNMP e ativa a pesquisa [de tempo de resposta](#response_time-attribute) para este dispositivo quando `true`. Esta configuração substituirá o atributo `global.response_time` . Por padrão, está definido como `false`. Você vai querer ter certeza de ter incluído a linha `provider: kentik_ping` para cada dispositivo ping_only.
          </td>
        </tr>

        <tr>
          <td>
            ping_interval_sec
          </td>

          <td/>

          <td>
            Essa configuração é usada para substituir a taxa padrão de 1 pacote/s usada durante `ping_only` \| `response_time` votação.
          </td>
        </tr>

        <tr>
          <td>
            flow_only
          </td>

          <td/>

          <td>
            Desativa todas as pesquisas SNMP quando `true`. Por padrão, está definido como `false`.
          </td>
        </tr>

        <tr>
          <td>
            purge_after_num
          </td>

          <td/>

          <td>
            Remove o dispositivo do arquivo de configuração após a falha dos trabalhos de descoberta agendados do X. <DNT>**This setting overrides the global `purge_devices_after_num` setting.**</DNT> Defina como `-1` para manter o dispositivo para sempre ou qualquer número inteiro >= `1` para configurar um limite de eliminação. (Padrão: `0`)
          </td>
        </tr>

        <tr>
          <td>
            ext
          </td>

          <td>
            ✓ (Obrigatório para pesquisa de API)
          </td>

          <td>
            [Configuração de pesquisa de API](#optional-api-polling-configurations)
          </td>
        </tr>

        <tr>
          <td>
            ext.ext_only
          </td>

          <td/>

          <td>
            Desativa todas as pesquisas SNMP para esta configuração `device_name` . Padrão: `false`.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="trap"
    title="Seção de armadilha"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nome da chave
          </th>

          <th>
            Obrigatório
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            ouvir
          </td>

          <td>
            ✓
          </td>

          <td>
            Porta IP de escuta para receber traps SNMP. Por padrão, ele é definido como `0.0.0.0:1620` e usamos um redirecionamento no comando `docker run ...` para redirecionar o UDP 162 mais comum no host para o UDP 1620 no contêiner. O redirecionamento é feito com este sinalizador `-p 162:1620/udp`
          </td>
        </tr>

        <tr>
          <td>
            comunidade
          </td>

          <td/>

          <td>
            Cadeia de caracteres da comunidade SNMPv1/v2c para receber traps SNMP. Por padrão, ainda processamos traps recebidos mesmo que eles não correspondam a esta comunidade.
          </td>
        </tr>

        <tr>
          <td>
            versão
          </td>

          <td/>

          <td>
            Versão SNMP a ser usada. As opções são `v1`, `v2c` e `v3`. Por padrão, está definido como `v2c`.
          </td>
        </tr>

        <tr>
          <td>
            transporte
          </td>

          <td/>

          <td>
            Protocolo de transporte SNMP a ser usado. As opções são `TCP` e `UDP`. Por padrão, está definido como `UDP`
          </td>
        </tr>

        <tr>
          <td>
            v3_config
          </td>

          <td/>

          <td>
            [Configuração SNMP v3](#snmpv3-config) a ser usada. Usado apenas se `version: v3`.
          </td>
        </tr>

        <tr>
          <td>
            trap_only
          </td>

          <td/>

          <td>
            Definir isso como `true` impedirá que o contêiner tente qualquer pesquisa SNMP ou ICMP, usada nos casos em que você deseja um contêiner que escute apenas interceptações recebidas.
          </td>
        </tr>

        <tr>
          <td>
            drop_undefined
          </td>

          <td/>

          <td>
            Definir isso como `true` impedirá que o contêiner encaminhe quaisquer mensagens de interceptação SNMP que não estejam explicitamente definidas em um perfil SNMP existente. (Padrão: `false`)
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="discovery"
    title="Seção de descoberta"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nome da chave
          </th>

          <th>
            Obrigatório
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            cidrs
          </td>

          <td>
            ✓
          </td>

          <td>
            matriz de faixas IP de destino em [notação CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). Esteja atento ao tamanho desses intervalos para [evitar um tempo limite](/docs/network-performance-monitoring/troubleshooting/snmp-discovery-no-devices).
          </td>
        </tr>

        <tr>
          <td>
            ignore_list
          </td>

          <td/>

          <td>
            Matriz de endereços IP que você deseja ignorar explicitamente durante todos os trabalhos de descoberta.
          </td>
        </tr>

        <tr>
          <td>
            depurar
          </td>

          <td/>

          <td>
            Indica se o log de nível de depuração deve ser habilitado durante a descoberta. Por padrão, está definido como `false`
          </td>
        </tr>

        <tr>
          <td>
            ports
          </td>

          <td>
            ✓
          </td>

          <td>
            Matriz de portas de destino a serem varridas durante a votação SNMP.
          </td>
        </tr>

        <tr>
          <td>
            default_communities
          </td>

          <td>
            ✓ (Obrigatório para SNMPv1/2c)
          </td>

          <td>
            Matriz de strings da comunidade SNMPv1/v2c para varredura durante a pesquisa SNMP. Essa matriz é avaliada em ordem e a descoberta aceita a primeira comunidade que passa.
          </td>
        </tr>

        <tr>
          <td>
            use_snmp_v1
          </td>

          <td>
            ✓ (Obrigatório para SNMPv1)
          </td>

          <td>
            Indica se o SNMPv1 deve ser usado durante a descoberta. Por padrão, está definido como `false`
          </td>
        </tr>

        <tr>
          <td>
            default_v3
          </td>

          <td>
            ✓ (Obrigatório para SNMPv3)
          </td>

          <td>
            [Configuração SNMPv3](#snmpv3-config) única para varredura durante a pesquisa SNMP.
          </td>
        </tr>

        <tr>
          <td>
            other_v3s
          </td>

          <td>
            ✓ (Obrigatório para SNMPv3)
          </td>

          <td>
            Múltiplas [configurações SNMPv3](#snmpv3-config) para varredura durante a pesquisa SNMP. <DNT>**Use this option OR `default_v3`, not both**</DNT>
          </td>
        </tr>

        <tr>
          <td>
            add_devices
          </td>

          <td>
            ✓
          </td>

          <td>
            Indica se os dispositivos descobertos devem ser adicionados à seção `devices` do arquivo `snmp-base.yaml` . Por padrão, está definido como `true`.
          </td>
        </tr>

        <tr>
          <td>
            add_mibs
          </td>

          <td>
            ✓
          </td>

          <td>
            Indica se MIBs descobertos devem ser incluídos na seção `global.mibs_enabled` do arquivo `snmp-base.yaml` . Por padrão, está definido como `true`.
          </td>
        </tr>

        <tr>
          <td>
            tópicos
          </td>

          <td>
            ✓
          </td>

          <td>
            Limite inteiro de threads a serem usados durante a descoberta. Deve ser menor que o número de núcleos disponíveis para o contêiner. Por padrão, está definido como `4`.
          </td>
        </tr>

        <tr>
          <td>
            replace_devices
          </td>

          <td>
            ✓
          </td>

          <td>
            Indica se os dispositivos descobertos devem ser substituídos se eles já existirem na seção `devices` do arquivo `snmp-base.yaml` . Por padrão, está definido como `true`.
          </td>
        </tr>

        <tr>
          <td>
            no_dedup_engine_id
          </td>

          <td/>

          <td>
            Quando definido como `true`, desativa a desduplicação de dispositivos descobertos se parecer que eles são o mesmo dispositivo, com base no ID do mecanismo SNMP relatado. Por padrão, está definido como `false`
          </td>
        </tr>

        <tr>
          <td>
            check_all_ips
          </td>

          <td/>

          <td>
            Quando definido como `true`, força o trabalho de descoberta a tentar a conectividade SNMP em todos os endereços IP de destino da matriz `cidrs` , sem verificar primeiro a atividade por meio da varredura de porta TCP. Essa configuração desacelerará os trabalhos de descoberta, mas pode ajudar a contornar problemas em que a descoberta falha em dispositivos que não estão listados na matriz `cidrs` com substituições `/32` . Por padrão, está definido como `false`
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="global"
    title="Seção global"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nome da chave
          </th>

          <th>
            Obrigatório
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            poll_time_sec
          </td>

          <td>
            ✓
          </td>

          <td>
            Tempo em segundos para pesquisar dispositivos. Isso pode ser substituído por dispositivo usando o atributo `devices.<deviceName>.poll_time_sec` . Por padrão, está definido como `60`.
          </td>
        </tr>

        <tr>
          <td>
            drop_if_outside_poll
          </td>

          <td/>

          <td>
            Indica se todos os valores deste ciclo serão eliminados se a sondagem demorar mais que o valor definido em `poll_time_sec`. Por padrão, está definido como `false`.
          </td>
        </tr>

        <tr>
          <td>
            mib_profile_dir
          </td>

          <td/>

          <td>
            Diretório para encontrar perfis MIB selecionados. Eles são extraídos automaticamente para a imagem `ktranslate` do repositório [snmp-profiles](https://github.com/kentik/snmp-profiles) do Kentik e podem ser substituídos no tempo de execução Docker criando uma montagem de volume de seu próprio diretório local de perfis.
          </td>
        </tr>

        <tr>
          <td>
            mibs_db
          </td>

          <td/>

          <td/>
        </tr>

        <tr>
          <td>
            mibs_enabled
          </td>

          <td>
            ✓
          </td>

          <td>
            Matriz de todos os MIBs ativos a imagem Docker `ktranslate` pesquisará. Esta lista será gerada automaticamente durante a descoberta se o atributo `discovery_add_mibs` for `true`. Os MIBs não listados aqui não serão pesquisados em nenhum dispositivo no arquivo de configuração. Você pode especificar uma tabela SNMP diretamente em um arquivo MIB usando a sintaxe `MIB-NAME.tableName` . Exemplo: `HOST-RESOURCES-MIB.hrProcessorTable`.
          </td>
        </tr>

        <tr>
          <td>
            timeout_ms
          </td>

          <td>
            ✓
          </td>

          <td>
            Tempo em milissegundos Tempo limite da consulta SNMP. Isso pode ser substituído por dispositivo usando o atributo `devices.<deviceName>.timeout_ms` . Por padrão, está definido como `3000`.
          </td>
        </tr>

        <tr>
          <td>
            novas tentativas
          </td>

          <td>
            ✓
          </td>

          <td>
            Número de tentativas de repetir pesquisas SNMP com falha. Isso pode ser substituído por dispositivo usando o atributo `devices.<deviceName>.retries` . Por padrão, está definido como `0`.
          </td>
        </tr>

        <tr>
          <td>
            user_tags
          </td>

          <td/>

          <td>
            `key:value` pair atributo para dar mais contexto ao dispositivo. tag neste nível será aplicada a todos os dispositivos no arquivo de configuração.
          </td>
        </tr>

        <tr>
          <td>
            match_attributes
          </td>

          <td/>

          <td>
            `attribute:regex` pares para adicionar métricas à lista de permissões. Os pares neste nível serão comparados com todos os dispositivos no arquivo de configuração. Usa a sintaxe [RE2](https://github.com/google/re2/wiki/Syntax) e possui um operador `OR` padrão. Chave de prefixo com `!` para forçar os operadores `AND` .
          </td>
        </tr>

        <tr>
          <td>
            response_time
          </td>

          <td/>

          <td>
            Indica se a sondagem [do tempo de resposta](#response_time-attribute) está habilitada para todos os dispositivos no arquivo de configuração. Por padrão, está definido como `false`.
          </td>
        </tr>

        <tr>
          <td>
            purge_devices_after_num
          </td>

          <td/>

          <td>
            Remove dispositivos do arquivo de configuração após a falha dos trabalhos de descoberta agendados do X. Defina como `-1` para manter os dispositivos para sempre ou qualquer número inteiro >= `1` para configurar um limite de eliminação. Por padrão, está definido como `0`.
          </td>
        </tr>

        <tr>
          <td>
            [watch_profile_changes](#watch-profile-changes)
          </td>

          <td/>

          <td>
            Configura um inspetor para [recarregar threads SNMP](#reload-snmp-threads) em alterações em perfis no caminho `mib_profile_dir`. Por padrão, está definido como `false`.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## Segredos do provedor de nuvem [#cloud-provider-secrets]

O agente de monitoramento de rede tem suporte integrado para recuperação de chaves do [AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/), [Azure Key Vault](https://learn.microsoft.com/en-us/azure/key-vault/general/) e [GCP Secret Manager](https://cloud.google.com/secret-manager/docs).

<Callout variant="important">
  SNMPv1 e SNMPv2c não suportam o uso de segredos de nuvem, pois os próprios protocolos enviam suas strings de comunidade por meio de texto simples por padrão. Se você estiver preocupado com a segurança da sua autenticação SNMP, atualize para usar o SNMPv3.
</Callout>

<Collapser
  id="cloud-secrets"
  title="Configuração de segredos da nuvem"
>
  <Tabs>
    <TabsBar>
      <TabsBarItem id="aws-secrets-manager">
        Gerenciador de segredos da AWS
      </TabsBarItem>

      <TabsBarItem id="azure-key-vault">
        Cofre de Chaves Azure
      </TabsBarItem>

      <TabsBarItem id="gcp-secret-manager">
        Gerenciador de segredos do GCP
      </TabsBarItem>
    </TabsBar>

    <TabsPages>
      <TabsPageItem id="aws-secrets-manager">
        Para usar AWS Secrets Manager, você precisará definir as três [variáveis ambientais](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html#envvars-list) a seguir e fornecê-las ao Docker em tempo de execução:

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                Nome
              </th>

              <th>
                Descrição
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `AWS_ACCESS_KEY_ID`
              </td>

              <td>
                Especifica a chave de acesso da AWS usada como parte das credenciais para autenticar o usuário.
              </td>
            </tr>

            <tr>
              <td>
                `AWS_SECRET_ACCESS_KEY`
              </td>

              <td>
                Especifica a chave secreta da AWS usada como parte das credenciais para autenticar o usuário.
              </td>
            </tr>

            <tr>
              <td>
                `AWS_REGION`
              </td>

              <td>
                Especifica a região da AWS para a qual enviar solicitações.
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \
        -e AWS_ACCESS_KEY_ID=$YOUR_AWS_ACCESS_KEY_ID \
        -e AWS_SECRET_ACCESS_KEY=$YOUR_AWS_SECRET_ACCESS_KEY \
        -e AWS_REGION=$YOUR_AWS_REGION \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>

      <TabsPageItem id="azure-key-vault">
        Para usar o Azure Key Vault, você precisará definir as cinco variáveis ambientais a seguir e fornecê-las ao Docker em tempo de execução:

        <Callout variant="tip">
          Você precisa definir `KT_AZURE_KEY_VAULT_NAME` ou `KT_AZURE_KEY_VAULT_URL`, não ambos. O padrão é usar `KT_AZURE_KEY_VAULT_NAME` e o agente usará um padrão de URL comum: `https://$KT_AZURE_KEY_VAULT_NAME.vault.azure.net/`
        </Callout>

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                Nome
              </th>

              <th>
                Descrição
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `KT_AZURE_KEY_VAULT_NAME`
              </td>

              <td>
                O nome do cofre onde o segredo está armazenado.
              </td>
            </tr>

            <tr>
              <td>
                `KT_AZURE_KEY_VAULT_URL`
              </td>

              <td>
                URL completo opcional para chamada de API para destino.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_CLIENT_ID](https://learn.microsoft.com/en-us/entra/identity-platform/howto-create-service-principal-portal#sign-in-to-the-application)
              </td>

              <td>
                Às vezes chamado de `Application ID`, esse é o identificador da entidade de serviço usada para acessar o segredo.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_CLIENT_SECRET](https://learn.microsoft.com/en-us/entra/identity-platform/howto-create-service-principal-portal#option-3-create-a-new-client-secret)
              </td>

              <td>
                Este é o segredo do cliente (senha) usado para a entidade de serviço durante a autenticação. Observe que esse ID é para o segredo do cliente <DNT>**value**</DNT> e não para o ID do segredo em si.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_SUBSCRIPTION_ID](https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id#find-your-azure-subscription)
              </td>

              <td>
                Este é o GUID de 32 dígitos associado à assinatura onde seu segredo é gerenciado.
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_TENANT_ID](https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id#find-your-microsoft-entra-tenant)
              </td>

              <td>
                Às vezes chamado de `Directory ID`, esse é o identificador do locatário no Microsoft Entra onde seu princípio de serviço está armazenado.
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -e KT_AZURE_KEY_VAULT_NAME=$YOUR_KEY_VAULT_NAME \
        #### Optional: Provide the full URL to target
        # -e KT_AZURE_KEY_VAULT_URL=$YOUR_KEY_VAULT_URL \
        -e AZURE_CLIENT_ID=$YOUR_CLIENT_ID \
        -e AZURE_CLIENT_SECRET=$YOUR_CLIENT_SECRET \
        -e AZURE_TENANT_ID=$YOUR_TENANT_ID \
        -e AZURE_SUBSCRIPTION_ID=$YOUR_SUBSCRIPTION_ID \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>

      <TabsPageItem id="gcp-secret-manager">
        Para usar o GCP Secret Manager, você precisará definir a seguinte montagem de volume para um arquivo JSON de credencial junto com duas variáveis ambientais e fornecê-las ao Docker em tempo de execução:

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                Nome
              </th>

              <th>
                Descrição
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                [Chave da conta de serviço](https://cloud.google.com/iam/docs/keys-create-delete#creating)
              </td>

              <td>
                Especifica o caminho do arquivo local para a chave da conta de serviço usada para autenticar o usuário. Este arquivo é montado em volume no contêiner Docker e depois referenciado na variável de ambiente `GOOGLE_APPLICATION_CREDENTIALS`.
              </td>
            </tr>

            <tr>
              <td>
                [GOOGLE_APPLICATION_CREDENTIALS](https://cloud.google.com/docs/authentication/provide-credentials-adc#local-key)
              </td>

              <td>
                Especifica o caminho do arquivo no contêiner onde você mapeou o arquivo de chave da conta de serviço.
              </td>
            </tr>

            <tr>
              <td>
                [GOOGLE_CLOUD_PROJECT](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
              </td>

              <td>
                Especifica o ID exclusivo do projeto onde o segredo está armazenado.
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -v $YOUR_LOCAL_SERVICE_ACCOUNT_KEY_FILE_PATH:/gcp_snmp_sa_key.json \
        -e GOOGLE_APPLICATION_CREDENTIALS='./gcp_snmp_sa_key.json' \
        -e GOOGLE_CLOUD_PROJECT=$YOUR_PROJECT_ID \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>
    </TabsPages>
  </Tabs>
</Collapser>

## Opções de SNMPv3 [#snmpv3-options]

<CollapserGroup>
  <Collapser
    id="snmpv3-config"
    title="Configuração SNMPv3"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nome da chave
          </th>

          <th>
            Obrigatório
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            user_name
          </td>

          <td>
            ✓
          </td>

          <td>
            Nome de usuário para autenticação SNMPv3
          </td>
        </tr>

        <tr>
          <td>
            authentication_protocol
          </td>

          <td>
            ✓
          </td>

          <td>
            Protocolo de autenticação SNMPv3. Os valores possíveis são `NoAuth`, `MD5` ou `SHA`
          </td>
        </tr>

        <tr>
          <td>
            authentication_passphrase
          </td>

          <td/>

          <td>
            Senha de autenticação SNMPv3
          </td>
        </tr>

        <tr>
          <td>
            privacy_protocol
          </td>

          <td>
            ✓
          </td>

          <td>
            Protocolo de privacidade SNMPv3. Os valores possíveis são `NoPriv`, `DES`, `AES`, `AES192`, `AES256`, `AES192C` ou `AES256C`
          </td>
        </tr>

        <tr>
          <td>
            privacy_passphrase
          </td>

          <td/>

          <td>
            Senha de privacidade SNMPv3
          </td>
        </tr>

        <tr>
          <td>
            context_engine_id
          </td>

          <td/>

          <td>
            ID do mecanismo de contexto SNMPv3
          </td>
        </tr>

        <tr>
          <td>
            context_name
          </td>

          <td/>

          <td>
            Nome do contexto SNMPv3
          </td>
        </tr>
      </tbody>
    </table>

    ### Exemplos:

    <Callout variant="tip">
      O uso de segredos da AWS, Azure, do GCP também exigirá que você [forneça as variáveis de ambiente adequadas](/docs/network-performance-monitoring/advanced/advanced-config/#cloud-secrets) e quaisquer outras informações de autenticação necessárias para que o agente consulte a API de destino.
    </Callout>

    <Tabs>
      <TabsBar>
        <TabsBarItem id="v3-plain-text">
          Texto simples
        </TabsBarItem>

        <TabsBarItem id="v3-aws-secret">
          Segredo da AWS
        </TabsBarItem>

        <TabsBarItem id="v3-azure-secret">
          Segredo do Azure
        </TabsBarItem>

        <TabsBarItem id="v3-gcp-secret">
          Segredo do GCP
        </TabsBarItem>
      </TabsBar>

      <TabsPages>
        <TabsPageItem id="v3-plain-text">
          ```yaml
          discovery:
            default_v3:
              user_name: $YOUR_SNMPV3_USER
              authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
              authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
              privacy_protocol: $YOUR_PRIVACY_PROTOCOL
              privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-aws-secret">
          ```yaml
          discovery:
            default_v3: aws.sm.$YOUR_SECRET_NAME
          ```

          Na AWS, você precisa [armazenar seus segredos em uma estrutura JSON](https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_secret_json_structure.html) com todos os pares `key:value` relevantes. Isto é um exemplo:

          ```json
          {
          "user_name": "$YOUR_SNMPV3_USER",
          "authentication_protocol": "$YOUR_AUTHENTICATION_PROTOCOL",
          "authentication_passphrase": "$YOUR_AUTHENTICATION_PASSPHRASE",
          "privacy_protocol": "$YOUR_PRIVACY_PROTOCOL",
          "privacy_passphrase": "$YOUR_PRIVACY_PASSPHRASE"
          }
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-azure-secret">
          ```yaml
          discovery:
            default_v3: azure.kv.$YOUR_SECRET_NAME
          ```

          No Azure, você precisa [armazenar seus segredos em uma estrutura multilinha](https://learn.microsoft.com/en-us/azure/key-vault/secrets/multiline-secrets) com todos os pares `key:value` relevantes. Isto é um exemplo:

          ```
          user_name: $YOUR_SNMPV3_USER
          authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
          authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
          privacy_protocol: $YOUR_PRIVACY_PROTOCOL
          privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-gcp-secret">
          ```yaml
          discovery:
            default_v3: gcp.sm.$YOUR_SECRET_NAME
          ```

          No GCP, você precisa [armazenar seus segredos em uma estrutura multilinha](https://cloud.google.com/secret-manager/docs/create-secret-quickstart) com todos os pares `key:value` relevantes. Isto é um exemplo:

          ```
          user_name: $YOUR_SNMPV3_USER
          authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
          authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
          privacy_protocol: $YOUR_PRIVACY_PROTOCOL
          privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>
      </TabsPages>
    </Tabs>
  </Collapser>

  <Collapser
    id="multiple-v3-discovery"
    title="Executando descoberta com vários perfis SNMP v3"
  >
    Para suportar a execução de tarefas de descoberta com vários perfis SNMP v3, você pode substituir a chave `discovery.default_v3` pela chave `discovery.other_v3s` , que contém uma matriz de [configuração SNMPv3](#snmpv3-config).

    ```yaml
    discovery:
      other_v3s:
      - user_name: $YOUR_USER_NAME_1
        authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL_1
        authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE_1
        privacy_protocol: $YOUR_PRIVACY_PROTOCOL_1
        privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE_1
        context_engine_id: ""
        context_name: ""
      - user_name: $YOUR_USER_NAME_2
        authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL_2
        authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE_2
        privacy_protocol: $YOUR_PRIVACY_PROTOCOL_1
        privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE_2
        context_engine_id: ""
        context_name: ""
    ```

    Isso também pode funcionar usando um gerenciador de segredos do provedor de nuvem. Um exemplo para AWS:

    ```yaml
    discovery:
      other_v3s:
      - aws.sm.$YOUR_SECRET_NAME_1
      - aws.sm.$YOUR_SECRET_NAME_2
    ```
  </Collapser>
</CollapserGroup>

## Configuração de pesquisa API [#api-polling-configurations]

<Callout variant="tip">
  Você também pode usar segredos do provedor de nuvem na configuração de autenticação da API.
</Callout>

<CollapserGroup>
  <Collapser
    id="arista"
    title="Arista eAPI"
  >
    A integração [Arista eAPI](https://www.arista.com/assets/data/pdf/Whitepapers/Arista_eAPI_FINAL.pdf) coleta telemetria BGP e MLAG adicional que normalmente não está disponível por meio de pesquisa SNMP.

    * Os detalhes do BGP são coletados deste comando: `show ip bgp summary vrf all`

      NRQL para encontrar telemetria BGP:

      ```sql
      FROM Metric SELECT
        max(kentik.eapi.bgp.InMsgQueue) AS 'InQ', // Messages Queued from the Neighbor
        max(kentik.eapi.bgp.MsgReceived) AS 'MsgSent', // Messages Received from the Neighbor
        max(kentik.eapi.bgp.MsgSent) AS 'MsgRcvd', // Messages Sent to the Neighbor
        latest(peer_state) AS 'State', // State of the BGP session
        latest(kentik.eapi.bgp.UpDownTime) AS 'Up/Down', // Period the BGP session has been in current state
        latest(kentik.eapi.bgp.Version) AS 'V' // BGP version number
      FACET
        entity.name AS 'Device',
        router_id AS 'Device IP',
        peer AS 'BGP Peer',
        peer_asn AS 'BGP Peer ASN',
        vrf AS 'VRF Name'
      ```

      <br/>

    * Os detalhes do MLAG são coletados deste comando: `show mlag detail`

      NRQL para encontrar telemetria MLAG:

      ```sql
      FROM Metric SELECT
        latest(kentik.eapi.mlag.PortsConfigured) AS 'Ports Configured', // Count of MLAG ports currently configured
        latest(kentik.eapi.mlag.PortsDisabled) AS 'Ports Disabled', // Count of MLAG ports in 'Disabled' state
        latest(kentik.eapi.mlag.PortsActivePartial) AS 'Ports Active-partial', // Count of MLAG ports in 'Active-partial' state 
        latest(kentik.eapi.mlag.PortsInactive) AS 'Ports Inactive', // Count of MLAG ports in 'Inactive' state
        latest(kentik.eapi.mlag.PortsActiveFull) AS 'Ports Active-full', // Count of MLAG ports in 'Active-full' state
        latest(kentik.eapi.mlag.PortsErrdisabled) AS 'Ports Err-disabled', // Count of MLAG ports in 'Err-disabled' state
        latest(config_sanity) AS 'Config-Sanity', // Current result of 'config-sanity' check
        latest(state) AS 'State', // Current MLAG state
        latest(neg_status) AS 'Negotiation Status', // Current negotiation status between switches
        latest(peer_address) AS 'Peer Address', // Address of MLAG peer
        latest(peer_link) AS 'Peer Link', // Link name for MLAG peer
        latest(peer_link_status) AS 'Peer Link Status', // Status of MLAG peer
        latest(local_interface) AS 'Local Interface', // Local interface used for MLAG configuration
        latest(local_intf_status) AS 'Local Interface Status' // Status of local interface used for MLAG configuration
      FACET
        entity.name AS 'Device',
        domain_id AS 'MLAG Domain ID'
      ```

      ### Opções de configuração

      <table>
        <thead>
          <tr>
            <th style={{ width: "200px" }}>
              Nome da chave
            </th>

            <th>
              Obrigatório
            </th>

            <th>
              Descrição
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              eapi_config.username
            </td>

            <td>
              ✓
            </td>

            <td>
              O nome de usuário a ser transmitido ao dispositivo para autenticar a autenticação eAPI.
            </td>
          </tr>

          <tr>
            <td>
              eapi_config.password
            </td>

            <td>
              ✓
            </td>

            <td>
              A senha a ser transmitida ao dispositivo para autenticar a autenticação eAPI.
            </td>
          </tr>

          <tr>
            <td>
              eapi_config.transport
            </td>

            <td/>

            <td>
              Especifica o tipo de transporte de conexão a ser usado. Os valores possíveis são `https` e `http`. Padrão: `https`.
            </td>
          </tr>

          <tr>
            <td>
              eapi_config.port
            </td>

            <td>
              ✓
            </td>

            <td>
              A porta TCP do endpoint para a conexão eAPI.
            </td>
          </tr>
        </tbody>
      </table>
  </Collapser>

  <Collapser
    id="meraki"
    title="Meraki dashboard API"
  >
    A integração [Meraki dashboard API](https://developer.cisco.com/meraki/api/) extrai várias métricas relacionadas à integridade do seu ambiente Meraki. A combinação de opções de configuração permite configurar diferentes cenários de monitoramento para suas necessidades e criar entidade em sua conta New Relic .

    <CollapserGroup>
      <Collapser
        id="meraki-organization"
        title="Meraki organização entidade"
      >
        Organização métrica são recolhidas por defeito na métrica `kentik.meraki.organization.Count` que é utilizada exclusivamente para gerar a `Meraki Organization` entidade. Isto serve principalmente para permitir a visualização da hierarquia Meraki para alinhar redes e dispositivos à sua organização pai.

        * `meraki_config.monitor_org_changes: true`: usa o [Obter alterações de configuração da organização](https://developer.cisco.com/meraki/api/get-organization-configuration-changes/) endpoint para visualizar o de alterações log da organização.

          NRQL para encontrar telemetria de alteração de configuração da organização:

          ```sql
          FROM KExtEvent SELECT *
          ```
      </Collapser>

      <Collapser
        id="meraki-network"
        title="Entidade da Rede Meraki"
      >
        * `meraki_config.preferences.show_network_attr: true`

          As métricas da rede são coletadas sob a métrica `kentik.meraki.network.Count` que é usada exclusivamente para gerar a entidade `Meraki Network` . Isto serve principalmente para permitir a visualização da hierarquia Meraki e alinhar os dispositivos à rede da qual são membros.
      </Collapser>

      <Collapser
        id="meraki-device"
        title="Entidade do dispositivo Meraki"
      >
        * `meraki_config.monitor_devices: true && meraki_config.preferences.device_status_only: true`: usa o [Obter status](https://developer.cisco.com/meraki/api/get-organization-devices-statuses/) endpoint de dispositivos de organização para listar o status de cada dispositivo Meraki na organização.

          NRQL para encontrar telemetria de status do dispositivo:

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Device Status' // Current status of this device
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            src_addr AS 'Device Public IP',
            mac AS 'Device MAC',
            model AS 'Device Model',
            serial AS 'Device Serial',
            address AS 'Device Address',
            lat AS 'Device Latitude',
            lng AS 'Device Longitude',
            notes AS 'Device Notes'
          WHERE instrumentation.name = 'meraki.device_status'
          ```

          <br/>

        * `meraki_config.monitor_uplinks: true && meraki_config.preferences.hide_uplink_usage: false`: Usa o endpoint [Obter status de uplinks de organização](https://developer.cisco.com/meraki/api/get-organization-uplinks-statuses/) e [Obter uso de uplinks de dispositivos de organização por rede](https://developer.cisco.com/meraki/api/get-organization-appliance-uplinks-usage-by-network/) para listar o status de uplink e o desempenho de cada dispositivo das séries Meraki MX, MG e Z na organização.

          NRQL para encontrar telemetria de uplink do dispositivo:

          ```sql
          FROM Metric SELECT
            max(kentik.meraki.uplinks.LatencyMS) AS 'Uplink Latency', // Uplink measured latency in milliseconds
            max(kentik.meraki.uplinks.LossPct) AS 'Uplink Loss %', // Uplink measured loss percentage
            max(kentik.meraki.uplinks.Recv) AS 'Uplink Receive Bytes', // Uplink bytes received
            max(kentik.meraki.uplinks.Sent) AS 'Uplink Transmit Bytes', // Uplink bytes sent
            latest(status) AS 'Uplink Status' // Latest status of the uplink
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            interface AS 'Device Uplink Interface',
            model AS 'Device Model',
            serial AS 'Device Serial'
          WHERE org_id IS NOT NULL
          ```

          <br/>

        * `meraki_config.monitor_uplinks: true && meraki_config.preferences.hide_uplink_usage: true`: Usa o [Obter status de uplinks](https://developer.cisco.com/meraki/api/get-organization-uplinks-statuses/) endpoint da organização para listar apenas o status do uplink de cada dispositivo das séries Meraki MX, MG e Z na organização.

          NRQL para encontrar telemetria de status de uplink do dispositivo:

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Uplink Status' // Latest status of the uplink
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            interface AS 'Device Uplink Interface',
            model AS 'Device Model',
            serial AS 'Device Serial'
          WHERE org_id IS NOT NULL
          ```

          <br/>

        * `meraki_config.monitor_vpn_status: true && meraki_config.preferences.show_vpn_peers: false`: Usa o [Obter status de VPN do Appliance](https://developer.cisco.com/meraki/api/get-organization-appliance-vpn-statuses/) endpoint de organização para mostrar status de VPN nas redes da organização.

          NRQL para encontrar a telemetria de status da VPN:

          ```sql
          FROM Metric SELECT
            latest(status) AS 'VPN Status' // Latest status of this VPN
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            serial AS 'Device Serial',
            vpn_mode AS 'VPN Mode',
            wan1 OR wan2 AS 'WAN Interface IP'
          WHERE instrumentation.name = 'meraki.vpn_status'
          AND org_id IS NOT NULL
          ```

          <br/>

        * `meraki_config.monitor_vpn_status: true && meraki_config.preferences.show_vpn_peers: true`: usa o [Obter status de VPN do](https://developer.cisco.com/meraki/api/get-organization-appliance-vpn-statuses/) endpoint dispositivo de organização para adicionar informações sobre peers de VPN nas redes da organização.

          NRQL para encontrar telemetria de pares VPN:

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Peer Status' // Current status of this VPN peer
          FACET
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            serial AS 'Device Serial',
            vpn_mode AS 'VPN Mode',
            wan1 AS 'WAN 1 IP',
            wan2 AS 'WAN 2 IP',
            peer_name AS 'Peer Name', // Name of this peer
            peer_reachability AS 'Peer Reachability', // Latest results of reachability test for this peer
            peer_network_id AS 'Peer Network ID', // Network ID for this peer
            peer_type AS 'Peer Type' // Type of Peer (Meraki vs Third-party)
          WHERE metricName = 'kentik.meraki.vpn_status.PeerStatus'
          ```
      </Collapser>

      <Collapser
        id="meraki-config-options"
        title="Opções de configuração Meraki"
      >
        <Collapser
          id="meraki-primary-config"
          title="Opções de configuração primária"
        >
          <Callout variant="tip">
            Você pode usar a variável de ambiente [KENTIK_MERAKI_API_KEY](/docs/network-performance-monitoring/advanced/ktranslate-container-management/#container-runtime-options) para passar sua chave de API para a integração Meraki sem armazená-la em texto simples em seu arquivo de configuração.
          </Callout>

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Nome da chave
                </th>

                <th>
                  Obrigatório
                </th>

                <th>
                  Entrada
                </th>

                <th>
                  Descrição
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki_config.api_key
                </td>

                <td>
                  ✓ (Não obrigatório se estiver usando a variável de ambiente [KENTIK_MERAKI_API_KEY](/docs/network-performance-monitoring/advanced/ktranslate-container-management) )
                </td>

                <td>
                  Chave de API (string)
                </td>

                <td>
                  [Chave de API dashboard Meraki](https://documentation.meraki.com/General_Administration/Other_Topics/Cisco_Meraki_Dashboard_API#Enable_API_Access) para autenticação.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.max_http_retry
                </td>

                <td/>

                <td>
                  Número inteiro entre 1 e 10 (padrão: 2)
                </td>

                <td>
                  Configuração opcional que controla a frequência com que uma nova tentativa é tentada em solicitações de API que retornam um erro `HTTP 429` . O intervalo entre novas tentativas é de 5 segundos.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_devices
                </td>

                <td/>

                <td>
                  verdade | falso (Padrão: falso)
                </td>

                <td>
                  Monitor o status de cada dispositivo Meraki na organização.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_org_changes
                </td>

                <td/>

                <td>
                  verdade | falso (Padrão: falso)
                </td>

                <td>
                  Monitorar o log de alterações da organização.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_uplinks
                </td>

                <td/>

                <td>
                  verdade | falso (Padrão: verdadeiro)
                </td>

                <td>
                  Monitore o status e o desempenho do uplink de todos os dispositivos das séries Meraki MX, MG e Z na organização.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_vpn_status
                </td>

                <td/>

                <td>
                  verdade | falso (Padrão: falso)
                </td>

                <td>
                  Monitorar os status da VPN nas redes da organização.
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser
          id="meraki-filter-config"
          title="Opções de filtragem"
        >
          Estas opções permitem restringir o monitoramento a objetos de destino específicos em seu ambiente Meraki.

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Nome da chave
                </th>

                <th>
                  Obrigatório
                </th>

                <th>
                  Entrada
                </th>

                <th>
                  Descrição
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki_config.organizations
                </td>

                <td/>

                <td>
                  Regex na [sintaxe RE2](https://github.com/google/re2/wiki/Syntax) (padrão: nulo)
                </td>

                <td>
                  Filtra todo monitoramento para uma lista específica de organização.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.networks
                </td>

                <td/>

                <td>
                  Regex na [sintaxe RE2](https://github.com/google/re2/wiki/Syntax) (padrão: nulo)
                </td>

                <td>
                  Filtra todo o monitoramento para uma lista específica de redes.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.product_types
                </td>

                <td/>

                <td>
                  Os tipos válidos são sem fio, dispositivo, switch, SystemsManager, câmera, CellularGateway, sensor e CloudGateway. (Padrão: nulo)
                </td>

                <td>
                  Adiciona parâmetro à solicitação do [monitor_devices](https://developer.cisco.com/meraki/api/get-organization-devices-statuses/) API para filtrar tipos específicos de dispositivos.
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser
          id="meraki-additional-config"
          title="Preferências adicionais"
        >
          Estas opções permitem definir melhor os dados coletados nas principais opções de configuração. Várias combinações são descritas na seção de exemplos acima.

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  Nome da chave
                </th>

                <th>
                  Obrigatório
                </th>

                <th>
                  Entrada
                </th>

                <th>
                  Descrição
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki_config.preferences.device_status_only
                </td>

                <td/>

                <td>
                  verdade | falso (Padrão: falso)
                </td>

                <td>
                  _Obrigatório_ ao usar `monitor_devices: true` para restringir a pesquisa apenas a informações de status. <DNT>**(This is used to prevent timeout issues.)**</DNT>
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.preferences.hide_uplink_usage
                </td>

                <td/>

                <td>
                  verdade | falso (Padrão: falso)
                </td>

                <td>
                  Usado em combinação com `monitor_uplinks` para remover métricas de desempenho e retornar apenas informações de status para uplinks.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.preferences.show_vpn_peers
                </td>

                <td/>

                <td>
                  verdade | falso (Padrão: falso)
                </td>

                <td>
                  Usado em combinação com `monitor_vpn_status` para adicionar telemetria em pares VPN.
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.preferences.show_network_attr
                </td>

                <td/>

                <td>
                  verdade | falso (Padrão: falso)
                </td>

                <td>
                  Usado para adicionar telemetria em redes. Necessário para criar `Meraki Network` entidade.
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>
      </Collapser>

      ### Exemplo de configuração mínima [#meraki-minimum-config]

      ```yaml
      # This represents the minimal configuration required for a container that only performs Meraki API polling.
      # By default we only monitor uplinks. All other items are optional.
      ---
       devices:
          meraki_cloud_controller:
            device_name: meraki_cloud_controller
            device_ip: snmp.meraki.com
            provider: meraki-cloud-controller
            ext:
              ext_only: true
              meraki_config:
                api_key: "$YOUR_API_KEY"
       trap: {}
       discovery: {}
       global:
         poll_time_sec: 300
         timeout_ms: 30000
      ```

      ### Exemplos completos de configuração [#meraki-full-config]

      #### Todas as opções necessárias para criar a entidade `Meraki Organization`, `Meraki Network` e `Meraki Device` .

      ```yaml
      devices:
        meraki_dashboard_api:
          device_name: meraki_controller
          device_ip: snmp.meraki.com
          provider: meraki-cloud-controller
          ext:
            ext_only: true
            meraki_config:
              api_key: $YOUR_MERAKI_API_KEY
              monitor_devices: true
              monitor_org_changes: true
              monitor_uplinks: true
              monitor_vpn_status: true
              preferences:
                device_status_only: true
                hide_uplink_usage: false
                show_vpn_peers: true
                show_network_attr: true
      trap: {}
      discovery: {}
      global:
        poll_time_sec: 300
        timeout_ms: 30000
      ```

      #### Direcionando a chave de API do dashboard Meraki para vários

      ```yaml
      devices:
         # Entity 1 - monitor everything this API key has access to
         meraki_all:
           device_name: meraki_all
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_1"
               max_http_retry: 8
               monitor_devices: true
               monitor_org_changes: true
               monitor_uplinks: true
               monitor_vpn_status: true
               preferences:
                 device_status_only: true
                 show_vpn_peers: true
                 hide_uplink_usage: false
         # Entity 2 - Monitor these specific organizations under this API key
         meraki_single_org:
           device_name: meraki_single_org
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_2"
               monitor_devices: true
               monitor_org_changes: true
               monitor_uplinks: true
               monitor_vpn_status: true
               preferences:
                 device_status_only: true
                 show_vpn_peers: true
                 hide_uplink_usage: false
               organizations:
                 - "Org 1 - Prod.*"
                 - "Org 2 - Staging"
         # Entity 3 - Monitor specific devices filtered by organization, network, and product types; using the same API key from Entity 2
         meraki_filtered:
           device_name: meraki_filtered
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_2"
               monitor_devices: true
               monitor_uplinks: false
               preferences:
                 device_status_only: true
               organizations:
                 - "Org 3 - Remote Sites"
               networks:
                 - "Corp.*99"
                 - "Retail.*"
               product_types:
                 - wireless
                 - appliance
      trap: {}
      discovery: {}
      global:
        poll_time_sec: 300
        timeout_ms: 30000
      ```
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

## Arquivos de configuração externos [#external-config-files]

Para oferecer suporte a uma ampla variedade de necessidades de configuração e automação, você pode usar arquivos externos montados em volume em seu contêiner Docker para desacoplar determinados elementos do arquivo de configuração padrão. Você precisará incluir o argumento mount abaixo no comando `docker run` , com um argumento por arquivo de configuração externo.

```
-v `pwd`/fileName.yaml:/fileName.yaml \
```

A sintaxe desses arquivos é `"@fileName.yaml"`, incluindo as aspas duplas.

<CollapserGroup>
  <Collapser
    id="discovery-cidrs-file"
    title="CIDRs de descoberta"
  >
    Exemplo:

    ```yaml
    discovery:
      cidrs: "@cidrs.yaml"
    ```

    O arquivo CIDRs deve usar uma sintaxe de lista YAML como esta:

    ```yaml
    - 10.10.0.0/24
    - 10.20.0.0/24
    - 192.168.0.21/32
    ```
  </Collapser>

  <Collapser
    id="devices-file"
    title="Dispositivos"
  >
    Exemplo:

    ```yaml
    devices:
      "@neteng-devices.yaml"
    ```

    Os arquivos do dispositivo devem usar a mesma sintaxe da seção `devices` padrão do arquivo de configuração principal, omitindo os campos opcionais gerados durante a descoberta:

    ```yaml
    devices:
      # Sample of SNMP v2c device
      ups_snmpv2c__10.10.0.201:
        device_name: ups_snmpv2c
        device_ip: 10.10.0.201
        snmp_comm: $YOUR_COMMUNITY_STRING
        oid: .1.3.6.1.4.1.318.1.3.27
        mib_profile: apc_ups.yml
        provider: kentik-ups
        poll_time_sec: 300
        retries: 1
        timeout_ms: 5000
        user_tags:
          owning_team: dc_ops
    ```
  </Collapser>
</CollapserGroup>

## O atributo `match_attributes` [#match_attributes-attribute]

Para oferecer suporte à filtragem de dados que não criam valor para suas necessidades de observabilidade, você pode definir o mapa de atributos `global.match_attributes.{}` e/ou `devices.[].match_attributes.{}` .

Isso fornecerá filtragem no nível `ktranslate` , antes de enviar dados para o New Relic, proporcionando controle granular sobre o monitoramento de itens como interfaces.

O comportamento padrão deste mapa é uma condição `OR` , mas você pode substituí-la e forçar um operador `AND` prefixando o nome da sua chave com `!`. Isso também é útil para retornar apenas itens correspondentes e omitir todos os resultados `null` e `""` (vazios).

<CollapserGroup>
  <Collapser
    id="default-or-null"
    title="Padrão 'OR' com valores nulos e vazios"
  >
    Combine quando `if_Alias` começar com `Uplink` <DNT>**OR**</DNT> quando `if_interface_name` começar com `Gig`, mantenha todos os valores de `null` e `""` :

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          if_Alias: "^Uplink.*"
          if_interface_name: "^Gig.*"
    ```
  </Collapser>

  <Collapser
    id="and-no-null"
    title="'AND', omita valores nulos e vazios"
  >
    Combine quando `if_Alias` começar com `Uplink` <DNT>**AND**</DNT> quando `if_interface_name` começar com `Gig`, elimine todos os valores `null` e `""` :

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          if_Alias: "^Uplink.*"
          "!if_interface_name": "^Gig.*"
    ```
  </Collapser>

  <Collapser
    id="single-no-null"
    title="Correspondência única, omitir valores nulos e vazios"
  >
    Combine quando `if_Alias` começar com `Uplink`, elimine todos os valores `null` e `""` :

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          "!if_Alias": "^Uplink.*"
    ```
  </Collapser>

  <Collapser
    id="negate-lookup"
    title="Crie uma previsão negativa"
  >
    O pacote regex de Golang não suporta padrões de lookahead negativos (`q(?!u)`) por padrão. Como solução alternativa, você pode adicionar o token `DOES_NOT_MATCH` ao seu mapa de atributo para fornecer efetivamente os resultados inversos do seu padrão de correspondência.

    Por exemplo, para corresponder em todas as interfaces que **não** incluem a string `Uplink`; você pode usar uma configuração como esta:

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          "!if_Alias": "^Uplink.*"
          DOES_NOT_MATCH: true
    ```
  </Collapser>
</CollapserGroup>

## O atributo `response_time` e `ping_only` [#response_time-attribute]

Para suportar o monitoramento de dispositivos onde as estatísticas de desempenho não estão acessíveis ou disponíveis, ou em casos simples onde o monitoramento do tempo de ida e volta (RTT) básico é necessário, você pode definir o atributo `global.response_time` ou `devices.[].ping_only` como `true`.

Este recurso usa o pacote [go-ping](https://pkg.go.dev/github.com/sparrc/go-ping) para enviar pacotes ICMP ou UDP sem privilégios para dispositivos a fim de coletar o tempo de ida e volta (RTT) médio, mínimo, máximo e stddev. Este pacote também mostra a porcentagem de perda de pacotes para o endpoint com base no envio de um pacote/seg de `ktranslate` para o endereço IP do dispositivo, que pode ser substituído pela configuração do atributo `devices.[].ping_interval_sec` . Você pode mudar do uso padrão de pacotes ICMP privilegiados ou UDP definindo a variável de ambiente `KENTIK_PING_PRIV=false` durante o tempo de execução Docker .

Definir o atributo `global.response_time` como `true` adicionará o monitoramento RTT à pesquisa SNMP existente. Para monitor dispositivos apenas com pacotes UDP|ICMP para RTT e sem sondagem SNMP, use `devices.[].ping_only: true`.

No New Relic, você pode ver os resultados desta pesquisa investigando a seguinte métrica:

```sql
FROM Metric SELECT
  average(kentik.ping.AvgRttMs) AS 'Average',
  max(kentik.ping.MaxRttMs) AS 'Max',
  min(kentik.ping.MinRttMs) AS 'Min',
  average(kentik.ping.StdDevRtt) AS 'StdDev',
  latest(kentik.ping.PacketLossPct) AS 'Packet Loss %'
FACET device_name
```

<Callout variant="tip">
  Você pode usar o atributo `ping_only` em substituição ao atributo `flow_only` se desejar coletar a métrica RTT de um dispositivo de fluxo. Se `ping_only` e `flow_only` forem `true`, o dispositivo será tratado como um dispositivo `flow_only` .
</Callout>

## O atributo `flow_only` [#flow_only-attribute]

Para oferecer suporte ao monitoramento de dispositivos onde você deseja coletar apenas dados de fluxo, você pode definir o atributo `devices.<deviceName>.flow_only` como `true`.

Isso gerará uma entidade <DNT>**Flow Device**</DNT> que terá telemetria apenas no namespace do evento `KFlow` . Como alternativa, a coleta de telemetria de fluxo de um dispositivo que está em seu arquivo de configuração como um dispositivo SNMP adicionará a decoração dos dados `KFlow` à entidade pré-existente, como <DNT>**Router**</DNT> ou <DNT>**Firewall**</DNT>.

No New Relic, você pode ver os resultados desta pesquisa investigando o seguinte evento:

```sql
FROM KFlow SELECT *
WHERE instrumentation.name = 'netflow-events'
```

## Aplicativo de mapeamento de dados de fluxo

Por padrão, a telemetria de fluxo é mapeada para um aplicativo conhecido com base na avaliação da porta da camada 4 em uso em uma conversa de fluxo específica. Se necessário, você pode substituir o mapeamento padrão fornecendo um arquivo YAML durante o tempo de execução Docker para a sinalização `-application_map`. Isso permitirá que você especifique nomes de aplicativos com base nas portas que você identificar.

Sintaxe de exemplo:

```yaml
applications:
  - ports: [9092, 9093]
    name: kafka
  - ports: [80, 8080]
    name: http
  - ports: [443, 8443]
    name: https
```

## Filtragem de entrada de dados de fluxo

Por padrão, o contêiner de dados de fluxo coletará e processará cada pacote de fluxo recebido. Se necessário, você pode adicionar um filtro de inclusão à sinalização `-nf.source` que ignorará todo o tráfego que não corresponda ao filtro fornecido.

<CollapserGroup>
  <Collapser
    id="flow-filter-options"
    title="Opções de filtro de fluxo"
  >
    Sintaxe: `--filters $TYPE,$FIELD,$FUNCTION,$MATCH`

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Nome do argumento
          </th>

          <th>
            Obrigatório
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            $TIPO
          </td>

          <td>
            ✓
          </td>

          <td>
            O tipo de filtro a ser aplicado. Os valores possíveis são `string`, `int` e `addr`.
          </td>
        </tr>

        <tr>
          <td>
            $ CAMPO
          </td>

          <td>
            ✓
          </td>

          <td>
            O nome do campo para avaliar o padrão de correspondência.
          </td>
        </tr>

        <tr>
          <td>
            $FUNÇÃO
          </td>

          <td>
            ✓
          </td>

          <td>
            O tipo de função a ser usada durante a avaliação. Os valores possíveis são `Equal: ==`, `NotEqual: !=`, `LessThan: <`, `GreaterThan: >`, `Contains: %`
          </td>
        </tr>

        <tr>
          <td>
            $MATCH
          </td>

          <td>
            ✓
          </td>

          <td>
            O valor a ser usado como padrão de correspondência.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="example-flow-filters"
    title="Filtros de exemplo"
  >
    * Colete dados de fluxo apenas de endereços de origem no intervalo CIDR `10.0.0.0/24`

      ```
      -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24
      ```

    * Colete dados de fluxo apenas onde a porta de destino não for igual a `8531`

      ```
      -nf.source netflow5 --filters int,l4_dst_port,!=,8531
      ```

    * Colete apenas dados de fluxo de endereços de origem no intervalo CIDR `10.0.0.0/24` E onde a porta de destino não seja igual a `8531` (operador `AND` implícito)

      ```
      --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531
      ```
  </Collapser>
</CollapserGroup>

## Recarregando automaticamente perfis SNMP personalizados [#reload-snmp-threads]

Por padrão, o contêiner Docker `ktranslate` deve ser destruído e reconstruído manualmente para incorporar alterações nos perfis SNMP no caminho [mib_profile_dir](#global). Este é um comportamento normal na maioria das implantações, pois a imagem Docker extrai os perfis mais recentes disponíveis no [repositório público de perfis snmp](https://github.com/kentik/snmp-profiles). Em situações em que você fornece [perfis personalizados](/docs/network-performance-monitoring/advanced/snmp-profiles/#private), você pode usar a configuração [watch_profile_changes](#global) para permitir que o contêiner atualize automaticamente as configurações subjacentes e os perfis SNMP do contêiner.

<Callout variant="important">
  Isso não é recursivo devido a uma limitação na [biblioteca do observador](https://github.com/fsnotify/fsnotify?tab=readme-ov-file#are-subdirectories-watched). Portanto, se um perfil for alterado em um subdiretório, você também deverá editar um arquivo de nível superior para acionar a alteração.
</Callout>

Assumindo esta estrutura de diretórios:

```
.
└── /snmp-profiles/
    └── profiles/
        └── kentik-snmp/
            ├── 3com
            ├── _general
            ├── a10networks
            └── ...
```

Você precisará colocar um novo arquivo na raiz do diretório e alterá-lo manualmente para acionar este ciclo de atualização. Uma maneira fácil de implementar isso é simplesmente gravar um timestamp em um arquivo como `last_updated.txt` quando sua alteração for enviada.

```
.
└── /snmp-profiles/
    ├── last_updated.txt
    └── profiles/
        └── kentik-snmp/
            ├── 3com
            ├── _general
            ├── a10networks
            └── ...
```
