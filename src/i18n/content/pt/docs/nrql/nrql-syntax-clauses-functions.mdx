---
title: Referência NRQL
tags:
  - Query your data
  - 'NRQL: New Relic Query Language'
  - Get started
metaDescription: 'A detailed reference list of clauses and functions in NRQL, the New Relic query language.'
freshnessValidatedDate: never
translationType: machine
---

Para escrever uma boa consulta [NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language) , é útil entender como funcionam nossas diversas cláusulas e funções NRQL . Este documento contém definições de cláusulas e funções NRQL e fornece exemplos de como usá-las.

Procurando regras básicas de sintaxe NRQL? Consulte [Como usar o NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-how-nrql-works). Para obter um tutorial, consulte [Tutorial introdutório de NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-tutorial).

## Componentes de consulta [#clauses]

Conforme observado em nosso [documento básico de sintaxe NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-how-nrql-works/#syntax), cada consulta NRQL conterá uma cláusula `SELECT` e uma cláusula `FROM` , sendo todas as outras cláusulas opcionais. As definições das cláusulas abaixo também contêm exemplos de consulta NRQL .

### DELETE palavra-chave [#delete]

A palavra-chave `DELETE` na New Relic Query Language (NRQL) é usada para remover dados e atributos específicos dentro do Controle de Pipeline. Isso ajuda a gerenciar os dados que são inseridos no New Relic banco de dados (NRDB).

A palavra-chave `DELETE` é aplicada na consulta NRQL para especificar quais dados ou atributos devem ser removidos. Aqui estão alguns exemplos:

Aqui estão alguns exemplos:

* **Excluindo métrica específica:**

  ```sql
  DELETE FROM Metric 
  WHERE metricName = 'newrelic.goldenmetrics.infra.kubernetes_pod.podScheduled'
  ```

  * Remove métrica com o nome especificado.

* **Excluindo intervalos específicos:**

  ```sql
  DELETE FROM Span WHERE appName = 'external-usage-consumer (test-odd-wire)'
  ```

  * Remove intervalos associados ao aplicativo especificado.

* **Excluindo atualizações específicas do agente:**

  ```sql
  DELETE FROM AgentUpdate WHERE a = 'b'
  ```

  * Remove atualizações do agente onde o atributo `a` é igual `b`.

### Cláusulas obrigatórias [#required]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="state-select"
    title={<>Obrigatório: declaração <InlineCode>
      SELECT
    </InlineCode></>
    }
  >
    ```sql
    SELECT attribute ...
    ```

    ```sql
    SELECT function(attribute) ...
    ```

    O `SELECT` especifica qual parte de um tipo de dados você deseja consultar especificando um [atributo](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#attribute) ou uma [função](#functions). É seguido por um ou mais argumentos separados por vírgulas. Em cada argumento você pode:

    * Obtenha os valores de todos os atributos disponíveis usando `*` como curinga. Por exemplo: `SELECT * FROM Transaction`.
    * Obtenha valores associados a um atributo especificado ou a vários atributos especificados em uma lista separada por vírgulas.
    * Obtenha valores agregados de um atributo especificado selecionando uma [função agregadora](#functions).
    * Rotule os resultados retornados em cada argumento com [a cláusula `AS` ](#sel-as).

    Você também pode [usar `SELECT` com funções matemáticas básicas](/docs/query-data/nrql-new-relic-query-language/getting-started/nrql-math-using-select).

    <CollapserGroup>
      <Collapser id="avg-resp-time-query" title="Tempo médio de resposta desde a semana passada">
        Esta consulta retorna o tempo médio de resposta desde a semana passada.

        ```sql
        SELECT average(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>

    Você pode incluir o curinga `*` e atributos individuais, [funções](#non-aggregator-functions), expressões matemáticas e [variáveisNRQL ](#with-as-nrql-var)na mesma instrução `SELECT`. `*` pode aparecer no início ou no final da lista `SELECT` , e as colunas adicionais selecionadas aparecerão no início ou no final da tabela de resultados, respectivamente:

    ```sql
    SELECT *, attribute, function(attribute), attribute1 + attribute2 FROM ...
    ```

    ```sql
    WITH attribute1 + attribute2 AS attrSum SELECT attrSum, attribute, function(attribute), * FROM ...
    ```

    <CollapserGroup>
      <Collapser
        id="select-star-with-columns-query"
        title={<><InlineCode>
          SELECT *
        </InlineCode> com colunas adicionais</>
        }
      >
        Esta consulta retorna todos os atributos PageView disponíveis com colunas adicionais no início.

        ```sql
        WITH concat('(', asnLatitude, ', ', asnLongitude, ')') AS coordinates
        SELECT coordinates, city, connectionSetupDuration + pageRenderingDuration AS partialDuration, *
        FROM PageView
        ```

        <img title="select star with additional columns" alt="select star with additional columns" src="/images/nrql_screenshot-select-star-with-additional-columns.webp" />

        <figcaption>
          <InlineCode>
            SELECT \*
          </InlineCode> com exemplo de colunas adicionais
        </figcaption>
      </Collapser>
    </CollapserGroup>

    <Callout variant="tip">
      Somente [funções não agregadoras](#non-aggregator-functions) são suportadas na lista `SELECT` junto com `*`.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-from"
    title={<>Obrigatório: cláusula <InlineCode>
      FROM
    </InlineCode></>
    }
  >
    ```sql
    SELECT ...
    FROM data type
    ...
    ```

    Use a cláusula `FROM` para especificar o [tipo de dados](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql#what-you-can-query) que você deseja consultar. Você pode iniciar sua consulta com `FROM` ou com [`SELECT`](#state-select). Você pode mesclar valores para o mesmo atributo em vários tipos de dados em uma lista separada por vírgulas.

    <CollapserGroup>
      <Collapser id="one-event" title="Consulte um tipo de dados">
        Esta consulta retorna a contagem de todas as [transações APM ](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults)nos últimos sete dias:

        ```sql
        SELECT count(*) FROM Transaction SINCE 7 days ago
        ```
      </Collapser>

      <Collapser id="multiple-events" title="Consultar vários tipos de dados">
        Esta consulta retorna a contagem de todos os [APM transação](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) e [eventos de Browser](/docs/insights/new-relic-insights/decorating-events/browser-default-attributes-insights#browser-attributes-table) nos últimos três dias:

        ```sql
        SELECT count(*) FROM Transaction, PageView SINCE 3 days ago
        ```
      </Collapser>

      <Collapser id="from-lookups" title="Consultar dados de uma tabela de consulta">
        Consulte [`lookup()`](#func-lookup).
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### Cláusulas opcionais [#optional]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="sel-as"
    title={<><InlineCode>
      AS
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    AS 'label'
    ...
    ```

    Use a cláusula `AS` para rotular um atributo, agregador, etapa de um funis ou o resultado de uma função matemática com uma string delimitada por aspas simples. O rótulo é usado no gráfico resultante. Observe que os rótulos de cláusula `AS` em gráficos de série temporal não serão exibidos se uma cláusula `FACET` for usada.

    <CollapserGroup>
      <Collapser
        id="math-as"
        title={<>Consulta usando função matemática e <InlineCode>
          AS
        </InlineCode></>
        }
      >
        Esta consulta retorna o número de visualizações de página por sessão:

        ```sql
        SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session'
        FROM PageView
        ```
      </Collapser>

      <Collapser
        id="funnel-as"
        title={<>Consulta usando funis e <InlineCode>
          AS
        </InlineCode></>
        }
      >
        Esta consulta retorna uma contagem de pessoas que visitaram a página principal e a página de carreiras de um site na semana passada:

        ```sql
        SELECT funnel(SESSION,
          WHERE name = 'Controller/about/main' AS 'Step 1',
          WHERE name = 'Controller/about/careers' AS 'Step 2')
        FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-compare"
    title={<><InlineCode>
      COMPARE WITH
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ... 
    (SINCE or UNTIL) (integer units) AGO
    COMPARE WITH (integer units) AGO
    ...
    ```

    Use a cláusula `COMPARE WITH` para comparar os valores de dois intervalos de tempo diferentes.

    `COMPARE WITH` requer uma instrução `SINCE` ou `UNTIL` . O horário especificado por `COMPARE WITH` é relativo ao horário especificado por `SINCE` ou `UNTIL`. Por exemplo, `SINCE 1 day ago COMPARE WITH 1 day ago` compara ontem com o dia anterior.

    O intervalo de tempo para o valor`COMPARE WITH` é sempre o mesmo especificado por `SINCE` ou `UNTIL`. Por exemplo, `SINCE 2 hours ago COMPARE WITH 4 hours ago` pode comparar das 15h às 17h com as 11h às 13h.

    `COMPARE WITH` pode ser formatado como um gráfico de linhas ou um outdoor:

    * Com `TIMESERIES`, `COMPARE WITH` cria um gráfico de linhas com a comparação mapeada ao longo do tempo.
    * Sem `TIMESERIES`, `COMPARE WITH` gera um outdoor com o valor atual e a variação percentual do valor `COMPARE WITH` .

    <DNT>**Example**</DNT>: esta consulta retorna dados como um gráfico de linhas mostrando o percentil 95 da semana anterior em comparação com o mesmo intervalo da semana anterior. Primeiro como um valor único e depois como um gráfico de linhas.

    ```sql
    SELECT percentile(duration, 95) FROM PageView
    SINCE 1 week ago COMPARE WITH 1 week AGO

    SELECT percentile(duration, 95) FROM PageView
    SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO
    ```

    <Callout variant="important">
      Para `FACET` consulta usando `COMPARE WITH`, as facetas no resultado são selecionadas com base no intervalo de tempo especificado usando `SINCE` e `UNTIL` e não no intervalo de tempo anterior que está sendo comparado. Os resultados de uma consulta `FACET` apenas para o intervalo de tempo anterior podem incluir um conjunto diferente de aspectos.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="extrapolate"
    title={<><InlineCode>
      EXTRAPOLATE
    </InlineCode> cláusula</>
    }
  >
    Você pode usar esta cláusula com estes tipos de dados:

    * `Transaction`

    * `TransactionError`

    * Evento personalizado reportado via <InlinePopover type="apm" />API do agente

      O objetivo de `EXTRAPOLATE` é compensar matematicamente os efeitos da [amostragem do agente APM de dados de eventos](/docs/agents/manage-apm-agents/agent-data/new-relic-events-limits-sampling) para que os resultados da consulta representem mais de perto a atividade total em seu sistema.

      Esta cláusula será útil quando um agente APM relata tantos [eventos](/docs/using-new-relic/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#event-data) que muitas vezes ultrapassa os limites de relatórios do [ciclo de coleta](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#harvest-cycle) . Quando isso ocorre, o agente começa a amostrar o evento.

      Quando `EXTRAPOLATE` é usado em uma consulta NRQL que suporta seu uso, a proporção entre <DNT>**reported events**</DNT> e <DNT>**total events**</DNT> é usada para extrapolar uma grande aproximação do total de dados sem amostragem. Quando é utilizado numa consulta NRQL que não suporta a sua utilização ou que não utilizou dados amostrados, não tem efeito.

      <Callout variant="important">
        Observe que `EXTRAPOLATE` é mais útil para dados homogêneos (como taxas de transferência ou taxas de erros). Não é eficaz ao tentar extrapolar uma contagem de coisas distintas (como `uniqueCount()` ou `uniques()`).
      </Callout>

      Esta cláusula funciona apenas com consultas NRQL que utilizam uma das seguintes [funções agregadoras](/docs/insights/nrql-new-relic-query-language/nrql-reference/nrql-syntax-components-functions#functions):

    * `apdex`

    * `average`

    * `count`

    * `histogram`

    * `sum`

    * `percentage` (se a função for tomada como argumento suporta `EXTRAPOLATE`)

    * `rate` (se a função for tomada como argumento suporta `EXTRAPOLATE`)

    * `stddev`

      <CollapserGroup>
        <Collapser id="extrapolate-example-1" title="Exemplo de extrapolação de taxas de transferência">
          Uma consulta que mostrará as taxas de transferência extrapoladas de um serviço denominado `interestingApplication`.

          ```sql
          SELECT count(*) FROM Transaction WHERE appName = 'interestingApplication' 
          SINCE 60 minutes ago EXTRAPOLATE
          ```
        </Collapser>

        <Collapser id="extrapolate-example-2" title="Exemplo de extrapolação de taxas de transferência como uma série temporal">
          Uma consulta que mostrará as taxas de transferência extrapoladas de um serviço denominado `interestingApplication` por nome de transação, exibidas como uma série temporal.

          ```sql
          SELECT count(*) FROM Transaction WHERE appName = 'interestingApplication'
          SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet"
    title={<><InlineCode>
      FACET
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    FACET attribute
    ...
    ```

    Use `FACET` para separar e agrupar seus resultados por valores de atributo. Por exemplo, você poderia `FACET` seus `PageView` dados por `deviceType` para descobrir qual porcentagem do seu tráfego vem de dispositivos móveis, tablets e desktops.

    Use a cláusula `LIMIT` para especificar quantas facetas aparecem (o padrão é 10). Para agrupamentos mais complexos, use [`FACET CASES`](#sel-facet-cases). As cláusulas `FACET` suportam até cinco atributos, separados por vírgulas.

    Os aspectos são classificados em ordem decrescente pelo primeiro campo fornecido na cláusula `SELECT` . Caso você esteja facetando um atributo com mais de 5.000 valores exclusivos, um subconjunto de valores de faceta é selecionado e ordenado de acordo com o tipo de consulta. Observe que se um gráfico de série temporal não retornar dados (NRQL não corresponde a dados correspondentes, NRQL inválido etc.), ele mostrará apenas uma linha plana com o rótulo correspondente à primeira tabela na cláusula `FROM` .

    Ao selecionar `min()`, `max()`, `percentile()`, `average()` ou `count()`, `FACET` usa essas funções para determinar como as facetas são escolhidas e classificadas. Ao selecionar qualquer outra [função](#functions), `FACET` usa a frequência do atributo que você está facetando para determinar como as facetas são selecionadas e classificadas.

    <CollapserGroup>
      <Collapser
        id="faceted-query"
        title={<>Consulta facetada usando <InlineCode>
          count()
        </InlineCode></>
        }
      >
        Esta consulta mostra as cidades com as maiores contagens de visualizações de página. Esta consulta usa o número total de visualizações de página por cidade para determinar como as facetas são escolhidas e ordenadas.

        ```sql
        SELECT count(*) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="uniquecount"
        title={<>Consulta facetada usando <InlineCode>
          uniqueCount()
        </InlineCode></>
        }
      >
        Esta consulta mostra as cidades que acessam o maior número de URLs exclusivos. Esta consulta utiliza o número total de vezes que uma determinada cidade aparece nos resultados para determinar como as facetas são selecionadas e ordenadas.

        ```sql
        SELECT uniqueCount(pageUrl) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser id="cohort-analysis" title="Agrupando resultados ao longo do tempo">
        [A segmentação avançada](/docs/insights/new-relic-insights/features/advanced-segmentation) e [a análise de coorte](/docs/insights/new-relic-insights/features/cohort-analysis-grouping-results-across-time) permitem que você analise as funções do bucket para dividir seus dados de maneira mais eficaz.

        A análise de coorte é uma forma de agrupar resultados com base no carimbo de data/hora. Você pode separá-los em grupos que cobrem um intervalo especificado de datas e horas.
      </Collapser>
    </CollapserGroup>

    <Callout variant="important">
      Ao usar funções para agregar valores de atributo, é importante que o atributo agregado na primeira função da sua consulta contenha valores não nulos. As facetas serão escolhidas apenas para linhas que contenham um valor não nulo para o atributo na primeira função.

      Exemplo:

      ```sql
      FROM Event SELECT average(attribute) FACET name
      ```

      Os nomes serão escolhidos apenas em linhas onde o atributo não é nulo.

      Para verificar se o atributo que você está usando na sua função contém valores não nulos, execute a seguinte consulta:

      ```sql
      FROM Event SELECT attribute, name WHERE attribute IS NOT NULL
      ```
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="facet-as"
    title={<><InlineCode>
      FACET ... AS
    </InlineCode> cláusula</>
    }
  >
    Use `FACET ... AS` para nomear facetas usando a palavra-chave `AS` na consulta. Esta cláusula é útil para adicionar nomes mais claros ou simplificados para facetas nos seus resultados. Também pode ser usado para renomear facetas em consultas [de agregação aninhadas](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query) .

    `FACET ... AS` consulta alterará os nomes das facetas nos resultados (quando aparecem como cabeçalhos nas tabelas, por exemplo), mas não os próprios nomes das facetas.

    ```sql
    FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type'
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-cases"
    title={<><InlineCode>
      FACET CASES
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    FACET CASES 
    (
      WHERE attribute operator value, 
      WHERE attribute operator value, 
      ...
    )
    ...
    ```

    Use `FACET CASES` para dividir seus dados por condições mais complexas do que é possível com [`FACET`](#sel-facet). Separe diversas condições com uma vírgula `,`. Por exemplo, você poderia consultar seus dados `PageView` e `FACET CASES` em categorias como menos de 1 segundo, de 1 a 10 segundos e mais de 10 segundos. Você pode combinar vários atributos em seus casos e rotular os casos com o seletor [`AS`](#sel-as). Os pontos de dados serão adicionados a no máximo um caso de faceta, o primeiro caso de faceta que eles corresponderem.

    Você também pode usar uma [função de tempo](/docs/query-data/nrql-new-relic-query-language/nrql-query-examples/group-results-across-time) com seu atributo e usar o operador `OR` para facetar resultados que não correspondam a nenhum dos casos especificados.

    <CollapserGroup>
      <Collapser
        id="facet-cases-basic"
        title={<>Uso básico com <InlineCode>
          WHERE
        </InlineCode></>
        }
      >
        ```sql
        SELECT count(*) FROM PageView 
        FACET CASES 
        (
          WHERE duration < 1, 
          WHERE duration > 1 AND duration < 10, 
          WHERE duration > 10
        )
        ```
      </Collapser>

      <Collapser id="facet-cases-mixnmatch" title="Grupo baseado em atributos múltiplos">
        Este exemplo agrupa os resultados em um bucket onde o nome da transação contém `login` e outro onde o URL contém `login` e um atributo personalizado indica que o usuário era um usuário pago:

        ```sql
        SELECT count(*) FROM Transaction 
        FACET CASES 
        (
          WHERE name LIKE '%login%', 
          WHERE name LIKE '%feature%' AND customer_type = 'Paid'
        )
        ```
      </Collapser>

      <Collapser
        id="facet-cases-as-label"
        title={<>Rotular grupos com <InlineCode>
          AS
        </InlineCode></>
        }
      >
        Este exemplo usa o seletor [`AS`](#sel-as) para dar aos resultados um nome legível:

        ```sql
        SELECT count(*) FROM Transaction 
        FACET CASES 
        (
          WHERE name LIKE '%login%' AS 'Total Logins', 
          WHERE name LIKE '%feature%' AND customer_type = 'Paid' AS 'Feature Visits from Paid Users'
        )
        ```
      </Collapser>

      <Collapser
        id="facet-cases-with-or"
        title={<>Facetar dados não correspondentes com <InlineCode>
          OR
        </InlineCode></>
        }
      >
        Este exemplo usa o operador `OR` para facetar resultados que não correspondem a nenhum dos seus casos:

        ```sql
        SELECT count(*) FROM Transaction 
        FACET CASES 
        (
          WHERE name LIKE '%login%', 
          WHERE name LIKE '%feature%' AND customer_type = 'Paid'
        ) 
        OR name
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-order"
    title={<><InlineCode>
      FACET ... ORDER BY
    </InlineCode> cláusula</>
    }
  >
    No NRQL, o padrão é a primeira agregação na cláusula `SELECT` para orientar a seleção de aspectos em uma consulta. `FACET ... ORDER BY` permite substituir esse comportamento padrão adicionando uma função agregada com o modificador `ORDER BY` para especificar como as facetas são selecionadas. Especificamente, a cláusula substituirá a prioridade pela qual as facetas são escolhidas para estarem no resultado final antes de serem limitadas pela cláusula `LIMIT`. Esta cláusula pode ser usada em consultas, mas não para alertas ou streaming.

    Este exemplo mostra como usar `FACET ... ORDER BY` para encontrar as durações médias de transação de aplicativos, mostrando as 10 durações mais altas (limite padrão) por aplicativos que têm o maior tamanho de resposta. Nesse caso, se `FACET ... ORDER BY` não for usado, os resultados da consulta mostrarão os 10 primeiros pelas durações mais altas, sendo o tamanho da resposta irrelevante para a seleção do aplicativo.

    ```sql
    FROM Transaction SELECT average(duration) TIMESERIES 
    FACET appName ORDER BY max(responseSize)
    ```

    Tenha em mente que se você usar a cláusula `FACET ... ORDER BY` , não poderá alterar a ordem de classificação adicionando os modificadores `ASC` e `DESC` . Por padrão, esta cláusula usa `DESC`.

    <Callout variant="tip">
      Como as operações são executadas antes da cláusula `LIMIT` ser aplicada, `FACET ... ORDER BY` não afeta o tipo dos resultados finais da consulta, o que será particularmente perceptível nos resultados de consultas que não sejam de séries temporais.
    </Callout>

    <Callout variant="important">
      O modificador `ORDER BY` neste caso funciona de maneira diferente da cláusula `ORDER BY` . Ao analisar consultas que seguem o formato `FACET attribute1 ORDER BY attribute2`, New Relic as lerá como `FACET ... ORDER BY` consulta, mas somente se `ORDER BY` aparecer imediatamente após `FACET`. Caso contrário `ORDER BY` será interpretado pela New Relic como uma cláusula.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-join"
    title={<><InlineCode>
      JOIN
    </InlineCode> cláusula</>
    }
  >
    Use a cláusula `JOIN` para combinar dados de um tipo de evento com os resultados de uma subconsulta baseada em um atributo ou chave comum.

    ```sql
    FROM Event [INNER|LEFT] JOIN (SELECT... FROM...) ON [key =] key SELECT ...
    ```

    Existem algumas regras simples para junções de subconsulta:

    * A cláusula `JOIN` deve sempre seguir imediatamente após a cláusula [`FROM`](#sel-from) .
    * Prefixar um tipo de junção (`INNER` ou `LEFT`) é opcional. Quando omitido, o tipo de junção é padronizado como `INNER`.
    * Parênteses contendo uma [subconsulta](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql) devem seguir imediatamente `JOIN`.
    * A cláusula `ON` deve seguir imediatamente a subconsulta.

    <table id="join-types">
      <thead>
        <tr>
          <th colSpan={2}>
            <DNT>
              **Join types**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td style={{ width: "300px" }}>
            `INNER`
          </td>

          <td>
            O resultado incluirá apenas valores da consulta externa que tenham um valor correspondente nos resultados da subconsulta associada. Este é o tipo de junção padrão.
          </td>
        </tr>

        <tr>
          <td>
            `LEFT`
          </td>

          <td>
            O resultado incluirá eventos da consulta externa que não correspondem à subconsulta associada.
          </td>
        </tr>
      </tbody>
    </table>

    <table id="join-on">
      <thead>
        <tr>
          <th colSpan={2}>
            <DNT>
              **Join `ON` clause**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td style={{ width: "300px" }}>
            `ON parentKey = subqueryKey`
          </td>

          <td>
            Define o valor principal a ser comparado na subconsulta e na consulta externa. O único operador de comparação permitido é a igualdade.

            * O lado esquerdo é sempre a chave usada na consulta pai e pode ser um atributo ou função.
            * O lado direito é utilizado para a subconsulta valor principal e deve ser um identificador.
          </td>
        </tr>

        <tr>
          <td>
            `ON key`
          </td>

          <td>
            Esta é uma sintaxe abreviada para quando o identificador da chave é o mesmo em ambos os contextos. É equivalente a `ON key = key`.
          </td>
        </tr>
      </tbody>
    </table>

    Restrições e limitações a considerar:

    * A subconsulta unida continuará a ter um [`LIMIT`](#sel-limit) padrão de 10, com um máximo de `LIMIT` de 5.000. Observe que o `LIMIT` da consulta externa não afeta a consulta interna.
    * O uso de `TIMESERIES` na subconsulta unida não é compatível. Se sua consulta externa usar `TIMESERIES`, lembre-se de que a subconsulta unida fornecerá um único resultado para todo o intervalo de tempo da consulta.
    * Como todas as subconsultas, as subconsultas unidas não podem ser utilizadas na condição do alerta.
    * Embora `SELECT *` seja compatível com a consulta pai, ele não é compatível com a subconsulta unida.
    * A cardinalidade da junção é limitada a 1:100, o que significa que uma única chave de junção não pode mapear mais de cem linhas no resultado da subconsulta.

    Para uma análise detalhada da cláusula `JOIN` , consulte o tutorial [de junções de subconsulta NRQL](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/subquery-joins).

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          INNER JOIN
        </InlineCode> com uma subconsulta facetada</>
        }
        id="example-faceted-inner-join"
      >
        Esta consulta encontra a contagem de eventos facetados por `browserTransactionName` do tipo de evento `PageView` e depois por `currentUrl` do tipo de evento `PageAction` . Isso une os dois tipos de eventos com base em valores de atributo `session` comuns.

        ```sql
        FROM PageView
        JOIN 
        (
          FROM PageAction 
          SELECT count(*) 
          FACET session, currentUrl
        ) 
        ON session
        SELECT count(*) FACET browserTransactionName, currentUrl
        ```

        <img title="screenshot faceted inner join" alt="screenshot faceted inner join" src="/images/nrql_screenshot-crop_example-faceted-inner-join.webp" />

        <figcaption>
          Exemplo <InlineCode>
            INNER JOIN
          </InlineCode> facetado
        </figcaption>
      </Collapser>

      <Collapser
        title={<><InlineCode>
          LEFT JOIN
        </InlineCode> com uma subconsulta facetada</>
        }
      >
        Este exemplo consulta os mesmos dados do [exemplo `INNER JOIN` facetado](#example-faceted-inner-join), mas como uma consulta `LEFT JOIN` , os resultados incluem itens na tabela `PageView` que não possuem valores `session` correspondentes nos resultados da subconsulta `PageAction` .

        ```sql
        FROM PageView
        LEFT JOIN 
        (
          FROM PageAction 
          SELECT count(*) 
          FACET session, currentUrl
        ) 
        ON session
        SELECT count(*) FACET browserTransactionName, currentUrl
        ```

        <img title="screenshot faceted left join" alt="screenshot faceted left join" src="/images/nrql_screenshot-crop_example-faceted-left-join.webp" />

        <figcaption>
          Exemplo <InlineCode>
            LEFT JOIN
          </InlineCode> facetado
        </figcaption>
      </Collapser>

      <Collapser
        title={<><InlineCode>
          INNER JOIN
        </InlineCode> com uma subconsulta não agregada</>
        }
      >
        Aqui estamos realizando uma subconsulta não agregada em linhas, com a consulta externa encontrando a contagem de eventos facetados por `currentUrl` do tipo de evento `PageAction` e depois por `browserTransactionNamed` do tipo de evento `PageView` . Isso une os dois tipos de eventos com base em valores de atributo `session` comuns.

        Observe que o valor `session` `34d5ce6acf4c60be` possui dois valores `browserTransactionName` do tipo de evento `PageView` da subconsulta, adicionando linhas adicionais ao resultado.

        ```sql
        FROM PageAction
        LEFT JOIN 
        (
          FROM PageView 
          SELECT session, browserTransactionName 
          LIMIT MAX
        ) 
        ON session
        SELECT count(*) FACET session, currentUrl, browserTransactionName LIMIT MAX
        ```

        <img title="screenshot columnar inner join" alt="screenshot columnar inner join" src="/images/nrql_screenshot-crop_example-columnar-inner-join.webp" />

        <figcaption>
          Exemplo <InlineCode>
            INNER JOIN
          </InlineCode> não agregado
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-limit"
    title={<><InlineCode>
      LIMIT
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    LIMIT count
    ...
    ```

    Use a cláusula `LIMIT` para controlar o número máximo de valores de faceta retornados por `FACET` consulta ou o número máximo de itens retornados por `SELECT *` consulta. Esta cláusula usa um único valor inteiro como argumento. Se a cláusula `LIMIT` não for especificada ou nenhum valor for fornecido, o limite será padronizado como 10 para `FACET` consulta e 100 no caso de `SELECT *` consulta.

    O valor máximo permitido para a cláusula `LIMIT` é 5.000. consulta pode usar a cláusula `LIMIT MAX` em vez de um valor específico, cujo padrão é automaticamente o valor máximo atual. Você pode usar isso se quiser sempre postar o número máximo de resultados, mesmo que isso mude no futuro. Se quiser que o comportamento da sua consulta permaneça inalterado, especifique um valor explícito em vez de usar `LIMIT MAX`.

    <CollapserGroup>
      <Collapser
        title={<>Consultar usando <InlineCode>
          LIMIT
        </InlineCode></>
        }
      >
        Esta consulta mostra os 20 principais países por contagem de sessões e fornece o 95º percentil do tempo de resposta para cada país apenas para usuários do Windows.

        ```sql
        SELECT uniqueCount(session), percentile(duration, 95)
        FROM PageView WHERE userAgentOS = 'Windows'
        FACET countryCode LIMIT 20 SINCE YESTERDAY
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-offset"
    title={<><InlineCode>
      OFFSET
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    LIMIT count OFFSET count
    ...
    ```

    Use a cláusula `OFFSET` com `LIMIT` para controlar a parte das linhas retornadas por `SELECT *` ou `SELECT column` consulta. Assim como a cláusula `LIMIT` , `OFFSET` usa um único valor inteiro como argumento. `OFFSET` define o número de linhas a serem ignoradas antes que as linhas selecionadas da sua consulta sejam retornadas. Isso é limitado por `LIMIT`.

    `OFFSET` as linhas são ignoradas a partir do registro mais recente.

    Por exemplo, a consulta `SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1` retorna os últimos 5 valores de `Minute_Report` exceto o mais recente.
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-order-by"
    title={<><InlineCode>
      ORDER BY
    </InlineCode> cláusula</>
    }
  >
    A cláusula `ORDER BY` permite especificar como deseja ordenar os resultados da consulta em consultas que selecionam evento atributo por linha.

    Esta consulta ordena dois atributos de transação específicos por duração.

    ```sql
    FROM Transaction SELECT appName, duration ORDER BY duration
    ```

    A ordem de classificação padrão é crescente, mas isso pode ser alterado adicionando os modificadores `ASC` ou `DESC` .

    Esta consulta ordena todos os atributos de transação por duração em ordem decrescente.

    ```sql
    FROM Transaction SELECT * ORDER BY duration DESC
    ```

    <Callout variant="important">
      A cláusula `ORDER BY` não se aplica à consulta `FACET` . Não deve ser confundida com a cláusula `FACET ... ORDER BY` , que orienta a seleção de facetas. Para obter mais informações, consulte [`FACET ... ORDER BY`](#sel-facet-order).
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="#sel-prediction"
    title={<><InlineCode>
      PREDICT
    </InlineCode> cláusula</>
    }
  >
    ```sql
    FROM Transaction SELECT count(*) WHERE error IS TRUE TIMESERIES PREDICT
    ...
    ```

    Com a cláusula `PREDICT` , você pode adicionar previsões de tendências de dados futuras em gráficos de linhas com base em dados históricos. Considere os seguintes pontos ao usar esta cláusula:

    * Aplica-se somente a consultas com cláusula `TIMESERIES` .
    * Usa `TIMESERIES <time period>` como intervalo para pontos de dados previstos.
    * Não oferece suporte [a dados de métrica de fração de tempo](/docs/data-analysis/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#timeslice-data) durante a Visualização Pública.

    <Callout variant="important">
      A cláusula `PREDICT` não pode ser usada com a cláusula [`COMPARE WITH`](/docs/nrql/nrql-syntax-clauses-functions/#sel-compare) ou [agregações aninhadas](/docs/nrql/using-nrql/nested-aggregation-make-ordered-computations-single-query) dentro [de subconsultas](/docs/nrql/using-nrql/subqueries-in-nrql/).
    </Callout>

    Para saber mais sobre como e quando você pode usar `PREDICT`, consulte [Previsões NRQL](/docs/query-your-data/explore-query-data/use-charts/nrql-predictions/).
  </Collapser>

  <Collapser
    className="freq-link"
    id="show-event-types"
    title={<><InlineCode>
      SHOW EVENT TYPES
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SHOW EVENT TYPES...
    ```

    `SHOW EVENT TYPES` retornará uma lista de todos os tipos de dados presentes em sua conta para um intervalo de tempo específico. É usado como a primeira cláusula em uma consulta em vez de `SELECT`.

    <Callout variant="important">
      Neste contexto, “tipos de eventos” referem-se aos tipos de dados que você pode acessar com uma consulta NRQL .
    </Callout>

    <CollapserGroup>
      <Collapser id="avg-resp-time-query" title="Tipos de dados no último dia">
        Esta consulta retornará todos os tipos de dados presentes no último dia:

        ```sql
        SHOW EVENT TYPES SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-since"
    title={<><InlineCode>
      SINCE
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    SINCE [numerical units AGO | phrase]
    ...
    ```

    O valor <DNT>**default**</DNT> é <DNT>**1 hour ago**</DNT>.

    Use a cláusula `SINCE` para definir o início inclusivo de um intervalo de tempo para os dados retornados. Você pode especificar um fuso horário para a consulta, mas não para os resultados. Os resultados do NRQL são baseados na hora do sistema.

    Ao usar NRQL, você pode definir um timestamp /hora UTC , um horário relativo ou uma string `DateTime`. Consulte [Especificando um horário](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/#spec-time).

    Veja também:

    * [Definir o intervalo de tempo de uma consulta](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/)
    * [ATÉ](#sel-until)
  </Collapser>

  <Collapser
    className="freq-link"
    id="slide-by"
    title={<><InlineCode>
      SLIDE BY
    </InlineCode> cláusula</>
    }
  >
    A cláusula `SLIDE BY` oferece suporte a um recurso conhecido como janelas deslizantes. Com janelas deslizantes,`SLIDE BY` os dados são reunidos em &quot;janelas&quot; de tempo que se sobrepõem entre si. Essas janelas podem ajudar a suavizar gráficos de linha com muita variação nos casos em que o agregado móvel (como uma média móvel) é mais importante do que agregados de janelas estreitas de tempo.

    Para usar `SLIDE BY`, coloque-o em uma consulta após a cláusula `TIMESERIES` . Por exemplo, esta consulta extrai dados em janelas de 5 minutos com um intervalo `SLIDE BY` de 1 minuto, o que significa que cada janela dura 5 minutos, mas a janela 1 começa em 0 minutos, a janela 2 começa em 1 minuto, a janela 3 começa em 2 minutos e assim por diante.

    ```sql
    SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute
    ```

    Para saber mais sobre como e quando você pode usar `SLIDE BY`, consulte [Criar gráficos mais suaves com janelas deslizantes](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows). Ou assista a este pequeno vídeo (aprox. 3:20 minutos).

    <Video id="b9WVyb1wU6w" type="youtube" />

    <CollapserGroup>
      <Collapser
        id="sliding-window-max-auto"
        title={<>Use <InlineCode>
          SLIDE BY
        </InlineCode> com intervalo <InlineCode>
          MAX
        </InlineCode> ou <InlineCode>
          AUTO
        </InlineCode></>
        }
      >
        Você pode usar janelas deslizantes em combinação com `MAX` ou `AUTO`. Contudo, `MAX` ou `AUTO` não podem ser colocados entre `TIMESERIES` e `SLIDE BY`.

        Esta consulta decidirá automaticamente um intervalo de janela `SLIDE BY` .

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO
        ```

        Esta consulta definirá a janela `SLIDE BY` para a granularidade máxima do intervalo.

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX
        ```

        <Callout variant="important">
          O valor `SLIDE BY` determinado por `AUTO` ou `MAX` pode produzir um intervalo de etapas maior que o tamanho da janela, o que pode causar lacunas e resultados inesperados.
        </Callout>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timeseries"
    title={<><InlineCode>
      TIMESERIES
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    TIMESERIES integer units
    ...
    ```

    Use a cláusula `TIMESERIES` para retornar dados como uma série temporal dividida por um período especificado. Como `TIMESERIES` é usado para acionar determinados gráficos, não há valor padrão.

    Para indicar o intervalo de tempo, use `integer units`. Por exemplo:

    * `TIMESERIES 1 minute`
    * `TIMESERIES 30 minutes`
    * `TIMESERIES 1 hour`
    * `TIMESERIES 30 seconds`

    `TIMESERIES` pode ser combinado com argumentos como `MAX`, `AUTO` e `SLIDE BY` para personalizar ainda mais os resultados da consulta, conforme mostrado nos exemplos abaixo.

    <Callout variant="important">
      Para funções como `average()` ou `percentile()`, uma grande janela de agregação pode ter um efeito de suavização significativo no outlier. Isso é verdade quer a consulta utilize ou não janelas deslizantes.
    </Callout>

    <CollapserGroup>
      <Collapser id="set-interval" title="Use um intervalo definido">
        O valor fornecido indica as unidades usadas para quebrar o gráfico. Por exemplo, para apresentar um gráfico de um dia mostrando incrementos de 30 minutos:

        ```sql
        SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes
        ```
      </Collapser>

      <Collapser id="timeseries-auto" title="Use um intervalo definido automaticamente">
        `TIMESERIES` também pode ser definido como `AUTO`, o que dividirá seu gráfico em um número razoável de divisões. Por exemplo, um gráfico diário será dividido em intervalos de 30 minutos e um gráfico semanal será dividido em intervalos de 6 horas.

        Esta consulta retorna dados como um gráfico de linhas mostrando os percentis 50 e 90 do tempo de transação do lado do cliente durante uma semana, com um ponto de dados a cada 6 horas.

        ```sql
        SELECT average(duration), percentile(duration, 50, 90)
        FROM PageView SINCE 1 week AGO TIMESERIES AUTO
        ```
      </Collapser>

      <Collapser
        id="timeseries-max"
        title={<>Usar intervalo <InlineCode>
          MAX
        </InlineCode></>
        }
      >
        Você pode definir `TIMESERIES` como `MAX`, o que ajustará automaticamente sua janela de tempo para o número máximo de intervalos permitidos para um determinado período. Isso permite que você atualize suas janelas de tempo sem precisar atualizar manualmente seus `TIMESERIES` buckets e garante que sua janela de tempo seja dividida no número máximo de intervalos permitidos. O número máximo de `TIMESERIES` buckets que serão retornados é 366.

        Por exemplo, a consulta a seguir cria intervalos de 4 minutos, que é o limite máximo para um gráfico diário.

        ```sql
        SELECT average(duration) FROM Transaction SINCE 1 day ago TIMESERIES MAX
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-until"
    title={<><InlineCode>
      UNTIL
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ...
    UNTIL integer units AGO
    ...
    ```

    Utilize a cláusula `UNTIL` para definir o término do intervalo de tempo de consulta. O valor é exclusivo, o que significa que o intervalo de tempo irá para o instante especificado, mas não o incluirá.

    O valor <DNT>**default**</DNT> é <DNT>**NOW**</DNT>. Use apenas `UNTIL` para especificar um ponto final diferente do padrão.

    Veja também:

    * [Definir o intervalo de tempo de uma consulta](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/)
    * [DESDE](#sel-since)
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-where"
    title={<><InlineCode>
      WHERE
    </InlineCode> cláusula</>
    }
  >
    Use a cláusula `WHERE` para filtrar resultados. NRQL retorna os resultados que atendem às condições especificadas na cláusula.

    ```sql
    SELECT function(attribute) ...
    WHERE attribute [operator 'value' | IN ('value' [, 'value']) | IS [NOT] NULL ]
    [AND|OR ...]
    ...
    ```

    * Se você especificar mais de uma condição, separe as condições pelos operadores `AND` ou `OR`.

    <table id="where-operators">
      <thead>
        <tr>
          <th width={150}>
            <DNT>
              **Operators that the `WHERE` clause accepts**
            </DNT>
          </th>

          <th>
            <DNT>
              **Description**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `=`, `!=`, `<`, `<=`, `>`, `>=`
          </td>

          <td>
            NRQL aceita operadores de comparação padrão. Exemplo: `state = 'WA'`

            Para atributos com valores booleanos, use `IS` e não `=`.
          </td>
        </tr>

        <tr>
          <td>
            `AND`
          </td>

          <td>
            Usado para definir uma interseção de duas condições.
          </td>
        </tr>

        <tr>
          <td>
            `OR`
          </td>

          <td>
            Usado para definir uma união de duas condições.
          </td>
        </tr>

        <tr>
          <td>
            `IS NULL`
          </td>

          <td>
            Determina se um atributo possui um valor nulo.
          </td>
        </tr>

        <tr>
          <td>
            `IS NOT NULL`
          </td>

          <td>
            Determina se um atributo não possui valor nulo.
          </td>
        </tr>

        <tr>
          <td>
            `IS TRUE`
          </td>

          <td>
            Determina se um atributo tem um valor booleano `true`.
          </td>
        </tr>

        <tr>
          <td>
            `IS FALSE`
          </td>

          <td>
            Determina se um atributo tem um valor booleano `false`.
          </td>
        </tr>

        <tr>
          <td>
            `IN`
          </td>

          <td>
            Determina se o valor da string de um atributo está em um conjunto especificado. Usar esse método gera melhor desempenho do que encadear várias cláusulas `WHERE` .

            Exemplo:

            ```sql
            animalType IN ('cat', 'dog', 'fish')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `NOT IN`
          </td>

          <td>
            Determina se o valor da string de um atributo não está em um conjunto especificado. Usar esse método gera melhor desempenho do que encadear várias cláusulas `WHERE` .

            Os valores devem estar entre parênteses, separados por vírgulas. Por exemplo:

            ```sql
            SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `LIKE`
          </td>

          <td>
            Determina se um atributo contém uma substring especificada.

            O argumento de string para o operador `LIKE` aceita o sinal de porcentagem (`%`) como um curinga em qualquer lugar da string.

            Tenha o seguinte em mente:

            * O operador `LIKE` não diferencia maiúsculas de minúsculas.

            * Se você não incluir nenhum curinga, obterá correspondências de letras maiúsculas e minúsculas para sua string. Por exemplo, esta consulta sem curingas corresponderá a `B` e `b`:

              ```sql
              FROM foo
              SELECT *
              WHERE bar LIKE 'B'
              ```

            <DNT>
              **Examples:**
            </DNT>

            `userAgentName LIKE 'IE%'`

            * Ou seja

            * IE Mobile

              `userAgentName LIKE 'o%a%'`

            * Ópera

            * Ópera Mini

              `userAgentName LIKE 'o%a'`

            * Ópera

              `userAgentName LIKE '%o%a%'`

            * Ópera

            * Ópera Mini

            * Mozilla Geco
          </td>
        </tr>

        <tr>
          <td>
            `NOT LIKE`
          </td>

          <td>
            Determina se um atributo não contém uma subsequência especificada.
          </td>
        </tr>

        <tr>
          <td>
            `RLIKE`
          </td>

          <td>
            Determina se um atributo contém uma substring Regex especificada. Usa [sintaxe RE2](https://github.com/google/re2/wiki/Syntax).

            <DNT>
              **Examples:**
            </DNT>

            `appName RLIKE r'z.*|q.*'`

            * `z-app`

            * `q-app`

              `hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*'`

            * `ip-10-351-19-237`

            * `ip-10-351-2-41`

            * `ip-10-351-24-238`

            * `ip-10-351-14-15`

              <Callout variant="important">
                O padrão do Regex é a correspondência de string completa, portanto `^` e `$` estão implícitos e você não precisa adicioná-los.
              </Callout>
          </td>
        </tr>

        <tr>
          <td>
            `NOT RLIKE`
          </td>

          <td>
            Determina se um atributo não contém uma substring Regex especificada. Usa [sintaxe RE2](https://github.com/google/re2/wiki/Syntax).
          </td>
        </tr>
      </tbody>
    </table>

    <CollapserGroup>
      <Collapser id="query-3-conditions" title="Exemplo de consulta com três condições">
        Esta consulta retorna o tempo de resposta do Browser para páginas com `checkout` na URL do usuário Safari nos Estados Unidos e Canadá nas últimas 24 horas.

        ```sql
        SELECT histogram(duration, 50, 20) FROM PageView
        WHERE countryCode IN ('CA', 'US') AND userAgentName = 'Safari' AND pageUrl LIKE '%checkout%'
        SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-metric-format"
    title={<><InlineCode>
      WITH METRIC_FORMAT
    </InlineCode> cláusula</>
    }
  >
    Para informações sobre consulta de dados métricos, consulte [consulta métrica](#query-metrics).
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-as-nrql-var"
    title={<><InlineCode>
      WITH ... AS
    </InlineCode> cláusula (variáveis NRQL)</>
    }
  >
    ```sql
    FROM ...
    WITH function(attribute) AS var
    SELECT var
    ...
    ```

    Use a cláusula `WITH ... AS` para definir variáveis NRQL para armazenar valores como variáveis que podem ser referenciadas em qualquer lugar da consulta. Algumas regras e dicas:

    * A cláusula `WITH ... AS` pode ir antes, no meio ou diretamente depois da cláusula `FROM` ou `SELECT`
    * Somente funções de linha (por exemplo, `capture()`) podem ser definidas como variáveis. funções agregadoras, como `average()`, não são suportadas.
    * Apenas um `WITH` pode ser usado, mas você pode usar diversas variáveis NRQL, desde que sejam separadas por vírgula.
    * Se uma variável NRQL definida usar o mesmo nome de um atributo existente, a variável terá precedência.
    * Os nomes de variáveis não podem incluir o símbolo `%` .

    <Callout variant="important">
      As regras [de evento para métrica](/docs/data-apis/convert-to-metrics/analyze-monitor-data-trends-metrics/) não suportam a cláusula `WITH ... AS` na [consulta NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/).
    </Callout>

    Aqui estão alguns exemplos de consulta:

    <CollapserGroup>
      <Collapser id="basic-nrql-var" title="Uso básico de uma variável">
        ```sql
        FROM Transaction
        WITH duration * 1000 AS millisec
        SELECT millisec
        ```
      </Collapser>

      <Collapser id="multiple-nrql-var" title="Usando múltiplas variáveis">
        ```sql
        FROM Log
        WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice)
        SELECT itemId, unitPrice
        ```

        Saiba mais sobre [análise de âncora](#func-aparse) (`aparse()`).
      </Collapser>

      <Collapser id="nrql-var-other-clauses" title="Use variável em outras cláusulas">
        Neste exemplo, uma variável NRQL, `unitPrice`, é usada para criar outra variável, `unitPriceNum`, convertendo a string extraída em um número. As variáveis são então usadas nas cláusulas `SELECT`, `WHERE` e `FACET` .

        ```sql
        FROM Log
        WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice),
          numeric(unitPrice) AS unitPriceNum
        SELECT sum(unitPriceNum)
        FACET itemId
        WHERE unitPriceNum < 100
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timezone"
    title={<><InlineCode>
      WITH TIMEZONE
    </InlineCode> cláusula</>
    }
  >
    ```sql
    SELECT ... WITH TIMEZONE (selected zone)
    ...
    ```

    Use a cláusula `WITH TIMEZONE` para selecionar um fuso horário para uma data ou hora na consulta que ainda não tenha um fuso horário especificado.

    Se você incluir a cláusula `WITH TIMEZONE` sem especificar um fuso horário em uma data e hora, as cláusulas `since` e `until` permanecerão no fuso horário fornecido.

    Se você não incluir a cláusula `WITH TIMEZONE` , mas incluir um fuso horário em uma sequência de data e hora, o fuso horário da sequência de data e hora será mantido.

    <Callout variant="important">
      O fuso horário padrão é sempre UTC se nenhum for especificado. Os valores brutos timestamp (conforme visto na visualização JSON) nos resultados são sempre UTC. A interface exibe os resultados no fuso horário que você especificou nas configurações da sua conta. Um fuso horário em uma sequência de carimbo de data/hora sempre funciona. Ela substitui a zona `WITH TIMEZONE` .
    </Callout>

    Por exemplo, a cláusula de consulta `SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'` retorna dados registrados da meia-noite de segunda-feira, horário dos Estados Unidos/Nova York, até meia-noite de terça-feira, horário dos Estados Unidos/Nova York.

    Aqui estão alguns exemplos de cláusulas de intervalo de tempo de consulta:

    * Nenhum fuso horário na string de data e hora usando a cláusula `WITH TIMEZONE` :

      ```sql
      SINCE today UNTIL '2022-05-19T12:00' WITH TIMEZONE 'America/Los_Angeles'
      ```

      Isso é resolvido como `"beginTime": "2022-05-19T07:00:00Z"` e `"endTime": "2022-05-19T19:00:00Z"`.

    * Fuso horário na string de data e hora, sem usar a cláusula `WITH TIMEZONE` :

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500'
      ```

      Isso é resolvido como `"beginTime": "2022-05-19T00:00:00Z"` e `"endTime": "2022-05-19T17:00:00Z"`.

    * Fuso horário na sequência de data e hora, usando a cláusula `WITH TIMEZONE` América/Los Angeles, que é -0700 durante o horário de verão:

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500' WITH TIMEZONE 'America/Los_Angeles'
      ```

      Isso é resolvido como `"beginTime": "2022-05-19T07:00:00Z"` e `"endTime": "2022-05-19T19:00:00Z"`.

    Consulte a lista [de IDs de zona](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/#timezones-ids) disponíveis.

    Consulte [Definir intervalo de tempo no painel e nos gráficos](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets) para obter informações detalhadas e exemplos.
  </Collapser>
</CollapserGroup>

## dados de consulta métrica [#query-metrics]

Os dados métricos são mais complexos do que outros tipos de dados. Existem dicas específicas para consultá-lo bem. Temos dois tipos de dados métricos, cada um com suas próprias diretrizes de consulta:

* [consulta dimensional métrica](/docs/data-ingest-apis/get-data-new-relic/metric-api/view-query-you-metric-data), que são reportados pela nossa API métrica e por algumas das nossas soluções que utilizam essa API (por exemplo, a nossa [integração Dropwizard](/docs/more-integrations/open-source-telemetry-integrations/dropwizard/dropwizard-reporter) ou [Micrometer integração](/docs/more-integrations/open-source-telemetry-integrations/micrometer/micrometer-metrics-registry)).
* [consulta métrica de fração de tempo data](/docs/query-data/nrql-new-relic-query-language/nrql-query-tutorials/query-metric-timeslice-data-nrql), que é nosso tipo de dados métrico original relatado por nosso APM, monitoramento de Mobile e <InlinePopover type="browser" />.

Para obter mais detalhes sobre como reportamos dados métricos, consulte [tipos de dados métricos](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics).

## Funções [#functions]

Nesta seção explicamos as funções NRQL , tanto [funções agregadoras](#aggregator-functions) quanto [funções não agregadoras](#non-aggregator-functions).

### Funções agregadoras [#aggregator-functions]

Você pode usar funções agregadoras para filtrar e agregar dados. Algumas dicas para usá-los:

* Se você estiver usando uma função agregadora diversas vezes na mesma consulta (por exemplo, `SELECT median(one_metric), median(another_metric)`), isso poderá causar problemas na exibição dos resultados. Para resolver isso, use a [função`AS` ](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-as). Por exemplo:
  ```sql
  SELECT median(one_metric) AS 'med-a', median(another_metric) AS 'med-b'
  ```
* O tipo de dados &quot;coerção&quot; não é compatível. Leia sobre [as funções de conversão de tipo disponíveis](#type-conversion).
* Para saber como exibir resultados ao longo do tempo, consulte [Agrupar resultados ao longo do tempo](/docs/insights/new-relic-insights/features/cohort-analysis).

Exemplos:

```sql
SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
```

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="func-aggregationendtime"
    title={<InlineCode>aggregationendtime()</InlineCode>
    }
  >
    Use a função `aggregationendtime()` para retornar o horário da agregação relevante. Mais especificamente, para um determinado agregado, a função `aggregationendtime()` fornece o timestamp do final do período dessa agregação. Por exemplo, em uma consulta de série temporal, para um ponto de dados que abrange dados de uma hora, a função retornaria o timestamp de data/hora do final desse período de hora.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-apdex"
    title={<InlineCode>apdex(attribute, t: )</InlineCode>
    }
  >
    Use a função `apdex` para retornar uma [pontuação Apdex](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#score) para uma única transação ou para todas as suas transações. A pontuação padrão <DNT>Apdex</DNT> é 0,5 segundos. O [atributo](/docs/insights/new-relic-insights/decorating-events/insights-attributes) pode ser qualquer atributo baseado no tempo de resposta, como [`duration`](/docs/insights/insights-data-sources/default-events-attributes/apm-default-event-attributes#txn-duration) ou [`backendDuration`](/docs/insights/insights-data-sources/default-events-attributes/browser-default-events-attributes-insights#backend-duration). O argumento `t:` define um limite [`Apdex T`](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) na mesma unidade de tempo que o atributo escolhido. Por exemplo, se o atributo for medido em segundos, `t` será um limite em segundos.

    A pontuação <DNT>Apdex</DNT> retornada pela função `apdex()` é baseada somente no tempo de execução. Não leva em conta erros de APM. Se uma transação incluir um erro, mas for concluída no [Apdex T](/docs/apm/new-relic-apm/getting-started/glossary#apdex_t) ou menos, essa transação será classificada [como satisfatória](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#bullet-satisfied) pela função `apdex()`.

    <CollapserGroup>
      <Collapser id="apdex-cust-attributes" title="Obtenha Apdex para clientes específicos">
        Se você [definiu atributo personalizado](/docs/insights/new-relic-insights/decorating-events/insights-custom-attributes), você pode filtrar com base nesses atributo. Por exemplo, você pode monitor o Apdex para clientes particularmente importantes:

        ```sql
        SELECT apdex(duration, t: 0.4) FROM Transaction
        WHERE customerName = 'ReallyImportantCustomer' SINCE 1 day ago
        ```
      </Collapser>

      <Collapser id="apdex-transaction" title="Obtenha Apdex para transações específicas">
        Use o atributo `name` para retornar uma pontuação para uma transação específica ou retorne um Apdex geral omitindo `name`. Esta consulta retorna uma pontuação Apdex para a transação <DNT>**Controller/notes/index**</DNT> na última hora:

        <img title="crop-apdex-function" alt="crop-apdex-function" src="/images/queries-nrql_screenshot-full_apdex-NRQL-query-builder.webp" />

        <figcaption>
          A função `apdex` retorna uma [pontuação Apdex](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) que mede a satisfação do usuário com seu site. Os argumentos são um atributo de tempo de resposta e um limite Apdex T em segundos.
        </figcaption>

        ```sql
        SELECT apdex(duration, t: 0.5) from Transaction
        WHERE name = 'Controller/notes/index' SINCE 1 hour ago
        ```
      </Collapser>

      <Collapser title="Obtenha Apdex geral para seu aplicativo">
        Este exemplo de consulta retorna um Apdex geral do aplicativo nas últimas três semanas:

        ```sql
        SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-average"
    title={<InlineCode>average(attribute)</InlineCode>
    }
  >
    Use a função `average()` para retornar o valor médio médio de um atributo. Leva um único nome de atributo como argumento. Se um valor do atributo não for numérico, ele será ignorado na agregação. Se os dados que correspondem às condições da consulta não forem encontrados ou se não houver valores numéricos retornados pela consulta, ela retornará um valor nulo.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-bucket-percentile"
    title={<InlineCode>bucketPercentile(attribute)</InlineCode>
    }
  >
    A função `bucketPercentile()` é o equivalente NRQL da função [`histogram_quantile`](https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile) no Prometheus. Destina-se a ser utilizado com dados métricos dimensionais. Em vez do quantil, o New Relic retorna o percentil, que é o quantil \* 100.

    Use a função `bucketPercentile()` para calcular o quantil a partir dos dados do histograma em formato Prometheus.

    Ele usa o nome do intervalo como argumento e relata o percentual ao longo dos limites do intervalo:

    ```sql
    SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago
    ```

    Opcionalmente, você pode adicionar especificações percentuais como argumento:

    ```sql
    SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago
    ```

    Como múltiplas métricas são usadas para compor os dados do histograma do Prometheus, você deve consultar a métrica específica do Prometheus em termos do `<basename>` associado.

    Por exemplo, para calcular o percentil de um histograma do Prometheus, com `<basename>` `prometheus_http_request_duration_seconds` usando NRQL, use `bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)`. Observe como `_bucket` é adicionado ao final de `<basename>` como sufixo.

    Consulte [a documentação do Prometheus.io](https://prometheus.io/docs/concepts/metric_types/#histogram) para obter mais informações.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cardinality"
    title={<InlineCode>cardinalidade([métrica, include:[`[atributo]`], exclude:[`[atributo]`]])</InlineCode>
    }
  >
    Utilize a função `cardinality()` para obter o número de combinações de todas as dimensões (atributo) em uma [métrica](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics).

    São necessários três argumentos, todos opcionais:

    * Nome da métrica: se presente, `cardinality()` calcula apenas a métrica especificada.
    * Incluir: se presente, a lista de inclusão restringe o cálculo da cardinalidade a esses atributos.
    * Excluir: se presente, a lista de exclusão faz com que esses atributos sejam ignorados no cálculo da cardinalidade.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cdfPercentage"
    title={<InlineCode>cdfPercentage(attribute, threshold [, threshold [, ...]])</InlineCode>
    }
  >
    `cdfPercentage()` é uma implementação da [função de distribuição cumulativa](https://en.wikipedia.org/wiki/Cumulative_distribution_function), retornando porcentagens de `attribute` valores cujo valor é menor ou igual a um ou mais `thresholds`.

    `cdfPercentage()` agrega em seu argumento `attribute` , que pode ser um atributo numérico ou um atributo de métrica de distribuição. Tipos mistos em uma consulta são aceitos. Outros tipos (como string) são ignorados. Até 10 limites podem ser especificados.

    <CollapserGroup>
      <Collapser title="Obtenha a porcentagem das primeiras pinturas mais rapidamente do que determinado limite">
        Esta consulta retorna a porcentagem do evento onde `firstPaint` é menor ou igual a 0,5 segundos, e a porcentagem do evento onde `firstPaint` é menor ou igual a 1 segundo.

        ```sql
        FROM PageView SELECT cdfPercentage(firstPaint, 0.5, 1.0)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-count"
    title={<InlineCode>count(*)</InlineCode>
    }
  >
    Use a função `count()` para retornar uma contagem de registros disponíveis. É necessário um único argumento; seja `*`, um atributo ou um valor constante. Atualmente, ele segue o comportamento típico do SQL e conta todos os registros que possuem valores para seu argumento.

    Como `count(*)` não nomeia um atributo específico, os resultados serão formatados no formato padrão [&quot;humanizar&quot;](/docs/insights/new-relic-insights/managing-dashboards-data/data-formatter-setting-default-formats-numeric-values#format) .
  </Collapser>

  <Collapser
    className="freq-link"
    id="derivative"
    title={<InlineCode>derivative(attribute [,time interval])</InlineCode>
    }
  >
    `derivative()` encontra a taxa de mudança para um determinado conjunto de dados. A taxa de variação é calculada usando uma regressão linear de mínimos quadrados para aproximar a derivada. Como esse cálculo exige a comparação de mais de um ponto de dados, se apenas um ponto de dados for incluído no intervalo de avaliação, o cálculo será indeterminado e não funcionará, resultando em um valor `null` .

    O `time interval` é o período para o qual a taxa de alteração é calculada. Por exemplo, `derivative(attributeName, 1 minute)` retornará a taxa de alteração por minuto.
  </Collapser>

  <Collapser
    className="freq-link"
    id="earliest-func"
    title={<InlineCode>earliest(attribute)</InlineCode>
    }
  >
    Use a função `earliest()` para retornar o valor mais antigo de um atributo no intervalo de tempo especificado.

    É preciso um único argumento.

    Se usado em conjunto com `FACET` , ele retornará o valor mais antigo de um atributo para cada uma das facetas resultantes.

    <Callout variant="tip">
      Se vários eventos ou métricas compartilharem o mesmo timestamp mais antigo, o resultado retornado será aleatório e poderá variar entre diferentes execuções de consulta. Para obter resultados mais consistentes, facete por atributo com valores diferentes para este evento ou métrica.
    </Callout>

    <CollapserGroup>
      <Collapser title="Obtenha o país mais antigo por agente de usuário no PageView">
        Esta consulta retorna o código de país mais antigo de cada agente de usuário do evento `PageView` .

        ```sql
        SELECT earliest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-filter"
    title={<InlineCode>filter(function(attribute), WHERE condition)</InlineCode>
    }
  >
    Use a função `filter()` para limitar os resultados de uma das funções agregadoras em sua instrução `SELECT`. Você pode usar `filter()` em conjunto com `FACET` ou `TIMESERIES`. O filtro só é útil ao selecionar várias agregações diferentes, como:

    ```sql
    SELECT filter(sum(x), WHERE attribute = 'a') AS 'A',
      filter(sum(x), WHERE attribute = 'b') AS 'B' ...
    ```

    Caso contrário, é melhor usar apenas a cláusula `WHERE` padrão.

    <CollapserGroup>
      <Collapser title="Analise compras que usaram códigos de oferta">
        Você pode usar `filter()` para comparar os itens comprados em um conjunto de transações para aqueles que usam um código de oferta e aqueles que não o usam:

        <img title="screenshot insights filter" alt="screenshot insights filter" src="/images/queries-nrql_screenshot-full_filter-NRQL-query-builder.webp" />

        <figcaption>
          Use a função `filter()` para limitar os resultados de uma das funções agregadoras em sua instrução `SELECT` .
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-funnel"
    title={<InlineCode>funnel(attribute, steps)</InlineCode>
    }
  >
    Use a função `funnel()` para gerar um gráfico Funis. Leva um atributo como seu primeiro argumento. Em seguida, você especifica as etapas como cláusulas [`WHERE`](#sel-where) (com cláusulas [`AS`](#sel-as) opcionais para rótulos) separadas por vírgulas.

    Para obter detalhes e exemplos, consulte a [documentação dos funis](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/funnels-evaluate-data-series-events).
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-histogram"
    title={<InlineCode>histogram(attribute[, width: n][, buckets: n][, start: n])</InlineCode>
    }
  >
    Use a função `histogram()` para gerar histograma, que é útil para visualizar a distribuição de um conjunto de dados. Ele divide o conjunto de dados em um número especificado de intervalos e conta o número de pontos de dados que se enquadram em cada intervalo.

    Argumentos:

    * `attribute` O primeiro argumento é obrigatório e especifica o atributo para o qual serão contados os valores que se enquadram em cada intervalo do histograma.

    * `width:` Indica a largura do intervalo da amostra. O valor máximo do intervalo é o valor do argumento `start` mais este valor `width` .

      * Ao usar argumentos posicionais (não rotulados), `width` é o segundo argumento.
      * *Padrão:* `10`

    * `buckets:` Número total de buckets (entre `1` e `500`, inclusive).

      * Ao usar argumentos posicionais (não rotulados), `buckets` é o terceiro argumento.
      * *Padrão:* `40`

    * `start:` O início do intervalo do histograma.

      * Ao usar argumentos posicionais (não rotulados), `start` é o quarto argumento.
      * *Padrão:* `0`

    <Callout variant="tip" title="Observação">
      Os valores que estão fora do intervalo definido do histograma são incluídos no primeiro ou no último intervalo. A primeira contagem do intervalo incluirá itens menores que o intervalo do histograma e a última contagem do intervalo incluirá itens maiores que o intervalo do histograma. Para excluir esses valores dos resultados do histograma, inclua um filtro na cláusula where da consulta. (Exemplo: `WHERE attribute >= [start] AND attribute <= [start + width]`)
    </Callout>

    <CollapserGroup>
      <Collapser id="histogram-response-times-defaults" title="Histograma do tempo de resposta do evento PageView">
        Esta consulta resulta em um histograma de tempo de resposta que varia de até 10 segundos em 40 buckets. Isso significa que cada intervalo cobre um intervalo de valores de 0,25 segundos. (10/40 = 0,25). Quaisquer valores de duração maiores que 10 segundos serão incluídos no último intervalo. Se a duração pudesse ser menor que zero, esses valores seriam incluídos no primeiro intervalo.

        ```sql
        SELECT histogram(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-response-times" title="Histograma com largura: 5, baldes: 10">
        Essas consultas equivalentes resultam em um histograma de tempo de resposta que varia de até 5 segundos em 10 baldes.

        ```sql
        SELECT histogram(duration, 5, 10) FROM PageView SINCE 1 week ago
        ```

        ```sql
        SELECT histogram(duration, width: 5, buckets: 10) FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-response-times-1to4" title="Histograma com largura: 3, baldes: 3, início: 1">
        Essas consultas equivalentes resultam em um histograma de tempo de resposta variando de 1 a 4 segundos em 3 baldes.

        Aqui está uma análise dos baldes:

        <table>
          <thead>
            <tr>
              <th />

              <th>
                Balde 1
              </th>

              <th>
                Balde 2
              </th>

              <th>
                Balde 3
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                Gama de baldes
              </td>

              <td>
                1 a 2
              </td>

              <td>
                2 a 3
              </td>

              <td>
                3 a 4
              </td>
            </tr>

            <tr>
              <td>
                Valores contados
              </td>

              <td>
                &lt;2
              </td>

              <td>
                ≥ 2 e &lt; 3
              </td>

              <td>
                ≥ 3
              </td>
            </tr>
          </tbody>
        </table>

        ```sql
        SELECT histogram(duration, 3, 3, 1) 
        FROM PageView SINCE 1 week ago
        ```

        ```sql
        SELECT histogram(duration, width: 3, buckets: 3, start: 1) 
        FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-prometheus" title="Intervalos de histograma do Prometheus">
        `histogram()` aceita intervalos de histograma do Prometheus:

        ```sql
        SELECT histogram(duration_bucket, 10, 20) 
        FROM Metric SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="distribution-metric" title="Métrica de distribuição New Relic">
        `histogram()` aceita [a métrica de distribuição](/docs/data-ingest-apis/get-data-new-relic/metric-api/events-metrics-service-create-metrics#limits-rules) como entrada:

        ```sql
        SELECT histogram(myDistributionMetric, 10, 20) 
        FROM Metric SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-facet-heatmap" title="Histograma com cláusula FACET">
        Use `histogram()` com uma cláusula `FACET` para gerar um gráfico de mapa de calor:

        ```sql
        SELECT histogram(duration) 
        FROM PageView FACET appName SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="keyset"
    title={<InlineCode>keyset()</InlineCode>
    }
  >
    Usar `keyset()` permitirá que você veja todos os atributos de um determinado tipo de dados em um determinado intervalo de tempo. Não são necessários argumentos. Ele retorna uma estrutura JSON contendo grupos de chaves digitadas em string, chaves digitadas numéricas, chaves digitadas booleanas e todas as chaves.

    <CollapserGroup>
      <Collapser title="Veja todos os atributos para um tipo de dados">
        Esta consulta retorna o atributo encontrado para `PageView` evento do último dia:

        ```sql
        SELECT keyset() FROM PageView SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latest"
    title={<InlineCode>latest(attribute)</InlineCode>
    }
  >
    Use a função `latest()` para retornar o valor mais recente de um atributo em um intervalo de tempo especificado.

    É preciso um único argumento.

    Se usado em conjunto com `FACET` , ele retornará o valor mais recente de um atributo para cada um dos aspectos resultantes.

    <Callout variant="tip">
      Se vários eventos ou métricas tiverem o mesmo timestamp mais recente, o resultado retornado será aleatório e poderá variar entre as execuções de consulta. Para obter resultados mais consistentes, faça uma faceta por atributo com valores diferentes para este evento ou métrica.
    </Callout>

    <CollapserGroup>
      <Collapser title="Obtenha o país mais recente por agente de usuário no PageView">
        Esta consulta retorna o código de país mais recente para cada agente de usuário do evento `PageView` .

        ```sql
        SELECT latest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latestrate"
    title={<InlineCode>latestrate(attribute, time interval)</InlineCode>
    }
  >
    Use a função `latestrate()` para retornar a taxa de alteração de um valor com base nos dois últimos pontos de dados. Toma o atributo em questão como primeiro argumento e a unidade de tempo da taxa resultante como segundo argumento. A função retorna um resultado em unidades de `change in attribute/time interval`.

    Esta função pode ser útil para fornecer a taxa de alteração mais recente de um atributo, a fim de ver as tendências mais recentes.

    <CollapserGroup>
      <Collapser title="Obtenha a taxa de variação mais recente da duração do PageView">
        Esta consulta retorna a taxa de alteração da duração com base nos dois últimos pontos de dados. Ele será retornado em unidades de `duration/second` devido ao argumento `1 SECOND` .

        ```sql
        SELECT latestrate(duration, 1 SECOND) FROM PageView
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-max"
    title={<InlineCode>max(attribute)</InlineCode>
    }
  >
    Use a função `max()` para retornar o valor máximo registrado de um atributo numérico no intervalo de tempo especificado. Leva um único nome de atributo como argumento. Se um valor do atributo não for numérico, ele será ignorado na agregação. Se os dados que correspondem às condições da consulta não forem encontrados ou se não houver valores numéricos retornados pela consulta, ela retornará um valor nulo.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-median"
    title={<InlineCode>median(attribute)</InlineCode>
    }
  >
    Use a função `median()` para retornar a mediana ou percentil 50 de um atributo. Para obter mais informações sobre consulta de percentil, consulte [`percentile()`](#func-percentile).

    <CollapserGroup>
      <Collapser title="Consulta mediana">
        Esta consulta irá gerar um gráfico de linhas para o valor mediano.

        ```sql
        SELECT median(duration) FROM PageView TIMESERIES AUTO
        ```
      </Collapser>
    </CollapserGroup>

    Mediana em uma cláusula [`JOIN`](#sel-join) :

    * Como a mediana é simplesmente um atalho para `percentile(attribute, 50)`, um resultado `median()` de uma subconsulta unida é um tipo de dados composto, que mapeia o 50º percentil para seu valor calculado.

      Para fazer referência ao valor mediano real na consulta externa, você pode usar a função [`getField()`](#func-getfield) . Observe que a chave mapeada é uma representação de string de um valor duplo, portanto, para `median()` é `'50.0'`.

      <CollapserGroup>
        <Collapser title="Aderiu à consulta mediana">
          ```sql
          FROM PageView
          JOIN (FROM PageAction SELECT median(timeSinceLoad) FACET session, currentUrl) ON session
          SELECT latest(getField(median, '50.0')) AS median
          FACET browserTransactionName, currentUrl
          ```

          <img title="screenshot joined median" alt="screenshot joined median" src="/images/nrql_screenshot-crop_example-joined-median.webp" />
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-min"
    title={<InlineCode>min(attribute)</InlineCode>
    }
  >
    Use a função `min()` para retornar o valor mínimo registrado de um atributo numérico no intervalo de tempo especificado. Leva um único nome de atributo como argumento. Se um valor do atributo não for numérico, ele será ignorado na agregação. Se os dados que correspondem às condições da consulta não forem encontrados ou se não houver valores numéricos retornados pela consulta, ela retornará um valor nulo.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentage"
    title={<InlineCode>percentage(function(attribute), WHERE condition)</InlineCode>
    }
  >
    Use a função `percentage()` para retornar a porcentagem de um conjunto de dados de destino que corresponde a alguma condição.

    Esta função espera exatamente dois argumentos (argumentos após os dois primeiros são ignorados). O primeiro argumento requer uma [função agregadora](#functions) em relação ao atributo desejado. Se o atributo não for numérico, esta função retornará um valor de 100%. O segundo argumento requer uma cláusula `WHERE` .

    ```sql
    FROM Transaction 
    SELECT percentage(count(*), WHERE error is true ) AS 'Error Percent' 
    WHERE host LIKE '%west%' EXTRAPOLATE
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentile"
    title={<InlineCode>percentile(attribute [, percentile [, ...]])</InlineCode>
    }
  >
    Use a função `percentile()` para retornar o valor aproximado de um atributo em um determinado percentil. Requer um atributo e pode receber qualquer número de argumentos que representem pontos percentuais. A função `percentile()` possibilita a exibição do percentual com até três dígitos após a vírgula decimal, proporcionando maior precisão. O limite percentual pode ser especificado como valores decimais, mas esteja ciente de que, para a maioria dos conjuntos de dados, percentis mais próximos que 0,1 um do outro não serão resolvidos.

    <img title="percentile.png" alt="percentile.png" src="/images/queries-nrql_screenshot-full_percentile-NRQL-query-builder.webp" />

    <figcaption>
      Exemplos de exibição de percentil
    </figcaption>

    Use `TIMESERIES` para gerar um gráfico de linhas com percentil mapeado ao longo do tempo.

    * Omita `TIMESERIES` para gerar um outdoor e uma folha de atributos mostrando valores agregados para o percentil.

      Se nenhum percentil estiver listado, o padrão será o 95º percentil. Para retornar apenas o valor do 50º percentil, a mediana, você também pode usar [`median()`](#func-median).

      <CollapserGroup>
        <Collapser title="Consulta de percentil básico">
          Esta consulta irá gerar um gráfico de linhas com linhas para o 5º, 50º e 95º percentil.

          ```sql
          SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO
          ```
        </Collapser>
      </CollapserGroup>

    percentil em uma cláusula [`JOIN`](#sel-join) :

    * Ao usar o percentil em uma subconsulta unida, observe que os resultados da subconsulta são um tipo de dados composto, que mapeia cada percentil para seu valor calculado.

      Para fazer referência a qualquer um dos valores percentuais individuais na consulta externa, você pode usar a função [`getField()`](#func-getfield). Observe que a chave mapeada é uma representação de string de um valor duplo, então você precisa adicionar `.0` aos números inteiros. Por exemplo, a chave para o percentil 95 é `'95.0'`.

      <CollapserGroup>
        <Collapser title="Inscreveu-se na consulta de percentil">
          ```sql
          FROM PageView
          JOIN 
          (
            FROM PageAction 
            SELECT percentile(timeSinceLoad, 95, 99.5) AS pctl
            FACET session, currentUrl
          ) 
          ON session
          SELECT latest(getField(pctl, '95.0')) AS `95th`, 
            latest(getField(pctl, '99.5')) AS `99.5th`
          FACET browserTransactionName, currentUrl
          ```

          <img title="screenshot joined percentile" alt="screenshot joined percentile" src="/images/nrql_screenshot-crop_example-joined-percentile.webp" />
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="predictLinear"
    title={<InlineCode>predictLinear(attribute, [,time interval])</InlineCode>
    }
  >
    `predictLinear()` é uma extensão da função `derivative()` . Ele usa um método semelhante de regressão linear de mínimos quadrados para prever os valores futuros de um conjunto de dados.

    * O `time interval` é o quão longe a consulta irá olhar no futuro. Por exemplo, `predictLinear(attributeName, 1 hour)` é uma previsão linear 1 hora no futuro da janela de tempo da consulta.
    * Geralmente, `predictLinear()` é útil para valores de crescimento contínuo, como espaço em disco ou previsões sobre grandes tendências.
    * Como `predictLinear()` é uma regressão linear, a familiaridade com o conjunto de dados consultado ajuda a garantir previsões precisas de longo prazo.
    * Qualquer conjunto de dados que cresça exponencialmente, logaritmicamente ou por outros meios não lineares provavelmente só terá sucesso em previsões de muito curto prazo.
    * New Relic não recomenda o uso de `predictLinear` em `TIMESERIES` consulta. Isso ocorre porque cada bucket fará uma previsão individual com base em seu período relativo dentro da consulta, o que significa que tal consulta não mostrará previsões do final da série temporal em diante.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-rate"
    title={<InlineCode>rate(function(attribute) [,time interval])</InlineCode>
    }
  >
    Use a função `rate()` para visualizar a frequência ou taxa de uma determinada consulta por intervalo de tempo. Por exemplo, você pode querer saber o número de visualizações de página por minuto durante um período de uma hora ou a contagem de sessões únicas em seu site por hora durante um período de um dia.

    * Use [`TIMESERIES`](#sel-timeseries) para gerar um gráfico de linhas com taxas mapeadas ao longo do tempo.

    * Omita [`TIMESERIES`](#sel-timeseries) para gerar um outdoor mostrando uma média de valor de taxa única ao longo do tempo.

      Aqui está uma consulta básica que irá gerar um gráfico de linhas mostrando a taxa de taxas de transferência para transação APM por 10 minutos nas últimas 6 horas:

      ```sql
      SELECT rate(count(*), 10 minute) FROM Transaction 
      SINCE 6 hours ago TIMESERIES
      ```

      Aqui está um pequeno vídeo (3:21 minutos) que explica como usar `rate` para comparar dados em diferentes janelas de tempo:

      <Video id="9UArmB4QiVM" type="youtube" />
  </Collapser>

  <Collapser
    className="freq-link"
    id="stdvar"
    title={<InlineCode>stdvar(attribute)</InlineCode>
    }
  >
    Use a função `stdvar()` para retornar a [variação padrão](https://en.wikipedia.org/wiki/Variance) de um atributo numérico no intervalo de tempo especificado.

    É preciso um único argumento. Se o atributo não for numérico, ele retornará um valor zero.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-sum"
    title={<InlineCode>sum(attribute)</InlineCode>
    }
  >
    Use a função `sum()` para retornar a soma dos valores registrados de um atributo numérico no intervalo de tempo especificado.

    É preciso um único argumento. Se o atributo não for numérico, ele retornará um valor zero.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniqueCount"
    title={<InlineCode>uniqueCount(attribute, [, attribute [, ...]] [, precision: number])</InlineCode>
    }
  >
    Use a função `uniqueCount()` para obter o número de valores exclusivos registrados para um atributo em um intervalo de tempo especificado. Para contar as combinações exclusivas de vários valores de atributos, especifique esses atributos com a função. Você pode incluir até 32 atributos. Esta função fornece um resultado exato para até 256 valor exclusivo quando você a chama sem o argumento `precision`. Para mais de 256 valor exclusivo, o resultado é aproximado. Você pode especificar um valor `precision` dentro do intervalo de 256 a 50.000 para aumentar o limite para resultados exatos. Quando o valor exclusivo excede o limite definido, a função usa a [estrutura de dados probabilística HyperLogLog](https://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf) para fornecer um resultado aproximado.

    Use a função `uniqueCount()` especificando o atributo e, opcionalmente, defina o argumento de precisão da seguinte maneira:

    ```sql
    uniqueCount(attribute, [, attribute [, ...]] [, precision: number])
    ```

    * **Atributo(s)**: especifique um atributo para o qual você deseja contar valor exclusivo ou especifique vários atributos para contar combinações exclusivas de valores. Você pode especificar até 32 atributos.
    * **Precisão**: especifique um número que define o limite para resultados exatos. Você pode definir um valor de até 50.000.

    Exemplo de consulta sem um argumento `precision` :

    ```sql
    SELECT uniqueCount(accountId) FROM Transaction SINCE 1 day ago
    ```

    Exemplo de consulta com um argumento `precision` :

    ```sql
    SELECT uniqueCount(appName, name, clusterName, precision: 1000) FROM Transaction SINCE 1 day ago
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniques"
    title={<><InlineCode>
      uniques(attribute [,limit]
    </InlineCode><InlineCode>
      )
    </InlineCode></>
    }
  >
    Utilize a função `uniques()` para retornar uma lista de valores exclusivos registrados para um atributo no intervalo de tempo especificado. Quando usado junto com a cláusula `facet` , uma lista de valores de atributo exclusivos será retornada para cada valor de faceta.

    O parâmetro `limit` é opcional. Quando não fornecido, aplica-se o limite padrão de 1.000 valores de atributo únicos por faceta. Você pode especificar um valor `limit` diferente, até um máximo de 10.000. A função `uniques()` retornará o primeiro conjunto de valores de atributo únicos descobertos, até que o limite seja atingido. Portanto, se você tiver 5.000 valores de atributo únicos em seu conjunto de dados, e o limite for definido como 1.000, a operadora retornará os primeiros 1.000 valores exclusivos que descobrir, independente de sua frequência.

    O número máximo de valores que podem ser retornados em um resultado de consulta é o produto do limite `uniques()` vezes o limite `facet` . Na consulta a seguir, o número máximo teórico de valores que podem ser retornados é 5 milhões (5.000 x 1.000).

    Dependendo do conjunto de dados que está sendo consultado e da complexidade da consulta, limites de proteção de memória podem impedir a execução de uma consulta muito grande.

    ```sql
    From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000
    ```

    <CollapserGroup>
      <Collapser
        title={<>Usando <InlineCode>
          tuple
        </InlineCode></>
        }
      >
        Se quiser saber as combinações únicas de alguns atributos, você pode estruturar uma consulta no formato `SELECT uniques(tuple(x, y, ... z)) ...` para obter todas as tuplas únicas de valores, para manter seu relacionamento. Na consulta a seguir, `tuple` é usado em `index` e `cellName` juntos para localizar valores únicos onde esses dois valores ocorrem em combinação.

        ```sql
        FROM NodeStatus SELECT uniques(tuple(index, cellName), 5)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### Funções não agregadoras [#non-aggregator-functions]

Use funções não agregadoras para retornar valores para cada ponto de dados dentro da consulta NRQL .

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="acct-type"
    title={<InlineCode>accountId()</InlineCode>
    }
  >
    Use a função `accountId()` para retornar o [ID da conta](/docs/accounts/accounts-billing/account-structure/account-id) associado aos dados da consulta. Esta função não aceita argumentos. Aqui estão alguns exemplos de consulta:

    <CollapserGroup>
      <Collapser title="Obtenha o ID da conta para cada evento de transação">
        Esta consulta retorna o ID da conta associado a cada evento `Transaction` retornado:

        ```sql
        SELECT accountId() FROM Transaction SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="Obtenha a contagem do evento de transação para cada conta">
        Esta consulta retorna o número de eventos `Transaction` no último dia que estão associados a cada ID de conta:

        ```sql
        SELECT count(*) FROM Transaction FACET accountId() SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="Obtenha a contagem do evento de transação para cada conta especificada na cláusula WHERE">
        Esta consulta retorna o número de eventos `Transaction` no último dia em que o ID da conta é especificamente `1`, `2` ou `3`:

        ```sql
        SELECT count(*) FROM Transaction WHERE accountId() IN (1,2,3) SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-aparse"
    title={<><InlineCode>
      aparse(attribute, pattern)
    </InlineCode></>
    }
  >
    Use a função de análise de âncora `aparse()` para extrair valores específicos de uma string. Esta é uma alternativa para `capture()`.

    `aparse()` leva dois argumentos:

    * Um atributo de string
    * Uma sequência de padrões com sequências de âncora e caracteres de extração. Por exemplo, você poderia usar `www.*.com` para extrair o domínio de um URL.

    Ao usar `aparse()`, a string padrão deve conter âncoras, como `www.` e `.com` acima, para identificar a localização da string extraída pretendida, anotada por `*`.

    `aparse()` usa os seguintes caracteres em strings de padrão:

    * `%`: curinga sem captura, como você veria na cláusula `LIKE`
    * `*`: captura de curinga, semelhante ao uso de captura regex

    Na prática, as strings âncora geralmente ocorrem no meio de um atributo de string, e não no início ou no final.

    Nesse caso, use o curinga `%` para ignorar valores indesejados: por exemplo, `%www.*.com%`.

    Assim como `capture()`, todos os resultados de `aparse()` são strings. Para usar esses resultados em funções matemáticas eles devem ser convertidos com a função `numeric()` .

    Observação: `aparse()` não diferencia maiúsculas de minúsculas.

    <CollapserGroup>
      <Collapser title="Uso básico" id="aparse-basic" className="freq-link">
        ```sql
        FROM PageView
        SELECT aparse(browserTransactionName, 'website.com/*')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>
          aparse()
        </InlineCode> valores específicos</>
        }
        id="aparse-specific-values"
        className="freq-link"
      >
        Para extrair um valor do meio de uma string, use o curinga sem captura, `%`, no início e no final da string padrão. Por exemplo:

        ```sql
        FROM Log
        SELECT count(*)
        FACET aparse(string, '%"itemId":"*"%')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>
          aparse()
        </InlineCode> vários valores</>
        }
        id="aparse-multiple-values"
        className="freq-link"
      >
        Ao extrair vários valores como variáveis, observe que a ordem é importante. Por exemplo:

        ```sql
        FROM Log
        WITH aparse(string, 'POST: * body: {"itemId":"*","unitPrice":*}\n') AS (url, itemId, unitPrice)
        SELECT url, itemId, unitPrice
        ```

        Para obter mais informações sobre variáveis, consulte [Variáveis NRQL](#with-as-nrql-var).
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-blob"
    title={<InlineCode>blob(attribute)</InlineCode>
    }
  >
    Use a função `blob()` em um atributo de tipo de blob para retornar uma string codificada em base 64 desse atributo.

    Esta função tem as seguintes restrições:

    * Consulta contendo chamadas para `blob()` tem um valor máximo de `LIMIT` de 20

    * `blob()` não pode ser chamado na cláusula `WHERE` de uma consulta

    * `blob()` não pode ser usado em consulta facetada ou consulta de série temporal

      Para obter mais informações sobre como isso é usado no Logging, consulte [Localizar dados em logs longos (blobs)](/docs/logs/log-management/ui-data/long-logs-blobs).

      Para decodificar um blob codificado em base 64, consulte a [função`decode()` ](#func-decode).

      <CollapserGroup>
        <Collapser
          title={<>Usando <InlineCode>
            blob()
          </InlineCode> no registro estendido</>
          }
        >
          ```sql
          SELECT message, blob(`newrelic.ext.message`) 
          FROM Log WHERE newrelic.ext.message IS NOT NULL
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-buckets"
    title={<InlineCode>buckets(attribute, ceiling [,number of buckets])</InlineCode>
    }
  >
    Use a função `buckets()` para agregar dados divididos por uma cláusula `FACET` em intervalos com base em intervalos. Você pode agrupar qualquer atributo armazenado como um valor numérico no banco de dados New Relic.

    São necessários três argumentos:

    * Nome do atributo

    * Valor máximo do intervalo de amostra (qualquer valor discrepante aparecerá no intervalo final)

    * Número total de intervalos

      Para obter mais informações e exemplos, consulte [Dividir seus dados em buckets](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/segment-your-insights-data-buckets).
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-concat"
    title={<InlineCode>concat(atributo, [, atributo [, ...]] [, precisão: ]))</InlineCode>
    }
  >
    Use a função `concat()` para retornar a string resultante da concatenação de seus argumentos.

    Podem ser fornecidos até 20 argumentos dos tipos numérico, booleano, tupla ou matriz. Argumentos nulos e argumentos de tipos não suportados são ignorados. Se nenhum argumento for fornecido, o resultado será uma string vazia.

    O argumento opcional de precisão pode ser fornecido para limitar o número de casas decimais incluídas ao concatenar valores numéricos de ponto flutuante.

    A string resultante pode ter um comprimento máximo de 4.096 caracteres.

    <CollapserGroup>
      <Collapser title="Obtenha vários valores de duração de `PageView` como uma string formatada">
        Esta consulta retorna as durações backend e de rede do evento `PageView`, formatadas com duas casas decimais e rótulos, como uma única string.

        ```sql
        FROM PageView 
        SELECT concat('Backend Duration: ', backendDuration, ', Network Duration: ', networkDuration, precision: 2)
        ```

        Isso retornaria respostas em um formato como:

        `Backend Duration: 0.69, Network Duration: 0`
      </Collapser>

      <Collapser title="Resultados da consulta de faceta por uma string formatada">
        Esta consulta retorna a duração média da configuração da conexão do evento `PageView` , facetada por uma string composta pela cidade, região e país do usuário.

        ```sql
        FROM PageView SELECT average(connectionSetupDuration) 
        FACET concat(city, ', ', regionCode, ' ', countryCode) 
        WHERE countryCode IN ('US', 'CA')
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-convert"
    title={<InlineCode>convert(attribute, fromUnits, toUnits)</InlineCode>
    }
  >
    Use a função `convert()` para realizar a conversão de unidades entre as unidades fornecidas no valor de entrada fornecido.

    Unidades e abreviações comuns para tempo, comprimento, peso, volume e dados são suportadas usando os [padrões UCUM](https://ucum.org/ucum) para alinhar com as especificações OpenTelemetry. Por conveniência, as abreviações padronizadas são aumentadas por algumas alternativas de linguagem natural como `ft` além de `ft_us`, `kilobytes` e `µs`.

    As unidades *diferenciam* maiúsculas de minúsculas. Todas as unidades estão em minúsculas, a menos que sua especificação exija que estejam em maiúsculas. Por exemplo, as unidades de dados `'bits'` são válidas para bits e `'By'` devem ter `B` maiúsculo para bytes.

    A maior unidade de tempo é o `year` juliano, que é sempre 365,25 dias.

    <CollapserGroup>
      <Collapser title="Converta um atributo de milissegundos para minutos">
        ```sql
        FROM Transaction SELECT convert(duration, 'ms', 'min') AS durationMin
        ```
      </Collapser>

      <Collapser title="Converta a soma dos pesos de gramas para libras">
        ```sql
        FROM Product SELECT convert(sum(itemWeight), 'grams', 'lbs')
        ```
      </Collapser>

      <Collapser title="Converter entre a unidade de tempo armazenada e segundos">
        Esta consulta pressupõe que você tenha as informações da unidade armazenadas como um atributo de string no próprio evento e que gostaria de padronizar os valores para segundos.

        ```sql
        FROM Metric 
        SELECT average(convert(apm.mobile.external.duration, unit, 's')) 
        WHERE appName = 'my-application'
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-capture"
    title={<InlineCode>capture(attribute, regular expression)</InlineCode>
    }
  >
    Use `capture()` para extrair valores de um atributo usando uma expressão regular com [sintaxe RE2](https://github.com/google/re2/wiki/Syntax).

    São necessários dois argumentos:

    * Nome do atributo

    * Expressão regular com sintaxe de captura (expressões regex em NRQL usam sintaxe semelhante a Python, `r'...'`)

      Ao capturar, use a sintaxe de captura nomeada RE2 `...(?P<name> pattern )...` para capturar o padrão contido, dado o nome especificado.

      Vários valores podem ser capturados especificando grupos de captura adicionais em uma expressão regular. Por exemplo: `...(?P<name1> pattern1)...(?P<name2> pattern2)...`

      Nota: Ao capturar vários valores, cada instrução de captura pode ter até 16 grupos de captura e cada consulta NRQL pode ter até 5 instruções de captura.

      Leia como [usar a captura de regex para melhorar os resultados da sua consulta](https://newrelic.com/blog/how-to-relic/using-regex-capture).

      <Callout variant="tip">
        A expressão regular deve corresponder a toda a sua entrada. Se uma expressão de captura não estiver extraindo os resultados esperados, verifique se ela precisa `.*` no início ou no final, que é o padrão para uma regex de correspondência parcial. No entanto, a regex de correspondência parcial pode causar uma execução de consulta lenta.
      </Callout>

      Aqui está um pequeno vídeo (3:05 minutos) que mostra como usar `capture()` para melhorar a legibilidade dashboard :

      <Video id="hOPrTWYgPHg" type="youtube" />

      Para mais informações, veja os exemplos abaixo:

      <CollapserGroup>
        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> dentro de uma condição de cláusula <InlineCode>
            SELECT
          </InlineCode></>
          }
        >
          A seguir, você selecionará o nome de domínio do site, removendo `https://` e quaisquer caminhos após o `.com`

          ```sql
          SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') 
          FROM PageView SINCE 1 day ago
          ```

          O seguinte irá capturar apenas a primeira palavra da mensagem de erro.

          ```sql
          SELECT capture(errorMessage, r'(?P<firstWord>\S+)\s.+') 
          FROM Transaction 
          WHERE errorMessage IS NOT NULL
          SINCE 1 hour ago 
          ```
        </Collapser>

        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> dentro de uma condição de cláusula <InlineCode>
            FACET
          </InlineCode></>
          }
        >
          O seguinte será facetado pelo método HTTP capturado.

          ```sql
          SELECT count(*) FROM Log 
          WHERE message LIKE '%HTTP%' 
          FACET capture(message, r'.* "(?P<httpMethod>[A-Z]+) .*')
          ```
        </Collapser>

        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> dentro de uma condição de cláusula <InlineCode>
            WHERE
          </InlineCode></>
          }
        >
          A seguir, filtraremos os resultados com base no evento de log com `message` atributo que corresponde à expressão regular onde o nome do trabalho capturado é `ExampleJob`.

          ```sql
          SELECT message FROM Log 
          WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' 
          SINCE 10 minutes ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> com uma conversão numérica</>
          }
        >
          O seguinte irá capturar a soma do tempo de CPU das linhas de log. Você deve converter explicitamente para numérico para realizar operações matemáticas.

          ```sql
          SELECT sum(numeric(capture(message, r'.*CpuTime:\s(?P<cpuTime>\d+)'))) 
          FROM Log 
          WHERE message LIKE '%CpuTime:%' SINCE 1 hour ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> vários valores com variáveis NRQL</>
          }
        >
          Neste exemplo Variáveis NRQL são usadas para armazenar múltiplos valores capturados de uma mensagem do log.

          ```sql
          FROM Log
          WITH capture(message, r'POST to carts: (?P<URL>.*) body: {"itemId":"(?P<UUID>.*)","unitPrice":(?P<unitPrice>.*)}.*')
            AS (URL, UUID, unitPrice)
          SELECT URL, UUID, unitPrice
          WHERE URL IS NOT NULL
          ```

          Veja mais sobre variáveis NRQL [aqui](#with-as-nrql-var).
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-decode"
    title={<InlineCode>decode(input, encoding)</InlineCode>
    }
  >
    Use `decode()` para realizar conversões de base 64 em strings e blobs. O valor de entrada (o primeiro argumento) será decodificado usando o padrão base 64 especificado pela codificação (o segundo argumento).

    Os seguintes valores de string são parâmetros de codificação suportados:

    * &apos;base64&apos;: Usa o [padrão RFC4648 base-64](https://datatracker.ietf.org/doc/html/rfc4648#section-4)

    * &apos;base64mime&apos;: usa o [padrão RFC2045 base-64 (MIME)](https://datatracker.ietf.org/doc/html/rfc2045)

    * &apos;base64url&apos;: Usa o [padrão RFC4648 base-64 com URL e nome de arquivo em alfabeto seguro](https://datatracker.ietf.org/doc/html/rfc4648#section-5)

      Como `blob()` não é permitido em cláusulas `WHERE` ou `FACET` , `decode()` com tipos de blob não é suportado na cláusula `WHERE` ou para consulta facetada.

      Para codificar strings, consulte a [função`encode()` ](#func-encode).

      <CollapserGroup>
        <Collapser
          title={<>Usando <InlineCode>
            decode()
          </InlineCode> em um atributo de string</>
          }
        >
          ```sql
          FROM Span SELECT entity.guid, decode(entity.guid, 'base64') 
          WHERE entity.guid IS NOT NULL
          ```
        </Collapser>

        <Collapser
          title={<>Usando <InlineCode>
            decode()
          </InlineCode> em um <InlineCode>
            FACET
          </InlineCode></>
          }
        >
          ```sql
          FROM Span SELECT count(*) 
          WHERE entity.guid IS NOT NULL 
          FACET entity.guid, decode(entity.guid, 'base64')
          ```
        </Collapser>

        <Collapser
          title={<>Usando <InlineCode>
            decode()
          </InlineCode> em uma cláusula <InlineCode>
            WHERE
          </InlineCode></>
          }
        >
          ```sql
          FROM Span SELECT count(*) 
          WHERE entity.guid IS NOT NULL 
          AND decode(entity.guid, 'base64') NOT LIKE '%APM%'
          ```
        </Collapser>

        <Collapser
          title={<>Usando <InlineCode>
            decode()
          </InlineCode> com um atributo de tipo de blob</>
          }
        >
          ```sql
          FROM Log
          WITH blob(`newrelic.ext.message`) AS encodedBlob,
          decode(encodedBlob, 'base64') AS decodedBlob
          SELECT encodedBlob, decodedBlob
          WHERE newrelic.ext.message IS NOT NULL
          LIMIT 10
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-dimensions"
    title={<InlineCode>[`dimensões(incluir: [atributo], excluir: [atributo])`]</InlineCode>
    }
  >
    Use a função `dimensions()` para retornar todos os valores dimensionais em um tipo de dados.

    Você pode incluir ou excluir explicitamente um atributo específico usando os argumentos opcionais:

    * `include`: se presente, a lista de inclusão limita `dimensions()` a esses atributos.

    * `exclude`: se presente, o cálculo `dimensions()` ignora esses atributos.

      ```sql
      FROM Metric SELECT count(node_filesystem_size) 
      TIMESERIES FACET dimensions()
      ```

      Quando usado com uma cláusula `FACET` , `dimensions()` produz uma série temporal exclusiva para todos os aspectos disponíveis no tipo de evento, semelhante ao modo como o Prometheus se comporta com consultas não agregadas.
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-encode"
    title={<InlineCode>encode(input, encoding)</InlineCode>
    }
  >
    Use `encode()` para realizar conversões de base 64 em strings. O valor de entrada (o primeiro argumento) será codificado usando o padrão base 64 especificado pela codificação (o segundo argumento).

    Os seguintes valores de string são parâmetros de codificação suportados:

    * &apos;base64&apos;: Usa o [padrão RFC4648 base-64](https://datatracker.ietf.org/doc/html/rfc4648#section-4)

    * &apos;base64mime&apos;: usa o [padrão RFC2045 base-64 (MIME)](https://datatracker.ietf.org/doc/html/rfc2045)

    * &apos;base64url&apos;: Usa o [padrão RFC4648 base-64 com URL e nome de arquivo em alfabeto seguro](https://datatracker.ietf.org/doc/html/rfc4648#section-5)

      Para decodificar strings ou blobs, consulte a [função`decode()` ](#func-decode). `encode()` não é compatível com blobs.

      <CollapserGroup>
        <Collapser
          title={<>Usando <InlineCode>
            encode()
          </InlineCode> em um atributo</>
          }
        >
          ```sql
          FROM PageView SELECT session, encode(session, 'base64')
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cidraddress"
    title={<InlineCode>cidrAddress(attribute [, number [, cidrFormat])</InlineCode>
    }
  >
    Use a função `cidrAddress()` para obter o endereço de rede base de um endereço IP CIDR.

    `cidrAddress()` recebe os seguintes argumentos:

    * `attribute` - Um valor de string que contém um endereço IP sozinho ou com um comprimento de prefixo na notação CIDR.

      * Pode ser um atributo de string ou um literal de string entre aspas.
      * O endereço IP deve ser um endereço IPv4.

    * `number` - Um valor inteiro que representa o comprimento do prefixo.

      * Pode ser um atributo inteiro ou um valor inteiro.
      * Se o parâmetro de atributo estiver em notação CIDR, esse parâmetro será opcional e terá precedência sobre o comprimento do prefixo fornecido na String CIDR.

    * `cidrFormat` - Um valor booleano opcional que é usado para determinar se a saída do endereço de rede deve ser formatada na notação CIDR. O padrão será verdadeiro.

      A função `cidrAddress()` retornará um valor desde que o parâmetro atributo e number contenha um endereço IP e comprimento de prefixo válidos. Se a entrada do parâmetro for inválida, `cidrAddress()` retornará `null`.

      <CollapserGroup>
        <Collapser title="Descubra quais sub-redes estão processando mais solicitações">
          A consulta a seguir retorna as sub-redes que processam a maioria das solicitações do tipo de evento [SyntheticRequest](/attribute-dictionary/?event=SyntheticRequest) .

          ```sql
          FROM SyntheticRequest SELECT count(*) FACET cidrAddress(serverIPAddress, 24)
          ```

          Isso retornaria respostas em um formato como:

          <table>
            <thead>
              <tr>
                <th>
                  Endereço Cidr do endereço IP do servidor
                </th>

                <th>
                  Contar
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  10.0.0.0/24
                </td>

                <td>
                  6k
                </td>
              </tr>

              <tr>
                <td>
                  10.10.1.0/24
                </td>

                <td>
                  4k
                </td>
              </tr>

              <tr>
                <td>
                  10.0.14.0/24
                </td>

                <td>
                  1k
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser title="Consulte todos os endereços IP que existem em um intervalo CIDR">
          Esta consulta retorna todos os endereços IP no atributo [`serverIPAddress`](/attribute-dictionary/?event=SyntheticRequest&attribute=serverIPAddress) que existem no intervalo CIDR de 10.0.0.0 a 10.0.0.255.

          ```sql
          FROM SyntheticRequest SELECT uniques(serverIPAddress) 
          WHERE cidrAddress(serverIPAddress, 24) = '10.0.0.0/24'
          ```
        </Collapser>

        <Collapser title="Filtrar endereços IP que existem em um intervalo CIDR específico dos resultados da consulta">
          Esta consulta retorna uma contagem de todos os registros, excluindo registros que contêm um valor [`serverIPAddress`](/attribute-dictionary/?event=SyntheticRequest&attribute=serverIPAddress) que se enquadra no intervalo CIDR de 10.0.0.0/24 ou 10.10.1.0/24.

          ```sql
          FROM SyntheticRequest SELECT count(*) 
          WHERE cidrAddress(serverIPAddress, 24) NOT IN ('10.0.0.0/24', '10.10.1.0/24')
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="event-type"
    title={<InlineCode>eventType()</InlineCode>
    }
  >
    ```sql
    ...WHERE eventType() = 'EventNameHere'...
    ...FACET eventType()...
    ```

    Use a função `eventType()` em uma cláusula [`FACET`](#sel-facet) para dividir os resultados pelo tipo de dados selecionado ou em uma cláusula [`WHERE`](#sel-where) para filtrar os resultados para um tipo de dados específico. Isso é particularmente útil para direcionar tipos de dados específicos com as funções [`filter()`](#func-filter) e [`percentage()`](#func-percentage) .

    <Callout variant="important">
      Neste contexto, “tipo de evento” refere-se aos tipos de dados que você pode acessar com uma consulta NRQL.
    </Callout>

    <CollapserGroup>
      <Collapser
        id="filter-eventtype"
        title={<>Use <InlineCode>
          eventType()
        </InlineCode> na função <InlineCode>
          filter()
        </InlineCode></>
        }
      >
        Esta consulta retorna a porcentagem do total de `TransactionError` resultados do total `Transaction` resultados. Você pode usar a função `eventType()` para destinar tipos específicos de dados com a função `filter()` .

        ```sql
        SELECT 100 * filter(count(*), WHERE eventType() = 'TransactionError') / filter(count(*), WHERE eventType() = 'Transaction') 
        FROM Transaction, TransactionError 
        WHERE appName = 'App.Prod' 
        TIMESERIES 2 Minutes SINCE 6 hours ago
        ```
      </Collapser>

      <Collapser
        id="facet-eventtype"
        title={<>Use <InlineCode>
          eventType()
        </InlineCode> com <InlineCode>
          FACET
        </InlineCode></>
        }
      >
        Esta consulta exibe uma contagem de quantos registros cada tipo de dados (`Transaction` e `TransactionError`) retorna.

        ```sql
        SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getfield"
    title={<InlineCode>getField(attribute, field)</InlineCode>
    }
  >
    Use a função `getField()` para extrair um elemento de uma matriz ou um campo de tipos de dados compostos, como [dados métricos dimensionais](/docs/data-apis/understand-data/metric-data/metric-data-type).

    `getField()` recebe os seguintes argumentos:

    * `attribute` - Uma matriz ou um tipo de dado composto.
    * `field` - O índice do elemento da matriz ou o nome do campo do tipo de dado composto.

    Você também pode usar colchetes `[ ]` como uma abreviação para `getField()`.

    <CollapserGroup>
      <Collapser title="Extraindo um elemento de uma matriz">
        <Callout variant="important">
          A indexação da matriz começa com `0`.
        </Callout>

        **Exemplos**\
        Considere a matriz `[100, 110, 90, 100, 105]` armazenada no atributo `durations`. A consulta abaixo retornará `90`:

        ```sql
        SELECT getField(durations, 2) FROM Foo
        ```

        A consulta a seguir usando a notação abreviada `getField()` também retornará `90`:

        ```sql
        SELECT durations[2] FROM Foo
        ```
      </Collapser>

      <Collapser title="Extraindo um campo de um tipo de dado composto">
        Os tipos de dados compostos suportados e seus campos são:

        <table>
          <thead>
            <tr>
              <th style={{ width: "500px" }}>
                Tipo de métrica
              </th>

              <th>
                Campos suportados
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `summary`
              </td>

              <td>
                `count`, `total`, `max`, `min`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `gauge`
              </td>

              <td>
                `count`, `total`, `max`, `min`, `latest`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `distribution`
              </td>

              <td>
                `count`, `total`, `max`, `min`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `count`
              </td>

              <td>
                `count`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `cumulativeCount`
              </td>

              <td>
                `count`, `cumulative`, `type`
              </td>
            </tr>

            <tr>
              <td>
                `timeslice`
              </td>

              <td>
                `count`, `total`, `totalExclusive`, `min`, `max`, `sumOfSquares`
              </td>
            </tr>
          </tbody>
        </table>

        **Exemplos**

        ```sql
        SELECT max(getField(mySummary, count)) FROM Metric
        ```

        ```sql
        SELECT sum(mySummary) FROM Metric where getField(mySummary, count) > 10
        ```

        consulta usando a notação abreviada para `getField()`:

        ```sql
        SELECT max(mySummary[count]) FROM Metric
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getCdfCount"
    title={<InlineCode>getCdfCount(attribute, threshold)</InlineCode>
    }
  >
    `getCdfCount()` é uma implementação da [função de distribuição cumulativa](https://en.wikipedia.org/wiki/Cumulative_distribution_function), retornando o número de valores em `attribute` igual ou inferior a `threshold`.

    Apenas um limite é permitido. `Attribute` pode ser um atributo numérico ou um atributo de métrica de distribuição. Tipos mistos em uma consulta são aceitos.

    Para um tipo numérico, retorna 1 se o atributo for menor ou igual ao limite, caso contrário, retorna 0. Para uma distribuição, retorna a contagem no conjunto de dados representado pela distribuição. Para todos os outros tipos, retorna 0.

    <CollapserGroup>
      <Collapser title="Obtenha o número de primeiras pinturas mais rápido que um limite">
        Esta consulta retorna o número do evento onde `firstPaint` é menor ou igual a 1 segundo.

        ```sql
        FROM PageView SELECT sum(getCdfCount(firstPaint, 1.0))
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-if"
    title={<><InlineCode>
      if(condition, trueValue [, falseValue])
    </InlineCode></>
    }
  >
    Use `if()` para executar operações de fluxo de controle if-then-else em uma consulta.

    `if()` leva 3 argumentos:

    * `condition` - uma expressão que pode ser avaliada como `true` ou `false`
    * `trueValue` - este valor é retornado se a expressão booleana for `true`
    * `falseValue` - este valor opcional é retornado se a expressão booleana for `false`, ou se não for fornecido `NULL`, é retornado

    <CollapserGroup>
      <Collapser title="Uso básico">
        ```sql
        FROM Log
        SELECT count(*)
        FACET if(level_name = 'ERROR', 'ERROR', 'NOT_ERROR')
        ```
      </Collapser>

      <Collapser
        title={<>Use com <InlineCode>
          AND
        </InlineCode> e <InlineCode>
          OR
        </InlineCode></>
        }
      >
        ```sql
        FROM Log
        SELECT count(*)
        FACET if(level_name = 'INFO' OR level_name = 'WARNING', 'NOT_ERROR', 'ERROR')
        ```
      </Collapser>

      <Collapser
        title={<>Aninhado <InlineCode>
          If()
        </InlineCode></>
        }
      >
        Use uma função `if()` aninhada para adicionar lógica condicional adicional.

        ```sql
        FROM Transaction SELECT count(*)
        FACET if(appName LIKE '%java%', 'Java',
            if(appName LIKE '%kafka%', 'Kafka', 'Other'))
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-jparse"
    title={<InlineCode>jparse(attribute [, path])</InlineCode>
    }
  >
    Use a função de análise JSON, `jparse()`, para analisar um valor de string e produzir um mapa/lista de valores (ou estruturas aninhadas) que podem ser manipulados como qualquer outro tipo de valor de primeira classe em NRQL.

    `jparse()` leva dois argumentos:

    * `attribute` - Um valor de string JSON.
    * `path` - Um valor de string opcional que é usado para referenciar diretamente uma parte específica do JSON dentro do parâmetro `attribute` . Consulte a seção [Referência de sintaxe do caminho de análise JSON](#json-parse-path-syntax-reference) abaixo.

    A função `jparse()` segue o [formato RFC 8259](https://datatracker.ietf.org/doc/html/rfc8259#section-2) para analisar valores JSON. Quando a função `jparse()` for usada sem o parâmetro `path` , ela retornará o valor JSON desserializado.

    Você pode usar colchetes para extrair valores individuais de um resultado `jparse()` por meio de uma chave/índice e mapear chaves JSON diretamente para atributo usando a cláusula `WITH` .

    <CollapserGroup>
      <Collapser id="jparse-square-bracket-syntax" title="Referenciando uma chave/índice usando a sintaxe de colchetes">
        <DNT>
          **Referencing a key**
        </DNT>

        A consulta a seguir faz referência à chave `userNames` no atributo `jsonString` e retornará `['abc', 'xyz']`.

        ```sql
        WITH '{"userNames": ["abc", "xyz"]}' AS jsonString SELECT jparse(jsonString)[userNames]
        ```

        <DNT>
          **Referencing an index**
        </DNT>

        A consulta a seguir faz referência ao índice `0` dentro do atributo `jsonString` e retornará `'abc'`.

        ```sql
        WITH '["abc", "xyz"]' AS jsonString SELECT jparse(jsonString)[0]
        ```
      </Collapser>

      <Collapser id="mapping-json-keys-to-attributes" title="Mapeamento de chaves JSON para atributo">
        A consulta a seguir usa `jparse()` na cláusula `WITH` para mapear as chaves JSON `userName` e `id` em variáveis NRQL para que possam ser usadas no restante da consulta.

        ```sql
        WITH '{"userName": "test", "unused": null, "id": 100}' AS jsonString, jparse(jsonString) AS (userName, id) SELECT userName, id
        ```
      </Collapser>
    </CollapserGroup>

    Para analisar valores específicos da string JSON, você pode usar o parâmetro `path` .

    <Collapser id="json-parse-path-syntax-reference" title="Referência de sintaxe do caminho de análise JSON">
      É comum que os dados JSON sejam aninhados em várias camadas em formas não triviais. A sintaxe do caminho permite fazer referência direta a uma parte específica dos dados JSON.

      Dados de exemplo:

      ```json
      {
        "valueA": "test",
        "valueB": {
          "nestedValue1": [1, 2, 3],
          "nestedValue2": 100
        },
        "valueC": [
          { "id": 1, "label": "A", "other": 7 },
          { "id": 2, "label": "B", "other": 9 },
          { "id": 3, "label": "C", "other": 13 }
        ]
      }
      ```

      Exemplos de sintaxe de caminho usando os dados acima:

      <table id="join-types">
        <thead>
          <tr>
            <th>
              <DNT>
                **Path Syntax Example**
              </DNT>
            </th>

            <th>
              <DNT>
                **Result Description**
              </DNT>
            </th>

            <th>
              <DNT>
                **Result**
              </DNT>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              `valueA`
            </td>

            <td>
              Retorna o valor na chave
            </td>

            <td>
              `"test"`
            </td>
          </tr>

          <tr>
            <td>
              `["valueA"]`
            </td>

            <td>
              Retorna o valor na chave
            </td>

            <td>
              `"test"`
            </td>
          </tr>

          <tr>
            <td>
              `[valueA, valueC]`
            </td>

            <td>
              Retorna lista de valor principal
            </td>

            <td>
              `["test", [{"id": 1…}, {"id": 2…}], {"id": 3…}]]`
            </td>
          </tr>

          <tr>
            <td>
              `valueB.nestedValue2`
            </td>

            <td>
              Retorna o valor na chave
            </td>

            <td>
              `100`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[0]`
            </td>

            <td>
              Retorna o valor da lista no índice `0`
            </td>

            <td>
              `{"id": 1…}`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[0,2]`
            </td>

            <td>
              Retorna os valores da lista no índice `0` e `2`
            </td>

            <td>
              `[{"id": 1…}, {"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[0:2]`
            </td>

            <td>
              Retorna o intervalo de valores da lista do primeiro índice ao segundo, excluindo o valor no segundo índice. Nesse caso, os valores da lista no índice `0` e `1` são retornados.
            </td>

            <td>
              `[{"id": 1…}, {"id": 2…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[:2]`
            </td>

            <td>
              Retorna o intervalo de valores da lista do início ao segundo índice, excluindo o valor no segundo índice. Nesse caso, os valores da lista no índice `0` e `1` são retornados.
            </td>

            <td>
              `[{"id": 1…}, {"id": 2…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[:-2]`
            </td>

            <td>
              Retorna todos os valores da lista, exceto o último *n*, onde *n* é um número negativo após os dois pontos (ou seja, `[:-n]`). Neste caso, o valor da lista no índice `0` será retornado.
            </td>

            <td>
              `[{"id": 1…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[1:]`
            </td>

            <td>
              Retorna o intervalo de valores da lista do índice especificado até o final da lista. Nesse caso, os valores da lista no índice `1` e `2` são retornados.
            </td>

            <td>
              `[{"id": 2…}, {"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[-1:]`
            </td>

            <td>
              Retorna os últimos *n* valores da lista, onde *n* é um número negativo antes dos dois pontos (por exemplo, `[-n:]`). Neste caso, o valor da lista no índice `2` será retornado.
            </td>

            <td>
              `[{"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[*]`
            </td>

            <td>
              Retorna todos os valores da lista
            </td>

            <td>
              `[{"id": 1…}, {"id": 2…}, {"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[*].id`
            </td>

            <td>
              Retorna o valor principal especificado de todos os membros da lista. Neste caso, o valor principal `id` .
            </td>

            <td>
              `[1, 2, 3]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[*]["label", "other"]`
            </td>

            <td>
              Retorna as chaves especificadas de todos os membros da lista. Neste caso, o valor principal `label` e `other` .
            </td>

            <td>
              `[["A", 7],…]`
            </td>
          </tr>
        </tbody>
      </table>
    </Collapser>

    Exemplos:

    <CollapserGroup>
      <Collapser id="basic-jparse-example" title="Exemplo Básico">
        A consulta a seguir analisa a string JSON no atributo `jsonString` .

        ```sql
        WITH '{"user": {"name": "John", "id": 5}}' AS jsonString SELECT jparse(jsonString)
        ```

        Esta consulta retornará a string JSON desserializada:

        ```json
        {"user":{"name":"John","id":5}}
        ```
      </Collapser>

      <Collapser id="parse-specific-value-from-log-message" title="Analisar um valor específico de uma mensagem do log">
        Um problema comum é ter dados ricos e estruturados escondidos em uma mensagem do log. Você pode aproveitar [`aparse()`](#func-aparse) e `jparse()` para eliminar ruídos e encontrar valores específicos.

        A seguinte consulta:

        1. Chama `aparse()` para extrair dados JSON do atributo `logMessage`
        2. Analisa o campo `user.name` dos dados JSON extraídos usando `jparse()` e o parâmetro de caminho `user.name` .

        ```sql
        WITH '1693242121842: value=\'{"user": {"name": "John", "id": 5}}\', useless=stuff' AS logMessage, aparse(logMessage, '%: value=\'*\'%') AS jsonString SELECT jparse(jsonString, 'user.name')
        ```
      </Collapser>

      <Collapser id="parse-multiple-values-from-json" title="Analisar vários valores aninhados de uma string JSON">
        A consulta a seguir analisa cada campo `id` da lista de objetos no atributo `jsonString` e gera esses valores como uma matriz.

        ```sql
        WITH '{"users": [{"name": "A", "id": 5}, {"name": "B", "id": 10}]}' AS jsonString, jparse(jsonString, 'users[*].id') AS ids SELECT ids
        ```

        A consulta acima retornará `[5, 10]`.
      </Collapser>
    </CollapserGroup>

    *Funções relacionadas:* [`mapKeys()`](#func-mapKeys), [`mapValues()`](#func-mapValues)
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-length"
    title={<InlineCode>length(attribute)</InlineCode>
    }
  >
    Use a função `length()` para retornar o comprimento de um valor de string ou o número de elementos em um valor de matriz.

    É preciso um único argumento.

    <CollapserGroup>
      <Collapser title="Obtenha o comprimento do URL do PageView">
        Esta consulta retorna o comprimento de cada string de URL do evento `PageView` .

        ```sql
        SELECT length(pageUrl) FROM PageView
        ```
      </Collapser>

      <Collapser title="Obter o comprimento de uma matriz">
        Considere a matriz `["US", "CA", "UK"]` armazenada no atributo `countries` .

        ```sql
        SELECT length(countries) FROM Foo
        ```

        length(countries) na consulta acima retornará `3`.
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-contains"
    title={<InlineCode>contains(attribute, element)</InlineCode>
    }
  >
    Use a função `contains()` para verificar se um elemento existe dentro de uma matriz.

    `contains()` recebe os seguintes argumentos:

    * `attribute` - Uma matriz
    * `element` - O elemento para verificar a matriz

    <CollapserGroup>
      <Collapser title="Verifique se uma matriz contém um elemento">
        Considere a matriz `["9999-1234-9999", "3333-7890-3333", "5555-3456-555"]` armazenada no atributo `guids` .

        ```sql
        SELECT contains(guids, '5555-3456-555') FROM Foo
        ```

        `contains(guids, '5555-3456-555')` na consulta acima retornará `TRUE`.
      </Collapser>

      <Collapser title="Filtrar itens em count(*) usando contains">
        Considere a matriz `["9999-1234-9999", "3333-7890-3333", "5555-3456-555"]` armazenada no atributo `guids` dentro do tipo de evento `Transaction` .

        ```sql
        SELECT count(*) FROM Transaction WHERE contains(guids, '9999-1234-9999')
        ```

        A consulta acima retornará uma contagem de transações que incluem o guid `"9999-1234-9999"` .
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-lookup"
    title={<InlineCode>lookup(table)</InlineCode>
    }
  >
    Se você [carregou uma tabela de consulta](/docs/logs/ui-data/lookup-tables-ui), você pode usar esta função com um nome de tabela para acessar os dados dessa tabela em uma consulta. Aqui está um exemplo de consulta:

    ```sql
    FROM Log
    SELECT count(*)
    WHERE hostname IN (FROM lookup(myHosts) SELECT uniques(myHost))
    ```

    Para mais informações, veja [Como consultar tabela de consulta de dados](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/lookups).
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-lower"
    title={<InlineCode>lower(str)</InlineCode>
    }
  >
    Use a função `lower()` para alterar todos os caracteres alfabéticos de um valor de string para minúsculas.

    Argumentos:

    * `str` - O valor da string deve ser em minúsculas

      * Pode ser qualquer coisa avaliada como uma string, incluindo uma string literal entre aspas, uma string de consulta atributo, uma função que retorna uma string ou até mesmo uma subconsulta que retorna um único valor de string.
      * Se esse argumento for avaliado como nulo, a função `lower()` retornará nulo.

      <CollapserGroup>
        <Collapser title="Letras minúsculas em uma string">
          Esta consulta demonstra o uso da função `lower()` em diversas partes de uma consulta.

          ```sql
          FROM PageAction
          SELECT latest(lower(actionName))
          WHERE lower(actionName) = lower('acmePageRenderedEvent') OR lower(actionName) = lower('SubmitLogin')
          FACET concat(actionName, ':', lower(actionName))
          ```

          <img title="screenshot lower()" alt="screenshot lower()" src="/images/lowerExample.webp" />

          <figcaption>
            <InlineCode>
              lower(str)
            </InlineCode> exemplo
          </figcaption>
        </Collapser>
      </CollapserGroup>

      *Função relacionada: [<InlineCode>
        upper()
      </InlineCode>](#func-upper)*
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mapKeys"
    title={<InlineCode>mapKeys(attribute)</InlineCode>
    }
  >
    Use a função `mapKeys()` para retornar uma lista de chaves quando um mapa for fornecido como entrada no parâmetro `attribute` .

    <CollapserGroup>
      <Collapser id="extract-list-of-keys" title="Extraia uma lista de chaves em uma string JSON">
        ```sql
        WITH '{"userResult1": 100, "userResult2": 200, "userResult3": 4}' AS jsonString SELECT mapKeys(jparse(jsonString)) AS keys
        ```

        A consulta acima:

        1. Desserializa a string JSON no atributo `jsonString` em um mapa usando a função `jparse()`
        2. Chama a função `mapKeys()` para extrair uma lista de todas as chaves deste mapa
        3. Vincula esta lista de chaves ao atributo `keys`

        Após executar a consulta acima, `keys` conterá a lista `['userResult1', 'userResult2', 'userResult3']`.
      </Collapser>

      <Collapser id="extract-list-of-keys-with-nested-keys" title="Extraia uma lista de chaves de uma string JSON com chaves aninhadas">
        ```sql
        WITH '{"value1": "test", "value2": {"nestedValue1": [1, 2, 3], "nestedValue2": 100}}' AS jsonString SELECT mapKeys(jparse(jsonString)) AS keys
        ```

        A consulta acima extrairá apenas as chaves mais externas da string JSON no atributo `jsonString` . Após executar a consulta, `keys` conterá a lista `['value1', 'value2']`.
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mapValues"
    title={<InlineCode>mapValues(attribute)</InlineCode>
    }
  >
    Use a função `mapValues()` para retornar uma lista de valores quando um mapa for fornecido como entrada no parâmetro `attribute` .

    <CollapserGroup>
      <Collapser id="extract-list-of-values" title="Extraia uma lista de valores dentro de uma string JSON">
        ```sql
        WITH '{"userResult1": 100, "userResult2": 200, "userResult3": 4}' AS jsonString SELECT mapValues(jparse(jsonString)) AS values
        ```

        A consulta acima:

        1. Desserializa a string JSON no atributo `jsonString` em um mapa usando a função `jparse()`
        2. Chama a função `mapValues()` para extrair uma lista de todos os valores neste mapa
        3. Vincula esta lista de valores ao atributo `values`

        Após executar a consulta acima, `values` conterá a lista `[100, 200, 4]`.
      </Collapser>

      <Collapser id="extract-list-of-values-with-nested-values" title="Extraia uma lista de valores de uma string JSON com valores aninhados">
        ```sql
        WITH '{"value1": "test", "value2": {"nestedValue1": [1, 2, 3], "nestedValue2": 100}}' AS jsonString SELECT mapValues(jparse(jsonString)) AS values
        ```

        A consulta acima extrai os valores mais externos da string JSON no atributo `jsonString` . Depois de executar a consulta, `values` conterá uma lista da string `"test"` e do objeto aninhado.

        Isso pode ser visto na visualização JSON:

        ```json
        "contents": [
          {
            "function": "alias",
            "alias": "values",
            "contents": {
              "constant": [
                "test",
                {
                  "nestedValue1": [
                    1,
                    2,
                    3
                  ],
                  "nestedValue2": 100
                }
              ]
            }
          }
        ],
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-minOf"
    title={<InlineCode>minuteOf(attribute), hourOf(attribute), etc.</InlineCode>
    }
  >
    Use a função `minuteOf()` para extrair apenas a parte dos minutos (ou seja, minutos de 0 a 59) de um atributo que contém um valor timestamp válido. Isso também funciona para funções como `hourOf()`, `weekOf()` e assim por diante. Para obter uma lista completa de funções baseadas em tempo, consulte a tabela em nosso [documento de resultados de grupo ao longo do tempo](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-group-results-across-time/#cohorts)
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mod"
    title={<InlineCode>mod(attribute, divisor)</InlineCode>
    }
  >
    Use a função `mod()` para retornar o módulo de piso após dividir o valor do atributo numérico fornecido (o primeiro argumento ou dividendo) por um valor numérico (o segundo argumento ou divisor). Esta operação de módulo pode ser usada dentro de uma condição de cláusula `WHERE` para filtrar para um subconjunto arbitrário de resultados ou dentro de uma cláusula `FACET` como uma maneira de subdividir o conjunto de resultados.

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          mod()
        </InlineCode> dentro de uma condição de cláusula <InlineCode>
          WHERE
        </InlineCode></>
        }
      >
        ```sql
        FROM Transaction SELECT * WHERE mod(port, 2) = 1
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          mod()
        </InlineCode> dentro de uma cláusula <InlineCode>
          FACET
        </InlineCode></>
        }
      >
        ```sql
        FROM NrConsumption SELECT uniques(hostId, 10000) 
        SINCE 1 day AGO FACET mod(hostId, 10)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-position"
    title={<InlineCode>position(str, substr [, occurrence])</InlineCode>
    }
  >
    Use a função `position()` para encontrar a localização de uma substring dentro de uma string. A correspondência diferencia maiúsculas de minúsculas.

    Argumentos:

    * `str` - a string na qual a substring será encontrada.

      * Pode ser qualquer coisa avaliada como uma string, incluindo uma string literal entre aspas, uma string de consulta atributo, uma função que retorna uma string ou até mesmo uma subconsulta que retorna um único valor de string.

    * `substr` - a string a ser pesquisada dentro de str.

    * `occurrence` - indica qual ocorrência de substr da qual retornar a posição.

      * *Padrão*: `0`
      * Se positivo, encontre a enésima ocorrência do substr desde o início de str, com base em zero
      * Se for negativo, encontre a enésima ocorrência do substr no final de str. A última ocorrência de substr seria a ocorrência -1.

      Alias: <InlineCode>
        indexOf(str, substr \[, occurrence])
      </InlineCode> - `indexOf()` é um nome alternativo para a função `position()`

      Retorna:

      * O índice baseado em 0 do caractere inicial do substr dentro de str
      * Nulo será retornado se str for nulo, substr for nulo ou a ocorrência referenciada de substr não for encontrada

    <CollapserGroup>
      <Collapser title="Encontre o índice posicional de uma substring em um URL">
        Esta consulta demonstra o uso da função <InlineCode>
          position()
        </InlineCode> para localizar o índice posicional de várias substrings em uma string. O uso da função <InlineCode>
          position()
        </InlineCode> nos argumentos da função [<InlineCode>
          substring()
        </InlineCode>](#func-substring) também é demonstrado aqui.

        ```sql
        FROM PageView
        WITH position(pageUrl, ':') AS FirstColon,
          position(pageUrl, '/', 1) + 1 AS DomainBegin, 
          position(pageUrl, '/', 2) AS DomainEnd, 
          DomainEnd - DomainBegin AS DomainLength
        SELECT pageUrl, FirstColon, substring(pageUrl, 0, FirstColon) AS Protocol,
          DomainBegin, DomainEnd, DomainLength, substring(pageUrl, DomainBegin, DomainLength) AS Domain,
          position(pageUrl, '/', -1) AS LastSlash, 
          substring(pageUrl, position(pageUrl, '/', -1)) AS PathEnd
        ```

        <img title="screenshot position()" alt="screenshot position()" src="/images/positionExample.webp" />

        <figcaption>
          <InlineCode>
            position(str, substr \[, occurrence])
          </InlineCode> exemplo
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="round"
    title={<InlineCode>round(attribute)</InlineCode>
    }
  >
    Use a função `round()` para retornar o valor arredondado de um atributo.

    Opcionalmente, `round()` pode receber um segundo argumento, `to_nearest`, para arredondar o primeiro argumento para o múltiplo mais próximo do segundo. `to_nearest` pode ser fracionário.

    ```sql
    SELECT round(n [, to_nearest])
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="stddev"
    title={<InlineCode>stddev(attribute)</InlineCode>
    }
  >
    Use a função `stddev()` para retornar um [Desvio padrão](https://en.wikipedia.org/wiki/Standard_deviation) para um atributo numérico durante o intervalo de tempo especificado. É preciso um único argumento. Se o atributo não for numérico, ele retornará um valor zero.
  </Collapser>

  <Collapser
    className="freq-link"
    id="abs"
    title={<InlineCode>abs(atributo)</InlineCode>
    }
  >
    Use a função `abs()` para retornar o [valor absoluto](https://en.wikipedia.org/wiki/Absolute_value) de `attribute`.
  </Collapser>

  <Collapser
    className="freq-link"
    id="floor"
    title={<InlineCode>piso(atributo)</InlineCode>
    }
  >
    Use a função `floor()` para retornar o inteiro mais próximo de `attribute` arredondando para baixo.
  </Collapser>

  <Collapser
    className="freq-link"
    id="ceil"
    title={<InlineCode>teto(atributo)</InlineCode>
    }
  >
    Use a função `ceil()` para retornar o inteiro mais próximo de `attribute` arredondando para cima.
  </Collapser>

  <Collapser
    className="freq-link"
    id="clamp_max"
    title={<InlineCode>clamp_max(atributo, limite)</InlineCode>
    }
  >
    Use a função `clamp_max()` para impor um limite superior ao valor de `attribute`.

    `clamp_max()` recebe os seguintes argumentos:

    * `attribute` - Um atributo numérico.
    * `limit` - O limite superior para o valor `attribute` .

    **Exemplo**\
    Você pode usar `clamp_max()` para garantir que valores discrepantes não distorçam a escala de um gráfico de série temporal:

    ```sql
      SELECT clamp_max(average(duration), 10) FROM Transaction TIMESERIES
    ```

    A consulta acima retorna `duration` a menos que exceda 10, nesse caso retornará 10.
  </Collapser>

  <Collapser
    className="freq-link"
    id="clamp_min"
    title={<InlineCode>clamp_min(atributo, limite)</InlineCode>
    }
  >
    Use a função `clamp_min()` para impor um limite inferior ao valor de `attribute`.

    `clamp_min()` recebe os seguintes argumentos:

    * `attribute` - Um atributo numérico.
    * `limit` - O limite inferior para o valor `attribute` .

    **Exemplo**\
    Você pode usar `clamp_min()` para garantir que valores discrepantes não distorçam a escala de um gráfico de série temporal:

    ```sql
      SELECT clamp_min(average(duration), 1) FROM Transaction TIMESERIES
    ```

    A consulta acima retorna `duration` a menos que seja menor que 1, nesse caso retornará 1.
  </Collapser>

  <Collapser
    className="freq-link"
    id="pow"
    title={<InlineCode>pow(atributo, expoente)</InlineCode>
    }
  >
    Use a função `pow()` para elevar `attribute` à potência de `exponent`.

    `pow()` recebe os seguintes argumentos:

    * `attribute` - Um atributo numérico.
    * `exponent` - Um atributo numérico para elevar `attribute` à potência de.

    **Exemplo**\
    A consulta abaixo retornará `duration` elevada à potência de 4:

    ```sql
      SELECT pow(duration, 4) FROM Transaction
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sqrt"
    title={<InlineCode>sqrt(atributo)</InlineCode>
    }
  >
    Use a função `sqrt()` para retornar a [raiz quadrada](https://en.wikipedia.org/wiki/Square_root) de `attribute`.
  </Collapser>

  <Collapser
    className="freq-link"
    id="exp"
    title={<InlineCode>exp(atributo)</InlineCode>
    }
  >
    Use a função `exp()` para retornar a [função exponencial natural](https://en.wikipedia.org/wiki/Exponential_function) de `attribute`.
  </Collapser>

  <Collapser
    className="freq-link"
    id="ln"
    title={<InlineCode>ln(atributo)</InlineCode>
    }
  >
    Use a função `ln()` para retornar o [logaritmo natural](https://en.wikipedia.org/wiki/Natural_logarithm) de `attribute`.
  </Collapser>

  <Collapser
    className="freq-link"
    id="log2"
    title={<InlineCode>log2(attribute)</InlineCode>
    }
  >
    Use a função `log2()` para retornar o [logaritmo de base 2](https://en.wikipedia.org/wiki/Binary_logarithm) de `attribute`.
  </Collapser>

  <Collapser
    className="freq-link"
    id="log10"
    title={<InlineCode>log10(attribute)</InlineCode>
    }
  >
    Use a função `log10()` para retornar o [logaritmo de base 10](https://en.wikipedia.org/wiki/Common_logarithm) de `attribute`.
  </Collapser>

  <Collapser
    className="freq-link"
    id="log"
    title={<InlineCode>log(attribute, base)</InlineCode>
    }
  >
    Use a função `log()` para calcular o logaritmo de `attribute` com base de `base`.

    `log()` recebe os seguintes argumentos:

    * `attribute` - Um atributo numérico.
    * `base` - Um atributo numérico a ser usado como base ao calcular o logaritmo de `attribute`.

    **Exemplo**\
    A consulta abaixo calculará o logaritmo de `duration` de base 4:

    ```sql
      SELECT log(duration, 4) FROM Transaction
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-string"
    title={<InlineCode>string(attribute [, precision: ])</InlineCode>
    }
  >
    Use a função `string()` para converter um valor numérico, booleano, de tupla ou de matriz em um valor de string.

    São necessários dois argumentos, um opcional:

    * Nome do atributo
    * Precisão: se presente, impõe um limite no número de casas decimais incluídas na conversão de valores numéricos de ponto flutuante.

    <CollapserGroup>
      <Collapser title="Obtenha resultados de consulta sem string como um valor de string">
        Esta consulta retorna a duração do PageView como uma string, com duas casas decimais.

        ```sql
        FROM PageView SELECT string(duration, precision: 2)
        ```
      </Collapser>

      <Collapser title="Obtenha resultados da função agregadora sem string como um valor de string">
        Esta consulta retorna a média da duração do PageView como uma string, com duas casas decimais.

        ```sql
        FROM PageView SELECT string(average(duration), precision: 2)
        ```
      </Collapser>

      <Collapser title="Resultados da consulta facetada por um número de ponto flutuante sem truncamento">
        Use `string()` para facetar um valor de ponto flutuante sem perder casas decimais.

        ```sql
        FROM PageView SELECT count(*) 
        FACET string(tuple(asnLatitude, asnLongitude), precision: 2)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-substring"
    title={<InlineCode>substring(str, start [, length])</InlineCode>
    }
  >
    Use a função `substring()` para extrair uma parte de uma string.

    Argumentos:

    * `str` - a string da qual extrair uma substring.

      * Pode ser qualquer coisa avaliada como uma string, incluindo uma string literal entre aspas, uma string de consulta atributo, uma função que retorna uma string ou até mesmo uma subconsulta que retorna um único valor de string.
      * Se esse argumento for avaliado como nulo, a função `substring()` retornará nulo.

    * `start` - a posição dentro de str a partir da qual a extração deve ser iniciada.

      * O primeiro caractere em str é a posição 0.
      * Um valor negativo encontrará a posição relativa ao final de str, sendo o último caractere da string a posição -1.
      * Se start for maior ou igual ao comprimento de str, a função `substring()` retornará uma string vazia.
      * Se start for negativo e seu valor absoluto for maior que o comprimento de str, a substring extraída começará na posição 0.

    * `length` - o comprimento, ou número de caracteres, da substring a ser extraída de str.

      * *Opcional* - se o comprimento não for fornecido, todos os caracteres em str após a posição inicial resolvida serão incluídos.

      <CollapserGroup>
        <Collapser title="Extraia várias partes de uma string">
          Esta consulta retorna partes do valor da sessão.

          ```sql
          FROM PageView
          SELECT session, substring(session, 0, 3) AS First3,
            substring(session, 3) AS After3rd,
            substring(session, -3) AS Last3
          ```

          <img title="screenshot substring()" alt="screenshot substring()" src="/images/substringExample.webp" />

          <figcaption>
            <InlineCode>
              substring(str, start \[, length])
            </InlineCode> exemplo
          </figcaption>
        </Collapser>
      </CollapserGroup>

      *Consulte a função [<InlineCode>
        position()
      </InlineCode>](#func-position) para obter exemplos de uso de <InlineCode>
        substring()
      </InlineCode> e <InlineCode>
        position()
      </InlineCode> juntos.*
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-toDatetime"
    title={<InlineCode>toDatetime(timestamp[, pattern [, timezone]])</InlineCode>
    }
  >
    Use a função `toDatetime()` para converter um timestamp em uma string de data e hora formatada.

    `toDatetime()` recebe os seguintes argumentos:

    * `timestamp` - Um timestamp numérico a ser traduzido em uma sequência de data e hora. Este pode ser um valor numérico ou um atributo e será convertido internamente em `long` .
    * `pattern` - Um padrão de data e hora opcional usado para formatar o resultado. Consulte a seção *Padrões de formatação e análise* na [documentação do DatetimeFormatter](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html) para saber como construir uma sequência de padrões.
      * Este deve ser um valor de string constante e terá como padrão `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` se um padrão não for fornecido.
    * `timezone` - Um valor de fuso horário opcional que é usado para interpretar a string de data e hora (ex. (UTC).
      * Deve ser um valor de string constante e o padrão será UTC ou o valor fornecido em `WITH TIMEZONE` , se disponível.

    Contanto que a entrada seja um valor numérico válido, a função `toDatetime()` sempre retornará um valor.

    Alias: `fromTimestamp()` é um nome alternativo para a função `toDatetime()` .

    Exemplos:

    <CollapserGroup>
      <Collapser title="Traduzir um timestamp usando o padrão padrão">
        A consulta a seguir traduz o atributo `timestampValue` usando o padrão padrão de `yyyy-MM-dd'T'HH:mm:ss.SSSXXX`. Isso retornará a string de data e hora `1970-01-01T00:20:34.567Z`.

        ```sql
        WITH 1234567 AS timestampValue SELECT toDatetime(timestampValue)
        ```
      </Collapser>

      <Collapser title="Traduzir um timestamp usando o parâmetro fuso horário">
        A consulta a seguir traduz o atributo `timestampValue` usando a string padrão `yyyy-MM-dd` com o fuso horário definido como &apos;América/Los\_Angeles&apos;. Isso retornará a string de data e hora `1969-12-31`.

        ```sql
        WITH 1234567 AS timestampValue SELECT toDatetime(timestampValue, 'yyyy-MM-dd', timezone:'America/Los_Angeles')
        ```
      </Collapser>

      <Collapser
        title={<>Traduzir um timestamp usando o fuso horário na cláusula <InlineCode>
          WITH TIMEZONE
        </InlineCode></>
        }
      >
        A consulta a seguir traduz o atributo `timestampValue` usando o fuso horário fornecido na cláusula `WITH TIMEZONE` . Isso retornará a string de data e hora `1969-12-31`.

        ```sql
        WITH 1234567 AS timestampValue SELECT toDatetime(timestampValue, 'yyyy-MM-dd') FROM Event WITH TIMEZONE 'America/Los_Angeles'
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-toTimestamp"
    title={<InlineCode>toTimestamp(datestring[, pattern [, timezone]])</InlineCode>
    }
  >
    Use a função `toTimestamp()` para analisar um timestamp em milissegundos de época a partir de uma string de data e hora.

    `toTimestamp()` recebe os seguintes argumentos:

    * `datestring` - Uma sequência de data e hora a ser traduzida em um timestamp (milissegundos de época). Pode ser um atributo de string ou uma string literal entre aspas.
    * `pattern` - Um padrão de data e hora opcional usado para analisar o parâmetro datestring. Consulte a seção *Padrões de formatação e análise* na [documentação do DatetimeFormatter](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html) para saber como construir uma sequência de padrões.
      * Este deve ser um valor de string constante e terá como padrão `yyyy-MM-dd'T'HH:mm:ss[.SSS][XXX]` se um padrão não for fornecido.
    * `timezone` - Um valor de fuso horário opcional que é usado para interpretar o parâmetro datestring (ex. PST).
      * Deve ser um valor de string constante e o padrão será UTC ou o valor fornecido em `WITH TIMEZONE` , se disponível.

    Alias: `fromDatetime()` é um nome alternativo para a função `toTimestamp()` .

    <Callout variant="tip">
      Se a string encontrada não corresponder ao padrão fornecido, ela retornará `null`. Se você tiver strings de data e hora em vários padrões, poderá unir os resultados usando `OR` para cascata até que um dos valores não seja nulo. Você também pode usar segmentos de padrão opcionais. O padrão padrão usa colchetes para tornar opcionais os milissegundos e as partes de deslocamento de zona.
    </Callout>

    <CollapserGroup>
      <Collapser id="partial-datetime-interpretation" title="Interpretação parcial de data e hora ao analisar strings de data e hora">
        <table>
          <thead>
            <tr>
              <th>
                Cenário
              </th>

              <th>
                Detalhe
              </th>

              <th>
                Padrão de amostra
              </th>

              <th>
                Exemplo de data e hora
              </th>

              <th>
                Resolve
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                Fuso horário ausente
              </td>

              <td>
                Usará o argumento de fuso horário ou o valor `WITH TIMEZONE` . O padrão é `UTC`.
              </td>

              <td>
                aaaa-MM-dd HH:mm:ss.SSS
              </td>

              <td>
                18/10/2023 15:27:03.123
              </td>

              <td>
                2023-10-18T15:27:03.123Z
              </td>
            </tr>

            <tr>
              <td rowspan="8">
                Campo de data e hora ausente
              </td>

              <td rowspan="8">
                Qualquer campo de hora ausente será substituído por 0. Qualquer campo de data ausente será substituído por 1. Se um campo estiver presente, todos os campos de precedência mais alta também deverão estar presentes.<br /> Nota: Os padrões de dia do ano e trimestre do ano são suportados.
              </td>

              <td>
                aaaa-MM-dd HH:mm:ss
              </td>

              <td>
                18/10/2023 15:27:03
              </td>

              <td>
                2023-10-18T15:27:03.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-dd HH:mm
              </td>

              <td>
                18/10/2023 15:27
              </td>

              <td>
                2023-10-18T15:27:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-dd HH
              </td>

              <td>
                2023-10-18 15
              </td>

              <td>
                2023-10-18T15:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-dd
              </td>

              <td>
                18/10/2023
              </td>

              <td>
                2023-10-18T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa &apos;dia&apos; D
              </td>

              <td>
                2023 dia 291
              </td>

              <td>
                2023-10-18T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM
              </td>

              <td>
                2023-10
              </td>

              <td>
                2023-10-01T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa qqq
              </td>

              <td>
                4º trimestre de 2023
              </td>

              <td>
                2023-10-01T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa
              </td>

              <td>
                2023
              </td>

              <td>
                2023-01-01T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td rowspan="3">
                Apenas tempo
              </td>

              <td rowspan="3">
                Se um padrão de tempo for usado sem data, o timestamp Unix em milissegundos será calculado.<br /> Nota: O ajuste de fuso horário ainda é respeitado.
              </td>

              <td>
                HH:mm
              </td>

              <td>
                00:30
              </td>

              <td>
                1971-01-01T00:30:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                HH: mm O
              </td>

              <td>
                00:30 GMT-1
              </td>

              <td>
                1971-01-01T01:30:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                HH: mm O
              </td>

              <td>
                00:30 GMT+1
              </td>

              <td>
                31-12-1969T23:30:00.000Z
              </td>
            </tr>

            <tr>
              <td rowspan="3">
                horário de 12 horas
              </td>

              <td rowspan="3">
                Se um padrão de 12 horas (h minúsculo) for usado, então o padrão am-pm-of-day (a) também deverá ser usado.<br /> Nota: Dentro da string de data e hora, AM/PM deve estar em letras maiúsculas.
              </td>

              <td>
                aaaa-MM-dd h:mm a
              </td>

              <td>
                18/10/2023 15:27
              </td>

              <td>
                2023-10-18T15:27:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-dd h:mm
              </td>

              <td>
                18/10/2023 3:27
              </td>

              <td>
                Padrão não suportado
              </td>
            </tr>

            <tr>
              <td>
                aaaa-MM-dd h:mm a
              </td>

              <td>
                18/10/2023 15h27
              </td>

              <td>
                nulo (devido ao pm minúsculo)
              </td>
            </tr>

            <tr>
              <td>
                Precedência de campo
              </td>

              <td>
                Se um campo estiver presente, todos os campos de precedência mais alta também deverão estar presentes.
              </td>

              <td>
                aaaa dd
              </td>

              <td>
                2023 18
              </td>

              <td>
                Padrão não suportado (dd é o dia do mês e o mês está faltando)
              </td>
            </tr>
          </tbody>
        </table>
      </Collapser>
    </CollapserGroup>

    Exemplos:

    <CollapserGroup>
      <Collapser title="Analise uma string de data e hora usando o padrão padrão">
        A consulta a seguir analisa a string de data e hora &apos;2023-10-18T15:27:03.123Z&apos; usando o padrão padrão de `yyyy-MM-dd'T'HH:mm:ss[.SSS][XXX]`. Isso retorna o valor do timestamp `1697642823123`.

        ```sql
        SELECT toTimestamp('2023-10-18T15:27:03.123Z') 
        FROM Event
        ```
      </Collapser>

      <Collapser title="Analisar uma string de data e hora usando o parâmetro fuso horário">
        A consulta a seguir analisa a string de data e hora &apos;2023-11-03 11:00:32&apos; com o fuso horário definido como &apos;América/Los\_Angeles&apos;. Isso retorna o valor do timestamp `1699034432000`.

        ```sql
        SELECT toTimestamp('2023-11-03 11:00:32', 'yyyy-MM-dd HH:mm:ss', timezone:'America/Los_Angeles') 
        FROM Event
        ```
      </Collapser>

      <Collapser
        title={<>Analisar uma string de data e hora usando o fuso horário na cláusula <InlineCode>
          WITH TIMEZONE
        </InlineCode></>
        }
      >
        A consulta a seguir analisa a string de data e hora &apos;2023-11-03 11:00:32&apos; com o fuso horário fornecido na cláusula `WITH TIMEZONE` . Isso retorna o valor do timestamp `1699034432000`.

        ```sql
        SELECT toTimestamp('2023-11-03 11:00:32', 'yyyy-MM-dd HH:mm:ss') 
        FROM Event WITH TIMEZONE 'America/Los_Angeles'
        ```
      </Collapser>
    </CollapserGroup>

    <Callout variant="important">
      A interface detectará automaticamente o valor `toTimestamp()` como um timestamp e o formatará como um valor de data e hora. Para exibir o timestamp numérico real, envolva a função `toTimestamp()` em uma função `string()`.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-upper"
    title={<InlineCode>upper(str)</InlineCode>
    }
  >
    Use a função `upper()` para alterar todos os caracteres alfabéticos de um valor de string para letras maiúsculas.

    Argumentos:

    * `str` - O valor da string deve ser maiúsculo

    * Pode ser qualquer coisa avaliada como uma string, incluindo uma string literal entre aspas, uma string de consulta atributo, uma função que retorna uma string ou até mesmo uma subconsulta que retorna um único valor de string.

    * Se esse argumento for avaliado como nulo, a função `upper()` retornará nulo.

      <CollapserGroup>
        <Collapser title="Uma string em maiúscula">
          Esta consulta demonstra o uso da função `upper()` em diversas partes de uma consulta.

          ```sql
          FROM PageAction
          SELECT latest(upper(actionName))
          WHERE upper(actionName) = upper('acmePageRenderedEvent') OR upper(actionName) = upper('SubmitLogin')
          FACET concat(actionName, ':', upper(actionName))
          ```

          <img title="screenshot upper()" alt="screenshot upper()" src="/images/upperExample.webp" />

          <figcaption>
            <InlineCode>
              upper(str)
            </InlineCode> exemplo
          </figcaption>
        </Collapser>
      </CollapserGroup>

      *Função relacionada: [<InlineCode>
        lower()
      </InlineCode>](#func-lower)*
  </Collapser>
</CollapserGroup>

## Conversão de tipo [#type-conversion]

NRQL não suporta “coerção”. Isso significa que um float armazenado como uma string é tratado como uma string e não pode ser operado por funções que esperam valores float .

Você pode converter uma string com um valor numérico ou um booleano com um valor de string em seus equivalentes numéricos e booleanos, ou converter um valor que não seja de string em um valor de string, com estas funções:

* Use a função `numeric()` para converter um número com formato de string em um valor numérico. A função pode ser incorporada em uma consulta que usa funções matemáticas em resultados de consulta ou funções agregadoras NRQL , como `average()`. Observe que se o valor NRQL estiver no [formato de medidor](/docs/data-apis/understand-data/metric-data/metric-data-type/), então `numeric()` não funcionará nele. Em vez disso, você deve usar uma destas funções de consulta compatíveis:
* `latest()`
* `min()`
* `max()`
* `sum()`
* `count()`
* `average()`
* Use a função `boolean()` para converter um valor de string `"true"` ou `"false"` no valor booleano correspondente.
* Use a função `string()` para converter um valor numérico, booleano, de tupla ou de matriz em um valor de string. Consulte [`string()`](#func-string) acima para obter mais informações.

## Comentários [#comments]

Ao escrever uma consulta NRQL, você pode adicionar comentários, o que pode ajudar os membros da sua equipe a entender e usar melhor a consulta.

Aqui estão os detalhes da sintaxe:

* `--` Dois traços comentarão todo o texto à direita deste indicador na mesma linha.
* `//` Duas barras comentarão todo o texto à direita deste indicador na mesma linha.
* `/* */` Qualquer texto entre esses conjuntos de caracteres será comentado. Este indicador pode ser aplicado a várias linhas.

Observe que os comentários não são exibidos em todos os lugares. Algumas visualizações, como “consulta recente” e “visualizar consulta”, não mostrarão comentários.

Alguns exemplos de consultas que incluem comentários:

```sql
FROM Transaction SELECT uniqueCount(appId) -- This will return the number of unique App IDs
```

```sql
FROM TransactionError
SELECT count(*) SINCE 1 day ago // Transaction Error for the past day
```

```sql
FROM TransactionTrace /* This data may be incomplete;
If so, run a query of Transaction */
SELECT count(*)
```

## Documentos relacionados [#related-docs]

Outros recursos populares para compreender a sintaxe e as regras do NRQL incluem:

* [Curso instrucional NRQL](https://learn.newrelic.com/writing-nrql-queries) da New Relic University
* [Aprenda como consultar o tipo de dados `Metric`](/docs/telemetry-data-platform/get-data/apis/query-metric-data-type)
* [Usar subconsultas](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql)
* [Use funis para avaliar uma série de dados relacionados](/docs/insights/new-relic-insights/features/funnels)