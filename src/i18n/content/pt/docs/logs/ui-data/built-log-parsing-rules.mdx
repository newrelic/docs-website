---
title: Regras de análise de log integradas
tags:
  - Logs
  - Log management
  - UI and data
metaDescription: 'A list of all New Relic''s log parsing rules, which you can use to easily parse common log formats.'
freshnessValidatedDate: never
translationType: machine
---

O New Relic pode analisar formatos de log comuns de acordo com regras integradas, para que você não precise criar suas próprias regras de análise. Aqui estão as regras de análise de log, seus padrões [Grok](https://github.com/thekrakken/java-grok/tree/master/src/main/resources/patterns) e quais campos são analisados.

* Para ativar a análise de log integrada, consulte nossa documentação para [adicionar o `logtype` atributo](/docs/logs/ui-data/parsing#logtype).
* Para gerenciar suas regras de análise de forma programática, use NerdGraph, nossa API no formato GraphQL, em [api.newrelic.com/graphiql](https://api.newrelic.com/graphiql). Para obter mais informações, consulte o [tutorial do NerdGraph](/docs/apis/nerdgraph/examples/nerdgraph-log-parsing-rules-tutorial) para criar, consultar e excluir suas regras de análise.

<CollapserGroup>
  <Collapser
    id="apache"
    title="Apache"
  >
    <DNT>**Source:**</DNT> `logtype = 'apache'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `clientip`: O endereço IP do cliente.
    * `verb`: O verbo HTTP
    * `ident`: A identidade do usuário do cliente que faz a solicitação
    * `response`: o código de status HTTP da resposta
    * `request`: O URI e a solicitação que está sendo feita
    * `httpversion`: a versão HTTP da solicitação
    * `rawrequest`: a solicitação HTTP bruta se os dados forem postados
    * `bytes`: O número de bytes enviados
    * `referrer`: O referenciador HTTP
    * `agent`: o agente do usuário do cliente
  </Collapser>

  <Collapser
    id="apache_error"
    title="Erro Apache"
  >
    <DNT>**Source:**</DNT> `logtype = 'apache_error'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    \[%{DATA:apache_error.timestamp}\] \[%{WORD:apache_error.source}:%{DATA:level}\] \[pid %{NUMBER:apache_error.pid}(:tid %{NUMBER:apache_error.tid})?\] (%{DATA:apache_error.sourcecode}\(%{NUMBER:apache_error.linenum}\): )?(?:\[client %{IPORHOST:apache_error.clientip}:%{POSINT:apache_error.port}\] ){0,1}%{GREEDYDATA:apache_error.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `apache_error.timestamp`: o timestamp da instrução de log
    * `apache_error.source`: O módulo de origem
    * `level`: O nível de log
    * `apache_error.pid`: O PID do Apache (identificador de processo)
    * `apache_error.tid`: O TID do Apache (identificador de thread)
    * `apache_error.sourcecode`: O código-fonte do Apache
    * `apache_error.linenum`: O número da linha do código-fonte
    * `apache_error.clientip`: O endereço IP do cliente
    * `apache_error.port`: O número da porta IP do cliente
    * `apache_error.message`: A mensagem de erro
  </Collapser>

  <Collapser
    id="application-load-balancer"
    title="Aplicativo Balanceador de carga"
  >
    <DNT>**Source:**</DNT> `logtype = 'alb'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} "%{DATA:request}" "%{DATA:user_agent}" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} "%{DATA:trace_id}" "%{NOTSPACE:domain_name}" "%{NOTSPACE:chosen_cert_arn}" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} "%{NOTSPACE:actions_executed}" "%{NOTSPACE:redirect_url}" "%{NOTSPACE:error_reason}" (?:"|)%{DATA:target_port_list}(?:"|) (?:"|)%{DATA:target_status_code_list}(?:"|) "%{NOTSPACE:classification}" "%{NOTSPACE:classification_reason}"
    ```

    <DNT>
      **Results:**
    </DNT>

    <table>
      <thead>
        <tr>
          <th style={{ width: "250px" }}>
            Campo
          </th>

          <th>
            Definição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `type`
          </td>

          <td>
            O tipo de solicitação ou conexão. Os valores possíveis são:

            * `http`:HTTP
            * `https`: HTTP sobre SSL/TLS
            * `h2`: HTTP/2 sobre SSL/TLS
            * `ws`: WebSockets
            * `wss`: WebSockets sobre SSL/TLS
          </td>
        </tr>

        <tr>
          <td>
            `elb`
          </td>

          <td>
            O ID do recurso do balanceador de carga. Se você estiver analisando entradas de log de acesso, observe que os IDs de recursos podem conter barras (`/`).
          </td>
        </tr>

        <tr>
          <td>
            `client_ip`
          </td>

          <td>
            O endereço IP do cliente solicitante
          </td>
        </tr>

        <tr>
          <td>
            `client_port`
          </td>

          <td>
            A porta IP do cliente solicitante
          </td>
        </tr>

        <tr>
          <td>
            `target_ip`
          </td>

          <td>
            O endereço IP do destino que processou esta solicitação.

            * Se o cliente não enviou uma solicitação completa, o balanceador de carga não poderá despachar a solicitação para um destino e esse valor será definido como `-`.
            * Se o destino for uma função do Lambda, esse valor será definido como `-`.
            * Se a solicitação for bloqueada pelo AWS WAF, esse valor será definido como `-` e o valor de `elb_status_code` será definido como `403`.
          </td>
        </tr>

        <tr>
          <td>
            `target_port`
          </td>

          <td>
            A porta IP do destino que processou esta solicitação.

            * Se o cliente não enviou uma solicitação completa, o balanceador de carga não poderá despachar a solicitação para um destino e esse valor será definido como `-`.
            * Se o destino for uma função do Lambda, esse valor será definido como `-`.
            * Se a solicitação for bloqueada pelo AWS WAF, esse valor será definido como `-` e o valor de `elb_status_code` será definido como `403`.
          </td>
        </tr>

        <tr>
          <td>
            `target_port_list`
          </td>

          <td>
            O endereço IP e a porta do destino que processou esta solicitação.

            * Se o cliente não enviou uma solicitação completa, o balanceador de carga não poderá despachar a solicitação para um destino e esse valor será definido como `-`.
            * Se o destino for uma função do Lambda, esse valor será definido como `-`.
            * Se a solicitação for bloqueada pelo AWS WAF, esse valor será definido como `-` e o valor de `elb_status_code` será definido como `403`.
          </td>
        </tr>

        <tr>
          <td>
            `request_processing_time`
          </td>

          <td>
            O tempo total decorrido (em segundos, com precisão de milissegundos) desde o momento em que o balanceador de carga recebeu a solicitação até o momento em que a enviou a um destino.

            * Esse valor será definido como `-1` se o balanceador de carga não puder despachar a solicitação para um destino. Isso pode acontecer se o destino fechar a conexão antes do tempo limite de inatividade ou se o cliente enviar uma solicitação malformada.
            * Esse valor também poderá ser definido como `-1` se o destino registrado não responder antes do tempo limite de inatividade.
          </td>
        </tr>

        <tr>
          <td>
            `target_processing_time`
          </td>

          <td>
            O tempo total decorrido (em segundos, com precisão de milissegundos) desde o momento em que o balanceador de carga enviou a solicitação a um destino até o destino começar a enviar os cabeçalhos de resposta.

            * Esse valor será definido como `-1` se o balanceador de carga não puder despachar a solicitação para um destino. Isso pode acontecer se o destino fechar a conexão antes do tempo limite de inatividade ou se o cliente enviar uma solicitação malformada.
            * Esse valor também poderá ser definido como `-1` se o destino registrado não responder antes do tempo limite de inatividade.
          </td>
        </tr>

        <tr>
          <td>
            `response_processing_time`
          </td>

          <td>
            O tempo total decorrido (em segundos, com precisão de milissegundos) desde o momento em que o balanceador de carga recebeu o cabeçalho de resposta do destino até começar a enviar a resposta ao cliente. Isso inclui o tempo de fila no balanceador de carga e o tempo de aquisição de conexão do balanceador de carga para o cliente.

            Esse valor será definido como `-1` se o balanceador de carga não puder enviar a solicitação a um destino. Isso pode acontecer se o destino fechar a conexão antes do tempo limite de inatividade ou se o cliente enviar uma solicitação malformada.
          </td>
        </tr>

        <tr>
          <td>
            `elb_status_code`
          </td>

          <td>
            O código de status da resposta do balanceador de carga
          </td>
        </tr>

        <tr>
          <td>
            `target_status_code_list`
          </td>

          <td>
            O código de status da resposta do destino. Este valor será registrado somente se uma conexão tiver sido estabelecida com o destino e o destino tiver enviado uma resposta. Caso contrário, será definido como `-`.
          </td>
        </tr>

        <tr>
          <td>
            `received_bytes`
          </td>

          <td>
            O tamanho da solicitação, em bytes, recebida do cliente (solicitante). Para solicitações HTTP, isso inclui os cabeçalhos. Para WebSockets, este é o número total de bytes recebidos do cliente na conexão.
          </td>
        </tr>

        <tr>
          <td>
            `sent_bytes`
          </td>

          <td>
            O tamanho da resposta, em bytes, enviada ao cliente (solicitante). Para solicitações HTTP, isso inclui os cabeçalhos. Para WebSockets, este é o número total de bytes enviados ao cliente na conexão.
          </td>
        </tr>

        <tr>
          <td>
            `request`
          </td>

          <td>
            A solicitação HTTP
          </td>
        </tr>

        <tr>
          <td>
            `user_agent`
          </td>

          <td>
            String usuário-agente que identifica o cliente que originou a solicitação, entre aspas duplas. A string consiste em um ou mais identificadores de produto, produto/versão. Se a sequência tiver mais de 8 KB, ela será truncada.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            A cifra SSL. Esse valor será definido como `-` se o ouvinte não for um ouvinte HTTPS.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            O protocolo SSL. Esse valor será definido como `-` se o ouvinte não for um ouvinte HTTPS.
          </td>
        </tr>

        <tr>
          <td>
            `target_group_arn`
          </td>

          <td>
            O nome de recurso da Amazon (ARN) do grupo de destino
          </td>
        </tr>

        <tr>
          <td>
            `trace_id`
          </td>

          <td>
            O conteúdo de `X-Amzn-Trace-Id header`, entre aspas duplas
          </td>
        </tr>

        <tr>
          <td>
            `domain_name`
          </td>

          <td>
            O domínio SNI fornecido pelo cliente durante o handshake TLS, entre aspas duplas. Esse valor será definido como `-` se o cliente não suportar SNI ou se o domínio não corresponder a um certificado e o certificado padrão for apresentado ao cliente.
          </td>
        </tr>

        <tr>
          <td>
            `chosen_cert_arn`
          </td>

          <td>
            O ARN do certificado apresentado ao cliente, entre aspas duplas.

            * Defina como `session-reused` se a sessão for reutilizada.
            * Defina como `-` se o ouvinte não for um ouvinte HTTPS.
          </td>
        </tr>

        <tr>
          <td>
            `matched_rule_priority`
          </td>

          <td>
            O valor de prioridade da regra que correspondeu à solicitação.

            * Se uma regra corresponder, este será um valor de `1` a `50000`.
            * Se nenhuma regra corresponder e a ação padrão tiver sido executada, esse valor será definido como `0`.
            * Se ocorrer um erro durante a avaliação das regras, ele será definido como `-1`.
            * Para qualquer outro erro, é definido como `-`.
          </td>
        </tr>

        <tr>
          <td>
            `request_creation_time`
          </td>

          <td>
            A hora em que o balanceador de carga recebeu a solicitação do cliente, no formato ISO 8601.
          </td>
        </tr>

        <tr>
          <td>
            `actions_executed`
          </td>

          <td>
            As ações tomadas ao processar a solicitação, entre aspas duplas. Este valor é uma lista separada por vírgulas que pode incluir os valores descritos em `actions_taken`. Se nenhuma ação for tomada, como para uma solicitação malformada, esse valor será definido como `-`.
          </td>
        </tr>

        <tr>
          <td>
            `redirect_url`
          </td>

          <td>
            A URL do destino de redirecionamento para o cabeçalho de localização da resposta HTTP, entre aspas duplas. Se nenhuma ação de redirecionamento tiver sido executada, esse valor será definido como `-`.
          </td>
        </tr>

        <tr>
          <td>
            `error_reason`
          </td>

          <td>
            O código do motivo do erro, entre aspas duplas.

            * Se a solicitação falhar, este será um dos códigos de erro descritos em Códigos de Motivo do Erro.
            * Se as ações executadas não incluírem uma ação de autenticação ou o destino não for uma função do Lambda, esse valor será definido como `-`.
          </td>
        </tr>

        <tr>
          <td>
            `classification`
          </td>

          <td>
            Classificação.
          </td>
        </tr>

        <tr>
          <td>
            `classification_reason`
          </td>

          <td>
            O motivo da classificação.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="cassandra"
    title="Cassandra"
  >
    Fonte: `logtype = 'cassandra'`

    Grok

    ```grok
    %{WORD:level}%{SPACE}\\[%{NOTSPACE:cassandra.thread}\\] %{TIMESTAMP_ISO8601:cassandra.timestamp} %{NOTSPACE:cassandra.source}:%{INT:cassandra.line.number} - %{GREEDYDATA:cassandra.message}
    ```

    ### Resultados

    * `level`: O nível de log da mensagem (all, trace, debug, info, warning, error, off)
    * `cassandra.thread`: o nome do thread que emite a instrução de log
    * `cassandra.timestamp`: o timestamp da instrução de log
    * `cassandra.source`: O nome do arquivo de origem
    * `cassandra.line.number`: O número da linha da mensagem
    * `cassandra.message`: A mensagem cassandra bruta
  </Collapser>

  <Collapser
    id="cloudfront"
    title="CloudFront (registro padrão)"
  >
    <DNT>**Source:**</DNT> `logtype = 'cloudfront-web'`

    <DNT>
      **Grok:**
    </DNT>

    ```
    ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end}
    ```

    <DNT>
      **Results:**
    </DNT>

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Campo
          </th>

          <th>
            Definição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            O ponto de presença que atendeu a solicitação. Cada ponto de presença é identificado por um código de três letras e um número atribuído arbitrariamente; por exemplo, `DFW3`.

            O código de três letras normalmente corresponde ao código de aeroporto da Associação Internacional de Transporte Aéreo para um aeroporto próximo ao ponto de presença. (Essas abreviações podem mudar no futuro.)
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            O número total de bytes que o CloudFront serviu ao visualizador em resposta à solicitação, incluindo cabeçalhos; por exemplo, `1045619`. Para conexões WebSocket, esse é o número total de bytes enviados do servidor para o cliente por meio da conexão.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            O endereço IP do visualizador que fez a solicitação, no formato IPv4 ou IPv6. Se o visualizador usou um proxy HTTP ou um balanceador de carga para enviar a solicitação, o valor de `c_ip` será o endereço IP do proxy ou do balanceador de carga. Consulte também `X-Forwarded-For`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            O método de solicitação HTTP&#x3A; `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST` ou `PUT`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            O nome de domínio da distribuição do CloudFront; por exemplo, `d111111abcdef8.cloudfront.net`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            A parte do URI que identifica o caminho e o objeto; por exemplo, `/images/cat.jpg`. Pontos de interrogação em URLs e strings de consulta não são incluídos.
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            Um código de status HTTP; por exemplo, `200`. O código de status `000` indica que o visualizador fechou a conexão (por exemplo, fechou a guia do Browser) antes que o CloudFront pudesse responder a uma solicitação. Se o visualizador fechar a conexão depois que o CloudFront começar a enviar a resposta, o log conterá o código de status HTTP aplicável.
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            O nome do domínio que originou a solicitação. Os referenciadores comuns incluem mecanismos de pesquisa, outros sites com links diretos para seus objetos e seu próprio site.
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            O valor do cabeçalho usuário-agente na solicitação. O cabeçalho usuário-agente identifica a origem da solicitação, como o tipo de dispositivo e Browser que enviou a solicitação e qual mecanismo de busca, se aplicável.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            A parte da string de consulta do URI, se houver. Quando um URI não contém uma string de consulta, o valor deste campo é um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            O cabeçalho do cookie na solicitação, incluindo pares nome-valor e o atributo associado.

            * Se você ativar o registro de cookies, o CloudFront registrará os cookies em todas as solicitações, independentemente de quais cookies você escolher encaminhar para a origem.
            * Se uma solicitação não incluir um cabeçalho de cookie, o valor deste campo será um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            Como o CloudFront classifica a resposta após o último byte sair do ponto de presença. Em alguns casos, o tipo de resultado pode mudar entre o momento em que o CloudFront está pronto para enviar a resposta e o momento em que o CloudFront termina de enviar a resposta.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            Uma string criptografada que identifica exclusivamente uma solicitação. No cabeçalho da resposta, é `x-amz-cf-id`.
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            O valor que o visualizador incluiu no cabeçalho Host dessa solicitação. Este é o nome de domínio na solicitação.

            * Se você estiver usando o nome de domínio do CloudFront nos URLs do objeto, esse campo conterá esse nome de domínio.
            * Se você estiver usando nomes de domínio alternativos em seus URLs de objeto, como `http://example.com/logo.png`, este campo conterá o nome de domínio alternativo, como `example.com`. Para usar nomes de domínio alternativos, você deve adicioná-los à sua distribuição.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            O protocolo que o visualizador especificou na solicitação: `http`, `https`, `ws` ou `wss`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            O número de bytes de dados que o visualizador incluiu na solicitação, incluindo cabeçalhos. Para conexões WebSocket, esse é o número total de bytes enviados do cliente para o servidor na conexão.
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            O número de segundos (até o milésimo de segundo; por exemplo, 0,002) entre o momento em que um servidor de borda do CloudFront recebe uma solicitação do visualizador e o momento em que o CloudFront grava o último byte da resposta na fila de saída do servidor de borda, conforme medido em o servidor.

            Da perspectiva do visualizador, o tempo total para obter o objeto completo será maior que esse valor devido à latência da rede e ao buffer TCP.
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            Se o visualizador usou um proxy HTTP ou um balanceador de carga para enviar a solicitação, o valor de `c_ip` no campo 5 será o endereço IP do proxy ou do balanceador de carga. Nesse caso, este campo é o endereço IP do visualizador que originou a solicitação.

            Este campo contém endereços IPv4 e IPv6 conforme aplicável. Se o visualizador não usou um proxy HTTP ou um balanceador de carga, o valor de `x_forwarded_for` será um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            Quando `cs_protocol` no campo 17 é `https`, esse campo contém o protocolo SSL/TLS que o cliente e o CloudFront negociaram para transmitir a solicitação e a resposta. Os valores possíveis incluem:

            * SSLv3

            * TLSv1

            * TLSv1.1

            * TLSv1.2

              Quando `cs_protocol` no campo 17 for `http`, o valor desse campo será um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            Quando `cs_protocol` no campo 17 for `https`, esse campo conterá a cifra SSL/TLS que o cliente e o CloudFront negociaram para criptografar a solicitação e a resposta. Os valores possíveis incluem:

            * `ECDHE-RSA-AES128-GCM-SHA256`

            * `ECDHE-RSA-AES128-SHA256`

            * `ECDHE-RSA-AES128-SHA`

            * `ECDHE-RSA-AES256-GCM-SHA384`

            * `ECDHE-RSA-AES256-SHA384`

            * `ECDHE-RSA-AES256-SHA`

            * `AES128-GCM-SHA256`

            * `AES256-GCM-SHA384`

            * `AES128-SHA256`

            * `AES256-SHA`

            * `AES128-SHA`

            * `DES-CBC3-SHA`

            * `RC4-MD5`

              Quando `cs_protocol` no campo 17 for `http`, o valor desse campo será um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            Como o CloudFront classificou a resposta antes de retorná-la ao visualizador. Os valores possíveis incluem:

            * `Hit`: o CloudFront entregou o objeto ao visualizador a partir do cache de borda.
            * `RefreshHit`: o CloudFront encontrou o objeto no cache de borda, mas ele havia expirado, então o CloudFront entrou em contato com a origem para verificar se o cache tem a versão mais recente do objeto.
            * `Miss`: a solicitação não pôde ser atendida por um objeto no cache de borda, então o CloudFront encaminhou a solicitação para o servidor de origem e retornou o resultado ao visualizador.
            * `LimitExceeded`: a solicitação foi negada porque um limite do CloudFront foi excedido.
            * `CapacityExceeded`: o CloudFront retornou um erro `503` porque o ponto de presença não tinha capacidade suficiente no momento da solicitação para atender o objeto.
            * `Error`: normalmente, isso significa que a solicitação resultou em um erro do cliente (`sc_status` é `4xx`) ou um erro do servidor (`sc_status` é `5xx`). Se o valor de `x_edge_result_type` for `Error` e o valor deste campo **não** for `Error`, o cliente se desconectou antes de finalizar o download.
            * `Redirect`: o CloudFront redireciona de HTTP para HTTPS. Se `sc_status` for `403` e você tiver configurado o CloudFront para restringir a distribuição geográfica do seu conteúdo, a solicitação poderá ter vindo de um local restrito.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            A versão HTTP que o visualizador especificou na solicitação. Os valores possíveis incluem:

            * `HTTP/0.9`
            * `HTTP/1.0`
            * `HTTP/1.1`
            * `HTTP/2.0`
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            Quando a criptografia em nível de campo é configurada para uma distribuição, esse campo contém um código que indica se o corpo da solicitação foi processado com êxito.

            Se a criptografia em nível de campo não estiver configurada para a distribuição, o valor será um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `fle-encrypted-fields`
          </td>

          <td>
            O número de campos que o CloudFront criptografou e encaminhou para a origem. O CloudFront transmite a solicitação processada para a origem enquanto criptografa os dados, portanto, `fle-encrypted-fields` pode ter um valor mesmo que o valor de `fle-status` seja um erro.

            Se a criptografia em nível de campo não estiver configurada para a distribuição, o valor de `fle-encrypted-fields` será um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            O número da porta da solicitação do visualizador.
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            O número de segundos entre o recebimento da solicitação e a gravação do primeiro byte da resposta, conforme medido no servidor.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            Quando `x-edge-result-type` <DNT>**is not**</DNT> `Error`, este campo contém o mesmo valor que `x-edge-result-type`. Quando `x-edge-result-type` <DNT>**is**</DNT> `Error`, este campo contém o tipo específico de erro.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            O valor do cabeçalho HTTP Content-Type da resposta.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            O valor do cabeçalho HTTP Content-Length da resposta.
          </td>
        </tr>

        <tr>
          <td>
            `sc_range_start`
          </td>

          <td>
            Quando a resposta contém o cabeçalho HTTP Content-Range, este campo contém o valor inicial do intervalo.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            Quando a resposta contém o cabeçalho HTTP Content-Range, este campo contém o valor final do intervalo.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="cloudfront-rtl"
    title="CloudFront (registro de tempo real)"
  >
    <DNT>**Source:**</DNT> `logtype = 'cloudfront-rtl'`

    <DNT>
      **Grok:**
    </DNT>

    ```
    ^%{NOTSPACE:timestamp}.\d{3}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:cs_ip_version}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_cookie}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:c_country}%{SPACE}%{NOTSPACE:cs_accept_encoding}%{SPACE}%{NOTSPACE:cs_accept}%{SPACE}%{NOTSPACE:cache_behavior_path_pattern}%{SPACE}%{NOTSPACE:cs_headers}%{SPACE}%{NOTSPACE:cs_header_names}%{SPACE}%{NOTSPACE:cs_headers_count}$
    ```

    <DNT>
      **Results:**
    </DNT>

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Campo
          </th>

          <th>
            Definição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `timestamp`
          </td>

          <td>
            A data e hora em que o servidor de borda terminou de responder à solicitação.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            O endereço IP do visualizador que fez a solicitação, por exemplo, `192.0.2.183` ou `2001:0db8:85a3:0000:0000:8a2e:0370:7334`. Se o visualizador usou um proxy HTTP ou um balanceador de carga para enviar a solicitação, o valor desse campo será o endereço IP do proxy ou do balanceador de carga. Consulte também o campo `x-forwarded-for` .
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            O número de segundos entre o recebimento da solicitação e a gravação do primeiro byte da resposta, conforme medido no servidor.
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            Um código de status HTTP; por exemplo, `200`. O código de status `000` indica que o visualizador fechou a conexão (por exemplo, fechou a guia do Browser) antes que o CloudFront pudesse responder a uma solicitação. Se o visualizador fechar a conexão depois que o CloudFront começar a enviar a resposta, o log conterá o código de status HTTP aplicável.
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            O número total de bytes que o servidor enviou ao visualizador em resposta à solicitação, incluindo cabeçalhos. Para conexões WebSocket, esse é o número total de bytes enviados do servidor para o cliente por meio da conexão.
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            O método de solicitação HTTP recebido do visualizador.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            O protocolo da solicitação do visualizador (http, https, ws ou wss).
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            O valor que o visualizador incluiu no cabeçalho Host da solicitação. Se você estiver usando o nome de domínio do CloudFront nos URLs do objeto (como d111111abcdef8.cloudfront.net), este campo contém esse nome de domínio. Se você estiver usando nomes de domínio alternativos (CNAMEs) nos URLs de seus objetos (como [www.example.com](http://www.example.com)), este campo contém o nome de domínio alternativo.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            O URL de solicitação completo, incluindo a string de consulta (se existir), mas sem o nome de domínio. Por exemplo, `/images/cat.webp?mobile=true`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            O número total de bytes de dados que o visualizador incluiu na solicitação, incluindo cabeçalhos. Para conexões WebSocket, esse é o número total de bytes enviados do cliente para o servidor na conexão.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            O ponto de presença que atendeu a solicitação. Cada ponto de presença é identificado por um código de três letras e um número atribuído arbitrariamente (por exemplo, DFW3). O código de três letras normalmente corresponde ao código do aeroporto da Associação Internacional de Transporte Aéreo (IATA) para um aeroporto próximo à localização geográfica do ponto de presença. (Essas abreviações podem mudar no futuro.)
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            Como o CloudFront classifica a resposta após o último byte sair do ponto de presença. Em alguns casos, o tipo de resultado pode mudar entre o momento em que o CloudFront está pronto para enviar a resposta e o momento em que o CloudFront termina de enviar a resposta.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            Uma string opaca que identifica exclusivamente uma solicitação. O CloudFront também envia essa string no cabeçalho de resposta x-amz-cf-id.
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            O nome de domínio da distribuição do CloudFront (por exemplo, `d111111abcdef8.cloudfront.net`).
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            O número de segundos (até o milésimo de segundo, por exemplo, 0,082) desde o momento em que o servidor recebe a solicitação do visualizador até o momento em que o servidor grava o último byte da resposta na fila de saída, conforme medido no servidor. Da perspectiva do visualizador, o tempo total para obter a resposta completa será maior que esse valor devido à latência da rede e ao buffer TCP.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            A versão HTTP que o visualizador especificou na solicitação. Os valores possíveis incluem `HTTP/0.9`, `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0` e `HTTP/3.0`.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip_version`
          </td>

          <td>
            A versão IP da solicitação (IPv4 ou IPv6).
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            O valor do cabeçalho usuário-agente na solicitação. O cabeçalho usuário-agente identifica a origem da solicitação, como o tipo de dispositivo e Browser que enviou a solicitação ou, se a solicitação veio de um mecanismo de busca, qual mecanismo de busca.
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            O valor do cabeçalho Referer na solicitação. Este é o nome do domínio que originou a solicitação. Os referenciadores comuns incluem mecanismos de pesquisa, outros sites com links diretos para seus objetos e seu próprio site.
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            O cabeçalho Cookie na solicitação, incluindo pares nome-valor e o atributo associado.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            A parte da string de consulta do URL da solicitação, se houver.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            Como o servidor classificou a resposta antes de devolvê-la ao visualizador. Veja também o campo x-edge-result-type. Os valores possíveis incluem:

            * `Hit`: o servidor entregou o objeto ao visualizador a partir do cache.
            * `RefreshHit`: o servidor encontrou o objeto no cache, mas o objeto havia expirado, então o servidor contatou a origem para verificar se o cache tinha a versão mais recente do objeto.
            * `Miss`: A solicitação não pôde ser atendida por um objeto no cache, então o servidor encaminhou a solicitação para o servidor de origem e retornou o resultado ao visualizador.
            * `LimitExceeded`: a solicitação foi negada porque uma cota do CloudFront (anteriormente chamada de limite) foi excedida
            * `CapacityExceeded`: o servidor retornou um erro 503 porque não tinha capacidade suficiente no momento da solicitação para atender o objeto.
            * `Error`: normalmente, isso significa que a solicitação resultou em um erro do cliente (o valor do campo sc-status está no intervalo 4xx) ou em um erro do servidor (o valor do campo sc-status está no intervalo 5xx). Se o valor do campo x-edge-result-type for Error e o valor deste campo não for Error, o cliente se desconectou antes de finalizar o download.
            * `Redirect`: o servidor redirecionou o visualizador de HTTP para HTTPS de acordo com as configurações de distribuição.
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            Se o visualizador usou um proxy HTTP ou um balanceador de carga para enviar a solicitação, o valor do campo c-ip será o endereço IP do proxy ou do balanceador de carga. Nesse caso, este campo é o endereço IP do visualizador que originou a solicitação. Este campo contém um endereço IPv4 (por exemplo, `192.0.2.183`) ou um endereço IPv6 (por exemplo, `2001:0db8:85a3:0000:0000:8a2e:0370:7334`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            Quando a solicitação utilizou HTTPS, este campo contém o protocolo SSL/TLS que o visualizador e o servidor negociaram para transmitir a solicitação e a resposta.
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            Quando a solicitação utilizou HTTPS, este campo contém a cifra SSL/TLS que o visualizador e o servidor negociaram para criptografar a solicitação e a resposta.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            Como o servidor classificou a resposta após o último byte sair do servidor. Em alguns casos, o tipo de resultado pode mudar entre o momento em que o servidor está pronto para enviar a resposta e o momento em que termina de enviar a resposta. Consulte também o campo `x-edge-response-result-type` . Por exemplo, no streaming HTTP, suponha que o servidor encontre um segmento do fluxo no cache. Nesse cenário, o valor deste campo normalmente seria `Hit`. No entanto, se o visualizador fechar a conexão antes que o servidor tenha entregue todo o segmento, o tipo de resultado final (e o valor deste campo) será `Error`. As conexões WebSocket terão um valor `Miss` para esse campo porque o conteúdo não pode ser armazenado em cache e é enviado por proxy diretamente para a origem.

            Os valores possíveis incluem:

            * `Hit`: o servidor entregou o objeto ao visualizador a partir do cache.
            * `RefreshHit`: o servidor encontrou o objeto no cache, mas o objeto havia expirado, então o servidor contatou a origem para verificar se o cache tinha a versão mais recente do objeto.
            * `Miss`: A solicitação não pôde ser atendida por um objeto no cache, então o servidor encaminhou a solicitação para a origem e retornou o resultado ao visualizador.
            * `LimitExceeded`: a solicitação foi negada porque uma cota do CloudFront (anteriormente chamada de limite) foi excedida.
            * `CapacityExceeded`: o servidor retornou um código de status HTTP 503 porque não tinha capacidade suficiente no momento da solicitação para atender o objeto.
            * `Error`: normalmente, isso significa que a solicitação resultou em um erro do cliente (o valor do campo sc-status está no intervalo 4xx) ou em um erro do servidor (o valor do campo sc-status está no intervalo 5xx). Se o valor do campo `sc-status` for `200`, ou se o valor deste campo for `Error` e o valor do campo `x-edge-response-result-type` não for `Error`, significa que a solicitação HTTP foi bem-sucedida, mas o cliente desconectado antes de receber todos os bytes.
            * `Redirect`: o servidor redirecionou o visualizador de HTTP para HTTPS de acordo com as configurações de distribuição.
          </td>
        </tr>

        <tr>
          <td>
            `fle_encrypted_fields`
          </td>

          <td>
            O número de campos de criptografia em nível de campo que o servidor criptografou e encaminhou para a origem. Os servidores CloudFront transmitem a solicitação processada para a origem à medida que criptografam os dados. Portanto, esse campo pode ter um valor mesmo que o valor de `fle-status` seja um erro.
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            Quando a criptografia em nível de campo é configurada para uma distribuição, esse campo contém um código que indica se o corpo da solicitação foi processado com êxito. Quando o servidor processa com êxito o corpo da solicitação, criptografa valores nos campos especificados e encaminha a solicitação para a origem, o valor desse campo é Processado. O valor de `x-edge-result-type` ainda pode indicar um erro do lado do cliente ou do servidor neste caso.

            Os valores possíveis para este campo incluem: \*`ForwardedByContentType`: O servidor encaminhou a solicitação para a origem sem análise ou criptografia porque nenhum tipo de conteúdo foi configurado.

            * `ForwardedByQueryArgs`: o servidor encaminhou a solicitação para a origem sem análise ou criptografia porque a solicitação contém um argumento de consulta que não estava na configuração para criptografia em nível de campo.
            * `ForwardedDueToNoProfile`: o servidor encaminhou a solicitação para a origem sem análise ou criptografia porque nenhum perfil foi especificado na configuração para criptografia em nível de campo.
            * `MalformedContentTypeClientError`: o servidor rejeitou a solicitação e retornou um código de status HTTP 400 ao visualizador porque o valor do cabeçalho Content-Type estava em um formato inválido.
            * `MalformedInputClientError`: o servidor rejeitou a solicitação e retornou um código de status HTTP 400 ao visualizador porque o corpo da solicitação estava em um formato inválido.
            * `MalformedQueryArgsClientError`: o servidor rejeitou a solicitação e retornou um código de status HTTP 400 ao visualizador porque um argumento de consulta estava vazio ou em um formato inválido.
            * `RejectedByContentType`: o servidor rejeitou a solicitação e retornou um código de status HTTP 400 ao visualizador porque nenhum tipo de conteúdo foi especificado na configuração para criptografia em nível de campo.
            * `RejectedByQueryArgs`: o servidor rejeitou a solicitação e retornou um código de status HTTP 400 ao visualizador porque nenhum argumento de consulta foi especificado na configuração para criptografia em nível de campo.
            * `ServerError`: o servidor de origem retornou um erro. Se a solicitação exceder uma cota de criptografia em nível de campo (anteriormente chamada de limite), esse campo conterá um dos códigos de erro a seguir e o servidor retornará o código de status HTTP 400 ao visualizador.
            * `FieldLengthLimitClientError`: um campo configurado para ser criptografado excedeu o comprimento máximo permitido
            * `FieldNumberLimitClientError`: uma solicitação que a distribuição está configurada para criptografar contém mais do que o número de campos permitidos.
            * `RequestLengthLimitClientError`: o comprimento do corpo da solicitação excedeu o comprimento máximo permitido quando a criptografia em nível de campo está configurada.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            O valor do cabeçalho HTTP Content-Type da resposta.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            O valor do cabeçalho HTTP Content-Length da resposta.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-start`
          </td>

          <td>
            Quando a resposta contém o cabeçalho HTTP Content-Range, este campo contém o valor inicial do intervalo.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            Quando a resposta contém o cabeçalho HTTP Content-Range, este campo contém o valor final do intervalo.
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            O número da porta da solicitação do visualizador.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            Quando o valor do campo `x-edge-result-type` for `Error`, esse campo conterá o tipo específico de erro. Quando o objeto foi servido ao visualizador a partir do cache do Origin Shield, este campo contém `OriginShieldHit`. Em todos os outros casos, este campo contém o mesmo valor que `x-edge-result-type`. Os valores possíveis para este campo incluem:

            * `AbortedOrigin`: o servidor encontrou um problema com a origem.
            * `OriginCommError`: a solicitação expirou durante a conexão com a origem ou a leitura de dados da origem.
            * `ClientCommError`: A resposta ao visualizador foi interrompida devido a um problema de comunicação entre o servidor e o visualizador.
            * `ClientGeoBlocked`: a distribuição está configurada para recusar solicitações da localização geográfica do visualizador.
            * `ClientHungUpRequest`: o visualizador parou prematuramente ao enviar a solicitação.
            * `Error` – Ocorreu um erro cujo tipo de erro não se enquadra em nenhuma das outras categorias. Esse tipo de erro pode ocorrer quando o servidor fornece uma resposta de erro do cache.
            * `InvalidRequest`: o servidor recebeu uma solicitação inválida do visualizador.
            * `InvalidRequestBlocked`: o acesso ao recurso solicitado está bloqueado.
            * `InvalidRequestCertificate`: a distribuição não corresponde ao certificado SSL/TLS para o qual a conexão HTTPS foi estabelecida.
            * `InvalidRequestHeader`: a solicitação continha um cabeçalho inválido.
            * `InvalidRequestMethod`: a distribuição não está configurada para lidar com o método de solicitação HTTP usado. Isso pode acontecer quando a distribuição oferece suporte apenas a solicitações armazenáveis em cache.
            * `OriginConnectError`: o servidor não conseguiu se conectar à origem.
            * `OriginContentRangeLengthError`: o cabeçalho Content-Length na resposta da origem não corresponde ao comprimento no cabeçalho Content-Range.
            * `OriginDnsError`: o servidor não conseguiu resolver o nome de domínio de origem.
            * `OriginError`: a origem retornou uma resposta incorreta.
            * `OriginHeaderTooBigError`: um cabeçalho retornado pela origem é muito grande para ser processado pelo servidor de borda.
            * `OriginInvalidResponseError`: a origem retornou uma resposta inválida.
            * `OriginReadError`: o servidor não conseguiu ler a origem.
            * `OriginShieldHit`: o objeto foi fornecido ao visualizador a partir do cache do Origin Shield.
            * `OriginWriteError`: o servidor não pôde gravar na origem.
            * `OriginZeroSizeObjectError`: um objeto de tamanho zero enviado da origem resultou em erro.
            * `SlowReaderOriginError`: o visualizador demorou a ler a mensagem que causou o erro de origem.
          </td>
        </tr>

        <tr>
          <td>
            `c_country`
          </td>

          <td>
            Um código de país que representa a localização geográfica do visualizador, conforme determinado pelo endereço IP do visualizador.
          </td>
        </tr>

        <tr>
          <td>
            `cs_accept_encoding`
          </td>

          <td>
            O valor do cabeçalho `Accept-Encoding` na solicitação do visualizador.
          </td>
        </tr>

        <tr>
          <td>
            `cs_accept`
          </td>

          <td>
            O valor do cabeçalho `Accept` na solicitação do visualizador.
          </td>
        </tr>

        <tr>
          <td>
            `cache_behavior_path_pattern`
          </td>

          <td>
            O padrão de caminho que identifica o comportamento do cache que corresponde à solicitação do visualizador.
          </td>
        </tr>

        <tr>
          <td>
            `cs_headers`
          </td>

          <td>
            Os cabeçalhos HTTP (nomes e valores) na solicitação do visualizador.
          </td>
        </tr>

        <tr>
          <td>
            `cs_header_names`
          </td>

          <td>
            Os nomes dos cabeçalhos HTTP (não valores) na solicitação do visualizador.
          </td>
        </tr>

        <tr>
          <td>
            `cs_headers_count`
          </td>

          <td>
            O número de cabeçalhos HTTP na solicitação do visualizador.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="elastic-load-balancer"
    title="Balanceador de carga elástico"
  >
    <DNT>**Source:**</DNT> `logtype = 'elb'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} "%{DATA:request}" "%{DATA:user_agent}" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol}
    ```

    <DNT>
      **Results:**
    </DNT>

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            Campo
          </th>

          <th>
            Definição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            O ponto de presença que atendeu a solicitação. Cada ponto de presença é identificado por um código de três letras e um número atribuído arbitrariamente; por exemplo, `DFW3`. O código de três letras normalmente corresponde ao código de aeroporto da Associação Internacional de Transporte Aéreo para um aeroporto próximo ao ponto de presença. (Essas abreviações podem mudar no futuro.)
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            O número total de bytes que o CloudFront serviu ao visualizador em resposta à solicitação, incluindo cabeçalhos; por exemplo, `1045619`. Para conexões WebSocket, esse é o número total de bytes enviados do servidor para o cliente por meio da conexão.
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            O endereço IP do visualizador que fez a solicitação. Se o visualizador usou um proxy HTTP ou um balanceador de carga para enviar a solicitação, o valor de `c_ip` será o endereço IP do proxy ou do balanceador de carga.
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            O método de solicitação HTTP&#x3A; `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST` ou `PUT`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            O nome de domínio da distribuição do CloudFront; por exemplo, `d111111abcdef8.cloudfront.net`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            A parte do URI que identifica o caminho e o objeto; por exemplo, `/images/cat.jpg`. Pontos de interrogação (`?`) em URLs e strings de consulta não são incluídos no log.
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            Um código de status HTTP (por exemplo, `200`). O código de status `000` indica que o visualizador fechou a conexão (por exemplo, fechou a guia do Browser) antes que o CloudFront pudesse responder a uma solicitação.

            Se o visualizador fechar a conexão depois que o CloudFront começar a enviar a resposta, o log conterá o código de status HTTP aplicável.
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            nome do domínio que originou a solicitação. Os referenciadores comuns incluem mecanismos de pesquisa, outros sites com links diretos para seus objetos e seu próprio site.
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            O valor do cabeçalho usuário-agente na solicitação. O cabeçalho usuário-agente identifica a origem da solicitação, como o tipo de dispositivo e Browser que enviou a solicitação e qual mecanismo de busca, se aplicável.
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            A parte da string de consulta do URI, se houver. Quando um URI não contém uma string de consulta, o valor deste campo é um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            O cabeçalho do cookie na solicitação, incluindo pares nome-valor e o atributo associado.

            * Se você ativar o registro de cookies, o CloudFront registrará os cookies em todas as solicitações, independentemente de quais cookies você escolher encaminhar para a origem.
            * Se uma solicitação não incluir um cabeçalho de cookie, o valor deste campo será um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            Como o CloudFront classifica a resposta após o último byte sair do ponto de presença. Em alguns casos, o tipo de resultado pode mudar entre o momento em que o CloudFront está pronto para enviar a resposta e o momento em que o CloudFront termina de enviar a resposta.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            Uma string criptografada que identifica exclusivamente uma solicitação. No cabeçalho da resposta, é `x-amz-cf-id`.
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            O valor que o visualizador incluiu no cabeçalho Host dessa solicitação. Este é o nome de domínio na solicitação.

            * Se você estiver usando o nome de domínio do CloudFront nos URLs do objeto, esse campo conterá esse nome de domínio.
            * Se você estiver usando nomes de domínio alternativos em seus URLs de objeto, como `[http://example.com/logo.png`, este campo conterá o nome de domínio alternativo, como `example.com`. Para usar nomes de domínio alternativos, você deve adicioná-los à sua distribuição.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            O protocolo que o visualizador especificou na solicitação: `http`, `https`, `ws` ou `wss`.
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            O número de bytes de dados que o visualizador incluiu na solicitação, incluindo cabeçalhos. Para conexões WebSocket, esse é o número total de bytes enviados do cliente para o servidor na conexão.
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            O número de segundos (até o milésimo de segundo; por exemplo, 0,002) entre o momento em que um servidor de borda do CloudFront recebe uma solicitação do visualizador e o momento em que o CloudFront grava o último byte da resposta na fila de saída do servidor de borda, conforme medido em o servidor.

            Da perspectiva do visualizador, o tempo total para obter o objeto completo será maior que esse valor devido à latência da rede e ao buffer TCP.
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            Se o visualizador usou um proxy HTTP ou um balanceador de carga para enviar a solicitação, o valor de `c_ip` no campo 5 será o endereço IP do proxy ou do balanceador de carga. Nesse caso, este campo é o endereço IP do visualizador que originou a solicitação. Este campo contém endereços IPv4 e IPv6 conforme aplicável.

            Se o visualizador não usou um proxy HTTP ou um balanceador de carga, o valor de `x_forwarded_for` será um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            Quando `cs_protocol` no campo 17 é `https`, esse campo contém o protocolo SSL/TLS que o cliente e o CloudFront negociaram para transmitir a solicitação e a resposta. Os valores possíveis incluem:

            * SSLv3
            * TLSv1
            * TLSv1.1
            * TLSv1.2 Quando `cs_protocol` no campo 17 for `http`, o valor desse campo será um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            Quando `cs_protocol` no campo 17 for `https`, esse campo conterá a cifra SSL/TLS que o cliente e o CloudFront negociaram para criptografar a solicitação e a resposta. Os valores possíveis incluem:

            * `ECDHE-RSA-AES128-GCM-SHA256`

            * `ECDHE-RSA-AES128-SHA256`

            * `ECDHE-RSA-AES128-SHA`

            * `ECDHE-RSA-AES256-GCM-SHA384`

            * `ECDHE-RSA-AES256-SHA384`

            * `ECDHE-RSA-AES256-SHA`

            * `AES128-GCM-SHA256`

            * `AES256-GCM-SHA384`

            * `AES128-SHA256`

            * `AES256-SHA`

            * `AES128-SHA`

            * `DES-CBC3-SHA`

            * `RC4-MD5`

              Quando `cs_protocol` é `http`, o valor deste campo é um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            Como o CloudFront classificou a resposta antes de retorná-la ao visualizador. Os valores possíveis incluem:

            * `Hit`: o CloudFront entregou o objeto ao visualizador a partir do cache de borda.
            * `RefreshHit`: o CloudFront encontrou o objeto no cache de borda, mas ele havia expirado, então o CloudFront entrou em contato com a origem para verificar se o cache tem a versão mais recente do objeto.
            * `Miss`: a solicitação não pôde ser atendida por um objeto no cache de borda, então o CloudFront encaminhou a solicitação para o servidor de origem e retornou o resultado ao visualizador.
            * `LimitExceeded`: a solicitação foi negada porque um limite do CloudFront foi excedido.
            * `CapacityExceeded`: o CloudFront retornou um erro `503` porque o ponto de presença não tinha capacidade suficiente no momento da solicitação para atender o objeto.
            * `Error`: normalmente, isso significa que a solicitação resultou em um erro do cliente (`sc_status` é `4xx`) ou um erro do servidor (`sc_status` é `5xx`). Se o valor de `x_edge_result_type` for `Error` e o valor deste campo **não** for `Error`, o cliente se desconectou antes de finalizar o download.
            * `Redirect`: o CloudFront redireciona de HTTP para HTTPS. Se `sc_status` for `403` e você tiver configurado o CloudFront para restringir a distribuição geográfica do seu conteúdo, a solicitação poderá ter vindo de um local restrito.
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            A versão HTTP que o visualizador especificou na solicitação. Os valores possíveis incluem:

            * `HTTP/0.9`
            * `HTTP/1.0`
            * `HTTP/1.1`
            * `HTTP/2.0`
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            Quando a criptografia em nível de campo é configurada para uma distribuição, esse campo contém um código que indica se o corpo da solicitação foi processado com êxito. Se a criptografia em nível de campo não estiver configurada para a distribuição, o valor desse campo será um hífen (`-`).

            Quando o CloudFront processa com êxito o corpo da solicitação, criptografa valores nos campos especificados e encaminha a solicitação para a origem, o valor desse campo é `Processed`. O valor de `x_edge_result_type` ainda pode indicar um erro do lado do cliente ou do servidor neste caso.

            Se a solicitação exceder um limite de criptografia em nível de campo, `fle-status` conterá um dos seguintes códigos de erro e o CloudFront retornará o código de status HTTP `400` ao visualizador.
          </td>
        </tr>

        <tr>
          <td>
            `fle-encrypted-fields`
          </td>

          <td>
            O número de campos que o CloudFront criptografou e encaminhou para a origem. O CloudFront transmite a solicitação processada para a origem enquanto criptografa os dados, portanto, `fle_encrypted_fields` pode ter um valor mesmo que o valor de `fle_status` seja um erro.

            Se a criptografia em nível de campo não estiver configurada para a distribuição, o valor de `fle_encrypted_fields` será um hífen (`-`).
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            O número da porta da solicitação do visualizador.
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            O número de segundos entre o recebimento da solicitação e a gravação do primeiro byte da resposta, conforme medido no servidor.
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            Quando `x_edge_result_type` <DNT>**is not**</DNT> `Error`, este campo contém o mesmo valor que `x_edge_result_type`. Quando `x_edge_result_type` <DNT>**is**</DNT> `Error`, este campo contém o tipo específico de erro.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            O valor do cabeçalho HTTP Content-Type da resposta.
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            O valor do cabeçalho HTTP Content-Length da resposta.
          </td>
        </tr>

        <tr>
          <td>
            `sc_range_start`
          </td>

          <td>
            Quando a resposta contém o cabeçalho HTTP Content-Range, este campo contém o valor inicial do intervalo.
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            Quando a resposta contém o cabeçalho HTTP Content-Range, este campo contém o valor final do intervalo.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="haproxy"
    title="HAProxy"
  >
    <DNT>**Source:**</DNT> `logtype = 'haproxy_http'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{HOSTPORT:client} \\[%{NOTSPACE:haproxy_timestamp}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{NUMBER:time_queue}/%{NUMBER:time_backend_connect}/%{NUMBER:time_duration} %{NUMBER:bytes_read} %{NOTSPACE:termination_state} %{NUMBER:actconn}/%{NUMBER:feconn}/%{NUMBER:beconn}/%{NUMBER:srvconn}/%{NUMBER:retries} %{NUMBER:srv_queue}/%{NUMBER:backend_queue}
    ```

    ```
    %{HOSTPORT:client} \\[%{NOTSPACE:haproxy_timestamp}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{NUMBER:time_client_req}/%{NUMBER:time_queue}/%{NUMBER:time_backend_connect}/%{NUMBER:time_server_response}/%{NUMBER:time_duration} %{NUMBER:status_code} %{NUMBER:bytes_read} %{NOTSPACE:captured_request_cookie} %{NOTSPACE:captured_response_cookie} %{NOTSPACE:termination_state_with_cookie_status} %{NUMBER:actconn}/%{NUMBER:feconn}/%{NUMBER:beconn}/%{NUMBER:srvconn}/%{NUMBER:retries} %{NUMBER:srv_queue}/%{NUMBER:backend_queue}?( \\\"%{GREEDYDATA:full_http_request}\\\")?( %{NOTSPACE:captured_response_headers})?
    ```

    <DNT>
      **Results:**
    </DNT>

    * `client`: IP/Porta de origem desta solicitação
    * `haproxy_timestamp`: timestamp em que esta solicitação foi aceita
    * `frontend_name`: Nome do frontend usado nesta solicitação
    * `backend_name`: Nome do backend usado nesta solicitação
    * `server_name`: nome do servidor no grupo backend usado nesta solicitação
    * `time_client_req`: Tempo de espera pela solicitação completa do cliente (ms)
    * `time_queue`: Tempo de espera nas filas (ms)
    * `time_backend_connect`: Tempo para estabelecer conexão com o servidor de destino (ms)
    * `time_server_response`: Tempo para o servidor de destino enviar resposta (ms)
    * `time_duration`: Tempo total de solicitação ativa no HAProxy (ms)
    * `status_code`: código de resposta HTTP
    * `bytes_read`: Total de bytes lidos nesta solicitação
    * `captured_request_cookie`: cookie capturado da solicitação
    * `captured_response_cookie`: cookie capturado da resposta
    * `termination_state`: Estado da sessão na desconexão
    * `termination_state_with_cookie_status`: Estado da sessão, incluindo status do cookie, na desconexão
    * `actconn`: Conexões ativas
    * `feconn`: Conexões de front-end
    * `beconn`: conexões backend
    * `srvconn`: Conexões do servidor
    * `retries`: Novas tentativas
    * `srv_queue`: Tamanho da fila do servidor
    * `backend_queue`: tamanho da fila backend
    * `full_http_request`: A linha de solicitação HTTP completa
    * `captured_response_headers`: Cabeçalho capturado da resposta
  </Collapser>

  <Collapser
    id="ktranslate-health"
    title="KTranslate Saúde"
  >
    <DNT>**Source:**</DNT> `logtype = 'ktranslate-health'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{NOTSPACE:timestamp} ktranslate(/)?(%{GREEDYDATA:container_service})? \[%{NOTSPACE:severity}] %{GREEDYDATA:message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `timestamp`: A hora do log
    * `container_service`: O identificador exclusivo usado para distinguir o contêiner no ktranslate. Isso é definido durante o tempo de execução Docker com o sinalizador `--service_name` opcional
    * `severity`: A gravidade da linha de log
    * `message`: o campo de mensagem contém uma mensagem de formato livre que fornece informações sobre o evento
  </Collapser>

  <Collapser
    id="linux_cron"
    title="Cron do Linux (/var/log/cron)"
  >
    <DNT>**Source:**</DNT> `logtype = 'linux_cron'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{SYSLOGTIMESTAMP:linux_cron.timestamp} %{NOTSPACE:linux_cron.hostname} %{DATA:linux_cron.process}(\[%{NUMBER:linux_cron.pid:integer}\])?: (\(%{DATA:linux_cron.user}\))?%{GREEDYDATA:linux_cron.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `linux_cron.timestamp`: A hora do log
    * `linux_cron.hostname`: O nome do host do servidor Linux
    * `linux_cron.process`: O nome do processo cron do Linux
    * `linux_cron.pid`: O PID do cron do Linux (identificador de processo)
    * `linux_cron.user`: O usuário Linux que executou o cron
    * `linux_cron.message`: A mensagem do log
  </Collapser>

  <Collapser
    id="linux_messages"
    title="Mensagens Linux (/var/mensagem do log)"
  >
    <DNT>**Source:**</DNT> `logtype = 'linux_messages'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{SYSLOGTIMESTAMP:linux_messages.timestamp} %{NOTSPACE:linux_messages.hostname} %{DATA:linux_messages.process}(\[%{NUMBER:linux_messages.pid:integer}\])?: %{GREEDYDATA:linux_messages.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `linux_messages.timestamp`: A hora do log
    * `linux_messages.hostname`: O nome do host do servidor Linux
    * `linux_messages.process`: O nome do processo Linux
    * `linux_messages.pid`: O PID do Linux (identificador de processo)
    * `linux_messages.message`: A mensagem do log
  </Collapser>

  <Collapser
    id="iis"
    title="Microsoft IIS"
  >
    <DNT>**Source:**</DNT> `logtype = 'iis_w3c'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken}
    ```

    <DNT>
      **Results:**
    </DNT>

    O IIS permite diversas [opções de configuração](https://docs.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms524877(v=vs.90)). Se você configurou alguma opção fora do padrão, nosso padrão Grok não analisará seu log. Nesse caso, recomendamos que você use [a análise personalizada](/docs/logs/ui-data/parsing/#custom-parsing).
  </Collapser>

  <Collapser
    id="mongodb"
    title="Mongodb"
  >
    <DNT>**Source:**</DNT> `logtype = 'mongodb'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{TIMESTAMP_ISO8601:mongodb.timestamp} %{WORD:mongodb.severity} %{WORD:mongodb.component} *\[%{WORD:mongodb.context}\] %{GREEDYDATA:mongodb.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `mongodb.timestamp`: o timestamp da instrução de log
    * `mongodb.severity`: O nível de gravidade da instrução de log (F=Fatal, E=Erro, W=Aviso, I=Informativo, D1-5=Depuração)
    * `mongodb.component`: a categoria do thread que emite a instrução de log
    * `mongodb.context`: o nome do thread que emite a instrução de log
    * `mongodb.message`: A mensagem bruta do mongodb
  </Collapser>

  <Collapser
    id="monit"
    title="Monitorar"
  >
    <DNT>**Source:**</DNT> `logtype = 'monit'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    \\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `state`: A gravidade da linha de log
    * `message`: A mensagem
  </Collapser>

  <Collapser
    id="mysql-error"
    title="Erro MySQL"
  >
    <DNT>**Source:**</DNT> `logtype = 'mysql-error'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    \\[%{WORD:log_level}\\]
    ```

    <DNT>
      **Results:**
    </DNT>

    * `log_level`: A gravidade da linha de log
  </Collapser>

  <Collapser
    id="nginx"
    title="NGINX"
  >
    <DNT>**Source:**</DNT> `logtype = 'nginx'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `clientip`: O endereço IP do cliente
    * `verb`: O verbo HTTP
    * `ident`: A identidade do usuário do cliente que faz a solicitação
    * `response`: o código de status HTTP da resposta
    * `request`: O URI e a solicitação que está sendo feita
    * `httpversion`: a versão HTTP da solicitação
    * `rawrequest`: a solicitação HTTP bruta se os dados forem postados
    * `bytes`: O número de bytes enviados
    * `referrer`: O referenciador HTTP
    * `agent`: o agente do usuário do cliente
  </Collapser>

  <Collapser
    id="nginx-error"
    title="Erro NGINX"
  >
    <DNT>**Source:**</DNT> `logtype = 'nginx-error'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \[%{WORD:severity}\] %{POSINT:pid}#%{NUMBER}: \*%{NUMBER} %{GREEDYDATA:errormessage} client: %{IPORHOST:client}, server: %{NOTSPACE:server}, request: (\\)?"%{DATA:request}", (?:, upstream: \"%{URI:upstream}\")?host: (\\)?"%{NOTSPACE:host}(\\)?"(, referrer: (\\)?"%{URI:referrer}(\\)?")?
    ```

    <DNT>
      **Results:**
    </DNT>

    * `severity`: A gravidade da linha de log
    * `pid`: o ID do processo do servidor
    * `errormessage`: A mensagem de erro
    * `clientip`: O endereço IP do cliente chamador
    * `server`: O endereço IP do servidor
    * `request`: A solicitação completa
    * `upstream`: o URI upstream
    * `host`: O nome do host do servidor
    * `referrer`: O referenciador HTTP
  </Collapser>

  <Collapser
    id="postgresql"
    title="Postgresql"
  >
    Fonte: `logtype = 'postgresql'`

    Grok:

    ```grok
    %{DATA:postgresql.timestamp} \[%{NUMBER:postgresql.pid}\] %{WORD:level}:\s+%{GREEDYDATA:postgresql.message}
    ```

    ### Resultados

    * `postgresql.timestamp`: O timestamp do log
    * `postgresql.pid`: o ID do processo do servidor
    * `level`: o nível de log da mensagem
    * `postgresql.message`: A mensagem do log
  </Collapser>

  <Collapser
    id="rabbitmq"
    title="Coelhomq"
  >
    <DNT>**Source:**</DNT> `logtype = 'rabbitmq'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{TIMESTAMP_ISO8601:rabbitmq.timestamp} \[%{LOGLEVEL:level}\] \<%{DATA:rabbitmq.pid}\> %{GREEDYDATA:rabbitmq.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `rabbitmq.timestamp`: O timestamp do log
    * `level`: O nível de log da mensagem (depuração, informação, aviso, erro, crítico, nenhum)
    * `rabbitmq.pid`: O ID do processo da linha de log
    * `rabbitmq.message`: A mensagem de erro RabbitMQ
  </Collapser>

  <Collapser
    id="redis"
    title="Redis"
  >
    <DNT>**Source:**</DNT> `logtype = 'redis'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{POSINT:redis.pid}:%{NOTSPACE:redis.role} (?<redistimestamp>[\d-]+ [a-zA-Z]+ [\d]+ [\d:]+.[\d]{3}) %{NOTSPACE:level} %{GREEDYDATA:redis.message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `redis.pid`: O ID do processo da linha de log
    * `redis.role`: A função da instância (X sentinela, filho de gravação CRDB/AOF, escravo S, mestre M)
    * `redistimestamp`: O timestamp do log
    * `level`: O nível de log da mensagem (. debug, - verbose, \* warning, # warning)
    * `redis.message`: A mensagem de erro Redis
  </Collapser>

  <Collapser
    id="route53"
    title="Rota 53"
  >
    <DNT>**Source:**</DNT> `logtype = 'route-53'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `log_format_version`: um formato versionado para o log.
    * `zone_id`: O ID da zona hospedada associada a todas as consultas de DNS neste log.
    * `query`: o domínio ou subdomínio especificado na solicitação.
    * `query_type`: o tipo de registro DNS especificado na solicitação ou `ANY`.
    * `response_code`: o código de resposta DNS que o Route 53 retornou em resposta à consulta DNS.
    * `protocol`: o protocolo usado para enviar a consulta, seja TCP ou UDP.
    * `edge_location`: o ponto de presença do Route 53 que respondeu à consulta. Cada localização de borda é identificada por um código de três letras e um número arbitrário; por exemplo, `DFW3`. O código de três letras normalmente corresponde ao código de aeroporto da Associação Internacional de Transporte Aéreo para um aeroporto próximo ao ponto de presença. (Essas abreviações podem mudar no futuro.)
    * `resolver_ip`: o endereço IP do resolvedor DNS que enviou a solicitação ao Route 53.
    * `edns_client_subnet`: um endereço IP parcial para o cliente de origem da solicitação, se disponível no resolvedor DNS.
  </Collapser>

  <Collapser
    id="syslog-rfc5424"
    title="Syslog RFC-5424"
  >
    <DNT>**Source:**</DNT> `logtype = 'syslog-rfc5424'`

    <DNT>
      **Grok:**
    </DNT>

    ```grok
    <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\-|%{NOTSPACE:app.name}) +(?:\\-|%{NOTSPACE:procid}) (?:\\-|%{NOTSPACE:msgid}) +(?:\[%{DATA:structured.data}\]|-|) +%{GREEDYDATA:message}
    ```

    <DNT>
      **Results:**
    </DNT>

    * `pri`: a prioridade representa a facilidade e a gravidade da mensagem.
    * `version`: Versão do protocolo Syslog.
    * `log.timestamp`: timestamp original.
    * `hostname`: a máquina que originalmente enviou a mensagem Syslog.
    * `app.name`: o dispositivo ou aplicativo que originou a mensagem.
    * `procid`: o nome ou ID do processo associado a um sistema Syslog.
    * `msgid`: identifica o tipo de mensagem.
    * `structured.data`: valor da sequência de dados estruturados.
    * `sd.sd-id.sd-param-name`: o conteúdo `structured.data` também é analisado em um atributo separado seguindo uma convenção de nomenclatura predefinida: `sd.sd-id.sd-param-name`. Consulte os exemplos de análise de dados estruturados a seguir.
    * `message`: mensagem de formato livre que fornece informações sobre o evento.

    <DNT>
      **Structured data parsing examples:**
    </DNT>

    Os dados estruturados `[example one="1" two="2"]` seriam analisados em dois atributos diferentes:

    ```
    sd.example.one: "1"
    sd.example.two: "2"
    ```

    Se o mesmo bloco de dados estruturados contiver nomes de parâmetros duplicados, ele também anexará um sufixo baseado em índice ao nome do atributo. Por exemplo, os dados estruturados `[example number="1" number="2"]` seriam analisados como:

    ```
    sd.example.number.0: "1"
    sd.example.number.1: "2"
    ```

    Para dados estruturados com números corporativos atribuídos, um atributo extra também é analisado. Por exemplo, os dados estruturados `[example@123 number="1"]` seriam analisados como:

    ```
    sd.example.enterprise.number: 123
    sd.example.number: "1"
    ```
  </Collapser>
</CollapserGroup>
