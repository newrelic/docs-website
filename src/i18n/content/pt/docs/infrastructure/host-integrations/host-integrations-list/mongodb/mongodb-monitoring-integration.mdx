---
title: MongoDB monitoramento integração (legado)
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: 'The legacy New Relic MongoDB integration: how to install it and configure it, and what data it reports.'
freshnessValidatedDate: never
translationType: machine
---

<Callout title="IMPORTANTE!">
  Esta integração de legado está prevista para chegar ao fim em 2024: adicionaremos uma data EOL específica quando soubermos disso. Recomendamos usar nossa [integração mais recente com o MongoDB](/docs/infrastructure/host-integrations/host-integrations-list/mongodb/mongodb-monitoring-integration-new). Para obter informações sobre como mudar da integração de legado para a nova, consulte nossos [documentos de migração](/docs/infrastructure/host-integrations/host-integrations-list/mongodb/mongodb-migration-guide).
</Callout>

Nosso legado integração MongoDB coleta e envia inventário e métricas do seu cluster MongoDB para nossa plataforma, onde você pode agregar e visualizar as principais métricas de desempenho. Coletamos dados em instâncias `mongos` e `mongod`, servidores de configuração, bem como em banco de dados e coleções para ajudar a identificar o desempenho gargalo.

## Compatibilidade e requisitos [#comp-req]

Esta integração de legado é compatível com MongoDB v3 e v4. Nossa [integração mais recente com o MongoDB](/docs/infrastructure/host-integrations/host-integrations-list/mongodb/mongodb-monitoring-integration-new) oferece suporte a versões mais recentes.

Antes de instalar esta integração de legado, certifique-se de atender aos seguintes requisitos:

* Uma conta New Relic . Não tem um? [Cadastre-se gratuitamente!](https://newrelic.com/signup) Não é necessário cartão de crédito.

* Usuário MongoDB com [papéis`clusterMonitor` e `listCollections` ](#users-privileges).

* Se o MongoDB **não** estiver em execução no Kubernetes ou no Amazon ECS, você deverá [instalar o agente de infraestrutura](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic) em um host que esteja executando o MongoDB. De outra forma:

  * Se estiver executando no Kubernetes, consulte [estes requisitos](/docs/monitor-service-running-kubernetes#requirements).
  * Se estiver executando no ECS, consulte [estes requisitos](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).

## Instalar e ativar [#install]

Caso queira instalar nossa integração MongoDB herdada, siga as instruções para seu ambiente:

<CollapserGroup>
  <Collapser
    id="ecs-install"
    title="SEC"
  >
    Consulte [Monitorar serviço em execução no ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
  </Collapser>

  ' '

  <Collapser
    id="k8s-install"
    title="Kubernetes"
  >
    Consulte [Monitorar serviço em execução no Kubernetes](/docs/monitor-service-running-kubernetes).
  </Collapser>

  <Collapser
    id="linux-install"
    title="Linux"
  >
    1. Instale [o agente de infraestrutura](/docs/integrations/host-integrations/installation/install-infrastructure-host-integrations/#install) e substitua a variável `INTEGRATION_FILE_NAME` por `nri-mongodb`.

    2. Mude o diretório para a pasta integração:

       ```
       cd /etc/newrelic-infra/integrations.d
       ```

    3. Cópia do arquivo de configuração de amostra:

       ```
       sudo cp mongodb-config.yml.sample mongodb-config.yml
       ```

    4. Edite o arquivo `mongodb-config.yml` conforme descrito nas [definições de configuração](#config).

    5. [Reinicie o agente de infraestrutura](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).

    6. Para ativar a análise automática de log e encaminhamento de erros do MongoDB, copie (ou renomeie) o arquivo `mongodb-log.yml.example` para `mongodb-log.yml`. Não há necessidade de reiniciar o agente.

       <DoNotTranslate>
         **Example:**
       </DoNotTranslate>

       ```
       sudo cp /etc/newrelic-infra/logging.d/mongodb-log.yml.example /etc/newrelic-infra/logging.d/mongodb-log.yml
       ```
  </Collapser>

  <Collapser
    id="windows-install"
    title="Windows"
  >
    1. Baixe a imagem do instalador `nri-mongodb` .MSI em:

       [https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-mongodb/nri-mongodb-amd64.msi](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-mongodb/nri-mongodb-amd64.msi)

    2. Para instalar a partir do prompt de comando do Windows, execute:

       ```
       msiexec.exe /qn /i PATH\TO\nri-mongodb-amd64.msi
       ```

    3. No diretório integração, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, crie uma cópia do arquivo de configuração de amostra executando:

       ```
       cp mongodb-config.yml.sample mongodb-config.yml
       ```

    4. Edite o arquivo de configuração `mongodb-config.yml` usando as [definições de configuração](#config).

    5. [Reinicie o agente de infraestrutura](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).
  </Collapser>
</CollapserGroup>

Notas Adicionais:

* <DoNotTranslate>**Advanced:**</DoNotTranslate>

  integração também estão disponíveis em [formato tarball](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball) para permitir a instalação fora de um gerenciador de pacote.

* <DoNotTranslate>**On-host integrations do not automatically update.**</DoNotTranslate>

  Para obter melhores resultados, [atualize regularmente o pacote de integração](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) e [o agente de infraestrutura](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

## Configuração [#configuration]

### Habilitando seu servidor MongoDB [#enable-instance]

No [shell do MongoDB](https://docs.mongodb.com/manual/mongo/), execute os comandos a seguir para criar uma função `listCollections` e um novo usuário. Em seguida, atribua funções `clusterMonitor` e `listCollections` ao novo usuário. Nota: Substitua nome de usuário, senha e valores semelhantes específicos do usuário.

Consulte a documentação do MongoDB para obter detalhes sobre [a criação de usuários](https://docs.mongodb.com/manual/reference/method/db.createUser/index.html) e [funções](https://docs.mongodb.com/manual/reference/method/db.createRole/index.html).

<Callout variant="tip">
  Conclua estas etapas nos mongos a serem monitorados. Se forem coletadas métricas de nível mongod, como estatísticas de host ou conjunto de réplicas, crie também a função e o usuário em cada mongod.
</Callout>

1. No shell do MongoDB, insira `use admin`.

2. Use o comando a seguir para criar a função `listCollections` .

   ```
   db.createRole({
       role: "listCollections",
       privileges: [{
           resource: {db:"",collection:""},
           actions: ["listCollections"]
       }],
       roles: []
   })
   ```

3. Use os comandos a seguir para criar um novo usuário e atribuir funções `clusterMonitor` e `listCollections` ao usuário.

   ```
   db.createUser({
       user: "username",
       pwd: "password",
       roles: [
           "clusterMonitor",
           "listCollections"
       ]
   })
   ```

<InstallFeedback/>

### Configurar a integração [#config]

Existem diversas formas de configurar a integração, dependendo de como ela foi instalada:

* Se habilitado via Kubernetes: consulte [Monitorar serviços em execução no Kubernetes](/docs/monitor-service-running-kubernetes).
* Se habilitado via Amazon ECS: consulte [Monitorar serviços em execução no ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
* Se instalado no host: edite a configuração no arquivo de configuração YAML da integração, `mongodb-config.yml`.

A configuração no formato YAML de uma integração é onde você pode colocar as credenciais de login necessárias e configurar como os dados são coletados. Quais opções você altera dependem de sua configuração e preferência.

O arquivo de configuração possui configurações comuns aplicáveis a toda integração, como `interval`, `timeout`, `inventory_source`. Para ler tudo sobre essas configurações comuns, consulte nosso documento [Formato de configuração](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) .

<Callout variant="important">
  Se você ainda estiver usando nossos arquivos de configuração/definição legados, consulte [o formato de configuração padrão](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/) para obter ajuda.
</Callout>

Configurações específicas relacionadas ao MongoDB são definidas usando a seção `env` do arquivo de configuração. Essas configurações controlam a conexão com sua instância do MongoDB, bem como outras configurações e recursos de segurança. A lista de configurações válidas é descrita na próxima seção deste documento.

A integração do MongoDB pode ser configurada para monitor um cluster MongoDB completo ou uma instância autônoma do MongoDB. Para monitor um cluster, os [argumentos](#arguments) `host` e `port` devem apontar para uma das instâncias `mongos` em seu cluster. Se desejar monitor uma instância independente, certifique-se de que `host` e `port` apontem para `mongod` executando o banco de dados.

<Callout variant="tip">
  A autenticação SCRAM não é suportada.
</Callout>

### Configurações da instância do MongoDB [#instance-settings]

A integração MongoDB coleta informações métricas e de inventário. Na tabela a seguir, consulte a coluna <DoNotTranslate>**Applies To**</DoNotTranslate> para ver as configurações disponíveis para cada coleção.

Os valores para estas configurações podem ser definidos de diversas maneiras:

* Adicionando o valor diretamente no arquivo de configuração. Esta é a forma mais comum.
* Substituindo os valores das variáveis de ambiente usando a notação `{{}}` . Isto requer o agente de infraestrutura v1.14.0 ou superior. Para obter mais informações, consulte nossa documentação sobre [passthrough](/docs/infrastructure/install-infrastructure-agent/configuration/configure-infrastructure-agent/#passthrough) ou veja o [exemplo de substituição](#envvar-replacement).
* Usando gerenciamento de segredos. Use isto para proteger informações confidenciais, como senhas que seriam expostas em texto simples no arquivo de configuração. Para obter mais informações, consulte [Gerenciamento de segredos](/docs/integrations/host-integrations/installation/secrets-management).

' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '

<table>
  <thead>
    <tr>
      <th style={{ width: '150px' }}>
        Contexto
      </th>

      <th>
        Descrição
      </th>

      <th>
        Aplica-se a
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <DoNotTranslate>
          **MONGODB_CLUSTER_NAME**
        </DoNotTranslate>
      </td>

      <td>
        Nome definido pelo usuário para identificar exclusivamente o cluster que está sendo monitorado. <DoNotTranslate>**Required**</DoNotTranslate>.
      </td>

      <td>
        Métrica/Inventário
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **HOST**
        </DoNotTranslate>
      </td>

      <td>
        Nome do host ou IP onde o MongoDB está rodando. O padrão é `localhost`.
      </td>

      <td>
        Métrica/Inventário
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **PORT**
        </DoNotTranslate>
      </td>

      <td>
        Porta na qual o MongoDB está escutando. O padrão é 27017.
      </td>

      <td>
        Métrica/Inventário
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **USERNAME**
        </DoNotTranslate>
      </td>

      <td>
        Nome de usuário para acessar o servidor MongoDB.
      </td>

      <td>
        Métrica/Inventário
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **PASSWORD**
        </DoNotTranslate>
      </td>

      <td>
        Senha do usuário fornecido.
      </td>

      <td>
        Métrica/Inventário
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **AUTH_SOURCE**
        </DoNotTranslate>
      </td>

      <td>
        O banco de dados para autenticação. O padrão é `admin`.
      </td>

      <td>
        Métrica/Inventário
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **SSL**
        </DoNotTranslate>
      </td>

      <td>
        Use SSL ao se comunicar com o servidor MongoDB. O padrão é `false`.
      </td>

      <td>
        Métrica/Inventário
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **SSL_CA_CERTS**
        </DoNotTranslate>
      </td>

      <td>
        Localização do certificado SSL no host. Obrigatório apenas se `SSL` for `true`.
      </td>

      <td>
        Métrica/Inventário
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **SSL_INSECURE_SKIP_VERIFY**
        </DoNotTranslate>
      </td>

      <td>
        Ignore a verificação da cadeia de certificados e do nome do host do servidor. O padrão é `false`.
      </td>

      <td>
        Métrica/Inventário
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **PEM_KEY_FILE**
        </DoNotTranslate>
      </td>

      <td>
        Localização do arquivo PEM contendo a chave privada e o certificado do cliente.
      </td>

      <td>
        Métrica/Inventário
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **PASSPHRASE**
        </DoNotTranslate>
      </td>

      <td>
        Senha para descriptografar o arquivo `PEMKeyFile` .
      </td>

      <td>
        Métrica/Inventário
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **CONCURRENT_COLLECTIONS**
        </DoNotTranslate>
      </td>

      <td>
        Número de entidades para as quais recolher métricas concomitantemente. O padrão é 50.
      </td>

      <td>
        Métrica
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **FILTERS**
        </DoNotTranslate>
      </td>

      <td>
        Um mapa JSON de nomes de bancos de dados para uma matriz de nomes de coleções. Se estiver vazio, o padrão é todos os bancos de dados e coleções.
      </td>

      <td>
        Métrica
      </td>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **METRICS**
        </DoNotTranslate>
      </td>

      <td>
        Defina como `true` para ativar a coleta somente de métricas. O padrão é `false`.
      </td>

      <td/>
    </tr>

    <tr>
      <td>
        <DoNotTranslate>
          **INVENTORY**
        </DoNotTranslate>
      </td>

      <td>
        Defina como `true` para ativar a coleta somente de inventário. O padrão é `false`.
      </td>

      <td/>
    </tr>
  </tbody>
</table>

### Etiquetas e atributo personalizado [#labels]

Você pode decorar ainda mais sua métrica usando etiquetas. Os rótulos permitem que você adicione atributo de par de valor principal à sua métrica, que você pode usar para consultar, filtrar ou agrupar sua métrica.

Nosso arquivo de configuração de amostra padrão inclui exemplos de rótulos; entretanto, como não são obrigatórios, você pode remover, modificar ou adicionar novos de sua preferência.

```
 labels:
   env: production
   role: load_balancer
```

## Exemplo de configuração [#examples]

<CollapserGroup>
  <Collapser
    id="basic-config"
    title="Configuração básica"
  >
    Esta é a configuração básica usada para coletar métricas e inventário do seu localhost:

    ```
    integrations:
      - name: nri-mongodb
        env:
          CLUSTER_NAME: my_cluster
          HOST: localhost
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          environment: production
        inventory_source: config/mongodb
    ```
  </Collapser>

  <Collapser
    id="basic-intervals"
    title="Configuração básica com diferentes intervalos métricos/inventário"
  >
    Esta configuração coleta métricas a cada 15 segundos e inventário a cada 60 segundos:

    ```
    integrations:
      - name: nri-mongodb
        env:
          METRICS: true
          CLUSTER_NAME: my_cluster
          HOST: localhost
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          environment: production

      - name: nri-mongodb
        env:
          INVENTORY: true
          CLUSTER_NAME: my_cluster
          HOST: localhost
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 60s
        labels:
          environment: production
        inventory_source: config/mongodb
    ```
  </Collapser>

  <Collapser
    id="envvar-replacement"
    title="Substituição de variáveis de ambiente"
  >
    Nesta configuração estamos usando a variável de ambiente `MONGODB_HOST` para preencher a configuração HOST da integração:

    ```
    integrations:
      - name: nri-mongodb
        env:
          METRICS: "true"
          CLUSTER_NAME: my_cluster
          HOST: {{MONGODB_HOST}}
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
    ```
  </Collapser>

  <Collapser
    id="filters"
    title="Filtros"
  >
    Nesta configuração estamos usando filtros para restringir o banco de dados e as coleções que monitor. Com este filtro de amostra a integração irá coletar:

    * `db1` banco de dados métricos e todas as suas coleções. Use `null` para coletar todas as coleções de um banco de dados

    * `db2` banco de dados métrica e métrica para `collection1` e `collection2`

    * `db3` banco de dados métrico e sem métrica de cobrança. Use uma matriz vazia `[]` se quiser pular a métrica da coleção

      ```
      integrations:
        - name: nri-mongodb
          env:
            METRICS: "true"
            CLUSTER_NAME: my_cluster
            HOST: localhost
            PORT: 27017
            USERNAME: mongodb_user
            PASSWORD: mongodb_password
            FILTERS: '{"db1":null,"db2":["collection1","collection2"],"db3:":[]}'
          interval: 15s
          labels:
            env: production
            role: load_balancer
      ```
  </Collapser>

  <Collapser
    id="multi-instance"
    title="Monitoramento Multi-instância"
  >
    Nesta configuração estamos monitorando múltiplos servidores MongoDB a partir da mesma integração. Para a primeira instância (`HOST: 1st_mongodb_host`) estamos coletando métrica e inventário enquanto para a segunda instância (`HOST: 2nd_mongodb_host`) coletaremos apenas métrica.

    ```
    integrations:
      - name: nri-mongodb
        env:
          METRICS: "true"
          CLUSTER_NAME: my_cluster
          HOST: 1st_mongodb_host
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
      - name: nri-mongodb
        env:
          INVENTORY: "true"
          CLUSTER_NAME: my_cluster
          HOST: 1st_mongodb_host
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 60s
        labels:
          env: production
          role: load_balancer
        inventory_source: config/mongodb

      - name: nri-mongodb
        env:
          METRICS: "true"
          CLUSTER_NAME: my_2nd_cluster
          HOST: 2nd_mongodb_host
          PORT: 27017
          USERNAME: mongodb_user
          PASSWORD: mongodb_password
        interval: 15s
        labels:
          env: production
          role: load_balancer
    ```
  </Collapser>
</CollapserGroup>

## Encontre e use dados [#find-and-use]

Os dados deste serviço são reportados para um [dashboard de integração](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts).

métrica estão anexadas a estes [tipos de eventos](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic):

* `MongoCollectionSample`
* `MongoConfigServerSample`
* `MongoDatabaseSample`
* `MongodTopSample`
* `MongoSample`
* `MongodSample`
* `MongosSample`

Você pode [consultar esses dados](/docs/using-new-relic/data/understand-data/query-new-relic-data) para fins de resolução de problemas ou para criar gráficos e dashboards personalizados.

Para saber mais sobre como encontrar e usar seus dados, consulte [Compreender os dados de integração](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Dados métricos [#metrics]

A integração MongoDB coleta os seguintes dados métricos atributo. Alguns nomes de métricas são prefixados com um indicador de categoria e um ponto, como `asserts.` ou `collection.`.

Diferentes métricas estão disponíveis dependendo se um cluster ou uma instância autônoma está sendo monitorada. Para uma instância autônoma, apenas [MongodSample](#mongod-clamshell), [MongoDatabaseSample](#mongo-database-clamshell), [MongodTopSample](#mongo-top-clamshell) e [MongoCollectionSample](#mongo-collection-clamshell) são coletados. Para um cluster, todos os tipos de eventos são coletados.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="mongo-collection-clamshell"
    title="Métrica de amostra de coleção Mongo"
  >
    Estes atributos estão anexados ao tipo de evento `MongoCollectionSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `collection.avgObjSizeInBytes`
          </td>

          <td>
            O tamanho do objeto médio na coleção, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `collection.capped`
          </td>

          <td>
            Se a coleção é limitada ou não.
          </td>
        </tr>

        <tr>
          <td>
            `collection.count`
          </td>

          <td>
            O número total de objetos na coleção.
          </td>
        </tr>

        <tr>
          <td>
            `collection.indexAccesses`
          </td>

          <td>
            O número de vezes que o índice foi usado.
          </td>
        </tr>

        <tr>
          <td>
            `collection.indexSizeInBytes`
          </td>

          <td>
            O tamanho do índice, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `collection.max`
          </td>

          <td>
            O número máximo de documentos em uma coleção limitada.
          </td>
        </tr>

        <tr>
          <td>
            `collection.maxSizeInBytes`
          </td>

          <td>
            O tamanho máximo de uma coleção limitada, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `collection.nindexes`
          </td>

          <td>
            O número total de índices na coleção.
          </td>
        </tr>

        <tr>
          <td>
            `collection.sizeInBytes`
          </td>

          <td>
            O tamanho total dos dados na coleção mais o tamanho de todos os índices da coleção, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `collection.storageSizeInBytes`
          </td>

          <td>
            O espaço de armazenamento total alocado a esta coleção para armazenamento de documentos, em bytes.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongo-config-server-clamshell"
    title="Métrica de amostra do servidor de configuração Mongo"
  >
    Estes atributos estão anexados ao tipo de evento `MongoConfigServerSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `asserts.messagesPerSecond`
          </td>

          <td>
            O número de asserções de mensagens geradas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.regularPerSecond`
          </td>

          <td>
            O número de asserções regulares levantadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.rolloversPerSecond`
          </td>

          <td>
            O número de vezes que os contadores de rollover são revertidos. Os contadores zeram a cada 2^30 asserções por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.userPerSecond`
          </td>

          <td>
            O número de asserções do usuário geradas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.warningPerSecond`
          </td>

          <td>
            O número de avisos gerados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countFailedPerSecond`
          </td>

          <td>
            O número de vezes que `count` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countPerSecond`
          </td>

          <td>
            O número de vezes `count` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesFailedPerSecond`
          </td>

          <td>
            O número de vezes que `createIndexes` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesPerSecond`
          </td>

          <td>
            O número de vezes `createIndexe` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deleteFailedPerSecond`
          </td>

          <td>
            O número de vezes que `delete` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deletePerSecond`
          </td>

          <td>
            O número de vezes `delete` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalFailedPerSecond`
          </td>

          <td>
            O número de vezes que `eval` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalPerSecond`
          </td>

          <td>
            O número de vezes `eval` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyFailedPerSecond`
          </td>

          <td>
            O número de vezes que `findAndModify` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyPerSecond`
          </td>

          <td>
            O número de vezes `findAndModify` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertFailedPerSecond`
          </td>

          <td>
            O número de vezes que `insert` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertPerSecond`
          </td>

          <td>
            O número de vezes `insert` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updateFailedPerSecond`
          </td>

          <td>
            O número de vezes que `update` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updatePerSecond`
          </td>

          <td>
            O número de vezes `update` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `connections.available`
          </td>

          <td>
            O número de conexões de entrada disponíveis não utilizadas que o banco de dados pode fornecer.
          </td>
        </tr>

        <tr>
          <td>
            `connections.current`
          </td>

          <td>
            O número de conexões de clientes com o servidor de banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `connections.totalCreated`
          </td>

          <td>
            O número total de conexões criadas.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openNoTimeout`
          </td>

          <td>
            O número de cursores abertos com a opção `DBQueryOptionnotimeout` definida para evitar o tempo limite após um período de inatividade.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openPinned`
          </td>

          <td>
            O número de cursores abertos fixados.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openTotal`
          </td>

          <td>
            O número de cursores que o MongoDB mantém para clientes.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.timedOutPerSecond`
          </td>

          <td>
            O número total de cursores que atingiram o tempo limite desde o início do processo do servidor.
          </td>
        </tr>

        <tr>
          <td>
            `document.deletedPerSecond`
          </td>

          <td>
            O número de documentos excluídos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.insertedPerSecond`
          </td>

          <td>
            O número de documentos inseridos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.returnedPerSecond`
          </td>

          <td>
            O número de documentos retornados pela consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.updatedPerSecond`
          </td>

          <td>
            O número de documentos atualizados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commits`
          </td>

          <td>
            O número de transações gravadas no diário durante o último intervalo de confirmação do grupo de diários.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto para confirmações, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLock`
          </td>

          <td>
            A contagem das confirmações que ocorreram enquanto um bloqueio de gravação foi mantido.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLockInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto para confirmações que ocorreram enquanto um bloqueio de gravação foi mantido, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.compression`
          </td>

          <td>
            A taxa de compactação dos dados gravados no diário.
          </td>
        </tr>

        <tr>
          <td>
            `dur.dataWrittenJournalDataFilesInBytes`
          </td>

          <td>
            A quantidade de dados gravados do diário nos arquivos de dados durante o último intervalo de confirmação do grupo de diários, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.earlyCommits`
          </td>

          <td>
            O número de vezes que o MongoDB solicitou uma confirmação antes do intervalo agendado de confirmação do grupo de diários.
          </td>
        </tr>

        <tr>
          <td>
            `dur.journaledInBytes`
          </td>

          <td>
            A quantidade de dados gravados no diário durante o último intervalo de confirmação do grupo de diários, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.preparingInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto na preparação para escrever no diário, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.remappingInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto no remapeamento de visualizações mapeadas de memória de cópia na gravação, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.timeCollectedCommitsInMilliseconds`
          </td>

          <td>
            O período de tempo durante o qual o MongoDB coletou os dados `durcommitsInMilliseconds`, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingDataFilesInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto na gravação em arquivos de dados após o registro no diário, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingJournalInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto escrevendo no diário, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.averageInMilliseconds`
          </td>

          <td>
            O tempo médio para cada liberação no disco, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.flushesDisk`
          </td>

          <td>
            O número de vezes que o banco de dados liberou todas as gravações no disco.
          </td>
        </tr>

        <tr>
          <td>
            `flush.lastInMilliseconds`
          </td>

          <td>
            O tempo que a última operação de liberação levou para ser concluída, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.totalInMilliseconds`
          </td>

          <td>
            A quantidade total de tempo que os processos mongod gastaram gravando (ou seja, liberando) dados no disco, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeMillisPerSecond`
          </td>

          <td>
            O número de operações `getLastError` com uma preocupação de gravação especificada (por exemplo, `w`) que aguardam que um ou mais membros de um conjunto de réplicas reconheçam a operação de gravação por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeoutsPerSecond`
          </td>

          <td>
            O número de vezes que as operações de gravação de preocupação atingiram o tempo limite como resultado do limite de tempo limite de `getLastError` por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsReaders`
          </td>

          <td>
            A contagem das conexões ativas do cliente que executam operações de leitura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsTotal`
          </td>

          <td>
            O número total de conexões de cliente ativas com o banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsWriters`
          </td>

          <td>
            A contagem de conexões de clientes ativas que executam operações de gravação.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueReaders`
          </td>

          <td>
            O número de operações que estão atualmente na fila e aguardando o bloqueio de leitura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueTotal`
          </td>

          <td>
            O número total de operações enfileiradas aguardando o bloqueio.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueWriters`
          </td>

          <td>
            O número de operações que estão atualmente na fila e aguardando o bloqueio de gravação.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.totaltime`
          </td>

          <td>
            O tempo desde a última inicialização do banco de dados e criação do bloqueio global.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de coleção foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de coleção foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de coleção foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de coleção foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de coleção no modo Exclusivo (X) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de coleção no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de coleção no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de coleção no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do banco de dados foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de banco de dados foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de banco de dados foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do banco de dados foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de banco de dados no modo Exclusivo (X) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de banco de dados no modo Intent Exclusive (IX) encontrou esperas porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de banco de dados no modo Intent Shared (IS) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de banco de dados no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de banco de dados no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio de banco de dados no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de banco de dados no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de banco de dados no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio global foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio global foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio global foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio global foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio global no modo Exclusivo (X) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio global no modo Intent Exclusive (IX) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio global no modo Intent Shared (IS) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio global no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio global no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio global no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio global no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio global no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de metadados foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de metadados foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do mecanismo de armazenamento MMAPv1 foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do mecanismo de armazenamento MMAPv1 foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do mecanismo de armazenamento MMAPv1 foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do mecanismo de armazenamento MMAPv1 foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Exclusivo (X) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Intent Exclusive (IX) encontrou esperas porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Intent Shared (IS) encontrou esperas porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio oplog foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de oplog foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio oplog foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio oplog foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitIntentExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio oplog no modo Intent Exclusive (IX) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio oplog no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio oplog no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo bloqueio oplog no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `mem.bits`
          </td>

          <td>
            O tamanho do mecanismo de armazenamento na memória.
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedInBytes`
          </td>

          <td>
            A quantidade de memória mapeada pelo banco de dados, em mebibyte (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedWithJournalInBytes`
          </td>

          <td>
            A quantidade de memória mapeada, incluindo a memória usada para registro em diário, em mebibyte (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.residentInBytes`
          </td>

          <td>
            A quantidade de memória usada atualmente pelo processo de banco de dados, em mebibyte (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.virtualInBytes`
          </td>

          <td>
            A quantidade de memória virtual usada pelo processo mongod, em mebibyte (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesInPerSecond`
          </td>

          <td>
            O número de bytes que reflete a quantidade de tráfego de rede neste banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesOutPerSecond`
          </td>

          <td>
            O número de bytes que reflete a quantidade de tráfego de rede enviado deste banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `network.requestsPerSecond`
          </td>

          <td>
            O número de solicitações distintas que o servidor recebeu.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.commandPerSecond`
          </td>

          <td>
            O número total de comandos emitidos para o banco de dados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.deletePerSecond`
          </td>

          <td>
            O número de operações de exclusão por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.getmorePerSecond`
          </td>

          <td>
            O número de operações getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.insertPerSecond`
          </td>

          <td>
            O número de operações de inserção por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.queryPerSecond`
          </td>

          <td>
            O número total de consultas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.updatePerSecond`
          </td>

          <td>
            O número de operações de atualização por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.commandPerSecond`
          </td>

          <td>
            O número total de comandos replicados emitidos para o banco de dados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.deletePerSecond`
          </td>

          <td>
            O número de operações de exclusão replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.getmorePerSecond`
          </td>

          <td>
            O número de operações getmore replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.insertPerSecond`
          </td>

          <td>
            O número de operações de inserção replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.queryPerSecond`
          </td>

          <td>
            O número total de consultas replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.updatePerSecond`
          </td>

          <td>
            O número de operações de atualização replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.fastmodPerSecond`
          </td>

          <td>
            O número de operações de atualização que não causam o crescimento dos documentos nem exigem atualizações no índice por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.idhackPerSecond`
          </td>

          <td>
            O número de consultas que contêm o campo `_id` por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.scanAndOrderPerSecond`
          </td>

          <td>
            O número de consultas que retornam números classificados que não podem realizar a operação de classificação usando um índice por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.writeConflictsPerSecond`
          </td>

          <td>
            O número de vezes que as operações de gravação encontraram um conflito por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `pageFaultsPerSecond`
          </td>

          <td>
            O número de falhas de página que exigem operações de disco por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `queryexecutor.scannedPerSecond`
          </td>

          <td>
            O número de itens de índice verificados durante a consulta e avaliação do plano de consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `record.movesPerSecond`
          </td>

          <td>
            O número de vezes que os documentos são movidos dentro da representação em disco do conjunto de dados MongoDB por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.batchesPerSecond`
          </td>

          <td>
            O número de lotes aplicados em todo o banco de dados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.operationsPerSecond`
          </td>

          <td>
            O número de operações oplog aplicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.count`
          </td>

          <td>
            O número de operações no buffer de oplog.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.maxSizeInBytes`
          </td>

          <td>
            O tamanho máximo do buffer, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.sizeInBytes`
          </td>

          <td>
            O tamanho atual do conteúdo do buffer de oplog, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsLoadedPrefetch`
          </td>

          <td>
            O número de documentos carregados durante o estágio de pré-busca da replicação.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsPreloadInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto no carregamento de documentos como parte do estágio de pré-busca da replicação, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexLoadedPrefetch`
          </td>

          <td>
            O número de entradas de índice carregadas pelos membros antes de atualizar os documentos como parte do estágio de pré-busca da replicação.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexPreloadInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto no carregamento de índices como parte do estágio de pré-busca da replicação, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.bytesPerSecond`
          </td>

          <td>
            A quantidade de dados lidos da origem de sincronização de replicação por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.getmoresPerSecond`
          </td>

          <td>
            O número de operações getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.operationPerSecond`
          </td>

          <td>
            O número de operações lidas da origem de replicação por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.readersCreatedPerSecond`
          </td>

          <td>
            O número de processos de consulta oplog criados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `replset.health`
          </td>

          <td>
            O valor de integridade do membro do conjunto de réplicas: informa se o membro está ativo (`1`) ou inativo (`0`).
          </td>
        </tr>

        <tr>
          <td>
            `replset.isArbiter`
          </td>

          <td>
            `1` se o mongod for um árbitro, `0` caso contrário.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isHidden`
          </td>

          <td>
            `1` se o mongod estiver oculto, `0` caso contrário.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isMaster`
          </td>

          <td>
            `1` se o mongod for o mestre atual, `0` caso contrário.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isSecondary`
          </td>

          <td>
            `1` se o mongod for atualmente secundário, `0` caso contrário.
          </td>
        </tr>

        <tr>
          <td>
            `replset.priority`
          </td>

          <td>
            A prioridade eleitoral do mongod.
          </td>
        </tr>

        <tr>
          <td>
            `replset.replicationLag`
          </td>

          <td>
            O atraso entre uma operação de gravação no primário e sua cópia no secundário.
          </td>
        </tr>

        <tr>
          <td>
            `replset.state`
          </td>

          <td>
            O estado de uma réplica que reflete sua disposição dentro do conjunto.
          </td>
        </tr>

        <tr>
          <td>
            `replset.uptimeInMilliseconds`
          </td>

          <td>
            O número de segundos que o processo mongos ou mongod esteve ativo, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `replset.voteFraction`
          </td>

          <td>
            A fração de votos que um servidor lançará em uma eleição de conjunto de réplicas.
          </td>
        </tr>

        <tr>
          <td>
            `replset.votes`
          </td>

          <td>
            O número de votos que um servidor dará em uma eleição de conjunto de réplicas.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.deleteDocumentsPerSecond`
          </td>

          <td>
            O número de documentos excluídos de coleções com índice ttl por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.removeDocumentPerSecond`
          </td>

          <td>
            O número de vezes que o processo em segundo plano remove documentos de coleções com um índice ttl por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheDirtyDataInBytes`
          </td>

          <td>
            O tamanho dos dados sujos no cache, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInBytes`
          </td>

          <td>
            O tamanho dos dados atualmente em cache, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInMemoryPageSplits`
          </td>

          <td>
            A página na memória se divide.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxInBytes`
          </td>

          <td>
            O tamanho máximo do cache, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxPageSizeEvictionInBytes`
          </td>

          <td>
            O tamanho máximo da página na remoção, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheModifiedPagesEvicted`
          </td>

          <td>
            O número de páginas que foram modificadas e removidas do cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedApplicationThreadsPerSecond`
          </td>

          <td>
            O número de páginas removidas por threads do aplicativo por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedInMemoryMaxPerSecond`
          </td>

          <td>
            O número de páginas removidas porque excederam o máximo do cache na memória, por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesHeld`
          </td>

          <td>
            O número de páginas atualmente mantidas no cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheUnmodifiedPagesEvicted`
          </td>

          <td>
            O número de páginas que não foram modificadas e removidas do cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadAvailable`
          </td>

          <td>
            O número de tickets de leitura disponíveis (transações simultâneas) restantes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadRemaining`
          </td>

          <td>
            O número de tickets lidos (transações simultâneas) em uso.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadTotal`
          </td>

          <td>
            O número total de tickets de leitura (transações simultâneas) disponíveis.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteAvailable`
          </td>

          <td>
            O número de tickets de gravação disponíveis (transações simultâneas) restantes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteRemaining`
          </td>

          <td>
            O número de tickets de gravação (transações simultâneas) em uso.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteTotal`
          </td>

          <td>
            O número total de tickets de gravação (transações simultâneas) disponíveis.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.failedEvictionsPagesPerSecond`
          </td>

          <td>
            O número de falhas na remoção de páginas que excederam o máximo na memória, por segundo.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongo-database-clamshell"
    title="Mongo banco de dados amostra métrica"
  >
    Estes atributos estão anexados ao tipo de evento `MongoDatabaseSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `stats.dataInBytes`
          </td>

          <td>
            O tamanho total dos dados mantidos neste banco de dados, incluindo o fator de preenchimento, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `stats.indexes`
          </td>

          <td>
            O número total de índices em todas as coleções do banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `stats.indexInBytes`
          </td>

          <td>
            O tamanho total de todos os índices criados neste banco de dados, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `stats.objects`
          </td>

          <td>
            O número de objetos (documentos) no banco de dados em todas as coleções.
          </td>
        </tr>

        <tr>
          <td>
            `stats.storageInBytes`
          </td>

          <td>
            A quantidade total de espaço alocado para coleções neste banco de dados para armazenamento de documentos, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `totalDatabases`
          </td>

          <td>
            O número total de banco de dados existente.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongod-top-clamshell"
    title="Métrica de amostra principal do Mongo"
  >
    Estes atributos estão anexados ao tipo de evento `MongodTopSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `usage.commandsInMillisecondsPerSecond`
          </td>

          <td>
            O tempo total gasto na execução de comandos, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.commandsPerSecond`
          </td>

          <td>
            O número de comandos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.getmoreInMillisecondsPerSecond`
          </td>

          <td>
            O tempo total gasto na execução do getmore, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.getmorePerSecond`
          </td>

          <td>
            O número de getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.insertInMillisecondsPerSecond`
          </td>

          <td>
            O tempo total gasto na execução de inserções, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.insertPerSecond`
          </td>

          <td>
            O número de inserções por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.queriesInMillisecondsPerSecond`
          </td>

          <td>
            O tempo total gasto na realização da consulta, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.queriesPerSecond`
          </td>

          <td>
            O número de consultas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.readLockInMillisecondsPerSecond`
          </td>

          <td>
            O tempo total gasto na execução de bloqueios de leitura, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.readLockPerSecond`
          </td>

          <td>
            O número de bloqueios de leitura por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.removeInMillisecondsPerSecond`
          </td>

          <td>
            O tempo total gasto na execução de remoções, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.removePerSecond`
          </td>

          <td>
            O número de remoções por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.totalInMillisecondsPerSecond`
          </td>

          <td>
            O tempo total gasto na execução de operações, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.totalPerSecond`
          </td>

          <td>
            O número de operações por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.updateInMillisecondsPerSecond`
          </td>

          <td>
            O tempo total gasto na execução de atualizações, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.updatePerSecond`
          </td>

          <td>
            O número de atualizações por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `usage.writeLockInMillisecondsPerSecond`
          </td>

          <td>
            O tempo total gasto na execução de bloqueios de gravação, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `usage.writeLockPerSecond`
          </td>

          <td>
            O número de bloqueios de gravação por segundo.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongo-clamshell"
    title="Métrica de amostra Mongo"
  >
    Estes atributos estão anexados ao tipo de evento `MongoSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `totalDatabases`
          </td>

          <td>
            O número de banco de dados no cluster.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongod-clamshell"
    title="Métrica de amostra Mongod"
  >
    Estes atributos estão anexados ao tipo de evento `MongodSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `asserts.messagesPerSecond`
          </td>

          <td>
            O número de asserções de mensagens geradas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.regularPerSecond`
          </td>

          <td>
            O número de asserções regulares levantadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.rolloversPerSecond`
          </td>

          <td>
            O número de vezes que os contadores de rollover são revertidos. Os contadores zeram a cada 2^30 asserções por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.userPerSecond`
          </td>

          <td>
            O número de asserções do usuário geradas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.warningPerSecond`
          </td>

          <td>
            O número de avisos gerados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countFailedPerSecond`
          </td>

          <td>
            O número de vezes que `count` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countPerSecond`
          </td>

          <td>
            O número de vezes `count` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesFailedPerSecond`
          </td>

          <td>
            O número de vezes que `createIndexes` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesPerSecond`
          </td>

          <td>
            O número de vezes `createIndexes` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deleteFailedPerSecond`
          </td>

          <td>
            O número de vezes que `delete` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deletePerSecond`
          </td>

          <td>
            O número de vezes `delete` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalFailedPerSecond`
          </td>

          <td>
            O número de vezes que `eval` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalPerSecond`
          </td>

          <td>
            O número de vezes `eval` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyFailedPerSecond`
          </td>

          <td>
            O número de vezes que `findAndModify` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyPerSecond`
          </td>

          <td>
            O número de vezes `findAndModify` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertFailedPerSecond`
          </td>

          <td>
            O número de vezes que `insert` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertPerSecond`
          </td>

          <td>
            O número de vezes `insert` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updateFailedPerSecond`
          </td>

          <td>
            O número de vezes que `update` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updatePerSecond`
          </td>

          <td>
            O número de vezes `update` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `connections.available`
          </td>

          <td>
            O número de conexões de entrada disponíveis não utilizadas que o banco de dados pode fornecer.
          </td>
        </tr>

        <tr>
          <td>
            `connections.current`
          </td>

          <td>
            O número de conexões de clientes com o servidor de banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `connections.totalCreated`
          </td>

          <td>
            O número total de conexões criadas.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openNoTimeout`
          </td>

          <td>
            O número de cursores abertos com a opção `DBQueryOptionnotimeout` definida para evitar o tempo limite após um período de inatividade.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openPinned`
          </td>

          <td>
            O número de cursores abertos fixados.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openTotal`
          </td>

          <td>
            O número de cursores que o MongoDB mantém para clientes.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.timedOutPerSecond`
          </td>

          <td>
            O número total de cursores que atingiram o tempo limite desde o início do processo do servidor.
          </td>
        </tr>

        <tr>
          <td>
            `document.deletedPerSecond`
          </td>

          <td>
            O número de documentos excluídos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.insertedPerSecond`
          </td>

          <td>
            O número de documentos inseridos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.returnedPerSecond`
          </td>

          <td>
            O número de documentos retornados pela consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.updatedPerSecond`
          </td>

          <td>
            O número de documentos atualizados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commits`
          </td>

          <td>
            O número de transações gravadas no diário durante o último intervalo de confirmação do grupo de diários.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto para confirmações, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLock`
          </td>

          <td>
            A contagem das confirmações que ocorreram enquanto um bloqueio de gravação foi mantido.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLockInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto para confirmações que ocorreram enquanto um bloqueio de gravação foi mantido, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.compression`
          </td>

          <td>
            A taxa de compactação dos dados gravados no diário.
          </td>
        </tr>

        <tr>
          <td>
            `dur.dataWrittenJournalDataFilesInBytes`
          </td>

          <td>
            A quantidade de dados gravados do diário nos arquivos de dados durante o último intervalo de confirmação do grupo de diários, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.earlyCommits`
          </td>

          <td>
            O número de vezes que o MongoDB solicitou uma confirmação antes do intervalo agendado de confirmação do grupo de diários.
          </td>
        </tr>

        <tr>
          <td>
            `dur.journaledInBytes`
          </td>

          <td>
            A quantidade de dados gravados no diário durante o último intervalo de confirmação do grupo de diários, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.preparingInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto na preparação para escrever no diário, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.remappingInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto no remapeamento de visualizações mapeadas de memória de cópia na gravação, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.timeCollectedCommitsInMilliseconds`
          </td>

          <td>
            O período de tempo durante o qual o MongoDB coletou os dados `durcommitsInMilliseconds`, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingDataFilesInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto na gravação em arquivos de dados após o registro no diário, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingJournalInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto escrevendo no diário, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.averageInMilliseconds`
          </td>

          <td>
            O tempo médio para cada liberação no disco, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.flushesDisk`
          </td>

          <td>
            O número de vezes que o banco de dados liberou todas as gravações no disco.
          </td>
        </tr>

        <tr>
          <td>
            `flush.lastInMilliseconds`
          </td>

          <td>
            O tempo que a última operação de liberação levou para ser concluída, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.totalInMilliseconds`
          </td>

          <td>
            A quantidade total de tempo que os processos mongod gastaram gravando (ou seja, liberando) dados no disco, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeMillisPerSecond`
          </td>

          <td>
            O número de operações `getLastError` com uma preocupação de gravação especificada (por exemplo, `w`) que aguardam que um ou mais membros de um conjunto de réplicas reconheçam a operação de gravação por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeoutsPerSecond`
          </td>

          <td>
            O número de vezes que as operações de gravação de preocupação atingiram o tempo limite como resultado do limite de tempo limite de `getLastError` por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsReaders`
          </td>

          <td>
            A contagem das conexões ativas do cliente que executam operações de leitura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsTotal`
          </td>

          <td>
            O número total de conexões de cliente ativas com o banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsWriters`
          </td>

          <td>
            A contagem de conexões de clientes ativas que executam operações de gravação.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueReaders`
          </td>

          <td>
            O número de operações que estão atualmente na fila e aguardando o bloqueio de leitura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueTotal`
          </td>

          <td>
            O número total de operações enfileiradas aguardando o bloqueio.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueWriters`
          </td>

          <td>
            O número de operações que estão atualmente na fila e aguardando o bloqueio de gravação.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.totaltime`
          </td>

          <td>
            O tempo desde a última inicialização do banco de dados e criação do bloqueio global.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de coleção foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de coleção foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de coleção foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de coleção foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de coleção no modo Exclusivo (X) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de coleção no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de coleção no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de coleção no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do banco de dados foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de banco de dados foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de banco de dados foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do banco de dados foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de banco de dados no modo Exclusivo (X) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de banco de dados no modo Intent Exclusive (IX) encontrou esperas porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de banco de dados no modo Intent Shared (IS) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de banco de dados no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de banco de dados no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio de banco de dados no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de banco de dados no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de banco de dados no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio global foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio global foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio global foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio global foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio global no modo Exclusivo (X) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio global no modo Intent Exclusive (IX) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio global no modo Intent Shared (IS) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio global no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio global no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio global no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio global no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio global no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de metadados foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de metadados foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do mecanismo de armazenamento MMAPv1 foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do mecanismo de armazenamento MMAPv1 foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do mecanismo de armazenamento MMAPv1 foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do mecanismo de armazenamento MMAPv1 foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Exclusivo (X) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Intent Exclusive (IX) encontrou esperas porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Intent Shared (IS) encontrou esperas porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio oplog foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de oplog foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio oplog foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio oplog foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitIntentExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio oplog no modo Intent Exclusive (IX) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio oplog no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio oplog no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo bloqueio oplog no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `mem.bits`
          </td>

          <td>
            O tamanho do mecanismo de armazenamento na memória.
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedInBytes`
          </td>

          <td>
            A quantidade de memória mapeada pelo banco de dados, em mebibyte (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedWithJournalInBytes`
          </td>

          <td>
            A quantidade de memória mapeada, incluindo a memória usada para registro em diário, em mebibyte (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.residentInBytes`
          </td>

          <td>
            A quantidade de memória usada atualmente pelo processo de banco de dados, em mebibyte (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.virtualInBytes`
          </td>

          <td>
            A quantidade de memória virtual usada pelo processo mongod, em mebibyte (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesInPerSecond`
          </td>

          <td>
            O número de bytes que reflete a quantidade de tráfego de rede neste banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesOutPerSecond`
          </td>

          <td>
            O número de bytes que reflete a quantidade de tráfego de rede enviado deste banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `network.requestsPerSecond`
          </td>

          <td>
            O número de solicitações distintas que o servidor recebeu.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.commandPerSecond`
          </td>

          <td>
            O número total de comandos emitidos para o banco de dados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.deletePerSecond`
          </td>

          <td>
            O número de operações de exclusão por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.getmorePerSecond`
          </td>

          <td>
            O número de operações getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.insertPerSecond`
          </td>

          <td>
            O número de operações de inserção por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.queryPerSecond`
          </td>

          <td>
            O número total de consultas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.updatePerSecond`
          </td>

          <td>
            O número de operações de atualização por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.commandPerSecond`
          </td>

          <td>
            O número total de comandos replicados emitidos para o banco de dados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.deletePerSecond`
          </td>

          <td>
            O número de operações de exclusão replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.getmorePerSecond`
          </td>

          <td>
            O número de operações getmore replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.insertPerSecond`
          </td>

          <td>
            O número de operações de inserção replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.queryPerSecond`
          </td>

          <td>
            O número total de consultas replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.updatePerSecond`
          </td>

          <td>
            O número de operações de atualização replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.fastmodPerSecond`
          </td>

          <td>
            O número de operações de atualização que não causam o crescimento dos documentos nem exigem atualizações no índice por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.idhackPerSecond`
          </td>

          <td>
            O número de consultas que contêm o campo `_id` por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.scanAndOrderPerSecond`
          </td>

          <td>
            O número de consultas que retornam números classificados que não podem realizar a operação de classificação usando um índice por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.writeConflictsPerSecond`
          </td>

          <td>
            O número de vezes que as operações de gravação encontraram um conflito por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `pageFaultsPerSecond`
          </td>

          <td>
            O número de falhas de página que exigem operações de disco por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `queryexecutor.scannedPerSecond`
          </td>

          <td>
            O número de itens de índice verificados durante a consulta e avaliação do plano de consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `record.movesPerSecond`
          </td>

          <td>
            O número de vezes que os documentos são movidos dentro da representação em disco do conjunto de dados MongoDB por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.batchesPerSecond`
          </td>

          <td>
            O número de lotes aplicados em todo o banco de dados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.operationsPerSecond`
          </td>

          <td>
            O número de operações oplog aplicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.count`
          </td>

          <td>
            O número de operações no buffer de oplog.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.maxSizeInBytes`
          </td>

          <td>
            O tamanho máximo do buffer, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.sizeInBytes`
          </td>

          <td>
            O tamanho atual do conteúdo do buffer de oplog, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsLoadedPrefetch`
          </td>

          <td>
            O número de documentos carregados durante o estágio de pré-busca da replicação.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsPreloadInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto no carregamento de documentos como parte do estágio de pré-busca da replicação, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexLoadedPrefetch`
          </td>

          <td>
            O número de entradas de índice carregadas pelos membros antes de atualizar os documentos como parte do estágio de pré-busca da replicação.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexPreloadInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto no carregamento de índices como parte do estágio de pré-busca da replicação, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.bytesPerSecond`
          </td>

          <td>
            A quantidade de dados lidos da origem de sincronização de replicação por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.getmoresPerSecond`
          </td>

          <td>
            O número de operações getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.operationPerSecond`
          </td>

          <td>
            O número de operações lidas da origem de replicação por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.readersCreatedPerSecond`
          </td>

          <td>
            O número de processos de consulta oplog criados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `replset.health`
          </td>

          <td>
            O valor de integridade do membro do conjunto de réplicas: informa se o membro está ativo (`1`) ou inativo (`0`).
          </td>
        </tr>

        <tr>
          <td>
            `replset.isArbiter`
          </td>

          <td>
            `1` se o mongod for um árbitro, `0` caso contrário.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isHidden`
          </td>

          <td>
            `1` se o mongod estiver oculto, `0` caso contrário.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isMaster`
          </td>

          <td>
            `1` se o mongod for o mestre atual, `0` caso contrário.
          </td>
        </tr>

        <tr>
          <td>
            `replset.isSecondary`
          </td>

          <td>
            `1` se o mongod for atualmente secundário, `0` caso contrário.
          </td>
        </tr>

        <tr>
          <td>
            `replset.priority`
          </td>

          <td>
            A prioridade eleitoral do mongod.
          </td>
        </tr>

        <tr>
          <td>
            `replset.replicationLag`
          </td>

          <td>
            O atraso entre uma operação de gravação no primário e sua cópia no secundário.
          </td>
        </tr>

        <tr>
          <td>
            `replset.state`
          </td>

          <td>
            O estado de uma réplica que reflete sua disposição dentro do conjunto.
          </td>
        </tr>

        <tr>
          <td>
            `replset.uptimeInMilliseconds`
          </td>

          <td>
            O número de segundos que o processo mongos ou mongod esteve ativo, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `replset.voteFraction`
          </td>

          <td>
            A fração de votos que um servidor lançará em uma eleição de conjunto de réplicas.
          </td>
        </tr>

        <tr>
          <td>
            `replset.votes`
          </td>

          <td>
            O número de votos que um servidor dará em uma eleição de conjunto de réplicas.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.deleteDocumentsPerSecond`
          </td>

          <td>
            O número de documentos excluídos de coleções com índice ttl por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.removeDocumentPerSecond`
          </td>

          <td>
            O número de vezes que o processo em segundo plano remove documentos de coleções com um índice ttl por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheDirtyDataInBytes`
          </td>

          <td>
            O tamanho dos dados sujos no cache, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInBytes`
          </td>

          <td>
            O tamanho dos dados atualmente em cache, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInMemoryPageSplits`
          </td>

          <td>
            A página na memória se divide.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxInBytes`
          </td>

          <td>
            O tamanho máximo do cache, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxPageSizeEvictionInBytes`
          </td>

          <td>
            O tamanho máximo da página na remoção, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheModifiedPagesEvicted`
          </td>

          <td>
            O número de páginas que foram modificadas e removidas do cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedApplicationThreadsPerSecond`
          </td>

          <td>
            O número de páginas removidas por threads do aplicativo por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedInMemoryMaxPerSecond`
          </td>

          <td>
            O número de páginas removidas porque excederam o máximo do cache na memória, por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesHeld`
          </td>

          <td>
            O número de páginas atualmente mantidas no cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheUnmodifiedPagesEvicted`
          </td>

          <td>
            O número de páginas que não foram modificadas e removidas do cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadAvailable`
          </td>

          <td>
            O número de tickets de leitura disponíveis (transações simultâneas) restantes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadRemaining`
          </td>

          <td>
            O número de tickets lidos (transações simultâneas) em uso.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadTotal`
          </td>

          <td>
            O número total de tickets de leitura (transações simultâneas) disponíveis.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteAvailable`
          </td>

          <td>
            O número de tickets de gravação disponíveis (transações simultâneas) restantes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteRemaining`
          </td>

          <td>
            O número de tickets de gravação (transações simultâneas) em uso.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteTotal`
          </td>

          <td>
            O número total de tickets de gravação (transações simultâneas) disponíveis.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.failedEvictionsPagesPerSecond`
          </td>

          <td>
            O número de falhas na remoção de páginas que excederam o máximo na memória, por segundo.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    className="freq-link"
    id="mongos-clamshell"
    title="Métrica de amostra Mongos"
  >
    Estes atributos estão anexados ao tipo de evento `MongosSample` :

    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            Métrica
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `asserts.messagesPerSecond`
          </td>

          <td>
            O número de asserções de mensagens geradas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.regularPerSecond`
          </td>

          <td>
            O número de asserções regulares levantadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.rolloversPerSecond`
          </td>

          <td>
            O número de vezes que os contadores de rollover são revertidos. Os contadores zeram a cada 2^30 asserções por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.userPerSecond`
          </td>

          <td>
            O número de asserções do usuário geradas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `asserts.warningPerSecond`
          </td>

          <td>
            O número de avisos gerados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countFailedPerSecond`
          </td>

          <td>
            O número de vezes que `count` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.countPerSecond`
          </td>

          <td>
            O número de vezes `count` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesFailedPerSecond`
          </td>

          <td>
            O número de vezes que `createIndexes` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.createIndexesPerSecond`
          </td>

          <td>
            O número de vezes `createIndexes` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deleteFailedPerSecond`
          </td>

          <td>
            O número de vezes que `delete` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.deletePerSecond`
          </td>

          <td>
            O número de vezes `delete` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalFailedPerSecond`
          </td>

          <td>
            O número de vezes que `eval` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.evalPerSecond`
          </td>

          <td>
            O número de vezes `eval` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyFailedPerSecond`
          </td>

          <td>
            O número de vezes que `findAndModify` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.findAndModifyPerSecond`
          </td>

          <td>
            O número de vezes `findAndModify` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertFailedPerSecond`
          </td>

          <td>
            O número de vezes que `insert` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.insertPerSecond`
          </td>

          <td>
            O número de vezes `insert` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updateFailedPerSecond`
          </td>

          <td>
            O número de vezes que `update` falhou.
          </td>
        </tr>

        <tr>
          <td>
            `commands.updatePerSecond`
          </td>

          <td>
            O número de vezes `update` foi executado.
          </td>
        </tr>

        <tr>
          <td>
            `connections.available`
          </td>

          <td>
            O número de conexões de entrada disponíveis não utilizadas que o banco de dados pode fornecer.
          </td>
        </tr>

        <tr>
          <td>
            `connections.current`
          </td>

          <td>
            O número de conexões de clientes com o servidor de banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `connections.totalCreated`
          </td>

          <td>
            O número total de conexões criadas.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openNoTimeout`
          </td>

          <td>
            O número de cursores abertos com a opção `DBQueryOptionnotimeout` definida para evitar o tempo limite após um período de inatividade.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openPinned`
          </td>

          <td>
            O número de cursores abertos fixados.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.openTotal`
          </td>

          <td>
            O número de cursores que o MongoDB mantém para clientes.
          </td>
        </tr>

        <tr>
          <td>
            `cursor.timedOutPerSecond`
          </td>

          <td>
            O número total de cursores que atingiram o tempo limite desde o início do processo do servidor.
          </td>
        </tr>

        <tr>
          <td>
            `document.deletedPerSecond`
          </td>

          <td>
            O número de documentos excluídos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.insertedPerSecond`
          </td>

          <td>
            O número de documentos inseridos por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.returnedPerSecond`
          </td>

          <td>
            O número de documentos retornados pela consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `document.updatedPerSecond`
          </td>

          <td>
            O número de documentos atualizados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commits`
          </td>

          <td>
            O número de transações gravadas no diário durante o último intervalo de confirmação do grupo de diários.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto para confirmações, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLock`
          </td>

          <td>
            A contagem das confirmações que ocorreram enquanto um bloqueio de gravação foi mantido.
          </td>
        </tr>

        <tr>
          <td>
            `dur.commitsInWriteLockInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto para confirmações que ocorreram enquanto um bloqueio de gravação foi mantido, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.compression`
          </td>

          <td>
            A taxa de compactação dos dados gravados no diário.
          </td>
        </tr>

        <tr>
          <td>
            `dur.dataWrittenJournalDataFilesInBytes`
          </td>

          <td>
            A quantidade de dados gravados do diário nos arquivos de dados durante o último intervalo de confirmação do grupo de diários, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.earlyCommits`
          </td>

          <td>
            O número de vezes que o MongoDB solicitou uma confirmação antes do intervalo agendado de confirmação do grupo de diários.
          </td>
        </tr>

        <tr>
          <td>
            `dur.journaledInBytes`
          </td>

          <td>
            A quantidade de dados gravados no diário durante o último intervalo de confirmação do grupo de diários, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `dur.preparingInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto na preparação para escrever no diário, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.remappingInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto no remapeamento de visualizações mapeadas de memória de cópia na gravação, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.timeCollectedCommitsInMilliseconds`
          </td>

          <td>
            O período de tempo durante o qual o MongoDB coletou os dados `durcommitsInMilliseconds`, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingDataFilesInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto na gravação em arquivos de dados após o registro no diário, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `dur.writingJournalInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto escrevendo no diário, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.averageInMilliseconds`
          </td>

          <td>
            O tempo médio para cada liberação no disco, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.flushesDisk`
          </td>

          <td>
            O número de vezes que o banco de dados liberou todas as gravações no disco.
          </td>
        </tr>

        <tr>
          <td>
            `flush.lastInMilliseconds`
          </td>

          <td>
            O tempo que a última operação de liberação levou para ser concluída, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `flush.totalInMilliseconds`
          </td>

          <td>
            A quantidade total de tempo que os processos mongod gastaram gravando (ou seja, liberando) dados no disco, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeMillisPerSecond`
          </td>

          <td>
            O número de operações `getLastError` com uma preocupação de gravação especificada (por exemplo, `w`) que aguardam que um ou mais membros de um conjunto de réplicas reconheçam a operação de gravação por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `getlasterror.wtimeoutsPerSecond`
          </td>

          <td>
            O número de vezes que as operações de gravação de preocupação atingiram o tempo limite como resultado do limite de tempo limite de `getLastError` por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsReaders`
          </td>

          <td>
            A contagem das conexões ativas do cliente que executam operações de leitura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsTotal`
          </td>

          <td>
            O número total de conexões de cliente ativas com o banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.activeClientsWriters`
          </td>

          <td>
            A contagem de conexões de clientes ativas que executam operações de gravação.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueReaders`
          </td>

          <td>
            O número de operações que estão atualmente na fila e aguardando o bloqueio de leitura.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueTotal`
          </td>

          <td>
            O número total de operações enfileiradas aguardando o bloqueio.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.currentQueueWriters`
          </td>

          <td>
            O número de operações que estão atualmente na fila e aguardando o bloqueio de gravação.
          </td>
        </tr>

        <tr>
          <td>
            `globallock.totaltime`
          </td>

          <td>
            O tempo desde a última inicialização do banco de dados e criação do bloqueio global.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de coleção foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de coleção foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de coleção foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de coleção foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de coleção no modo Exclusivo (X) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionAcquireWaitCountShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de coleção no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de coleção no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.collectionTimeAcquiringMicrosShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de coleção no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do banco de dados foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de banco de dados foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de banco de dados foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do banco de dados foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de banco de dados no modo Exclusivo (X) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de banco de dados no modo Intent Exclusive (IX) encontrou esperas porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitIntentShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de banco de dados no modo Intent Shared (IS) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseAcquireWaitShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio de banco de dados no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de banco de dados no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio de banco de dados no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de banco de dados no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.databaseTimeAcquiringMicrosShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio de banco de dados no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio global foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio global foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio global foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio global foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio global no modo Exclusivo (X) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio global no modo Intent Exclusive (IX) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitIntentShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio global no modo Intent Shared (IS) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalAcquireWaitShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio global no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio global no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio global no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio global no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.globalTimeAcquiringMicrosShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo bloqueio global no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de metadados foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.metadataAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de metadados foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do mecanismo de armazenamento MMAPv1 foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do mecanismo de armazenamento MMAPv1 foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do mecanismo de armazenamento MMAPv1 foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio do mecanismo de armazenamento MMAPv1 foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Exclusivo (X) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Intent Exclusive (IX) encontrou esperas porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitIntentShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Intent Shared (IS) encontrou esperas porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalAcquireWaitShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            O tempo de espera para aquisições do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.mmapv1journalTimeAcquiringMicrosShared`
          </td>

          <td>
            O tempo de espera para aquisições do tipo de bloqueio do mecanismo de armazenamento MMAPv1 no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio oplog foi adquirido no modo Exclusivo (X).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentExclusive`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio de oplog foi adquirido no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireIntentShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio oplog foi adquirido no modo Intent Shared (IS).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireShared`
          </td>

          <td>
            O número de vezes que o tipo de bloqueio oplog foi adquirido no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitIntentExclusive`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio oplog no modo Intent Exclusive (IX) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogAcquireWaitShared`
          </td>

          <td>
            O número de vezes que a aquisição do tipo de bloqueio oplog no modo Compartilhado (S) encontrou espera porque os bloqueios foram mantidos em um modo conflitante.
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentExclusive`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo de bloqueio oplog no modo Intent Exclusive (IX).
          </td>
        </tr>

        <tr>
          <td>
            `locks.oplogTimeAcquiringMicrosIntentShared`
          </td>

          <td>
            O tempo de espera para as aquisições do tipo bloqueio oplog no modo Compartilhado (S).
          </td>
        </tr>

        <tr>
          <td>
            `mem.bits`
          </td>

          <td>
            O tamanho do mecanismo de armazenamento na memória.
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedInBytes`
          </td>

          <td>
            A quantidade de memória mapeada pelo banco de dados, em mebibyte (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.mappedWithJournalInBytes`
          </td>

          <td>
            A quantidade de memória mapeada, incluindo a memória usada para registro em diário, em mebibyte (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.residentInBytes`
          </td>

          <td>
            A quantidade de memória usada atualmente pelo processo de banco de dados, em mebibyte (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `mem.virtualInBytes`
          </td>

          <td>
            A quantidade de memória virtual usada pelo processo mongod, em mebibyte (MiB).
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesInPerSecond`
          </td>

          <td>
            O número de bytes que reflete a quantidade de tráfego de rede neste banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `network.bytesOutPerSecond`
          </td>

          <td>
            O número de bytes que reflete a quantidade de tráfego de rede enviado deste banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `network.requestsPerSecond`
          </td>

          <td>
            O número de solicitações distintas que o servidor recebeu.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.commandPerSecond`
          </td>

          <td>
            O número total de comandos emitidos para o banco de dados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.deletePerSecond`
          </td>

          <td>
            O número de operações de exclusão por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.getmorePerSecond`
          </td>

          <td>
            O número de operações getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.insertPerSecond`
          </td>

          <td>
            O número de operações de inserção por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.queryPerSecond`
          </td>

          <td>
            O número total de consultas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcounters.updatePerSecond`
          </td>

          <td>
            O número de operações de atualização por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.commandPerSecond`
          </td>

          <td>
            O número total de comandos replicados emitidos para o banco de dados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.deletePerSecond`
          </td>

          <td>
            O número de operações de exclusão replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.getmorePerSecond`
          </td>

          <td>
            O número de operações getmore replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.insertPerSecond`
          </td>

          <td>
            O número de operações de inserção replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.queryPerSecond`
          </td>

          <td>
            O número total de consultas replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `opcountersrepl.updatePerSecond`
          </td>

          <td>
            O número de operações de atualização replicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.fastmodPerSecond`
          </td>

          <td>
            O número de operações de atualização que não causam o crescimento dos documentos nem exigem atualizações no índice por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.idhackPerSecond`
          </td>

          <td>
            O número de consultas que contêm o campo `_id` por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.scanAndOrderPerSecond`
          </td>

          <td>
            O número de consultas que retornam números classificados que não podem realizar a operação de classificação usando um índice por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `operation.writeConflictsPerSecond`
          </td>

          <td>
            O número de vezes que as operações de gravação encontraram um conflito por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `pageFaultsPerSecond`
          </td>

          <td>
            O número de falhas de página que exigem operações de disco por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `queryexecutor.scannedPerSecond`
          </td>

          <td>
            O número de itens de índice verificados durante a consulta e avaliação do plano de consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `record.movesPerSecond`
          </td>

          <td>
            O número de vezes que os documentos são movidos dentro da representação em disco do conjunto de dados MongoDB por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.batchesPerSecond`
          </td>

          <td>
            O número de lotes aplicados em todo o banco de dados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.apply.operationsPerSecond`
          </td>

          <td>
            O número de operações oplog aplicadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.count`
          </td>

          <td>
            O número de operações no buffer de oplog.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.maxSizeInBytes`
          </td>

          <td>
            O tamanho máximo do buffer, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.buffer.sizeInBytes`
          </td>

          <td>
            O tamanho atual do conteúdo do buffer de oplog, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsLoadedPrefetch`
          </td>

          <td>
            O número de documentos carregados durante o estágio de pré-busca da replicação.
          </td>
        </tr>

        <tr>
          <td>
            `repl.docsPreloadInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto no carregamento de documentos como parte do estágio de pré-busca da replicação, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexLoadedPrefetch`
          </td>

          <td>
            O número de entradas de índice carregadas pelos membros antes de atualizar os documentos como parte do estágio de pré-busca da replicação.
          </td>
        </tr>

        <tr>
          <td>
            `repl.indexPreloadInMilliseconds`
          </td>

          <td>
            A quantidade de tempo gasto no carregamento de índices como parte do estágio de pré-busca da replicação, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.bytesPerSecond`
          </td>

          <td>
            A quantidade de dados lidos da origem de sincronização de replicação por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.getmoresPerSecond`
          </td>

          <td>
            O número de operações getmore por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.operationPerSecond`
          </td>

          <td>
            O número de operações lidas da origem de replicação por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `repl.network.readersCreatedPerSecond`
          </td>

          <td>
            O número de processos de consulta oplog criados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.deleteDocumentsPerSecond`
          </td>

          <td>
            O número de documentos excluídos de coleções com índice ttl por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `ttl.removeDocumentPerSecond`
          </td>

          <td>
            O número de vezes que o processo em segundo plano remove documentos de coleções com um índice ttl por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheDirtyDataInBytes`
          </td>

          <td>
            O tamanho dos dados sujos no cache, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInBytes`
          </td>

          <td>
            O tamanho dos dados atualmente em cache, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheInMemoryPageSplits`
          </td>

          <td>
            A página na memória se divide.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxInBytes`
          </td>

          <td>
            O tamanho máximo do cache, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheMaxPageSizeEvictionInBytes`
          </td>

          <td>
            O tamanho máximo da página na remoção, em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheModifiedPagesEvicted`
          </td>

          <td>
            O número de páginas que foram modificadas e removidas do cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedApplicationThreadsPerSecond`
          </td>

          <td>
            O número de páginas removidas por threads do aplicativo por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesEvictedInMemoryMaxPerSecond`
          </td>

          <td>
            O número de páginas removidas porque excederam o máximo do cache na memória, por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cachePagesHeld`
          </td>

          <td>
            O número de páginas atualmente mantidas no cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.cacheUnmodifiedPagesEvicted`
          </td>

          <td>
            O número de páginas que não foram modificadas e removidas do cache.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadAvailable`
          </td>

          <td>
            O número de tickets de leitura disponíveis (transações simultâneas) restantes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadRemaining`
          </td>

          <td>
            O número de tickets lidos (transações simultâneas) em uso.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.ReadTotal`
          </td>

          <td>
            O número total de tickets de leitura (transações simultâneas) disponíveis.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteAvailable`
          </td>

          <td>
            O número de tickets de gravação disponíveis (transações simultâneas) restantes.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteRemaining`
          </td>

          <td>
            O número de tickets de gravação (transações simultâneas) em uso.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.concurrentTransactions.WriteTotal`
          </td>

          <td>
            O número total de tickets de gravação (transações simultâneas) disponíveis.
          </td>
        </tr>

        <tr>
          <td>
            `wiredtiger.failedEvictionsPagesPerSecond`
          </td>

          <td>
            O número de falhas na remoção de páginas que excederam o máximo na memória, por segundo.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## Dados de inventário [#inventory]

A integração do MongoDB captura todas as opções de linha de comando e parâmetros configurados em tempo de execução de cada host no cluster.

Os dados estão disponíveis na [página Inventário](/docs/infrastructure/new-relic-infrastructure/infrastructure-ui-pages/infrastructure-inventory-page-search-your-entire-infrastructure), na origem <DoNotTranslate>**config/mongodb**</DoNotTranslate> . Para obter mais informações sobre dados de inventário, consulte [Compreender os dados de integração](/docs/infrastructure/integrations-getting-started/getting-started/understand-integration-data-data-types#inventory-data).

## Verifique o código-fonte [#source-code]

Esta integração é um software de código aberto. Isso significa que você pode [navegar pelo código-fonte](https://github.com/newrelic/nri-mongodb) e enviar melhorias, ou criar seu próprio fork e construí-lo.