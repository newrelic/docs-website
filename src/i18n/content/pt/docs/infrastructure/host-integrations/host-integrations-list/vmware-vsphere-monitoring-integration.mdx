---
title: VMware vSphere integração de monitoramento
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: An introduction to New Relic's open-source VMware vSphere / ESXi integration.
freshnessValidatedDate: never
translationType: machine
---

A integração do VMware vSphere da New Relic ajuda você a entender a integridade e o desempenho do seu ambiente vSphere. Você pode:

* Consulte dados para obter insights sobre o desempenho de seus hipervisores, máquina virtual e muito mais.
* Vá de visualizações de alto nível até os dados mais granulares.

Nossa integração utiliza a [API do vSphere](https://code.vmware.com/apis/704/vsphere) para coletar métricas e eventos gerados por todos os componentes do vSphere, e encaminha os dados para nossa plataforma através do agente de infraestrutura.

<img
  title=""
  alt=""
  src="/images/infrastructure_screenshot-full_vmware-vsphere-ui.webp"
/>

## Por que isso importa [#features]

Com nossa integração com o vSphere, você pode:

* Instrumento e monitor múltiplas instâncias do vSphere usando a mesma conta.

* Colete dados sobre snapshots, VM, hosts, pools de recursos, cluster e armazenamentos de dados, incluindo tags.

* Monitor a integridade de seus hipervisores e VM usando nossos gráficos e painel.

* Use os dados recuperados para monitor os principais indicadores de desempenho e de escalabilidade da capacidade.

* Defina

  <InlinePopover type="alerts"/>

  com base em qualquer métrica coletada do vCenter.

* Crie [carga de trabalho](/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-one-workloads-isolate-resolve-incidents-faster) para agrupar recursos e focar nos dados principais.

## Compatibilidade e requisitos [#requirements]

Nossa integração é compatível com VMware vSphere 6.5 ou superior.

Antes de instalar a integração, certifique-se de atender aos seguintes requisitos:

* [Agente de infraestrutura instalado em um host](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic)
* Conta de serviço do vCenter com pelo menos permissões globais somente leitura com a opção `propagate to children` marcada

<Callout variant="important">
  <DNT>**Large environments:**</DNT> Em ambientes com mais de 800 máquinas virtuais, a integração não consegue reportar todos os dados e pode falhar. Oferecemos uma solução alternativa que preservará todas as métricas e eventos, mas desabilitará o registro da entidade. Para aplicar a solução alternativa, adicione a seguinte variável de ambiente ao arquivo de configuração:

  ```yaml
  integrations:
  - name: nri-vsphere
    env:
      # Integration configuration parameters.

      EVENTS: true
      METRICS: true

  ```
</Callout>

## Instale a integração [#install]

A maneira mais fácil de instalar a integração é seguir nossa [instalação guiada](https://onenr.io/0Bj3VYmGbRX):

1. Login em [one.newrelic.com](https://onenr.io/0Bj3VYmGbRX).

2. Clique em

   <DNT>
     **Integrations & Agents**
   </DNT>

   , pesquise "vSphere" e clique na integração.

3. Siga as etapas na interface.

Se você precisar instalar manualmente, consulte as seções abaixo.

<CollapserGroup>
  <Collapser
    id="linux-install"
    title="Instalação Linux"
  >
    1. Instale [o agente de infraestrutura](/docs/integrations/host-integrations/installation/install-infrastructure-host-integrations/#install) e substitua `INTEGRATION_FILE_NAME` por `nri-vsphere` ao executar o comando de instalação.

    2. Mude o diretório para a pasta integração:

       ```
       cd /etc/newrelic-infra/integrations.d
       ```

    3. Cópia do arquivo de configuração de amostra:

       ```
       sudo cp vsphere-config.yml.sample vsphere-config.yml
       ```

    4. Edite o arquivo `vsphere-config.yml` conforme descrito nas [definições de configuração](#config).
  </Collapser>

  <Collapser
    id="windows-install"
    title="Instalação do Windows"
  >
    1. Baixe a imagem do instalador `nri-vsphere` MSI em:

       [download.newrelic.com/infrastructure_agent/windows/integrations/nri-vsphere/nri-vsphere-amd64.msi](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-vsphere/nri-vsphere-amd64.msi)

    2. Para instalar a partir do prompt de comando do Windows, execute:

       ```
       msiexec.exe /qn /i PATH\TO\nri-vsphere-amd64.msi
       ```

    3. No diretório integração, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, crie uma cópia do arquivo de configuração de amostra executando:

       ```
       cp vsphere-config.yml.sample vsphere-config.yml
       ```

    4. Edite o arquivo `vsphere-config.yml` conforme descrito nas [definições de configuração](#config).
  </Collapser>

  <Collapser
    id="tarball"
    title="Instalação do Tarball (avançado)"
  >
    Você também pode [instalar a integração a partir de um arquivo tarball](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball). Isso lhe dá controle total sobre o processo de instalação e configuração.
  </Collapser>
</CollapserGroup>

<InstallFeedback/>

## Configurar a integração [#config]

A configuração no formato YAML de uma integração é onde você pode colocar as credenciais de login necessárias e configurar como os dados são coletados. Quais opções você altera dependem de sua configuração e preferência.

Para configurar a integração do vSphere, você deve definir a URL dos endpoints de API do vSphere e seu nome de usuário e senha do vSphere. Para obter exemplos de configuração, consulte os [arquivos de configuração de amostra](#example-config). Alguns recursos de integração do vSphere são opcionais e podem ser habilitados por meio das configurações de configuração.

Além disso, com [o gerenciamento de segredos](/docs/integrations/host-integrations/installation/secrets-management), você pode configurar a integração no host com o agente de infraestrutura do New Relic para usar dados confidenciais (como senhas) sem precisar gravá-los como texto simples no arquivo de configuração da integração.

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="vsphere-events"
    title="Evento de coleta do vSphere"
  >
    Para coletar eventos do vSphere, use a variável de ambiente `ENABLE_VSPHERE_EVENTS` .

    A integração coleta eventos entre o horário atual e o último evento buscado para cada data center. Armazena as informações referentes ao último evento buscado em um cache que é atualizado após cada execução. evento só estão disponíveis se a integração estiver conectada a um vCenter e não diretamente a um host ESXi.

    O número de eventos coletados por solicitação pode ser ajustado modificando `EVENTS_PAGE_SIZE`, que é definido como `100` por padrão.

    Evento estão disponíveis na página <DNT>**Events**</DNT> e podem ser consultados via [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) como `InfrastructureEvent` em `vSphereEvent`. Aqui está um exemplo de dados de evento do vSphere:

    ```
    "summary": "User dcui@127.0.0.1 logged out (login time: Tuesday, 14 July, 2020 08:32:09 AM, number of API invocations: 0, user agent: VMware-client/6.5.0)",
    "vSphereEvent.computeResource": "cluster1",
    "vSphereEvent.datacenter": "Prod Datacenter",
    "vSphereEvent.date": "Tue, 14 Jul 2020 09:03:51 UTC",
    "vSphereEvent.host": "192.168.0.230",
    "vSphereEvent.userName": "dcui"
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="snapshot-data"
    title="Coletar dados de instantâneos"
  >
    Para coletar dados de snapshot, use a variável de ambiente `ENABLE_VSPHERE_SNAPSHOTS` .

    Os dados do instantâneo podem ser encontrados em `VSphereSnapshotVmSample`. Os dados coletados abrangem o espaço total e exclusivo ocupado por arquivos de disco e memória, árvore de snapshots e horário de criação.

    Você pode utilizar essas informações para criar [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) consultas, [dashboards](/docs/dashboards/new-relic-one-dashboards/get-started/introduction-new-relic-one-dashboards) e [alertas](/docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries), desde que estejam vinculados à entidade virtual da máquina correspondente.
  </Collapser>

  <Collapser
    className="freq-link"
    id="vsphere-tags"
    title="Coletar tag do vSphere"
  >
    Para coletar a tag do vSphere, use a variável de ambiente `ENABLE_VSPHERE_TAGS` .

    Estão disponíveis como atributo na amostra da entidade correspondente como `label.tagCategory:tagName`.

    Se duas tags da mesma categoria forem atribuídas a um recurso, elas serão adicionadas a um atributo exclusivo separado por uma barra vertical. Por exemplo: `label.tagCategory:tagName|tagName`2.

    Tag pode ser usada para executar consulta [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql), filtrar entidade em nosso [explorador de entidade](/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-one-entity-explorer) e criar [dashboard](/docs/dashboards/new-relic-one-dashboards/get-started/introduction-new-relic-one-dashboards) e [alertas](/docs/alerts/new-relic-alerts/defining-conditions/create-alert-conditions-nrql-queries).
  </Collapser>

  <Collapser
    className="freq-link"
    id="vsphere-filter"
    title="Filtrar recursos por tag"
  >
    A filtragem de recursos permite especificar quais recursos você deseja monitor, declarando um conjunto de tags que os recursos devem ter para serem monitorados.

    Os recursos exigem uma correspondência em qualquer (uma ou mais) tags de filtro para serem incluídos. Se nenhuma tag de recurso corresponder a nenhuma tag de filtro, nenhuma informação sobre esse recurso será enviada para New Relic.

    Para usar a filtragem de recursos por tag, você precisa ter a variável de ambiente `ENABLE_VSPHERE_TAGS` ativada.

    Uma expressão de filtro de tag é uma lista separada por espaços de pares de strings com o formato `category=name`.

    Por exemplo, para recuperar apenas recursos com uma categoria de tag `region` e incluir regiões `us` e `eu` use uma expressão de filtro como: `region=us region=eu`

    ```
    INCLUDE_TAGS: >
      region=us
      region=eu
    ```

    Para ativar a filtragem de recursos por tag, edite seu arquivo de configuração de integração e adicione a opção `INCLUDE_TAGS` com a expressão de filtro desejada.

    <Callout variant="caution">
      Observe que os recursos data center que atuam como raiz da árvore de recursos DEVEM ter uma tag anexada E corresponder à expressão de filtro para que outros recursos filhos sejam buscados.
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="perf-metrics"
    title="Habilitar e configurar métrica de desempenho (visualização)"
  >
    As métricas de desempenho fornecem uma melhor compreensão do status atual dos recursos VMware e podem ser coletadas <DNT>**in addition**</DNT> para a métrica coletada por padrão;e incluída nas amostras;descritas na parte inferior da página.

    Todas as métricas coletadas são incluídas na amostra correspondente com o prefixo `perf.` anexado ao nome. Por exemplo, `net.packetsRx.summation` é coletado e enviado como `perf.net.packetsRx.summation`.

    Para coletar métricas de desempenho do vSphere, use a variável de ambiente `ENABLE_VSPHERE_PERF_METRICS` .

    Os dados são coletados de acordo com as configurações do arquivo de configuração [`vsphere-performance.metrics`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-performance.metrics) . Você pode substituir a localização do arquivo de configuração da métrica de desempenho usando a variável de ambiente `PERF_METRIC_FILE` . Observe que a integração segue [os níveis de coleta de dados da VMware](https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.monitoring.doc/GUID-25800DE4-68E5-41CC-82D9-8811E27924BC.html) (1 a 4).

    Quando `ENABLE_VSPHERE_PERF_METRICS` é definido, todas as métricas do nível 1 são coletadas. O nível de coleta de dados da métrica de desempenho coletada pode ser modificado usando `PERF_LEVEL`. Cada métrica no arquivo de configuração pode ser comentada e novas podem ser adicionadas se necessário.

    <Callout variant="caution">
      A coleta de dados de desempenho pode aumentar a carga no vCenter e o tempo necessário para coletar dados. Recomendamos incluir apenas a métrica necessária no arquivo de configuração.
    </Callout>

    Para ajustar a coleta de dados, o número de entidade e métrica recuperadas por solicitação pode ser modificado usando `BATCH_SIZE_PERF_ENTITIES` e `BATCH_SIZE_PERF_METRICS`.

    <Callout variant="tip">
      Para obter mais informações sobre a métrica de desempenho do vSphere, consulte a [documentação do VMware](https://docs.vmware.com/en/VMware-vSphere/6.7/vsphere-esxi-vcenter-server-67-monitoring-performance-guide.pdf).
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="multi-instance"
    title="Instância múltipla"
  >
    Nesta configuração estamos monitorando múltiplos servidores vSphere a partir da mesma integração. Para a primeira instância (`FIRST_VSPHERE_API_URL`) estamos coletando evento e tag enquanto para a segunda instância (`SECOND_VSPHERE_API_URL`) nós os desativamos.

    ```yaml
    integrations:
      - name: nri-vsphere
        env:
          # vSphere API connection data (vCenter or ESXi servers)
          URL: https://<FIRST_VSPHERE_API_URL>/sdk
          USER: <FIRST_VSPHERE_USER>
          PASS: <FIRST_PASSWORD>

          # Collect events data
          ENABLE_VSPHERE_EVENTS: true

          # Collect vSphere tags
          ENABLE_VSPHERE_TAGS: true

        # Execution interval. Set a value higher than 20s, as real-time vSphere samples are run every 20s.
        interval: 120s
      - name: nri-vsphere
        env:
          # vSphere API connection data (vCenter or ESXi servers)
          URL: https://<SECOND_VSPHERE_API_URL>/sdk
          USER: <SECOND_VSPHERE_USER>
          PASS: <SECOND_PASSWORD>

          # Collect events data
          ENABLE_VSPHERE_EVENTS: false

          # Collect vSphere tags
          ENABLE_VSPHERE_TAGS: false

        # Execution interval. Set a value higher than 20s, as real-time vSphere samples are run every 20s.
        interval: 300s
    ```
  </Collapser>
</CollapserGroup>

<Callout variant="important">
  Se você conectar a integração diretamente ao host ESXi, os dados do vCenter não estarão disponíveis (por exemplo, metadados de evento, tag ou data center ).
</Callout>

### Exemplo de configuração [#example-config]

Aqui estão exemplos de configuração de integração do vSphere, incluindo métrica de desempenho:

* [`vsphere-config.yml.sample`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-config.yml.sample) (Linux)
* [`vsphere-win-config.yml.sample`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-win-config.yml.sample) (Windows)
* [`vsphere-performance.metrics`](https://github.com/newrelic/nri-vsphere/blob/master/vsphere-performance.metrics) (Desempenho métrico)

Para mais informações, consulte nossa documentação sobre a [estrutura geral de integração no host configuração](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview).

<Callout variant="important">
  A opção de configuração [inventory_source](/docs/integrations/integrations-sdk/file-specifications/host-integrations-newer-configuration-format#inventory_source) não é compatível com esta integração.
</Callout>

## Atualize sua integração [#update]

<DNT>
  **On-host integrations do not automatically update.**
</DNT>

Para obter melhores resultados, [atualize regularmente o pacote de integração](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) e o [agente de infraestrutura](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

## Visualizar e usar dados [#data]

Os dados deste serviço são reportados para um [dashboard de integração](https://onenr.io/0qwyY4Bzpwn). Você pode [consultar esses dados](/docs/using-new-relic/data/understand-data/query-new-relic-data) para fins de resolução de problemas ou para criação de gráficos e dashboards.

Os dados do vSphere são anexados a estes [tipos de eventos](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#event):

* `VSphereHostSample`
* `VSphereClusterSample`
* `VSphereVmSample`
* `VSphereDatastoreSample`
* `VSphereDatacenterSample`
* `VSphereResourcePoolSample`
* `VSphereSnapshotVmSample`

os dados de desempenho são habilitados e configurados separadamente (veja [Habilitar e configurar métrica de desempenho](#perf-metrics)).

Para obter mais informações sobre como visualizar e usar seus dados, consulte [Compreender os dados de integração](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Dados métricos [#metrics]

A integração do vSphere fornece dados métricos anexados ao seguinte New Relic [evento](/docs/telemetry-data-platform/ingest-manage-data/understand-data/new-relic-data-types#events-new-relic):

* `VSphereHostSample`
* `VSphereVmSample`
* `VSphereDatastoreSample`
* `VSphereDatacenterSample`
* `VSphereResourcePoolSample`
* `VSphereClusterSample`
* `VSphereSnapshotVmSample`

### Exemplo de VSphereHost

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nome
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cpu.totalMHz`
      </td>

      <td>
        Soma dos MHz para todos os núcleos individuais no host
      </td>
    </tr>

    <tr>
      <td>
        `cpu.coreMHz`
      </td>

      <td>
        Velocidade dos núcleos da CPU
      </td>
    </tr>

    <tr>
      <td>
        `cpu.available`
      </td>

      <td>
        Quantidade de MHz de CPU livre no host
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Uso da CPU em todos os núcleos do host em MHz
      </td>
    </tr>

    <tr>
      <td>
        `cpu.percent`
      </td>

      <td>
        Porcentagem de utilização da CPU no host
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Número de núcleos físicos de CPU no host. Núcleos físicos de CPU são os processadores contidos em um pacote de CPU
      </td>
    </tr>

    <tr>
      <td>
        `cpu.threads`
      </td>

      <td>
        Número de threads físicos da CPU no host
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalMiB`
      </td>

      <td>
        Capacidade total de discos montados no host, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.free`
      </td>

      <td>
        Quantidade de memória disponível no host, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Quantidade de memória usada no host, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Capacidade total de memória do host, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Número de máquina virtual no host
      </td>
    </tr>

    <tr>
      <td>
        `hypervisorHostname`
      </td>

      <td>
        Nome do anfitrião
      </td>
    </tr>

    <tr>
      <td>
        `uuid`
      </td>

      <td>
        A identificação do BIOS de hardware
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Nome do data center relacionado ao host
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Nome do cluster relacionado ao host
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolNameList`
      </td>

      <td>
        Lista de nomes dos pools de recursos relacionados ao host
      </td>
    </tr>

    <tr>
      <td>
        `datastoreNameList`
      </td>

      <td>
        Lista de nomes de datastores relacionados ao host
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Localização do data center
      </td>
    </tr>

    <tr>
      <td>
        `networkNameList`
      </td>

      <td>
        Lista de nomes de redes relacionadas ao host
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: O status é desconhecido
        * `green`: entidade está OK
        * `yellow`: A entidade pode ter um problema
        * `red`: A entidade definitivamente tem um problema
      </td>
    </tr>

    <tr>
      <td>
        `connectionState`
      </td>

      <td>
        O estado da conexão do host:

        * `connected`: Conectado ao servidor. Para ESX Server, esta é a configuração padrão.
        * `disconnected`: o usuário desativou explicitamente o host. O VirtualCenter não espera receber pulsações do host. Na próxima vez que uma pulsação for recebida, o host será movido novamente para o estado conectado e um evento será registrado.
        * `notResponding`: o VirtualCenter não está recebendo pulsações do servidor. O estado muda automaticamente para conectado quando os batimentos cardíacos são recebidos novamente. Esse estado normalmente é usado para disparar um alarme no host.
      </td>
    </tr>

    <tr>
      <td>
        `inMaintenanceMode`
      </td>

      <td>
        O sinalizador para indicar se o host está ou não em modo de manutenção. Este sinalizador é definido quando o host entra no modo de manutenção. Não é definido durante a fase de entrada do modo de manutenção.
      </td>
    </tr>

    <tr>
      <td>
        `inQuarantineMode`
      </td>

      <td>
        O sinalizador para indicar se o host está ou não no modo de quarentena. `InfraUpdateHa` recomendará definir esse sinalizador com base no `HealthUpdates` recebido pelo `HealthUpdateProviders` configurado para o cluster.

        Um host relatado como degradado será recomendado para entrar no modo de quarentena, enquanto um host relatado como íntegro será recomendado para sair do modo de quarentena. A execução dessas ações recomendadas definirá esse sinalizador.

        Os hosts no modo de quarentena serão evitados pelo vSphere DRS, desde que o aumento da consolidação no cluster não afete negativamente o desempenho da VM.
      </td>
    </tr>

    <tr>
      <td>
        `powerState`
      </td>

      <td>
        O estado de energia do host:

        * `poweredOff`: o host foi desligado especificamente pelo usuário por meio do VirtualCenter. Este estado não é um estado específico, porque depois que o VirtualCenter emite o comando para desligar o host, o host pode travar ou encerrar todos os processos, mas não conseguir desligar.
        * `poweredOn`: o host está ligado. Um host que está entrando no modo de espera também está neste estado.
        * `standBy`: o host foi especificamente colocado em modo de espera, explicitamente pelo usuário ou automaticamente pelo DPM. Este estado não é um estado específico, porque depois que o VirtualCenter emite o comando para colocar o host no estado de espera, o host pode travar ou encerrar todos os processos, mas não conseguir desligar. Um host que está saindo do modo de espera também está neste estado.
        * `unknown`: se o host estiver desconectado ou `notResponding`, sabemos seu estado de energia, então o host é marcado como `unknown`.
      </td>
    </tr>

    <tr>
      <td>
        `standbyMode`
      </td>

      <td>
        O modo de espera do host. A propriedade é preenchida apenas pelo servidor vCenter. Se consultar diretamente do host ESX, a propriedade será `unset`.

        * `entering`: O host está entrando no modo de espera.
        * `exiting`: O host está saindo do modo de espera.
        * `in`: O host está no modo de espera.
        * `none`: O host não está no modo de espera e não está no processo de entrar ou sair do modo de espera.
      </td>
    </tr>

    <tr>
      <td>
        `cryptoState`
      </td>

      <td>
        Estado de criptografia do host. Os valores válidos são enumerados pelo tipo CryptoState:

        * `incapable`: O host não é seguro para receber material confidencial.
        * `prepared`: o host está preparado para receber material confidencial, mas ainda não possui uma chave de host definida.
        * `safe`: o host é criptografado e possui uma chave de host definida.
      </td>
    </tr>

    <tr>
      <td>
        `bootTime`
      </td>

      <td>
        A hora em que o host foi inicializado.
      </td>
    </tr>
  </tbody>
</table>

### Exemplo de VSphereVm [#vspherevirtualmachine]

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nome
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Tamanho da memória da máquina virtual, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Estatísticas de utilização de memória de convidados, em MiB. Isso também é conhecido como memória de convidado ativa. O valor pode variar entre `0` e o tamanho de memória configurado da máquina virtual. Válido enquanto a máquina virtual está em execução.
      </td>
    </tr>

    <tr>
      <td>
        `mem.free`
      </td>

      <td>
        Memória de convidado disponível, em MiB. O valor pode variar entre `0` e o tamanho de memória configurado da máquina virtual. Válido enquanto a máquina virtual está em execução.
      </td>
    </tr>

    <tr>
      <td>
        `mem.ballooned`
      </td>

      <td>
        O tamanho do driver balão na máquina virtual, em MiB. O host inflará o driver balão para recuperar a memória física da máquina virtual. Este é um sinal de que há pressão de memória no host.
      </td>
    </tr>

    <tr>
      <td>
        `mem.swapped`
      </td>

      <td>
        A porção de memória, em MiB, concedida a esta máquina virtual a partir do espaço de troca do host. Este é um sinal de que há pressão de memória no host.
      </td>
    </tr>

    <tr>
      <td>
        `mem.swappedSsd`
      </td>

      <td>
        A quantidade de memória trocada para dispositivos de disco rápidos, como SSD, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `cpu.allocationLimit`
      </td>

      <td>
        Limites de recursos para CPU, em MHz. Se definido como `-1`, não há limite de alocação fixo.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Estatísticas básicas de desempenho da CPU, em MHz. Válido enquanto a máquina virtual está em execução.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.hostUsagePercent`
      </td>

      <td>
        Porcentagem da CPU do host usada pela máquina virtual. Caso seja configurado um limite, o percentual é calculado considerando o limite como total.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Número de processadores na máquina virtual
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalMiB`
      </td>

      <td>
        Espaço de armazenamento total comprometido com esta máquina virtual em todos os datastores, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `ipAddress`
      </td>

      <td>
        Endereço IP do convidado principal, se disponível
      </td>
    </tr>

    <tr>
      <td>
        `ipAddresses`
      </td>

      <td>
        Lista de IPs associados à VM (exceto `ipAddress`). Um caractere de barra vertical ou vertical (`|`) é usado como separador.
      </td>
    </tr>

    <tr>
      <td>
        `connectionState`
      </td>

      <td>
        Indica se a máquina virtual está ou não disponível para gerenciamento:

        * `connected`: o servidor tem acesso à máquina virtual.
        * `disconnected`: o servidor está atualmente desconectado da máquina virtual, pois seu host está desconectado.
        * `inaccessible`: um ou mais arquivos de configuração da máquina virtual estão inacessíveis.
        * `invalid`: o formato de configuração da máquina virtual é inválido.
        * `orphaned`: a máquina virtual não está mais registrada no host associado.
      </td>
    </tr>

    <tr>
      <td>
        `powerState`
      </td>

      <td>
        O estado de energia atual da máquina virtual: `poweredOff`, `poweredOn` ou `suspended`.
      </td>
    </tr>

    <tr>
      <td>
        `guestHeartbeatStatus`
      </td>

      <td>
        * `gray`: O status é desconhecido.
        * `green`: A entidade está OK.
        * `yellow`: a entidade pode ter um problema.
        * `red`: A entidade definitivamente tem um problema.
      </td>
    </tr>

    <tr>
      <td>
        `operatingSystem`
      </td>

      <td>
        Sistema operacional da máquina virtual
      </td>
    </tr>

    <tr>
      <td>
        `guestFullName`
      </td>

      <td>
        Nome completo do sistema operacional convidado, se disponível nas ferramentas convidadas
      </td>
    </tr>

    <tr>
      <td>
        `hypervisorHostname`
      </td>

      <td>
        Nome do host onde a máquina virtual está sendo executada
      </td>
    </tr>

    <tr>
      <td>
        `instanceUuid`
      </td>

      <td>
        Identificação exclusiva da máquina virtual
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Nome do data center
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Nome do cluster
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolNameList`
      </td>

      <td>
        Lista de nomes dos pools de recursos
      </td>
    </tr>

    <tr>
      <td>
        `datastoreNameList`
      </td>

      <td>
        Lista de nomes de datastores
      </td>
    </tr>

    <tr>
      <td>
        `networkNameList`
      </td>

      <td>
        Lista de nomes de redes
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Localização do data center
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: O status é desconhecido.
        * `green`: A entidade está OK.
        * `yellow`: a entidade pode ter um problema.
        * `red`: A entidade definitivamente tem um problema.
      </td>
    </tr>

    <tr>
      <td>
        `disk.suspendMemory`
      </td>

      <td>
        Tamanho do arquivo de instantâneo (bytes).
      </td>
    </tr>

    <tr>
      <td>
        `disk.suspendMemoryUnique`
      </td>

      <td>
        Tamanho do arquivo de instantâneo, blocos exclusivos (bytes).
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalUncommittedMiB`
      </td>

      <td>
        Espaço de armazenamento adicional potencialmente utilizado por esta máquina virtual em todos os datastores. Essencialmente, um agregado da propriedade não confirmada em todos os armazenamentos de dados em que esta máquina virtual está localizada (Mebibytes).
      </td>
    </tr>

    <tr>
      <td>
        `disk.totalUnsharedMiB`
      </td>

      <td>
        Espaço total de armazenamento ocupado pela máquina virtual em todos os datastores, que não é compartilhado com nenhuma outra máquina virtual (Mebibytes).
      </td>
    </tr>

    <tr>
      <td>
        `mem.hostUsage`
      </td>

      <td>
        Uso de memória do host (Mebibytes).
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolName`
      </td>

      <td>
        Nome do pool de recursos.
      </td>
    </tr>

    <tr>
      <td>
        `vmConfigName`
      </td>

      <td>
        Nome de configuração da VM.
      </td>
    </tr>

    <tr>
      <td>
        `vmHostname`
      </td>

      <td>
        Nome VM do host.
      </td>
    </tr>
  </tbody>
</table>

### VSphereDatastoreSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nome
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `capacity`
      </td>

      <td>
        A capacidade máxima deste armazenamento de dados, em GiB, se acessível é `true`
      </td>
    </tr>

    <tr>
      <td>
        `freeSpace`
      </td>

      <td>
        O espaço disponível deste armazenamento de dados, em GiB, se acessível é `true`
      </td>
    </tr>

    <tr>
      <td>
        `uncommitted`
      </td>

      <td>
        O espaço de armazenamento adicional total, potencialmente utilizado por todas as máquinas virtuais neste armazenamento de dados, em GiB, se acessível, é `true`
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Número de máquinas virtuais anexadas ao armazenamento de dados
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Localização do data center
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Nome do data center
      </td>
    </tr>

    <tr>
      <td>
        `hostCount`
      </td>

      <td>
        Número de hosts anexados ao armazenamento de dados
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: O status é desconhecido.
        * `green`: A entidade está OK.
        * `yellow`: a entidade pode ter um problema.
        * `red`: A entidade definitivamente tem um problema.
      </td>
    </tr>

    <tr>
      <td>
        `accessible`
      </td>

      <td>
        Status de conectividade do armazenamento de dados. Se estiver definido como `false`, o armazenamento de dados não estará acessível.
      </td>
    </tr>

    <tr>
      <td>
        `url`
      </td>

      <td>
        Localizador único para armazenamento de dados, se acessível é `true`
      </td>
    </tr>

    <tr>
      <td>
        `fileSystemType`
      </td>

      <td>
        Tipo de volume do sistema de arquivos, como `VMFS` ou `NFS`
      </td>
    </tr>

    <tr>
      <td>
        `name`
      </td>

      <td>
        Nome do armazenamento de dados
      </td>
    </tr>

    <tr>
      <td>
        `nas.remoteHost`
      </td>

      <td>
        Host que executa o servidor NFS/CIFS
      </td>
    </tr>

    <tr>
      <td>
        `nas.remotePath`
      </td>

      <td>
        Caminho remoto do ponto de montagem NFS/CIFS
      </td>
    </tr>
  </tbody>
</table>

### VSphereDatacenterSample

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nome
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `datastore.totalUsedGiB`
      </td>

      <td>
        Espaço total utilizado nos datastores, em GiB
      </td>
    </tr>

    <tr>
      <td>
        `datastore.totalFreeGiB`
      </td>

      <td>
        Espaço livre total nos datastores, em GiB
      </td>
    </tr>

    <tr>
      <td>
        `datastore.totalGiB`
      </td>

      <td>
        Tamanho total dos datastores, em GiB
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Contagem total de CPU por data center
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsagePercentage`
      </td>

      <td>
        Uso total da CPU, em porcentagem
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Uso total da CPU, em MHz
      </td>
    </tr>

    <tr>
      <td>
        `cpu.totalMHz`
      </td>

      <td>
        Capacidade total da CPU, em MHz
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Uso total de memória, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Memória total, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.usagePercentage`
      </td>

      <td>
        Uso total de memória como porcentagem
      </td>
    </tr>

    <tr>
      <td>
        `clusters`
      </td>

      <td>
        Contagem total cluster por data center
      </td>
    </tr>

    <tr>
      <td>
        `resourcePools`
      </td>

      <td>
        Total de pools de recursos por data center
      </td>
    </tr>

    <tr>
      <td>
        `datastores`
      </td>

      <td>
        Total de armazenamentos de dados por data center
      </td>
    </tr>

    <tr>
      <td>
        `networks`
      </td>

      <td>
        Contagem total de adaptadores de rede por data center
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: O status é desconhecido
        * `green`: entidade está OK
        * `yellow`: A entidade pode ter um problema
        * `red`: A entidade definitivamente tem um problema
      </td>
    </tr>

    <tr>
      <td>
        `hostCount`
      </td>

      <td>
        Contagem total de sistemas host por data center
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Contagem total de máquinas virtuais por data center
      </td>
    </tr>
  </tbody>
</table>

### Exemplo de VSphereResourcePool

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nome
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cpu.TotalMHz`
      </td>

      <td>
        Capacidade total da CPU do pool de recursos, em MHz
      </td>
    </tr>

    <tr>
      <td>
        `cpu.overallUsage`
      </td>

      <td>
        Uso de CPU do pool de recursos, em MHz
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Memória total reservada do pool de recursos, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.usage`
      </td>

      <td>
        Uso de memória do pool de recursos, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.free`
      </td>

      <td>
        Memória do pool de recursos disponível, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.ballooned`
      </td>

      <td>
        Tamanho do driver balão no pool de recursos, em MiB
      </td>
    </tr>

    <tr>
      <td>
        `mem.swapped`
      </td>

      <td>
        Parte da memória, em MiB, concedida a este pool de recursos do espaço de troca do host
      </td>
    </tr>

    <tr>
      <td>
        `vmCount`
      </td>

      <td>
        Número de máquinas virtuais no pool de recursos
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: O status é desconhecido.
        * `green`: A entidade está OK.
        * `yellow`: a entidade pode ter um problema.
        * `red`: A entidade definitivamente tem um problema.
      </td>
    </tr>

    <tr>
      <td>
        `resourcePoolName`
      </td>

      <td>
        Nome do pool de recursos
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Localização do data center
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        Nome do data center
      </td>
    </tr>

    <tr>
      <td>
        `clusterName`
      </td>

      <td>
        Nome do cluster
      </td>
    </tr>
  </tbody>
</table>

### Exemplo de VSphereCluster

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nome
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `cpu.totalEffectiveMHz`
      </td>

      <td>
        Recursos efetivos de CPU, em MHz, disponíveis para máquina virtual. Este é o nível de recurso efetivo agregado de todos os hosts em execução. Os hosts que estão em modo de manutenção ou que não respondem não são contados. Os recursos usados pelo VMware Service Console não estão incluídos no agregado. Este valor representa a quantidade de recursos disponíveis para o conjunto de recursos raiz para execução da máquina virtual.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.totalMHz`
      </td>

      <td>
        Recursos agregados de CPU de todos os hosts, em MHz. Ele não filtra a CPU usada pelo sistema ou relacionada a hosts em manutenção.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.cores`
      </td>

      <td>
        Número de núcleos físicos da CPU. Núcleos físicos de CPU são os processadores contidos em um pacote de CPU.
      </td>
    </tr>

    <tr>
      <td>
        `cpu.threads`
      </td>

      <td>
        Número agregado de threads de CPU.
      </td>
    </tr>

    <tr>
      <td>
        `mem.size`
      </td>

      <td>
        Recursos de memória agregados de todos os hosts, em MiB. Ele não filtra a memória usada pelo sistema ou relacionada a hosts em manutenção.
      </td>
    </tr>

    <tr>
      <td>
        `mem.effectiveSize`
      </td>

      <td>
        Recursos efetivos de memória, em MiB, disponíveis para execução da máquina virtual. Este é o nível de recurso efetivo agregado de todos os hosts em execução. Os hosts que estão em modo de manutenção ou que não respondem não são contados. Os recursos usados pelo VMware Service Console não estão incluídos no agregado. Este valor representa a quantidade de recursos disponíveis para o conjunto de recursos raiz para execução da máquina virtual.
      </td>
    </tr>

    <tr>
      <td>
        `effectiveHosts`
      </td>

      <td>
        Número total de hosts efetivos. Este número exclui hosts em manutenção.
      </td>
    </tr>

    <tr>
      <td>
        `hosts`
      </td>

      <td>
        Número total de hosts
      </td>
    </tr>

    <tr>
      <td>
        `overallStatus`
      </td>

      <td>
        * `gray`: O status é desconhecido.
        * `green`: A entidade está OK.
        * `yellow`: a entidade pode ter um problema.
        * `red`: A entidade definitivamente tem um problema.
      </td>
    </tr>

    <tr>
      <td>
        `datastoreList`
      </td>

      <td>
        Lista de armazenamento de dados usado pelo cluster. Um caractere de barra vertical ou vertical (`|`) é usado como separador.
      </td>
    </tr>

    <tr>
      <td>
        `hostList`
      </td>

      <td>
        Lista de hosts pertencentes ao cluster. Um caractere de barra vertical ou vertical (`|`) é usado como separador.
      </td>
    </tr>

    <tr>
      <td>
        `networkList`
      </td>

      <td>
        Lista de redes anexadas ao cluster. Um caractere de barra vertical ou vertical (`|`) é usado como separador.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.vmotionRate`
      </td>

      <td>
        Limite para ClusterRecommendations geradas. O DRS gera apenas as recomendações que estão acima do vmotionRate especificado. As classificações variam de 1 a 5. Essa configuração se aplica ao cluster DRS manual, parcialmente automatizado e totalmente automatizado.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.restartPriorityTimeout`
      </td>

      <td>
        Tempo máximo que a VM de prioridade mais baixa deve aguardar até que a VM de prioridade mais alta esteja pronta (segundos).
      </td>
    </tr>

    <tr>
      <td>
        `datacenterName`
      </td>

      <td>
        nome data center .
      </td>
    </tr>

    <tr>
      <td>
        `datacenterLocation`
      </td>

      <td>
        Localização do data center.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.enabled`
      </td>

      <td>
        Sinalizador que indica se o serviço está habilitado ou não.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.enableVmBehaviorOverrides`
      </td>

      <td>
        Sinalizador que determina se as substituições do comportamento do DRS para máquina virtual individual (ClusterDrsVmConfigInfo) estão habilitadas.
      </td>
    </tr>

    <tr>
      <td>
        `drsConfig.defaultVmBehavior`
      </td>

      <td>
        Especifica o comportamento DRS padrão em todo clusterpara máquina virtual. Você pode substituir o comportamento padrão de uma máquina virtual usando o objeto ClusterDrsVmConfigInfo.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.enabled`
      </td>

      <td>
        Sinalizador para indicar se o recurso vSphere HA está habilitado ou não.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.admissionControlEnabled`
      </td>

      <td>
        Sinalizador que determina se o controle estrito de admissão está habilitado
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.isolationResponse`
      </td>

      <td>
        Indica se a máquina virtual deve ou não ser desligada se um host determinar que ela está isolada do restante dos recursos do computador.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.restartPriority`
      </td>

      <td>
        Prioridade de reinicialização para uma máquina virtual.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.hostMonitoring`
      </td>

      <td>
        Determina se o HA reinicia a máquina virtual após falha de um host.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.vmMonitoring`
      </td>

      <td>
        Nível do serviço de monitoramento de integridade da máquina virtual HA.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.vmComponentProtecting`
      </td>

      <td>
        Esta propriedade indica se o serviço vSphere HA VM Component Protection está ativado.
      </td>
    </tr>

    <tr>
      <td>
        `dasConfig.hbDatastoreCandidatePolicy`
      </td>

      <td>
        A política sobre quais datastores serão usados pelo vCenter Server para escolher datastores de pulsação: allFeasibleDs, allFeasibleDsWithUserPreference, userSelectedDs
      </td>
    </tr>
  </tbody>
</table>

### VSphereSnapshotVmSample [#vspheresnapshot]

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nome
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `snapshotTreeInfo`
      </td>

      <td>
        Informações da árvore para o instantâneo. Es: cluster:VM: Instantâneo1:Instantâneo2
      </td>
    </tr>

    <tr>
      <td>
        `name`
      </td>

      <td>
        Nome do instantâneo
      </td>
    </tr>

    <tr>
      <td>
        `creationTime`
      </td>

      <td>
        Hora de criação do instantâneo
      </td>
    </tr>

    <tr>
      <td>
        `powerState`
      </td>

      <td>
        O estado de energia da máquina virtual quando este instantâneo foi obtido
      </td>
    </tr>

    <tr>
      <td>
        `snapshotId`
      </td>

      <td>
        O identificador exclusivo que distingue este instantâneo de outros instantâneos da máquina virtual
      </td>
    </tr>

    <tr>
      <td>
        `quiesced`
      </td>

      <td>
        Sinalizador para indicar se o snapshot foi criado ou não com a opção "quiesce", garantindo um estado consistente do sistema de arquivos
      </td>
    </tr>

    <tr>
      <td>
        `backupManifest`
      </td>

      <td>
        O caminho relativo do snapshotDirectory que aponta para o manifesto de backup. Disponível apenas para determinados snapshots desativados
      </td>
    </tr>

    <tr>
      <td>
        `description`
      </td>

      <td>
        Descrição do instantâneo
      </td>
    </tr>

    <tr>
      <td>
        `replaySupported`
      </td>

      <td>
        Sinalizador para indicar se este instantâneo está associado a uma sessão de gravação na máquina virtual que pode ser reproduzida
      </td>
    </tr>

    <tr>
      <td>
        `totalMemoryInDisk`
      </td>

      <td>
        Tamanho total da memória no disco.
      </td>
    </tr>

    <tr>
      <td>
        `totalUniqueMemoryInDisk`
      </td>

      <td>
        Tamanho total do arquivo correspondente aos blocos de arquivo que foram alocados exclusivamente para armazenar memória. Em outras palavras, se o armazenamento subjacente suportar o compartilhamento de blocos de arquivos entre arquivos de disco, a propriedade corresponderá ao tamanho dos blocos de arquivo que foram alocados apenas no contexto desse arquivo. Não inclui blocos compartilhados que foram alocados em outros arquivos. Esta propriedade não será definida se a implementação subjacente não for capaz de calcular esta informação.
      </td>
    </tr>

    <tr>
      <td>
        `totalDisk`
      </td>

      <td>
        Tamanho total dos arquivos de snapshot no disco
      </td>
    </tr>

    <tr>
      <td>
        `totalUniqueDisk`
      </td>

      <td>
        Tamanho total do arquivo correspondente aos blocos de arquivo que foram alocados exclusivamente para armazenar dados de snapshot no disco. Em outras palavras, se o armazenamento subjacente suportar o compartilhamento de blocos de arquivos entre arquivos de disco, a propriedade corresponderá ao tamanho dos blocos de arquivo que foram alocados apenas no contexto desse arquivo. Não inclui blocos compartilhados que foram alocados em outros arquivos. Esta propriedade não será definida se a implementação subjacente não for capaz de calcular esta informação.
      </td>
    </tr>

    <tr>
      <td>
        `datastorePathDisk`
      </td>

      <td>
        Caminho do arquivo em disco no armazenamento de dados
      </td>
    </tr>

    <tr>
      <td>
        `datastorePathMemory`
      </td>

      <td>
        Caminho do arquivo de memória no armazenamento de dados
      </td>
    </tr>
  </tbody>
</table>

## Resolução de problemas [#troubleshooting]

<CollapserGroup>
  <Collapser
    id="data-gaps"
    title="Lacunas nos dados relatados"
  >
    Um possível motivo para lacunas de dados pode ser o fato de a integração demorar muito para coletar e processar dados do vCenter. Caso a integração ultrapasse o [timeout](/docs/infrastructure/host-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/#timeout), que por padrão é `120s`, o agente de infraestrutura irá encerrar a integração, e uma mensagem do log como a seguinte será impressa:

    ```shell
    level=warn msg="HeartBeat timeout exceeded after 120000000000" integration_name=nri-vsphere
    ```

    Para corrigir isso, você pode estender o parâmetro [timeout](/docs/infrastructure/host-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/#timeout) no arquivo de configuração.

    ```yaml
    integrations:
    - name: nri-vsphere
      env:
        # Integration configuration parameters.

      interval: 120s

      timeout: 300s
    ```
  </Collapser>
</CollapserGroup>
