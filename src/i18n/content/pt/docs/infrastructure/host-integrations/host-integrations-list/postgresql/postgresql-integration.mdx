---
title: PostgreSQL monitoramento integração
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: 'New Relic''s PostgreSQL integration: how to install it and configure it, and what data it reports.'
freshnessValidatedDate: never
translationType: machine
---

A New Relic [integração](/docs/integrations/host-integrations/getting-started/introduction-host-integrations) PostgreSQL no host recebe e envia métricas de inventário da sua instância PostgreSQL para a New Relic plataforma, onde você pode agregar e visualizar as principais métricas de desempenho. Dados de instância, banco de dados e cluster ajudam a encontrar a origem dos problemas.

Para instalar a integração de monitoramento do PostgreSQL, você deve executar as seguintes etapas:

1. [Instale e ative a integração](#install).
2. [Configure a integração](#config).
3. [Usuário e permissões do PostgreSQL](#create-user).
4. [Encontre e use dados](#find-and-use).
5. Opcionalmente, consulte [as definições de configuração do PostgreSQL](/docs/infrastructure/host-integrations/host-integrations-list/postgresql/postgresql-config).

<Callout variant="important">
  Para obter melhores resultados, [atualize regularmente o pacote de integração](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) e [o agente de infraestrutura](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).
</Callout>

## Compatibilidade e requisitos [#req]

### Versões do PostgreSQL [#postgresql-versions]

Nossa integração é compatível com PostgreSQL até a versão 16.

### Serviços gerenciados com suporte [#supported-ms]

* Amazon RDS
* Azure Flexível

### Sistema operacional suportado [#supported-os]

* Windows

  <img
    style={{ width: '32px', height: '32px'}}
    class="inline"
    title="Windows"
    alt="Windows"
    src="/images/os_icon_windows.webp"
  />

* Linux

  <img
    style={{ width: '32px', height: '32px'}}
    class="inline"
    title="Linux"
    alt="Linux"
    src="/images/os_icon_linux.webp"
  />

Para uma lista abrangente de versões específicas do Windows e Linux, verifique a tabela de [sistemas operacionais compatíveis](/docs/infrastructure/install-infrastructure-agent/get-started/requirements-infrastructure-agent/#operating-systems).

### Requisito do sistema [#system-reqs]

* Uma conta New Relic . Não tem um? [Cadastre-se gratuitamente!](https://newrelic.com/signup) Não é necessário cartão de crédito.

* Se o PostgreSQL não estiver em execução no Kubernetes ou Amazon ECS, você poderá [instalar o agente de infraestrutura](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic) em um host do sistema operacional Linux ou Windows ou em um host capaz de acessar remotamente onde o PostgreSQL está instalado. De outra forma:

  * Se estiver executando

    <img
      style={{ width: '32px', height: '32px'}}
      class="inline"
      title="Kubernetes"
      alt="Kubernetes"
      src="/images/os_icon_k8.webp"
    >
      Kubernetes, consulte [estes requisitos](/docs/monitor-service-running-kubernetes#requirements).
    </img>

  * Se estiver executando

    <img
      style={{ width: '32px', height: '32px'}}
      class="inline"
      title="ECS"
      alt="ECS"
      src="/images/os_icon_ecs.webp"
    >
      Amazon ECS, consulte [estes requisitos](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
    </img>

## Instale e ative a integração [#install]

Para instalar a integração do PostgreSQL, siga as instruções do seu ambiente.

### Instalação Linux [#linux]

1. Instale [o agente de infraestrutura](/docs/integrations/host-integrations/installation/install-infrastructure-host-integrations/#install) e substitua a variável `INTEGRATION_FILE_NAME` por `nri-postgresql`.

2. Mude o diretório para a pasta integração configuração executando:

   ```shell
   cd /etc/newrelic-infra/integrations.d
   ```

3. [Crie um usuário](#create-user) com `READ` permissões nas funções necessárias.

4. Copie o arquivo de configuração de amostra executando:

   ```shell
   sudo cp postgresql-config.yml.sample postgresql-config.yml
   ```

5. Edite o arquivo de configuração `postgresql-config.yml` com seu editor favorito. Confira alguns [exemplos de arquivos de configuração.](#examples).

6. Para ativar a análise e o encaminhamento automáticos do Postgresql, copie ou renomeie o arquivo `postgresql-log.yml.example` para `postgresql-log.yml`. Você não precisa reiniciar o agente, mas pode ser necessário atualizar o arquivo YML com a localização do seu arquivo de log postgresql, se não estiver usando os locais padrão.

   Por exemplo:

   ````shell
   sudo cp /etc/newrelic-infra/logging.d/postgresql-log.yml.example /etc/newrelic-infra/logging.d/postgresql-log.yml
   ```  
   ````

### Outros ambientes [#other-env]

<CollapserGroup>
  <Collapser
    id="windows-install"
    title={<><img src="/images/os_icon_windows.webp" title="Windows installation" alt="Windows installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }}>Instalação do Windows</img></>}
  >
    1. Baixe a imagem do instalador `nri-postgresql` .MSI em:

       [https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-postgresql/nri-postgresql-amd64.msi](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-postgresql/nri-postgresql-amd64.msi)

    2. Para instalar a partir do prompt de comando do Windows, execute:

       ```shell
       msiexec.exe /qn /i PATH\TO\nri-postgresql-amd64.msi
       ```

    3. No diretório integração, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, crie uma cópia do arquivo de configuração de amostra executando:

       ```shell
       cp postgresql-config.yml.sample postgresql-config.yml
       ```

    4. Edite o arquivo `postgresql-config.yml` conforme descrito em [arquivos de amostra postgresql-config.yml](#examples).
  </Collapser>

  <Collapser
    id="ecs-install"
    title={<><img src="/images/os_icon_ecs.webp" title="Amazon ECS installation" alt="Amazon ECS installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }}>' 'Instalação do Amazon ECS</img></>}
  >
    Consulte [Monitorar serviço em execução no ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
  </Collapser>

  <Collapser
    id="k8s-install"
    title={<><img src="/images/os_icon_k8.webp" title="Kubernetes installation" alt="Kubernetes installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }}>Kubernetes Instalação</img></>}
  >
    Consulte [Monitorar serviço em execução no Kubernetes](/docs/monitor-service-running-kubernetes).
  </Collapser>
</CollapserGroup>

Notas Adicionais:

* <DNT>
    **Advanced:**
  </DNT>

  integração também estão disponíveis em [formato tarball](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball) para permitir a instalação fora de um gerenciador de pacote.

* <DNT>
    **On-host integrations do not automatically update.**
  </DNT>

  Para obter melhores resultados, [atualize regularmente o pacote de integração](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) e [o agente de infraestrutura](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

<InstallFeedback/>

## Configurar a integração [#config]

Existem diversas maneiras de configurar a integração, dependendo de como você a instalou:

* Se habilitado através

  <img
    style={{ width: '32px', height: '32px'}}
    class="inline"
    title="Kubernetes"
    alt="Kubernetes"
    src="/images/os_icon_k8.webp"
  >
    Kubernetes,[consulte Monitorar serviços em execução no Kubernetes](/docs/monitor-service-running-kubernetes).
  </img>

* Se habilitado através

  <img
    style={{ width: '32px', height: '32px'}}
    class="inline"
    title="ECS"
    alt="ECS"
    src="/images/os_icon_ecs.webp"
  >
    Amazon ECS, consulte [Monitorar serviços em execução no ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
  </img>

* Se instalado no host, edite a configuração no arquivo de configuração YAML da integração, `postgresql-config.yml`. A configuração no formato YAML de uma integração é onde você pode colocar as credenciais de login necessárias e configurar como os dados são coletados. Quais opções você altera dependem de sua configuração e preferência. O arquivo de configuração possui configurações comuns aplicáveis a toda integração, como `interval`, `timeout`, `inventory_source`. Para ler tudo sobre essas configurações comuns, consulte nosso documento [Formato de configuração](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) .

<Callout variant="important">
  Se você ainda estiver usando nossos arquivos de configuração ou definição de legado, verifique o [formato de configuração padrão](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/).
</Callout>

Configurações específicas relacionadas ao PostgreSQL são definidas usando a seção `env` do arquivo de configuração. Essas configurações controlam a conexão com sua instância do PostgreSQL, bem como outras configurações e recursos de segurança. A lista de configurações válidas é descrita na próxima seção deste documento.

## Usuário e permissões do PostgreSQL [#create-user]

Crie um usuário com `SELECT` permissões em:

* `pg_stat_database`
* `pg_stat_database_conflicts`
* `pg_stat_bgwriter`

Para criar o usuário para a integração PostgreSQL:

```sql
CREATE USER new_relic WITH PASSWORD MY_PASSWORD;
GRANT SELECT ON pg_stat_database TO new_relic;
GRANT SELECT ON pg_stat_database_conflicts TO new_relic;
GRANT SELECT ON pg_stat_bgwriter TO new_relic;
```

Isto permitirá à integração reunir métricas globais relacionadas com a instância PostgreSQL.

Se você também deseja obter métricas relacionadas a tabelas e índices (por exemplo, tamanho da tabela e tamanho do índice), o papel PostgreSQL usado pela integração (`new_relic`) também precisa de permissões `SELECT` nas tabelas das quais irá coletar métricas de. Por exemplo, para permitir que a integração recolha métricas de todas as tabelas e índices presentes no banco de dados (no público `schema`), utilize o seguinte:

```sql
GRANT SELECT ON ALL TABLES IN SCHEMA public TO new_relic;
```

Se você também deseja obter métricas de nível de consulta a partir do arquivo de configuração de consulta customizado do PostgreSQL, a função PostgreSQL usada pela integração (`new_relic`) precisa ser adicionada à função (`pg_read_all_stats`). Isso ocorre porque o usuário aproveita a extensão (`pg_stat_statements`).

```sql
GRANT pg_read_all_stats TO new_relic;
```

A ativação da extensão `pg_stat_statements` pode exigir que você a crie manualmente a partir de um prompt de consulta:

```sql
CREATE EXTENSION pg_stat_statements;
```

### Arquivos de amostra postgresql-config.yml [#examples]

<CollapserGroup>
  <Collapser
    id="example-postgresSQL-collection-config"
    title="Arquivo de coleta de configuração do PostgreSQL"
  >
    * Matriz JSON: Interpretada como uma lista de nomes de bancos de dados da qual serão coletadas todas as métricas relevantes, incluindo quaisquer tabelas e índices pertencentes a esse banco de dados.

      Por exemplo:

      ```yml
      collection_list: '["postgres"]'
      ```

    * Objeto JSON: será coletada apenas a entidade especificada no objeto, nenhuma descoberta automática será realizada. Os níveis de JSON são `database name -> schema name -> table name -> index name`.

      Por exemplo:

      ```yml
      collection_list: '{"postgres":{"public":{"pg_table1":["pg_index1","pg_index2"],"pg_table2":[]}}}'
      ```

    * `ALL`: coleta métricas para todos os bancos de dados, esquemas, tabelas e índices descobertos.

      Por exemplo:

      ```yml
      collection_list: 'ALL'
      ```

      ```yml
      integrations:
        - name: nri-postgresql
          env:
            USERNAME: postgres
            PASSWORD: pass
            HOSTNAME: psql-sample.localnet
            PORT: 6432
            DATABASE: postgres

            COLLECT_DB_LOCK_METRICS: false
            COLLECTION_LIST: '{"postgres":{"public":{"pg_table1":["pg_index1","pg_index2"],"pg_table2":[]}}}'
            TIMEOUT:  10
          interval: 15s
          labels:
            env: production
            role: postgresql
          inventory_source: config/postgresql
      ```
  </Collapser>

  <Collapser
    id="example-postgresSQL-managed-db-service-config"
    title="Arquivo de configuração PostgreSQL Azure Flexível e AWS RDS/Aurora"
  >
    * Opções habilitadas para SSL do Azure/AWS: as ofertas de banco de dados gerenciado flexível do Azure exigem SSL para se conectar. AWS RDS/Aurora pode exigir SSL se sua versão MySQL for 5.7+ e require_secure_transport estiver definido como ON em seu grupo de parâmetros Aurora. Para acomodar o requisito SSL, essas configurações no postgresql-config.yml precisam ser definidas como `true`.

      Por exemplo:

      ```yml
      ENABLE_SSL: "true"
      TRUST_SERVER_CERTIFICATE: "true"
      ```

    * Opções desabilitadas de SSL do Azure/AWS : Além das configurações acima, as seguintes configurações de SSL devem ser comentadas ou removidas da configuração. Isso se deve ao fato de a configuração confiar no certificado do servidor acima.

      Por exemplo:

      ```yml
      # SSL_ROOT_CERT_LOCATION: /etc/newrelic-infra/root_cert.crt
      # SSL_CERT_LOCATION: /etc/newrelic-infra/postgresql.crt
      # SSL_KEY_LOCATION: /etc/newrelic-infra/postgresql.key
      ```

    * Resumo: Depois que essas configurações estiverem em vigor, o arquivo de configuração completo do Azure/AWS deverá ser semelhante ao mostrado abaixo. Observação: o infra agente e a integração Postgresql devem ser instalados em um host com acesso de rede à instância do banco de dados.

      Por exemplo:

      ```yml
      integrations:
        - name: nri-postgresql
          env:
            USERNAME: newrelic
            PASSWORD: password
            HOSTNAME: AWS-or-Azure-instance-name
            PORT: 5432
            DATABASE: postgres
            COLLECT_DB_LOCK_METRICS: false
            COLLECTION_LIST: 'ALL'
            ENABLE_SSL: "true"
            TRUST_SERVER_CERTIFICATE: "true"
            # SSL_ROOT_CERT_LOCATION: /etc/newrelic-infra/root_cert.crt
            # SSL_CERT_LOCATION: /etc/newrelic-infra/postgresql.crt
            # SSL_KEY_LOCATION: /etc/newrelic-infra/postgresql.key
            TIMEOUT:  10
          interval: 15s
          labels:
            env: production
            role: postgresql
          inventory_source: config/postgresql
      ```
  </Collapser>

  <Collapser
    id="example-postgresSQL-SSL-config"
    title="Arquivo de coleta de configuração SSL do PostgreSQL"
  >
    ```yml
    integrations:
      - name: nri-postgresql
        env:
          USERNAME: postgres
          PASSWORD: pass
          HOSTNAME: psql-sample.localnet
          PORT: 6432
          DATABASE: postgres

          COLLECT_DB_LOCK_METRICS: false
          COLLECTION_LIST: '["postgres"]'
          ENABLE_SSL: true
          TRUST_SERVER_CERTIFICATE: false
          SSL_ROOT_CERT_LOCATION: /etc/newrelic-infra/root_cert.crt
          SSL_CERT_LOCATION: /etc/newrelic-infra/postgresql.crt
          SSL_KEY_LOCATION: /etc/newrelic-infra/postgresql.key
          TIMEOUT:  10
        interval: 15s
        labels:
          env: production
          role: postgresql
        inventory_source: config/postgresql
    ```
  </Collapser>

  <Collapser
    id="example-postgresSQL-custom-query-config"
    title="Consulta personalizada PostgreSQL"
  >
    ```yml
    integrations:
      - name: nri-postgresql
        env:
          USERNAME: postgres
          PASSWORD: pass
          HOSTNAME: psql-sample.localnet
          PORT: 6432
          DATABASE: postgres

          COLLECT_DB_LOCK_METRICS: false
          COLLECTION_LIST: ALL
          CUSTOM_METRICS_QUERY: >-
            select
              'rows_inserted' as "metric_name",
              'delta' as "metric_type",
              sd.tup_inserted as "metric_value",
              sd.datid as "database_id"
              from pg_stat_database sd;
          TIMEOUT:  10
        interval: 15s
        labels:
          env: production
          role: postgresql
        inventory_source: config/postgresql
    ```
  </Collapser>

  <Collapser
    id="example-postgresSQL-custom-query-config-file"
    title="Arquivo de configuração de consulta personalizada do PostgreSQL"
  >
    Um arquivo de configuração YAML adicional com um ou mais SQL customizados pode ser definido e a integração precisará do caminho para o arquivo no parâmetro CUSTOM_METRICS_CONFIG.

    * postgresql-config.yml

      ```yml
      integrations:
        - name: nri-postgresql
          env:
            USERNAME: postgres
            PASSWORD: pass
            HOSTNAME: psql-sample.localnet
            PORT: 6432
            DATABASE: postgres

            COLLECT_DB_LOCK_METRICS: false
            COLLECTION_LIST: ALL
            CUSTOM_METRICS_CONFIG: "path/to/postgresql-custom-query.yml"
            TIMEOUT:  10
          interval: 15s
          labels:
            env: production
            role: postgresql
          inventory_source: config/postgresql
      ```

    * postgresql-custom-query.yml

      ```yml
      ---
      queries:

        # Metric names are set to the column names in the query results
        - query: >-
            SELECT
            BG.checkpoints_timed AS scheduled_checkpoints_performed,
            BG.checkpoints_req AS requested_checkpoints_performed,
            BG.buffers_checkpoint AS buffers_written_during_checkpoint,
            BG.buffers_clean AS buffers_written_by_background_writer,
            BG.maxwritten_clean AS background_writer_stops,
            BG.buffers_backend AS buffers_written_by_backend,
            BG.buffers_alloc AS buffers_allocated
            FROM pg_stat_bgwriter BG;

          # database defaults to the auth database in the main config
          database: new_frontier_config_dev

          # If not set explicitly here, metric type will default to
          # 'gauge' for numbers and 'attribute' for strings
          metric_types:
            buffers_allocated: rate

          # If unset, sample_name defaults to PostgresqlCustomSample
          sample_name: MyCustomSample
      ```
  </Collapser>
</CollapserGroup>

Para obter mais informações sobre a estrutura geral da configuração de integração no host, consulte [Configuração](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview).

## Opções de configuração para a integração [#config-options]

Para obter mais informações sobre como encontrar e usar seus dados, consulte [Configurações de configuração do PostgreSQL](/docs/infrastructure/host-integrations/host-integrations-list/postgresql/postgresql-config).

## Encontre e use dados [#find-and-use]

Os dados deste serviço são reportados para um [dashboard de integração](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts).

métrica estão anexadas a estes [tipos de eventos](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic):

* [Métrica PostgresqlDatabaseSample](#databaseSample)
* [Métrica PostgresqlIndexSample](#indexSample)
* [Métrica PostgresqlInstanceSample](#instanceSample)
* [Métrica PostgresqlTableSample](#tableSample)
* [Métrica PgBouncerSample](#pgBouncerSample)

Você pode [consultar esses dados](/docs/using-new-relic/data/understand-data/query-new-relic-data) para fins de resolução de problemas ou para criar gráficos e dashboards personalizados.

Para saber mais sobre como encontrar e usar seus dados, consulte como [entender os dados de integração](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Métrica coletada pela integração [#metrics]

A integração PostgreSQL recolhe a seguinte métrica. Alguns nomes de métricas são prefixados com um indicador de categoria e um ponto, como `db.` ou `index.`.

<CollapserGroup>
  <Collapser
    id="databaseSample"
    title="Métrica PostgresqlDatabaseSample"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgreSQLDatabaseSample atributo
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `db.connections`
          </td>

          <td>
            Número de backend atualmente conectados a este banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `db.maxconnections`
          </td>

          <td>
            O número máximo de conexões simultâneas com o servidor de banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `db.commitsPerSecond`
          </td>

          <td>
            Transação cometida por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `db.rollbacksPerSecond`
          </td>

          <td>
            Transação revertida por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `db.readsPerSecond`
          </td>

          <td>
            Número de blocos de disco lidos neste banco de dados por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `db.bufferHitsPerSecond`
          </td>

          <td>
            Número de vezes que blocos de disco já foram encontrados no cache do buffer, de modo que uma leitura não foi necessária. Isso inclui apenas ocorrências no cache do buffer do PostgreSQL, e não no cache do sistema de arquivos do sistema operacional.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsReturnedPerSecond`
          </td>

          <td>
            Linhas retornadas pela consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsFetchedPerSecond`
          </td>

          <td>
            Linhas buscadas por consulta por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsInsertedPerSecond`
          </td>

          <td>
            Linhas inseridas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsUpdatedPerSecond`
          </td>

          <td>
            Linhas atualizadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsDeletedPerSecond`
          </td>

          <td>
            Linhas excluídas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.tablespacePerSecond`
          </td>

          <td>
            Número de consultas neste banco de dados que foram canceladas devido à eliminação de tablespaces.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.locksPerSecond`
          </td>

          <td>
            Quantidade de consultas neste banco de dados que foram canceladas por timeout de bloqueio.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.snapshotPerSecond`
          </td>

          <td>
            Número de consultas neste banco de dados que foram canceladas devido a snapshots antigos.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.bufferpinPerSecond`
          </td>

          <td>
            Número de consultas neste banco de dados que foram canceladas devido a buffers fixados.
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.deadlockPerSecond`
          </td>

          <td>
            Número de consultas neste banco de dados que foram canceladas devido a impasses.
          </td>
        </tr>

        <tr>
          <td>
            `db.tempFilesCreatedPerSecond`
          </td>

          <td>
            Quantidade de arquivos temporários criados pela consulta neste banco de dados. Todos os arquivos temporários são contados, independentemente do motivo pelo qual o arquivo temporário foi criado (por exemplo, classificação ou hash) e independentemente da configuração `log_temp_files` .
          </td>
        </tr>

        <tr>
          <td>
            `db.tempWrittenInBytesPerSecond`
          </td>

          <td>
            Quantidade total de dados gravados em arquivos temporários por consulta neste banco de dados. Todos os arquivos temporários são contados, independentemente do motivo pelo qual o arquivo temporário foi criado e da configuração `log_temp_files` .
          </td>
        </tr>

        <tr>
          <td>
            `db.deadlocksPerSecond`
          </td>

          <td>
            Número de deadlocks detectados neste banco de dados.
          </td>
        </tr>

        <tr>
          <td>
            `db.readTimeInMillisecondsPerSecond`
          </td>

          <td>
            Tempo gasto na leitura de blocos de arquivos de dados pelo backend neste banco de dados, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `db.writeTimeInMillisecondsPerSecond`
          </td>

          <td>
            Tempo gasto na gravação de blocos de arquivos de dados pelo backend neste banco de dados, em milissegundos.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="indexSample"
    title="Métrica PostgresqlIndexSample"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgreSQLIndexSample atributo
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `index.sizeInBytes`
          </td>

          <td>
            O tamanho de um índice.
          </td>
        </tr>

        <tr>
          <td>
            `index.rowsReadPerSecond`
          </td>

          <td>
            O número de entradas de índice retornadas por varreduras neste índice.
          </td>
        </tr>

        <tr>
          <td>
            `index.rowsFetchedPerSecond`
          </td>

          <td>
            O número de entradas de índice obtidas por varreduras neste índice.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="instanceSample"
    title="Métrica PostgresqlInstanceSample"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgreSQLInstanceSample atributo
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `bgwriter.checkpointsScheduledPerSecond`
          </td>

          <td>
            Número de pontos de verificação agendados que foram executados.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.checkpointsRequestedPerSecond`
          </td>

          <td>
            Número de pontos de verificação solicitados que foram executados.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersWrittenForCheckpointsPerSecond`
          </td>

          <td>
            Número de buffers gravados durante os pontos de verificação.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersWrittenByBackgroundWriterPerSecond`
          </td>

          <td>
            Número de buffers gravados pelo gravador em segundo plano.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.backgroundWriterStopsPerSecond`
          </td>

          <td>
            Número de vezes que o gravador em segundo plano interrompeu uma varredura de limpeza porque havia gravado muitos buffers.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersWrittenByBackendPerSecond`
          </td>

          <td>
            Número de buffers gravados diretamente por um backend.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersAllocatedPerSecond`
          </td>

          <td>
            Número de buffers alocados.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.backendFsyncCallsPerSecond`
          </td>

          <td>
            Número de vezes que um backend teve que executar sua própria chamada `fsync`. Normalmente, o gravador de segundo plano lida com eles mesmo quando o backend faz sua própria gravação.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.checkpointWriteTimeInMillisecondsPerSecond`
          </td>

          <td>
            Quantidade total de tempo gasto na parte do processamento do ponto de verificação em que os arquivos são gravados no disco, em milissegundos.
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.checkpointSyncTimeInMillisecondsPerSecond`
          </td>

          <td>
            Quantidade total de tempo gasto na parte do processamento do ponto de verificação em que os arquivos são sincronizados com o disco, em milissegundos.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="tableSample"
    title="Métrica PostgresqlTableSample"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgreSQLTableSample atributo
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `table.totalSizeInBytes`
          </td>

          <td>
            O espaço total em disco usado pela tabela, incluindo índices e dados TOAST.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexSizeInBytes`
          </td>

          <td>
            O espaço total em disco usado pelos índices anexados à tabela especificada.
          </td>
        </tr>

        <tr>
          <td>
            `table.liveRows`
          </td>

          <td>
            Número de linhas ativas.
          </td>
        </tr>

        <tr>
          <td>
            `table.deadRows`
          </td>

          <td>
            Número de linhas mortas.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexBlocksReadPerSecond`
          </td>

          <td>
            O número de blocos de disco lidos de todos os índices desta tabela.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexBlocksHitPerSecond`
          </td>

          <td>
            O número de ocorrências de buffer em todos os índices desta tabela.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexToastBlocksReadPerSecond`
          </td>

          <td>
            O número de blocos de disco lidos no índice da tabela TOAST desta tabela.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexToastBlocksHitPerSecond`
          </td>

          <td>
            O número de ocorrências de buffer no índice da tabela TOAST desta tabela.
          </td>
        </tr>

        <tr>
          <td>
            `table.lastVacuum`
          </td>

          <td>
            Hora do último vácuo na mesa.
          </td>
        </tr>

        <tr>
          <td>
            `table.lastAutoVacuum`
          </td>

          <td>
            Hora do último vácuo automático na mesa.
          </td>
        </tr>

        <tr>
          <td>
            `table.lastAnalyze`
          </td>

          <td>
            Hora da última análise na tabela.
          </td>
        </tr>

        <tr>
          <td>
            `table.lastAutoAnalyze`
          </td>

          <td>
            Hora da última análise automática na tabela.
          </td>
        </tr>

        <tr>
          <td>
            `table.sequentialScansPerSecond`
          </td>

          <td>
            Número de verificações sequenciais iniciadas nesta tabela por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `table.sequentialScanRowsFetchedPerSecond`
          </td>

          <td>
            Número de linhas ativas buscadas por verificações sequenciais por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexScansPerSecond`
          </td>

          <td>
            Número de varreduras de índice iniciadas nesta tabela.
          </td>
        </tr>

        <tr>
          <td>
            `table.indexScanRowsFetchedPerSecon`
          </td>

          <td>
            Número de linhas ativas buscadas por varreduras de índice.
          </td>
        </tr>

        <tr>
          <td>
            `table.rowsInsertedPerSecond`
          </td>

          <td>
            Linhas inseridas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `table.rowsUpdatedPerSecond`
          </td>

          <td>
            Linhas atualizadas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `table.rowsDeletedPerSecond`
          </td>

          <td>
            Linhas excluídas por segundo.
          </td>
        </tr>

        <tr>
          <td>
            `table.bloatSizeInBytes`
          </td>

          <td>
            Tamanho do inchaço em bytes.
          </td>
        </tr>

        <tr>
          <td>
            `table.dataSizeInBytes`
          </td>

          <td>
            Tamanho do espaçamento em disco usado pela bifurcação principal da tabela.
          </td>
        </tr>

        <tr>
          <td>
            `table.bloatRatio`
          </td>

          <td>
            Fração do tamanho dos dados da tabela que está inchada.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="pgBouncerSample"
    title="Métrica PgBouncerSample"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PgBouncerSample atributo
          </th>

          <th>
            Descrição
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `pgbouncer.stats.transactionsPerSecond`
          </td>

          <td>
            A taxa de transação.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.queriesPerSecond`
          </td>

          <td>
            A taxa de consulta.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.bytesInPerSecond`
          </td>

          <td>
            O tráfego de rede total recebido.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.bytesOutPerSecond`
          </td>

          <td>
            O tráfego de rede total enviado.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.totalTransactionDurationInMillisecondsPerSecond`
          </td>

          <td>
            Tempo gasto por `pgbouncer` na transação.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.totalQueryDurationInMillisecondsPerSecond`
          </td>

          <td>
            Tempo gasto por `pgbouncer` consultando ativamente o PostgreSQL.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgTransactionCount`
          </td>

          <td>
            O número médio de transações por segundo no último período estatístico.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgTransactionDurationInMilliseconds`
          </td>

          <td>
            A duração média da transação.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgQueryCount`
          </td>

          <td>
            O número médio de consultas por segundo no último período estatístico.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgBytesIn`
          </td>

          <td>
            O tráfego de rede do cliente recebido.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgBytesOut`
          </td>

          <td>
            O tráfego de rede do cliente enviado.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgQueryDurationInMilliseconds`
          </td>

          <td>
            A duração média da consulta.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsActive`
          </td>

          <td>
            Conexões do cliente vinculadas à conexão do servidor e capazes de processar consultas.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsWaiting`
          </td>

          <td>
            Conexões de cliente aguardando uma conexão de servidor.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsWaitingCancelReq`
          </td>

          <td>
            Conexões de clientes que ainda não encaminharam cancelamentos de consulta ao servidor.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsActiveCancelReq`
          </td>

          <td>
            Conexões de cliente que encaminharam cancelamentos de consulta ao servidor e estão aguardando a resposta do servidor.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsActiveCancel`
          </td>

          <td>
            Conexões de servidor que estão encaminhando uma solicitação de cancelamento no momento.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsBeingCancel`
          </td>

          <td>
            Servidores que normalmente poderiam ficar ociosos, mas estão aguardando até que todas as solicitações de cancelamento em andamento sejam concluídas e que foram enviadas para cancelar uma consulta neste servidor.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsActive`
          </td>

          <td>
            Conexões de servidor vinculadas a uma conexão de cliente.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsIdle`
          </td>

          <td>
            Conexões do servidor inativas e prontas para uma consulta do cliente.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsUsed`
          </td>

          <td>
            As conexões do servidor ficam ociosas por mais de `server_check_delay`, precisando de `server_check_query`.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsTested`
          </td>

          <td>
            Conexões de servidor atualmente em execução `server_reset_query` ou `server_check_query`.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsLogin`
          </td>

          <td>
            Conexões do servidor atualmente em processo de login.
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.maxwaitInMilliseconds`
          </td>

          <td>
            Idade da conexão de cliente não atendida mais antiga.
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>
