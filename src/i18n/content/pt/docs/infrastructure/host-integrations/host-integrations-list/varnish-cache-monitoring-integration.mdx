---
title: Varnish Cache monitoramento integração
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: 'New Relic''s Varnish Cache integration: how to install it and configure it, and what data it reports.'
freshnessValidatedDate: never
translationType: machine
---

A [integração no host do](/docs/integrations/host-integrations/getting-started/introduction-host-integrations) Varnish Cache coleta e envia inventário e métricas do seu ambiente Varnish Cache para New Relic para que você possa monitor sua integridade. Coletamos métricas nos níveis de instância, bloqueio, pool de memória, armazenamento e backend .

Continue lendo para instalar a integração e ver quais dados coletamos.

## Compatibilidade e requisitos [#comp-req]

Nossa integração é compatível com Varnish Cache 1.0 ou superior.

Antes de instalar a integração, certifique-se de atender aos seguintes requisitos:

* [Instale o agente de infraestrutura](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic).
* Distribuição Linux ou versão Windows [compatível com nosso agente de infraestrutura](/docs/infrastructure/new-relic-infrastructure/getting-started/compatibility-requirements-new-relic-infrastructure).

## Começo rápido [#quick]

Instrua seu ambiente Varnish Cache rapidamente e envie seus dados de telemetria com instalação guiada. Nossa instalação guiada cria um comando CLI personalizado para o seu ambiente que baixa e instala a CLI do New Relic e o agente de infraestrutura.

Pronto para começar? Clique em um desses botões para experimentar.

<ButtonGroup>
  <ButtonLink role="button" to="https://one.newrelic.com/marketplace/install-data-source?state=eda6d17b-58b5-5e7a-18ca-3b4ce777ecff" variant="primary">
    Instalação guiada
  </ButtonLink>

  <ButtonLink role="button" to="https://one.eu.newrelic.com/marketplace/install-data-source?state=eda6d17b-58b5-5e7a-18ca-3b4ce777ecff" variant="primary">
    UE instalação guiada
  </ButtonLink>
</ButtonGroup>

Nossa instalação guiada usa o agente de infraestrutura para configurar a integração do Varnish Cache. Além disso, ele descobre outros aplicativos e fontes log em execução no seu ambiente e recomenda quais você deve usar.

A instalação guiada funciona com a maioria das configurações. Mas se não atender às suas necessidades, você pode encontrar outros métodos abaixo para começar a monitorar seu ambiente Varnish Cache.

## Instalar e ativar [#install]

Para instalar a integração do Varnish Cache:

<CollapserGroup>
  <Collapser id="linux-install" title="Instalação Linux">
    1. Instale [o agente de infraestrutura](/docs/integrations/host-integrations/installation/install-infrastructure-host-integrations/#install) e substitua a variável `INTEGRATION_FILE_NAME` por `nri-varnish`.

    2. Mude o diretório para a pasta integração:

       ```
       cd /etc/newrelic-infra/integrations.d
       ```

    3. Cópia do arquivo de configuração de amostra:

       ```
       sudo cp varnish-config.yml.sample varnish-config.yml
       ```

    4. Edite o arquivo `varnish-config.yml` conforme descrito nas [definições de configuração](#config).
  </Collapser>

  <Collapser id="windows-install" title="Instalação do Windows">
    1. Baixe a imagem do instalador `nri-varnish` .MSI em:

       [https://download.newrelic.com/infrastructure\_agent/windows/integrations/nri-varnish/nri-varnish-amd64.msi](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-varnish/nri-varnish-amd64.msi)

    2. Para instalar a partir do prompt de comando do Windows, execute:

       ```shell
       msiexec.exe /qn /i PATH\TO\nri-varnish-amd64.msi
       ```

    3. No diretório integração, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, crie uma cópia do arquivo de configuração de amostra executando:

       ```shell
       copy varnish-config.yml.sample varnish-config.yml
       ```

    4. Edite o arquivo `varnish-config.yml` conforme descrito nas [definições de configuração](#config).
  </Collapser>
</CollapserGroup>

Notas Adicionais:

* <DNT>**Advanced:**</DNT> Também é possível [instalar a integração a partir de um arquivo tarball](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball). Isso lhe dá controle total sobre o processo de instalação e configuração.
* <DNT>**On-host integrations do not automatically update.**</DNT> Para obter melhores resultados, [atualize regularmente o pacote de integração](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) e [o agente de infraestrutura](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

<InstallFeedback />

## Configurar a integração [#config]

A configuração no formato YAML de uma integração é onde você pode colocar as credenciais de login necessárias e configurar como os dados são coletados. Quais opções você altera dependem de sua configuração e preferência.

O arquivo de configuração possui configurações comuns aplicáveis a todas as integrações como `interval`, `timeout`, `inventory_source`. Para ler tudo sobre essas configurações comuns, consulte nosso documento [Formato de configuração](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) .

<Callout variant="important">
  Se você ainda estiver usando nossos arquivos de configuração/definição legados, consulte este [documento](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/) para obter ajuda.
</Callout>

Configurações específicas relacionadas ao Varnish são definidas usando a seção `env` do arquivo de configuração. Essas configurações controlam a conexão com sua instância do Varnish, bem como outras configurações de segurança e recurso. A lista de configurações válidas é descrita na seção a seguir.

### Configurações da instância do Varnish Cache [#instance-settings]

A integração Varnish Cache recolhe informação métrica(<strong>M</strong>) e de inventário(<strong>I</strong>). Verifique a coluna <DNT>**Applies To**</DNT> abaixo para descobrir quais configurações podem ser usadas para cada coleção específica:

&apos; &apos;

<table>
  <thead>
    <tr>
      <th style={{ width: '150px' }}>
        Contexto
      </th>

      <th>
        Descrição
      </th>

      <th>
        Padrão
      </th>

      <th>
        Aplica-se a
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <DNT>
          **INSTANCE\_NAME**
        </DNT>
      </td>

      <td>
        Nome definido pelo usuário para identificar dados desta instância no New Relic. <DNT>**Required**</DNT>.
      </td>

      <td>
        N/A
      </td>

      <td style={{ "text-align": "center" }}>
        MI
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **PARAMS\_CONFIG\_FILE**
        </DNT>
      </td>

      <td>
        A localização do arquivo de configuração `varnish.params` . Se este argumento for omitido, os seguintes locais serão verificados:

        * `/etc/default/varnish/varnish.params`

        * `/etc/sysconfig/varnish/varnish.params`

          Nota: A localização e o nome do arquivo de configuração do Varnish podem variar. Para obter detalhes, consulte [Diferentes locais do arquivo de configuração do Varnish](https://book.varnish-software.com/4.0/chapters/Getting_Started.html#different-locations-of-the-varnish-configuration-file). Para Varnish 6 e superiores este parâmetro não é obrigatório e a integração deverá ser configurada apenas para coleta de métricas. Veja [o exemplo do Verniz 6](#example6).
      </td>

      <td>
        N/A
      </td>

      <td style={{ "text-align": "center" }}>
        EU
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **VARNISH\_NAME**
        </DNT>
      </td>

      <td>
        Nome usado ao executar o daemon `varnishd` com um sinalizador `-n` personalizado. <DNT>**Optional**</DNT>.
      </td>

      <td>
        N/A
      </td>

      <td style={{ "text-align": "center" }}>
        M
      </td>
    </tr>

    <tr>
      <td>
        <DNT>
          **METRICS**
        </DNT>
      </td>

      <td>
        Defina como `true` para ativar a coleta somente de métricas.
      </td>

      <td>
        `false`
      </td>

      <td style={{ "text-align": "center" }} />
    </tr>

    <tr>
      <td>
        <DNT>
          **INVENTORY**
        </DNT>
      </td>

      <td>
        Defina como `true` para ativar a coleta somente de inventário.
      </td>

      <td>
        `false`
      </td>

      <td style={{ "text-align": "center" }} />
    </tr>
  </tbody>
</table>

Os comandos `varnish-config.yml` aceitam os seguintes argumentos:

Os valores para estas configurações podem ser definidos de diversas maneiras:

* Adicionando o valor diretamente no arquivo de configuração. Esta é a forma mais comum.
* Substituindo os valores das variáveis de ambiente usando a notação `{{}}` . Isso requer o agente de infraestrutura v1.14.0+. Leia mais [aqui](/docs/infrastructure/install-infrastructure-agent/configuration/configure-infrastructure-agent/#passthrough).
* Usando gerenciamento de segredos. Use isto para proteger informações confidenciais, como senhas que seriam expostas em texto simples no arquivo de configuração. Para obter mais informações, consulte [Gerenciamento de segredos](/docs/integrations/host-integrations/installation/secrets-management).

### Etiquetas/atributo personalizado [#labels]

Variáveis de ambiente podem ser usadas para controlar definições de configuração, como <InlinePopover type="licenseKey" />e, em seguida, são passadas para o agente de infraestrutura. Para obter instruções sobre como usar esse recurso, consulte [Configurar o agente de infraestrutura](/docs/infrastructure/new-relic-infrastructure/configuration/configure-infrastructure-agent#passthrough). Você pode decorar ainda mais sua métrica usando etiquetas. Os rótulos permitem que você adicione pares de valores principais atributo à sua métrica que você pode usar para consultar, filtrar ou agrupar sua métrica.<br /> Nosso arquivo de configuração de amostra padrão inclui exemplos de rótulos, mas, como não são obrigatórios, você pode remover, modificar ou adicionar novos de sua escolha.

```
 labels:
   env: production
   role: varnish
```

## Exemplo de configuração [#example-config]

Exemplo de configuração de arquivo `varnish-config.yml` :

<CollapserGroup>
  <Collapser id="example" title="Exemplo de configuração">
    Esta é a configuração básica para coletar métricas e inventário:

    ```
    integrations:
      - name: nri-varnish
        env:
          INSTANCE_NAME: new_relic
          PARAMS_CONFIG_FILE: /etc/default/varnish/varnish.params
        interval: 15s
        labels:
          env: production
          role: varnish
        inventory_source: config/varnish
    ```
  </Collapser>

  <Collapser id="example6" title="Configuração para Varnish 6+">
    Esta é uma configuração básica para o Varnish 6 ou superior. Somente métricas serão coletadas porque a partir do Varnish 6 o arquivo params ficou obsoleto.

    ```
    integrations:
      - name: nri-varnish
        env:
          INSTANCE_NAME: new_relic
          METRICS: true
        interval: 15s
        labels:
          env: production
          role: varnish
        inventory_source: config/varnish
    ```
  </Collapser>
</CollapserGroup>

Para obter mais informações sobre a estrutura geral da configuração de integração no host, consulte [Configuração](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview).

## Encontre e use dados [#find-and-use]

Para encontrar seus dados de integração no New Relic, acesse <DNT>**[one.newrelic.com &gt; All capabilities](https://one.newrelic.com/all-capabilities) &gt; Infrastructure &gt; Third-party services**</DNT> e selecione um dos links de integração do Varnish Cache.

No New Relic, os dados do Varnish Cache são anexados ao seguinte tipo de evento:

* `VarnishSample`
* `VarnishLockSample`
* `VarnishStorageSample`
* `VarnishMempoolSample`
* `VarnishBackendSample`

Para saber mais sobre como encontrar e usar seus dados, consulte [Compreender os dados de integração](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Dados métricos [#metrics]

A integração Varnish Cache recolhe os seguintes dados métricos atributo. Cada nome de métrica é prefixado com um indicador de categoria e um ponto, como `bans.` ou `main.`.

<Callout variant="tip">
  Várias métricas são calculadas como taxas (por segundo) em vez de totais, como os nomes das métricas podem sugerir. Para mais detalhes sobre quais métricas são calculadas como taxas, consulte o [arquivo spec.csv](https://github.com/newrelic/nri-varnish/blob/master/spec.csv).
</Callout>

### Amostra de Varnish métrica [#varnish-sample]

Esses atributos podem ser encontrados consultando os tipos de eventos VarnishSample.

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Métrica
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `backend.connectionBusy`
      </td>

      <td>
        Número de vezes que a conexão máxima foi atingida.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionFails`
      </td>

      <td>
        Número de conexões com falha com o backup.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionRecycles`
      </td>

      <td>
        Número de conexões backend que foram recicladas.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionRetries`
      </td>

      <td>
        Número de conexões backend que foram tentadas novamente.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionReuses`
      </td>

      <td>
        Número de reutilizações de conexões backend .
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionSuccess`
      </td>

      <td>
        Número de conexões backend bem-sucedidas,
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionUnHealthy`
      </td>

      <td>
        Número de conexões backend que não foram tentadas devido ao status backend &quot;não íntegro&quot;.
      </td>
    </tr>

    <tr>
      <td>
        `backend.fetches`
      </td>

      <td>
        Número total de buscas backend iniciadas.
      </td>
    </tr>

    <tr>
      <td>
        `backend.requests`
      </td>

      <td>
        Número total de solicitações de conexão backend feitas.
      </td>
    </tr>

    <tr>
      <td>
        `bans.added`
      </td>

      <td>
        Contador de banimentos adicionado à lista de banimentos.
      </td>
    </tr>

    <tr>
      <td>
        `bans.completed`
      </td>

      <td>
        Número de banimentos marcados como &apos;concluídos&apos;.
      </td>
    </tr>

    <tr>
      <td>
        `bans.cutoffLurkerKilled`
      </td>

      <td>
        Número de objetos mortos por proibições de corte (espreitador).
      </td>
    </tr>

    <tr>
      <td>
        `bans.deleted`
      </td>

      <td>
        Contador de banimentos excluídos da lista de banimentos.
      </td>
    </tr>

    <tr>
      <td>
        `bans.dups`
      </td>

      <td>
        Contagem de proibições substituídas por proibições idênticas posteriores.
      </td>
    </tr>

    <tr>
      <td>
        `bans.fragmentationInBytes`
      </td>

      <td>
        Bytes extras em listas de banimentos persistentes devido à fragmentação.
      </td>
    </tr>

    <tr>
      <td>
        `bans.lookupKilled`
      </td>

      <td>
        Número de objetos eliminados por banimentos durante a pesquisa de objetos.
      </td>
    </tr>

    <tr>
      <td>
        `bans.lookupTestsTested`
      </td>

      <td>
        Contagem de quantos testes e objetos foram testados entre si durante a pesquisa.
      </td>
    </tr>

    <tr>
      <td>
        `bans.lurkerCon`
      </td>

      <td>
        Número de vezes que o ban-lurker teve que esperar por pesquisas.
      </td>
    </tr>

    <tr>
      <td>
        `bans.lurkerKilled`
      </td>

      <td>
        Número de objetos mortos pelo ban-lurker.
      </td>
    </tr>

    <tr>
      <td>
        `bans.lurkerTested`
      </td>

      <td>
        Contagem de quantos banimentos e objetos foram testados entre si pelo ban-lurker.
      </td>
    </tr>

    <tr>
      <td>
        `bans.lurkerTestsTested`
      </td>

      <td>
        Contagem de quantos testes e objetos foram testados entre si durante o ban-lurker.
      </td>
    </tr>

    <tr>
      <td>
        `bans.obj`
      </td>

      <td>
        Número de banimentos usando variáveis `obj.*` . Essas proibições podem possivelmente ser eliminadas pelo espreitador de banimentos.
      </td>
    </tr>

    <tr>
      <td>
        `bans.persistedInBytes`
      </td>

      <td>
        Bytes usados pelas listas de banimentos persistentes.
      </td>
    </tr>

    <tr>
      <td>
        `bans.req`
      </td>

      <td>
        Número de banimentos que usam variáveis `req.*` . Essas proibições não podem ser eliminadas pelo espreitador de banimentos.
      </td>
    </tr>

    <tr>
      <td>
        `bans.tested`
      </td>

      <td>
        Contagem de quantos banimentos e objetos foram testados entre si durante a aplicação de pesquisa de hash.
      </td>
    </tr>

    <tr>
      <td>
        `cache.graceHits`
      </td>

      <td>
        Contagem de ocorrências no cache com graça. Uma ocorrência no cache com graça é uma ocorrência no cache onde o objeto expirou. Esses hits também foram incluídos no contador `cache_hit` .
      </td>
    </tr>

    <tr>
      <td>
        `cache.hits`
      </td>

      <td>
        Número de vezes que um objeto foi entregue a um cliente sem buscá-lo em um servidor backend .
      </td>
    </tr>

    <tr>
      <td>
        `cache.misses`
      </td>

      <td>
        Número de vezes que o objeto foi buscado no backend antes de entregá-lo ao cliente.
      </td>
    </tr>

    <tr>
      <td>
        `cache.missHits`
      </td>

      <td>
        Número de vezes que um objeto atingido foi retornado devido a uma resposta errada.
      </td>
    </tr>

    <tr>
      <td>
        `cache.passHits`
      </td>

      <td>
        Número de vezes que um objeto atingido foi retornado para uma resposta aprovada.
      </td>
    </tr>

    <tr>
      <td>
        `esi.errors`
      </td>

      <td>
        Edge Side Inclui (ESI) erros de análise (desbloqueio).
      </td>
    </tr>

    <tr>
      <td>
        `esi.warnings`
      </td>

      <td>
        Edge Side Inclui (ESI) avisos de análise (desbloqueio).
      </td>
    </tr>

    <tr>
      <td>
        `fetch.bad`
      </td>

      <td>
        O comprimento/busca de `beresp.body` não pôde ser determinado.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.chuncked`
      </td>

      <td>
        O `beresp.body` fragmentado.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.contentLength`
      </td>

      <td>
        O `beresp.body` com comprimento de conteúdo.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.eof`
      </td>

      <td>
        O `beresp.body` com EOF.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.failed`
      </td>

      <td>
        O `beresp` falhou.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.head`
      </td>

      <td>
        O `beresp` sem corpo porque a solicitação é HEAD.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.noBody`
      </td>

      <td>
        O `beresp` sem corpo.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.noBody1xx`
      </td>

      <td>
        O `beresp` sem corpo devido à resposta 1XX.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.noBody204`
      </td>

      <td>
        O `beresp` sem corpo devido à resposta 204.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.noBody304`
      </td>

      <td>
        O `beresp` sem corpo devido à resposta 304.
      </td>
    </tr>

    <tr>
      <td>
        `fetch.noThreadFail`
      </td>

      <td>
        A busca `beresp` falhou, nenhum thread disponível.
      </td>
    </tr>

    <tr>
      <td>
        `hcb.inserts`
      </td>

      <td>
        Número de inserções de hash de aplicação (HCB) baseadas em árvore de bits críticos.
      </td>
    </tr>

    <tr>
      <td>
        `hcb.lock`
      </td>

      <td>
        Número de pesquisas de HCB com bloqueio.
      </td>
    </tr>

    <tr>
      <td>
        `hcb.noLock`
      </td>

      <td>
        Número de pesquisas de HCB sem bloqueio.
      </td>
    </tr>

    <tr>
      <td>
        `lru.limited`
      </td>

      <td>
        Número de vezes que foi necessário mais espaço de armazenamento, mas o limite foi atingido.
      </td>
    </tr>

    <tr>
      <td>
        `lru.moved`
      </td>

      <td>
        Número de operações de movimentação realizadas na lista LRU.
      </td>
    </tr>

    <tr>
      <td>
        `lru.nuked`
      </td>

      <td>
        Número de objetos menos usados recentemente (LRU) despejados à força do armazenamento para abrir espaço para um novo objeto.
      </td>
    </tr>

    <tr>
      <td>
        `main.backends`
      </td>

      <td>
        Número de back-end.
      </td>
    </tr>

    <tr>
      <td>
        `main.bans`
      </td>

      <td>
        Contagem de proibições.
      </td>
    </tr>

    <tr>
      <td>
        `main.busyKilled`
      </td>

      <td>
        Número de solicitações encerradas após suspensão em objhdr ocupado.
      </td>
    </tr>

    <tr>
      <td>
        `main.busySleep`
      </td>

      <td>
        Número de solicitações enviadas para suspensão em objhdr ocupado.
      </td>
    </tr>

    <tr>
      <td>
        `main.busyWakeup`
      </td>

      <td>
        Número de solicitações despertadas após suspensão em objhdr ocupado.
      </td>
    </tr>

    <tr>
      <td>
        `main.expired`
      </td>

      <td>
        Número de objetos expirados.
      </td>
    </tr>

    <tr>
      <td>
        `main.expiredMailed`
      </td>

      <td>
        Número de objetos enviados para thread de expiração.
      </td>
    </tr>

    <tr>
      <td>
        `main.expiredReceived`
      </td>

      <td>
        Número de objetos recebidos pelo thread de expiração.
      </td>
    </tr>

    <tr>
      <td>
        `main.gunzip`
      </td>

      <td>
        Número de operações gunzip.
      </td>
    </tr>

    <tr>
      <td>
        `main.gunzipTest`
      </td>

      <td>
        Número de operações de teste do gunzip.
      </td>
    </tr>

    <tr>
      <td>
        `main.gzip`
      </td>

      <td>
        Número de operações gzip.
      </td>
    </tr>

    <tr>
      <td>
        `main.objectcores`
      </td>

      <td>
        Número de estruturas objectcore feitas.
      </td>
    </tr>

    <tr>
      <td>
        `main.objectheads`
      </td>

      <td>
        Número de estruturas objetadas feitas.
      </td>
    </tr>

    <tr>
      <td>
        `main.objects`
      </td>

      <td>
        Número de estruturas de objetos feitas.
      </td>
    </tr>

    <tr>
      <td>
        `main.passedRequests`
      </td>

      <td>
        Total de solicitações aprovadas vistas.
      </td>
    </tr>

    <tr>
      <td>
        `main.pipeSessions`
      </td>

      <td>
        Total de sessões de pipe vistas.
      </td>
    </tr>

    <tr>
      <td>
        `main.pools`
      </td>

      <td>
        Número de conjuntos de threads.
      </td>
    </tr>

    <tr>
      <td>
        `main.purgeObjects`
      </td>

      <td>
        Número de objetos eliminados.
      </td>
    </tr>

    <tr>
      <td>
        `main.purgeOperations`
      </td>

      <td>
        Número de operações de limpeza executadas.
      </td>
    </tr>

    <tr>
      <td>
        `main.reqDropped`
      </td>

      <td>
        Número de solicitações descartadas.
      </td>
    </tr>

    <tr>
      <td>
        `main.sessions`
      </td>

      <td>
        Número total de sessões visualizadas.
      </td>
    </tr>

    <tr>
      <td>
        `main.sessQueueLength`
      </td>

      <td>
        Comprimento da fila de sessões aguardando threads.
      </td>
    </tr>

    <tr>
      <td>
        `main.summs`
      </td>

      <td>
        Número de vezes que as estatísticas por thread foram somadas nos contadores globais.
      </td>
    </tr>

    <tr>
      <td>
        `main.syntheticResponses`
      </td>

      <td>
        Total de respostas sintéticas feitas.
      </td>
    </tr>

    <tr>
      <td>
        `main.threads`
      </td>

      <td>
        Número total de threads.
      </td>
    </tr>

    <tr>
      <td>
        `main.threadsCreated`
      </td>

      <td>
        Número total de threads criados em todos os pools.
      </td>
    </tr>

    <tr>
      <td>
        `main.threadsDestroyed`
      </td>

      <td>
        Número total de threads destruídos em todos os pools.
      </td>
    </tr>

    <tr>
      <td>
        `main.threadsFailed`
      </td>

      <td>
        Número de vezes que a criação de um thread falhou.
      </td>
    </tr>

    <tr>
      <td>
        `main.threadsLimited`
      </td>

      <td>
        Número de vezes que mais encadeamentos foram necessários, mas o limite foi atingido em um conjunto de encadeamentos.
      </td>
    </tr>

    <tr>
      <td>
        `main.unresurrectedObjects`
      </td>

      <td>
        Número de objetos não ressuscitados.
      </td>
    </tr>

    <tr>
      <td>
        `main.uptimeInMilliseconds`
      </td>

      <td>
        O tempo de operação do processo filho, em milissegundos.
      </td>
    </tr>

    <tr>
      <td>
        `main.vclAvailable`
      </td>

      <td>
        Número de linguagens de configuração de Varnish (VCL) disponíveis.
      </td>
    </tr>

    <tr>
      <td>
        `main.vclDiscarded`
      </td>

      <td>
        Número de VCLs descartadas.
      </td>
    </tr>

    <tr>
      <td>
        `main.vclFails`
      </td>

      <td>
        Número de falhas de VCL.
      </td>
    </tr>

    <tr>
      <td>
        `main.vclLoaded`
      </td>

      <td>
        Número total de VCLs carregadas.
      </td>
    </tr>

    <tr>
      <td>
        `main.vmodsLoaded`
      </td>

      <td>
        Número de módulos Varnish carregados (VMOD).
      </td>
    </tr>

    <tr>
      <td>
        `mgt.childDied`
      </td>

      <td>
        Número de vezes que o processo filho morreu devido a sinais.
      </td>
    </tr>

    <tr>
      <td>
        `mgt.childDump`
      </td>

      <td>
        Número de vezes que o processo filho produziu core dumps.
      </td>
    </tr>

    <tr>
      <td>
        `mgt.childExit`
      </td>

      <td>
        Número de vezes que o processo filho foi interrompido de forma limpa.
      </td>
    </tr>

    <tr>
      <td>
        `mgt.childPanic`
      </td>

      <td>
        Número de vezes que o processo de gerenciamento pegou uma criança em pânico.
      </td>
    </tr>

    <tr>
      <td>
        `mgt.childStart`
      </td>

      <td>
        Número de vezes que o processo filho foi iniciado.
      </td>
    </tr>

    <tr>
      <td>
        `mgt.childStop`
      </td>

      <td>
        Número de vezes que o processo filho foi interrompido de forma limpa.
      </td>
    </tr>

    <tr>
      <td>
        `mgt.uptimeInMilliseconds`
      </td>

      <td>
        O processo de gerenciamento tempo de operação, em milissegundos.
      </td>
    </tr>

    <tr>
      <td>
        `net.400Errors`
      </td>

      <td>
        Número de solicitações de clientes recebidas, sujeitas a 400 erros.
      </td>
    </tr>

    <tr>
      <td>
        `net.417Errors`
      </td>

      <td>
        Número de solicitações de clientes recebidas, sujeitas a erros 417
      </td>
    </tr>

    <tr>
      <td>
        `net.httpOverflow`
      </td>

      <td>
        Número de estouros de cabeçalho HTTP.
      </td>
    </tr>

    <tr>
      <td>
        `net.pipe.inInBytes`
      </td>

      <td>
        Número total de bytes encaminhados de clientes em sessões de pipe.
      </td>
    </tr>

    <tr>
      <td>
        `net.pipe.outInBytes`
      </td>

      <td>
        Número total de bytes encaminhados para clientes em sessões de pipe.
      </td>
    </tr>

    <tr>
      <td>
        `net.pipereq.headerInBytes`
      </td>

      <td>
        Total de bytes de solicitação recebidos para sessões canalizadas.
      </td>
    </tr>

    <tr>
      <td>
        `net.request.bodyInBytes`
      </td>

      <td>
        Total do corpo da solicitação transmitido, em bytes.
      </td>
    </tr>

    <tr>
      <td>
        `net.request.headerInBytes`
      </td>

      <td>
        Total de cabeçalhos de solicitação transmitidos, em bytes.
      </td>
    </tr>

    <tr>
      <td>
        `net.requests`
      </td>

      <td>
        Número de boas solicitações de clientes recebidas.
      </td>
    </tr>

    <tr>
      <td>
        `net.response.bodyInBytes`
      </td>

      <td>
        Corpo total de resposta transmitido, em bytes.
      </td>
    </tr>

    <tr>
      <td>
        `net.response.headerInBytes`
      </td>

      <td>
        Total de cabeçalhos de resposta transmitidos, em bytes.
      </td>
    </tr>

    <tr>
      <td>
        `sess.backendClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `RESP_CLOSE`, (backend/VCL solicitou fechamento).
      </td>
    </tr>

    <tr>
      <td>
        `sess.badClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `Error RX_BAD`, (req/resp incorreto recebido).
      </td>
    </tr>

    <tr>
      <td>
        `sess.bodyFailClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `Error RX_BODY`, (Falha ao receber req.body).
      </td>
    </tr>

    <tr>
      <td>
        `sess.clientClose`
      </td>

      <td>
        Número de sessões fechadas com erro `REM_CLOSE`, (Cliente fechado).
      </td>
    </tr>

    <tr>
      <td>
        `sess.clientReqClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `REQ_CLOSE`, (Cliente solicitou fechamento).
      </td>
    </tr>

    <tr>
      <td>
        `sess.closed`
      </td>

      <td>
        Número total de sessões fechadas.
      </td>
    </tr>

    <tr>
      <td>
        `sess.closedError`
      </td>

      <td>
        Número total de sessões fechadas com erros.
      </td>
    </tr>

    <tr>
      <td>
        `sess.dropped`
      </td>

      <td>
        Número de sessões descartadas por thread.
      </td>
    </tr>

    <tr>
      <td>
        `sess.eofTxnClose`
      </td>

      <td>
        Número de sessões fechadas com erro `TX_EOF`, (transmissão EOF).
      </td>
    </tr>

    <tr>
      <td>
        `sess.errorTxnClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `TX_ERROR`, (Erro de transação).
      </td>
    </tr>

    <tr>
      <td>
        `sess.herd`
      </td>

      <td>
        Número de vezes que `timeout_linger` foi acionado.
      </td>
    </tr>

    <tr>
      <td>
        `sess.junkClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `RX_JUNK`(dados indesejados recebidos).
      </td>
    </tr>

    <tr>
      <td>
        `sess.overflowClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `RX_OVERFLOW`, (estouro de buffer recebido).
      </td>
    </tr>

    <tr>
      <td>
        `sess.overloadClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `OVERLOAD`, (Sem algum recurso).
      </td>
    </tr>

    <tr>
      <td>
        `sess.pipeOverflowClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `PIPE_OVERFLOW`, (estouro de pipe de sessão).
      </td>
    </tr>

    <tr>
      <td>
        `sess.pipeTxnClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `TX_PIPE`, (transação canalizada).
      </td>
    </tr>

    <tr>
      <td>
        `sess.queued`
      </td>

      <td>
        Número de sessões enfileiradas para thread.
      </td>
    </tr>

    <tr>
      <td>
        `sess.readAhead`
      </td>

      <td>
        Sessão Leia Adiante.
      </td>
    </tr>

    <tr>
      <td>
        `sess.requestHTTP10Close`
      </td>

      <td>
        Número de sessões fechadas com o erro `REQ_HTTP10`, (Proto &lt; HTTP/1.1).
      </td>
    </tr>

    <tr>
      <td>
        `sess.requestHTTP20Close`
      </td>

      <td>
        Número de sessões fechadas com erro `REQ_HTTP20`, (HTTP2 não aceito).
      </td>
    </tr>

    <tr>
      <td>
        `sess.shortRangeClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `RANGE_SHORT`, (Dados insuficientes para intervalo).
      </td>
    </tr>

    <tr>
      <td>
        `sess.timeoutClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `RX_TIMEOUT`, (Tempo limite de recebimento).
      </td>
    </tr>

    <tr>
      <td>
        `sess.vclFailClose`
      </td>

      <td>
        Número de sessões fechadas com o erro `VCL_FAILURE`, (falha de VCL).
      </td>
    </tr>

    <tr>
      <td>
        `session.connections`
      </td>

      <td>
        Contagem de sessões aceitas com sucesso.
      </td>
    </tr>

    <tr>
      <td>
        `session.drops`
      </td>

      <td>
        A contagem de sessões foi interrompida silenciosamente devido à falta de thread de trabalho.
      </td>
    </tr>

    <tr>
      <td>
        `session.fail`
      </td>

      <td>
        Contagem de falhas ao aceitar a conexão TCP.
      </td>
    </tr>

    <tr>
      <td>
        `shm.contentions`
      </td>

      <td>
        Número de contenções MTX de memória compartilhada (SHM).
      </td>
    </tr>

    <tr>
      <td>
        `shm.cycles`
      </td>

      <td>
        Número de ciclos de SHM através do buffer.
      </td>
    </tr>

    <tr>
      <td>
        `shm.flushes`
      </td>

      <td>
        Número de liberações de SHM devido a estouro.
      </td>
    </tr>

    <tr>
      <td>
        `shm.records`
      </td>

      <td>
        Número de registros SHM.
      </td>
    </tr>

    <tr>
      <td>
        `shm.writes`
      </td>

      <td>
        Número de gravações SHM.
      </td>
    </tr>

    <tr>
      <td>
        `workspace.backendOverflow`
      </td>

      <td>
        Número de vezes que ficamos sem espaço em `workspace_backend`.
      </td>
    </tr>

    <tr>
      <td>
        `workspace.clientOverflow`
      </td>

      <td>
        Número de vezes que ficamos sem espaço em `workspace_client`.
      </td>
    </tr>

    <tr>
      <td>
        `workspace.deliveryFail`
      </td>

      <td>
        A entrega falhou devido a espaço de trabalho insuficiente.
      </td>
    </tr>

    <tr>
      <td>
        `workspace.sessionOverflow`
      </td>

      <td>
        Número de vezes que ficamos sem espaço em `workspace_session`.
      </td>
    </tr>

    <tr>
      <td>
        `workspace.threadOverflow`
      </td>

      <td>
        Número de vezes que ficamos sem espaço em `workspace_thread`.
      </td>
    </tr>
  </tbody>
</table>

### Amostra de bloqueio de Varnish métrica [#varnish-lock-sample]

Esses atributos podem ser encontrados consultando o tipo de evento `VarnishLockSample` .

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Métrica
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `lock.created`
      </td>

      <td>
        Contagem de bloqueios criados.
      </td>
    </tr>

    <tr>
      <td>
        `lock.destroyed`
      </td>

      <td>
        Contagem de fechaduras destruídas.
      </td>
    </tr>

    <tr>
      <td>
        `lock.locks`
      </td>

      <td>
        Contagem de operações de bloqueio.
      </td>
    </tr>
  </tbody>
</table>

### Métrica de amostra de armazenamento de Varnish [#varnish-storage-sample]

Esses atributos podem ser encontrados consultando o tipo de evento `VarnishStorageSample` .

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Métrica
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `storage.allocFails`
      </td>

      <td>
        Número de vezes que o armazenamento falhou ao fornecer um segmento de armazenamento.
      </td>
    </tr>

    <tr>
      <td>
        `storage.allocInBytes`
      </td>

      <td>
        Número total de bytes alocados por este armazenamento.
      </td>
    </tr>

    <tr>
      <td>
        `storage.allocOustanding`
      </td>

      <td>
        Número de alocações de armazenamento pendentes.
      </td>
    </tr>

    <tr>
      <td>
        `storage.allocReqs`
      </td>

      <td>
        Número de vezes que o armazenamento foi solicitado a fornecer um segmento de armazenamento.
      </td>
    </tr>

    <tr>
      <td>
        `storage.availableInBytes`
      </td>

      <td>
        Número de bytes restantes no armazenamento.
      </td>
    </tr>

    <tr>
      <td>
        `storage.freeInBytes`
      </td>

      <td>
        Número total de bytes retornados para este armazenamento.
      </td>
    </tr>

    <tr>
      <td>
        `storage.outstandingInBytes`
      </td>

      <td>
        Número de bytes alocados do armazenamento.
      </td>
    </tr>
  </tbody>
</table>

### Varnish mempool amostra métrica [#varnish-mempool-sample]

Esses atributos podem ser encontrados consultando o tipo de evento `VarnishMempoolSample` .

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Métrica
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `mempool.allocatedSizeInBytes`
      </td>

      <td>
        Tamanho alocado do conjunto de memória, em bytes.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.allocs`
      </td>

      <td>
        Alocações de pool de memória.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.frees`
      </td>

      <td>
        Número de conjuntos de memória livres.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.live`
      </td>

      <td>
        Número de pools de memória em uso.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.pool`
      </td>

      <td>
        Contagem no pool de memória.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.ranDry`
      </td>

      <td>
        A piscina secou.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.recycles`
      </td>

      <td>
        Reciclado da piscina.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.requestSizeInBytes`
      </td>

      <td>
        Tamanho da solicitação do pool de memória, em bytes.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.surplus`
      </td>

      <td>
        Muitos para piscina.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.timeouts`
      </td>

      <td>
        Tempo esgotado da piscina.
      </td>
    </tr>

    <tr>
      <td>
        `mempool.tooSmall`
      </td>

      <td>
        Muito pequeno para reciclar.
      </td>
    </tr>
  </tbody>
</table>

### Métrica de amostra backend de Varnish [#varnish-backend-sample]

Esses atributos podem ser encontrados consultando o tipo de evento `VarnishBackendSample` .

<table>
  <thead>
    <tr>
      <th style={{ width: "350px" }}>
        Métrica
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `backend.busyFetches`
      </td>

      <td>
        As buscas não foram tentadas devido ao backend estar ocupado.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connections`
      </td>

      <td>
        Número de conexões simultâneas com o backend.
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionsFailed`
      </td>

      <td>
        Falha no número de conexões backend .
      </td>
    </tr>

    <tr>
      <td>
        `backend.connectionsNotAttempted`
      </td>

      <td>
        Número de aberturas de conexão backend que não foram tentadas.
      </td>
    </tr>

    <tr>
      <td>
        `backend.happy`
      </td>

      <td>
        Boas sondagens de saúde.
      </td>
    </tr>

    <tr>
      <td>
        `backend.unhealtyFetches`
      </td>

      <td>
        Buscas não tentadas devido ao backend não ser íntegro
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.pipeHeaderInBytes`
      </td>

      <td>
        Total de bytes de solicitação enviados para sessões canalizadas.
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.pipeInInBytes`
      </td>

      <td>
        Número total de bytes encaminhados do backend em sessões de pipe.
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.pipeOutInBytes`
      </td>

      <td>
        Número total de bytes encaminhados para backend em sessões de pipe.
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.requestBodyInBytes`
      </td>

      <td>
        Total de bytes do corpo da solicitação backend enviados.
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.requestHeaderInBytes`
      </td>

      <td>
        Total de bytes de cabeçalho de solicitação backend enviados.
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.requests`
      </td>

      <td>
        Número de solicitações backend enviadas,
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.responseBodyInBytes`
      </td>

      <td>
        Total de bytes do corpo da resposta de backend recebidos.
      </td>
    </tr>

    <tr>
      <td>
        `net.backend.responseHeaderInBytes`
      </td>

      <td>
        Total de bytes de cabeçalho de resposta backend recebidos.
      </td>
    </tr>
  </tbody>
</table>

## Dados de inventário [#inventory]

A integração Varnish Cache captura o parâmetro de configuração. Ele analisa o arquivo de configuração `varnish.params` para todos os parâmetros que estão ativos.

Os dados estão disponíveis na [página Inventário](/docs/infrastructure/new-relic-infrastructure/infrastructure-ui-pages/infrastructure-inventory-page-search-your-entire-infrastructure), na origem <DNT>**config/varnish**</DNT> . Para obter mais informações sobre dados de inventário, consulte [Compreender os dados de integração](/docs/infrastructure/integrations-getting-started/getting-started/understand-integration-data-data-types#inventory-data).

## Verifique o código-fonte [#source-code]

Esta integração é um software de código aberto. Isso significa que você pode [navegar pelo código-fonte](https://github.com/newrelic/nri-varnish) e enviar melhorias, ou criar seu próprio fork e construí-lo.