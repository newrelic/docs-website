---
title: Integração de monitoramento JMX
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: 'New Relic''s JMX integration: how to install and configure it, and what data it reports.'
freshnessValidatedDate: never
translationType: machine
---

Nossa [integração](/docs/integrations/host-integrations/getting-started/introduction-host-integrations) JMX permite ao usuário monitor qualquer aplicativo que exponha métrica com JMX. A integração inclui um arquivo de coleta padrão que coleta automaticamente as principais métricas da JVM.

## Compatibilidade e requisitos [#comp-req]

Antes de instalar a integração, certifique-se de atender aos seguintes requisitos:

* Uma conta New Relic . Não tem um? [Cadastre-se gratuitamente!](https://newrelic.com/signup) Não é necessário cartão de crédito.
* Java versão 8 ou superior.
* Se você precisar usar uma versão Java diferente daquela configurada em `PATH`, siga [a documentação de configuração da New Relic no GitHub](https://github.com/newrelic/nrjmx#configuring-java-version).
* Esta integração não suporta o protocolo IIOP.

## Começo rápido [#quick]

Se você não estiver executando o JMX em ambientes Kubernetes ou ECS, recomendamos nossa instalação guiada. Nossa instalação guiada usa nosso agente de infraestrutura e nossa CLI para configurar a integração JMX e descobre outros aplicativos e fontes de log em execução em seu ambiente e, em seguida, recomenda quais deles você deve usar.

A instalação guiada funciona com a maioria das configurações. Mas se não atender às suas necessidades, existem outras opções de instalação abaixo.

Pronto para começar? Clique no botão relevante, dependendo da [região do data center](/docs/accounts/accounts-billing/account-setup/choose-your-data-center) que você usa. Quando terminar a instalação, retorne a esta documentação para revisar as opções de configuração.

<ButtonGroup>
  <ButtonLink
    role="button"
    to="https://one.newrelic.com/launcher/nr1-core.explorer?pane=eyJuZXJkbGV0SWQiOiJucjEtY29yZS5saXN0aW5nIn0=&cards[0]=eyJuZXJkbGV0SWQiOiJucjEtaW5zdGFsbC1uZXdyZWxpYy5ucjEtaW5zdGFsbC1uZXdyZWxpYyIsInBhdGgiOiJvaGkiLCJyZWNpcGVOYW1lIjoiYXBhY2hlLW9wZW4tc291cmNlLWludGVncmF0aW9uIiwiYWN0aXZlQ29tcG9uZW50IjoiVlRTT0NvbW1hbmQiLCJhY3RpdmVFbnZpcm9ubWVudCI6ImFwYWNoZS1vcGVuLXNvdXJjZS1pbnRlZ3JhdGlvbiJ9"
    variant="primary"
  >
    Instalação guiada, região dos EUA
  </ButtonLink>

  <ButtonLink
    role="button"
    to="https://one.eu.newrelic.com/launcher/nr1-core.explorer?pane=eyJuZXJkbGV0SWQiOiJucjEtY29yZS5saXN0aW5nIn0=&cards[0]=eyJuZXJkbGV0SWQiOiJucjEtaW5zdGFsbC1uZXdyZWxpYy5ucjEtaW5zdGFsbC1uZXdyZWxpYyIsInBhdGgiOiJvaGkiLCJyZWNpcGVOYW1lIjoiYXBhY2hlLW9wZW4tc291cmNlLWludGVncmF0aW9uIiwiYWN0aXZlQ29tcG9uZW50IjoiVlRTT0NvbW1hbmQiLCJhY3RpdmVFbnZpcm9ubWVudCI6ImFwYWNoZS1vcGVuLXNvdXJjZS1pbnRlZ3JhdGlvbiJ9"
    variant="primary"
  >
    Instalação guiada, região da UE
  </ButtonLink>
</ButtonGroup>

## Instalar [#install]

Se você não estiver usando a instalação guiada, siga as instruções para seu ambiente:

<CollapserGroup>
  <Collapser
    id="ecs-install"
    title="SEC"
  >
    Consulte [Monitorar serviço em execução no ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
  </Collapser>

  ' '

  <Collapser
    id="k8s-install"
    title="Kubernetes"
  >
    Consulte [Monitorar serviço em execução no Kubernetes](/docs/kubernetes-pixie/kubernetes-integration/advanced-configuration/monitor-services/monitor-services-running-kubernetes).
  </Collapser>

  <Collapser
    id="linux-install"
    title="Linux"
  >
    1. Instale [o agente de infraestrutura](/docs/integrations/host-integrations/installation/install-infrastructure-host-integrations/#install) e substitua a variável `INTEGRATION_FILE_NAME` por `nri-jmx`.

    2. Mude o diretório para a pasta integração:

       ```sh
       cd /etc/newrelic-infra/integrations.d
       ```

    3. Copie o arquivo de configuração de amostra:

       ```sh
       sudo cp jmx-config.yml.sample jmx-config.yml
       ```

    4. Copie o arquivo de configuração da JVM:

       ```sh
       sudo cp jvm-metrics.yml.sample jvm-metrics.yml
       ```

    5. <DoNotTranslate>**Optional**</DoNotTranslate>: Se você estiver interessado em monitoramento Tomcat, use este exemplo de arquivo métrico:

       ```sh
       sudo cp tomcat-metrics.yml.sample tomcat-metrics.yml
       ```

    6. Edite o arquivo `jmx-config.yml` conforme descrito nas [definições de configuração](#config).

    7. [Reinicie o agente de infraestrutura](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).

       <Callout variant="important">
         Se os arquivos de amostra não estiverem presentes em sua instalação, você poderá baixá-los diretamente do [repositório GitHub](https://github.com/newrelic/nri-jmx).
       </Callout>
  </Collapser>

  <Collapser
    id="windows-install"
    title="Windows"
  >
    1. Baixe a imagem do instalador `nri-jmx` .MSI em:

       [https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-jmx/nri-jmx-amd64-installer.exe](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-jmx/nri-jmx-amd64-installer.exe)

    2. Para instalar a partir do prompt de comando do Windows, execute:

       ```sh
       PATH\TO\nri-jmx-amd64-installer.exe
       ```

    3. No diretório integração, `C:\Program Files\New Relic\newrelic-infra\integrations.d\`, crie uma cópia do arquivo de configuração de amostra executando:

       ```sh
       cp jmx-config.yml.sample jmx-config.yml
       ```

    4. Edite o arquivo de configuração `jmx-config.yml` usando as [definições de configuração](#config).

    5. [Reinicie o agente de infraestrutura](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status).
  </Collapser>
</CollapserGroup>

## Atualize sua integração [#update]

Essa integração não é atualizada automaticamente. Para obter melhores resultados, [atualize regularmente o pacote de integração](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package) e [o agente de infraestrutura](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent).

## Tarefas pós-instalação [#after-install]

Quando terminar a instalação, você poderá definir opções de configuração. Algumas configurações são necessárias para que a integração funcione, enquanto outras são opcionais.

### Configurar a integração [#config]

A configuração no formato YAML de uma integração é onde você pode colocar as credenciais de login necessárias e configurar como os dados são coletados. Quais opções você altera dependem de sua configuração e preferência.

Existem diversas formas de configurar a integração, dependendo de como ela foi instalada:

* Se habilitado via Kubernetes: consulte [Monitorar serviços em execução no Kubernetes](/docs/monitor-service-running-kubernetes).
* Se habilitado via Amazon ECS: consulte [Monitorar serviços em execução no ECS](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs).
* Se instalado no host: edite a configuração no arquivo de configuração YAML da integração, `jmx-config.yml`.

#### Arquivos de configuração de integração [#host-connection]

O arquivo de configuração possui configurações comuns aplicáveis a toda integração, como `interval`, `timeout` ou `inventory_source`. Para ler tudo sobre essas configurações comuns, consulte nosso documento [de formato de configuração](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) .

Configurações específicas relacionadas ao JMX são definidas usando a seção `env` do arquivo de configuração. Essas configurações controlam a conexão com sua instância JMX, bem como outras configurações e recursos de segurança. A lista de configurações válidas é descrita na próxima seção deste documento.

As opções de configuração estão abaixo. Para obter um exemplo de configuração, consulte o [arquivo de configuração de exemplo](#example-config).

<CollapserGroup>
  <Collapser
    id="jmx-instance"
    title="Configurações da instância JMX"
  >
    A integração JMX coleta informações métricas e de inventário. Esta tabela mostra a que cada opção de configuração se aplica.

    ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '

    <table>
      <thead>
        <tr>
          <th style={{ width: '170px' }}>
            Contexto
          </th>

          <th style={{ width: '300px' }}>
            Descrição
          </th>

          <th>
            Padrão
          </th>

          <th>
            Aplica-se a
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `JMX_HOST`
          </td>

          <td>
            O host em que o JMX está sendo executado.
          </td>

          <td>
            `localhost`
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `JMX_PORT`
          </td>

          <td>
            A porta em que o JMX está sendo executado.
          </td>

          <td>
            `9999`
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `JMX_URI_PATH`
          </td>

          <td>
            A parte do caminho do URI do serviço JMX. Isto é útil para uris de serviço fora do padrão.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `JMX_USER`
          </td>

          <td>
            O nome de usuário da conexão JMX.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `JMX_PASS`
          </td>

          <td>
            A senha para a conexão JMX.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `JMX_REMOTE`
          </td>

          <td>
            (Específico do JBoss) Se deve ou não usar o formato de conexão de URL remota JMX. O padrão de conexão é o modo de domínio JBoss se `true`.
          </td>

          <td>
            `false`
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `JMX_REMOTE_JBOSS_STANDLONE`
          </td>

          <td>
            (Específico do JBoss) Se deve ou não usar o formato de conexão independente do JBoss. Relevante apenas se `JMX_REMOTE` estiver definido.
          </td>

          <td>
            `false`
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `CONNECTION_URL`
          </td>

          <td>
            URL completo endpoint JMX. Isto substitui todos os argumentos de conexão (acima) fornecendo todos os parâmetros em uma linha.

            Exemplo: `"service:jmx:rmi:///jndi/rmi://localhost:7199/jmxrmi"`
          </td>

          <td>
            N/A
          </td>

          <td style={{ "text-align": "center" }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `COLLECTION_FILES`
          </td>

          <td>
            Uma lista separada por vírgula de caminhos completos para os arquivos de definição da coleção métrica. Para instalação no host, o arquivo de coleta de métricas JVM padrão está em `/etc/newrelic-infra/integrations.d/jvm-metrics.yml`.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `COLLECTION_CONFIG`
          </td>

          <td>
            Configuração da coleção métrica em JSON.

            JVM Example:

            ```java
            COLLECTION_CONFIG='{"collect":[{"domain":"java.lang","event_type":"JVMSample","beans":[{"query":"type=GarbageCollector,name=*","attributes":["CollectionCount","CollectionTime"]},{"query":"type=Memory","attributes":["HeapMemoryUsage.Committed","HeapMemoryUsage.Init","HeapMemoryUsage.Max","HeapMemoryUsage.Used","NonHeapMemoryUsage.Committed","NonHeapMemoryUsage.Init","NonHeapMemoryUsage.Max","NonHeapMemoryUsage.Used"]},{"query":"type=Threading","attributes":["ThreadCount","TotalStartedThreadCount"]},{"query":"type=ClassLoading","attributes":["LoadedClassCount"]},{"query":"type=Compilation","attributes":["TotalCompilationTime"]}]}]}'
            ```

            Exemplo do Tomcat:

            ```java
            COLLECTION_CONFIG={"collect":[{"domain":"Catalina","event_type":"TomcatSample","beans":[{"query":"type=UtilityExecutor","attributes":["completedTaskCount"]}]}]}
            ```

            `COLLECTION_CONFIG` is useful to [configure `nri-jmx` in Kubernetes using annotations](#metrics-collection-kubernetes-annotations).
          </td>

          <td>
            N/A
          </td>

          <td style={{ "text-align": "center" }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `KEY_STORE`
          </td>

          <td>
            O caminho do arquivo do keystore que contém o certificado SSL do cliente JMX.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `KEY_STORE_PASSWORD`
          </td>

          <td>
            A senha do armazenamento de chaves SSL.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `LOCAL_ENTITY`
          </td>

          <td>
            Coletar todas as métricas da entidade local. Utilize somente quando monitoramento localhost.
          </td>

          <td>
            `false`
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `TIMEOUT`
          </td>

          <td>
            O tempo limite para consulta JMX individual, em milissegundos.
          </td>

          <td>
            `10000`
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `TRUST_STORE`
          </td>

          <td>
            O caminho do arquivo do keystore que contém o certificado SSL do servidor JMX.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `TRUST_STORE_PASSWORD`
          </td>

          <td>
            A senha do armazenamento confiável.
          </td>

          <td>
            N/A
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `METRIC_LIMIT`
          </td>

          <td>
            Number of metrics that can be collected per entity. If this limit is exceeded the entity will not be reported. A limit of `0` implies no limit.
          </td>

          <td>
            `200`
          </td>

          <td style={{ 'text-align': 'center' }}>
            MI
          </td>
        </tr>

        <tr>
          <td>
            `METRICS`
          </td>

          <td>
            Defina como `true` para ativar a coleta somente de métricas.
          </td>

          <td>
            `false`
          </td>

          <td style={{ 'text-align': 'center' }}/>
        </tr>

        <tr>
          <td>
            `INVENTORY`
          </td>

          <td>
            Defina como `true` para ativar a coleta somente de inventário.
          </td>

          <td>
            `false`
          </td>

          <td style={{ 'text-align': 'center' }}/>
        </tr>
      </tbody>
    </table>

    Os valores para estas configurações podem ser definidos de diversas maneiras:

    * Adicionando o valor diretamente no arquivo de configuração. Esta é a forma mais comum.
    * Substituindo os valores das variáveis de ambiente usando a notação `{{}}` . Isto requer o agente de infraestrutura v1.14.0 ou superior. Leia mais [aqui](/docs/infrastructure/install-infrastructure-agent/configuration/configure-infrastructure-agent/#passthrough) ou veja o [exemplo abaixo](#example4).
    * Usando gerenciamento de segredos. Use isto para proteger informações confidenciais (como senhas) de serem expostas em texto simples no arquivo de configuração. Para obter mais informações, consulte [gerenciamento de segredos](/docs/integrations/host-integrations/installation/secrets-management).
  </Collapser>

  <Collapser
    id="labels"
    title="Etiquetas e atributo personalizado"
  >
    Você também pode personalizar suas etiquetas. Adicione valor principal pair atributo à sua métrica, que você poderá usar para consultar, filtrar ou agrupar sua métrica.

    Nosso arquivo de configuração de amostra padrão contém exemplos de rótulos. Eles não são obrigatórios e você pode remover, modificar ou adicionar novos de sua escolha.

    ```yaml
    labels:
      env: production
      role: jmx
    ```
  </Collapser>
</CollapserGroup>

### Arquivos de coleta métrica [#metrics-collection]

Os arquivos de definição de coleção de métricas são arquivos YAML estruturados que informam à integração qual métrica coletar. Para um exemplo de configuração, veja o [exemplo do arquivo de coleta de métricas](#collection-example).

Arquivo de coleta de métricas JVM padrão: `/etc/newrelic-infra/integrations.d/jvm-metrics.yml`

<Callout variant="tip">
  Você pode gravar diferentes arquivos de coleção para facilitar a organização e manutenção. Veja [o arquivo de configuração](#collection-example) para ver um exemplo.
</Callout>

<CollapserGroup>
  <Collapser
    id="domains"
    title="Domínio domínio"
  >
    A integração coleta e organiza métricas por domínio. Todas as métricas definidas por domínio serão enviadas para a New Relic e poderão ser encontradas no tipo de evento correspondente. Este tipo de evento é gerado automaticamente ou pode ser definido pelo usuário. Cada arquivo contém um único bloco `collect:` que contém uma matriz de domínio. Para cada domínio, são definidas as seguintes chaves:

    * `domain`: O domínio JMX; por exemplo, `java.lang`. Você pode usar curingas para corresponder a vários domínios; por exemplo, `java.*`. Se você usar um curinga, `event_type` será obrigatório e deverá ser exclusivo. Este campo é obrigatório.
    * `event_type`: o nome [do tipo de evento](/docs/data-apis/understand-data/new-relic-data-types/#event-data) para uma coleção deste domínio. Se o domínio for curinga, isso será obrigatório e deverá ser exclusivo. Se o domínio não for curinga e for indefinido pelo usuário, será gerado automaticamente. Por exemplo, o domínio `java.lang` terá o tipo de evento `JavaLangSample`. Para obter mais informações, consulte [Dicas de nomenclatura](#data-naming).
    * `beans`: uma matriz de [beans](#metrics-collection) a serem coletados neste domínio.

    <Callout variant="important">
      Existe um limite de 200 métricas por instância no arquivo de configuração. Se você exceder o limite de uma instância específica, ela não será enviada para a New Relic. Se você não estiver vendo seus dados no New Relic, revise os [procedimentos de resolução de problemas](#troubleshoot) para identificar se você excedeu o limite.
    </Callout>
  </Collapser>

  <Collapser
    id="beans"
    title="Feijões"
  >
    Cada domínio contém uma matriz de [beans](https://pubs.vmware.com/vfabric5/index.jsp?topic=/com.vmware.vfabric.hyperic.4.6/JMX_MBean_Query_for_JVMs.html) a serem coletados. Para cada bean, as seguintes chaves são definidas:

    * `query`: O nome do bean a ser coletado; por exemplo,`type=GarbageCollector,name=YoungGen`. Você pode usar curingas; por exemplo, `type=GarbageCollector,name=*`. Este campo é obrigatório.
    * `exclude_regex`: uma lista opcional de padrões regex que correspondem aos beans a serem excluídos da coleção; por exemplo, `type=GarbageCollector,name=.*`.
    * `attributes`: Uma lista de [atributos](#attributes) a serem coletados. Se não for especificado, coleta todos os atributos.

    <Callout variant="important">
      Os tipos de dados `HashMap` e `ArrayList` não são suportados.
    </Callout>
  </Collapser>

  <Collapser
    id="attributes"
    title="Atributo"
  >
    Cada bean pode conter atributo, uma lista opcional de beans que podem ser excluídos da coleção. Para cada atributo, são definidas as seguintes chaves:

    <Callout variant="important">
      Para atributo de mapa, você deve definir uma chave `attr` ou `attr_regex` .
    </Callout>

    * `attr`: uma correspondência exata do nome do atributo. Os atributos compostos podem ser coletados anexando o nome do membro composto ao nome do atributo com um ponto; por exemplo, `HeapMemoryUsage.Max`.

    * `attr_regex`: Um padrão regex que corresponde ao atributo a ser coletado.

    * `metric_type`: o tipo de métrica New Relic para coletar esse atributo. As opções são:

      * `gauge`: os dados serão coletados como uma medição numérica instantânea.
      * `rate`: os dados serão coletados como a mudança nessa métrica por segundo.
      * `delta`: os dados serão coletados como a mudança nessa métrica desde a última medição.
      * `attribute`: os dados serão coletados como uma string literal.

      Se não for especificado, a integração JMX tentará inferir o tipo de métrica com base no valor retornado. Por exemplo, se a métrica for um número, ela o coletará como `gauge`. Se a métrica for uma string, ela será coletada como `attribute`.

      Se as métricas forem coletadas com um tipo de métrica incorreto, você poderá especificar manualmente o tipo de métrica correto no arquivo de coleta.

    * `metric_name`: o nome sob o qual a métrica aparecerá no New Relic. Se não for especificado, o padrão será o nome do atributo.

    Para obter mais informações sobre a consulta JMX, consulte a documentação [do Oracle ObjectName](https://docs.oracle.com/javase/7/docs/api/javax/management/ObjectName.html) .
  </Collapser>
</CollapserGroup>

### Configuração de coleção usando anotações do Kubernetes [#metrics-collection-kubernetes-annotations]

Você pode usar anotações do Kubernetes para fornecer configuração de coleção. Para conseguir isso, você precisa implantar um `configMap` no cluster do Kubernetes que criará o arquivo de configuração para a aplicação `nri-jmx` .

Neste arquivo de configuração você precisa especificar o comando para [auto-discovery do contêiner](/docs/integrations/host-integrations/installation/container-auto-discovery), que permitirá utilizar o espaço reservado na configuração da integração, incluindo anotações do Kubernetes.

Exemplo de `configMap` para monitor JVM em um aplicativo Tomcat:

<CollapserGroup>
  <Collapser
    id="jmx-configuration-configmap-example-using-helm"
    title="Exemplo de configMap usando gráficos de leme (recomendado)"
  >
    ```yaml
    nri-bundle:
      newrelic-infrastructure:
        integrations_config:
          - name: jmx-config.yml
            data:
              discovery:
                command:
                  # Use the following optional arguments:
                  # --namespaces: Comma separated list of namespaces to discover pods on
                  # --tls: Use secure (TLS) connection
                  # --port: Port used to connect to the kubelet. Default is 10255
                  exec: /var/db/newrelic-infra/nri-discovery-kubernetes
                  match:
                    label.app: java
              integrations:
                - name: nri-jmx
                  env:
                    # Using the discovered IP as the host address
                    JMX_HOST: ${discovery.ip}
                    JMX_PORT: ${discovery.port}
                    COLLECTION_CONFIG: ${discovery.annotation.newrelic.config}
    ```

    Saiba mais sobre como monitorar integração no host [aqui](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle#monitor-on-host-integrations)
  </Collapser>

  <Collapser
    id="jmx-configuration-configmap-example-plain-manifest"
    title="Exemplo de configMap usando manifesto simples"
  >
    ```yaml
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: nri-integration-cfg
    data:
      jmx-config.yml: |
        ---
        # Run auto discovery to find pods with label "app=java"
        discovery:
          command:
            # Use the following optional arguments:
            # --namespaces: Comma separated list of namespaces to discover pods on
            # --tls: Use secure (TLS) connection
            # --port: Port used to connect to the kubelet. Default is 10255
            exec: /var/db/newrelic-infra/nri-discovery-kubernetes
            match:
              label.app: java
        integrations:
          - name: nri-jmx
            env:
              # Using the discovered IP as the host address
              JMX_HOST: ${discovery.ip}
              JMX_PORT: ${discovery.port}
              COLLECTION_CONFIG: ${discovery.annotation.newrelic.config}
    ```
  </Collapser>
</CollapserGroup>

A seguir, use anotações para definir a configuração da coleção. Por exemplo, aqui está uma implantação do Tomcat com anotações:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tomcat-deployment
  labels:
    app: java
spec:
  replicas: 1
  selector:
    matchLabels:
      app: java
  template:
    metadata:
      annotations:
        newrelic.config: >-
          {
            "collect": [
              {
                "domain": "java.lang",
                "event_type": "JVMSample",
                "beans": [
                  {
                    "query": "type=GarbageCollector,name=*",
                    "attributes": [
                      "CollectionCount",
                      "CollectionTime"
                    ]
                  },
                  {
                    "query": "type=Memory",
                    "attributes": [
                      "HeapMemoryUsage.Committed",
                      "HeapMemoryUsage.Init",
                      "HeapMemoryUsage.Max",
                      "HeapMemoryUsage.Used",
                      "NonHeapMemoryUsage.Committed",
                      "NonHeapMemoryUsage.Init",
                      "NonHeapMemoryUsage.Max",
                      "NonHeapMemoryUsage.Used"
                    ]
                  },
                  {
                    "query": "type=Threading",
                    "attributes": [
                      "ThreadCount",
                      "TotalStartedThreadCount"
                    ]
                  },
                  {
                    "query": "type=ClassLoading",
                    "attributes": [
                      "LoadedClassCount"
                    ]
                  },
                  {
                    "query": "type=Compilation",
                    "attributes": [
                      "TotalCompilationTime"
                    ]
                  }
                ]
              }
            ]
          }
      labels:
        app: java
    spec:
      containers:
        - name: tomcat
          image: tomcat:10.0.12
          ports:
            - containerPort: 9999
          env:
            - name: CATALINA_OPTS
              value: '-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false'
```

### Conectores personalizados [#custom-connector]

JMX permite o uso de conectores customizados para comunicação com o aplicativo. Para usar um conector personalizado, você deve incluir os conectores personalizados no caminho de classe nrjmx.

Por padrão, a subpasta `connectors` está no classpath. Se esta pasta não existir, crie-a na pasta onde o nrjmx está instalado.

Por exemplo, para adicionar suporte ao JBoss, crie uma pasta chamada `connectors` no caminho da biblioteca padrão (Linux) `/usr/lib/nrjmx/` (`/usr/lib/nrjmx/connectors/`) e copie o jar do conector personalizado (`$JBOSS_HOME/bin/client/jboss-cli-client.jar`) nela. Agora você pode executar a consulta JMX no JBoss.

## Exemplo de configuração [#example-config]

Exemplo de configuração de arquivo para uma instalação no host:

<CollapserGroup>
  <Collapser
    id="host-connection-example"
    title="Exemplo de arquivo de conexão de host"
  >
    ```yml
    integrations:
      - name: nri-jmx
        env:
          COLLECTION_FILES: "/etc/newrelic-infra/integrations.d/jvm-metrics.yml,/etc/newrelic-infra/integrations.d/tomcat-metrics.yml"
          JMX_HOST: jmx-host.localnet
          JMX_PASS: admin
          JMX_PORT: 9999
          JMX_USER: admin
        interval: 15s
        labels:
          env: production
    ```
  </Collapser>

  <Collapser
    id="collection-example"
    title="Exemplo de arquivo de coleta métrica"
  >
    ```yml
    collect:
      # The event type for this domain will be JavaLangSample
      - domain: java.lang
        beans:
          # Collect all beans of type Threading
          - query: type=Threading
            # Attributes can be either a string or a map
            attribute:
              # When unspecified, the metric_type is inferred
              # and the metric name is just the attribute name
              - ThreadCount
                # If using a map attribute, a custom metric name can be set
              - attr: TotalStartedThreadCount
                metric_name: ThreadsStarted
                # Attributes can be collected with regex matches and
                # the metric type can be overridden if the integration
                # can not correctly infer the type
              - attr_regex: "ThreadCpu.*Enabled"
                metric_type: attribute
          - query: type=Memory
            attributes:
              # Composite attributes can be collected with this syntax
              - HeapMemoryUsage.Max
              - NonHeapMemoryUsage.Max
            # Queries can be wildcarded where
          - query: type=GarbageCollector,name=*
            # If a specific bean is unwanted, it can be excluded
            # with a regex match pattern. Useful if using a wildcard query
            exclude_regex:
              # This will match any bean where the name is YoungGen
              - name=YoungGen
            attributes:
              - attr: LastGcInfo.GcThreadCount
                metric_type: gauge
                metric_name: GCThreadCount
        # Domains can be wildcarded
      - domain: java.util.*
        # If the domain is wildcarded, a custom event must be defined
        event_type: JavaUtilSample
        beans:
          # If no attributes are defined, all are collected by default
          - query: type=Logging
    ```
  </Collapser>
</CollapserGroup>

Para obter mais informações sobre a estrutura geral da configuração de integração no host, consulte [Configuração](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview).

### Nomeando seus dados [#data-naming]

Métricas são enviadas e armazenadas na forma de amostras. Esta é uma lista de pares de valores principais que incluem dados métricos e metadados. Cada amostra é armazenada como um [evento](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic) em nosso banco de dados.

Você é responsável por criar e nomear os dados JMX relatados à New Relic. Por esse motivo, a New Relic recomenda fortemente seguir estas convenções ao nomear seus tipos de eventos. Para garantir que você tenha um esquema de nomenclatura consistente:

* Use estojo de camelo.
* Use um nome que identifique claramente quais dados ele contém.

Exemplo: `MyorgApplicationSample`

<DoNotTranslate>**Recommendation:**</DoNotTranslate> Use o mesmo esquema de nomenclatura para métricas semelhantes em aplicativos diferentes.

## Encontre e use dados [#find-and-use]

Os dados deste serviço são reportados para um [dashboard de integração](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts).

Os dados JMX são anexados ao [tipo de evento](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic) definido pelo usuário especificado no [arquivo de configuração](#metrics-collection). Por exemplo, se você tem interesse em monitorar o Tomcat utilizando a integração JMX, defina um `event_type` chamado `TomcatSample`, e [consulte esse tipo de evento](/docs/using-new-relic/data/understand-data/query-new-relic-data).

Você pode [consultar esses dados](/docs/using-new-relic/data/understand-data/query-new-relic-data) para fins de resolução de problemas ou para criar gráficos e dashboards personalizados.

Para saber mais sobre como encontrar e usar seus dados, consulte [Compreender os dados de integração](/docs/infrastructure/integrations/find-use-infrastructure-integration-data).

## Dados métricos [#metrics]

As métricas geradas pela integração incluem metadados associados ao [MBean](https://pubs.vmware.com/vfabric5/index.jsp?topic=/com.vmware.vfabric.hyperic.4.6/JMX_MBean_Query_for_JVMs.html) do qual estão coletando. Você pode usar esses metadados em [consultas NRQL](/docs/insights/nrql-new-relic-query-language/using-nrql/introduction-nrql) para filtrar e facetar os dados para que a consulta retorne apenas os dados dos beans desejados. Também pode ser utilizado para identificar unicamente as métricas, uma vez que o nome da métrica não é necessariamente único entre todos os beans.

Cada evento contém os seguintes metadados:

<table>
  <thead>
    <tr>
      <th style={{ width: "180px" }}>
        Nome
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `displayName`
      </td>

      <td>
        O nome de domínio JMX para essas métricas.
      </td>
    </tr>

    <tr>
      <td>
        `entityName`
      </td>

      <td>
        The JMX domain name for these metrics with the entity type `domain:` prepended.
      </td>
    </tr>

    <tr>
      <td>
        `host`
      </td>

      <td>
        O host JMX do qual a métrica está sendo coletada.
      </td>
    </tr>

    <tr>
      <td>
        `query`
      </td>

      <td>
        A consulta usada para coletar essas métricas.
      </td>
    </tr>

    <tr>
      <td>
        `bean`
      </td>

      <td>
        O feijão cujo atributo essas métricas foram coletadas.
      </td>
    </tr>

    <tr>
      <td>
        `key:<mbean_key>`
      </td>

      <td>
        Para cada chave no nome do bean, um atributo é adicionado ao conjunto de métricas denominado `key:<mbean_key>` com o valor da chave do bean.
      </td>
    </tr>
  </tbody>
</table>

### Exemplo de consulta NRQL

Aqui está um exemplo de consulta [NRQL](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql) aproveitando o monitor de metadados de todo o coletor de lixo JVM coletado:

```sql
SELECT latest(CollectionTime)
FROM JVMSample
FACET `key:name`
WHERE `key:type` = 'GarbageCollector'
```

### Atributo de dados métricos [#metrics-attributes]

A integração JMX coleta os seguintes atributos de dados métricos:

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        Nome
      </th>

      <th>
        Descrição
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `HeapMemoryUsage.Used`
      </td>

      <td>
        A memória heap Java total usada.
      </td>
    </tr>

    <tr>
      <td>
        `HeapMemoryUsage.Committed`
      </td>

      <td>
        A memória heap Java total comprometida para ser usada.
      </td>
    </tr>

    <tr>
      <td>
        `HeapMemoryUsage.Init`
      </td>

      <td>
        A memória heap Java inicial alocada.
      </td>
    </tr>

    <tr>
      <td>
        `HeapMemoryUsage.Max`
      </td>

      <td>
        A memória heap Java máxima disponível.
      </td>
    </tr>

    <tr>
      <td>
        `NonHeapMemoryUsage.Used`
      </td>

      <td>
        O total de memória não heap Java usada.
      </td>
    </tr>

    <tr>
      <td>
        `NonHeapMemoryUsage.Committed`
      </td>

      <td>
        O total de memória não heap Java comprometida para ser usada.
      </td>
    </tr>

    <tr>
      <td>
        `NonHeapMemoryUsage.Init`
      </td>

      <td>
        A memória não heap Java inicial alocada.
      </td>
    </tr>

    <tr>
      <td>
        `NonHeapMemoryUsage.Max`
      </td>

      <td>
        O máximo de memória Java não heap disponível.
      </td>
    </tr>

    <tr>
      <td>
        `ThreadCount`
      </td>

      <td>
        O número de threads ativos.
      </td>
    </tr>

    <tr>
      <td>
        `CollectionCount`
      </td>

      <td>
        O número total de coletas de lixo que ocorreram.
      </td>
    </tr>

    <tr>
      <td>
        `CollectionTime`
      </td>

      <td>
        O tempo aproximado de coleta de lixo acumulado decorreu.
      </td>
    </tr>
  </tbody>
</table>

## Dados de inventário [#inventory]

A integração JMX captura o parâmetro de configuração da integração JMX. Os dados estão disponíveis na [página Inventário](/docs/infrastructure/new-relic-infrastructure/infrastructure-ui-pages/infrastructure-inventory-page-search-your-entire-infrastructure), na origem <DoNotTranslate>**config/jmx**</DoNotTranslate> . Para obter mais informações sobre dados de inventário, consulte [Compreender os dados de integração](/docs/infrastructure/integrations-getting-started/getting-started/understand-integration-data-data-types#inventory-data).

## Resolução de problemas [#troubleshoot]

Dicas de resolução de problemas:

<CollapserGroup id="troubleshooting-list">
  <Collapser
    id="integration-errors"
    title="Registro de pesquisa em busca de erros"
  >
    Se você estiver tendo problemas com a integração, primeiro [habilite e pesquise erros no log](/docs/infrastructure/new-relic-infrastructure/troubleshooting/generate-logs-troubleshooting-infrastructure) .
  </Collapser>

  <Collapser
    id="metrics-limit"
    title="Limite métrico excedido"
  >
    Se você suspeita que existe um domínio enviando mais de 200 métricas, verifique o [arquivo de log](/docs/infrastructure/new-relic-infrastructure/troubleshooting/generate-logs-troubleshooting-infrastructure) para esta mensagem:

    ```
    "Domain x has n metrics, the current limit is 200. This domain will not be reported."
    ```

    Se você vir esta mensagem de erro, diminua o número de métricas enviadas para o domínio reportado.
  </Collapser>

  ' '

  <Collapser
    id="missing-metrics"
    title="Métrica ausente"
  >
    Se você tiver métricas ausentes, certifique-se de que a consulta MBean seja válida tentando executá-la com a [ferramenta nrjmx](https://github.com/newrelic/nrjmx) ou use sua ferramenta preferida para garantir que a consulta seja válida no JMXConsole.
  </Collapser>

  ' '

  <Collapser
    id="missing-dashboard"
    title="Dashboard não aparece na IU de infraestrutura"
  >
    Confirme se o arquivo de configuração `jvm-metrics.yml` foi atualizado e se o caminho para o arquivo está enumerado no arquivo `jmx-config.yml` .
  </Collapser>

  <Collapser
    id="jmxterm"
    title="Resolução de problemas via JMXTerm"
  >
    [JMXTerm](https://docs.cyclopsgroup.org/jmxterm) é uma ferramenta interativa CLI usada para resolução de problemas. Encontre a documentação do JMXTerm em nossa [`nrjmx` página de resolução de problemas](https://github.com/newrelic/nrjmx/blob/master/TROUBLESHOOT.md). A partir de `nrjmx` v1.7.0, JMXTerm não é mais fornecido com `nrjmx` e precisa ser baixado de forma independente. Verifique as \[`nrjmx` instruções de instalação] ([https://github.com/newrelic/nrjmx#instalação](https://github.com/newrelic/nrjmx#installation)).
  </Collapser>
</CollapserGroup>

## Verifique o código-fonte [#source-code]

Esta integração é um software de código aberto. Isso significa que você pode [navegar pelo código-fonte](https://github.com/newrelic/nri-jmx) e enviar melhorias, ou criar seu próprio fork e construí-lo.