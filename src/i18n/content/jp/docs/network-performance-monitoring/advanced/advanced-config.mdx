---
title: ネットワーク監視の高度な構成
tags:
  - Integrations
  - Network monitoring
  - Advanced configuration
metaDescription: Advanced configuration options for network monitoring
freshnessValidatedDate: never
translationType: machine
---

ネットワークの監視を構成するときに使用できるすべてのオプションを確認したい場合は、次のセクションを参照してください。

## `snmp-base.yaml` サンプルファイル [#snmp-base-yml-template]

以下は、SNMP およびフロー データ デバイスをポーリングするために `ktranslate` Dockerイメージによって使用される `snmp-base.yaml` ファイルで使用できるさまざまな設定オプションの例です。 [GitHub の KTranslate リポジトリ](https://github.com/kentik/ktranslate/blob/main/config/snmp.yaml.sample)で、多くのコメントが付けられたサンプルを参照することもできます。

```yaml
# Configuration of every device monitored by this container
devices:
  # Sample of SNMP v2c device
  ups_snmpv2c__10.10.0.201:
    device_name: ups_snmpv2c
    device_ip: 10.10.0.201
    snmp_comm: $YOUR_COMMUNITY_STRING
    oid: .1.3.6.1.4.1.318.1.3.27
    description: "APC Web/SNMP Management Card (MB:v4.1.0 PF:v6.2.1 PN:apc_hw05_aos_621.bin AF1:v6.2.1 AN1:apc_hw05_sumx_621.bin MN:AP9537SUM HR:05 SN: ABC123DEF456 MD:05/21/2016) (Embedded PowerNet SNMP Agent SW v2.2 compatible)"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: apc_ups.yml
    provider: kentik-ups
    poll_time_sec: 300
    retries: 1
    timeout_ms: 5000
    user_tags:
      owning_team: dc_ops
    discovered_mibs:
    - PowerNet-MIB_UPS
    - TCP-MIB
    - UDP-MIB
    purge_after_num: 1
  # Sample of SNMP v3 device
  router_snmpv3__10.10.0.202:
    device_name: router_snmpv3
    device_ip: 10.10.0.202
    snmp_v3:
      user_name: $YOUR_USER_NAME
      authentication_protocol: $YOUR_AUTH_PROTOCOL
      authentication_passphrase: $YOUR_AUTH_PASSPHRASE
      privacy_protocol: $YOUR_PRIVACY_PROTOCOL
      privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
    oid: .1.3.6.1.4.1.9.1.544
    description: "Cisco IOS Software, 3800 Software (C3845-ADVENTERPRISEK9-M), Version
      15.1(3)T4, RELEASE SOFTWARE (fc1)\r\nTechnical Support: http://www.cisco.com/techsupport\r\nCopyright
      (c) 1986-2012 by Cisco Systems, Inc.\r\nCompiled Thu 24-May-12 04:27 by prod_rel_team"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: cisco-asr.yml
    provider: kentik-router
    user_tags:
      owning_team: core-networking
    discovered_mibs:
    - BGP4-MIB
    - CISCO-MEMORY-POOL-MIB
    - CISCO-PROCESS-MIB
    - IF-MIB
    - OSPF-MIB
    engine_id: "80:00:01:01:0a:14:1e:28"
    match_attributes:
      if_interface_name: "^Ten.*|^Gig.*"
      "!if_Alias": "[Uu]plink"
  # Sample of SNMP v1 device
  netbotz_snmpv1__10.10.0.203:
    device_name: netbotz_snmpv1
    device_ip: 10.10.0.201
    snmp_comm: $YOUR_COMMUNITY_STRING
    use_snmp_v1: true
    oid: .1.3.6.1.4.1.5528.100.20.10.2013
    description: "Linux netbotz930A7A 2.6.12 #307 Wed Dec 29 15:25:32 EST 2010 ppc"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: apc-netbotz.yml
    provider: kentik-netbotz
    user_tags:
      owning_team: sys_ops
    discovered_mibs:
    - IF-MIB
    - IP-MIB
    - TCP-MIB
    - UDP-MIB
    no_use_bulkwalkall: true
  # Sample of "flow only" device
  flow_only__10.10.0.210:
    device_name: flow_only
    device_ip: 10.10.0.210
    user_tags:
      owning_team: net_eng
    flow_only: true
  # Sample of "ping only" device
  ping_only__10.10.0.220:
    device_name: ping_only
    device_ip: 10.10.0.220
    provider: kentik-ping
    user_tags:
      owning_team: load_balancing
    ping_only: true
    ping_interval_sec: 5
  # Sample of Arista eAPI device
  arista_eapi_10.10.0.230:
    device_name: arista_eapi
    device_ip: 10.10.0.230
    snmp_comm: public
    oid: .1.3.6.1.4.1.30065.1.3011.7020.3735.24.2878.2
    description: "Arista Networks EOS version 4.22.9M running on an Arista
      Networks DCS-7020SR-24C2"
    last_checked: 2021-11-09T18:14:59.907821489Z
    mib_profile: arista-switch.yml
    provider: kentik-switch
    discovered_mibs:
    - ARISTA-BGP4V2-MIB
    - ARISTA-QUEUE-MIB
    - BGP4-MIB
    - HOST-RESOURCES-MIB
    - IF-MIB
    ext:
      ext_only: false
      eapi_config:
        username: $YOUR_ARISTA_API_USERNAME
        password: $YOUR_ARISTA_API_PASSWORD
        transport: https
        port: 443
  # Sample of Meraki Dashboard API device
  meraki_dashboard_api:
    device_name: meraki_controller
    device_ip: snmp.meraki.com
    provider: meraki-cloud-controller
    ext:
      ext_only: true
      meraki_config:
        api_key: $YOUR_MERAKI_API_KEY
        monitor_devices: true
        monitor_org_changes: true
        monitor_uplinks: true
        monitor_vpn_status: true
        organizations:
          - "Top Org.*"
        networks:
          - "Production"
          - "Guest"
        product_types:
          - appliance
        preferences:
          device_status_only: true
          hide_uplink_usage: false
          show_vpn_peers: true
          show_network_attr: true
# Configuration for receipt of SNMP Traps
trap:
  listen: 0.0.0.0:1620
  community: public
  version: ""
  transport: ""
  v3_config: null
  trap_only: false
  drop_undefined: false
# Configuration for the SNMP discovery job
discovery:
  cidrs:
  - 10.0.0.0/24
  - 10.0.0.202/32
  ignore_list:
  - 10.0.0.98
  - 10.0.0.99
  debug: false
  ports:
  - 161
  - 1161
  default_communities:
  - $YOUR_COMMUNITY_STRING_1
  - $YOUR_COMMUNITY_STRING_2
  - $YOUR_COMMUNITY_STRING_3
  use_snmp_v1: false
  default_v3: null
  add_mibs: true
  threads: 4
  add_devices: true
  replace_devices: true
  no_dedup_engine_id: false
  check_all_ips: true
global:
  poll_time_sec: 60
  drop_if_outside_poll: false
  mib_profile_dir: /etc/ktranslate/profiles
  mibs_db: /etc/ktranslate/mibs.db
  mibs_enabled:
  - ARISTA-BGP4V2-MIB
  - ARISTA-QUEUE-MIB
  - BGP4-MIB
  - CISCO-MEMORY-POOL-MIB
  - CISCO-PROCESS-MIB
  - HOST-RESOURCES-MIB
  - IF-MIB
  - OSPF-MIB
  - PowerNet-MIB_UPS
  timeout_ms: 3000
  retries: 0
  global_v3: null
  response_time: false
  user_tags:
    environment: production
  match_attributes:
    if_Description: ".*WAN.*"
  purge_devices_after_num: 0
```

<CollapserGroup>
  <Collapser
    id="devices"
    title="デバイスセクション"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            キー名
          </th>

          <th>
            必須
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            device_name
          </td>

          <td>
            ✓✓
          </td>

          <td>
            デバイスの名前。これは、NewRelic内のデバイスの一意の識別子です。
          </td>
        </tr>

        <tr>
          <td>
            device_ip
          </td>

          <td>
            ✓✓
          </td>

          <td>
            デバイスのターゲットIP。
          </td>
        </tr>

        <tr>
          <td>
            snmp_comm
          </td>

          <td>
            ✓（SNMPv1 / 2cに必要）
          </td>

          <td>
            `SNMPv1/2c` 使用するコミュニティ文字列。
          </td>
        </tr>

        <tr>
          <td>
            use_snmp_v1
          </td>

          <td>
            ✓（SNMPv1に必要）
          </td>

          <td>
            SNMPv1を使用するかどうかを示します。デフォルトでは、 `false`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            snmp_v3
          </td>

          <td>
            ✓（SNMPv3に必要）
          </td>

          <td>
            [SNMPv3構成](#snmpv3-config)
          </td>
        </tr>

        <tr>
          <td>
            debug
          </td>

          <td/>

          <td>
            SNMPポーリング中にデバッグレベルのログを有効にするかどうかを示します。デフォルトでは、 `false`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            port
          </td>

          <td/>

          <td>
            SNMPクエリを送信するポート。デフォルトでは、ポート`161`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            oid
          </td>

          <td>
            ✓（SNMPポーリングに必要）
          </td>

          <td>
            デバイスで検出された`systemObjectID | sysObjectID | sysOID` 。これは、デバイスを既知のSNMPプロファイルに一致させ、 `provider`属性を設定するために使用されます。一致するものが見つからない場合、これにより`provider`が[kentik-default](/docs/network-performance-monitoring/troubleshooting/snmp-discovery-kentik-default)デバイスとして設定されます。
          </td>
        </tr>

        <tr>
          <td>
            description
          </td>

          <td/>

          <td>
            デバイスの検出された`sysDescr` 。このフィールドは情報です。
          </td>
        </tr>

        <tr>
          <td>
            last_checked
          </td>

          <td/>

          <td>
            このデバイスが `ktranslate` Dockerイメージによって最後に検出されたときのタイムスタンプ。 このフィールドは情報提供です。
          </td>
        </tr>

        <tr>
          <td>
            mib_profile
          </td>

          <td>
            ✓（SNMPポーリングに必要）
          </td>

          <td>
            `sysOID`に基づく検出実行中にこのデバイスに関連付けられた SNMP プロファイル ファイル。 <DNT>**If this starts with a bang (!) token, it will override the automatic matching from the `sysOID` and use a manual override.**</DNT>例: `"!cisco-asa.yml"` (引用符が必要です)。
          </td>
        </tr>

        <tr>
          <td>
            provider
          </td>

          <td>
            ✓（New Relicに必要）
          </td>

          <td>
            NewRelicのエンティティ合成中に使用される値。これは、一致した`mib_profile`に基づいて自動的に作成され、エンティティを作成するには、 [entity-definitions](https://github.com/newrelic/entity-definitions/search?q=%22attribute%3A+provider%22+filename%3Adefinition.yml)リポジトリ内のルールの1つと一致する必要があります。デバイスを手動で追加する場合は、この値が有効であることを確認するように注意する必要があります。
          </td>
        </tr>

        <tr>
          <td>
            poll_time_sec
          </td>

          <td/>

          <td>
            SNMPポーリング頻度を秒単位で示します。この設定は、 `global.poll_time_sec`属性を上書きするために使用されます。
          </td>
        </tr>

        <tr>
          <td>
            retries
          </td>

          <td/>

          <td>
            SNMPOIDのポーリングを再試行する試行回数を示します。この設定は、 `global.retries`属性を上書きするために使用されます。
          </td>
        </tr>

        <tr>
          <td>
            timeout_ms
          </td>

          <td/>

          <td>
            SNMPポーリングタイムアウトをミリ秒単位で示します。この設定は、 `global.timeout_ms`属性を上書きするために使用されます。
          </td>
        </tr>

        <tr>
          <td>
            user_tags
          </td>

          <td/>

          <td>
            `key:value` 属性をペアにして、デバイスにより多くのコンテキストを提供します。このレベルのタグは、 `global.user_tags`属性で適用されるすべてのタグに追加されます。
          </td>
        </tr>

        <tr>
          <td>
            discovered_mibs
          </td>

          <td/>

          <td>
            このデバイスが応答できる、一致した`mib_profile`からプルされたMIBのリスト。このフィールドは情報です。
          </td>
        </tr>

        <tr>
          <td>
            engine_id
          </td>

          <td/>

          <td>
            このデバイスのSNMPエージェントに対して検出された一意のエンジンID。通常、SNMPv3の検出中に検出されます。このフィールドは情報です。
          </td>
        </tr>

        <tr>
          <td>
            match_attributes
          </td>

          <td/>

          <td>
            `attribute:regex` ペアを使用して、メトリックを許可リストに追加します。このレベルのペアは、 `global.match_attributes`属性で適用されるすべてのペアに追加されます。[RE2](https://github.com/google/re2/wiki/Syntax)構文を使用し、デフォルトの`OR`演算子があります。キーの前に`!`を付けて、 `AND`演算子を強制します。
          </td>
        </tr>

        <tr>
          <td>
            monitor_admin_shut
          </td>

          <td/>

          <td>
            `Administratively Shutdown`ステータスのインターフェースを監視するかどうかを示します。デフォルトでは、 `false`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            no_use_bulkwalkall
          </td>

          <td/>

          <td>
            `true`の場合、SNMP `GETBULK`要求アクションを無効にします。デフォルトでは、 `false`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            response_time
          </td>

          <td/>

          <td>
            このデバイスで[応答時間](#response_time-attribute)ポーリングが有効になっているかどうかを示します。デフォルトでは、 `false`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            ping_only
          </td>

          <td/>

          <td>
            `true`の場合、すべての SNMP ポーリングを無効にし、このデバイスの [応答時間](#response_time-attribute) ポーリングを有効にします。この設定は、 `global.response_time` 属性をオーバーライドします。デフォルトでは、 `false`に設定されています。各 ping_only デバイスに行 `provider: kentik_ping` が含まれていることを確認してください。
          </td>
        </tr>

        <tr>
          <td>
            ping_interval_sec
          </td>

          <td/>

          <td>
            この設定は、 `ping_only` |の間に使用される1パケット/秒のデフォルトレートを上書きするために使用されます。 `response_time`ポーリング。
          </td>
        </tr>

        <tr>
          <td>
            flow_only
          </td>

          <td/>

          <td>
            `true`の場合、すべてのSNMPポーリングを無効にします。デフォルトでは、 `false`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            purge_after_num
          </td>

          <td/>

          <td>
            X 個のスケジュールされた検出ジョブが失敗した後、構成ファイルからデバイスを削除します。 <DNT>**This setting overrides the global `purge_devices_after_num` setting.**</DNT>デバイスを永久に保持するにはこれを`-1`に設定し、パージ値を設定するには`1`以上の整数を設定します。 (デフォルト: `0` )
          </td>
        </tr>

        <tr>
          <td>
            ext
          </td>

          <td>
            ✓（APIポーリングに必要）
          </td>

          <td>
            [APIポーリング構成](#optional-api-polling-configurations)
          </td>
        </tr>

        <tr>
          <td>
            ext.ext_only
          </td>

          <td/>

          <td>
            この `device_name` 構成のすべての SNMP ポーリングを無効にします。デフォルト: `false` 。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="trap"
    title="トラップセクション"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            キー名
          </th>

          <th>
            必須
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            listen
          </td>

          <td>
            ✓✓
          </td>

          <td>
            SNMPトラップを受信するためのリスニングIPポート。デフォルトでは`0.0.0.0:1620`に設定されており、 `docker run ...`コマンドでリダイレクトを使用して、ホスト上のより一般的な UDP 162 をコンテナー内の UDP 1620 にリダイレクトします。リダイレクトはこのフラグで行われます `-p 162:1620/udp`
          </td>
        </tr>

        <tr>
          <td>
            community
          </td>

          <td/>

          <td>
            SNMP トラップを受信するための SNMPv1/v2c コミュニティ ストリング。デフォルトでは、受信トラップがこのコミュニティに一致しない場合でも、受信トラップを処理します。
          </td>
        </tr>

        <tr>
          <td>
            version
          </td>

          <td/>

          <td>
            使用するSNMPバージョン。オプションは、 `v1` 、 `v2c` 、および`v3`です。デフォルトでは、 `v2c`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            transport
          </td>

          <td/>

          <td>
            使用するSNMPトランスポートプロトコル。オプションは`TCP`と`UDP`です。デフォルトでは、 `UDP`
          </td>
        </tr>

        <tr>
          <td>
            v3_config
          </td>

          <td/>

          <td>
            使用する[SNMPv3構成](#snmpv3-config)。`version: v3`の場合にのみ使用されます。
          </td>
        </tr>

        <tr>
          <td>
            トラップのみ
          </td>

          <td/>

          <td>
            これを`true`に設定すると、コンテナーは SNMP または ICMP ポーリングを試行しなくなります。これは、着信トラップのみをリッスンするコンテナーが必要な場合に使用されます。
          </td>
        </tr>

        <tr>
          <td>
            ドロップ\_未定義
          </td>

          <td/>

          <td>
            これを`true`に設定すると、コンテナは既存の SNMP プロファイルで明示的に定義されていない SNMP トラップ メッセージを転送できなくなります。 (デフォルト: `false` )
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="discovery"
    title="ディスカバリーセクション"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            キー名
          </th>

          <th>
            必須
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            cidrs
          </td>

          <td>
            ✓✓
          </td>

          <td>
            [CIDR 表記](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)のターゲット IP 範囲の配列。 [タイムアウトを避ける](/docs/network-performance-monitoring/troubleshooting/snmp-discovery-no-devices)ために、これらの範囲のサイズに注意してください。
          </td>
        </tr>

        <tr>
          <td>
            ignore_list
          </td>

          <td/>

          <td>
            すべての検出ジョブで明示的に無視するIPアドレスの配列。
          </td>
        </tr>

        <tr>
          <td>
            debug
          </td>

          <td/>

          <td>
            検出中にデバッグレベルのログを有効にするかどうかを示します。デフォルトでは、 `false`
          </td>
        </tr>

        <tr>
          <td>
            ports
          </td>

          <td>
            ✓✓
          </td>

          <td>
            SNMPポーリング中にスキャンするターゲットポートの配列。
          </td>
        </tr>

        <tr>
          <td>
            default_communities
          </td>

          <td>
            ✓（SNMPv1 / 2cに必要）
          </td>

          <td>
            SNMPポーリング中にスキャンするSNMPv1/v2cコミュニティストリングの配列。この配列は順番に評価され、検出は最初に通過するコミュニティを受け入れます。
          </td>
        </tr>

        <tr>
          <td>
            use_snmp_v1
          </td>

          <td>
            ✓（SNMPv1に必要）
          </td>

          <td>
            検出中にSNMPv1を使用するかどうかを示します。デフォルトでは、 `false`
          </td>
        </tr>

        <tr>
          <td>
            default_v3
          </td>

          <td>
            ✓（SNMPv3に必要）
          </td>

          <td>
            SNMPポーリング中にスキャンする単一の[SNMPv3構成](#snmpv3-config)。
          </td>
        </tr>

        <tr>
          <td>
            other_v3s
          </td>

          <td>
            ✓（SNMPv3に必要）
          </td>

          <td>
            SNMPポーリング中にスキャンするための複数の[SNMPv3設定](#snmpv3-config)。 <DNT>**Use this option OR `default_v3`, not both**</DNT>
          </td>
        </tr>

        <tr>
          <td>
            add_devices
          </td>

          <td>
            ✓✓
          </td>

          <td>
            検出されたデバイスを`snmp-base.yaml`ファイルの`devices`セクションに追加するかどうかを示します。デフォルトでは、 `true`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            add_mibs
          </td>

          <td>
            ✓✓
          </td>

          <td>
            検出されたMIBを`snmp-base.yaml`ファイルの`global.mibs_enabled`セクションに追加するかどうかを示します。デフォルトでは、 `true`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            threads
          </td>

          <td>
            ✓✓
          </td>

          <td>
            検出中に使用するスレッドの整数制限。コンテナで使用可能なコアの数よりも少なくする必要があります。デフォルトでは、 `4`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            replace_devices
          </td>

          <td>
            ✓✓
          </td>

          <td>
            検出されたデバイスが`snmp-base.yaml`ファイルの`devices`セクションにすでに存在する場合、それらを置き換えるかどうかを示します。デフォルトでは、 `true`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            no_dedup_engine_id
          </td>

          <td/>

          <td>
            `true`に設定すると、報告されたSNMPエンジンIDに基づいて、検出されたデバイスが同じデバイスであると思われる場合に、それらのデバイスの重複排除を無効にします。デフォルトでは、 `false`
          </td>
        </tr>

        <tr>
          <td>
            check_all_ips
          </td>

          <td/>

          <td>
            `true`に設定すると、TCPポートスキャンを介して最初に活気をチェックせずに、検出ジョブが`cidrs`アレイのすべてのターゲットIPアドレスに対してSNMP接続を試行するように強制します。この設定は検出ジョブの速度を低下させますが、 `/32`オーバーライドを使用して`cidrs`アレイにリストされていないデバイスに対して検出が失敗する問題を回避するのに役立ちます。デフォルトでは、 `false`
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="global"
    title="グローバルセクション"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            キー名
          </th>

          <th>
            必須
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            poll_time_sec
          </td>

          <td>
            ✓✓
          </td>

          <td>
            デバイスをポーリングする時間（秒単位）。これは、 `devices.<deviceName>.poll_time_sec`属性を使用してデバイスごとにオーバーライドできます。デフォルトでは、 `60`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            drop_if_outside_poll
          </td>

          <td/>

          <td>
            ポーリングに`poll_time_sec`で設定された値よりも長い時間がかかる場合に、このサイクルからすべての値を削除するかどうかを示します。 デフォルトでは、 `false`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            mib_profile_dir
          </td>

          <td/>

          <td>
            キュレートされたMIBプロファイルを見つけるためのディレクトリ。これらは、Kentikの[snmp-profiles](https://github.com/kentik/snmp-profiles)リポジトリから自動的に`ktranslate`イメージにプルされ、Dockerランタイムで、プロファイルの独自のローカルディレクトリのボリュームマウントを作成することでオーバーライドできます。
          </td>
        </tr>

        <tr>
          <td>
            mibs_db
          </td>

          <td/>

          <td/>
        </tr>

        <tr>
          <td>
            mibs_enabled
          </td>

          <td>
            ✓✓
          </td>

          <td>
            `ktranslate` Dockerイメージがポーリングするすべてのアクティブな MIB の配列。 このリストは、 `discovery_add_mibs`属性が`true`の場合、検出中に自動的に生成されます。 ここにリストされていない MIB は、設定ファイル内のどのデバイスでもポーリングされません。 `MIB-NAME.tableName`構文を使用して、MIB ファイル内で SNMP テーブルを直接指定できます。 例: `HOST-RESOURCES-MIB.hrProcessorTable` 。
          </td>
        </tr>

        <tr>
          <td>
            timeout_ms
          </td>

          <td>
            ✓✓
          </td>

          <td>
            SNMP クエリのタイムアウト時間 (ミリ秒)。 これは、 `devices.<deviceName>.timeout_ms`属性を使用してデバイスごとにオーバーライドできます。 デフォルトでは、 `3000`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            retries
          </td>

          <td>
            ✓✓
          </td>

          <td>
            失敗した SNMP ポーリングを再試行する回数。 これは、 `devices.<deviceName>.retries`属性を使用してデバイスごとにオーバーライドできます。 デフォルトでは、 `0`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            user_tags
          </td>

          <td/>

          <td>
            `key:value` 属性をペアにして、デバイスにより多くのコンテキストを提供します。このレベルのタグは、構成ファイル内のすべてのデバイスに適用されます。
          </td>
        </tr>

        <tr>
          <td>
            match_attributes
          </td>

          <td/>

          <td>
            `attribute:regex` ペアを使用して、メトリックを許可リストに追加します。このレベルのペアは、構成ファイル内のすべてのデバイスと照合されます。[RE2](https://github.com/google/re2/wiki/Syntax)構文を使用し、デフォルトの`OR`演算子があります。キーの前に`!`を付けて、強制的に`AND`演算子にします。
          </td>
        </tr>

        <tr>
          <td>
            response_time
          </td>

          <td/>

          <td>
            構成ファイル内のすべてのデバイス[に対して応答時間](#response_time-attribute)ポーリングが有効になっているかどうかを示します。デフォルトでは、 `false`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            purge_devices_after_num
          </td>

          <td/>

          <td>
            X 個のスケジュールされた検出ジョブが失敗した後、構成ファイルからデバイスを削除します。 デバイスを永久に保持するにはこれを`-1`に設定するか、パージ値を設定するには`1`以上の整数を設定します。 デフォルトでは、 `0`に設定されています。
          </td>
        </tr>

        <tr>
          <td>
            [watch_profile_changes](#watch-profile-changes)
          </td>

          <td/>

          <td>
            `mib_profile_dir`パスのプロファイルが変更されたときに[SNMP スレッドを再ロードする](#reload-snmp-threads)ウォッチャーを設定します。 デフォルトでは、 `false`に設定されています。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## クラウドプロバイダーの秘密 [#cloud-provider-secrets]

ネットワーク監視エージェントには[、AWS Secrets Manager](https://docs.aws.amazon.com/secretsmanager/) 、 [Azure Key Vault](https://learn.microsoft.com/en-us/azure/key-vault/general/) 、および[GCP Secret Manager](https://cloud.google.com/secret-manager/docs)からキーを取得するためのサポートが組み込まれています。

<Callout variant="important">
  SNMPv1 および SNMPv2c は、プロトコル自体がコミュニティ文字列をデフォルトでプレーン テキストで送信するため、クラウド シークレットの使用をサポートしていません。 SNMP 認証のセキュリティが懸念される場合は、SNMPv3 を使用するように更新してください。
</Callout>

<Collapser
  id="cloud-secrets"
  title="クラウドの秘密設定"
>
  <Tabs>
    <TabsBar>
      <TabsBarItem id="aws-secrets-manager">
        AWS Secrets Manager
      </TabsBarItem>

      <TabsBarItem id="azure-key-vault">
        Azure Key Vault
      </TabsBarItem>

      <TabsBarItem id="gcp-secret-manager">
        GCP シークレット マネージャー
      </TabsBarItem>
    </TabsBar>

    <TabsPages>
      <TabsPageItem id="aws-secrets-manager">
        AWS Secrets Manager を使用するには、次の 3 つの [環境変数](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html#envvars-list)を設定し、実行時にdockerに提供する必要があります。

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                名前
              </th>

              <th>
                説明
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `AWS_ACCESS_KEY_ID`
              </td>

              <td>
                ユーザーを認証するためのクレデンシャルの一部として使用されるAWSアクセスキーを指定します。
              </td>
            </tr>

            <tr>
              <td>
                `AWS_SECRET_ACCESS_KEY`
              </td>

              <td>
                ユーザーを認証するための認証情報の一部として使用されるAWSシークレットキーを指定します。
              </td>
            </tr>

            <tr>
              <td>
                `AWS_REGION`
              </td>

              <td>
                リクエストの送信先の AWS リージョンを指定します。
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -e NEW_RELIC_API_KEY=$YOUR_NR_LICENSE_KEY \
        -e AWS_ACCESS_KEY_ID=$YOUR_AWS_ACCESS_KEY_ID \
        -e AWS_SECRET_ACCESS_KEY=$YOUR_AWS_SECRET_ACCESS_KEY \
        -e AWS_REGION=$YOUR_AWS_REGION \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>

      <TabsPageItem id="azure-key-vault">
        Azure Key Vault を使用するには、次の 5 つの環境変数を設定し、実行時にdockerに提供する必要があります。

        <Callout variant="tip">
          両方ではなく、 `KT_AZURE_KEY_VAULT_NAME`または`KT_AZURE_KEY_VAULT_URL`を設定する必要があります。 デフォルトでは`KT_AZURE_KEY_VAULT_NAME`が使用され、エージェントは共通の URL パターンを使用します。 `https://$KT_AZURE_KEY_VAULT_NAME.vault.azure.net/`
        </Callout>

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                名前
              </th>

              <th>
                説明
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `KT_AZURE_KEY_VAULT_NAME`
              </td>

              <td>
                シークレットが保存されているボールト名。
              </td>
            </tr>

            <tr>
              <td>
                `KT_AZURE_KEY_VAULT_URL`
              </td>

              <td>
                APIコールがターゲットとするオプションの完全なURL。
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_CLIENT_ID](https://learn.microsoft.com/en-us/entra/identity-platform/howto-create-service-principal-portal#sign-in-to-the-application)
              </td>

              <td>
                `Application ID`と呼ばれることもあります。これは、シークレットにアクセスするために使用されるサービス プリンシパルの識別子です。
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_CLIENT_SECRET](https://learn.microsoft.com/en-us/entra/identity-platform/howto-create-service-principal-portal#option-3-create-a-new-client-secret)
              </td>

              <td>
                これは、認証時にサービス プリンシパルに使用されるクライアント シークレット (パスワード) です。 この ID はクライアント シークレットの<DNT>**value**</DNT>のものであり、シークレット自体の ID ではないことに注意してください。
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_SUBSCRIPTION_ID](https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id#find-your-azure-subscription)
              </td>

              <td>
                これは、シークレットが管理されるサブスクリプションに関連付けられた 32 桁の GUID です。
              </td>
            </tr>

            <tr>
              <td>
                [AZURE_TENANT_ID](https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id#find-your-microsoft-entra-tenant)
              </td>

              <td>
                `Directory ID`と呼ばれることもあります。これは、サービス プリンシパルが保存されている Microsoft Entra のテナントの識別子です。
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -e KT_AZURE_KEY_VAULT_NAME=$YOUR_KEY_VAULT_NAME \
        #### Optional: Provide the full URL to target
        # -e KT_AZURE_KEY_VAULT_URL=$YOUR_KEY_VAULT_URL \
        -e AZURE_CLIENT_ID=$YOUR_CLIENT_ID \
        -e AZURE_CLIENT_SECRET=$YOUR_CLIENT_SECRET \
        -e AZURE_TENANT_ID=$YOUR_TENANT_ID \
        -e AZURE_SUBSCRIPTION_ID=$YOUR_SUBSCRIPTION_ID \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>

      <TabsPageItem id="gcp-secret-manager">
        GCP Secret Manager を使用するには、認証情報 JSON ファイルに対して次のボリューム マウントを 2 つの環境変数とともに設定し、実行時にdockerに提供する必要があります。

        <table>
          <thead>
            <tr>
              <th style={{ width: "200px" }}>
                名前
              </th>

              <th>
                説明
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                [サービスアカウントキー](https://cloud.google.com/iam/docs/keys-create-delete#creating)
              </td>

              <td>
                ユーザーの認証に使用されるサービス アカウント キーのローカル ファイル パスを指定します。 このファイルはdockerコンテナにボリューム マウントされ、`GOOGLE_APPLICATION_CREDENTIALS` 環境変数で参照されます。
              </td>
            </tr>

            <tr>
              <td>
                [GOOGLE_APPLICATION_CREDENTIALS](https://cloud.google.com/docs/authentication/provide-credentials-adc#local-key)
              </td>

              <td>
                サービス アカウント キー ファイルをマップしたコンテナー内のファイル パスを指定します。
              </td>
            </tr>

            <tr>
              <td>
                [GOOGLE_CLOUD_PROJECT](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
              </td>

              <td>
                シークレットが保存される一意のプロジェクト ID を指定します。
              </td>
            </tr>
          </tbody>
        </table>

        ```
        docker run -d --name ktranslate-$CONTAINER_SERVICE --restart unless-stopped --pull=always -p 162:1620/udp \
        -v `pwd`/snmp-base.yaml:/snmp-base.yaml \
        -v $YOUR_LOCAL_SERVICE_ACCOUNT_KEY_FILE_PATH:/gcp_snmp_sa_key.json \
        -e GOOGLE_APPLICATION_CREDENTIALS='./gcp_snmp_sa_key.json' \
        -e GOOGLE_CLOUD_PROJECT=$YOUR_PROJECT_ID \
        kentik/ktranslate:v2 \
          -snmp /snmp-base.yaml \
          -nr_account_id=$YOUR_NR_ACCOUNT_ID \
          -metrics=jchf \
          -tee_logs=true \
          -service_name=$CONTAINER_SERVICE \
          -snmp_discovery_on_start=true \
          -snmp_discovery_min=180 \
          nr1.snmp
        ```
      </TabsPageItem>
    </TabsPages>
  </Tabs>
</Collapser>

## SNMPv3 オプション [#snmpv3-options]

<CollapserGroup>
  <Collapser
    id="snmpv3-config"
    title="SNMPv3設定"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            キー名
          </th>

          <th>
            必須
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            user_name
          </td>

          <td>
            ✓✓
          </td>

          <td>
            SNMPv3認証のユーザー名
          </td>
        </tr>

        <tr>
          <td>
            authentication_protocol
          </td>

          <td>
            ✓✓
          </td>

          <td>
            SNMPv3認証プロトコル。可能な値は、 `NoAuth` 、 `MD5` 、または `SHA`
          </td>
        </tr>

        <tr>
          <td>
            authentication_passphrase
          </td>

          <td/>

          <td>
            SNMPv3認証パスフレーズ
          </td>
        </tr>

        <tr>
          <td>
            privacy_protocol
          </td>

          <td>
            ✓✓
          </td>

          <td>
            SNMPv3プライバシープロトコル。可能な値は、 `NoPriv` 、 `DES` 、 `AES` 、 `AES192` 、 `AES256` 、 `AES192C` 、または `AES256C`
          </td>
        </tr>

        <tr>
          <td>
            privacy_passphrase
          </td>

          <td/>

          <td>
            SNMPv3プライバシーパスフレーズ
          </td>
        </tr>

        <tr>
          <td>
            context_engine_id
          </td>

          <td/>

          <td>
            SNMPv3コンテキストエンジンID
          </td>
        </tr>

        <tr>
          <td>
            context_name
          </td>

          <td/>

          <td>
            SNMPv3コンテキスト名
          </td>
        </tr>
      </tbody>
    </table>

    ### 例：

    <Callout variant="tip">
      AWS、Azure、または GCP のシークレットを使用するには、エージェントがターゲット API をクエリするために必要な[適切な環境変数とその他の認証情報を提供する](/docs/network-performance-monitoring/advanced/advanced-config/#cloud-secrets)必要もあります。
    </Callout>

    <Tabs>
      <TabsBar>
        <TabsBarItem id="v3-plain-text">
          プレーンテキスト
        </TabsBarItem>

        <TabsBarItem id="v3-aws-secret">
          AWS シークレット
        </TabsBarItem>

        <TabsBarItem id="v3-azure-secret">
          アズールの秘密
        </TabsBarItem>

        <TabsBarItem id="v3-gcp-secret">
          GCP シークレット
        </TabsBarItem>
      </TabsBar>

      <TabsPages>
        <TabsPageItem id="v3-plain-text">
          ```yaml
          discovery:
            default_v3:
              user_name: $YOUR_SNMPV3_USER
              authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
              authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
              privacy_protocol: $YOUR_PRIVACY_PROTOCOL
              privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-aws-secret">
          ```yaml
          discovery:
            default_v3: aws.sm.$YOUR_SECRET_NAME
          ```

          AWS では、関連するすべての`key:value`ペアを含む[JSON 構造にシークレットを保存する](https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_secret_json_structure.html)必要があります。 これは例です:

          ```json
          {
          "user_name": "$YOUR_SNMPV3_USER",
          "authentication_protocol": "$YOUR_AUTHENTICATION_PROTOCOL",
          "authentication_passphrase": "$YOUR_AUTHENTICATION_PASSPHRASE",
          "privacy_protocol": "$YOUR_PRIVACY_PROTOCOL",
          "privacy_passphrase": "$YOUR_PRIVACY_PASSPHRASE"
          }
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-azure-secret">
          ```yaml
          discovery:
            default_v3: azure.kv.$YOUR_SECRET_NAME
          ```

          Azure では、関連するすべての`key:value`ペアを含む[複数行構造でシークレットを保存する](https://learn.microsoft.com/en-us/azure/key-vault/secrets/multiline-secrets)必要があります。 これは例です:

          ```
          user_name: $YOUR_SNMPV3_USER
          authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
          authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
          privacy_protocol: $YOUR_PRIVACY_PROTOCOL
          privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>

        <TabsPageItem id="v3-gcp-secret">
          ```yaml
          discovery:
            default_v3: gcp.sm.$YOUR_SECRET_NAME
          ```

          GCP では、関連するすべての`key:value`ペアを含む[複数行構造でシークレットを保存する](https://cloud.google.com/secret-manager/docs/create-secret-quickstart)必要があります。 これは例です:

          ```
          user_name: $YOUR_SNMPV3_USER
          authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL
          authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE
          privacy_protocol: $YOUR_PRIVACY_PROTOCOL
          privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE
          ```
        </TabsPageItem>
      </TabsPages>
    </Tabs>
  </Collapser>

  <Collapser
    id="multiple-v3-discovery"
    title="複数のSNMPv3プロファイルを使用した検出の実行"
  >
    複数のSNMPv3プロファイルでの検出ジョブの実行をサポートするために、 `discovery.default_v3`キーを[SNMPv3構成](#snmpv3-config)の配列を保持する`discovery.other_v3s`キーに置き換えることができます。

    ```yaml
    discovery:
      other_v3s:
      - user_name: $YOUR_USER_NAME_1
        authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL_1
        authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE_1
        privacy_protocol: $YOUR_PRIVACY_PROTOCOL_1
        privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE_1
        context_engine_id: ""
        context_name: ""
      - user_name: $YOUR_USER_NAME_2
        authentication_protocol: $YOUR_AUTHENTICATION_PROTOCOL_2
        authentication_passphrase: $YOUR_AUTHENTICATION_PASSPHRASE_2
        privacy_protocol: $YOUR_PRIVACY_PROTOCOL_1
        privacy_passphrase: $YOUR_PRIVACY_PASSPHRASE_2
        context_engine_id: ""
        context_name: ""
    ```

    これは、クラウド プロバイダーのシークレット マネージャーを使用しても機能します。 AWS の例:

    ```yaml
    discovery:
      other_v3s:
      - aws.sm.$YOUR_SECRET_NAME_1
      - aws.sm.$YOUR_SECRET_NAME_2
    ```
  </Collapser>
</CollapserGroup>

## APIポーリング構成 [#api-polling-configurations]

<Callout variant="tip">
  API 認証設定でクラウド プロバイダーのシークレットを使用することもできます。
</Callout>

<CollapserGroup>
  <Collapser
    id="arista"
    title="Arista eAPI"
  >
    [Arista eAPI](https://www.arista.com/assets/data/pdf/Whitepapers/Arista_eAPI_FINAL.pdf) 統合は、通常 SNMP ポーリングでは利用できない追加の BGP および MLAG テレメトリを収集します。

    * BGP の詳細は次のコマンドから収集されます。 `show ip bgp summary vrf all`

      NRQL を使用して BGP テレメトリを検索します。

      ```sql
      FROM Metric SELECT
        max(kentik.eapi.bgp.InMsgQueue) AS 'InQ', // Messages Queued from the Neighbor
        max(kentik.eapi.bgp.MsgReceived) AS 'MsgSent', // Messages Received from the Neighbor
        max(kentik.eapi.bgp.MsgSent) AS 'MsgRcvd', // Messages Sent to the Neighbor
        latest(peer_state) AS 'State', // State of the BGP session
        latest(kentik.eapi.bgp.UpDownTime) AS 'Up/Down', // Period the BGP session has been in current state
        latest(kentik.eapi.bgp.Version) AS 'V' // BGP version number
      FACET
        entity.name AS 'Device',
        router_id AS 'Device IP',
        peer AS 'BGP Peer',
        peer_asn AS 'BGP Peer ASN',
        vrf AS 'VRF Name'
      ```

      <br/>

    * MLAG の詳細は、次のコマンドから収集されます。 `show mlag detail`

      NRQL で MLAG テレメトリを検索します。

      ```sql
      FROM Metric SELECT
        latest(kentik.eapi.mlag.PortsConfigured) AS 'Ports Configured', // Count of MLAG ports currently configured
        latest(kentik.eapi.mlag.PortsDisabled) AS 'Ports Disabled', // Count of MLAG ports in 'Disabled' state
        latest(kentik.eapi.mlag.PortsActivePartial) AS 'Ports Active-partial', // Count of MLAG ports in 'Active-partial' state 
        latest(kentik.eapi.mlag.PortsInactive) AS 'Ports Inactive', // Count of MLAG ports in 'Inactive' state
        latest(kentik.eapi.mlag.PortsActiveFull) AS 'Ports Active-full', // Count of MLAG ports in 'Active-full' state
        latest(kentik.eapi.mlag.PortsErrdisabled) AS 'Ports Err-disabled', // Count of MLAG ports in 'Err-disabled' state
        latest(config_sanity) AS 'Config-Sanity', // Current result of 'config-sanity' check
        latest(state) AS 'State', // Current MLAG state
        latest(neg_status) AS 'Negotiation Status', // Current negotiation status between switches
        latest(peer_address) AS 'Peer Address', // Address of MLAG peer
        latest(peer_link) AS 'Peer Link', // Link name for MLAG peer
        latest(peer_link_status) AS 'Peer Link Status', // Status of MLAG peer
        latest(local_interface) AS 'Local Interface', // Local interface used for MLAG configuration
        latest(local_intf_status) AS 'Local Interface Status' // Status of local interface used for MLAG configuration
      FACET
        entity.name AS 'Device',
        domain_id AS 'MLAG Domain ID'
      ```

      ### 設定オプション

      <table>
        <thead>
          <tr>
            <th style={{ width: "200px" }}>
              キー名
            </th>

            <th>
              必須
            </th>

            <th>
              説明
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              eapi_config.ユーザー名
            </td>

            <td>
              ✓✓
            </td>

            <td>
              eAPI 認証を認証するためにデバイスに渡すユーザー名。
            </td>
          </tr>

          <tr>
            <td>
              eapi_config.パスワード
            </td>

            <td>
              ✓✓
            </td>

            <td>
              eAPI 認証を認証するためにデバイスに渡すパスワード。
            </td>
          </tr>

          <tr>
            <td>
              eapi_config.transport
            </td>

            <td/>

            <td>
              使用する接続トランスポートのタイプを指定します。可能な値は `https` と `http`です。デフォルト: `https` 。
            </td>
          </tr>

          <tr>
            <td>
              eapi_config.port
            </td>

            <td>
              ✓✓
            </td>

            <td>
              eAPI 接続のエンドポイントの TCP ポート。
            </td>
          </tr>
        </tbody>
      </table>
  </Collapser>

  <Collapser
    id="meraki"
    title="Meraki ダッシュボード API"
  >
    [Meraki ダッシュボードAPIインテグレーションは、](https://developer.cisco.com/meraki/api/) Meraki 環境の健全性に関連するさまざまなメトリクスを取得します。 構成オプションを組み合わせることで、ニーズに合わせてさまざまな監視シナリオを設定し、New Relic アカウントにエンティティを作成できます。

    <CollapserGroup>
      <Collapser
        id="meraki-organization"
        title="Meraki 組織エンティティ"
      >
        組織メトリクスは、デフォルトでは、 `Meraki Organization`エンティティの生成にのみ使用される`kentik.meraki.organization.Count`メトリクスの下に収集されます。 これは主に、Meraki 階層を視覚化し、ネットワークとデバイスを親組織に合わせて調整できるようにするためです。

        * `meraki_config.monitor_org_changes: true`:[組織構成変更の取得](https://developer.cisco.com/meraki/api/get-organization-configuration-changes/)エンドポイントを使用して、組織の変更ログを表示します。

          NRQL を使用して組織構成変更テレメトリを検索します。

          ```sql
          FROM KExtEvent SELECT *
          ```
      </Collapser>

      <Collapser
        id="meraki-network"
        title="Meraki ネットワーク エンティティ"
      >
        * `meraki_config.preferences.show_network_attr: true`

          ネットワーク メトリクスは、 `kentik.meraki.network.Count`エンティティの生成にのみ使用されるメトリクスの下に収集されます。 `Meraki Network` これは主に、Meraki 階層の視覚化を可能にし、デバイスがメンバーとなっているネットワークに合わせて調整することを目的としています。
      </Collapser>

      <Collapser
        id="meraki-device"
        title="Meraki デバイス エンティティ"
      >
        * `meraki_config.monitor_devices: true && meraki_config.preferences.device_status_only: true`：[組織デバイス ステータスの取得](https://developer.cisco.com/meraki/api/get-organization-devices-statuses/)エンドポイントを使用して、組織内のすべての Meraki デバイスのステータスを一覧表示します。

          NRQL を使用してデバイス ステータス テレメトリを検索します。

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Device Status' // Current status of this device
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            src_addr AS 'Device Public IP',
            mac AS 'Device MAC',
            model AS 'Device Model',
            serial AS 'Device Serial',
            address AS 'Device Address',
            lat AS 'Device Latitude',
            lng AS 'Device Longitude',
            notes AS 'Device Notes'
          WHERE instrumentation.name = 'meraki.device_status'
          ```

          <br/>

        * `meraki_config.monitor_uplinks: true && meraki_config.preferences.hide_uplink_usage: false`：[組織のアップリンク ステータスの取得](https://developer.cisco.com/meraki/api/get-organization-uplinks-statuses/)と[ネットワーク エンドポイントごとの組織アプライアンス アップリンクの使用状況の](https://developer.cisco.com/meraki/api/get-organization-appliance-uplinks-usage-by-network/)両方を使用して、組織内のすべての Meraki MX、MG、および Z シリーズ デバイスのアップリンク ステータスとパフォーマンスを一覧表示します。

          NRQL を使用してデバイスのアップリンク テレメトリを検索します。

          ```sql
          FROM Metric SELECT
            max(kentik.meraki.uplinks.LatencyMS) AS 'Uplink Latency', // Uplink measured latency in milliseconds
            max(kentik.meraki.uplinks.LossPct) AS 'Uplink Loss %', // Uplink measured loss percentage
            max(kentik.meraki.uplinks.Recv) AS 'Uplink Receive Bytes', // Uplink bytes received
            max(kentik.meraki.uplinks.Sent) AS 'Uplink Transmit Bytes', // Uplink bytes sent
            latest(status) AS 'Uplink Status' // Latest status of the uplink
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            interface AS 'Device Uplink Interface',
            model AS 'Device Model',
            serial AS 'Device Serial'
          WHERE org_id IS NOT NULL
          ```

          <br/>

        * `meraki_config.monitor_uplinks: true && meraki_config.preferences.hide_uplink_usage: true`：[組織のアップリンク ステータスの取得](https://developer.cisco.com/meraki/api/get-organization-uplinks-statuses/)エンドポイントを使用して、組織内のすべての Meraki MX、MG、および Z シリーズ デバイスのアップリンク ステータスのみを一覧表示します。

          NRQL を使用してデバイスのアップリンク ステータス テレメトリを検索します。

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Uplink Status' // Latest status of the uplink
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            interface AS 'Device Uplink Interface',
            model AS 'Device Model',
            serial AS 'Device Serial'
          WHERE org_id IS NOT NULL
          ```

          <br/>

        * `meraki_config.monitor_vpn_status: true && meraki_config.preferences.show_vpn_peers: false`:[組織アプライアンスの VPN ステータスの取得](https://developer.cisco.com/meraki/api/get-organization-appliance-vpn-statuses/)エンドポイントを使用して、組織内のネットワーク全体の VPN ステータスを表示します。

          NRQL を使用して VPN ステータス テレメトリを検索します。

          ```sql
          FROM Metric SELECT
            latest(status) AS 'VPN Status' // Latest status of this VPN
          FACET
            org_id AS 'Organization ID',
            org_name AS 'Organization Name',
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            serial AS 'Device Serial',
            vpn_mode AS 'VPN Mode',
            wan1 OR wan2 AS 'WAN Interface IP'
          WHERE instrumentation.name = 'meraki.vpn_status'
          AND org_id IS NOT NULL
          ```

          <br/>

        * `meraki_config.monitor_vpn_status: true && meraki_config.preferences.show_vpn_peers: true`:[組織アプライアンスの VPN ステータスの取得](https://developer.cisco.com/meraki/api/get-organization-appliance-vpn-statuses/)エンドポイントを使用して、組織内のネットワーク全体の VPN ピアに関する情報を追加します。

          NRQL を使用して VPN ピアのテレメトリを検索します。

          ```sql
          FROM Metric SELECT
            latest(status) AS 'Peer Status' // Current status of this VPN peer
          FACET
            network_id AS 'Network ID',
            network AS 'Network Name',
            device_name AS 'Device Name',
            serial AS 'Device Serial',
            vpn_mode AS 'VPN Mode',
            wan1 AS 'WAN 1 IP',
            wan2 AS 'WAN 2 IP',
            peer_name AS 'Peer Name', // Name of this peer
            peer_reachability AS 'Peer Reachability', // Latest results of reachability test for this peer
            peer_network_id AS 'Peer Network ID', // Network ID for this peer
            peer_type AS 'Peer Type' // Type of Peer (Meraki vs Third-party)
          WHERE metricName = 'kentik.meraki.vpn_status.PeerStatus'
          ```
      </Collapser>

      <Collapser
        id="meraki-config-options"
        title="Meraki 設定オプション"
      >
        <Collapser
          id="meraki-primary-config"
          title="主な構成オプション"
        >
          <Callout variant="tip">
            [API](/docs/network-performance-monitoring/advanced/ktranslate-container-management/#container-runtime-options)環境変数を使用すると、API キーを設定ファイルにプレーン テキストで保存せずに Meraki 統合に渡すことができます。
          </Callout>

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  キー名
                </th>

                <th>
                  必須
                </th>

                <th>
                  入力
                </th>

                <th>
                  説明
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki_config.api_key
                </td>

                <td>
                  ✓ ( [KENTIK_MERAKI_API_KEY](/docs/network-performance-monitoring/advanced/ktranslate-container-management)環境変数を使用する場合は不要)
                </td>

                <td>
                  APIキー(文字列)
                </td>

                <td>
                  認証用の[Meraki ダッシュボード API キー](https://documentation.meraki.com/General_Administration/Other_Topics/Cisco_Meraki_Dashboard_API#Enable_API_Access) 。
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.max_http_retry
                </td>

                <td/>

                <td>
                  1 ～ 10 の整数 (デフォルト: 2)
                </td>

                <td>
                  `HTTP 429`エラーを返す API リクエストで再試行する頻度を制御するオプションの設定。再試行の間隔は 5 秒です。
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_devices
                </td>

                <td/>

                <td>
                  本当 | false (デフォルト: false)
                </td>

                <td>
                  組織内のすべての Meraki デバイスのステータスを監視します。
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_org_changes
                </td>

                <td/>

                <td>
                  本当 | false (デフォルト: false)
                </td>

                <td>
                  組織の変更ログを監視します。
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_uplinks
                </td>

                <td/>

                <td>
                  本当 | false (デフォルト: true)
                </td>

                <td>
                  組織内のすべての Meraki MX、MG、および Z シリーズ デバイスのアップリンク ステータスとパフォーマンスを監視します。
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.monitor_vpn_status
                </td>

                <td/>

                <td>
                  本当 | false (デフォルト: false)
                </td>

                <td>
                  組織内のネットワーク全体の VPN ステータスを監視します。
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser
          id="meraki-filter-config"
          title="フィルタリングオプション"
        >
          これらのオプションを使用すると、Meraki 環境内の特定の対象オブジェクトへの監視を制限できます。

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  キー名
                </th>

                <th>
                  必須
                </th>

                <th>
                  入力
                </th>

                <th>
                  説明
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki_config.organizations
                </td>

                <td/>

                <td>
                  [RE2 構文](https://github.com/google/re2/wiki/Syntax)の正規表現 (デフォルト: null)
                </td>

                <td>
                  すべての監視をフィルタリングして、組織の特定のリストを絞り込みます。
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.networks
                </td>

                <td/>

                <td>
                  [RE2 構文](https://github.com/google/re2/wiki/Syntax)の正規表現 (デフォルト: null)
                </td>

                <td>
                  すべての監視をフィルタリングして、ネットワークの特定のリストを絞り込みます。
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.product_types
                </td>

                <td/>

                <td>
                  有効なタイプは、ワイヤレス、アプライアンス、スイッチ、systemsManager、カメラ、セルラーゲートウェイ、センサー、およびクラウドゲートウェイです。(デフォルト: null)
                </td>

                <td>
                  特定のタイプのデバイスでフィルタリングするためのパラメータを[monitor_devices](https://developer.cisco.com/meraki/api/get-organization-devices-statuses/) APIリクエストに追加します。
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser
          id="meraki-additional-config"
          title="追加の設定"
        >
          これらのオプションを使用すると、メインの構成オプションから収集されたデータをさらに定義できます。上記の例のセクションでは、さまざまな組み合わせが説明されています。

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  キー名
                </th>

                <th>
                  必須
                </th>

                <th>
                  入力
                </th>

                <th>
                  説明
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  meraki_config.preferences.device_status_only
                </td>

                <td/>

                <td>
                  本当 | false (デフォルト: false)
                </td>

                <td>
                  `monitor_devices: true`を使用してポーリングをステータス情報のみに制限する場合に_必須です_。 <DNT>**(This is used to prevent timeout issues.)**</DNT>
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.preferences.hide_uplink_usage
                </td>

                <td/>

                <td>
                  本当 | false (デフォルト: false)
                </td>

                <td>
                  `monitor_uplinks` と組み合わせて使用すると、パフォーマンス メトリックを削除し、アップリンクのステータス情報のみを返します。
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.preferences.show_vpn_peers
                </td>

                <td/>

                <td>
                  本当 | false (デフォルト: false)
                </td>

                <td>
                  `monitor_vpn_status` と組み合わせて使用して、VPN ピアにテレメトリを追加します。
                </td>
              </tr>

              <tr>
                <td>
                  meraki_config.preferences.show_network_attr
                </td>

                <td/>

                <td>
                  本当 | false (デフォルト: false)
                </td>

                <td>
                  ネットワーク上にテレメトリーを追加するために使用されます。 `Meraki Network`エンティティを作成するために必要です。
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>
      </Collapser>

      ### 最小構成例 [#meraki-minimum-config]

      ```yaml
      # This represents the minimal configuration required for a container that only performs Meraki API polling.
      # By default we only monitor uplinks. All other items are optional.
      ---
       devices:
          meraki_cloud_controller:
            device_name: meraki_cloud_controller
            device_ip: snmp.meraki.com
            provider: meraki-cloud-controller
            ext:
              ext_only: true
              meraki_config:
                api_key: "$YOUR_API_KEY"
       trap: {}
       discovery: {}
       global:
         poll_time_sec: 300
         timeout_ms: 30000
      ```

      ### 完全な設定例 [#meraki-full-config]

      #### `Meraki Organization` 、 `Meraki Network` 、および`Meraki Device`エンティティの作成に必要なすべてのオプション。

      ```yaml
      devices:
        meraki_dashboard_api:
          device_name: meraki_controller
          device_ip: snmp.meraki.com
          provider: meraki-cloud-controller
          ext:
            ext_only: true
            meraki_config:
              api_key: $YOUR_MERAKI_API_KEY
              monitor_devices: true
              monitor_org_changes: true
              monitor_uplinks: true
              monitor_vpn_status: true
              preferences:
                device_status_only: true
                hide_uplink_usage: false
                show_vpn_peers: true
                show_network_attr: true
      trap: {}
      discovery: {}
      global:
        poll_time_sec: 300
        timeout_ms: 30000
      ```

      #### 複数の Meraki ダッシュボード API をターゲットとするキー

      ```yaml
      devices:
         # Entity 1 - monitor everything this API key has access to
         meraki_all:
           device_name: meraki_all
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_1"
               max_http_retry: 8
               monitor_devices: true
               monitor_org_changes: true
               monitor_uplinks: true
               monitor_vpn_status: true
               preferences:
                 device_status_only: true
                 show_vpn_peers: true
                 hide_uplink_usage: false
         # Entity 2 - Monitor these specific organizations under this API key
         meraki_single_org:
           device_name: meraki_single_org
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_2"
               monitor_devices: true
               monitor_org_changes: true
               monitor_uplinks: true
               monitor_vpn_status: true
               preferences:
                 device_status_only: true
                 show_vpn_peers: true
                 hide_uplink_usage: false
               organizations:
                 - "Org 1 - Prod.*"
                 - "Org 2 - Staging"
         # Entity 3 - Monitor specific devices filtered by organization, network, and product types; using the same API key from Entity 2
         meraki_filtered:
           device_name: meraki_filtered
           device_ip: snmp.meraki.com
           provider: meraki-cloud-controller
           ext:
             ext_only: true
             meraki_config:
               api_key: "$YOUR_API_KEY_2"
               monitor_devices: true
               monitor_uplinks: false
               preferences:
                 device_status_only: true
               organizations:
                 - "Org 3 - Remote Sites"
               networks:
                 - "Corp.*99"
                 - "Retail.*"
               product_types:
                 - wireless
                 - appliance
      trap: {}
      discovery: {}
      global:
        poll_time_sec: 300
        timeout_ms: 30000
      ```
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

## 外部設定ファイル [#external-config-files]

さまざまな設定と自動化のニーズをサポートするために、 dockerコンテナーにボリューム マウントする外部ファイルを使用して、標準の設定ファイルの特定の要素を分離できます。 `docker run`コマンドに以下のマウント引数を含める必要があります。外部設定ファイルごとに 1 つの引数を指定します。

```
-v `pwd`/fileName.yaml:/fileName.yaml \
```

これらのファイルの構文は、二重引用符を含めて`"@fileName.yaml"`です。

<CollapserGroup>
  <Collapser
    id="discovery-cidrs-file"
    title="ディスカバリーCIDR"
  >
    例：

    ```yaml
    discovery:
      cidrs: "@cidrs.yaml"
    ```

    CIDRファイルは、次のようなYAMLリスト構文を使用する必要があります。

    ```yaml
    - 10.10.0.0/24
    - 10.20.0.0/24
    - 192.168.0.21/32
    ```
  </Collapser>

  <Collapser
    id="devices-file"
    title="デバイス"
  >
    例：

    ```yaml
    devices:
      "@neteng-devices.yaml"
    ```

    デバイスファイルは、メイン構成ファイルの標準`devices`セクションと同じ構文を使用する必要がありますが、検出中に生成されるオプションのフィールドは省略されます。

    ```yaml
    devices:
      # Sample of SNMP v2c device
      ups_snmpv2c__10.10.0.201:
        device_name: ups_snmpv2c
        device_ip: 10.10.0.201
        snmp_comm: $YOUR_COMMUNITY_STRING
        oid: .1.3.6.1.4.1.318.1.3.27
        mib_profile: apc_ups.yml
        provider: kentik-ups
        poll_time_sec: 300
        retries: 1
        timeout_ms: 5000
        user_tags:
          owning_team: dc_ops
    ```
  </Collapser>
</CollapserGroup>

## `match_attributes`属性 [#match_attributes-attribute]

可観測性のニーズに見合う価値を生み出さないデータのフィルタリングをサポートするために、 `global.match_attributes.{}`または`devices.[].match_attributes.{}`属性マップを設定できます。

これにより、New Relic にデータを送信する前に、 `ktranslate`レベルでフィルタリングが提供され、インターフェースなどの監視をきめ細かく制御できるようになります。

このマップのデフォルトの動作は`OR`条件ですが、これをオーバーライドして、キー名の前に`!`を付けることで`AND`演算子を強制することができます。これは、一致したアイテムのみを返し、すべての`null`および`""` （空の）結果を省略する場合にも役立ちます。

<CollapserGroup>
  <Collapser
    id="default-or-null"
    title="null値と空の値を持つデフォルトの「OR」"
  >
    `if_Alias` `Uplink`で始まる場合に一致します。 <DNT>**OR**</DNT> `if_interface_name` `Gig`で始まる場合、すべての`null`と`""`値を保持します。

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          if_Alias: "^Uplink.*"
          if_interface_name: "^Gig.*"
    ```
  </Collapser>

  <Collapser
    id="and-no-null"
    title="'AND'、nullおよび空の値を省略"
  >
    `if_Alias` `Uplink`で始まる場合に一致し、 <DNT>**AND**</DNT> `if_interface_name` `Gig`で始まる場合に一致し、すべての`null`および`""`値を削除します。

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          if_Alias: "^Uplink.*"
          "!if_interface_name": "^Gig.*"
    ```
  </Collapser>

  <Collapser
    id="single-no-null"
    title="単一一致、null値と空の値を省略"
  >
    `if_Alias`が`Uplink`で始まる場合に一致し、すべての`null`と`""`の値を削除します。

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          "!if_Alias": "^Uplink.*"
    ```
  </Collapser>

  <Collapser
    id="negate-lookup"
    title="ネガティブな先読みを作成する"
  >
    Golang の正規表現パッケージは、デフォルトでは否定先読みパターン ( `q(?!u)` ) をサポートしていません。 回避策として、属性マップに`DOES_NOT_MATCH`トークンを追加して、一致パターンの逆の結果を効果的に得ることができます。

    たとえば、文字列`Uplink`を含ま**ない**すべてのインターフェースに一致させるには、次のような設定を使用できます。

    ```yaml
    devices:
      deviceName:
        ...
        match_attributes:
          "!if_Alias": "^Uplink.*"
          DOES_NOT_MATCH: true
    ```
  </Collapser>
</CollapserGroup>

## `response_time`属性と`ping_only`属性 [#response_time-attribute]

パフォーマンス統計にアクセスできない、または利用できないデバイスの監視をサポートするため、または基本的なラウンドトリップ時間（RTT）の監視が必要な単純な場合に、 `global.response_time`または`devices.[].ping_only`属性を`true`に設定できます。

この機能は、平均、最小、最大、および stddev ラウンドトリップ時間 (RTT) を収集するために、 [go-ping](https://pkg.go.dev/github.com/sparrc/go-ping)パッケージを使用して ICMP または非特権 UDP パケットをデバイスに送信します。このパッケージは、 `ktranslate`からデバイスの IP アドレスに 1 秒あたり 1 パケットを送信することに基づいて、エンドポイントのパケット損失率も示します。これは、 `devices.[].ping_interval_sec`属性を設定することでオーバーライドできます。Docker ランタイム中に`KENTIK_PING_PRIV=false`環境変数を設定することにより、特権 ICMP パケットまたは UDP のデフォルトの使用から切り替えることができます。

`global.response_time`属性を`true`に設定すると、既存のSNMPポーリングに加えてRTT監視が追加されます。RTTのUDP|ICMPパケットのみを使用し、SNMPポーリングを使用しないデバイスを監視するには、 `devices.[].ping_only: true`を使用します。

New Relicでは、次のメトリックを調査することで、このポーリングの結果を確認できます。

```sql
FROM Metric SELECT
  average(kentik.ping.AvgRttMs) AS 'Average',
  max(kentik.ping.MaxRttMs) AS 'Max',
  min(kentik.ping.MinRttMs) AS 'Min',
  average(kentik.ping.StdDevRtt) AS 'StdDev',
  latest(kentik.ping.PacketLossPct) AS 'Packet Loss %'
FACET device_name
```

<Callout variant="tip">
  フローデバイスからRTTメトリックを収集する場合は、 `flow_only`属性の代わりに`ping_only`属性を使用できます。`ping_only`と`flow_only`の両方が`true`の場合、デバイスは`flow_only`デバイスとして扱われます。
</Callout>

## `flow_only`属性 [#flow_only-attribute]

フロー データのみを収集するデバイスのモニタリングをサポートするには、 `devices.<deviceName>.flow_only`属性を`true`に設定します。

これにより、 `KFlow`イベントのネームスペースにテレメトリーのみを持つ<DNT>**Flow Device**</DNT>エンティティが生成されます。 あるいは、SNMP デバイスとして設定ファイルにあるデバイスからフロー テレメトリーを収集すると、 <DNT>**Router**</DNT>や<DNT>**Firewall**</DNT>などの既存のエンティティに`KFlow`データの装飾が追加されます。

New Relicでは、次のイベントを調査することで、このポーリングの結果を確認できます。

```sql
FROM KFlow SELECT *
WHERE instrumentation.name = 'netflow-events'
```

## フローデータアプリケーションマッピング

デフォルトでは、フローテレメトリは、特定のフロー会話で使用されているレイヤー4ポートの評価に基づいて、既知のアプリケーションにマッピングされます。必要に応じて、Dockerの実行時に`-application_map`フラグにYAMLファイルを提供することで、デフォルトのマッピングをオーバーライドできます。これにより、識別したポートに基づいてアプリケーション名を指定できます。

構文例：

```yaml
applications:
  - ports: [9092, 9093]
    name: kafka
  - ports: [80, 8080]
    name: http
  - ports: [443, 8443]
    name: https
```

## フローデータ入力フィルタリング

デフォルトでは、フローデータコンテナは受信したすべてのフローパケットを収集して処理します。必要に応じて、指定したフィルターと一致しないすべてのトラフィックを無視する包含フィルターを`-nf.source`フラグに追加できます。

<CollapserGroup>
  <Collapser
    id="flow-filter-options"
    title="フローフィルターのオプション"
  >
    構文： `--filters $TYPE,$FIELD,$FUNCTION,$MATCH`

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            引数名
          </th>

          <th>
            必須
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            $ TYPE
          </td>

          <td>
            ✓✓
          </td>

          <td>
            適用するフィルターのタイプ。可能な値は、 `string` 、 `int` 、および`addr`です。
          </td>
        </tr>

        <tr>
          <td>
            $ FIELD
          </td>

          <td>
            ✓✓
          </td>

          <td>
            一致パターンを評価するフィールドの名前。
          </td>
        </tr>

        <tr>
          <td>
            $ FUNCTION
          </td>

          <td>
            ✓✓
          </td>

          <td>
            評価中に使用する関数のタイプ。可能な値は`Equal: ==` 、 `NotEqual: !=` 、 `LessThan: <` 、 `GreaterThan: >` 、 `Contains: %`
          </td>
        </tr>

        <tr>
          <td>
            $ MATCH
          </td>

          <td>
            ✓✓
          </td>

          <td>
            一致パターンとして使用される値。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="example-flow-filters"
    title="フィルタの例"
  >
    * `10.0.0.0/24` CIDR範囲の送信元アドレスからのみフローデータを収集します

      ```
      -nf.source sflow --filters addr,src_addr,%,10.10.0.0/24
      ```

    * 宛先ポートがと等しくないフローデータのみを収集します `8531`

      ```
      -nf.source netflow5 --filters int,l4_dst_port,!=,8531
      ```

    * `10.0.0.0/24` CIDR 範囲内の送信元アドレス、かつ宛先ポートが`8531`に等しくない送信元アドレスからのみフロー データを収集します (暗黙的な`AND`演算子)

      ```
      --filters addr,src_addr,%,10.0.0.0/24 --filters int,l4_dst_port,!=,8531
      ```
  </Collapser>
</CollapserGroup>

## カスタム SNMP プロファイルの自動再ロード [#reload-snmp-threads]

デフォルトでは、`ktranslate`docker[ mib_profile_dir](#global) パスの SNMP プロファイルへの変更を組み込むには、 コンテナーを手動で破棄して再構築する必要があります。これは、 dockerイメージがパブリック[snmp-profiles リポジトリ](https://github.com/kentik/snmp-profiles)から利用可能な最新のプロファイルを取得するため、ほとんどの デプロイメント では通常の動作です。 [カスタム プロファイル](/docs/network-performance-monitoring/advanced/snmp-profiles/#private)を提供する場合は、 [watch_profile_changes](#global)設定を使用して、コンテナーがコンテナーの基盤となる構成と SNMP プロファイルを自動的に更新できるようにすることができます。

<Callout variant="important">
  [ウォッチャー ライブラリ](https://github.com/fsnotify/fsnotify?tab=readme-ov-file#are-subdirectories-watched)の制限のため、これは再帰的ではありません。 したがって、サブディレクトリ内のプロファイルが変更された場合は、変更をトリガーするためにトップレベルのファイルも編集する必要があります。
</Callout>

このディレクトリ構造を仮定すると、次のようになります。

```
.
└── /snmp-profiles/
    └── profiles/
        └── kentik-snmp/
            ├── 3com
            ├── _general
            ├── a10networks
            └── ...
```

この更新サイクルをトリガーするには、新しいファイルをディレクトリのルートに配置し、手動で変更する必要があります。 これを実装する簡単な方法は、変更を送信するときに、 `last_updated.txt`などのファイルにタイムスタンプを書き込むだけです。

```
.
└── /snmp-profiles/
    ├── last_updated.txt
    └── profiles/
        └── kentik-snmp/
            ├── 3com
            ├── _general
            ├── a10networks
            └── ...
```
