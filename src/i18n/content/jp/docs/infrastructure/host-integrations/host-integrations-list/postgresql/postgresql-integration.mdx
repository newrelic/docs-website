---
title: PostgreSQLモニタリングの統合
tags:
  - Integrations
  - On-host integrations
  - On-host integrations list
metaDescription: 'New Relic''s PostgreSQL integration: how to install it and configure it, and what data it reports.'
translationType: machine
---

import linux from 'images/linux.png'

import ecs from 'images/ecs.png';

import kubernetes from 'images/kubernetes-k8.png';

import windows from 'images/windows.png';

New Relic PostgreSQL [オンホスト統合](/docs/integrations/host-integrations/getting-started/introduction-host-integrations) は、お使いの PostgreSQL インスタンスから New Relic プラットフォームにインベントリメトリクスを受信・送信し、主要なパフォーマンスメトリクスを集約・可視化することができます。インスタンス、データベース、クラスターからのデータは、問題の原因を見つけるのに役立ちます。

PostgreSQL監視統合をインストールするには、次の手順を実行する必要があります。

1. [インテグレーションの設定](#config)。
2. [インテグレーションのインストールとアクティブ化](#install)。
3. [PostgreSQL のユーザと権限](#create-user).
4. [データの検索と使用](#find-and-use)。
5. 必要に応じて、 [PostgreSQLの構成設定](/docs/infrastructure/host-integrations/host-integrations-list/postgresql/postgresql-config)を参照してください。

<Callout variant="important">
  最善の結果を得るため、[インテグレーションパッケージの更新](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package)と[Infrastructureエージェントの更新](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent)を定期的に実施してください。
</Callout>

## 互換性および要件 [#req]

### PostgreSQLのバージョン [#mysql-versions]

弊社のインテグレーションは、PostgreSQLバージョン9.0以降と互換性があります。

### 対応するオペレーティング・システム [#supported-os]

* Windows

  <img style={{ width: '32px', height: '32px'}} class="inline" title="Windows" alt="Windows" src={windows}/>

* Linux

  <img style={{ width: '32px', height: '32px'}} class="inline" title="Linux" alt="Linux" src={linux}/>

特定のWindowsおよびLinuxバージョンの包括的なリストについては、 [互換性のあるオペレーティングシステム](/docs/infrastructure/install-infrastructure-agent/get-started/requirements-infrastructure-agent/#operating-systems)の表を確認してください。

### システム要件 [#system-reqs]

* New Relicアカウント。アカウントをお持ちでない場合[無料サインアップ](https://newrelic.com/signup)クレジットカードは不要です。

* MySQLがKubernetesまたはAmazon ECSで実行されていない場合、LinuxまたはWindows OSホストに、またはMySQLがインストールされている場所にリモートアクセスできるホストに[Infrastructureエージェントをインストール](/docs/infrastructure/install-infrastructure-agent/get-started/install-infrastructure-agent-new-relic)できます。その他の場合：

  * <img style={{ width: '32px', height: '32px'}} class="inline" title="Kubernetes" alt="Kubernetes" src={kubernetes}>で実行している場合</img>

    Kubernetes、 [これらの要件](/docs/monitor-service-running-kubernetes#requirements)を参照してください。

  * <img style={{ width: '32px', height: '32px'}} class="inline" title="ECS" alt="ECS" src={ecs}>で実行している場合</img>

    Amazon ECS、 [これらの要件](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs)を参照してください。

## インテグレーションの設定 [#config]

統合の設定方法は、インストールした方法によって、いくつかあります。

* <img style={{ width: '32px', height: '32px'}} class="inline" title="Kubernetes" alt="Kubernetes" src={kubernetes}>で有効にした場合</img>

  Kubernetes、[Kubernetesで実行されているサービスを監視するをご覧ください](/docs/monitor-service-running-kubernetes)。

* <img style={{ width: '32px', height: '32px'}} class="inline" title="ECS" alt="ECS" src={ecs}>で有効にした場合</img>

  Amazon ECS 、 [ECSで実行されているサービスを監視する](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs)。

* オンホストでインストールした場合は、統合の YAML 設定ファイル `postgresql-config.yml` で設定を編集してください。統合の YAML 形式の設定は、必要なログイン情報を配置したり、データを収集する方法を設定したりするところです。どのオプションを変更するかは、セットアップと好みによります。設定ファイルには、 `interval`, `timeout`, `inventory_source` など、すべての統合に適用される共通の設定があります。これらの共通設定については、 [Configuration Format](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-newer-configuration-format/#configuration-basics) のドキュメントを参照してください。

<Callout variant="important">
  従来の設定ファイルや定義ファイルをお使いの場合は、 [標準設定フォーマット](/docs/create-integrations/infrastructure-integrations-sdk/specifications/host-integrations-standard-configuration-format/) をご確認ください。
</Callout>

PostgreSQLに関連する特定の設定は、設定ファイルの `env` セクションで定義されます。これらの設定は、他のセキュリティ設定や機能と同様に、PostgreSQLインスタンスへの接続を制御します。有効な設定の一覧は、このドキュメントの次のセクションで説明します。

## インテグレーションのインストールとアクティブ化 [#install]

PostgreSQLとの統合をインストールするには、お使いの環境に応じた手順で行ってください。

### Linuxのインストール [#linux]

1. 手順に従って、 [インフラストラクチャ統合パッケージ](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic) を、ファイル名 `nri-postgresql` を使ってインストールします。

2. を実行して、integrationsのコンフィギュレーション・フォルダーにディレクトリを変更します。

   ```shell
   cd /etc/newrelic-infra/integrations.d
   ```

3. 以下を実行して、サンプルの設定ファイルをコピーします。

   ```shell
   sudo cp postgresql-config.yml.sample postgresql-config.yml
   ```

4. `postgresql-config.yml` 設定ファイルをお好きなエディタで編集してください。 [素晴らしい設定ファイルの例をご覧ください](#examples)。

5. インフラストラクチャエージェントを再起動する前に、 [必要な機能に対する `READ` の権限を持つユーザー](#create-user) を作成します。

6. Infrastructureエージェントを再起動します。[さまざまなLinux環境でInfrastructureエージェントを再起動する](/docs/infrastructure/install-infrastructure-agent/manage-your-agent/start-stop-restart-infrastructure-agent/#linux)方法を参照してください。

### その他の環境 [#other-env]

<CollapserGroup>
  <Collapser
    id="windows-install"
    title={<><img src={windows} title="Windows installation" alt="Windows installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }}/>Windowsへのインストレーション</>}
  >
    1. `nri-postgresql` .MSI インストーライメージをダウンロードします。

       [https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-postgresql/nri-postgresql-amd64.msi](https://download.newrelic.com/infrastructure_agent/windows/integrations/nri-postgresql/nri-postgresql-amd64.msi)

    2. インストールするには、Windowsのコマンドプロンプトで次のコマンドを実行します。

       ```shell
       msiexec.exe /qn /i <var>PATH\TO\</var>nri-postgresql-amd64.msi
       ```

    3. インテグレーションのディレクトリ`C:\Program Files\New Relic\newrelic-infra\integrations.d\`で、以下を実行してサンプル設定ファイルのコピーを作成します。

       ```shell
       cp postgresql-config.yml.sample postgresql-config.yml
       ```

    4. `postgresql-config.yml` ファイルを [postgresql-config.yml サンプルファイル](#examples) の説明に従って編集してください。

    5. [Infrastructureエージェントを再起動します](/docs/infrastructure/new-relic-infrastructure/configuration/start-stop-restart-check-infrastructure-agent-status)。
  </Collapser>

  <Collapser
    id="ecs-install"
    title={<><img src={ecs} title="Amazon ECS installation" alt="Amazon ECS installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }}/>' ' Amazon ECSへのインストレーション</>}
  >
    [ECSで実行しているサービスを監視する](/docs/integrations/host-integrations/host-integrations-list/monitor-services-running-amazon-ecs)をご覧ください。
  </Collapser>

  <Collapser
    id="k8s-install"
    title={<><img src={kubernetes} title="Kubernetes installation" alt="Kubernetes installation" style={{ height: '32px', width: '32px', verticalAlign: 'middle' }}/>Kubernetesへのインストレーション</>}
  >
    [Kubernetesで実行しているサービスを監視する](/docs/monitor-service-running-kubernetes)をご覧ください。
  </Collapser>
</CollapserGroup>

追加の注：

* **アドバンスト：**インテグレーションは[tarball書式](/docs/integrations/host-integrations/installation/install-host-integrations-built-new-relic#tarball)で使用すると、パッケージマネージャ以外にもインストールできます。
* **オンホストインテグレーションは、自動的にアップデートしません。**最善の結果を得るため、[インテグレーションパッケージの更新](/docs/integrations/host-integrations/installation/update-infrastructure-host-integration-package)と[Infrastructureエージェントの更新](/docs/infrastructure/new-relic-infrastructure/installation/update-infrastructure-agent)を定期的に実施してください。

## PostgreSQLのユーザーとパーミッション [#create-user]

`SELECT` のパーミッションを持つユーザーを作成します。

* `pg_stat_database`
* `pg_stat_database_conflicts`
* `pg_stat_bgwriter`

このステップは、 [`postgresql-config.yml` ファイル](#examples) を構成する前でも後でも完了できます。PostgreSQL統合のためのユーザを作成する。

```
CREATE USER new_relic WITH PASSWORD '<var>PASSWORD</var>';
GRANT SELECT ON pg_stat_database TO new_relic;
GRANT SELECT ON pg_stat_database_conflicts TO new_relic;
GRANT SELECT ON pg_stat_bgwriter TO new_relic;
```

これにより、PostgreSQLインスタンスに関連するグローバルメトリクスを収集することができます。

テーブルやインデックスに関連するメトリクス（例えば、テーブルサイズやインデックスサイズ）も取得したい場合、統合で使用するPostgreSQLロール（`new_relic` ）は、メトリクスを収集するテーブルに対して、 `SELECT` の権限も必要です。例えば、データベース（パブリック `スキーマ` ）に存在するすべてのテーブルとインデックスからメトリクスを収集することを統合機能に許可するには、次のように使用します。

```
GRANT SELECT ON ALL TABLES IN SCHEMA public TO new_relic;
```

PostgreSQLカスタムクエリ構成ファイルからクエリレベルのメトリックも取得する場合は、統合で使用されるPostgreSQLロール（ `new_relic` ）を（ `pg_read_all_stats` ）ロールに追加する必要があります。これは、ユーザーが（ `pg_stat_statements` ）拡張機能を利用しているためです。

```
GRANT pg_read_all_stats TO new_relic;
```

`pg_stat_statements`拡張機能を有効にするには、クエリプロンプトから手動で作成する必要がある場合があります。

```
CREATE EXTENSION pg_stat_statements;
```

### postgresql-config.yml サンプルファイル [#examples]

<CollapserGroup>
  <Collapser
    id="example-postgresSQL-collection-config"
    title="PostgreSQL設定収集ファイル"
  >
    * JSONの配列。データベースに属するテーブルやインデックスを含む、関連するすべてのメトリクスを収集するためのデータベース名のリストと解釈されます。

      たとえば、

      ```yml
      collection_list: '["postgres"]'
      ```

    * JSON オブジェクト：オブジェクトで指定されたエンティティのみが収集され、自動検出は行われません。JSONのレベルは、 `データベース名 -> スキーマ名 -> テーブル名 -> インデックス名`.

      たとえば、

      ```yml
      collection_list: '{"postgres":{"public":{"pg_table1":["pg_index1","pg_index2"],"pg_table2":[]}}}'
      ```

    * `ALL`: 検出されたすべてのデータベース、スキーマ、テーブル、およびインデックスのメトリクスを収集します。

      たとえば、

      ```yml
      collection_list: 'ALL'
      ```

      ```yml
      integrations:
        - name: nri-postgresql
          env:
            USERNAME: postgres
            PASSWORD: pass
            HOSTNAME: psql-sample.localnet
            PORT: 6432
            DATABASE: postgres

            COLLECT_DB_LOCK_METRICS: false
            COLLECTION_LIST: '{"postgres":{"public":{"pg_table1":["pg_index1","pg_index2"],"pg_table2":[]}}}'
            TIMEOUT:  10
          interval: 15s
          labels:
            env: production
            role: postgresql
          inventory_source: config/postgresql
      ```
  </Collapser>

  <Collapser
    id="example-postgresSQL-SSL-config"
    title="PostgreSQL SSL設定収集ファイル"
  >
    ```yml
    integrations:
      - name: nri-postgresql
        env:
          USERNAME: postgres
          PASSWORD: pass
          HOSTNAME: psql-sample.localnet
          PORT: 6432
          DATABASE: postgres

          COLLECT_DB_LOCK_METRICS: false
          COLLECTION_LIST: '["postgres"]'
          ENABLE_SSL: true
          TRUST_SERVER_CERTIFICATE: false
          SSL_ROOT_CERT_LOCATION: /etc/newrelic-infra/root_cert.crt
          SSL_CERT_LOCATION: /etc/newrelic-infra/postgresql.crt
          SSL_KEY_LOCATION: /etc/newrelic-infra/postgresql.key
          TIMEOUT:  10
        interval: 15s
        labels:
          env: production
          role: postgresql
        inventory_source: config/postgresql
    ```
  </Collapser>

  <Collapser
    id="example-postgresSQL-custom-query-config"
    title="PostgreSQLカスタムクエリ"
  >
    ```yml
    integrations:
      - name: nri-postgresql
        env:
          USERNAME: postgres
          PASSWORD: pass
          HOSTNAME: psql-sample.localnet
          PORT: 6432
          DATABASE: postgres

          COLLECT_DB_LOCK_METRICS: false
          COLLECTION_LIST: ALL
          CUSTOM_METRICS_QUERY: >-
            select
              'rows_inserted' as "metric_name",
              'delta' as "metric_type",
              sd.tup_inserted as "metric_value",
              sd.datid as "database_id"
              from pg_stat_database sd;
          TIMEOUT:  10
        interval: 15s
        labels:
          env: production
          role: postgresql
        inventory_source: config/postgresql
    ```
  </Collapser>

  <Collapser
    id="example-postgresSQL-custom-query-config-file"
    title="PostgreSQLカスタムクエリ設定ファイル"
  >
    1つまたは複数のカスタムSQLを含む追加のYAML構成ファイルを定義することができ、統合はCUSTOM_METRICS_CONFIGパラメータでファイルへのパスを必要とします。

    * postgresql-config.yml

      ```yml
      integrations:
        - name: nri-postgresql
          env:
            USERNAME: postgres
            PASSWORD: pass
            HOSTNAME: psql-sample.localnet
            PORT: 6432
            DATABASE: postgres

            COLLECT_DB_LOCK_METRICS: false
            COLLECTION_LIST: ALL
            CUSTOM_METRICS_CONFIG: "path/to/postgresql-custom-query.yml"
            TIMEOUT:  10
          interval: 15s
          labels:
            env: production
            role: postgresql
          inventory_source: config/postgresql
      ```

    * postgresql-custom-query.yml

      ```yml
      ---
      queries:

        # Metric names are set to the column names in the query results
        - query: >-
            SELECT
            BG.checkpoints_timed AS scheduled_checkpoints_performed,
            BG.checkpoints_req AS requested_checkpoints_performed,
            BG.buffers_checkpoint AS buffers_written_during_checkpoint,
            BG.buffers_clean AS buffers_written_by_background_writer,
            BG.maxwritten_clean AS background_writer_stops,
            BG.buffers_backend AS buffers_written_by_backend,
            BG.buffers_alloc AS buffers_allocated
            FROM pg_stat_bgwriter BG;

          # database defaults to the auth database in the main config
          database: new_frontier_config_dev

          # If not set explicitly here, metric type will default to
          # 'gauge' for numbers and 'attribute' for strings
          metric_types:
            buffers_allocated: rate

          # If unset, sample_name defaults to PostgresqlCustomSample
          sample_name: MyCustomSample
      ```
  </Collapser>
</CollapserGroup>

オンホストインテグレーション設定の一般的な構成の詳細については、[設定](/docs/integrations/integrations-sdk/file-specifications/host-integration-configuration-overview)を参照してください。

## 統合のための構成オプション [#config-options]

データを検索して使用する方法の詳細については、 [PostgreSQLの構成設定](/docs/infrastructure/host-integrations/host-integrations-list/postgresql/postgresql-config)を参照してください。

## データの検索と使用 [#find-and-use]

このサービスからのデータは、[インテグレーションダッシュボード](/docs/integrations/new-relic-integrations/getting-started/infrastructure-integration-dashboards-charts)にレポートされます。

メトリクスは、これらの [イベントタイプ](/docs/using-new-relic/data/understand-data/new-relic-data-types#events-new-relic) に付けられています。

* [PostgresqlDatabaseSampleのメトリクス](#databaseSample)
* [PostgresqlIndexSampleメトリクス](#indexSample)
* [PostgresqlInstanceSampleメトリクス](#instanceSample)
* [PostgresqlTableSampleメトリクス](#tableSample)
* [PgBouncerSampleメトリクス](#pgBouncerSample)

トラブルシューティング目的で、またはカスタムのチャートとダッシュボードを作成するために、[このデータのクエリ](/docs/using-new-relic/data/understand-data/query-new-relic-data)を行えます。

データを検索して使用する方法の詳細については、[統合データを理解する](/docs/infrastructure/integrations/find-use-infrastructure-integration-data)方法を参照してください。

## 統合によって収集されたメトリック [#metrics]

PostgreSQL統合は、次のメトリックを収集します。一部のメトリック名には、 `db.`または`index.` 。

<CollapserGroup>
  <Collapser
    id="databaseSample"
    title="PostgresqlDatabaseSampleのメトリクス"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgreSQLDatabaseSampleの属性
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `db.connection`
          </td>

          <td>
            このデータベースに現在接続されているバックエンドの数。
          </td>
        </tr>

        <tr>
          <td>
            `db.maxconnections`
          </td>

          <td>
            データベースサーバーへの最大同時接続数です。
          </td>
        </tr>

        <tr>
          <td>
            `db.commitsPerSecond`
          </td>

          <td>
            コミットされたトランザクション/秒。
          </td>
        </tr>

        <tr>
          <td>
            `db.rollbacksPerSecond`
          </td>

          <td>
            1秒間にロールバックされるトランザクション数
          </td>
        </tr>

        <tr>
          <td>
            `db.ReadsPerSecond`
          </td>

          <td>
            このデータベースで1秒間に読み込まれたディスクブロック数。
          </td>
        </tr>

        <tr>
          <td>
            `db.bufferHitsPerSecond`
          </td>

          <td>
            ディスクブロックがバッファキャッシュ内に既に存在し、読み取りが不要であった回数です。これは、オペレーティングシステムのファイルシステムキャッシュではなく、PostgreSQLのバッファキャッシュでのヒットのみを含みます。
          </td>
        </tr>

        <tr>
          <td>
            `db.RowsReturnedPerSecond`
          </td>

          <td>
            1秒あたりのクエリで返される行数。
          </td>
        </tr>

        <tr>
          <td>
            `db.RowsFetchedPerSecond`
          </td>

          <td>
            1秒間にクエリで取得された行数。
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsInsertedPerSecond`
          </td>

          <td>
            1秒間に挿入される行数。
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsUpdatedPerSecond`
          </td>

          <td>
            1秒間に更新される行数。
          </td>
        </tr>

        <tr>
          <td>
            `db.rowsDeletedPerSecond`
          </td>

          <td>
            1秒間に削除される行数。
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.tablespacePerSecond`
          </td>

          <td>
            このデータベースで、ドロップされたテーブルスペースのためにキャンセルされたクエリの数。
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.locksPerSecond`
          </td>

          <td>
            このデータベースで、ロックのタイムアウトによりキャンセルされたクエリの数。
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.snapshotPerSecond`
          </td>

          <td>
            古いスナップショットのためにキャンセルされた、このデータベースのクエリの数。
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.bufferpinPerSecond`
          </td>

          <td>
            このデータベースで、バッファが固定されているためにキャンセルされたクエリの数。
          </td>
        </tr>

        <tr>
          <td>
            `db.conflicts.deadlockPerSecond`
          </td>

          <td>
            このデータベースでデッドロックのためにキャンセルされたクエリの数。
          </td>
        </tr>

        <tr>
          <td>
            `db.temppFilesCreatedPerSecond`
          </td>

          <td>
            このデータベースのクエリによって作成された一時ファイルの数。一時ファイルが作成された理由（ソートやハッシュ化など）や、 `log_temp_files` の設定に関わらず、すべての一時ファイルがカウントされます。
          </td>
        </tr>

        <tr>
          <td>
            `db.tempWrittenInBytesPerSecond`
          </td>

          <td>
            このデータベースのクエリによって一時ファイルに書き込まれたデータの総量。一時ファイルが作成された理由や、 `log_temp_files` の設定にかかわらず、すべての一時ファイルがカウントされます。
          </td>
        </tr>

        <tr>
          <td>
            `db.deadlocksPerSecond`
          </td>

          <td>
            このデータベースで検出されたデッドロックの数。
          </td>
        </tr>

        <tr>
          <td>
            `db.readTimeInMillisecondsPerSecond`
          </td>

          <td>
            このデータベースのバックエンドがデータファイルのブロックを読み込むのにかかった時間（単位：ミリ秒）。
          </td>
        </tr>

        <tr>
          <td>
            `db.writeTimeInMillisecondsPerSecond`
          </td>

          <td>
            このデータベースのバックエンドによるデータファイルブロックの書き込みにかかった時間（単位：ミリ秒）。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="indexSample"
    title="PostgresqlIndexSampleメトリクス"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgreSQLIndexSampleの属性
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `index.sizeInBytes`
          </td>

          <td>
            インデックスのサイズです。
          </td>
        </tr>

        <tr>
          <td>
            `index.rowsReadPerSecond`
          </td>

          <td>
            このインデックスに対するスキャンによって返されたインデックス・エントリの数です。
          </td>
        </tr>

        <tr>
          <td>
            `index.rowsFetchedPerSecond`
          </td>

          <td>
            このインデックスに対するスキャンによってフェッチされたインデックスエントリの数。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="instanceSample"
    title="PostgresqlInstanceSampleメトリクス"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgreSQLInstanceSample属性
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `bgwriter.checkpointsScheduledPerSecond`
          </td>

          <td>
            実行されたスケジュールされたチェックポイントの数。
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.checkpointsRequestedPerSecond`
          </td>

          <td>
            要求されたチェックポイントが実行された数。
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersWrittenForCheckpointsPerSecond`
          </td>

          <td>
            チェックポイント中に書き込まれたバッファの数。
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersWrittenByBackgroundWriterPerSecond`
          </td>

          <td>
            バックグラウンドライターで書き込まれたバッファの数。
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.backgroundWriterStopsPerSecond`
          </td>

          <td>
            バッファの書き込みが多すぎたために、バックグラウンドライターがクリーニングスキャンを停止した回数。
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersWrittenByBackendPerSecond`
          </td>

          <td>
            バックエンドが直接書き込んだバッファの数。
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.buffersAllocatedPerSecond`
          </td>

          <td>
            割り当てられたバッファの数。
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.backendFsyncCallsPerSecond`
          </td>

          <td>
            バックエンドが独自に `fsync` 呼び出しを実行しなければならなかった回数。通常は、バックエンドが独自の書き込みを行っても、バックグラウンドのライターが処理します。
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.checkpointWriteTimeInMillisecondsPerSecond`
          </td>

          <td>
            チェックポイント処理のうち、ファイルをディスクに書き込む処理にかかった時間の合計（単位：ミリ秒）。
          </td>
        </tr>

        <tr>
          <td>
            `bgwriter.checkpointSyncTimeInMillisecondsPerSecond`
          </td>

          <td>
            チェックポイント処理のうち、ファイルをディスクに同期させる処理にかかった時間の合計（単位：ミリ秒）。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="tableSample"
    title="PostgresqlTableSampleメトリクス"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PostgreSQLTableSampleの属性
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `table.totalSizeInBytes`
          </td>

          <td>
            インデックスとTOASTデータを含む、テーブルが使用する総ディスク容量。
          </td>
        </tr>

        <tr>
          <td>
            `table.indexSizeInBytes`
          </td>

          <td>
            指定されたテーブルにアタッチされたインデックスが使用するディスク容量の合計です。
          </td>
        </tr>

        <tr>
          <td>
            `table.liveRows`
          </td>

          <td>
            ライブの列数
          </td>
        </tr>

        <tr>
          <td>
            `table.deadRows`
          </td>

          <td>
            デッドローの数
          </td>
        </tr>

        <tr>
          <td>
            `table.indexBlocksReadPerSecond`
          </td>

          <td>
            このテーブルのすべてのインデックスから読み込まれたディスクブロックの数です。
          </td>
        </tr>

        <tr>
          <td>
            `table.indexBlocksHitPerSecond`
          </td>

          <td>
            このテーブルのすべてのインデックスにおけるバッファヒットの数。
          </td>
        </tr>

        <tr>
          <td>
            `table.indexToastBlocksReadPerSecond`
          </td>

          <td>
            このテーブルのTOASTテーブルインデックスから読み込まれたディスクブロックの数。
          </td>
        </tr>

        <tr>
          <td>
            `table.indexToastBlocksHitPerSecond`
          </td>

          <td>
            このテーブルのTOASTテーブルインデックスのバッファヒットの数。
          </td>
        </tr>

        <tr>
          <td>
            `Table.LastVacuum`
          </td>

          <td>
            テーブルに最後の真空をかけた時間
          </td>
        </tr>

        <tr>
          <td>
            `table.lastAutoVacuum`
          </td>

          <td>
            テーブルに最後に自動バキュームをかけた時間
          </td>
        </tr>

        <tr>
          <td>
            `table.lastAnalyze`
          </td>

          <td>
            テーブル上での最後の分析の時間。
          </td>
        </tr>

        <tr>
          <td>
            `table.lastAutoAnalyze`
          </td>

          <td>
            最後に自動分析を行った時間
          </td>
        </tr>

        <tr>
          <td>
            `table.sequentialScansPerSecond`
          </td>

          <td>
            このテーブルに対して1秒あたりに実行されるシーケンシャルスキャンの数。
          </td>
        </tr>

        <tr>
          <td>
            `table.secensialScanRowsFetchedPerSecond`
          </td>

          <td>
            シーケンシャルスキャンによって1秒あたりに取得されたライブ行の数。
          </td>
        </tr>

        <tr>
          <td>
            `table.indexScansPerSecond`
          </td>

          <td>
            このテーブルで行われたインデックススキャンの数。
          </td>
        </tr>

        <tr>
          <td>
            `table.indexScanRowsFetchedPerSecon`
          </td>

          <td>
            インデックススキャンによって取得されたライブ行の数。
          </td>
        </tr>

        <tr>
          <td>
            `table.rowsInsertedPerSecond`
          </td>

          <td>
            1秒間に挿入される行数。
          </td>
        </tr>

        <tr>
          <td>
            `table.rowsUpdatedPerSecond`
          </td>

          <td>
            1秒間に更新される行数。
          </td>
        </tr>

        <tr>
          <td>
            `table.rowsDeletedPerSecond`
          </td>

          <td>
            1秒間に削除される行数。
          </td>
        </tr>

        <tr>
          <td>
            `Table.bloatSizeInBytes`
          </td>

          <td>
            ブルートのサイズ（バイト）。
          </td>
        </tr>

        <tr>
          <td>
            `table.dataSizeInBytes`
          </td>

          <td>
            テーブルのメインフォークが使用するディスクの間隔のサイズ。
          </td>
        </tr>

        <tr>
          <td>
            `table.bloatRatio`
          </td>

          <td>
            テーブルのデータサイズのうち、肥大化している部分の割合。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="pgBouncerSample"
    title="PgBouncerSampleメトリクス"
  >
    <table>
      <thead>
        <tr>
          <th style={{ width: "350px" }}>
            PgBouncerSampleの属性
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `pgbouncer.stats.trampsampsPerSecond`
          </td>

          <td>
            取引レートです。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.questionsPerSecond`
          </td>

          <td>
            クエリーレートです。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.bytesInPerSecond`
          </td>

          <td>
            受信したネットワークトラフィックの総量です。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.bytesOutPerSecond`
          </td>

          <td>
            送信されたネットワークトラフィックの総量です。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.toutalTransactionDurationInMillisecondsPerSecond`
          </td>

          <td>
            `pgbouncer` がトランザクションに費やした時間。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.totalQueryDurationInMillisecondsPerSecond`
          </td>

          <td>
            `pgbouncer` が積極的にPostgreSQLを照会するのに費やした時間。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgTransactionCount`
          </td>

          <td>
            直近の統計期間における1秒あたりの平均トランザクション数。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgTransactionDurationInMilliseconds`
          </td>

          <td>
            トランザクションの平均時間です。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgQueryCount`
          </td>

          <td>
            直近の統計期間における、1秒あたりの平均クエリ数。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgBytesIn`
          </td>

          <td>
            受信したクライアントのネットワークトラフィックを
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgBytesOut`
          </td>

          <td>
            送信されたクライアントのネットワークトラフィック。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.stats.avgQueryDurationInMilliseconds`
          </td>

          <td>
            クエリの平均時間です。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsActive`
          </td>

          <td>
            クライアントの接続は、サーバーの接続にリンクされ、クエリを処理することができます。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.clientConnectionsWaiting`
          </td>

          <td>
            クライアントの接続がサーバーの接続を待っている状態。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsActive`
          </td>

          <td>
            クライアント接続にリンクされたサーバー接続。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsIdle`
          </td>

          <td>
            サーバー接続はアイドル状態で、クライアントからの問い合わせに対応しています。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsUsed`
          </td>

          <td>
            サーバー接続のアイドルは、 `server_check_delay` 以上で、 `server_check_query` が必要です。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsTested`
          </td>

          <td>
            現在実行中のサーバー接続は、 `server_reset_query` または `server_check_query` のいずれかです。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.serverConnectionsLogin`
          </td>

          <td>
            現在ログイン処理中のサーバー接続。
          </td>
        </tr>

        <tr>
          <td>
            `pgbouncer.pools.maxwaitInMilliseconds`
          </td>

          <td>
            最も古い未サービスのクライアント接続の年齢。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>