---
title: Lambdaモニタリング用の従来の手動インストゥルメンテーション
metaDescription: Legacy instructions for manually enabling New Relic monitoring for Amazon AWS Lambda.
translationType: machine
---

このページでは、ラムダ関数を手動で計測する方法を紹介します。ランタイム言語別にまとめています。

<CollapserGroup>
  <Collapser
    id="go"
    title="Go"
  >
    Go-language Lambdaをインストゥルメントするには、以下の手順に従います。

    1. Goエージェントパッケージをダウンロードし、関数と同じディレクトリに置きます。

    2. エージェントをインストール：`go get -u github.com/newrelic/go-agent/v3/newrelic`を呼び出します。

    3. nrlambdaインテグレーション`go get -u github.com/newrelic/go-agent/v3/integrations/nrlambda`をインストールします。

    4. あなたのLambdaコードで、私たちのコンポーネントをインポートし、アプリケーションを作成し、Lambdaの起動方法を更新してください。インストゥルメンテーションの例をご覧ください。

       * [エクステンション・レポ](https://github.com/newrelic/newrelic-lambda-extension/tree/main/examples/sam/go)
       * [エージェントのレポを見る](https://github.com/newrelic/go-agent/blob/master/v3/integrations/nrlambda/example/main.go)

    5. オプション：[](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#custom-event)RecordCustomEvent[ API`を使用して、Lambdaの呼び出しに関連付けられる`カスタムイベント](/docs/agents/go-agent/features/create-custom-events-insights-go)を追加します。例：

       ```go
       func handler(ctx context.Context) {
         if txn := newrelic.FromContext(ctx); nil != txn {
           txn.Application().RecordCustomEvent("MyEvent", map[string]interface{}{
             "zip": "zap",
           })
         }
         fmt.Println("hello world!")
       }
       ```

    6. Lambda関数を構築して圧縮し、AWSにアップロードします。

    <CollapserGroup>
      <Collapser
        id="zip-upload"
        title="圧縮とアップロートについての推奨"
      >
        Lambdaの圧縮とアップロードについての推奨は、次のとおりです。

        1. Linuxで実行するバイナリを構築します。これにより、`main`と呼ばれるバイナリファイルが作成されます。次のものを使用できます。

           ```bash
           GOOS=linux go build -o main
           ```

        2. 次のものを使用して、バイナリをデプロイメントパッケージに圧縮します。

           ```bash
           zip deployment.zip main
           ```

        3. AWS LambdaコンソールまたはAWS CLIのいずれかを使用して、zipファイルをAWSにアップロードします。（バイナリ構築中に付けられた名前と同じにするため）ハンドラーの名前を`main`にします。
      </Collapser>
    </CollapserGroup>

    6. 次の環境変数はLambdaをモニターする機能には不要ですが、Lambda機能をディストリビューティッド（分散）トレーシングに含める場合は必要です。[ディストリビューティッド（分散）トレーシング](/docs/apm/distributed-tracing/getting-started/introduction-distributed-tracing)を有効にするには、AWSコンソールで以下の[環境変数](https://docs.aws.amazon.com/amplify/latest/userguide/environment-variables.html)を設定します。

       * `NEW_RELIC_ACCOUNT_ID`。[アカウントID](/docs/accounts/install-new-relic/account-setup/account-id)。
       * `NEW_RELIC_TRUSTED_ACCOUNT_KEY。`これは、[アカウントID](/docs/accounts/install-new-relic/account-setup/account-id)でもあります。アカウントが子アカウントの場合、これはroot/親アカウントのアカウントIDです。

    7. オプション：ログ作成を設定するには、[Go agentのログ作成](/docs/agents/go-agent/configuration/go-agent-logging)を参照してください。

    8. 少なくとも1回Lambdaを呼び出します。これにより、CloudWatchロググループが作成されます。次のステップではこのグループが必要です。

       ラッパーはLambda実行についてのデータを収集し、JSONメッセージを生成し、CloudWatchログにログ記録します。次に、[CloudWatchを設定してそのログをNew Relicに送信します](/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/instrument-your-own/#manual-stream-logs)。
  </Collapser>

  <Collapser
    id="java"
    title="Java"
  >
    JavaでのAWS Lambdaのモニタリングでは、[APM Javaエージェント](/docs/agents/java-agent)は使用しません。代わりに、次の2つのOpenTracing依存関係を使用します。

    * AWS Lambda OpenTracing Java SDK：AWS Lambda RequestHandlerおよびRequestStreamHandlerの[OpenTracing](https://github.com/opentracing)インストゥルメンテーション。

    * 当社のAWS Lambda OpenTracing Tracer：OpenTracing Tracerの実装は、AWS Lambdaをモニターするように設計されています。スパン、エラーイベント、トランザクションイベント、エラートレースを生成し、ディストリビューティッド（分散）トレーシングをサポートします。

      <Callout variant="tip">
        **サポート対象の OpenTracing バージョン**

        * **OpenTracing 0.31.0**:

          * Lambda Tracer：[com.newrelic.opentracing:newrelic-java-lambda:1.1.1](https://search.maven.org/artifact/com.newrelic.opentracing/newrelic-java-lambda/1.1.1/jar)
          * Lambda SDK：[com.newrelic.opentracing:java-aws-lambda:1.0.0](https://search.maven.org/artifact/com.newrelic.opentracing/java-aws-lambda/1.0.0/jar)

        * **OpenTracing 0.32.0、0.33.0**：

          * ラムダトレーサー： [com.newrelic.opentracing:newrelic-java-lambda:2.2.1](https://search.maven.org/artifact/com.newrelic.opentracing/newrelic-java-lambda)
          * Lambda SDK：[com.newrelic.opentracing:java-aws-lambda:1.0.0](https://search.maven.org/artifact/com.newrelic.opentracing/java-aws-lambda)
      </Callout>

      Java Lambdaをインストゥルメントするには、以下の手順に従います。

    1. プロジェクトの`build.gradle`ファイルに、OpenTracing AWS Lambda TracerとAWS Lambda OpenTracing SDKの依存関係を含めます。

       ```java
       dependencies {
           compile("com.newrelic.opentracing:java-aws-lambda:2.1.0")
           compile("com.newrelic.opentracing:newrelic-java-lambda:2.2.1")
           compile("io.opentracing:opentracing-util:0.33.0")
       }
       ```

    2. `Java Lambdaの例`に示されたようにAWS Lambda [RequestHandler](https://github.com/newrelic/newrelic-lambda-tracer-java#usage)インタフェースを実装し、`doHandleRequest`メソッドを上書きします。

    3. `doHandleRequest`メソッドで、`LambdaTracing.instrument(...)` APIを呼び出して、lambda関数の実行をトレースするrootスパンを作成します。ここでは、Lambda関数のビジネスロジックも定義します。

    4. `Java Lambdaの例`に示されたように、[LambdaTracer.INSTANCE](https://github.com/newrelic/newrelic-lambda-tracer-java#usage)をOpenTracing Globalトレーサーとして登録します。

    5. [ZIPデプロイメントパッケージを作成](https://docs.aws.amazon.com/lambda/latest/dg/java-package.html)し、AWS Lambdaにアップロードします。または、その他の方法でディプロイします。

    6. AWS Lambdaコンソールで、ハンドラーを設定します。[Java Lambda例](https://github.com/newrelic/newrelic-lambda-tracer-java#usage)の場合は、ハンドラーは`com.handler.example.MyLambdaHandler::handleRequest`となります。`handleRequest`が前提となっているため、`com.handler.example.MyLambdaHandler`も使用できます。

    7. 以下の [AWSコンソール環境変数](https://docs.aws.amazon.com/amplify/latest/userguide/environment-variables.html)は、Lambda関数を[ディストリビューティッド（分散）トレーシング](/docs/apm/distributed-tracing/getting-started/introduction-distributed-tracing)に含める場合は必要です。これが推奨されます。

       * `NEW_RELIC_ACCOUNT_ID`。[アカウントID](/docs/accounts/install-new-relic/account-setup/account-id)。
       * `NEW_RELIC_PRIMARY_APPLICATION_ID`。これは、お客様の[アカウントID](/docs/accounts/install-new-relic/account-setup/account-id)でもあります。
       * `NEW_RELIC_TRUSTED_ACCOUNT_KEY`。これは、[アカウントID](/docs/accounts/install-new-relic/account-setup/account-id)でもあります。アカウントが子アカウントの場合、これはroot/親アカウントのアカウントIDである必要があります。

    8. オプション：Lambdaコンソールで、この環境変数を追加してデバッグロギングを有効にします。`NEW_RELIC_DEBUG`は`true`です。

    9. 少なくとも1回Lambdaを呼び出します。これにより、CloudWatchロググループが作成されます。次のステップではこのグループが必要です。

       ラッパーはLambda実行についてのデータを収集し、JSONメッセージを生成し、CloudWatchログにログ記録します。次に、[CloudWatchを設定してそのログをNew Relicに送信します](/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/instrument-your-own/#manual-stream-logs)。

       以下のような、一般的な使用例を示す完全なプロジェクトの[AWS Lambdaディストリビューティッド（分散）トレーシングの例](https://github.com/newrelic/newrelic-lambda-tracer-java/tree/main/examples/distributed-tracing-example)を参照してください。

    * Lambda関数間のディストリビューティッド（分散）トレーシング
    * 手作業でのスパン作成（別名カスタムインストゥルメンテーション）
    * 外部コールのトレース
    * カスタムアトリビュート（別名タグ）のスパンへの追加
  </Collapser>

  <Collapser
    id="net-core"
    title=".NET Core"
  >
    .NET CoreベースのAWS Lambda関数のモニタリングでは、標準[.NET Core APMエージェント](/docs/agents/net-agent/installation/compatibility-requirements-net-core-agent)は使用しません。代わりに、NuGetパッケージを使用します。

    .NET Core Lambdaをインストゥルメントするには、以下の手順に従います。

    1. Lambda関数プロジェクトに、`NewRelic.OpenTracing.AmazonLambda.Tracer NuGet`パッケージをインストールします。

       注：`NewRelic.OpenTracing.AmazonLambda.Tracer`は、`Amazon.Lambda.APIGatewayEvent` NuGet パッケージのバージョン1.2.0 以降によって異なります。環境がすでに下位バージョンの`Amazon.Lambda.APIGatewayEvent`を使用している場合、New Relicパッケージは`System.MissingMethodException`などのエラーを生成する可能性があります。

    2. NuGetパッケージとOpenTracingユーティリティをインポートします。

       ```cs
       using OpenTracing.Util;
       using NewRelic.OpenTracing.AmazonLambda;
       ```

    3. この例で示されたように、機能を以下のようにインストゥルメントします。

    ```cs
    public class Function
    {
      static Function()
      {
        // Register The NewRelic Lambda Tracer Instance
        GlobalTracer.Register(NewRelic.OpenTracing.AmazonLambda.LambdaTracer.Instance);
      }

      public object FunctionWrapper(ILambdaContext context)
      {
        // Instantiate NewRelic TracingWrapper and pass your FunctionHandler as
        // an argument
        return new TracingRequestHandler().LambdaWrapper(FunctionHandler, context);
      }

      /// <summary>
      /// A simple function that takes a string and does a ToUpper
      /// </summary>
      /// <param name="input"></param>
      /// <param name="context"></param>
      /// <returns></returns>
      public object FunctionHandler(ILambdaContext context)
      { ... }
  
    }
    ```

    <Callout variant="tip">
      `FunctionWrapper`に渡される引数は、`FunctionHandler`の署名と一致する必要があります。
    </Callout>

    ハンドラー関数がタスクを返す場合、Lambdaラッパーは返されたタスクが完了するまでブロックします。そのため、持続時間を計測でき、例外がある場合それを把握できます。また、`APIGatewayProxyFunction`から継承することもできます。

    例については、以下を参照してください。

    <CollapserGroup>
      <Collapser
        id="net-handler-returns-task-example"
        title="非同期ハンドラー関数"
      >
        ```cs
        public async Task<int> FunctionHandlerAsync(ILambdaContext lambdaContext)
        {
          return await new TracingRequestHandler().LambdaWrapper(
                                ActualFunctionHandlerAsync, lambdaContext);
        }

        public async Task<APIGatewayProxyResponse> ActualFunctionHandlerAsync(ILambdaContext
        lambdaContext)
        { 
          // Function can make other async operations here
          ...
        }

        ```
      </Collapser>

      <Collapser
        id="net-handler-inherit-apigatewayproxyfunction"
        title="APIGatewayProxyFunctionからの継承"
      >
        ```cs
        public class LambdaFunction : APIGatewayProxyFunction
        {
          static LambdaFunction()
          {
            // Register The NewRelic Lambda Tracer Instance
            OpenTracing.Util.GlobalTracer.Register(NewRelic.OpenTracing.AmazonLambda.LambdaTracer.Instance);
          }

          public override Task<APIGatewayProxyResponse> FunctionHandlerAsync(APIGatewayProxyRequest request, ILambdaContext lambdaContext)
          {
            Task<APIGatewayProxyResponse> task = new TracingRequestHandler().LambdaWrapper(ActualFunctionHandlerAsync, request, lambdaContext);
            return task;
          }

          public Task<APIGatewayProxyResponse> ActualFunctionHandlerAsync(APIGatewayProxyRequest request, ILambdaContext lambdaContext)
          {
            return base.FunctionHandlerAsync(request, lambdaContext);
          }
        }
        ```
      </Collapser>
    </CollapserGroup>

    4. SQSおよびSNSのオプション：.NET Lambda Tracerのバージョン1.0以降、[ディストリビューティッド（分散）トレーシング](/docs/apm/distributed-tracing/getting-started/introduction-distributed-tracing)のサポートがSQSとSNSについて追加されています。SQSまたはSNSにおいてディストリビューティッド（分散）トレーシングを有効にするには、このステップの項目を完了させるとともに、これに続くステップにおいて環境変数を設定する必要があります。

       <Callout variant="important">
         SQSおよびSNSにおいてディストリビューティッド（分散）トレーシングのサポートを有効にすると、SQSとSNSの両方において自動インストゥルメンテーションが無効になり、それらのインストゥルメントに向けてこれらのwrapperの使用が要求されることになります。
       </Callout>

       1. `NEW_RELIC_USE_DT_WRAPPER`環境変数を`true`に設定します。
       2. SQSおよびSNSコールをインストゥルメントするには、規定のwrapperを使用する必要があります。

    <CollapserGroup>
      <Collapser
        id="net-dt-sqs"
        title="SQS Wrapperの使用"
      >
        SQS wrapperは、以下の手法のラッピングをサポートしています。

        * Amazon.SQS.AmazonSQSClient.SendMessageAsync(...)
        * Amazon.SQS.AmazonSQSClient.SendMessageBatchAsync(...)

        例

        ```cs
  
        // SQS Client
        AmazonSQSClient client = new AmazonSQSClient("<var>AWS_SECRET_ACCESS_KEY</var>", <var>AWS_REGION</var>);

        // SendMessageRequest
        SendMessageRequest sendRequest = new SendMessageRequest("<var>QUEUE_URI_STRING</var>", "An SQS Message");
        Task<SendMessageResponse> responseOne = SQSWrapper.WrapRequest(client.SendMessageAsync, sendRequest);

        // String-based
        Task<SendMessageResponse> responseTwo = SQSWrapper.WrapRequest(client.SendMessageAsync, "<var>QUEUE_URI_STRING</var>", "Another SQS Message");

        // SendMessageBatchRequest
        List<SendMessageBatchRequestEntry> batchEntries = new List<SendMessageBatchRequestEntry>();
        batchEntries.Add(new SendMessageBatchRequestEntry("id1", "First SQS Message"));
        batchEntries.Add(new SendMessageBatchRequestEntry("id2", "Second SQS Message"));
        batchEntries.Add(new SendMessageBatchRequestEntry("id3", "Third SQS Message"));
        SendMessageBatchRequest sendBatchRequest = new SendMessageBatchRequest(<var>QUEUE_URI</var>, batchEntries);
        Task<SendMessageBatchResponse> response = SQSWrapper.WrapRequest(client.SendMessageBatchAsync, sendBatchRequest);

        // SendMessageBatchRequestEntry List
        List<SendMessageBatchRequestEntry> moreBatchEntries = new List<SendMessageBatchRequestEntry>();
        batchEntries.Add(new SendMessageBatchRequestEntry("id4", "Fourth SQS Message"));
        batchEntries.Add(new SendMessageBatchRequestEntry("id5", "Fifth SQS Message"));
        batchEntries.Add(new SendMessageBatchRequestEntry("id6", "Sixth SQS Message"));
        Task<SendMessageBatchResponse> response = SQSWrapper.WrapRequest(client.SendMessageBatchAsync, moreBatchEntries);

        ```
      </Collapser>

      <Collapser
        id="net-dt-sns"
        title="SNS Wrapperの使用"
      >
        SNS wrapperは、以下の手法のラッピングをサポートしています。

        * Amazon.SimpleNotificationService.AmazonSimpleNotificationServiceClient.PublishAsync(...)

        例

        ```cs
  
        // SNS Client
        AmazonSimpleNotificationServiceClient client = new Amazon.SimpleNotificationService.AmazonSimpleNotificationServiceClient("<var>AWS_SECRET_ACCESS_KEY</var>", <var>AWS_REGION</var>);

        // PublishRequest - Phone Number
        PublishRequest phonePublishRequest = new PublishRequest();
        phonePublishRequest.PhoneNumber = +1XXX5555100;
        phonePublishRequest.Message = "An SNS Message for phones";
        Task<PublishResponse> phoneResponse = SNSWrapper.WrapRequest(client.PublishAsync, phonePublishRequest);

        // PublishRequest - ARN
        PublishRequest publishRequest = new PublishRequest("<var>TOPIC_ARN</var>", "An SNS Message");
        Task<PublishResponse> publishResponse = SNSWrapper.WrapRequest(client.PublishAsync, publishRequest);

        // String-based without subject
        Task<PublishResponse> responseOne = SNSWrapper.WrapRequest(client.PublishAsync, "<var>TOPIC_ARN</var>", "Another SNS Message");

        // String-based with subject
        Task<PublishResponse> responseTwo = SNSWrapper.WrapRequest(client.PublishAsync, "<var>TOPIC_ARN</var>", "Yet Another SNS Message", "A Subject");

        ```
      </Collapser>
    </CollapserGroup>

    5. 次の環境変数はLambdaをモニターする機能には不要ですが、Lambda機能をディストリビューティッド（分散）トレーシングに含める場合は必要です。[ディストリビューティッド（分散）トレーシング](/docs/apm/distributed-tracing/getting-started/introduction-distributed-tracing)を有効にするには、[AWS Lambdaコンソール](https://docs.aws.amazon.com/lambda/latest/dg/env_variables.html)で次の環境変数を設定します。

       * `NEW_RELIC_ACCOUNT_ID`：LambdaがレポートするNew Relic[アカウントID](/docs/accounts/install-new-relic/account-setup/account-id)。
       * `NEW_RELIC_TRUSTED_ACCOUNT_KEY`：これも[アカウントID](/docs/accounts/install-new-relic/account-setup/account-id)です。アカウントが子アカウントの場合、これはroot/親アカウントのアカウントIDである必要があります。

    6. ラッパー関数 (上記の例では`FunctionWrapper`)が関数ハンドラーとして設定されていることを確認します。

    7. 少なくとも1回Lambdaを呼び出します。これにより、CloudWatchロググループが作成されます。次のステップではこのグループが必要です。

       ラッパーはLambda実行についてのデータを収集し、JSONメッセージを生成し、CloudWatchログにログ記録します。次に、[CloudWatchを設定してそのログをNew Relicに送信します](/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/instrument-your-own/#manual-stream-logs)。
  </Collapser>

  <Collapser
    id="node"
    title="Node.js"
  >
    Node.js Lambdaをインストゥルメントするには：

    1. Node.jsエージェントパッケージをダウンロードし、関数と同じディレクトリに配置し、エージェントが`node_modules`ディレクトリで依存関係としてインストールされていることを確認します。Node Package Managerを使用します。

    ```bash
  
    npm install newrelic --save

    ```

    2. AWS SDKモジュールをNode.jsエージェントとともにインストールするには:

    ```bash

    npm install @newrelic/aws-sdk --save

    ```

    3. Lambdaコードで、ファイルの先頭でエージェントモジュールとAWS SDKを要求し、ハンドラー関数をラップします。例:

    ```js

    const newrelic = require('newrelic');
    require('@newrelic/aws-sdk');

    // Other module loads go under the two require statements above

    module.exports.handler = newrelic.setLambdaHandler((event, context, callback) => {
      // This is your handler function code
      console.log('Lambda executed');
      callback();
    });

    ```

    4. オプション：[`recordCustomEvent` API](/docs/agents/nodejs-agent/api-guides/nodejs-agent-api#record_custom_event)を使用して、Lambdaに[カスタムイベント](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#custom-event)を追加することもできます。例:

    ```js
    module.exports.handler = newrelic.setLambdaHandler((event, context, callback) => {
      newrelic.recordCustomEvent('MyEventType', { foo: 'bar' });
      console.log('Lambda executed');
      callback();
    });
    ```

    5. Lambda関数とNode.jsエージェントフォルダを一緒に圧縮します。要件および推奨：

       * New Relicエージェントフォルダに入っていないNew Relicファイルは、含める必要はありません。
       * Lambda関数のファイル名が、例えば、`lambda_function.node`の場合は、zipファイルを`lambda_function.zip`と命名することを推奨します。tarballは使用しないでください。
       * Lambdaと関連モジュールはすべて、zipファイルのルートディレクトリにある必要があります。つまり、ファイルを含むファイルを圧縮するとうまくいきません。

    6. 圧縮したファイルを、AWS Lambdaアカウントにアップロードします。

    7. AWSコンソールで、以下の[環境変数](https://docs.aws.amazon.com/lambda/latest/dg/env_variables.html)を設定します。

       * `NEW_RELIC_NO_CONFIG_FILE`。設定ファイルを使用していない場合は、`true`に設定します。
       * `NEW_RELIC_APP_NAME`：アプリケーション名。
       * `NEW_RELIC_ACCOUNT_ID`。[アカウントID](/docs/accounts/install-new-relic/account-setup/account-id)。
       * `NEW_RELIC_TRUSTED_ACCOUNT_KEY`。これは、[アカウントID](/docs/accounts/install-new-relic/account-setup/account-id)でもあります。アカウントが子アカウントの場合、これはroot/親アカウントのアカウントIDである必要があります。

    8. オプション：ローカル環境においてAWS以外のサーバーレスモードでエージェントを実行するには、環境変数`NEW_RELIC_SERVERLESS_MODE_ENABLED`を`true`に設定します。（これをAWS Lambda環境で実行する場合、エージェントはサーバーレスモードで自動的に実行されます。**AWSで実行中の場合、この変数は使用しないでください**。）

    9. オプション：サーバーレスモードでのロギングを有効にするには、環境変数を次のように設定します。

       * `NEW_RELIC_LOG_ENABLED`を`true`に設定します。
       * CloudWatchに出力する場合は、`NEW_RELIC_LOG`を`stdout`に設定、または書き込み可能なファイルロケーションに設定します。
       * ログレベルは、デフォルトで`info`に設定されます。[その他のログレベル](/docs/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration#logging_config)を参照してください。

    10. 少なくとも1回Lambdaを呼び出します。これにより、CloudWatchロググループが作成されます。次のステップではこのグループが必要です。

    ラッパーはLambda実行についてのデータを収集し、JSONメッセージを生成し、CloudWatchログにログ記録します。次に、[CloudWatchを設定してそのログをNew Relicに送信します](/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/instrument-your-own/#manual-stream-logs)。
  </Collapser>

  <Collapser
    id="python"
    title="Python"
  >
    Python Lambdaをインストゥルメントするには：

    1. Pythonエージェントパッケージをダウンロードし、関数と同じディレクトリに配置します。この場合は、pipを使用します。

    ```bash

    pip install -t . newrelic

    ```

    <Callout variant="important">
      Homebrewを使用する場合は、以下のエラーが発生することがあります。`DistutilsOptionError：ホームまたはprefix/exec-prefixのいずれかを提供する必要があります。両方ではありません`。詳細については、[Homebrew GitHubの投稿](https://github.com/Homebrew/brew/blob/master/docs/Homebrew-and-Python.md#note-on-pip-install---user)を参照してください。
    </Callout>

    2. Lambdaコードで、Pythonエージェントモジュールをインポートし、New Relicデコレーターを使用してハンドラー関数を修飾します。**最初に、コードにNew Relicパッケージをインポートする必要があります。**次の例を見てみましょう。

    ```py

    import newrelic.agent
    newrelic.agent.initialize()
    @newrelic.agent.lambda_handler()
    def handler(event, context):
    ...

    ```

    3. オプション：[`record_custom_event` API](/docs/agents/python-agent/python-agent-api/record_custom_event)を使用して、Lambdaに[カスタムイベント](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#custom-event)を追加することもできます。次の例を見てみましょう。

    ```py

    @newrelic.agent.lambda_handler()
    def handler(event, context):
    newrelic.agent.record_custom_event('CustomEvent', {'foo': 'bar'})
    ...

    ```

    4. このガイドラインを使用して、`lambda_function.py`と`newrelic/`フォルダを一緒に圧縮します。

       * `newrelic/`フォルダに入っていないNew Relicファイルは、含める必要はありません。
       * Lambda関数ファイル名が、たとえば`lambda_function.py`の場合は、zipファイルを`lambda_function.zip`と命名します。tarballは使用しないでください。
       * Lambdaと関連モジュールはすべて、zipファイルのルートディレクトリにある必要があります。つまり、ファイルを含むファイルを圧縮するとうまくいきません。

    5. 圧縮したファイルを、AWS Lambdaアカウントにアップロードします。

    6. AWSコンソールで、以下の[環境変数](https://docs.aws.amazon.com/lambda/latest/dg/env_variables.html)を設定します。

       * `NEW_RELIC_SERVERLESS_MODE_ENABLED`。`true`に設定します。

    7. 次の環境変数はLambdaをモニターする機能には不要ですが、Lambda機能をディストリビューティッド（分散）トレーシングに含める場合は必要です。[ディストリビューティッド（分散）トレーシング](/docs/apm/distributed-tracing/getting-started/introduction-distributed-tracing)を有効にするには、AWSコンソールで以下の[環境変数](https://docs.aws.amazon.com/amplify/latest/userguide/environment-variables.html)を設定します。

       * `NEW_RELIC_DISTRIBUTED_TRACING_ENABLED`。trueに設定します。
       * `NEW_RELIC_ACCOUNT_ID`。[アカウントID](/docs/accounts/install-new-relic/account-setup/account-id)。
       * `NEW_RELIC_TRUSTED_ACCOUNT_KEY。`これは、[アカウントID](/docs/accounts/install-new-relic/account-setup/account-id)でもあります。アカウントが子アカウントの場合、これはroot/親アカウントのアカウントIDである必要があります。

    8. オプション：ロギングを設定するには、AWSコンソールで[`NEW_RELIC_LOG`と`NEW_RELIC_LOG_LEVEL`環境変数](/docs/agents/python-agent/configuration/python-agent-configuration#environment-variables)を使用します。

    9. 少なくとも1回Lambdaを呼び出します。これにより、CloudWatchロググループが作成されます。次のステップではこのグループが必要です。

       New Relicデコレーターは、Lambda実行についてのデータを収集し、JSONメッセージを生成し、CloudWatchログに記録します。次に、[CloudWatchを設定してそのログをNew Relicに送信します](/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/instrument-your-own/#manual-stream-logs)。
  </Collapser>
</CollapserGroup>