---
title: モバイルセッションリプレイ
metaDescription: 'Learn how to set up and use Mobile Session Replay to capture and replay user sessions in your mobile applications, ensuring privacy while revealing performance and usability insights'
freshnessValidatedDate: never
translationType: machine
---

<Callout title="プレビュー機能">
  モバイル セッション リプレイは現在も鋭意開発中ですが、この強力な新機能をぜひお試しください。 この機能は現在、弊社の[プレリリース ポリシー](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy/)に従ってプレビュー プログラムの一部として提供されています。
</Callout>

ユーザーが実際に体験した内容を正確に把握できるのに、わかりにくいモバイル アプリのバグを再現するために何時間も費やす必要があるでしょうか?モバイル セッションリプレイは、エンドユーザーが携帯電話やタブレットで見たもののビデオ再生を提供し、そのセッションのすべてのテレメトリー データと同期させることで、トラブルシューティングにおける推測作業を排除します。 つまり、バグ レポートやローカルでの再現に頼ることなく、エラーがユーザーに及ぼす実際の影響を迅速に評価し、パフォーマンスのボトルネックや UX の摩擦ポイントを特定し、問題をより迅速に解決できるようになります。

<img title="New Relic - Mobile Session Replay" alt="Mobile Session Replay player interface showing a mobile app session with timeline controls, device frame displaying app screens, and synchronized telemetry data panel" src="/images/mobile-session-replay-player.webp" />

## 要件と互換性 [#requirements]

モバイル セッションリプレイを設定する前に、アプリが次の要件を満たしていることを確認してください。

### 技術的な前提条件 [#technical-prerequisites]

モバイル セッション リプレイを使用するには、以下が必要です。

* モバイル監視が有効になっているNew Relicアカウント
* New Relicで構成されたアクティブなモバイルアプリケーション
* モバイルアプリからNew Relicのデータ取り込みエンドポイントまでのネットワーク接続

### パフォーマンスに関する考慮事項 [#performance-considerations]

モバイル セッション リプレイを有効にする前に、アプリとユーザーに対する次の影響を考慮してください。

* **アプリのパフォーマンス**: セッションリプレイはビューポートデータをキャプチャして送信するため、古いデバイスではアプリのパフォーマンスに影響を与える可能性があります。
* **データ消費**: 特に画像がキャプチャされている場合、リプレイデータの送信はユーザーデータを消費します。
* **ストレージ要件**: キャプチャされたデータは、送信サイクル間でユーザーデバイス上に十分なストレージ容量を必要とします。
* **ネットワークの最適化**: すべてのデータは送信前にクライアント側で圧縮され、ネットワーク使用量を最小限に抑えます。
* **サンプリング戦略**: データ収集のニーズとパフォーマンスへの影響のバランスをとるために、サンプリングレートを慎重に検討します。

### 対応UIフレームワーク [#supported-frameworks]

セッションリプレイは現在、iOS、 Android 、およびReact Nativeアプリの一部のUIフレームワークでサポートされています。 今後もさらなるUIやハイブリッドフレームワークへの対応に積極的に取り組んでまいります。

**現在サポートされているもの:**

* iOS UIキット
* iOS SwiftUI
* Android XMLレイアウト
* Android ジェットパック コンポーズ
* React Native ビュー

**計画されているサポート:**

* Webビュー
* フラッター
* コルドバ
* コンデンサ
* マウイ島

### 最小エージェントバージョン [#minimum-versions]

<Callout variant="important">
  この機能は現在開発中であるため、最高のエクスペリエンスと最新の機能を得るために、MobileAgent の最新バージョンに更新することを強くお勧めします。
</Callout>

以下は、基本的なセッションリプレイ キャプチャをサポートした最初のエージェント バージョンです。

* [iOS エージェント v7.5.10](/docs/release-notes/mobile-release-notes/ios-release-notes/) 2025 年 9 月 15 日にリリース
* [Android エージェント v7.6.8 は](/docs/release-notes/mobile-release-notes/android-release-notes/)2025 年 7 月 29 日にリリースされました
* [React Nativeエージェント v1.5.10](/docs/release-notes/mobile-release-notes/react-native-release-notes/) 2025 年 9 月 15 日にリリース

## モバイルセッションリプレイの仕組み [#how-it-works]

モバイル セッションリプレイの仕組みを理解すると、プライバシー設定やトラブルシューティングについて情報に基づいた決定を下すのに役立ちます。

ユーザーがアプリをリリースすると、モバイル エージェントはNew Relicサーバーを呼び出して、セッションリプレイが有効になっているかどうか、有効になっている場合はサンプリング レートとプライバシー設定が何であるかを確認します。 エージェントはサンプリングの決定を解決し、リプレイ データのキャプチャを開始します。

Browserセッションリプレイとは異なり、モバイルアプリにはキャプチャして再作成できるDOMがありません。 代わりに、モバイル エージェントはビューのライフサイクルを監視し、ビューポートを HTML に変換します。 マスキング設定はビューポートの HTML 複製に適用され、JSON にシリアル化されてクライアント側に保存されます。その後、1 分ごとにデータ転送がトリガーされ、ペイロードが gzip 圧縮されて New Relic に送信されます。

アプリケーションが予期せずクラッシュまたはハングした場合、最後に成功した送信サイクルからアプリが予期せず終了するまでの間に収集されたデータは、次のアプリのリリースまでクライアント側に保存されます。そのとき、Mobile エージェントは孤立したデータの復元とアップロードを試みます。 iOS と Android が予期しない終了を処理する方法により、予期しないアプリの終了後にすべてのデータを回復できない場合があります。

New Relic UI でリプレイを表示すると、JSON が NRDB から取得され、Web ブラウザーで再生される「ビデオ」を構成する HTML 更新のストリームに逆シリアル化されます。

ネイティブ プラットフォーム ビューのフレームワークから HTML への変換により、モバイル セッションリプレイは一般に正確ですが、ピクセル パーフェクトではありません。 リプレイの精度向上に引き続き取り組んでまいります。

## モバイルセッションリプレイの設定 [#setup]

セッションリプレイ、サンプリングレート、およびほとんどのプライバシー設定の有効化は、 New Relicのアプリケーション設定ページでサーバー側で管理されるため、更新はデプロイメントや新しいアプリバージョンの採用に依存しません。 コード内で管理する必要があるのは、一部のタイプのマスキング オーバーライドのみです。

<Steps>
  <Step>
    ### モバイルセッションリプレイを有効にする [#enable]

    New Relic ウェブインターフェースの場合:

    1. **[one.newrelic.com &gt; All Capabilities &gt; Mobile](https://one.newrelic.com/all-capabilities)**に移動します。
    2. モバイルアプリを選択します。
    3. 左側のメニューで、 **Settings &gt; Application**をクリックします。
    4. **Mobile Session Replay** \[モバイルセッションリプレイを]オンに切り替えます。

    <img title="Enable Mobile Session Replay" alt="Enable Mobile Session Replay" src="/images/mobile-session-replay-enable.webp" />
  </Step>

  <Step>
    ### サンプリングレートを構成する [#sampling]

    サンプリング レートを定義して、セッションリプレイをキャプチャする頻度を制御します。 高スループットのアプリの場合、サンプリング レートは 100 万分の 1 パーセント程度まで小さくなることがあります。現在、1 つのサンプリング レートが利用可能です。

    * **合計ユーザーセッション**: すべてのユーザーセッションのランダムサンプルを記録します。

    <Callout variant="tip" title="近日公開">
      **エラー サンプリングを含むセッションは**、プレビュー期間の後半に利用できるようになります。この機能は、少なくとも 1 つのエラーが発生したセッションのランダム サンプルを記録し、クライアント側で最大 30 秒間、データのスライディング ウィンドウをバッファリングします。エラーが発生すると、バッファリングされたデータがアップロードされ、セッションの残りの部分が記録されます。
    </Callout>
  </Step>

  <Step>
    ### プライバシー設定を構成する [#privacy]

    セッションリプレイを記録する場合、ユーザーのプライバシーを保護することが重要です。 デフォルト設定では、すべてのテキストと画像をマスクして機密情報を保護しますが、特定のプライバシー ニーズに合わせて調整することもできます。

    すべてのマスキングはクライアント側で行われるため、機密情報がエンドユーザーのデバイスから漏れることはありません。このセクションでは、ユーザー エクスペリエンスの向上と問題の診断にセッション リプレイを有用に保ちながら、プライバシー基準を遵守するためのマスキング戦略、モード、上書きルールを使用する方法を説明します。
  </Step>
</Steps>

## プライバシーとマスキング [#privacy-masking]

プライバシー要件に最適なマスキング戦略を選択してください。

### マスキング戦略 [#masking-strategies]

モバイル セッションリプレイは、プライバシー保護とリプレイ ユーティリティのバランスをとるための 2 つのマスキング戦略を提供します。 選択内容によって、セッション記録で機密データがどのように処理されるかが決まります。

#### デフォルトのマスキング戦略 [#default-strategy]

デフォルトのマスキング戦略では、すべてのテキストと画像を例外なくマスキングすることで、最大限のプライバシー保護を実現します。次の場合にこの戦略を選択します。

* アプリでは非常に機密性の高いデータ（医療、金融サービスなど）を扱います
* 規制遵守には厳格なデータ保護が必要
* 個人情報を盗まれるリスクをゼロにしたい

**マスクされるもの:**

* すべてのテキストはアスタリスクに置き換えられます（例：「hello」は「\*\*\*\*\*」になります）
* すべての画像が同じ寸法のプレースホルダーブロックに置き換えられます
* ユーザーのタップやスワイプは引き続きキャプチャされます（非表示にしない限り）

これにより、誤ってマスク解除コードを追加した場合でも、デフォルトの戦略によって常にすべてがマスクされるようになります。

**デフォルトのマスキング戦略の重要な制限:**

* マスキングモードは設定できません
* インライン マスキング オーバーライド ( `nr-unmask`タグなど) は無視されます
* サーバー側のマスキングルールは効果がない

<img title="Mobile Session Replay default masking strategy" alt="Mobile Session Replay default masking strategy showing all text and images masked" src="/images/mobile-session-replay-default.webp" />

#### カスタムマスキング戦略 [#custom-strategy]

カスタム マスキング戦略を使用すると、マスクする内容と表示したままにする内容をきめ細かく制御できます。この戦略は次の場合に使用します。

* アプリには公開コンテンツとセンシティブなコンテンツが混在しています
* 問題を効果的に診断するには、特定のUI要素を確認する必要があります
* 非機密領域を選択的にマスク解除したい

カスタム戦略は次の要素で構成されます。

1. **マスキング モード**: さまざまなコンテンツ タイプ (テキスト、画像、インタラクション) のベースライン ルール
2. **オーバーライドルール**: 特定のコンポーネントをマスクまたはマスク解除する例外

**カスタム マスキングに切り替えるには:**

New Relic ウェブインターフェースの場合:

1. **Mobile &gt; \[あなたのエンティティ] &gt; Settings &gt; Application &gt; Session Replay**に移動します
2. **Masking strategy** \[マスキング戦略]セクションで、**Custom** \[カスタム]を選択します。
3. マスキングモードを設定します（次のセクションを参照）
4. オプションで、特定のコンポーネントのオーバーライドルールを追加します

<img title="Mobile Session Replay masking strategies" alt="Mobile Session Replay masking strategy selection with Default and Custom options" src="/images/mobile-session-replay-strategy.webp" />

### マスキングモード [#masking-modes]

カスタム マスキング戦略を使用する場合、マスキング モードはセッション リプレイのベースライン プライバシー動作を確立します。 これらのモードは、個々のコンポーネントの特定のルールによって上書きされない限り、アプリ全体にグローバルに適用されます。

**マスキング モードを構成するには:**

New Relic ウェブインターフェースの場合:

1. **Mobile &gt; \[あなたのエンティティ] &gt; Settings &gt; Application &gt; Session Replay**に移動します
2. **Custom \[カスタム]**マスキング戦略が選択されていることを確認します
3. **Masking modes** \[マスキングモード]セクションで、必要に応じて各モードのオン/オフを切り替えます。
4. 変更はすべての新しいセッション記録に直ちに反映されます

<img title="Mobile Session Replay masking modes" alt="Mobile Session Replay masking modes configuration panel" src="/images/mobile-session-replay-mode.webp" />

4 つのマスキング モードは、異なる種類のコンテンツを制御します。

#### ユーザー入力テキストをマスクする [#mask-user-input]

ユーザーが入力フィールドに入力したテキストがリプレイに表示されるかどうかを制御します。

**有効にした場合（推奨）：**

* ユーザーが入力したすべての文字はアスタリスクに置き換えられます
* 例: ユーザーは「 [john.doe@email.com](mailto:john.doe@email.com) 」と入力します→ リプレイでは「\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*」と表示されます
* ユーザー名、メールアドレス、検索クエリ、フォームデータ、その他のユーザーが入力したコンテンツを保護します

**無効にした場合:**

* ユーザーが入力したテキストは、リプレイに入力したとおりに表示されます。
* 入力フィールドに機密情報が含まれていない場合にのみ使用してください
* フォーム検証の問題や検索機能のデバッグに役立ちます

<Callout variant="important">
  この設定に関係なく、パスワード フィールドは**常にマスクされ**ます。SecureField (iOS)、パスワード入力タイプ (Android)、および安全なテキスト入力フィールドでは、リプレイでプレーンテキストが表示されることはありません。
</Callout>

**デフォルト設定:**カスタム マスキング戦略で有効。

**このモードを無効にする必要がある場合:**

* クエリが個人を特定できない公開検索バー
* 非機密フィルターまたはカテゴリ選択
* オートコンプリートまたは入力検証の問題のデバッグ

#### マスクアプリケーションのテキスト [#mask-app-text]

アプリケーションによって表示されるテキスト (ラベル、ボタン、ヘッダー、コンテンツ) がリプレイに表示されるかどうかを制御します。

**有効にすると:**

* アプリによってレンダリングされるすべての静的および動的テキストはアスタリスクに置き換えられます
* 例: 「First Name:」ラベルはリプレイでは「\*\*\*\*\*\*\*\*\*\*\*」になります
* 機密情報を含む、または漏洩する可能性のあるテキストを保護します

**無効にした場合:**

* アプリケーションのすべてのテキストは、ユーザーが見ているとおりに表示されます
* ラベル、ボタン、見出し、コンテンツは完全に読みやすい
* リプレイの理解と操作がはるかに簡単になります
* ユーザーがどの画面や機能を操作したかを特定するために不可欠

**デフォルト設定:**カスタム マスキング戦略で有効。

**ほとんどのアプリに対する推奨事項:**非常に機密性の高い情報を表示する場合を除き、このモードを無効にします。表示される UI テキストは、次の点で重要です。

* ユーザーのナビゲーションパスを理解する
* ユーザーがクリックしたボタンや機能を特定する
* 表示されたエラーメッセージを見る
* レイアウトまたはローカリゼーションの問題の診断
* リプレイと特定のアプリ機能を相関させる

**次の場合にはこのモードを有効にしてください。**

* 患者情報を表示するヘルスケアアプリ
* 口座の詳細や取引を表示する金融アプリ
* センシティブな内容を含む可能性のあるユーザー生成コンテンツを含むアプリ
* コンプライアンス要件により、表示されるすべてのテキストをマスクすることが義務付けられています

<Callout variant="tip">
  このモードを無効にして、特定の機密テキスト要素をマスクする必要がある場合は、[オーバーライド ルールを](#masking-overrides)使用して、UI の残りの部分を表示したまま、それらのコンポーネントのみを選択的にマスクします。
</Callout>

#### マスク画像 [#mask-images]

<Callout variant="important">
  イメージキャプチャをサポートするエージェントの最小バージョン:

  * iOS エージェント v7.5.10 (2025 年 9 月 15 日リリース)
  * Android エージェント v7.6.9（2025 年 9 月 15 日リリース）
  * React Native エージェント v1.5.10 (2025年9月15日リリース)
</Callout>

アプリケーション内の画像をキャプチャしてリプレイで表示するかどうかを制御します。

**有効にした場合（推奨）：**

* すべての画像は同じサイズのプレースホルダーブロックに置き換えられます
* プレースホルダーはレイアウト構造を維持するので、画像の位置を確認できます。
* 画像データはNew Relicに送信されません
* ユーザーがアップロードした写真、プロフィール写真、および機密性の高い可能性のある画像を保護します

**無効にした場合:**

* 画像はキャプチャされ、圧縮され、Base64でエンコードされ、リプレイペイロードに含められます。
* リプレイでは画像が表示されるが、ユーザーが見たものよりも画質が低い
* データ転送と保存コストが大幅に増加する
* 画像の読み込み、レンダリング、レイアウトに関する問題の診断に役立ちます

<Callout variant="caution" title="画像を撮影する際の重要な考慮事項">
  画像キャプチャを有効にすると、データ使用量とパフォーマンスに大きな影響が出ます。

  * **データ使用量**: 画像はリプレイペイロードサイズを大幅に増加させ、ユーザーデータとNew Relicのストレージクォータを大幅に消費します。
  * **品質**: 画像は影響を最小限に抑えるためにクライアント側で積極的に圧縮されるため、元の画像よりも品質が低くなります。
  * **パフォーマンス**: 画像のキャプチャと圧縮は、古いデバイス上のアプリのパフォーマンスに影響を与える可能性があります
  * **プライバシー**:画像に機密情報や個人情報が含まれているかどうかを考慮する

  視覚的なデバッグがユースケースに不可欠な場合にのみ、画像マスクを無効にしてください。
</Callout>

**デフォルト設定:**カスタム マスキング戦略で有効。

**このモードを無効にする必要がある場合:**

* 画像の読み込み失敗やレンダリングの問題の診断
* 画像寸法に関連するレイアウトの問題の調査
* 画像ギャラリーやメディアコンテンツに対するユーザーのインタラクションを理解する
* アプリには、公開されている機密情報を含まない画像（アイコン、ロゴ、イラスト）のみが表示されます。

**次の場合にはこのモードを有効にしてください。**

* ユーザーのプロフィール写真またはアップロードされた写真
* アプリ内でキャプチャされたドキュメントまたはスクリーンショット
* 医療画像またはヘルスケア関連の画像
* ユーザーが作成した視覚コンテンツ

#### ユーザーのタップとスワイプを非表示にする [#hide-interactions]

ユーザーのタッチ インタラクションをリプレイで視覚化するかどうかを制御します。

**無効にした場合（推奨）：**

* ユーザーのタップはリプレイ上で灰色の円として表示されます
* スワイプジェスチャはモーションパスを示す赤い線として表示されます
* ユーザーがどのUI要素を操作したかを理解するために不可欠
* ユーザビリティの問題、タップのミス、または混乱を招くインタラクションを特定するのに役立ちます

**有効にすると:**

* リプレイにはタップやスワイプの視覚化は表示されません
* ユーザーは目に見えるインタラクションなしでアプリ内を移動しているように見えます
* タッチパターンによって機密情報が明らかになる可能性がある場合に使用します

<Callout variant="tip">
  この設定に関係なく、OS キーボードとそのタップおよびスワイプはリプレイでは**キャプチャされません**。 これにより、パスワードの入力と機密テキストの入力が自動的に保護されます。
</Callout>

**デフォルト設定:**カスタム マスキング戦略では無効 (タップとスワイプは表示されます)。

**インタラクションを非表示にする必要がある場合:**通常はテキストをマスクするだけで十分ですが、次の場合にはタップ/スワイプを非表示にする必要がある場合があります。

* アプリにはPINパッドまたはテンキーが統合されており、タップパターンでセキュリティコードが表示されます
* スワイプパターンは認証に使用されます（パターンロック、ジェスチャーパスワード）
* 特定の画面でのタッチインタラクションは、繊細な選択（医学的症状の選択、財務上の決定）を推測する可能性があります。

**ほとんどのアプリに対する推奨事項:**インタラクションを次のユーザーに見えるようにしておきます:

* 見逃された領域や反応しない領域も含め、ユーザーがタップした場所を正確に確認します
* アプリのナビゲーションパターンとユーザーフローを理解する
* 小さなタッチターゲットやわかりにくいボタンなどのユーザビリティの問題を特定する
* ジェスチャベースの機能（スワイプして削除、引いて更新など）を診断します

## 高度なマスキング設定 [#advanced-masking]

アプリケーションの特定の部分に、指定したマスキング モードとは異なるマスキング設定を適用する場合は、マスキング オーバーライドを使用します。たとえば、アプリケーションの大部分に機密データが含まれていない場合は、モードをマスク解除に設定し、オーバーライドを指定して、機密データが含まれるアプリケーションの部分のみをマスクすることができます。

### マスクオーバーライドメソッド [#masking-overrides]

マスキング オーバーライド ルールを作成するには、次の 3 つの方法があります。

#### インライン属性 [#inline-attributes]

インライン マスキング オーバーライドは、マスクまたはマスク解除するコンポーネントにタグを付けることでコード内に適用されます。アップデートを適用するには、アプリの新しいバージョンを 作成し、ユーザーに採用してもらう必要があるため、変更のマスキングを管理するために変更管理プロセスを監視したい場合に最適です。

<Tabs>
  <TabsBar>
    <TabsBarItem id="ios">
      iOS
    </TabsBarItem>

    <TabsBarItem id="android">
      Android
    </TabsBarItem>

    <TabsBarItem id="reactnative">
      リアクトネイティブ
    </TabsBarItem>
  </TabsBar>

  <TabsPages>
    <TabsPageItem id="ios">
      **SwiftUI**

      特定のマスキング動作が必要なコンテンツをラップするには、 `NRConditionalMaskView`を使用します。この SwiftUI コンポーネントは、セッションリプレイでのデータマスキングをきめ細かく制御できます。

      **要件：**

      * iOS 16.0以降
      * Swift 5.0以降

      **輸入：**

      ```swift
      import SwiftUI
      import NewRelic
      ```

      **基本的な使用方法:**

      ```swift
      // Mask all text content within this view
      NRConditionalMaskView(maskApplicationText: true) {
          VStack {
              Text("This text will be masked in session replay")
              Text("This text will also be masked")
          }
      }
      ```

      **コンテンツのマスクを解除:**

      ```swift
      // Explicitly unmask content (useful when parent views have masking enabled)
      NRConditionalMaskView(maskApplicationText: false) {
          Text("This text will be visible in session replay")
      }
      ```

      **識別子ベースのマスキング:**

      ```swift
      // Use an identifier to control masking via API or dashboard settings
      NRConditionalMaskView(sessionReplayIdentifier: "unmasked-section") {
          Text("This text masking is controlled by the identifier")
      }
      ```

      **パラメーター：**

      * `maskApplicationText`: `true`の場合、ビュー内のすべてのテキスト コンテンツをマスクします。`false`の場合、テキストが表示されるようにします。`nil`の場合、親から継承します。
      * `maskUserInputText`: `true`の場合、ビュー内のユーザー入力フィールドをマスクします。`false`の場合、入力内容が表示されます。`nil`の場合、親から継承します。
      * `maskAllImages`: `true`の場合、ビュー内のすべての画像をマスクします。`false`の場合、画像が表示されます。`nil`の場合、親から継承します。
      * `maskAllUserTouches`: `true`のとき、マスクユーザーはビュー内のインタラクションをタッチします。 `false`の場合、タッチイベントが表示されます。`nil`の場合、親から継承します。
      * `sessionReplayIdentifier`: `addSessionReplayMaskedAccessibilityIdentifier` 、 `addSessionReplayUnmaskedAccessibilityIdentifier` 、または New Relic アプリケーション ダッシュボードを介してマスキングを制御するためのオプションの識別子。
      * `activated`: `false`の場合、このビューのマスキング機能が完全に無効になります。デフォルトは`true`です。

      **高度な例 - フォーム内の混合マスキング:**

      ```swift
      struct RegistrationForm: View {
          @State private var firstName = ""
          @State private var email = ""
          @State private var password = ""
          
          var body: some View {
              VStack(alignment: .leading, spacing: 16) {
                  // Public form labels remain visible
                  NRConditionalMaskView(maskApplicationText: false) {
                      Text("Create Your Account")
                          .font(.title)
                  }
                  
                  // Personal information
                  NRConditionalMaskView(sessionReplayIdentifier: "personal-info") {
                      TextField("First Name", text: $firstName)
                      TextField("Email", text: $email)
                  }
                  
                  // Highly sensitive - mask everything
                  NRConditionalMaskView(sessionReplayIdentifier: "password-section") {
                      SecureField("Password", text: $password)
                      Text("Password must be at least 8 characters")
                  }
                  
                  Button("Sign Up") {
                      // Handle registration
                  }
              }
              .padding()
          }
      }
      ```

      **UIキット**

      マスクまたはマスク解除する`UIView`の`accessibilityIdentifier`に`nr-mask`または`nr-unmask`を追加します。既存の識別子を追加すると、自動テスト用に一意の識別子を維持する必要がある場合に役立ちますが、値を変更した後にテストを更新する必要がある可能性が高くなります。

      `accessibilityIdentifier`追加する例:

      ```swift
      let myView = UIView()
      myView.accessibilityIdentifier = "nr-mask"
      ```

      既存の`accessibilityIdentifier`に追加する例:

      ```swift
      let myView = UIView()
      myView.accessibilityIdentifier = "someExistingId.nr-unmask"
      ```
    </TabsPageItem>

    <TabsPageItem id="android">
      **ジェットパックコンポーズ**

      Modifier 拡張機能を使用して、Jetpack Compose でのマスキング動作を制御します。

      例：

      ```kotlin
      // Mask a composable
      Text(
          text = "Sensitive information",
          modifier = Modifier.newRelicMask()
      )

      // Unmask a composable
      Text(
          text = "Public information",
          modifier = Modifier.newRelicUnmask()
      )
      ```

      **XMLレイアウト**

      マスクまたはマスク解除するビューまたはコンポーネントに`nr-mask`または`nr-unmask`タグを追加します。

      例：

      ```xml
      <EditText
          android:id="@+id/editTextEmail"
          android:layout_width="390dp"
          android:inputType="text"
          android:tag="nr-mask"
          android:importantForAutofill="no" />

      <EditText
          android:id="@+id/editTextEmail"
          android:layout_width="390dp"
          android:inputType="text"
          android:tag="nr-unmask"
          android:importantForAutofill="no" />
      ```
    </TabsPageItem>

    <TabsPageItem id="reactnative">
      ビューまたはコンポーネントをマスクまたはマスク解除するには、 `<NewRelicMask>`および`<NewRelicUnMask>`コンポーネントを使用します。

      例：

      ```jsx
      <View>
        <NewRelicMask>
          <Text>Sensitive information</Text>
        </NewRelicMask>
      </View>

      <View>
        <NewRelicUnmask>
          <Text>Non-sensitive information</Text>
        </NewRelicUnmask>
      </View>
      ```
    </TabsPageItem>
  </TabsPages>
</Tabs>

#### ローカルAPIメソッド [#local-api]

ローカルAPIメソッドのマスキング オーバーライドは、 New Relicエージェント設定内のコードにも適用されます。 これらは、ターゲット ビューに既に一意の識別子があり、コード全体で各ビューを個別にタグ付けするのではなく、集中リストでターゲット ビューを管理したい場合に便利です。

<Tabs>
  <TabsBar>
    <TabsBarItem id="ios">
      iOS
    </TabsBarItem>

    <TabsBarItem id="android">
      Android
    </TabsBarItem>
  </TabsBar>

  <TabsPages>
    <TabsPageItem id="ios">
      **SwiftUI**

      SwiftUI ビューの場合は、次のメソッドとともに`NRConditionalMaskView`の`sessionReplayIdentifier`問題を使用します。

      * `addSessionReplayMaskedAccessibilityIdentifier`
      * `addSessionReplayUnmaskedAccessibilityIdentifier`

      例：

      ```swift
      // In your app initialization
      NewRelic.addSessionReplayMaskedAccessibilityIdentifier("sensitive-section")
      NewRelic.addSessionReplayUnmaskedAccessibilityIdentifier("public-section")

      // In your SwiftUI views
      NRConditionalMaskView(sessionReplayIdentifier: "sensitive-section") {
          Text("This will be masked")
      }

      NRConditionalMaskView(sessionReplayIdentifier: "public-section") {
          Text("This will be visible")
      }
      ```

      **UIキット**

      次のメソッドに`class`または`accessibilityIdentifier`を追加して、ビューをマスクまたはマスク解除します。

      * `addSessionReplayMaskViewClass`
      * `addSessionReplayUnmaskViewClass`
      * `addSessionReplayMaskViewAccessibilityIdentifier`
      * `addSessionReplayUnmaskViewAccessibilityIdentifier`

      例：

      ```swift
      NewRelic.addSessionReplayMaskViewClass("SecureLabel")
      NewRelic.addSessionReplayUnmaskViewClass("UnsecureLabel")
      NewRelic.addSessionReplayMaskViewAccessibilityIdentifier("login")
      NewRelic.addSessionReplayUnmaskViewAccessibilityIdentifier("editTextEmail")
      ```
    </TabsPageItem>

    <TabsPageItem id="android">
      **ジェットパックコンポーズ**

      Jetpack Compose では、XML レイアウトと同じ方法を使用して、テストタグまたはクラス名でコンポーザブルをターゲットにすることができます。

      例：

      ```kotlin
      // In your application initialization
      NewRelic.addSessionReplayMaskViewTag("sensitive-data")
      NewRelic.addSessionReplayUnmaskViewTag("public-data")

      // In your composables
      Text(
          text = "Sensitive information",
          modifier = Modifier.testTag("sensitive-data")
      )

      Text(
          text = "Public information",
          modifier = Modifier.testTag("public-data")
      )
      ```

      **XMLレイアウト**

      次のメソッドに`class`または`android:tag`を追加して、ビューをマスクまたはマスク解除します。

      * `addSessionReplayMaskViewClass`
      * `addSessionReplayUnmaskViewClass`
      * `addSessionReplayMaskViewTag`
      * `addSessionReplayUnmaskViewTag`

      例：

      ```java
      NewRelic.addSessionReplayMaskViewTag("login");
      NewRelic.addSessionReplayUnmaskViewTag("editTextEmail");
      NewRelic.addSessionReplayUnmaskViewClass("android.widget.Button");
      NewRelic.addSessionReplayMaskViewClass("android.widget.TextView");
      NewRelic.addSessionReplayMaskViewClass("com.yourpackagename.CustomView");
      ```
    </TabsPageItem>
  </TabsPages>
</Tabs>

#### サーバー側のルール [#server-side-rules]

<Callout variant="important">
  サーバー側ルールをサポートする最小エージェント バージョン:

  * iOS エージェント v7.5.10 (2025 年 9 月 15 日リリース)
  * Android エージェント v7.6.9（2025 年 9 月 15 日リリース）
  * React Native エージェント v1.5.10 (2025年9月15日リリース)
</Callout>

サーバー側のマスキング ルールを使用すると、すでにリリースされているアプリのバージョンのマスキングの間違いを遡及的に修正できます。アプリの更新を必要とせず、すべての新しいセッションの開始時にすぐに有効になります。

ルールは 3 つのコンポーネントで構成されます。

* **タイプ**: 一致するコンポーネントをマスクするかマスク解除するかを決定します
* **識別子**: 対象要素をどのように扱うかを指定します (例: クラス別、タグ別など)。
* **値**: ルールが適用される選択された識別子の値

たとえば、 `Mask` `class` `android.widget.EditText`のルールは、Android アプリ内のユーザーが編集可能なすべてのテキスト フィールドをマスクします。

<img title="Mobile Session Replay masking override" alt="Mobile Session Replay masking override" src="/images/mobile-session-replay-override.webp" />

<figcaption>
  アプリケーション設定でモバイル セッションリプレイのマスキング オーバーライドを定義します。
</figcaption>

**新しいルールを作成するには**

New Relic ウェブインターフェースの場合:

1. **Mobile &gt; \[あなたのエンティティ] &gt; Settings &gt; Application &gt; Session Replay**に移動します。
2. **Override rules** \[オーバーライド ルール]までスクロールし、 **Add new override rule** \[新しいオーバーライド ルールの追加]をクリックします。
3. ルールの種類 (マスクまたはマスク解除) を選択します。
4. コンポーネントをターゲットするために使用する識別子を選択します。
5. ルールを適用する識別子の値を入力します。
6. **Add rule** \[ルールの追加]をクリックします。

新しいルールはオーバーライド ルール テーブルに追加され、すべての新しいセッションに適用されます。

**ルールを削除または編集するには:**

New Relic ウェブインターフェースの場合:

1. **Mobile &gt; \[あなたのエンティティ] &gt; Settings &gt; Application &gt; Session Replay**に移動します。
2. 「オーバーライド ルール」テーブルで、変更するルールを見つけます。
3. `...`メニューをクリックし、 **Delete** \[削除]または**Edit** \[編集]を選択します。

### マスキングルールの優先度 [#priority]

1 つのビューまたは要素に複数のマスキング ルールが適用される場合、次の優先順位によってどのルールが適用されるかが決まります。

1. **戦略はすべてに優先する**

   マスキング戦略が`Default`の場合、モードとオーバーライドは適用されません。

   *例:*コードにインライン`nr-unmask`属性オーバーライドを追加したが、設定で`Default`マスキング戦略が選択されている場合は、すべてがマスクされたままになります。

2. **オーバーライドはモードを優先します**

   モードはオーバーライドが存在しない場合に標準的な動作を決定するため、オーバーライドが存在する場合は、それが常にモードよりも優先されます。

   *例:* `Mask application text`モードが有効で、コード内のビューにインライン`nr-unmask`属性オーバーライドを追加すると、そのビューはマスク解除されますが、他のすべてのビューはマスクされます。

3. **マスクのオーバーライドはマスク解除のオーバーライドよりも優先されます**

   1 つのビューにマスクとマスク解除の両方のオーバーライドがある場合、そのビューは常にマスクされます。

   *例:*ビューにインライン`nr-unmask`属性オーバーライドと`nr-mask`サーバー側ルールがある場合、ビューはマスクされます。

## セッションリプレイの表示と分析 [#view-analyze]

セッションリプレイの収集を開始すると、一般的なパターンやユーザーエクスペリエンスで摩擦が生じる領域を特定することで、デジタルエクスペリエンスを向上させるために使用できます。 また、エラーや予期しない動作が発生する前にユーザーが実行した手順を確認することで、問題を迅速に診断して解決するのにも役立ちます。

### セッションリプレイページでリプレイを表示する [#replay-page]

セッションリプレイ ページには、選択した期間に収集されたすべてのリプレイのリストが表示されます。 デフォルトでは、少なくとも 5 秒間続いたリプレイのみをリストにフィルターします。表にはエラー数などの役立つデータ ポイントが表示され、フィルターを使用すると、問題の解決に役立つセッションにリストを絞り込むことができます。

<img title="Mobile Session Replay listing page" alt="Mobile Session Replay listing page" src="/images/mobile-session-replay-listing.webp" />

<figcaption>
  **Mobile &gt; \[あなたのアプリ] &gt; Session replay**でリプレイを表示およびフィルタリングします。
</figcaption>

たとえば、 `countryCode`フィルターを追加して特定の地域からのリプレイを表示し、ローカリゼーションが期待どおりに機能しているかどうかを確認したり、 `deviceModel`フィルターを追加して互換性の問題がある可能性のある特定の電話機モデルからのリプレイを表示したりできます。

**セッションリプレイページにアクセスするには:**

New Relic ウェブインターフェースの場合:

1. **[one.newrelic.com &gt; All Capabilities &gt; Mobile](https://one.newrelic.com/all-capabilities)**に移動します。
2. モバイルアプリを選択します。
3. 左側のメニューで下にスクロールし、 **Session replay** \[セッション リプレイ] をクリックします。
4. リプレイを表示するには行をクリックします。

### エラーやパフォーマンスの問題のあるリプレイを表示する [#errors-issues]

現在、メインのセッションリプレイページからリプレイを表示できます。 クラッシュ、リクエスト エラー、処理された例外、および ANR エクスペリエンスとの統合は、プレビュー期間の後半に提供される予定です。

<Callout variant="tip" title="近日公開">
  利用可能な場合、リプレイのキャプチャ中にユーザーが問題に遭遇すると、クラッシュ、リクエスト エラー、処理された例外、および ANR エクスペリエンスでエラーが発生したときにリプレイのプレビューが利用できるようになります。

  プレビューには、問題が発生する前の 5 ～ 10 秒と、致命的でない問題の場合は問題が発生してから 5 ～ 10 秒が表示されます。リプレイ中にエラーが発生した正確なタイミングを示すアイコンがタイムラインにオーバーレイされます。これにより、問題の原因となった可能性のあるユーザーアクションと、エンドユーザーへの影響の重大度を迅速に評価できます。

  プレビューだけでは問題を解決できない場合は、 **View full session replay** \[完全なセッション リプレイを表示]ボタンをクリックして、キャプチャされた他のテレメトリー データと同期されたセッション全体を確認できます。
</Callout>

<img title="Mobile Session Replay in errors experiences (preview)" alt="Preview of Mobile Session Replay integration with error experiences showing a replay timeline with error markers" src="/images/mobile-session-replay-errors.webp" />

<figcaption>
  プレビュー: リプレイは、クラッシュ、リクエスト エラー、処理された例外、および ANR エクスペリエンスのコンテキストで利用できるようになります。
</figcaption>

## 権限とアクセスを管理する [#permissions]

モバイル セッションリプレイには独自の権限セットがあるため、リプレイを表示して設定を更新できるユーザーを細かく調整できます。 任意の標準ロールを持つユーザーはリプレイを表示できますが、セッションリプレイ設定を変更できるのはすべての製品管理者だけです。 ユーザー権限をより細かく制御するために、カスタム ロールを作成できます。

### 権限の概要 [#permission-overview]

ユーザー権限は、**Administration &gt; Access management &gt; Roles**にあるユーザー管理 UI で管理されます。

アプリケーション設定ページでセッションリプレイ設定を表示または変更するには、ユーザーはセッションリプレイ権限とアプリケーション設定権限の両方が必要です。

<table>
  <thead>
    <tr>
      <th style={{ width: "300px" }}>
        許可
      </th>

      <th>
        説明
      </th>

      <th style={{ width: "200px" }}>
        付与対象:
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        モバイル / セッションリプレイ / 表示
      </td>

      <td>
        セッションリプレイとリストページを表示します。 アプリケーション設定 / 表示と組み合わせて、アプリ設定ページで現在のセッションリプレイ設定を表示します。
      </td>

      <td>
        すべての製品管理者<br />標準ユーザー<br />読み取り専用
      </td>
    </tr>

    <tr>
      <td>
        モバイル / セッションリプレイ / 変更
      </td>

      <td>
        アプリ設定・変更と連動して、アプリ設定ページでセッションリプレイの設定を更新します。
      </td>

      <td>
        全製品アドミン
      </td>
    </tr>

    <tr>
      <td>
        モバイル / アプリケーション設定 / 表示
      </td>

      <td>
        アプリ設定ページで現在の設定を表示します。セッションリプレイセクションを表示するには、セッションリプレイ/ビューも必要です。
      </td>

      <td>
        すべての製品管理者<br />標準ユーザー<br />読み取り専用
      </td>
    </tr>

    <tr>
      <td>
        モバイル / アプリケーション設定 / 変更
      </td>

      <td>
        アプリ設定ページで設定を更新します。セッションリプレイセクションを更新するには、セッションリプレイ/修正も必要です。
      </td>

      <td>
        全製品アドミン
      </td>
    </tr>
  </tbody>
</table>