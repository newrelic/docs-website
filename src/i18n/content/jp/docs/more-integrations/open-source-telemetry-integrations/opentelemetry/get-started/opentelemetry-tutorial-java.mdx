---
title: 'OpenTelemetry チュートリアル: サンプル Java アプリを計測する'
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: 'To test out OpenTelemetry on a sample app instead of your own app, consider these three tutorials.'
freshnessValidatedDate: never
translationType: machine
---

import opentelemetrySpringBootASCIIDisplay from 'images/opentelemetry_screenshot-crop_Spring-Boot-ASCII-display.webp'

import opentelemetryMainDistributedTracingPage from 'images/opentelemetry_screenshot-crop_main-distributed-tracing-page.webp'

import opentelemetryDistributedTracingError from 'images/opentelemetry_screenshot-crop_distributed-tracing-error.webp'

import opentelemetryInProcessSpans from 'images/opentelemetry_screenshot-crop_in-process-spans.webp'

import opentelemetryExceptiononSpanEvent from 'images/opentelemetry_screenshot-crop_exception-on-span-event.webp'

import opentelemetryAttributesTab from 'images/opentelemetry_screenshot-crop_attributes-tab.webp'

import opentelemetryMetricsExplorerMain from 'images/opentelemetry_screenshot-crop_metrics-explorer-main.webp'

import opentelemetryMetricsExplorerDimensions from 'images/opentelemetry_screenshot-crop_metrics-explorer-dimensions.webp'

import opentelemetryJvmsPageMain from 'images/opentelemetry_screenshot-crop_jvms-page-main.webp'

import opentelemetryCompareJvmInstances from 'images/opentelemetry_screenshot-full_compare-jvm-instances.webp'

import opentelemetryJvmColorCodedComparison from 'images/opentelemetry_screenshot-full_jvm-color-coded-comparison.webp'

import opentelemetryMainLogsPage from 'images/opentelemetry_screenshot-full_main-logs-page.webp'

import opentelemetryLogsinTerminal from 'images/opentelemetry_screenshot-full_logs-in-terminal.webp'

import opentelemetryLogDetailsWithTrace from 'images/opentelemetry_screenshot-full_log-details-with-trace.webp'

import opentelemetryTraceRelatedtoLog from 'images/opentelemetry_screenshot-full_trace-related-to-log.webp'

import opentelemetryTraceWaterfallFromLog from 'images/opentelemetry_screenshot-full_trace-waterfall-from-log.webp'

import opentelemetryLogCapturedinTraceSpan from 'images/opentelemetry_screenshot-full_log-captured-in-trace-span.webp'

import opentelemetryTraceDurationDemoChart from 'images/opentelemetry_screenshot-crop_jvm-metric-charts.webp'

これらの Java チュートリアルを試して、New Relic プラットフォームが OTLP データで何ができるかを確認してください。選択できる 3 つのチュートリアルがあり、それぞれ同じデモ Spring アプリを使用しています。アプリはフィボナッチ数列の n 番目の数値を計算し、トレース、メトリクス、ログを生成します。

これらのチュートリアルに取り組むことで、OpenTelemetry と New Relic を使用して独自のアプリをセットアップするのに役立つスキルを習得できます。

<img
  title="Screenshot showing various JVM metric charts"
  alt="Screenshot showing various JVM metric charts"
  src={opentelemetryTraceDurationDemoChart}
/>

<figcaption>
  これらのチュートリアルのいずれかを終了すると、JVM メトリックを次のようなグラフで表示できます。
</figcaption>

## 要件 [#requirements]

始めるには、次のものが揃っていることを確認してください。

* New Relic アカウント:[無料アカウント](https://newrelic.com/signup)をまだお持ちでない場合は、サインアップしてください。
* Java 17 以降: まだお持ちでない場合は、こちら[のダウンロード オプション](https://www.java.com/en/download/manual.jsp)を参照してください。

## チュートリアル [#tutorials]

各チュートリアルでは同じデモ アプリを使用しますが、OpenTelemetry と New Relic に慣れるのに役立つ異なるアプローチが用意されています。

* **Pre-instrumented app** \[事前にインスツルメントされたアプリ]: 事前にインスツルメントされたデモ アプリを実行すると、UI でデータを簡単に確認できます。
* **OpenTelemetry Java agent** \[OpenTelemetry Java エージェント]: OpenTelemetry Java エージェントを使用してデモ アプリを監視します。
* **Manual setup** \[手動セットアップ]: デモ アプリを手動で計測します。

完了したいチュートリアルに応じて、下のタブをクリックしてください。

<Callout variant="tip">
  OpenTelemetry を使用する場合、OTLP 経由でアプリケーションから New Relic にデータをエクスポートするには 2 つの選択肢があります。

  * アプリから New Relic に直接
  * アプリは OpenTelemetry Collector にデータを送信し、そこで New Relic にエクスポートされます。

  これらのチュートリアルでは、最初のオプションについて説明します。コレクター経由でデータをエクスポートする場合は、この[コレクターのドキュメントで](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/collector/opentelemetry-collector-basic/)詳細を確認してください。
</Callout>

<Tabs>
  <TabsBar>
    <TabsBarItem id="pre-instrumented-tutorial">
      事前にインストルメント化されたアプリ
    </TabsBarItem>

    <TabsBarItem id="java-agent-tutorial">
      OpenTelemetry Java エージェント
    </TabsBarItem>

    <TabsBarItem id="manual-setup-tutorial">
      手動セットアップ
    </TabsBarItem>
  </TabsBar>

  <TabsPages>
    <TabsPageItem id="pre-instrumented-tutorial">
      ### 事前にインストルメント化されたデモ アプリを実行する [#pre-instrum]

      これは、New Relic にデータを送信して UI で表示することがどのようなものかをすぐに確認できるように、インストルメンテーションを当社に実行してもらいたい場合に最適なオプションです。

      1. ターミナルで次のコマンドを実行してデモ アプリのクローンを作成し、Getting Started Guides の`java`ディレクトリに移動します。

         ```bash
         git clone https://github.com/newrelic/newrelic-opentelemetry-examples.git
         cd newrelic-opentelemetry-examples/getting-started-guides/java
         ```

      2. 次の 2 つの環境変数を設定して、New Relic アカウントにデータを送信します。

         * 必ず使用してください <InlinePopover type="licenseKey"/>.

         * New Relic データセンターのリージョンが EU で US ではない場合、エンドポイントを次のように設定します。 `https://otlp.eu01.nr-data.net`

           * `OTEL_EXPORTER_OTLP_HEADERS=api-key=INSERT_YOUR_NEW_RELIC_LICENSE_KEY`
           * `OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.nr-data.net`
           * `OTEL_EXPORTER_OTLP_PROTOCOL=http/protobuf`

      3. 以下の最初の環境変数を設定してサービスに名前を付け、次に 2 番目の環境変数をサービス インスタンス ID に設定します。これにより、特定のプラットフォーム機能がアクティブになります。デフォルトではログがオフになっているため、最後にログを有効にします。

         * `OTEL_SERVICE_NAME=getting-started-java`

         * `OTEL_RESOURCE_ATTRIBUTES=service.instance.id=INSERT_YOUR_ID_HERE`

           * `INSERT_YOUR_OWN_ID_HERE`一意のインスタンス ID に置き換えます。たとえば、1234 を使用できます。

         * `OTEL_LOGS_EXPORTER=otlp`

      4. 同じ`getting-started-guides/java`ディレクトリで、アプリケーションをビルドして実行します。

         * マックOS：

           ```bash
           ./gradlew bootRun
           ```

         * パワーシェル：

           ```bash
           .\gradlew.bat build
           ```

      5. 新しいターミナル タブを開き、 `getting-started-guides/java/Instrumented`ディレクトリに切り替え、次のコマンドを実行してアプリケーションへのトラフィックを生成します:

         * マックOS：

           ```bash
           ./load-generator.sh
           ```

         * パワーシェル：

           ```bash
           .\load-generator.ps1
           ```

         <Callout variant="tip">
           または、ブラウザの次の URL でエンドポイントにアクセスできます: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE` 。`INSERT_A_VALUE`を 1 から 90 の値に置き換えます。エラーを生成するには、有効範囲外の整数を挿入します。
         </Callout>

      6. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > APM & services**に移動します。

      7. `getting-started-java`という新しいエンティティ (サービス) をクリックして、UI を調べます。UI で何を探すべきかについてのその他のヒントについて[は、New Relic でデータを表示する](#view-data)を参照してください。

      8. UI でデータを見終わったら、両方のターミナル セッションで CONTROL+C を押してアプリケーションをシャットダウンします。
    </TabsPageItem>

    <TabsPageItem id="java-agent-tutorial">
      ### OpenTelemetry Java エージェントを使用してデモ アプリを監視する [#java-agent]

      これは、同じデモ アプリを使用する別のチュートリアルです。この場合、OpenTelemetry Java エージェントを使用して、デモ アプリを自動的に監視します。Java ソース コードを変更する必要はありません。エージェントを使用すると、New Relic へのサンプル データのエクスポートをすぐに開始できます。

      自動インスツルメンテーション エージェントは、バイトコードを動的に挿入して一般的なライブラリやフレームワークからテレメトリを取得する JAR ファイルです。また、インバウンド要求、アウトバウンド HTTP 呼び出し、およびデータベース呼び出しなどのデータをキャプチャするためにも使用できます。任意の Java 8+ アプリケーションにアタッチできます。

      <Callout variant="tip">
        追加の構成オプションについては、 [Java エージェントの公式ドキュメント](https://opentelemetry.io/docs/instrumentation/java/automatic/)を参照してください。
      </Callout>

      OpenTelemetry Java エージェントを使用してデモ アプリを監視するには:

      1. エージェントとインストルメンテーション ライブラリを含む[エージェント JAR ファイル](https://github.com/open-telemetry/opentelemetry-java-instrumentation/releases/latest/download/opentelemetry-javaagent.jar)をダウンロードします。好みのディレクトリに配置し、後で使用するパスを書き留めます。

      2. まだ行っていない場合は、デモ アプリケーション リポジトリをダウンロードして、次のディレクトリに切り替えます。

         ```bash
         git clone https://github.com/newrelic/newrelic-opentelemetry-examples.git
         cd newrelic-opentelemetry-examples/getting-started-guides/java
         ```

      3. 次のコマンドでデモ アプリをビルドします。

         * マックOS：

           ```bash
           ./gradlew build
           ```

         * パワーシェル：

           ```bash
           .\gradlew.bat build
           ```

           <Callout variant="tip">
             ビルドが成功すると、結果として得られるアプリケーション JAR ファイルが `Uninstrumented/build/libs`にあり、その名前は `uninstrumented.jar`になります。
           </Callout>

      4. 以下の[環境変数の参照セクション](#ref-env-vars)に移動して、エクスポートする必要がある変数を確認してから、これらの手順に戻ります。

      5. `getting-started-guides/java/Uninstrumented`に進み、アプリでエージェントを起動します。

         <Callout variant="important">
           `path/to`を、以前にダウンロードした JAR ファイルの場所に置き換えます。
         </Callout>

         ```bash
         java -javaagent:path/to/opentelemetry-javaagent.jar \
              -jar ./build/libs/uninstrumented.jar
         ```

      6. `getting-started-guides/java/Uninstrumented`ディレクトリで新しいターミナルを開き、ロード ジェネレーターを実行して、アプリケーションへのトラフィックを生成します。

         * マックOS：

           ```bash
           ./load-generator.sh
           ```

         * パワーシェル：

           ```bash
           .\load-generator.ps1
           ```

         <Callout variant="tip">
           または、ブラウザの次の URL でエンドポイントにアクセスできます: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE` 。`INSERT_A_VALUE`を 1 から 90 の値に置き換えます。エラーを生成するには、有効範囲外の整数を挿入します。
         </Callout>

      7. New Relic にデータを[送信したので、UI でデータを表示する手順を](#view-data)参照してください。

      8. UI でデータを見終わったら、両方のターミナル セッションで CONTROL+C を押してアプリケーションをシャットダウンします。
    </TabsPageItem>

    <TabsPageItem id="manual-setup-tutorial">
      ### デモアプリを手動でセットアップする [#manual-instrum]

      このトラックでは、袖をまくって車のエンジンをいじります。これは、レポートされるテレメトリを最大限に制御し、その方法の詳細を確認したい場合にとるべきアプローチです。

      インストルメンテーションをデモ アプリに手動で挿入してテレメトリをキャプチャし、そのデータを New Relic にエクスポートするように SDK を設定します。

      <Callout variant="tip">
        SDK を手動で構成することもできますが、 [自動構成オプション](https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions/autoconfigure)を使用して SDK を構成する方法を紹介します。これにより、環境変数とシステム プロパティを使用してプロセスが簡素化されます。
      </Callout>

      <Steps>
        <Step>
          #### デモアプリケーションをダウンロードする [#download]

          デモ アプリをまだダウンロードしていない場合は、次を実行します。

          ```bash
          git clone https://github.com/newrelic/newrelic-opentelemetry-examples.git
          ```
        </Step>

        <Step>
          #### 依存関係のインストール [#dependencies]

          依存関係を追加するには:

          1. アプリケーション ディレクトリに移動します。

             ```bash
             cd newrelic-opentelemetry-examples/getting-started-guides/java/uninstrumented
             ```

          2. `build.gradle`を開きます。

          3. 次の強調表示された項目を`dependencies`ブロックに追加します (コード ブロック内を下にスクロールする必要がある場合があります)。

             ```gradle lineHighlight=29-42
             plugins {
                 id 'org.springframework.boot' version '2.7.5'
                 id 'io.spring.dependency-management' version '1.1.0'
                 id 'java'
             }

             java {
                 toolchain {
                     languageVersion = JavaLanguageVersion.of(17)
                 }
             }

             repositories {
                 mavenCentral()
             }

             bootRun {
                 mainClass.set 'com.example.demo.Application'
             }

             configurations.all {
                 exclude module: 'spring-boot-starter-logging'
             }

             dependencies {
                 implementation 'org.springframework.boot:spring-boot-starter-web'
                 implementation 'org.springframework.boot:spring-boot-starter-log4j2'

                 // OpenTelemetry core
                 implementation platform('io.opentelemetry:opentelemetry-bom:1.22.0')
                 implementation platform('io.opentelemetry:opentelemetry-bom-alpha:1.22.0-alpha')
                 implementation 'io.opentelemetry:opentelemetry-api'
                 implementation 'io.opentelemetry:opentelemetry-sdk'
                 implementation 'io.opentelemetry:opentelemetry-exporter-otlp'
                 implementation 'io.opentelemetry:opentelemetry-exporter-otlp-logs'
                 implementation 'io.opentelemetry:opentelemetry-sdk-extension-autoconfigure'

                 // OpenTelemetry instrumentation
                 implementation platform('io.opentelemetry.instrumentation:opentelemetry-instrumentation-bom-alpha:1.22.1-alpha')
                 implementation 'io.opentelemetry.instrumentation:opentelemetry-runtime-metrics'
                 implementation 'io.opentelemetry.instrumentation:opentelemetry-log4j-appender-2.17'
                 implementation 'io.opentelemetry.instrumentation:opentelemetry-spring-webmvc-6.0'
             }
             ```

          メモ：

          * `bom` (部品表) 依存関係は、特定のエコシステムの依存関係のバージョンを同期するために使用されます。OpenTelemetry は多数の Java コンポーネントを公開しているため、使用するコンポーネントが少数であろうと多数であろうと、これらはすべてのバージョンが確実に同期されるようにするのに役立ちます。
          * 残りの依存関係は、SDK、API、OTLP エクスポーター、および計測ライブラリへのアクセスを提供します。
          * spring-boot-starter-logging モジュールを除外する追加の構成があります。これにより、 `log4j-slf4j-impl cannot be present with log4j-to-slf4j`に関連するビルド エラー メッセージが表示されなくなります。
        </Step>

        <Step>
          #### autoconfigure 拡張機能を使用して SDK を構成する [#auto-config-ext]

          SDK を手動で構成することもできますが、プロセスが合理化されるため、自動構成拡張機能を使用することをお勧めします。

          1. アプリのソース コード ディレクトリに移動します。

             ```bash
             cd newrelic-opentelemetry-examples/getting-started-guides/java/uninstrumented/src/main/java/com/example/demo
             ```

          2. `Application.java`を開きます。

          3. 強調表示された行を挿入します。

             ```java lineHighlight=7-12,17-20
             @SpringBootApplication
             public class Application {

                 private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

                 public static void main(String[] args) {
                     // Build the SDK auto-configuration extension module
                     OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                             .setResultAsGlobal(false)
                             .build()
                             .getOpenTelemetrySdk();
                     Application.openTelemetry = openTelemetrySdk;

                     SpringApplication.run(Application.class, args);
                 }

                 @Bean
                 public OpenTelemetry openTelemetry() {
                     return openTelemetry;
                 }
             }
             ```

          4. 以下の[環境変数の参照セクション](#ref-env-vars)に移動して、エクスポートする必要がある変数を確認してから、これらの手順に戻ります。
        </Step>

        <Step>
          #### インストルメンテーション ライブラリの追加: トレース [#library-traces]

          `Application.java`で、トレース フィルタを登録して、強調表示されている Spring Web MVC のインストルメンテーションを追加します。

          ```java lineHighlight=22-26
          @SpringBootApplication
          public class Application {

              private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

              public static void main(String[] args) {
                  // Build the SDK auto-configuration extension module
                  OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                          .setResultAsGlobal(false)
                          .build()
                          .getOpenTelemetrySdk();
                  Application.openTelemetry = openTelemetrySdk;

                  SpringApplication.run(Application.class, args);
              }

              @Bean
              public OpenTelemetry openTelemetry() {
                  return openTelemetry;
              }

              // Add Spring WebMVC instrumentation by registering a tracing filter
              @Bean
              public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
                  return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
              }
          }
          ```
        </Step>

        <Step>
          #### インストルメンテーション ライブラリの追加: メトリクス [#library-metrics]

          `Application.java`ファイルに以下を登録して、Java ランタイムに関する指標を生成および収集します。以下の強調表示された行を挿入します。

          ```java lineHighlight=14-20
          @SpringBootApplication
          public class Application {

              private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

              public static void main(String[] args) {
                  // Build the SDK auto-configuration extension module
                  OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                          .setResultAsGlobal(false)
                          .build()
                          .getOpenTelemetrySdk();
                  Application.openTelemetry = openTelemetrySdk;

                  // Register runtime metrics instrumentation
                  BufferPools.registerObservers(openTelemetrySdk);
                  Classes.registerObservers(openTelemetrySdk);
                  Cpu.registerObservers(openTelemetrySdk);
                  GarbageCollector.registerObservers(openTelemetrySdk);
                  MemoryPools.registerObservers(openTelemetrySdk);
                  Threads.registerObservers(openTelemetrySdk);

                  SpringApplication.run(Application.class, args);
              }

              @Bean
              public OpenTelemetry openTelemetry() {
                  return openTelemetry;
              }

              // Add Spring WebMVC instrumentation by registering a tracing filter
              @Bean
              public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
                  return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
              }
          }
          ```
        </Step>

        <Step>
          #### インストルメンテーション ライブラリの追加: ログ [#library-logs]

          このデモ アプリケーションは、 `GlobalLoggerProvider` を使用する`OpenTelemetryAppender`を( `log4j.xml`経由で) 使用するように構成されています。`GlobalLoggerProvider`を設定すると、ここで autoconfigure を使用して構成された Log SDK に`OpenTelemetryAppender`が接続されます。

          1. `Application.java`を開きます。

          2. 次の強調表示された行を挿入します。

             ```java lineHighlight=14-15
             @SpringBootApplication
             public class Application {

                 private static volatile OpenTelemetry openTelemetry = OpenTelemetry.noop();

                 public static void main(String[] args) {
                     // Build the SDK auto-configuration extension module
                     OpenTelemetrySdk openTelemetrySdk = AutoConfiguredOpenTelemetrySdk.builder()
                             .setResultAsGlobal(false)
                             .build()
                             .getOpenTelemetrySdk();
                     Application.openTelemetry = openTelemetrySdk;

                     // Set GlobalLoggerProvider, which is used by Log4j2 appender
                     GlobalLoggerProvider.set(openTelemetrySdk.getSdkLoggerProvider());

                     // Register runtime metrics instrumentation
                     BufferPools.registerObservers(openTelemetrySdk);
                     Classes.registerObservers(openTelemetrySdk);
                     Cpu.registerObservers(openTelemetrySdk);
                     GarbageCollector.registerObservers(openTelemetrySdk);
                     MemoryPools.registerObservers(openTelemetrySdk);
                     Threads.registerObservers(openTelemetrySdk);

                     SpringApplication.run(Application.class, args);
                 }

                 @Bean
                 public OpenTelemetry openTelemetry() {
                     return openTelemetry;
                 }

                 // Add Spring WebMVC instrumentation by registering a tracing filter
                 @Bean
                 public Filter webMvcTracingFilter(OpenTelemetry openTelemetry) {
                     return SpringWebMvcTelemetry.create(openTelemetry).createServletFilter();
                 }
             }
             ```

          3. `Uninstrumented/src/main`に`resources`というディレクトリを作成します。

          4. この新しいディレクトリに、次の内容の`log4j2.xml`というファイルを作成します:

             ```xml
             <?xml version="1.0" encoding="UTF-8"?>
             <Configuration status="WARN" packages="io.opentelemetry.instrumentation.log4j.appender.v2_17">
               <Appenders>
                 <Console name="ConsoleAppender" target="SYSTEM_OUT" follow="true">
                   <PatternLayout pattern="%d{yyyy-mm-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
                 </Console>
                 <OpenTelemetry name="OpenTelemetryAppender" />
               </Appenders>
               <Loggers>
                 <Root level="info">
                   <AppenderRef ref="OpenTelemetryAppender" />
                   <AppenderRef ref="ConsoleAppender" />
                 </Root>
               </Loggers>
             </Configuration>
             ```

             <Callout variant="tip">
               この行の`packages=...`セクションにより、Log4J は`OpenTelemetryAppender`を見つけて構成できます。ソース コードは[OpenTelemetry リポジトリ](https://github.com/open-telemetry/opentelemetry-java-instrumentation/tree/main/instrumentation/log4j/log4j-appender-2.17/library)にあり、 `io.opentelemetry.instrumentation:opentelemetry-log4j-appender-2.17`を介して依存関係として追加されました)
             </Callout>
        </Step>

        <Step>
          #### カスタム トレース インストルメンテーション: スパン属性定数の作成 [#custom-attribs]

          各トレースはスパンで構成されています。スパンは、作業の論理単位または特定の要求内の操作を表します。以下のコードは、次のことを示しています。

          * スパンでリクエストレベルの洞察を提供するために使用できる属性キーを保持する静的定数
          * スパンを作成する[Tracer](https://opentelemetry.io/docs/concepts/signals/traces/#tracer)を初期化する方法

          次の強調表示された行を`Controller.java`に挿入します。

          ```java lineHighlight=4-14
          @RestController
          public class Controller {

              // Attribute constants
              private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
              private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");

              private final Tracer tracer;

              @Autowired
              Controller(OpenTelemetry openTelemetry) {
                  // Initialize tracer
                  tracer = openTelemetry.getTracer(Controller.class.getName());
              }

              @GetMapping(value = "/fibonacci")
              . . .
          }
          ```
        </Step>

        <Step>
          #### カスタム トレース インストルメンテーション: カスタム スパンの作成 [#cust-span]

          必要なスパンを作成できます。特定の操作に関する属性でスパンに注釈を付けるのはあなた次第です。設定した属性は、結果や操作のプロパティなど、追跡している特定の操作に関する追加のコンテキストを提供します。

          1. `Controller.java`で、これらの強調表示された行を挿入して、 `fibonacci`という名前の新しいスパンを開始します。これは次のことを行います:

             * このメソッドの実行に関するデータをキャプチャします
             * ユーザーのリクエストから n の値を格納する属性を設定します

             ```java lineHighlight=2-3
             private long fibonacci(long n) {
                 // Start a new span and set your first attribute
                 var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();
                 . . .
             }
             ```

          2. 成功したリクエストに関する情報を保存する属性をスパンに追加して、コードに詳細を追加します。

             ```java lineHighlight=20-21
             private long fibonacci(long n) {
                 // Start a new span and set your first attribute
                 var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();

                 try {
                     if (n < 1 || n > 90) {
                         throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                     }

                     long result = 1;
                     if (n > 2) {
                     long a = 0;
                     long b = 1;

                     for (long i = 1; i < n; i++) {
                         result = a + b;
                         a = b;
                         b = result;
                     }
                     // Set a span attribute to capture information about successful requests
                     span.setAttribute(ATTR_RESULT, last);
                     return last;
                 } catch (IllegalArgumentException e) {
                     throw e;
                 }
             }
             ```
        </Step>

        <Step>
          #### カスタム トレース インストルメンテーション: 例外を記録する [#span-exception]

          発生した例外を記録したい場合があります。これは、スパン ステータスの設定と併せて行うことをお勧めします。まず、スパンを現在のスパンとして設定し、例外が発生した場合にステータス コードをエラーに設定してから、スパンを終了します。

          ```java lineHighlight=5-6,26-27,29-32
          private long fibonacci(long n) {
              // Start a new span and set your first attribute
              var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();

              // Set the span as the current span
              try (var scope = span.makeCurrent()) {
                  if (n < 1 || n > 90) {
                      throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                  }

                  long result = 1;
                  if (n > 2) {
                      long a = 0;
                      long b = 1;

                      for (long i = 1; i < n; i++) {
                          result = a + b;
                          a = b;
                          b = result;
                      }
                  }
                  // Set a span attribute to capture information about successful requests
                  span.setAttribute(ATTR_RESULT, result);
                  return result;
              } catch (IllegalArgumentException e) {
                  // Record the exception and set the span status
                  span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
                  throw e;
              } finally {
                  // End the span
                  span.end();
              }
          }
          ```

          ユーザーが無効な入力を提供した場合、このメソッドは`IllegalArgumentException`をスローします。これが発生すると、例外がスパンのイベントとして記録され、スパンのステータスが`ERROR`に設定されます。例外メッセージは、ステータスの説明としてキャプチャされます。例外は、発生したスパンでイベントとして記録されます。

          最後に、 `ErrorHandler`クラスの`handleException()`で、次の強調表示された行でスパンのステータスを`ERROR`に設定します。

          ```java lineHighlight=10-11
          @ControllerAdvice
          private static class ErrorHandler {

              @ExceptionHandler({
                  IllegalArgumentException.class,
                  MissingServletRequestParameterException.class,
                  HttpRequestMethodNotSupportedException.class
              })
              public ResponseEntity<Object> handleException(Exception e) {
                  // Set the span status and description
                  Span.current().setStatus(StatusCode.ERROR, e.getMessage());
                  return new ResponseEntity<>(Map.of("message", e.getMessage()), HttpStatus.BAD_REQUEST);
              }
          }
          ```

          前の手順と同様に、これにより、ユーザーが無効な数値を入力した場合にスパンのステータス コードが設定されます。ただし、これは`fibonacci()`ではなく例外ハンドラで発生するため、現在のスパンがリクエストの親スパンになります。この親スパンは、Application クラスのフィルターを介して追加された Spring Web MVC インストルメンテーションから取得されます。これで、アプリケーション エンドポイントが例外を発生させると、親スパンと子スパンの両方のスパン ステータスが`ERROR`になります。
        </Step>

        <Step>
          #### カスタム メトリック インストルメンテーション: カスタム メトリック カウンターを追加します。 [#metrics-cust]

          メトリックは、個々の測定値を集計に結合し、システム負荷の関数として一定のデータを生成するため、非常に役立つテレメトリ データ タイプです。このデータをスパンと組み合わせて使用すると、傾向を特定し、アプリケーションのランタイム テレメトリを提供できます。また、メトリクスが表す測定値の下位区分を説明するのに役立つ属性でメトリクスに注釈を付けることもできます。

          OpenTelemetry メトリクス API は、メトリクス SDK によって集計され、アウト オブ プロセスでエクスポートされる測定値を記録する多数の計測器を定義します。器具には次の 2 種類があります。

          * 同期: これらの計測器は、発生時に測定値を記録します。
          * 非同期: これらの計測器はコールバックを登録します。これはコレクションごとに 1 回だけ呼び出され、関連付けられたコンテキストはありません。

          <Callout variant="tip">
            OpenTelemetry プロジェクトのメトリックのステータスについて質問がある場合は、[シグナル ステータス](https://opentelemetry.io/docs/instrumentation/java/#status-and-releases)を参照してください。
          </Callout>

          カスタム カウンターを追加するには、次の手順を実行します。

          1. カスタム メトリックのブール属性をインスタンス化し、メトリック インストルメントを初期化します。<Callout variant="tip">この場合、 [LongCounter](https://opentelemetry.io/docs/instrumentation/java/manual/#metrics)を使用しています。これは正の値のみを記録し、ネットワーク経由で送信されたバイト数などをカウントするのに役立ちます。デフォルトでは、カウンタ測定値は単調 (常に増加) 合計に集計されます。</Callout>

             ```java lineHighlight=7,10,16-21
             @RestController
             public class Controller {

                 // Attribute constants
                 private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
                 private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");
                 private static final AttributeKey<Boolean> ATTR_VALID_N = AttributeKey.booleanKey("fibonacci.valid.n");

                 private final Tracer tracer;
                 private final LongCounter fibonacciInvocations;

                 @Autowired
                 Controller(OpenTelemetry openTelemetry) {
                     // Initialize tracer
                     tracer = openTelemetry.getTracer(Controller.class.getName());
                     // Initialize instrument
                     Meter meter = openTelemetry.getMeter(Controller.class.getName());
                     fibonacciInvocations = meter
                         .counterBuilder("fibonacci.invocations")
                         .setDescription("Measures the number of times the fibonacci method is invoked.")
                         .build();
                 }
                 . . .
             }
             ```

          2. 次の強調表示された行を挿入して、カスタム カウンターが有効な入力と無効な入力、およびそれぞれの発生回数をキャプチャできるようにします。

             ```java lineHighlight=24-25,30-31
             private long fibonacci(long n) {
                 // Start a new span and set your first attribute
                 var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();

                 // Set the span as the current span
                 try (var scope = span.makeCurrent()) {
                     if (n < 1 || n > 90) {
                         throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                     }

                     long result = 1;
                     if (n > 2) {
                         long a = 0;
                         long b = 1;

                         for (long i = 1; i < n; i++) {
                             result = a + b;
                             a = b;
                             b = result;
                         }
                     }
                     // Set a span attribute to capture information about successful requests
                     span.setAttribute(ATTR_RESULT, result);
                     // Counter to increment the number of times a valid input is recorded
                     fibonacciInvocations.add(1, Attributes.of(ATTR_VALID_N, true));
                     return result;
                 } catch (IllegalArgumentException e) {
                     // Record the exception and set the span status
                     span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
                     // Counter to increment the number of times an invalid input is recorded
                     fibonacciInvocations.add(1, Attributes.of(ATTR_VALID_N, false));
                     throw e;
                 } finally {
                     // End the span
                     span.end();
                 }
             }
             ```
        </Step>

        <Step>
          #### カスタムログ計測 [#cust-log]

          OpenTelemetry Java のログ シグナルのステータスは、現在[実験](https://opentelemetry.io/docs/instrumentation/java/#status-and-releases)段階です。ログ メッセージはアプリのルート ハンドラによって管理され、デフォルトで`INFO`レベル以上のログがコンソールに送信されます。ただし、特定のクラスを含めてロギング レベルを変更するか、カスタム ハンドラまたはフィルタをインストールすることで、ロガーの動作を変更できます。

          ##### ロガーを初期化する [#initialize-logger]

          前述のとおり、これは`java.util.logging`ライブラリからのものです。Logger は OpenTelemetry コンポーネントではありませんが、アプリケーションは Log4j ログを OpenTelemetry Log SDK に送信するように構成されています。

          ```java lineHighlight=4-5
          @RestController
          public class Controller {

              // Logger (note that this is not an OTel component)
              private static final Logger LOGGER = LogManager.getLogger(Controller.class);

              // Attribute constants
              private static final AttributeKey<Long> ATTR_N = AttributeKey.longKey("fibonacci.n");
              private static final AttributeKey<Long> ATTR_RESULT = AttributeKey.longKey("fibonacci.result");
              private static final AttributeKey<Boolean> ATTR_VALID_N = AttributeKey.booleanKey("fibonacci.valid.n");
              . . .
          }
          ```

          ##### カスタム ログ メッセージを追加する [#cust-log-messages]

          ロガーを初期化したら、ロガーを使用して次のことを記録できます。

          * 有効な入力の結果とその結果の値
          * 出力が記録されなかった場合

          次の強調表示された行を挿入します。

          ```java lineHighlight=26-27,34-35
          private long fibonacci(long n) {
              // Start a new span and set your first attribute
              var span = tracer.spanBuilder("fibonacci").setAttribute(ATTR_N, n).startSpan();

              // Set the span as the current span
              try (var scope = span.makeCurrent()) {
                  if (n < 1 || n > 90) {
                      throw new IllegalArgumentException("n must be 1 <= n <= 90.");
                  }

                  long result = 1;
                  if (n > 2) {
                      long a = 0;
                      long b = 1;

                      for (long i = 1; i < n; i++) {
                          result = a + b;
                          a = b;
                          b = result;
                      }
                  }
                  // Set a span attribute to capture information about successful requests
                  span.setAttribute(ATTR_RESULT, result);
                  // Counter to increment the number of times a valid input is recorded
                  fibonacciInvocations.add(1, Attributes.of(ATTR_VALID_N, true));
                  // Log the result of a valid input
                  LOGGER.info("Compute fibonacci(" + n + ") = " + result);
                  return result;
              } catch (IllegalArgumentException e) {
                  // Record the exception and set the span status
                  span.recordException(e).setStatus(StatusCode.ERROR, e.getMessage());
                  // Counter to increment the number of times an invalid input is recorded
                  fibonacciInvocations.add(1, Attributes.of(ATTR_VALID_N, false));
                  // Log when no output was recorded
                  LOGGER.info("Failed to compute fibonacci(" + n + ")");
                  throw e;
              } finally {
                  // End the span
                  span.end();
              }
          }
          ```
        </Step>

        <Step>
          #### アプリを実行してトラフィックを生成する [#exercise-app]

          New Relic にデータを送信する準備ができました!

          1. ディレクトリ`getting-started-guides/java`に移動し、次のコマンドでアプリをビルドして実行します:

             * マックOS：

               ```bash
               ./gradlew bootRun
               ```

             * パワーシェル：

               ```bash
               .\gradlew.bat build
               ```

               <Callout variant="tip">
                 端末に Spring ASCII が表示された場合は、アプリが正常にビルドされ、実行されていることを意味します。

                 <img
                   alt="Screenshot showing Spring Boot ASCII logo"
                   title="Screenshot showing Spring Boot ASCII logo"
                   src={opentelemetrySpringBootASCIIDisplay}
                 />
               </Callout>

          2. `getting-started-guides/java/Uninstrumented`ディレクトリで新しいターミナルを開き、ロード ジェネレータを実行して、アプリケーションからトラフィックを生成します。

             * マックOS：

               ```bash
               ./load-generator.sh
               ```

             * パワーシェル：

               ```bash
               .\load-generator.ps1
               ```

             <Callout variant="tip">
               または、ブラウザの次の URL でエンドポイントにアクセスできます: `http://localhost:8080/fibonacci?n=INSERT_A_VALUE` 。`INSERT_A_VALUE`を 1 から 90 の値に置き換えます。エラーを生成するには、有効範囲外の整数を挿入します。
             </Callout>

          3. New Relic にデータを[送信したので、UI でデータを表示する手順を](#view-data)参照してください。
        </Step>
      </Steps>
    </TabsPageItem>
  </TabsPages>
</Tabs>

## New Relic でデモ データを表示する [#view-data]

どのチュートリアルを完了しても、New Relic UI でデータを見つけるための以下のヒントに従うことができます。

1. **[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > APM & services**に移動します。
2. `getting-started-java`という名前の新しいエンティティ (サービス) (または任意の名前) をクリックします。
3. 各データ型のセクションで詳細を確認してください。

<Callout variant="tip">
  Windows を使用していて、New Relic アカウントにデータが表示されない場合は、ファイアウォールを通過するトラフィックが許可されていることを確認してください。
</Callout>

### トレース [#traces]

New Relic で`getting-started-java`エンティティに到達したら:

1. 左側のペインの**Monitor** \[モニター]セクションで、 **Distributed tracing** \[分散トレーシング]をクリックし、 **Fibonacci** \[フィボナッチ]トレース グループをクリックします。

   <img alt="Screenshot showing the main distributed tracing page" title="Screenshot showing the main distributed tracing page" src={opentelemetryMainDistributedTracingPage}/>

2. そこから、エラーのあるトレースを見つけてクリックして開きます。

   <img alt="Screenshot showing an error in distributed tracing" title="Screenshot showing an error in distributed tracing" src={opentelemetryDistributedTracingError}/>

3. トレースを開いたら、 `Show in-process spans`をクリックし、結果のスパンをクリックすると、右側に詳細パネルが開きます。ユーザー入力が無効な場合に記録した例外を確認するには、 `View span events`をクリックします。

   <img title="Screenshot of in-process spans" alt="Screenshot of in-process spans" src={opentelemetryInProcessSpans}/>

手動インストルメンテーション チュートリアルを完了した場合、スパンとして記録した例外が New Relic でどのように表示されるかを以下に示します。

<img
  title="Screenshot showing an exception as a span event"
  alt="Screenshot showing an exception as a span event"
  src={opentelemetryExceptiononSpanEvent}
/>

スパン属性、スパン名、ステータス コードなど、設定した追加の詳細を表示するには、\[**属性**] タブをクリックします。このペインでは、このガイドで使用したインストルメンテーション ライブラリによって自動的に収集される追加のメタデータと、New Relic によって添付されたメタデータを表示することもできます。

<img
  title="Screenshot of the attributes tab"
  alt="Screenshot of the attributes tab"
  src={opentelemetryAttributesTab}
/>

データの表示の詳細について[は、New Relic UI の OpenTelemetry を](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page)参照してください。

### 指標 [#metrics]

New Relic の`getting-started-java`エンティティに到達すると、ランタイム メトリック (JVM) やカスタム カウンター属性など、収集されたすべてのメトリックのリストが表示されます。

#### メトリクスエクスプローラー [#metrics-explorer]

これは、メトリックのリストを表示できるツールです。

1. 左側のペインで、\[**データ] > \[メトリクス エクスプローラー]**を選択し、\[ `fibonacci.invocations` ] を選択します。

   <img
     title="Screenshot showing metrics explorer"
     alt="Screenshot showing metrics explorer"
     src={opentelemetryMetricsExplorerMain}
   />

2. \[**ディメンション**] で、収集した属性とカスタム メトリックを表示し、 **fibonacci.valid.n**をクリックします。

   <img
     title="Screenshot showing the total number of invocations of fibonacci function"
     alt="Screenshot showing the total number of invocations of fibonacci function"
     src={opentelemetryMetricsExplorerDimensions}
   />

詳しくは、 [メトリクス エクスプローラー ビュー](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-metrics-explorer-page)に関するドキュメントをご覧ください。

#### JVM [#jvms]

また、JVM ページに移動して、スループット、メモリ使用量、1 分あたりのガベージ コレクション時間など、Java ランタイム メトリックの視覚化を表示することもできます。

<img
  title="Screenshot of the main JVMs page"
  alt="Screenshot of the main JVMs page"
  src={opentelemetryJvmsPageMain}
/>

単一のインスタンスのメトリックを表示するか、複数のインスタンスを選択して比較できます。

<img
  title="Screenshot of how to compare JVM instances"
  alt="Screenshot of how to compare JVM instances"
  src={opentelemetryCompareJvmInstances}
/>

インスタンスを選択して \[**比較**] をクリックすると、次のように表示されます。各インスタンスは簡単に識別できるように色分けされています。

<img
  title="Screenshot showing the color-coded JVM comparison"
  alt="Screenshot showing the color-coded JVM comparison"
  src={opentelemetryJvmColorCodedComparison}
/>

詳細については、 [JVM ビュー](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-jvms-page/)に関するドキュメントを参照してください。

### ログ [#logs]

ログにアクセスする場所は次のとおりです。

<img
  title="Screenshot showing the main logs page"
  alt="Screenshot showing the main logs page"
  src={opentelemetryMainLogsPage}
/>

ターミナルにもログが表示されます。

<img
  title="Screenshot showing logs in a terminal"
  alt="Screenshot showing logs in a terminal"
  src={opentelemetryLogsinTerminal}
/>

ログ ビューに戻り、ログを選択すると、ログ メッセージと、関連するスパンやトレース ID などの収集された追加の属性、および New Relic によって挿入されたメタデータが表示されたペインが開きます。

<img
  title="Screenshot showing log details with trace"
  alt="Screenshot showing log details with trace"
  src={opentelemetryLogDetailsWithTrace}
/>

この小さな青いアイコンをクリックすると、相関分散トレースに移動できます。

<img
  title="Screenshot showing how to find correlated trace"
  alt="Screenshot showing how to find correlated trace"
  src={opentelemetryTraceRelatedtoLog}
/>

これにより、相関トレースを表示するペインが開き、トレースに関する詳細を表示できます。このページの詳細について[は、UI の OpenTelemetry: 分散トレース ページ](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-distributed-tracing-page/)および[分散トレース UI の理解と使用](/docs/distributed-tracing/ui-data/understand-use-distributed-tracing-ui/)を参照してください。

<img
  title="Screenshot showing the trace waterfall from the logs section"
  alt="Screenshot showing the trace waterfall from the logs section"
  src={opentelemetryTraceWaterfallFromLog}
/>

分散トレース ビューから相関ログを見つけることもできます。対応するログを持つトレースを選択すると、それがタブとして示され、ビューを切り替えることなくトレースから直接ログを表示できます。

<img
  title="Screenshot showing how to see log details from a trace span"
  alt="Screenshot showing how to see log details from a trace span"
  src={opentelemetryLogCapturedinTraceSpan}
/>

ログ ビューの詳細については、 [こちら](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/view-your-data/opentelemetry-logs-page)をご覧ください。

## 参考：環境変数 [#ref-env-vars]

これは、チュートリアル 2 または 3 を実行している場合にエクスポートする必要がある環境変数のリストです。変数のエクスポートが完了したら、変数リストに続くリンクを使用してチュートリアルに戻ります。

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="env-vars-table"
    title="ここをクリックして環境変数のリストを開きます"
  >
    <table>
      <tbody>
        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_HEADERS=api-key=YOUR_LICENSE_KEY`

            * ヘッダー: これにより、データが送信される New Relic アカウントが決まります。`YOUR_LICENSE_KEY`をあなたの

              <InlinePopover type="licenseKey"/>

              .
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.nr-data.net` (米国の場合) `OTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.eu01.nr-data.net` (EU の場合)

            * これは、アプリケーション テレメトリのエクスポート先となるエンドポイントです。New Relic の OTLP エンドポイントにデータをエクスポートします。
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_PROTOCOL=http/protobuf`

            * これは、New Relic が推奨する OTLP `http/protobuf`を使用することを指定します。
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_SERVICE_NAME=getting-started-java`

            * これは、アプリケーション テレメトリを New Relic のエンティティに関連付ける名前です。このチュートリアルでは`getting-started-java`と呼んでいますが、任意の名前にすることができます。
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_RESOURCE_ATTRIBUTES=service.instance.id=INSERT_YOUR_OWN_ID_HERE`

            * `INSERT_YOUR_OWN_ID_HERE`一意のインスタンス ID に置き換えます。たとえば、 `1234`を使用できます。詳細については、「OpenTelemetry の[リソース セマンティック規則」](https://github.com/open-telemetry/semantic-conventions/blob/main/docs/resource/README.md#service-experimental)を参照してください。
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT=4095`

            * 属性値の最大長に制限を設定すると、 [New Relic の制限](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/best-practices/opentelemetry-best-practices-attributes/)を超えた場合にスパン データがドロップされるのを防ぐことができます。
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE=DELTA`

            * New Relic は、デフォルトの累積ではなく、デルタ一時性のメトリクスをサポートします。
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_METRICS_DEFAULT_HISTOGRAM_AGGREGATION=BASE2_EXPONENTIAL_BUCKET_HISTOGRAM`

            * (推奨) ヒストグラム集約: データ圧縮を向上させるために、既定の明示的なバケット ヒストグラムの代わりに指数ヒストグラムを使用します。
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_LOGS_EXPORTER=otlp`

            * OTLP 経由のログ エクスポートを有効にします。ログのエクスポートはデフォルトで無効になっています。
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPORTER_OTLP_COMPRESSION=gzip`

            * (推奨) gzip 圧縮を設定すると、リクエストごとに送信できるデータ量を最大化できます。最大許容ペイロード サイズは 1MB (10^6 バイト) です。Gzip 圧縮はパフォーマンスが高く、データ出力が低くなります。
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPERIMENTAL_EXPORTER_OTLP_RETRY_ENABLED=true`

            * (推奨) 実験的なエクスポートの再試行を有効にして、インターネットの信頼性の低さに対処します。
          </td>
        </tr>

        <tr>
          <td>
            `OTEL_EXPERIMENTAL_RESOURCE_DISABLED_KEYS=process.command_line`

            * (推奨) これにより、多くの場合、New Relic の最大属性長制限を超え、機密情報が含まれている可能性がある`process.command_line`リソース属性が無効になります。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

上記のコラプスにリストされている環境変数を作成したら、チュートリアルに戻ってセットアップを完了します。

* [チュートリアル 2 (OpenTelemetry Java エージェントを使用してデモ アプリを監視する)](#java-agent)
* [チュートリアル 3 (デモ アプリを手動でセットアップする)](#auto-config-ext)

## 次は何ですか？ [#what-next]

OpenTelemetry インストルメンテーションと SDK 構成を試したので、学んだことを適用して、OpenTelemetry と New Relic を使用して独自のアプリまたはサービスをセットアップできます。詳細については[、OpenTelemetry を使用して独自のアプリまたはサービスをセットアップする](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/get-started/opentelemetry-set-up-your-app)を参照してください。