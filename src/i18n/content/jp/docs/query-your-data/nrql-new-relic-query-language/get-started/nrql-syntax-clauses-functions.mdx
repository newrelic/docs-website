---
title: NRQLの構文、句、関数
tags:
  - Query your data
  - 'NRQL: New Relic Query Language'
  - Get started
metaDescription: 'A detailed reference list of clauses and functions in NRQL, the New Relic query language.'
translationType: human
---

import queriesnrqlApdexNRQLQueryBuilder from 'images/queries-nrql_screenshot-full_apdex-NRQL-query-builder.png'

import lowerExample from 'images/lowerExample.png'

import percentile0 from 'images/percentile_0.png'

import positionExample from 'images/positionExample.png'

import queriesnrqlPercentileNRQLQueryBuilder from 'images/queries-nrql_screenshot-full_percentile-NRQL-query-builder.png'

import queriesnrqlFilterNRQLQueryBuilder from 'images/queries-nrql_screenshot-full_filter-NRQL-query-builder.png'

import screenshotInsightsFilter00 from 'images/screenshot_insights_filter_0_0.png'

import substringExample from 'images/substringExample.png'

import upperExample from 'images/upperExample.png'

NRQLは、New Relicデータベースのクエリに使用できるクエリ言語です。このドキュメントでは、NRQLの構文、句、構成要素、関数について説明します。

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="Getting started with New Relic"
    title="New Relicのご利用は初めてですか？"
  >
    New Relicを初めて使用する方で、NRQLの使用がいかに簡単かを確認したい場合は、無料のプラットフォームで、チュートリアルに従いながら開始できます。するべきことは、以下のとおりです。

    1. まだの場合は、[無料のアカウントにサインアップしてください](https://newrelic.com/signup)。
    2. 当社の[エージェントとインテグレーション](/docs/infrastructure/host-integrations/get-started/introduction-host-integrations/)を使用して、共通のフレームワークとツールから自動的にデータを収集します。
    3. New Relicの設定方法の推奨パスについては、[クイック起動ガイド](/docs/new-relic-solutions/get-started/quick-launch-guide)を参照してください。クエリするデータの取り込みを開始し、本チュートリアルまたは当社のいずれかのチュートリアルを使用して準備できます。
  </Collapser>
</CollapserGroup>

## 構文 [#syntax]

このリソースには、NRQLクエリで使用できるさまざまな関数と句の説明が含まれています。NRQLを理解するためのその他の人気リソース：

* [NRQLの概要](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql)：NRQL全体の概要と、他の入門ドキュメントへのリンクを提供します
* [NRQLの使用方法](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql-how-nrql-works)：NRQLの仕組みと、NRQLを使用してデータをクエリする方法を説明します
* [入門NRQLチュートリアル](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql-tutorial)：基本的なクエリに慣れるように設計されたNRQLの基本的なチュートリアル
* New Relic Universityの[NRQL教育コース](https://learn.newrelic.com/writing-nrql-queries)
* [`Metric`データ型のクエリ方法を習得](/docs/telemetry-data-platform/get-data/apis/query-metric-data-type)
* [サブクエリを使用](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql)
* [ファネルを使用して一連の関連データを評価する](/docs/insights/new-relic-insights/features/funnels)

## クエリの構成要素 [#clauses]

すべてのNRQLクエリは`SELECT`文または`FROM`句で始まります。その他のすべての句はオプションです。以下の句の定義には、NRQLクエリの例も含まれます。

### 必要な句 [#required]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="state-select"
    title={<>必須：<InlineCode>SELECT</InlineCode>文</>}
  >
    ```sql
    SELECT attribute ...
    ```

    ```sql
    SELECT function(attribute) ...
    ```

    `SELECT`は、[属性](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#attribute)または[関数](#functions)を指定することによって、データ型のどの部分をクエリするかを指定します。その後、カンマ区切りの1つ以上の引数が続きます。各引数では、以下を実行できます。

    * ワイルドカードとして`*`を使用することで、利用可能なすべての属性値を取得。例：`SELECT * from Transaction`。
    * 指定した属性、または [カンマ区切りのリスト](#commas)で指定した複数の属性に関連する値を取得。
    * [集計関数](#functions)を選択することで、指定した属性から集計値を取得。
    * [`AS`句](#sel-as)で、各引数で返された結果にラベル付け。

    [基本的な数学関数とともに`SELECT`を使用する](/docs/query-data/nrql-new-relic-query-language/getting-started/nrql-math-using-select)こともできます。

    <CollapserGroup>
      <Collapser
        id="avg-resp-time-query"
        title="直近1週間の平均レスポンスタイム"
      >
        このクエリは、直近1週間の平均応答時間を返します。

        ```sql
        SELECT average(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-from"
    title={<>必須：<InlineCode>FROM</InlineCode>句</>}
  >
    ```sql
    SELECT ...
      FROM data type
      ...
    ```

    `FROM`句を使用して、クエリする[データ型](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql#what-you-can-query)を指定します。クエリは`FROM`または[`SELECT`](#state-select)で開始できます。[カンマ区切りのリスト](#commas)の複数のデータタイプにまたがる同じ属性の値をマージできます。

    <CollapserGroup>
      <Collapser
        id="one-event"
        title="1つのデータ型のクエリ"
      >
        このクエリは、直近7日間の[APMトランザクション](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults)の全カウント数を返します。

        ```sql
        SELECT count(*) FROM Transaction SINCE 7 days ago
        ```
      </Collapser>

      <Collapser
        id="multiple-events"
        title="複数のデータ型のクエリ"
      >
        このクエリは、直近3日間の[APMトランザクション](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults)と[ブラウザイベント](/docs/insights/new-relic-insights/decorating-events/browser-default-attributes-insights#browser-attributes-table)の全カウント数を返します。

        ```sql
        SELECT count(*) FROM Transaction, PageView SINCE 3 days ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### オプション句 [#optional]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="sel-as"
    title={<><InlineCode>AS</InlineCode> 句</>}
  >
    ```sql
    SELECT ...
      AS 'label'
      ...
    ```

    `AS`句を使用して、シングルクォート区切りの文字列で属性、集計、ファネル内のステップ、または数学関数の結果にラベルを付けます。このラベルは結果のチャートで使用されます。

    <CollapserGroup>
      <Collapser
        id="math-as"
        title={<>数学関数とを使用したクエリ <InlineCode>AS</InlineCode></>}
      >
        このクエリはセッションごとのページ数を返します。

        ```sql
        SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session'
          FROM PageView
        ```
      </Collapser>

      <Collapser
        id="funnel-as"
        title={<>ファネルとを使用したクエリ <InlineCode>AS</InlineCode></>}
      >
        このクエリは、過去1週間でサイトのメインページと採用情報ページの両方を訪れた人の数を返します。

        ```sql
        SELECT funnel(SESSION,
            WHERE name='Controller/about/main' AS 'Step 1',
            WHERE name = 'Controller/about/careers' AS 'Step 2')
            FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-compare"
    title={<><InlineCode>COMPARE WITH</InlineCode> 句</>}
  >
    ```sql
    SELECT ... (SINCE or UNTIL) (integer units) AGO
      COMPARE WITH (integer units) AGO
      ...
    ```

    `COMPARE WITH`句を使用すると、2つの異なる時間範囲の値を比較できます。

    `COMPARE WITH` には`SINCE`または`UNTIL`文が必要です。`COMPARE WITH`で指定された時間は、`SINCE`または`UNTIL`で指定した時間に相対します。たとえば、`SINCE 1 day ago COMPARE WITH 1 day ago`昨日を一昨日と比較します。

    `COMPARE WITH`値の時間範囲は、常に`SINCE`または`UNTIL`で指定されたものと同じになります。たとえば、`SINCE 2 hours ago COMPARE WITH 4 hours ago`は午後3時〜5時までと午前11時〜午後1時までを比較できます。

    `COMPARE WITH` 結果は、折れ線グラフまたはビルボードで表示できます。

    * `TIMESERIES`を使用すると、`COMPARE WITH`は比較内容を経時的にマッピングした折れ線グラフを作成します。
    * `TIMESERIES`がない場合、`COMPARE WITH`は現在値と`COMPARE WITH`値からの増減率でビルボードを生成します。

    **例**：このクエリは、過去1週間の95パーセンタイルと1週間前の同じ範囲の比較を表示する折れ線グラフでデータを返します。最初は単一値、次は折れ線グラフです。

    ```sql
    SELECT percentile(duration, 95) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO

    SELECT percentile(duration, 95) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO
    ```

    <Callout variant="important">
      `COMPARE WITH`を使用する`FACET`クエリの場合、結果のファセットは、比較される前の時間範囲ではなく、`SINCE`および`UNTIL`を使用して指定された時間範囲に基づいて選択されます。以前の時間範囲のみに対する`FACET`クエリの結果には、別のファセットのセットが含まれる場合があります。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="extrapolate"
    title={<><InlineCode>EXTRAPOLATE</InlineCode> 句</>}
  >
    この句は以下のデータ型で使用できます。

    * `Transaction`

    * `TransactionError`

    * APMエージェントAPIで報告されたカスタムイベント

      `EXTRAPOLATE`の目的は、クエリ結果がシステム内のアクティビティ全体をより厳密に表現できるよう、[イベントデータのAPMエージェントサンプリング](/docs/agents/manage-apm-agents/agent-data/new-relic-events-limits-sampling)の影響を数学的に補うことです。

      この句は、APMエージェントが[収集サイクル](/docs/using-new-relic/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#event-data)の報告限度をしばしば超過する多くの[イベント](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#harvest-cycle)を報告する際に便利です。その場合、エージェントはイベントのサンプリングを開始します。

      `EXTRAPOLATE`に対応したNRQLクエリでこれを使用する場合、**報告されたイベント**と**合計イベント**の比率で、合計未サンプルデータの近似を推定します。この句に未対応であるか、サンプルデータを使用していないNRQLでこれを使用する場合、結果に影響を与えません。

      <Callout variant="important">
        `EXTRAPOLATE`は、（スループットまたはエラー率など）同種データに対して最も有用である点に注意してください。（`uniqueCount()`または`uniques()`など）特徴的なものの数を外挿する際には有効ではありません。
      </Callout>

      この句は、以下のいずれかの[集計関数](/docs/insights/nrql-new-relic-query-language/nrql-reference/nrql-syntax-components-functions#functions)を使用するNRQLクエリでのみ機能します。

    * `apdex`

    * `average`

    * `count`

    * `histogram`

    * `sum`

    * `percentage` （引数として取る関数が`EXTRAPOLATE`に対応している場合）

    * `rate` （引数として取る関数が`EXTRAPOLATE`に対応している場合）

    * `stddev`

      <CollapserGroup>
        <Collapser
          id="extrapolate-example-1"
          title="スループットの推定の例"
        >
          `interestingApplication`という名前のサービスの推定スループットを示すクエリ。

          ```sql
          SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE
          ```
        </Collapser>

        <Collapser
          id="extrapolate-example-2"
          title="時系列としてのスループットの推定の例"
        >
          トランザクション名ごとに、時系列として表示する`interestingApplication`という名前のサービスの推定スループットを示すクエリ。

          ```sql
          SELECT count(*) FROM Transaction WHERE appName='interestingApplication'
          SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet"
    title={<><InlineCode>FACET</InlineCode> 句</>}
  >
    ```sql
    SELECT ...
      FACET attribute
      ...
    ```

    `FACET`を使用すると、結果を属性値で分割してグループ化できます。たとえば、`PageView`データで`deviceType`別に`FACET`を行い、トラフィックの何割が携帯電話、タブレット、およびデスクトップデバイスから発生しているかを把握することができます。

    `LIMIT`句を使用して、表示するファセットの数を指定します（デフォルトは10）。より複雑なグループ化に関しては、[`FACET CASES`](#sel-facet-cases)を使用します。`FACET`句は、カンマで区切られた最大5つの属性をサポートします。

    ファセットは、`SELECT`句で指定した最初のフィールドによって降順でソートされます。2,000件以上のユニーク値を持つ属性をファセットに指定した場合、ファセット値のサブセットを選択し、それらをクエリタイプに従って並べ替えます。

    `min()`、`max()`、`percentile()`、`average()`、または`count()`を選択すると、`FACET`はこれらの関数を使用してファセットの選択方法とソート方法を決定します。その他の[関数](#functions)を選択すると、`FACET`はファセット対象の属性の発生頻度に基づいて、ファセットの選択方法とソート方法を決定します。

    <CollapserGroup>
      <Collapser
        id="faceted-query"
        title={<>使用したファセットクエリ <InlineCode>count()</InlineCode></>}
      >
        このクエリは、ページビュー数が最も多い都市を表示します。このクエリは、都市ごとのページビューの合計数を使用してファセットの選択方法と並べ替え方法を決定します。

        ```sql
        SELECT count(*) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="uniquecount"
        title={<>使用したファセットクエリ <InlineCode>uniqueCount()</InlineCode></>}
      >
        このクエリは、最も多数のユニークURLにアクセスしている都市を表示します。このクエリは、特定の都市が結果に表れる合計回数を使用して、ファセットの選択方法と並べ替え方法を決定します。

        ```sql
        SELECT uniqueCount(pageUrl) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="cohort-analysis"
        title="時間範囲で結果をグループ化"
      >
        [高度なセグメンテーション](/docs/insights/new-relic-insights/features/advanced-segmentation)や[コホート分析](/docs/insights/new-relic-insights/features/cohort-analysis-grouping-results-across-time)では、バケット機能でファセットすることでデータをより効率的に分割することができます。

        コホート分析は、タイムスタンプに基づいて結果をグループ化する方法です。指定範囲日時に対応するバケットに結果を分割することができます。
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="facet-as"
    title={<><InlineCode>FACET ... AS</InlineCode> 句</>}
  >
    `FACET ... AS`句では、クエリで`AS`キーワードを使用してファセットに名前を付けます。この句は、結果のファセットに明確な名前または簡略化された名前を追加するのに役立ちます。[ネスト構造の集計](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query)クエリで、ファセットの名前を変更するためにも使用できます。

    `FACET ... AS` クエリでは、結果のファセット名が変更されますが（たとえば、テーブルのヘッダーとして表示される場合）、実際のファセット名自体は変更されません。

    ```sql
    FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type'
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-cases"
    title={<><InlineCode>FACET CASES</InlineCode> 句</>}
  >
    ```sql
    SELECT ...
      FACET CASES (
        WHERE attribute operator value, WHERE attribute operator value, ...
        )
      ...
    ```

    `FACET CASES`を使用して、[`FACET`](#sel-facet)で可能な範囲を超えた複雑な条件別にデータを取り出します。複数の条件はカンマ`,`で区切ります。たとえば、PageViewデータをクエリして、1秒未満、1秒から10秒、10秒を上回るといったカテゴリに`FACET CASES`を行うことができます。ケース内の複数の属性を組み合わせ、[`AS`](#sel-as)セレクタでケースにラベルを付けることができます。データ点は、最大で1つのファセットケースに追加されます。つまり、一致する最初のファセットになります。

    また、属性とともに[時間関数](/docs/query-data/nrql-new-relic-query-language/nrql-query-examples/group-results-across-time)を使用することもできます。また、`OR`演算子を使用して、指定したどのケースにも一致しないファセット結果を表示することもできます。

    <CollapserGroup>
      <Collapser
        id="facet-cases-basic"
        title={<>基本的な使用 <InlineCode>WHERE</InlineCode></>}
      >
        ```sql
        SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10)
        ```
      </Collapser>

      <Collapser
        id="facet-cases-mixnmatch"
        title="複数の属性に基づくグループ化"
      >
        この例は、トランザクション名に`login`が含まれる1つのバケットと、URLに`login`が含まれ、かつカスタムアトリビュートがユーザーが有料ユーザーであったことを示すもう1つのバケットに結果をグループ化します。

        ```sql
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid')
        ```
      </Collapser>

      <Collapser
        id="facet-cases-as-label"
        title={<>グループのラベル付け <InlineCode>AS</InlineCode></>}
      >
        この例は、結果に人間が読める名前をつけるために[`AS`](#sel-as)セレクタを使います。

        ```sql
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users')
        ```
      </Collapser>

      <Collapser
        id="facet-cases-with-or"
        title={<>ファセット不一致データ <InlineCode>OR</InlineCode></>}
      >
        この例では、`OR`演算子を使用して、どのケースにも一致しないファセット結果を表示しています。

        ```sql
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') OR name
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-order"
    title={<><InlineCode>FACET ... ORDER BY</InlineCode> 句</>}
  >
    NRQLでは、デフォルトは`SELECT`句の最初の集計で、クエリ内のファセットの選択をガイドします。`FACET ... ORDER BY`では、ORDER BY修飾子で集計関数を追加し、ファセットの選択方法を指定することで、このデフォルト動作をオーバーライドできます。具体的には、`LIMIT`句によって制限される前に、最終結果に含めるファセットの優先度をオーバーライドします。この句はクエリで使用できますが、アラートやストリーミングには使用できません。

    この例では、`FACET ... ORDER BY`を使用してアプリトランザクションの平均期間を見つける方法を示し、応答サイズが最大のアプリによる上位10（デフォルトの制限）の最大期間を示しています。この場合、`FACET ... ORDER BY`が使用されていない場合、クエリ結果には、アプリの選択とは関係のない応答サイズで、期間が最も長い上位10件が代わりに表示されます。

    ```sql
    FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize)
    ```

    <Callout variant="tip">
      `LIMIT`句が適用される前に操作が実行されるため、`FACET ... ORDER BY`は、最終的なクエリ結果の種類に影響を与えません。これは、非時系列クエリの結果で特に顕著になります。
    </Callout>

    <Callout variant="important">
      この場合の`ORDER BY`修飾子は、`ORDER BY`句とは機能が異なります。`FACET attribute1 ORDER BY attribute2`の形式に従うクエリを構文解析する場合、New Relicはこれらのクエリを`FACET ... ORDER BY`クエリとして読み取りますが、`ORDER BY`が`FACET`の直後に表示される場合に限定されます。それ以外の場合、`ORDER BY`はNew Relicによって句として解釈されます。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-limit"
    title={<><InlineCode>LIMIT</InlineCode> 句</>}
  >
    ```sql
    SELECT ...
      LIMIT count
      ...
    ```

    `LIMIT`句を使用して、`FACET`クエリで返されるファセット値の最大数、または`SELECT *`クエリで返される項目の最大数を制御します。この句は、単一の整数値を引数に取ります。`LIMIT`句が指定されない、または値が提供されない場合、リミットのデフォルト設定は、`FACET`クエリの場合は10、`SELECT *`クエリの場合は100となります。

    `LIMIT`句で許容される最大値は2,000です。

    <CollapserGroup>
      <Collapser title={<>使用したクエリ <InlineCode>LIMIT</InlineCode></>}>
        このクエリはセッション数上位20カ国を表示し、各国のWindowsユーザー限定でレスポンスタイムの95パーセンタイルを提供します。

        ```sql
        SELECT uniqueCount(session), percentile(duration, 95)
          FROM PageView WHERE userAgentOS = 'Windows'
          FACET countryCode LIMIT 20 SINCE YESTERDAY
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-offset"
    title={<><InlineCode>OFFSET</InlineCode> 句</>}
  >
    ```sql
    SELECT ...
      LIMIT count OFFSET count
      ...
    ```

    `OFFSET`句と`LIMIT`句を使用して、`SELECT *`または`SELECT column`クエリによって返される行の一部を制御します。`LIMIT`句と同様に、`OFFSET`は引数として単一の整数値を取ります。`OFFSET`は、クエリで選択された行が返される前に、スキップされる行数を設定します。これは`LIMIT`によって制約されます。

    `OFFSET` 行はスキップされ、直近のレコードから開始されます。

    たとえば、クエリ`SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1`は、最新の値を除き、`Minute_Report`から最後の5つの値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-order-by"
    title={<><InlineCode>ORDER BY</InlineCode> 句</>}
  >
    `ORDER BY`句を使用すると、行でイベント属性を選択するクエリで結果を並べ替える方法を指定できます。

    このクエリは、期間順にトランザクションを並べ替えます。

    ```sql
    FROM Transaction SELECT appName, duration ORDER BY duration
    ```

    デフォルトの並べ替え順序は昇順ですが、`ASC`または`DESC`の修飾子を追加することで変更できます。
  </Collapser>

  <Collapser
    className="freq-link"
    id="show-event-types"
    title={<><InlineCode>SHOW EVENT TYPES</InlineCode> 句</>}
  >
    ```sql
    SHOW EVENT TYPES...
    ```

    `SHOW EVENT TYPES` は、特定の時間範囲内にアカウントに存在するすべてのデータ型のリストを返します。これは、`SELECT`の代わりにクエリの最初の句として使用されます。

    <Callout variant="important">
      この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータ型を指します。
    </Callout>

    <CollapserGroup>
      <Collapser
        id="avg-resp-time-query"
        title="直近1日のデータ型"
      >
        このクエリは、直近1日のすべてのデータ型を返します。

        ```sql
        SHOW EVENT TYPES SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-since"
    title={<><InlineCode>SINCE</InlineCode> 句</>}
  >
    ```sql
    SELECT ...
      SINCE [numerical units AGO | phrase]
      ...
    ```

    **デフォルト**値は **1 時間前**です。

    `SINCE`句を使用して、返されたデータに対する時間範囲の開始を定義します。タイムゾーンは結果ではなく、クエリに対して指定できます。NRQLの結果はシステム時間に基づきます。

    NRQLを使用する場合、UTCタイムスタンプまたは相対時間範囲を設定できます。

    * タイムスタンプは`YYYY-MM-DD HH:MM:SS ZZZZ`の形式を使用します。例えば：

      ```sql
      FROM Transaction SELECT count(*) SINCE '2021-12-25 00:00:00 +0000' UNTIL '2021-12-25 23:59:59 +0000'
      ```

    * 当社は、以下の相対時間範囲をサポートしています：`YESTERDAY`、`TODAY`、`SUNDAY`、`MONDAY`、`TUESDAY`、`WEDNESDAY`、`THURSDAY`、`FRIDAY`、`SATURDAY`。例、`SINCE YESTERDAY UNTIL NOW`。

    * また、`YEAR`、`QUARTER`、`MONTH`、`WEEK`、`DAY`、`HOUR`、`MINUTE`、`SECOND`もサポートしています。この場合、`SINCE`を`THIS`または`LAST`と組み合わせることができます。たとえば、`SINCE LAST MONTH UNTIL THIS WEEK`。`SINCE 3 WEEKS AGO UNTIL 10 MINUTES AGO`のように、`AGO`を含めることもできます。
  </Collapser>

  <Collapser
    className="freq-link"
    id="slide-by"
    title={<><InlineCode>SLIDE BY</InlineCode> 句</>}
  >
    `SLIDE BY`句は、スライディングウィンドウと呼ばれる機能をサポートしています。スライディングウィンドウを使用すると、`SLIDE BY`データは、互いに重複する時間の「ウィンドウ」に収集されます。これらのウィンドウは、移動集計（移動平均など）が狭い時間枠からの集計よりも重要である場合に、変動の多い折れ線グラフを滑らかにするのに役立ちます。

    `SLIDE BY`を使用するには、`TIMESERIES`句の後のクエリにこの句を配置します。たとえば、このクエリは1分の`SLIDE BY`間隔で5分間のウィンドウにデータをプルします。つまり、各ウィンドウは5分間続きますが、ウィンドウ1は0分後に開始し、ウィンドウ2は1分後に開始し、ウィンドウ3は2分後に開始します。

    ```sql
    SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute
    ```

    `SLIDE BY`をいつ、どのように使用できるかについての詳細は、[スライディングウィンドウを使用してよりスムーズなグラフを作成する](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows)を参照してください。または、この短いビデオをご覧ください（約3分20秒）。

    <Video
      id="b9WVyb1wU6w"
      type="youtube"
    />

    <CollapserGroup>
      <Collapser
        id="sliding-window-max-auto"
        title={<><InlineCode>SLIDE BY</InlineCode>を<InlineCode>MAX</InlineCode>または<InlineCode>AUTO</InlineCode>間隔と使用</>}
      >
        スライディングウィンドウは、`MAX`または`AUTO`と組み合わせて使用できます。ただし、`MAX`または`AUTO`を`TIMESERIES`と`SLIDE BY`の間に配置することはできません。

        このクエリは、`SLIDE BY`ウィンドウ間隔を自動的に決定します。

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO
        ```

        このクエリはSLIDE BYウィンドウを最高間隔粒度に設定します。

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX
        ```

        <Callout variant="important">
          `AUTO`または`MAX`によって決定される`SLIDE BY`値は、ウィンドウサイズよりも大きいステップ間隔を生成する可能性があり、ギャップや予期しない結果を引き起こす可能性があります。
        </Callout>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timeseries"
    title={<><InlineCode>TIMESERIES</InlineCode> 句</>}
  >
    ```sql
    SELECT ...
      TIMESERIES integer units
      ...
    ```

    `TIMESERIES`句を使用して、指定期間単位の時系列としてデータを返します。`TIMESERIES`は特定のチャートを表示するために使用されるため、デフォルト値はありません。

    時間範囲を指定するには、`integer units`を使用します。例：

    * `TIMESERIES 1 minute`
    * `TIMESERIES 30 minutes`
    * `TIMESERIES 1 hour`
    * `TIMESERIES 30 seconds`

    `TIMESERIES` 以下の例に示すように、`MAX`、`AUTO`、`SLIDE BY`などの引数と組み合わせると、クエリ結果をさらに調整できます。

    <Callout variant="important">
      `average()`または`percentile()`などの関数では、集計ウィンドウを大きく設定することで、外れ値に対して大幅なスムージング効果が得られます。これは、クエリがスライディングウィンドウを使用するかどうかに関係なく当てはまります。
    </Callout>

    <CollapserGroup>
      <Collapser
        id="set-interval"
        title="設定した間隔を使用する"
      >
        指定された値は、グラフを分割する単位を示します。たとえば、以下のようにして1日のグラフを30分刻みで表示します。

        ```sql
        SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes
        ```
      </Collapser>

      <Collapser
        id="timeseries-auto"
        title="自動設定した間隔を使用する"
      >
        `TIMESERIES` は`AUTO`に設定することもでき、これによってグラフが適切な数の区分に分割されます。たとえば、1日のチャートは30分間隔で分割され、1週間のチャートは6時間間隔で分割されます。

        このクエリは、6時間間隔のデータ点で、1週間のクライアントサイドのトランザクションタイムの50パーセントタイルと90パーセンタイルを示す折れ線グラフを返します。

        ```sql
        SELECT average(duration), percentile(duration, 50, 90)
          FROM PageView SINCE 1 week AGO TIMESERIES AUTO
        ```
      </Collapser>

      <Collapser
        id="timeseries-max"
        title={<><InlineCode>MAX</InlineCode>間隔を使用</>}
      >
        `TIMESERIES`を`MAX`に設定することで時間枠が自動的に調整され、指定された期間に許可された間隔数を最大にできます。これによって、`TIMESERIES`バケットを手動で更新することなく時間枠を更新でき、認められた最大インターバル数に時間枠を分割できます。返される`TIMESERIES`バケットの最大数は366です。

        たとえば、以下のクエリでは4分間の間隔を作成していますが、これは1日のチャートの上限となります。

        ```sql
        SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-until"
    title={<><InlineCode>UNTIL</InlineCode> 句</>}
  >
    ```sql
    SELECT ...
      UNTIL integer units AGO
      ...
    ```

    **デフォルト**値は**NOW**です。`UNTIL`は、デフォルト以外の終了点を指定するためのみに使用してください。

    `UNTIL`句を使用して、データを返す時間範囲の終了時点を定義します。時間範囲を指定するとデータが保存されるようになり、時間範囲が終了した後に確認することができます。

    詳細情報と例については、[タイムピッカーを使用して時間設定を調整する](/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/#dash-time-picker)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-where"
    title={<><InlineCode>WHERE</InlineCode> 句</>}
  >
    `WHERE`句を使用して、結果をフィルタリングします。NRQLは、句で指定する条件を満たす結果を返します。

    ```sql
    SELECT function(attribute) ...
      WHERE attribute [operator 'value' | IN ('value' [, 'value']) | IS [NOT] NULL ]
      [AND|OR ...]
      ...
    ```

    * 複数の条件を指定する場合は、条件を演算子`AND`または`OR`で区切ります。
    * [SQLの`JOIN`をシミュレート](/docs/insights/nrql-new-relic-query-language/using-nrql/simulate-sql-join-functions-insights)する場合は、`WHERE`または`FACET`句でカスタムアトリビュートを使用します。

    <table id="where-operators">
      <thead>
        <tr>
          <th width={150}>
            **`WHERE`句が受け付ける演算子**
          </th>

          <th>
            **説明**
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `=`、`!=`、`<`、`<=`、`>`、 `>=`
          </td>

          <td>
            NRQLは標準的な比較演算子を受け付けます。例： `state = 'WA'`

            ブール値を持つ属性の場合、`=`ではなく`IS`を使用します。
          </td>
        </tr>

        <tr>
          <td>
            `AND`
          </td>

          <td>
            2つの条件の論理積を定義するために使用します。
          </td>
        </tr>

        <tr>
          <td>
            `OR`
          </td>

          <td>
            2つの条件の論理和を定義するために使用します。
          </td>
        </tr>

        <tr>
          <td>
            `IS NULL`
          </td>

          <td>
            属性がnull値を持つかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `IS NOT NULL`
          </td>

          <td>
            属性がnull値を持たないかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `IS TRUE`
          </td>

          <td>
            属性が`true`のブール値を持つかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `IS FALSE`
          </td>

          <td>
            属性が`false`のブール値を持つかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `IN`
          </td>

          <td>
            属性の文字列値が指定したセットに存在するかどうかを判断します。この方法を使用すると、複数の`WHERE`句を組み合わせた場合よりもパフォーマンスが向上します。

            例: `animalType IN ('cat', 'dog', 'fish')`
          </td>
        </tr>

        <tr>
          <td>
            `NOT IN`
          </td>

          <td>
            属性の文字列値が指定したセットに存在しないかどうかを判断します。この方法を使用すると、複数の`WHERE`句を組み合わせた場合よりもパフォーマンスが向上します。

            値は括弧で囲み、カンマで区切る必要があります。例：

            ```sql
            SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `LIKE`
          </td>

          <td>
            属性に指定のサブ文字列が含まれるかどうかを判断します。

            `LIKE`演算子の文字列引数は、文字列内の任意の位置にワイルドカードとしてパーセント記号（%）を受け付けます。サブ文字列が一致対象の文字列で開始（先頭に一致）または終了（末尾に一致）しない場合、ワイルドカードを文字列の先頭または末尾に指定する必要があります。

            **例：**

            `userAgentName LIKE 'IE%'`

            * IE

            * IE Mobile

              `userAgentName LIKE 'o%a%'`

            * Opera

            * Opera Mini

              `userAgentName LIKE 'o%a'`

            * Opera

              `userAgentName LIKE '%o%a%'`

            * Opera

            * Opera Mini

            * Mozilla Gecko
          </td>
        </tr>

        <tr>
          <td>
            `NOT LIKE`
          </td>

          <td>
            属性に指定のサブ文字列が含まれないかどうかを判断します。
          </td>
        </tr>

        <tr>
          <td>
            `RLIKE`
          </td>

          <td>
            属性に特定のRegexサブ文字列が含まれるかどうかを判断します。[RE2構文](https://github.com/google/re2/wiki/Syntax)を使用します。

            **例：**

            `appName RLIKE r'z.*|q.*''`

            * `z-app`

            * `q-app`

              `hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*'`

            * `ip-10-351-19-237`

            * `ip-10-351-2-41`

            * `ip-10-351-24-238`

            * `ip-10-351-14-15`

              <Callout variant="important">
                Regexではデフォルトで文字列全体マッチとなっているため、`^`と`$`は暗黙となり、追加する必要はありません。
              </Callout>
          </td>
        </tr>

        <tr>
          <td>
            `NOT RLIKE`
          </td>

          <td>
            属性に指定のRegexサブ文字列が含まれないかどうかを判断します。[RE2構文](https://github.com/google/re2/wiki/Syntax)を使用します。
          </td>
        </tr>
      </tbody>
    </table>

    <CollapserGroup>
      <Collapser
        id="query-3-conditions"
        title="3つの条件を使用したクエリの例"
      >
        このクエリは、過去24時間、米国およびカナダ国内のSafariユーザーについて、URLに`checkout`が含まれるページのブラウザレスポンスタイムを返します。

        ```sql
        SELECT histogram(duration, 50, 20) FROM PageView
        WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%'
        SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-metric-format"
    title={<><InlineCode>WITH METRIC_FORMAT</InlineCode> 句</>}
  >
    メトリックデータのクエリに関する情報については、[メトリクスのクエリを行う](#query-metrics)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-as-nrql-var"
    title={<><InlineCode>WITH ... AS</InlineCode> 句（NRQL環境変数）</>}
  >
    ```sql
    FROM ...
      WITH function(attribute) AS var
      SELECT var
      ...
    ```

    `WITH ... AS`句を使用してNRQL環境変数を定義し、クエリ内のどこでも参照できる環境変数として値を格納します。いくつかのルールとヒント：

    * `WITH ... AS`句は、`FROM`/`SELECT`句の前、間、直後に実行できます。
    * 環境変数として設定できるのは、行単位の関数（`capture()`など）のみです。集計関数（`average()`など）はサポートされていません。
    * `WITH`は1つしか使用できませんが、コンマで区切られている限り、複数のNRQL環境変数を使用できます。
    * 定義されたNRQL環境変数が既存の属性と同じ名前を使用する場合、環境変数が優先されます。
    * 環境変数名に`%`記号を含めることはできません。

    以下にいくつかクエリを示します。

    <CollapserGroup>
      <Collapser
        id="basic-nrql-var"
        title="環境変数の基本的な使用"
      >
        ```sql
        FROM Transaction
          WITH duration*1000 AS millisec
          SELECT millisec
        ```
      </Collapser>

      <Collapser
        id="multiple-nrql-var"
        title="複数の環境変数の使用"
      >
        ```sql
        FROM Log
          WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice)
          SELECT itemId, unitPrice
        ```

        [アンカー解析](#func-aparse)（`aparse()`）の詳細をご覧ください。
      </Collapser>

      <Collapser
        id="nrql-var-other-clauses"
        title="他の句での環境変数の使用"
      >
        この例では、NRQL環境変数`unitPrice`を使用して、抽出された文字列を数値に変換する別の環境変数`unitPriceNum`を作成します。この環境変数は、`SELECT`、`WHERE`および`FACET`句で使用されます。

        ```sql
        FROM Log
          WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice),
            numeric(unitPrice) AS unitPriceNum
          SELECT sum(unitPriceNum)
          FACET itemId
          WHERE unitPriceNum < 100
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timezone"
    title={<><InlineCode>WITH TIMEZONE</InlineCode> 句</>}
  >
    ```sql
    SELECT ... WITH TIMEZONE (selected zone)
      ...
    ```

    `WITH TIMEZONE`句を使用すると、タイムゾーンが未指定のクエリ内で日付や時刻のタイムゾーンを選択できます。

    日時にタイムゾーンを指定せずに`WITH TIMEZONE`句を含めると、`since`句と`until`句は指定されたタイムゾーンを保持します。

    `WITH TIMEZONE`句を含めなくても、日時文字列にタイムゾーンを含めると、日時文字列のタイムゾーンが保持されます。

    <Callout variant="important">
      タイムゾーンが指定されていない場合、デフォルトのタイムゾーンは常にUTCです。結果の生のタイムスタンプ値（JSONビューで表示）は常にUTCです。UIには、アカウント設定で指定したタイムゾーンで結果が表示されます。タイムスタンプ文字列のタイムゾーンは常に機能します。これは、`WITH TIMEZONE`ゾーンより優先されます。
    </Callout>

    たとえば、クエリ句`SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'`は、米国/ニューヨーク時間の月曜日の午前0時から、米国/ニューヨーク時間の火曜日の午前0時までに記録されたデータを返します。

    クエリのタイムスパン句の例をいくつか紹介します。

    * `WITH TIMEZONE`句を使用した日時文字列にタイムゾーンがありません。

      ```sql
      SINCE today UNTIL '2022-05-19T12:00' WITH TIMEZONE 'America/Los_Angeles'
      ```

      これは、`"beginTime": "2022-05-19T07:00:00Z"`と`"endTime": "2022-05-19T19:00:00Z"`として解決されます。

    * `WITH TIMEZONE`句を使用しない日時文字列のタイムゾーン：

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500'
      ```

      これは、`"beginTime": "2022-05-19T00:00:00Z"`と`"endTime": "2022-05-19T17:00:00Z"`として解決されます。

    * 夏時間の-0700である米国/ロサンゼルスという`WITH TIMEZONE`句を使用した、日時文字列のタイムゾーン：

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500' WITH TIMEZONE 'America/Los_Angeles'
      ```

      これは、`"beginTime": "2022-05-19T07:00:00Z"`と`"endTime": "2022-05-19T19:00:00Z"`として解決されます。

    <table style={{ width: "auto" }}>
      <thead>
        <tr>
          <th colSpan={4}>
            利用可能なタイムゾーンの選択
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            アフリカ/アビジャン
          </td>

          <td>
            アフリカ/アディスアベバ
          </td>

          <td>
            アフリカ/アルジェ
          </td>

          <td>
            アフリカ/ブランタイヤ
          </td>
        </tr>

        <tr>
          <td>
            アフリカ/カイロ
          </td>

          <td>
            アフリカ/ウィントフック
          </td>

          <td>
            米州/アダック
          </td>

          <td>
            米州/アンカレッジ
          </td>
        </tr>

        <tr>
          <td>
            米州/アラグアイナ
          </td>

          <td>
            米州/アルゼンチン/ブエノスアイレス
          </td>

          <td>
            アメリカ/ベリーズ
          </td>

          <td>
            アメリカ/ボゴタ
          </td>
        </tr>

        <tr>
          <td>
            アメリカ/カンポグランデ
          </td>

          <td>
            アメリカ/カンクン
          </td>

          <td>
            アメリカ/カラカス
          </td>

          <td>
            アメリカ/シカゴ
          </td>
        </tr>

        <tr>
          <td>
            アメリカ/チワワ
          </td>

          <td>
            アメリカ/ドーソンクリーク
          </td>

          <td>
            アメリカ/デンバー
          </td>

          <td>
            アメリカ/エンセナーダ
          </td>
        </tr>

        <tr>
          <td>
            アメリカ/グリーンベイ
          </td>

          <td>
            アメリカ/ゴットホープ
          </td>

          <td>
            アメリカ/グースベイ
          </td>

          <td>
            アメリカ/ハバナ
          </td>
        </tr>

        <tr>
          <td>
            アメリカ/ラパス
          </td>

          <td>
            アメリカ/ロサンゼルス
          </td>

          <td>
            アメリカ/ミクロン
          </td>

          <td>
            アメリカ/モンテビデオ
          </td>
        </tr>

        <tr>
          <td>
            アメリカ/ニューヨーク
          </td>

          <td>
            アメリカ/ノローニャ
          </td>

          <td>
            アメリカ/サンティアゴ
          </td>

          <td>
            アメリカ/サンパウロ
          </td>
        </tr>

        <tr>
          <td>
            アメリカ/セントジョンズ
          </td>

          <td>
            アジア/アナディル
          </td>

          <td>
            アジア/バンコク
          </td>

          <td>
            アジア/ベイルート
          </td>
        </tr>

        <tr>
          <td>
            アジア/ダマスカス
          </td>

          <td>
            アジア/ダッカ
          </td>

          <td>
            アジア/ドバイ
          </td>

          <td>
            アジア/ガザ
          </td>
        </tr>

        <tr>
          <td>
            アジア/香港
          </td>

          <td>
            アジア/イルクーツク
          </td>

          <td>
            アジア/エルサレム
          </td>

          <td>
            アジア/カブール
          </td>
        </tr>

        <tr>
          <td>
            アジア/カトマンズ
          </td>

          <td>
            アジア/コルカタ
          </td>

          <td>
            アジア/クラスノヤルスク
          </td>

          <td>
            アジア/マガダン
          </td>
        </tr>

        <tr>
          <td>
            アジア/ノボシビルスク
          </td>

          <td>
            アジア/ヤンゴン
          </td>

          <td>
            アジア/ソウル
          </td>

          <td>
            アジア/タシケント
          </td>
        </tr>

        <tr>
          <td>
            アジア/テヘラン
          </td>

          <td>
            アジア/東京
          </td>

          <td>
            アジア/ウラジオストク
          </td>

          <td>
            アジア/ヤクーツク
          </td>
        </tr>

        <tr>
          <td>
            アジア/エカテリンブルク
          </td>

          <td>
            アジア/エレバン
          </td>

          <td>
            大西洋/アゾレス
          </td>

          <td>
            大西洋/カーポベルデ
          </td>
        </tr>

        <tr>
          <td>
            大西洋/スタンリー
          </td>

          <td>
            オーストラリア/アデレード
          </td>

          <td>
            オーストラリア/ブリスベン
          </td>

          <td>
            オーストラリア/ダーウィン
          </td>
        </tr>

        <tr>
          <td>
            オーストラリア/ユークラ
          </td>

          <td>
            オーストラリア/ホバート
          </td>

          <td>
            オーストラリア/ロードハウ
          </td>

          <td>
            オーストラリア/パース
          </td>
        </tr>

        <tr>
          <td>
            チリ/イースター島
          </td>

          <td>
            その他/GMT+10
          </td>

          <td>
            その他/GMT+8
          </td>

          <td>
            その他/GMT-11
          </td>
        </tr>

        <tr>
          <td>
            その他/GMT-12
          </td>

          <td>
            ヨーロッパ/アムステルダム
          </td>

          <td>
            ヨーロッパ/ベルファスト
          </td>

          <td>
            ヨーロッパ/ベオグラード
          </td>
        </tr>

        <tr>
          <td>
            ヨーロッパ/ブリュッセル
          </td>

          <td>
            ヨーロッパ/ダブリン
          </td>

          <td>
            ヨーロッパ/リスボン
          </td>

          <td>
            ヨーロッパ/ロンドン
          </td>
        </tr>

        <tr>
          <td>
            ヨーロッパ/ミンスク
          </td>

          <td>
            ヨーロッパ/モスクワ
          </td>

          <td>
            太平洋/オークランド
          </td>

          <td>
            太平洋/チャタム
          </td>
        </tr>

        <tr>
          <td>
            太平洋/ガンビエ
          </td>

          <td>
            太平洋/キリバス
          </td>

          <td>
            太平洋/マルケサス
          </td>

          <td>
            太平洋/ミッドウェイ
          </td>
        </tr>

        <tr>
          <td>
            太平洋/ノーフォーク
          </td>

          <td>
            太平洋/トンガタプ
          </td>

          <td>
            UTC
          </td>
        </tr>
      </tbody>
    </table>

    詳細な情報と例については、[ダッシュボードとチャートで時間範囲を設定する](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets)を参照してください。
  </Collapser>
</CollapserGroup>

## メトリックデータをクエリ [#query-metrics]

メトリックデータはその他のデータ型より複雑です。それをうまくクエリする特定のヒントがあります。メトリックデータには2つの型があり、それぞれに以下の独自のクエリガイドラインがあります。

* [ディメンションメトリクスをクエリします](/docs/data-ingest-apis/get-data-new-relic/metric-api/view-query-you-metric-data)。これは、当社のメトリクスAPIとそのAPIを使用するソリューションの一部（たとえば、[Dropwizard インテグレーション](/docs/more-integrations/open-source-telemetry-integrations/dropwizard/dropwizard-reporter)または[Micrometerインテグレーション）により報告されます](/docs/more-integrations/open-source-telemetry-integrations/micrometer/micrometer-metrics-registry)。
* [クエリメトリックタイムスライスデータ](/docs/query-data/nrql-new-relic-query-language/nrql-query-tutorials/query-metric-timeslice-data-nrql)、当社のAPM、モバイルモニタリング、ブラウザモニタリングによって報告されるオリジナルのメトリックデータ型です。

メトリックデータのレポート方法の詳細は、[メトリックデータタイプ](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics)を参照してください。

## 関数 [#functions]

このセクションでは、NRQL関数、[集計関数](#aggregator-functions)と[非集計関数](#non-aggregator-functions)の両方について説明します。

### 集計関数 [#aggregator-functions]

集計関数を使用して、データをフィルタリング、集計します。以下を使用するためのヒント：

* New Relic Universityの[フィルタークエリ](http://newrelic.wistia.com/medias/8k4xbxlfwj)、[Apdexクエリ](http://newrelic.wistia.com/medias/46dvx1mkm0)、および[パーセンタイルクエリ](http://newrelic.wistia.com/medias/j3htrz66l0)のチュートリアルを参照してください。または、完全な[Writing NRQLクエリ](https://learn.newrelic.com/writing-nrql-queries)のオンラインコースにアクセスしてください。

* 同じクエリで集計関数を複数回使用している場合（例：`SELECT median(one_metric), median(another_metric)`）、結果の表示に問題が生じることがあります。この問題を解決するには、[`AS`関数](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-as)を使用します。例：

  ```sql
   SELECT median(one_metric) as 'med-a', median(another_metric) as 'med-b'
  ```

* データ型「型強制」には対応していません。[利用可能なデータ型変換関数](#type-conversion)の詳細を参照してください。

* 時間の経過に伴う結果の表示方法については、[時間の経過に伴う結果のグループ化](/docs/insights/new-relic-insights/features/cohort-analysis)を参照してください。

例：

```sql
SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
```

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="func-aggregationendtime"
    title={<InlineCode>aggregationendtime()</InlineCode>}
  >
    `aggregationendtime()`関数を使用して、関連集計の時刻を返します。より具体的には、`aggregationendtime()`関数は、指定した集計の、集計期間終了のタイムスタンプを提供します。たとえば、時系列クエリでは、1時間分のデータを含むデータポイントの場合、関数はその時間の終わりのタイムスタンプを返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-apdex"
    title={<InlineCode>apdex(attribute, t: )</InlineCode>}
  >
    `apdex`関数を使用して、単一のトランザクションまたはすべてのトランザクションの[Apdexスコア](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#score)を返します。[属性](/docs/insights/new-relic-insights/decorating-events/insights-attributes)には、[`duration`](/docs/insights/insights-data-sources/default-events-attributes/apm-default-event-attributes#txn-duration)または[`backendDuration`](/docs/insights/insights-data-sources/default-events-attributes/browser-default-events-attributes-insights#backend-duration)などのレスポンスタイムに基づく、任意の属性を指定できます。`t:`引数は、選択した属性と同じ時間単位で[Apdex T](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction)閾値を定義します。たとえば、属性が秒単位で測定される場合、`t`は秒単位の閾値になります。

    `apdex()`関数が返すApdexスコアは、実行時間のみに基づくものです。APMエラーは考慮していません。エラーが含まれているにもかかわらず、トランザクションが[Apdex T](/docs/apm/new-relic-apm/getting-started/glossary#apdex_t)以下で完了する場合、そのトランザクションは`apdex ()`関数によって[満足](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#bullet-satisfied)と評価されます。

    <CollapserGroup>
      <Collapser
        id="apdex-cust-attributes"
        title="特定の顧客の Apdexを取得する"
      >
        [定義済みカスタム属性](/docs/insights/new-relic-insights/decorating-events/insights-custom-attributes)がある場合は、それらの属性に基づいて絞り込むことができます。たとえば、特に重要な顧客のApdexを監視することができます。

        ```sql
        SELECT apdex(duration, t: 0.4) FROM Transaction
          WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago
        ```
      </Collapser>

      <Collapser
        id="apdex-transaction"
        title="特定のトランザクションのApdexを取得する"
      >
        `name`属性を使用して特定のトランザクションのスコア、または`name`を省略して総合的なApdexを返します。このクエリは、直近1時間の**Controller/notes/index**トランザクションのApdexスコアを返します。

        <img
          title="crop-apdex-function"
          alt="crop-apdex-function"
          src={queriesnrqlApdexNRQLQueryBuilder}
        />

        <figcaption>
          `apdex`関数は、あなたのサイトに対するユーザーの満足度を測定する[Apdexスコア](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction)を返します。引数は、秒単位のレスポンスタイムの属性とApdex Tの閾値です。
        </figcaption>

        ```sql
        SELECT apdex(duration, t: 0.5) from Transaction
        WHERE name='Controller/notes/index' SINCE 1 hour ago
        ```
      </Collapser>

      <Collapser title="アプリ全体のApdexを取得する">
        このクエリの例では、直近3週間のアプリケーション全体のApdexを返します。

        ```sql
        SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-average"
    title={<InlineCode>average(attribute)</InlineCode>}
  >
    `average()`関数を使用して、属性の平均値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数値が返されない場合は、null値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-buckets"
    title={<InlineCode>buckets(attribute, ceiling \[,number of buckets])</InlineCode>}
  >
    `buckets()`関数を使用して、`FACET`句ごとに分割されたデータを、範囲に基づきバケットに集計します。New Relicデータベースの数値として保存される属性ごとにバケットにまとめることができます。

    この関数は、以下の3つの引数を取ります。

    * 属性名

    * サンプル範囲の最大値。外れ値は最終バケットに表示されます。

    * バケットの合計数

      詳細と例については、[データをバケットに分割](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/segment-your-insights-data-buckets)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-bucket-percentile"
    title={<InlineCode>bucketPercentile(attribute)</InlineCode>}
  >
    `bucketPercentile()`関数は、Prometheusの[`histogram_quantile`](https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile)関数のNRQL版です。次元メトリックデータとともに使用します。分位数の代わりにNew Relicパーセンタイルを返します。これは分位数\*100です。

    `bucketPercentile()`関数を使用して、Prometheus形式のヒストグラムデータから分位数を計算します。

    バケット名を引数として取得し、バケットの境界とともにパーセンタイルをレポートします。

    ```sql
    SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago
    ```

    オプションで、引数としてパーセンタイル指定を追加できます。

    ```sql
    SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago
    ```

    複数のメトリックスを使用してPrometheusヒストグラムデータを構成しているため、関連する`<basename>`に関して特定のPrometheusメトリックスのクエリを行う必要があります。

    たとえば、`<basename>` `prometheus_http_request_duration_seconds`がNRQLを使用して、Prometheusヒストグラムからパーセンタイルを計算するには、`bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)`を使用します。\_bucketがサフィックスとして`<basename>`の最後に追加されていることに注意してください。

    詳細については、[Prometheus.ioドキュメント](https://prometheus.io/docs/concepts/metric_types/#histogram)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cardinality"
    title={<InlineCode>cardinality(attribute)</InlineCode>}
  >
    `cardinality()`関数を使用して、[メトリック](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics)上のすべてのディメンション（属性）の組み合わせの数を取得します。

    次の3つの引数を取りますが、すべてオプションです。

    * メトリック名：ある場合は、`cardinality()`は指定したメトリックのみを計算します。

    * インクルード：ある場合、Includeリストは濃度計算をこの属性に制限します。

    * エクスクルード：ある場合、Excludeリストによりこの属性は濃度計算で無視されます。

      ```sql
      SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list})
      ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-count"
    title={<InlineCode>count(\*)</InlineCode>}
  >
    `count()`関数を使用して、使用可能レコード数を返します。これは単一の引数を受け入れます (`*`、属性、または定数値のいずれか)。現在、一般的なSQL動作に従い、その引数に対する値を持つすべてのレコードを計上します。

    `count(*)`は特定の属性を示すものではないため、結果はデフォルトの[「humanize」](/docs/insights/new-relic-insights/managing-dashboards-data/data-formatter-setting-default-formats-numeric-values#format)形式でフォーマットされます。
  </Collapser>

  <Collapser
    className="freq-link"
    id="derivative"
    title={<InlineCode>derivative(attribute \[,time interval])</InlineCode>}
  >
    `derivative()` は、所定のデータセットの変化率を検索します。線形最小二乗回帰を使用して変化率を計算し、微分係数を近似します。この計算では複数のデータポイントの比較が必要であるため、評価範囲にデータポイントが1つしかない場合、解が求められず、結果は`null`値になります。

    `time interval`は、変化率を計算する期間です。たとえば、`derivative(attributeName, 1 minute)`は1分あたりの変化率を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-dimensions"
    title={<InlineCode>'dimensions(include: &#x7B;attributes}, exclude: &#x7B;attributes})'</InlineCode>}
  >
    `dimensions()`関数を使用して、データ型のすべての次元値を返します。

    オプションの引数を使用して、以下の特定の属性を明示的に含めたり、除外したりできます。

    * インクルード：ある場合、includeリストは`dimensions()`をそれらの属性に限定します。

    * エクスクルード：ある場合、`dimensions()`の計算ではそれらの属性は無視されます。

      ```sql
      FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions()
      ```

      `FACET`句とともに使用する場合、`dimensions()`は、未集計クエリでのPrometheusの動作と同様に、イベントタイプで使用できるすべてのファセットについて一意の時系列を生成します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="latestrate"
    title={<InlineCode>latestrate(attribute, time interval)</InlineCode>}
  >
    `latestrate()`関数を使用して、最後の2つのデータポイントに基づく値の変化率を返します。問題となる属性を最初の引数として受け取り、結果である変化率の時間の単位を2番目の引数として受け取ります。この関数は結果を`change in attribute/time interval`の単位で返します。

    この関数は、最先端の傾向を確認するために、属性の最新の変化率を提供するのに役立ちます。

    <CollapserGroup>
      <Collapser title="PageView期間の最新の変化率を取得する">
        このクエリは、最後の2つのデータポイントに基づいて期間の変化率を返します。`1 SECOND`引数であるため、`duration/second`の単位で返されます。

        ```sql
        SELECT latestrate(duration, 1 SECOND) FROM PageView
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-max"
    title={<InlineCode>max(attribute)</InlineCode>}
  >
    `max()`関数を使用して、指定された時間範囲内に記録された数値属性の最大値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数値が返されない場合は、null値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-median"
    title={<InlineCode>median(attribute)</InlineCode>}
  >
    `median()`関数を利用して、属性の中央値あるいは50パーセンタイルを返します。パーセンタイルクエリの詳細に関しては、[percentile()](#func-percentile)を参照してください。

    <Callout variant="tip">
      `median()`クエリは、[クエリビルダー](/docs/chart-builder/use-chart-builder/get-started/introduction-chart-builder)を利用する場合にのみ利用できます。
    </Callout>

    <CollapserGroup>
      <Collapser title="中央値クエリ">
        このクエリは、中央値に関する折れ線グラフを生成します。

        ```sql
        SELECT median(duration) FROM PageView TIMESERIES AUTO
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-min"
    title={<InlineCode>min(attribute)</InlineCode>}
  >
    `min()`関数を使用して、指定された時間範囲内に記録された数値属性の最小値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数値が返されない場合は、null値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-minOf"
    title={<InlineCode>minuteOf(attribute)</InlineCode>}
  >
    `minuteOf()`関数を使用して、有効なタイムスタンプ値を持つ属性の分の部分（つまり、0〜59分）のみを抽出します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mod"
    title={<InlineCode>mod(attribute, divisor)</InlineCode>}
  >
    与えられた数値属性の値（最初の引数、すなわち被除数）を数値（2つ目の引数、すなわち除数）で割った後、`mod()`関数を使用してfloor係数を返します。このモジュロ演算は、WHERE句の条件内で使用して結果の任意のサブセットにフィルターしたり、FACET句で結果セットをさらに分割したりする方法として使用できます。

    <CollapserGroup>
      <Collapser title={<><InlineCode>mod()</InlineCode> <InlineCode>WHERE</InlineCode>句条件内</>}>
        ```sql
        FROM Transaction SELECT * WHERE mod(port, 2) = 1
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title={<><InlineCode>mod()</InlineCode> <InlineCode>FACET</InlineCode>句内</>}>
        ```sql
        FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentage"
    title={<InlineCode>percentage(function(attribute), WHERE condition)</InlineCode>}
  >
    `percentage()`関数を使用して、いくつかの条件に一致する目的のデータセットの割合を返します。

    最初の引数には、目的の属性に対する[集計関数](#functions)が必要です。必ず2つの引数を使用してください（最初の2つ以外の引数は無視されます）。属性が数値でない場合、この関数は100%を値として返します。

    ```sql
    FROM Transaction SELECT percentage(count(*), WHERE error is true ) AS 'Error Percent' Where host LIKE '%west%' EXTRAPOLATE
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentile"
    title={<InlineCode>percentile(attribute \[, percentile \[, ...]])</InlineCode>}
  >
    `percentile()`関数を使用して、所定の指定パーセンタイルでの属性の概算値を返します。この関数は属性が必須であり、パーセンタイル点を表す引数はいくつでも指定できます。`percentile()`関数は、小数点以下3桁までの表示を可能にすることで、より厳密な内容を提供できます。パーセンタイルの閾値は小数点値として指定される場合があるものの、大半のデータセットにおいて、互いに0.1よりも近いパーセンタイルは解決されない点に注意してください。

    <img
      title="percentile.png"
      alt="percentile.png"
      src={queriesnrqlPercentileNRQLQueryBuilder}
    />

    <figcaption>
      パーセンタイルの表示例
    </figcaption>

    `TIMESERIES`を使用して、時系列でマッピングされたパーセンタイルで折れ線グラフを生成します。

    * `TIMESERIES`を省略して、パーセンタイルの集計値を示すビルボードと属性シートを生成します。

      パーセンタイルが指定されていない場合、デフォルトで95パーセンタイルとなります。50パーセンタイル値、つまり中央値のみを返すには、[median()](#func-median)を使用することもできます。

      <CollapserGroup>
        <Collapser title="基本的なパーセンタイルのクエリ">
          このクエリは、5、50、95パーセンタイルの折れ線を表示する折れ線グラフを生成します。

          ```sql
          SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="predictLinear"
    title={<InlineCode>predictLinear(attribute, \[,time interval])</InlineCode>}
  >
    `predictLinear()` は`derivative()`関数の拡張機能です。同様の方法の最小2乗線形回帰を使用して、データセットの将来値を予測します。

    * `time interval`は、クエリでどの程度将来まで扱うかを表します。たとえば、`predictLinear(attributeName, 1 hour)`は、1時間の線形予想をクエリの時間枠の将来に当てはめます。
    * 一般に、`predictLinear()`は、ディスクスペースのような増加が続く値や大きなトレンドの予想などで有用です。
    * `predictLinear()`は線形回帰のため、クエリを行っているデータセットに習熟していると、正確な長期的な予想を行えます。
    * 指数的または対数的、その他の非線形的に増加するデータセットでは、非常に短期的な予想でのみ有効な可能性が高いと言えます。
    * New Relicでは、`TIMESERIES`クエリで`predictLinear`を使用することを推奨していません。これは、各バケットがクエリ内の相対的な期間に基づき個別に予想を行う、つまり、そうしたクエリは時系列終了以後の予想は示さないためです。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-rate"
    title={<InlineCode>rate(function(attribute) \[,time interval])</InlineCode>}
  >
    `rate()`関数を使用して、時間間隔ごとに所定のクエリの頻度またはレートを可視化します。たとえば、1時間の1分あたりのページビュー数や1日間の1時間あたりのサイトのユニークセッション数を把握する必要がある場合があります。

    * [`TIMESERIES`](#sel-timeseries)を使用して、時系列でマッピングされた評価を示す折れ線グラフを生成します。

    * [`TIMESERIES`](#sel-timeseries)を省略して、時間で平均化された単一の評価値を示すビルボードを生成します。

      過去6時間にわたる10分あたりのAPMトランザクションのスループット評価を示す折れ線グラフを生成する基本的なクエリを以下に示します。

      ```sql
      SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago
      TIMESERIES
      ```

      ここでは、さまざまな時間枠でデータを比較するために`rate`を使用する方法を説明する短いビデオ（3分21秒）を紹介します。

      <Video
        id="9UArmB4QiVM"
        type="youtube"
      />
  </Collapser>

  <Collapser
    className="freq-link"
    id="round"
    title={<InlineCode>round(attribute)</InlineCode>}
  >
    `round()`関数を使用して、属性の丸め値を返します。

    オプションで、`round()`は2番目の引数`to_nearest`を取り、最初の引数を2番目の引数の最も近い倍数に切り上げます。`to_nearest`は分数にすることができます。

    ```sql
    SELECT round(n [, to_nearest])
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="stddev"
    title={<InlineCode>stddev(attribute)</InlineCode>}
  >
    `stddev()`関数を使用して、指定された時間範囲内に記録された数値属性の[標準偏差値](https://en.wikipedia.org/wiki/Standard_deviation)を返します。単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="stdvar"
    title={<InlineCode>stdvar(attribute)</InlineCode>}
  >
    `stdvar()`関数を使用して、指定された時間範囲内に記録された数値属性の[標準分散](https://en.wikipedia.org/wiki/Variance)を返します。

    単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-sum"
    title={<InlineCode>sum(attribute)</InlineCode>}
  >
    `sum()`関数を使用して、指定された時間範囲内に記録された数値属性の合計値を返します。

    単一の引数を取ります。最初の引数以外は無視されます。属性が数値でない場合は、ゼロを値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniqueCount"
    title={<InlineCode>uniqueCount(attribute)</InlineCode>}
  >
    `uniqueCount()`関数を使用して、指定された時間範囲内に記録された属性のユニーク値の数を返します。

    <Callout variant="tip">
      クエリのパフォーマンスを最適化するため、この関数は256個以上のユニーク値を検査するクエリのおおよその結果を返します。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniques"
    title={<><InlineCode>uniques(attribute ,limit</InlineCode><InlineCode>)</InlineCode></>}
  >
    `uniques()`関数を使用して、指定された時間範囲内に記録された属性のユニーク値のリストを返します。`facet`句と共に使用すると、各ファセット値ごとにユニーク属性値リストが返されます。

    `limit`パラメーターはオプションです。提供されない場合は、ファセットあたり1,000のユニーク属性値のデフォルトlimitが適用されます。最大10,000までの、別の`limit`値を指定できます。`uniques()`関数は、limitに達するまで、発見したユニーク属性値の最初のセットを返します。このため、データセットに5,000のユニーク属性値があり、リミットが1,000に設定されている場合は、演算子はその頻度に関わらず、発見した最初の1,000のユニーク値を返します。

    クエリ結果で返すことのできる最大数は、`uniques()`上限と`facet`上限を掛け合わせたものになります。以下のクエリでは、論理的に返すことができる値の最大数は500万です（5,000 x 1,000）。

    クエリするデータセットとクエリの複雑性に応じて、メモリ保護limitで非常に大きなクエリの実行が阻止される場合があります。

    ```sql
    From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000
    ```

    <CollapserGroup>
      <Collapser title={<>使用 <InlineCode>tuple</InlineCode></>}>
        少数の属性の独自の組み合わせを知りたい場合、`SELECT uniques(tuple(x, y, ... z)) ...`形式でクエリを構築することで、値の独自のタプルをすべて取得して、それらの関係を維持することができます。以下のクエリでは、`tuple`が`index`と`cellName`で一緒に使用され、これらの2つの値が組み合わせで発生する一意の要素を見つけます。

        ```sql
        FROM NodeStatus SELECT uniques(tuple(index, cellName), 5)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### 非集計関数 [#non-aggregator-functions]

NRQLクエリ内の非数値データには非集計関数を使用します。

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="acct-type"
    title={<InlineCode>accountId()</InlineCode>}
  >
    `accountId()`関数を使用して、クエリされたデータに関連する[アカウントID](/docs/accounts/accounts-billing/account-structure/account-id)を返します。この関数は引数を取りません。以下にいくつかクエリを示します。

    <CollapserGroup>
      <Collapser title="各トランザクションイベントのアカウントIDの取得">
        このクエリは、返された各`Transaction`イベントに関連するアカウントIDを返します。

        ```sql
        SELECT accountId() FROM Transaction SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="各アカウントのトランザクションイベント数の取得">
        このクエリは、各アカウントIDに関連する最終日の`Transaction`イベント数を返します。

        ```sql
        SELECT count(*) FROM Transaction FACET accountId() SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="WHERE句で指定された各アカウントのトランザクションイベント数の取得">
        このクエリは、アカウントIDが、特に`1`、`2`、`3`のいずれかである最終日の`Transaction`イベント数を返します。

        ```sql
        SELECT count(*) FROM Transaction WHERE accountId() IN (1,2,3) SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-aparse"
    title={<><InlineCode>aparse(attribute, pattern)</InlineCode></>}
  >
    アンカー解析関数、`aparse()`を使用して、文字列から特定の値を抽出します。これは`capture()`の代替手段です。

    `aparse()` 次の2つの引数が必要です。

    * 文字列属性
    * アンカー文字列と抽出文字を含むパターン文字列、URLからドメインを抽出するには、'www.\*.com' のように入力します。

    `aparse()`を使用する場合、パターン文字列には上記の 'www.' や '.com' のようなアンカーを含め、目的の抽出文字列の位置を '\*' で指定する必要があります。

    `aparse()` はパターン文字列で次の文字を使用します。

    * '%' - `LIKE`句に表示されているように、非キャプチャワイルドカード
    * '\*' - 正規表現キャプチャの使用に似たワイルドカードのキャプチャ

    実際には、アンカー文字列は文字列属性の中央に発生し、先頭や末尾には発生しません。

    この場合、'%' のワイルドカードを使用して、不要な値（'%www.\*.com%' など）を無視します。

    `capture()`と同様に、`aparse()`の結果はすべて文字列です。これらの結果を数学関数で使用するには、`numeric()`関数でキャストする必要があります。

    注： `aparse()`は大文字と小文字を区別しません。

    <CollapserGroup>
      <Collapser
        title="基本的な使用"
        id="aparse-basic"
        className="freq-link"
      >
        ```sql
        FROM PageView
          SELECT aparse(browserTransactionName, 'website.com/*')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>aparse()</InlineCode> 特定の値</>}
        id="aparse-specific-values"
        className="freq-link"
      >
        文字列の中央から値を抽出するには、パターン文字列の先頭と末尾で非キャプチャワイルドカード '%' を使用します。例:

        ```sql
        FROM Log
          SELECT count(*)
          FACET aparse(string, '%"itemId":"*"%')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>aparse()</InlineCode> 複数の値</>}
        id="aparse-multiple-values"
        className="freq-link"
      >
        複数の値を環境変数として抽出する場合は、順序が重要であることに注意してください。例:

        ```sql
        FROM Log
          WITH aparse(string, 'POST: * body: {"itemId":"*","unitPrice":*}\n') AS (url, itemId, unitPrice)
          SELECT url, itemId, unitPrice
        ```

        環境変数の詳細については、[NRQL環境変数](#with-as-nrql-var)を参照してください。
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-concat"
    title={<InlineCode>concat(属性, \[, 属性 \[, ...]]\[, 精度: ]))</InlineCode>}
  >
    `concat()`関数を使用して、引数を連結した結果の文字列を返します。

    数値、ブーリアン、タプル、または配列型の引数を20個まで指定できます。Null引数とサポートされていないタイプの引数は無視されます。引数が指定されていない場合、結果は空の文字列になります。

    浮動小数点数値を連結する際に含まれる小数点以下の桁数を制限するために、オプションの精度引数を提供することができます。

    結果の文字列の長さは最大4096文字です。

    <CollapserGroup>
      <Collapser title="書式設定された文字列としてPageViewから複数の期間値を取得">
        このクエリは、1つの文字列として小数点以下2桁とラベルで書式設定されたPageViewイベントから、バックエンドとネットワーク期間を返します。

        ```sql
        FROM PageView SELECT concat('Backend Duration: ', backendDuration, ', Network Duration: ', networkDuration, precision: 2)
        ```

        これにより、次のような形式で回答が返されます。

        `Backend Duration: 0.69, Network Duration: 0`
      </Collapser>

      <Collapser title="書式設定された文字列によるファセットクエリの結果">
        このクエリは、ユーザーの都市、地域、国で構成される文字列をファセットしたPageViewイベントからの平均接続セットアップ時間を返します。

        ```sql
        FROM PageView SELECT average(connectionSetupDuration) FACET concat(city, ', ', regionCode, ' ', countryCode) WHERE countryCode IN ('US', 'CA')
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-capture"
    title={<InlineCode>capture（属性、正規表現）</InlineCode>}
  >
    `capture()`を使用して、[RE2構文](https://github.com/google/re2/wiki/Syntax)の正規表現を使用して属性から値を抽出します。

    2つの引数が必要です。

    * 属性名。

    * capture構文を使用した正規表現。NRQLの正規表現は、Pythonのような構文`r'...'`を使用します。

      キャプチャする場合は、RE2名前付きキャプチャ構文`...(?P<name> pattern )...`は、指定された名前で、含まれるパターンをキャプチャします。

      複数の値をキャプチャするには、正規表現で追加のキャプチャグループを指定します。例: `...(?P<name1> pattern1)...(?P<name2> pattern2)...`

      注：複数の値をキャプチャする場合、各キャプチャ文では最大16個のキャプチャグループ、各NRQLクエリでは最大5個のキャプチャ文を持つことができます。

      [正規表現キャプチャを使用してクエリ結果を改善する](https://newrelic.com/blog/how-to-relic/using-regex-capture)方法をお読みください。

      <Callout variant="tip">
        正規表現は入力全体と一致する必要があります。キャプチャ式が期待される結果を抽出しない場合は、最初または最後に`.*`が必要かどうかを確認します。これは、部分一致正規表現のパターンです。ただし、部分一致正規表現は、クエリの実行を遅らせることがあります。
      </Callout>

      `capture()`を使用して、ダッシュボードの読みやすさを向上する方法を紹介する短いビデオ（3分05秒）もあります。

      <Video
        id="hOPrTWYgPHg"
        type="youtube"
      />

      詳しくは、以下の例をご覧ください。

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> <InlineCode>SELECT</InlineCode>句条件内</>}>
          以下では、ウェブサイトのドメイン名を選択し、`https://`とに続くパスを削除します。 `.com`

          ```sql
          SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') FROM PageView SINCE 1 day ago
          ```

          以下では、エラーメッセージの最初のワードのみがキャプチャされます。

          ```sql
          SELECT capture(errorMessage, r'(?P<firstWord>\S+)\s.+') FROM Transaction SINCE 1 hour ago where errorMessage is not null
          ```
        </Collapser>

        <Collapser title={<><InlineCode>capture()</InlineCode> <InlineCode>FACET</InlineCode>句条件内</>}>
          キャプチャしたHTTPメソッドによって、以下がファセットされます。

          ```sql
          SELECT count(*) FROM Log WHERE message like '%HTTP%' FACET capture(message, r'.* "(?P<httpMethod>[A-Z]+) .*')
          ```
        </Collapser>

        <Collapser title={<><InlineCode>capture()</InlineCode> <InlineCode>WHERE</InlineCode>句条件内</>}>
          以下は、キャプチャされたジョブ名が`ExampleJob`である正規表現と一致する`message`属性を持つログイベントに基づいて、結果をフィルター処理します。

          ```sql
          SELECT message FROM Log WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' SINCE 10 minutes ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> 数字型変換</>}>
          以下では、ログラインからCPU時間の合計をキャプチャします。数学演算を実行するには、明示的に数値にキャストする必要があります。

          ```sql
          SELECT sum(numeric(capture(message, r'.*CpuTime:\s(?P<cpuTime>\d+)'))) FROM Log WHERE message like '%CpuTime:%' SINCE 1 hour ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> NRQL環境変数を含む複数の値</>}>
          この例では、NRQL環境変数を使用して、ログメッセージからキャプチャした複数の値を格納します。

          ```sql
          FROM Log
            WITH capture(message, r'POST to carts: (?P<URL>.*) body: {"itemId":"(?P<UUID>.*)","unitPrice":(?P<unitPrice>.*)}.*')
              AS (URL, UUID, unitPrice)
            SELECT URL, UUID, unitPrice
            WHERE URL IS NOT NULL
          ```

          NRQL環境変数の詳細については、[こちら](#with-as-nrql-var)をご覧ください。
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="earliest-func"
    title={<InlineCode>earliest(attribute)</InlineCode>}
  >
    `earliest()`関数を使用して、指定された時間範囲における属性の最も古い値を返します。

    単一の引数を取ります。最初の引数以外は無視されます。

    `FACET`と併用する場合、この関数は得られた各ファセットの属性の最新値を返します。

    <CollapserGroup>
      <Collapser title="PageView からユーザーエージェントごとに最も古い国を取得">
        このクエリは、`PageView`イベントからユーザーエージェントごとに最も古い国コードを返します。

        ```sql
        SELECT earliest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="event-type"
    title={<InlineCode>eventType()</InlineCode>}
  >
    ```sql
    ...WHERE eventType() = 'EventNameHere'...
    ...FACET eventType()...
    ```

    [FACET](#sel-facet)句で`eventType()`関数を使用し、選択したデータ型別に結果を取り出し、または[WHERE](#sel-where)句で特定のデータ型に結果をフィルタリングします。これは [filter()](#func-filter) や [percentage()](#func-percentage) 関数で特定のデータ型を対象とする際に特に便利です。

    <Callout variant="important">
      この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータ型を指します。
    </Callout>

    <CollapserGroup>
      <Collapser
        id="filter-eventtype"
        title={<><InlineCode>eventType()</InlineCode>を<InlineCode>filter()</InlineCode>関数で使用</>}
      >
        このクエリは、合計`Transaction`の結果あたりの合計`TransactionError`の結果の割合を返します。`eventType()`関数を使用して、`filter()`関数で特定のデータ型をターゲットにすることができます。

        ```sql
        SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago
        ```
      </Collapser>

      <Collapser
        id="facet-eventtype"
        title={<><InlineCode>eventType()</InlineCode>を使用 <InlineCode>FACET</InlineCode></>}
      >
        このクエリは、各データ型（`Transaction`および`TransactionError`）が返すレコード数を表示します。

        ```sql
        SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-filter"
    title={<InlineCode>filter(function(attribute), WHERE condition)</InlineCode>}
  >
    `filter()`関数を使用して、SELECT文内の集計関数の1つに結果を制限します。`filter()`は`FACET`や`TIMESERIES`とともに使用できます。フィルターは、次のような複数の異なる集計を選択する場合にのみ便利です。

    ```sql
    SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' ...
    ```

    それ以外の場合は、標準`WHERE`句を使用するのが良いでしょう。

    <CollapserGroup>
      <Collapser title="オファーコードを使用した購入を分析する">
        `filter()`は、一連のトランザクションで購入された商品の中で、オファーコードを使用して購入された商品と、オファーコードを使用せずに購入された商品を比較するために使用できます。

        <img
          title="screenshot insights filter"
          alt="screenshot insights filter"
          src={queriesnrqlFilterNRQLQueryBuilder}
        />

        <figcaption>
          `filter()`関数を使用して、`SELECT`文内の集計関数の1つに結果を制限します。
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-funnel"
    title={<InlineCode>funnel(attribute, steps)</InlineCode>}
  >
    `funnel()`関数を使用して、ファネルチャートを生成します。属性を最初の引数として取ります。その後、カンマで区切られた[`WHERE`](#sel-where)句（オプションでラベル付け用に[`AS`](#sel-as)句を含める）としてステップを指定します。

    詳細な情報と例については、 [ファネルのドキュメント](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/funnels-evaluate-data-series-events)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getfield"
    title={<InlineCode>getField(attribute, field)</InlineCode>}
  >
    `getField()`関数を使用して、[ディメンションメトリックデータ](/docs/data-apis/understand-data/metric-data/metric-data-type)などの複合データ型からフィールドを抽出します。

    次の引数を取ります。

    <table>
      <thead>
        <tr>
          <th style={{ width: "500px" }}>
            メトリックタイプ
          </th>

          <th>
            サポートされているフィールド
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `summary`
          </td>

          <td>
            `count`、`total`、`max`、`min`、 `type`
          </td>
        </tr>

        <tr>
          <td>
            `gauge`
          </td>

          <td>
            `count`、`total`、`max`、`min`、`latest`、 `type`
          </td>
        </tr>

        <tr>
          <td>
            `distribution`
          </td>

          <td>
            `count`、`total`、`max`、`min`、 `type`
          </td>
        </tr>

        <tr>
          <td>
            `count`
          </td>

          <td>
            `count`、 `type`
          </td>
        </tr>

        <tr>
          <td>
            `cumulativeCount`
          </td>

          <td>
            `count`、`cumulative`、 `type`
          </td>
        </tr>

        <tr>
          <td>
            `timeslice`
          </td>

          <td>
            `count`、`total`、`totalExclusive`、`min`、`max`、 `sumOfSquares`
          </td>
        </tr>
      </tbody>
    </table>

    例：

    ```sql
    SELECT max(getField(mySummary, count)) from Metric
    ```

    ```sql
    SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-histogram"
    title={<InlineCode>histogram(attribute, ceiling \[,number of buckets])</InlineCode>}
  >
    `histogram()`関数を使用して、ヒストグラムを生成します。この関数は、以下の3つの引数を取ります。

    * 属性名

    * サンプル範囲の最大値

    * バケットの合計数（1～500（500を含む））

      <CollapserGroup>
        <Collapser
          id="histogram-response-times"
          title="PageViewイベントからのレスポンスタイムのヒストグラム"
        >
          このクエリは20バケットにわたって10秒以内のレスポンスタイムのヒストグラムを生成します。

          ```sql
          SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="histogram-prometheus"
          title="Prometheusヒストグラムバケット"
        >
          `histogram()` Prometheusヒストグラムバケットを受け取ります。

          ```sql
          SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="distribution-metric"
          title="New Relicディストリビューションメトリック"
        >
          `histogram()` [ディストリビューションメトリック](/docs/data-ingest-apis/get-data-new-relic/metric-api/events-metrics-service-create-metrics#limits-rules)を入力として受け取ります。

          ```sql
          SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="histogram-facet-heatmap"
          title="FACET句があるヒストグラム"
        >
          `FACET`句とともに`histogram()`を使用し、ヒートマップチャートを生成します。

          ```sql
          SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-if"
    title={<><InlineCode>if(condition, trueValue , falseValue)</InlineCode></>}
  >
    `if()`を使用して、クエリ全体でif-then-elseコントロールフロー操作を実行します。

    `if()` 次の3つの引数が必要です。

    * 条件 - trueまたはfalseに評価できる式
    * trueValue - ブール式がtrueの場合、この値が返されます
    * falseValue - ブール式がfalseの場合、またはNULLが指定されていない場合に、このオプション値が返されます

    <CollapserGroup>
      <Collapser title="基本的な使用">
        ```sql
        FROM Log
          SELECT count(*)
          FACET if(level_name = 'ERROR', 'ERROR', 'NOT_ERROR')
        ```
      </Collapser>

      <Collapser title={<><InlineCode>AND</InlineCode>およびと併用 <InlineCode>OR</InlineCode></>}>
        ```sql
        FROM Log
          SELECT count(*)
          FACET if(level_name = 'INFO’ OR level_name = ‘WARNING’, 'NOT_ERROR', 'ERROR’)
        ```
      </Collapser>

      <Collapser title={<>ネストされた <InlineCode>If()</InlineCode></>}>
        ネストされたif()関数を使用して、条件付きロジックを追加します。

        ```sql
        FROM Transaction SELECT count(*)
          FACET if(appName LIKE '%java%', 'Java',
          if(appName LIKE '%kafka%', 'Kafka', 'Other'))
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="keyset"
    title={<InlineCode>keyset()</InlineCode>}
  >
    `keyset()`を使用すると、所定の時間範囲における所定のデータ型に対するすべての属性を表示できます。この関数は引数を取りません。文字列型キー、数値型キー、ブール型キー、およびすべてのキーをグループ化したJSON構造体を返します。

    <CollapserGroup>
      <Collapser title="データ型のすべての属性を表示">
        このクエリは、最終日からの`PageView`イベントで見つかった属性を返します。

        ```sql
        SELECT keyset() FROM PageView SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latest"
    title={<InlineCode>latest(attribute)</InlineCode>}
  >
    `latest()`関数を使用して、指定された時間範囲における属性の最新値を返します。

    単一の引数を取ります。最初の引数以外は無視されます。

    `FACET`と併用する場合、この関数は得られた各ファセットの属性の最新値を返します。

    <CollapserGroup>
      <Collapser title="PageViewからユーザーエージェントごとに最新の国を取得">
        このクエリは、`PageView`イベントからユーザーエージェントごとに最新の国コードを返します。

        ```sql
        SELECT latest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-length"
    title={<InlineCode>length（属性）</InlineCode>}
  >
    `length()`関数を使用して、文字列値の長さまたは配列値の要素数を返します。

    単一の引数を取ります。最初の引数以外は無視されます。

    <CollapserGroup>
      <Collapser title="PageViewからURLの長さを取得する">
        このクエリは、`PageView`イベントから各URL文字列の長さを返します。

        ```sql
        SELECT length(pageUrl) FROM PageView
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-lower"
    title={<InlineCode>lower(str)</InlineCode>}
  >
    `lower()`関数を使用して、文字列値のアルファベット文字をすべて小文字に変更します。

    引数：

    * str - 小文字にする文字列値

      * これは、引用符内のリテラル文字列、クエリされた文字列属性、文字列を返す関数、または単一の文字列値を返すサブクエリなどの文字列に評価されるものなら何でもかまいません。
      * この引数がnullと評価される場合は、`lower()`関数はnullを返します。

      <CollapserGroup>
        <Collapser title="文字列を小文字にする">
          このクエリは、クエリのさまざまな部分で`lower()`関数を使用する方法を示します。

          ```sql
          FROM PageAction
          SELECT latest(lower(actionName))
          WHERE lower(actionName) = lower('acmePageRenderedEvent') OR lower(actionName) = lower('SubmitLogin')
          FACET concat(actionName, ':', lower(actionName))
          ```

          <img
            title="screenshot lower()"
            alt="screenshot lower()"
            src={lowerExample}
          />

          <figcaption>
            <InlineCode>lower(str)</InlineCode> 例
          </figcaption>
        </Collapser>
      </CollapserGroup>

      _関連機能：[<InlineCode>upper()</InlineCode>](#func-upper)_
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-position"
    title={<InlineCode>position(str, substr \[, occurrence])</InlineCode>}
  >
    `position()`関数を使用して、文字列内の部分文字列の位置を検索します。

    引数：

    * str - 部分文字列を検索する文字列。

      * これは、引用符内のリテラル文字列、クエリされた文字列属性、文字列を返す関数、または単一の文字列値を返すサブクエリなどの文字列に評価されるものなら何でもかまいません。

    * substr - 文字列内で検索する文字列。

    * occurrence - 部分文字列の出現する位置を返します。

      * _デフォルト：_0
      * 正の場合、ゼロベースで文字列の先頭からn番目に出現する部分文字列を検索します。
      * 負の場合、文字列の末尾からn番目に出現する部分文字列を検索します。最後に出現する部分文字列は-1になります。

      Alias：<InlineCode>indexOf(str, substr , occurrence)</InlineCode> - `indexOf()`は`position()`関数の代替名です

      戻り値：

      * 文字列内での部分文字列の開始文字の0ベースのインデックス
      * 参照された部分文字列の出現が見つからない場合、-1が返されます
      * 文字列または部分文字列がnullの場合は、nullを返します
      * 検索では大文字と小文字が区別されます

    <CollapserGroup>
      <Collapser title="URL内の部分文字列の位置インデックスを検索します。">
        このクエリは、<InlineCode>position()</InlineCode>関数を使用して文字列内のさまざまな部分文字列の位置インデックスを検索する方法を示します。ここでは、[<InlineCode>position()</InlineCode>](#func-substring)関数の引数内での<InlineCode>substring()</InlineCode>関数の使用も示します。

        ```sql
        FROM PageView
        WITH position(pageUrl, ':') as FirstColon,
          position(pageUrl, '/', 1) + 1 as DomainBegin, position(pageUrl, '/', 2) as DomainEnd, DomainEnd - DomainBegin as DomainLength
        SELECT pageUrl, FirstColon, substring(pageUrl, 0, FirstColon) as Protocol,
          DomainBegin, DomainEnd, DomainLength, substring(pageUrl, DomainBegin, DomainLength) as Domain,
          position(pageUrl, '/', -1) as LastSlash, substring(pageUrl, position(pageUrl, '/', -1)) as PathEnd
        ```

        <img
          title="screenshot position()"
          alt="screenshot position()"
          src={positionExample}
        />

        <figcaption>
          <InlineCode>position(str, substr , occurrence)</InlineCode> 例
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-string"
    title={<InlineCode>string(attribute \[, precision: ])</InlineCode>}
  >
    `string()`関数を使用して、数値、ブーリアン値、タプル値、または配列値を文字列値に変換します。

    次の2つの引数を取り、1つはオプションです。

    * 属性名
    * 精度：存在する場合、浮動小数点数値を変換する際に含まれる小数点以下の桁数に制限を適用します。

    <CollapserGroup>
      <Collapser title="文字列以外のクエリ結果を文字列値として取得">
        このクエリは、PageView期間を小数第2位までの文字列として返します。

        ```sql
        FROM PageView SELECT string(duration, precision: 2)
        ```
      </Collapser>

      <Collapser title="文字列以外の集計関数の結果を文字列値として取得">
        このクエリは、PageView期間の平均を小数第2位までの文字列として返します。

        ```sql
        FROM PageView SELECT string(average(duration), precision: 2)
        ```
      </Collapser>

      <Collapser title="切り捨てなしの浮動小数点数によるファセットクエリの結果">
        `string()`を使用して、小数点以下の桁数を失うことなく浮動小数点値でファセットします。

        ```sql
        FROM PageView SELECT count(*) FACET string(tuple(asnLatitude, asnLongitude), precision: 2)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-substring"
    title={<InlineCode>substring(str, start \[, length])</InlineCode>}
  >
    `substring()`関数を使用して文字列の一部を抽出します。

    引数：

    * str - 部分文字列を抽出する文字列。

      * これは、引用符内のリテラル文字列、クエリされた文字列属性、文字列を返す関数、または単一の文字列値を返すサブクエリなどの文字列に評価されるものなら何でもかまいません。
      * この引数がnullと評価される場合は、`substring()`関数はnullを返します。

    * start - 抽出を開始する文字列内の位置。

      * 文字列の最初の文字位置は0です。
      * 負の値は、文字列の末尾の文字位置が-1で、文字列の末尾に相対的な位置を検索します。
      * startが文字列の長さより長いか等しい場合、`substring()`関数は空の文字列を返します。
      * startが負で、その絶対値が文字列の長さより長い場合、抽出された部分文字列の位置は0から開始されます。

    * length - 文字列から抽出する部分文字列の長さまたは文字数。

      * _オプション_ - 長さが指定されていない場合、解決された開始位置の後の文字列のすべての文字が含まれます。

      <CollapserGroup>
        <Collapser title="文字列のさまざまな部分を抽出">
          このクエリはセッション値の一部を返します。

          ```sql
          FROM PageView
          SELECT session, substring(session, 0, 3) as First3,
            substring(session, 3) as After3rd,
            substring(session, -3) as Last3
          ```

          <img
            title="screenshot substring()"
            alt="screenshot substring()"
            src={substringExample}
          />

          <figcaption>
            <InlineCode>substring(str, start , length)</InlineCode> 例
          </figcaption>
        </Collapser>
      </CollapserGroup>

      _<InlineCode>position()</InlineCode>と<InlineCode>substring()</InlineCode>を一緒に使用する例については、[<InlineCode>position()</InlineCode>](#func-position)関数を参照してください。_
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-upper"
    title={<InlineCode>upper(str)</InlineCode>}
  >
    `upper()`関数を使用して、文字列値のアルファベット文字をすべて大文字に変更します。

    引数：

    * str - 大文字にする文字列値

    * これは、引用符内のリテラル文字列、クエリされた文字列属性、文字列を返す関数、または単一の文字列値を返すサブクエリなどの文字列に評価されるものなら何でもかまいません。

    * この引数がnullと評価される場合は、`upper()`関数はnullを返します。

      <CollapserGroup>
        <Collapser title="文字列を大文字にする">
          このクエリは、クエリのさまざまな部分で`upper()`関数を使用する方法を示します。

          ```sql
          FROM PageAction
          SELECT latest(upper(actionName))
          WHERE upper(actionName) = upper('acmePageRenderedEvent') OR upper(actionName) = upper('SubmitLogin')
          FACET concat(actionName, ':', upper(actionName))
          ```

          <img
            title="screenshot upper()"
            alt="screenshot upper()"
            src={upperExample}
          />

          <figcaption>
            <InlineCode>upper(str)</InlineCode> 例
          </figcaption>
        </Collapser>
      </CollapserGroup>

      _関連関数：[<InlineCode>lower()</InlineCode>](#func-lower)_
  </Collapser>
</CollapserGroup>

## データ型変換

NRQLは「型強制」をサポートしていません。つまり、文字列として保存されたフロートは文字列として取り扱われ、フロート値を要求する関数に渡しても操作できません。

以下に示す関数で、数値を伴う文字列、または文字列を伴うブーリアン値を同等の数値またはブーリアン値に変換したり、文字列以外の値を文字列値に変換したりできます。

* `numeric()`関数を使用して、文字列形式の数値を数値に変換します。この関数は、クエリ結果に数学関数を使用するクエリ、または`average()`などのNRQL集計関数に組み込むことができます。
* `boolean()`関数を使用して、`"true"`または`"false"`の文字列値を対応するブーリアン値に変換します。
* `string()`関数を使用して、数値、ブーリアン値、タプル値、または配列値を文字列値に変換します。詳細については、上記の[`string()`](#func-string)を参照してください。