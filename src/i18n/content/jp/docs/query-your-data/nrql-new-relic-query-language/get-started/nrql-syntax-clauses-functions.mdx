---
title: NRQLの構文、句、関数
tags:
  - Query your data
  - 'NRQL: New Relic Query Language'
  - Get started
metaDescription: 'A detailed reference list of clauses and functions in NRQL, the New Relic query language.'
translationType: human
---

import screenApdexFunction from 'images/screen-apdex-function.png'

import percentile0 from 'images/percentile_0.png'

import screenshotInsightsFilter00 from 'images/screenshot_insights_filter_0_0.png'

NRQLは、New Relicデータベースのクエリに使用できるクエリ言語です。このドキュメントでは、NRQLの構文、句、構成要素、関数について説明します。

## 構文 [#syntax]

このドキュメントは、NRQLクエリで使用される関数と句の参考資料です。NRQLを理解するためのその他のリソース：

* [NRQLの概要](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql)：どのようなNRQLが使用されるのか、それでどのようなデータをクエリできるのか、基本的なNRQL構文について説明しています。
* [New Relicチャートの作成に使用するNRQLクエリを検証する](/docs/using-new-relic/user-interface-functions/view-your-data/standard-new-relic-ui-page-functions#view-query)
* [`Metric`データ型のクエリ方法を習得](/docs/telemetry-data-platform/get-data/apis/query-metric-data-type)
* [ファネルを使用して一連の関連データを評価する](/docs/insights/new-relic-insights/features/funnels)
* [イベントAPIでクエリを行うNRQLをフォーマットする](/docs/insights/insights-api/get-data/query-insights-event-data-api)

## クエリの構成要素 [#clauses]

すべてのNRQLクエリは`SELECT`文または`FROM`句で始まります。その他のすべての句はオプションです。以下の句の定義には、NRQLクエリの例も含まれます。

### 必要な句 [#required]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="state-select"
    title={<>必須：<InlineCode>SELECT</InlineCode>文</>}
  >
    ```
    SELECT attribute ...
    ```

    ```
    SELECT function(attribute) ...
    ```

    `SELECT`は、[属性](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#attribute)または[関数](#functions)を指定することによって、データ型のどの部分をクエリするかを指定します。その後、カンマ区切りの1つ以上の引数が続きます。各引数では、以下を実行できます。

    * ワイルドカードとして`*`を使用することで、利用可能なすべての属性値を取得。例：`SELECT * from Transaction`。
    * 指定した属性、または [カンマ区切りのリスト](#commas)で指定した複数の属性に関連する値を取得。
    * [集計関数](#functions)を選択することで、指定した属性から集計値を取得。
    * [`AS`句](#sel-as)で、各引数で返された結果にラベル付け。

    [基本的な数学関数とともに`SELECT`を使用する](/docs/query-data/nrql-new-relic-query-language/getting-started/nrql-math-using-select)こともできます。

    <CollapserGroup>
      <Collapser
        id="avg-resp-time-query"
        title="直近1週間の平均レスポンスタイム"
      >
        このクエリは、直近1週間の平均応答時間を返します。

        ```
        SELECT average(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-from"
    title={<>必須：<InlineCode>FROM</InlineCode>句</>}
  >
    ```
    SELECT ...
      FROM data type
      ...
    ```

    `FROM`句を使用して、クエリする[データ型](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql#what-you-can-query)を指定します。クエリは`FROM`または[`SELECT`](#state-select)で開始できます。[カンマ区切りのリスト](#commas)の複数のデータタイプにまたがる同じ属性の値をマージできます。

    <CollapserGroup>
      <Collapser
        id="one-event"
        title="1つのデータ型のクエリ"
      >
        このクエリは、直近3日間の [APMトランザクション](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults)の全カウント数を返します。

        ```
        SELECT count(*) FROM Transaction SINCE 3 days ago
        ```
      </Collapser>

      <Collapser
        id="multiple-events"
        title="複数のデータ型のクエリ"
      >
        このクエリは、直近3日間の[APMトランザクション](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults)と[ブラウザイベント](/docs/insights/new-relic-insights/decorating-events/browser-default-attributes-insights#browser-attributes-table)の全カウント数を返します。

        ```
        SELECT count(*) FROM Transaction, PageView SINCE 3 days ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### オプション句 [#optional]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="sel-as"
    title={<><InlineCode>AS</InlineCode> 句</>}
  >
    ```
    SELECT ...
      AS 'label'
      ...
    ```

    `AS`句を使用して、シングルクォート区切りの文字列で属性、集計、ファネル内のステップ、または数学関数の結果にラベルを付けます。このラベルは結果のチャートで使用されます。

    <CollapserGroup>
      <Collapser
        id="math-as"
        title={<>数学関数とを使用したクエリ <InlineCode>AS</InlineCode></>}
      >
        このクエリはセッションごとのページ数を返します。

        ```
        SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session'
          FROM PageView
        ```
      </Collapser>

      <Collapser
        id="funnel-as"
        title={<>ファネルとを使用したクエリ <InlineCode>AS</InlineCode></>}
      >
        このクエリは、過去1週間でサイトのメインページと採用情報ページの両方を訪れた人の数を返します。

        ```
        SELECT funnel(SESSION,
            WHERE name='Controller/about/main' AS 'Step 1',
            WHERE name = 'Controller/about/careers' AS 'Step 2')
            FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-compare"
    title={<><InlineCode>COMPARE WITH</InlineCode> 句</>}
  >
    ```
    SELECT ... (SINCE or UNTIL) (integer units) AGO
      COMPARE WITH (integer units) AGO
      ...
    ```

    `COMPARE WITH`句を使用すると、2つの異なる時間範囲の値を比較できます。

    `COMPARE WITH` には`SINCE`または`UNTIL`文が必要です。`COMPARE WITH`で指定された時間は、`SINCE`または`UNTIL`で指定した時間に相対します。たとえば、`SINCE 1 day ago COMPARE WITH 1 day ago`昨日を一昨日と比較します。

    `COMPARE WITH`値の時間範囲は、常に`SINCE`または`UNTIL`で指定されたものと同じになります。たとえば、`SINCE 2 hours ago COMPARE WITH 4 hours ago`は午後3時〜5時までと午前11時〜午後1時までを比較できます。

    `COMPARE WITH` 結果は、折れ線グラフまたはビルボードで表示できます。

    * `TIMESERIES`を使用すると、`COMPARE WITH`は比較内容を経時的にマッピングした折れ線グラフを作成します。
    * `TIMESERIES`がない場合、`COMPARE WITH`は現在値と`COMPARE WITH`値からの増減率でビルボードを生成します。

    **例：**このクエリは、データを過去1時間の95パーセンタイルと1週間前の同じ範囲を表示する折れ線グラフで返します。最初は単一値、次は折れ線グラフです。

    ```
    SELECT percentile(duration) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO

    SELECT percentile(duration) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="extrapolate"
    title={<><InlineCode>EXTRAPOLATE</InlineCode> 句</>}
  >
    この句は以下のデータ型で使用できます。

    * `Transaction`

    * `TransactionError`

    * APMエージェントAPIで報告されたカスタムイベント

      `EXTRAPOLATE`の目的は、クエリ結果がシステム内のアクティビティ全体をより厳密に表現できるよう、[イベントデータのAPMエージェントサンプリング](/docs/agents/manage-apm-agents/agent-data/new-relic-events-limits-sampling)の影響を数学的に補うことです。

      この句は、APMエージェントが[収集サイクル](/docs/using-new-relic/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#event-data)の報告限度をしばしば超過する多くの[イベント](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#harvest-cycle)を報告する際に便利です。その場合、エージェントはイベントのサンプリングを開始します。

      `EXTRAPOLATE`に対応したNRQLクエリでこれを使用する場合、**報告されたイベント**と**合計イベント**の比率で、合計未サンプルデータの近似を推定します。この句に未対応であるか、サンプルデータを使用していないNRQLでこれを使用する場合、結果に影響を与えません。

      <Callout variant="important">
        `EXTRAPOLATE`は、（スループットまたはエラー率など）同種データに対して最も有用である点に注意してください。（`uniqueCount()`または`uniques()`など）特徴的なものの数を外挿する際には有効ではありません。
      </Callout>

      この句は、以下のいずれかの[集計関数](/docs/insights/nrql-new-relic-query-language/nrql-reference/nrql-syntax-components-functions#functions)を使用するNRQLクエリでのみ機能します。

    * apdex

    * average

    * count

    * ヒストグラム

    * sum

    * percentage（引数として取る関数が`EXTRAPOLATE`に対応している場合）

    * rate（引数として取る関数が`EXTRAPOLATE`に対応している場合）

    * stddev

      <CollapserGroup>
        <Collapser
          id="extrapolate-example-1"
          title="スループットの推定の例"
        >
          `interestingApplication`という名前のサービスの推定スループットを示すクエリ。

          ```
          SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE
          ```
        </Collapser>

        <Collapser
          id="extrapolate-example-2"
          title="時系列としてのスループットの推定の例"
        >
          トランザクション名ごとに、時系列として表示する`interestingApplication`という名前のサービスの推定スループットを示すクエリ。

          ```
          SELECT count(*) FROM Transaction WHERE appName='interestingApplication'
          SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet"
    title={<><InlineCode>FACET</InlineCode> 句</>}
  >
    ```
    SELECT ...
      FACET attribute
      ...
    ```

    `FACET`を使用すると、結果を属性値で分割してグループ化できます。たとえば、`PageView`データで`deviceType`別に`FACET`を行い、トラフィックの何割が携帯電話、タブレット、およびデスクトップデバイスから発生しているかを把握することができます。

    `LIMIT`句を使用して、表示するファセットの数を指定します（デフォルトは10）。より複雑なグループ化に関しては、[`FACET CASES`](#sel-facet-cases)を使用します。`FACET`句は、カンマで区切られた最大5つの属性をサポートします。

    ファセットは、`SELECT`句で指定した最初のフィールドによって降順でソートされます。2,000件以上のユニーク値を持つ属性をファセットに指定した場合、ファセット値のサブセットを選択し、それらをクエリタイプに従って並べ替えます。

    `min()`、`max()`、`percentile()`、`average()`、または`count()`を選択すると、`FACET`はこれらの関数を使用してファセットの選択方法とソート方法を決定します。その他の[関数](#functions)を選択すると、`FACET`はファセット対象の属性の発生頻度に基づいて、ファセットの選択方法とソート方法を決定します。

    <CollapserGroup>
      <Collapser
        id="faceted-query"
        title={<>使用したファセットクエリ <InlineCode>count()</InlineCode></>}
      >
        このクエリは、ページビュー数が最も多い都市を表示します。このクエリは、都市ごとのページビューの合計数を使用してファセットの選択方法と並べ替え方法を決定します。

        ```
        SELECT count(*) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="uniquecount"
        title={<>使用したファセットクエリ <InlineCode>uniqueCount()</InlineCode></>}
      >
        このクエリは、最も多数のユニークURLにアクセスしている都市を表示します。このクエリは、特定の都市が結果に表れる合計回数を使用して、ファセットの選択方法と並べ替え方法を決定します。

        ```
        SELECT uniqueCount(pageUrl) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="cohort-analysis"
        title="時間範囲で結果をグループ化"
      >
        [高度なセグメンテーション](/docs/insights/new-relic-insights/features/advanced-segmentation)や[コホート分析](/docs/insights/new-relic-insights/features/cohort-analysis-grouping-results-across-time)では、バケット機能でファセットすることでデータをより効率的に分割することができます。

        コホート分析は、タイムスタンプに基づいて結果をグループ化する方法です。指定範囲日時に対応するバケットに結果を分割することができます。
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    title={<><InlineCode>FACET ... AS</InlineCode> 句</>}
  >
    `FACET ... AS`句では、クエリで`AS`キーワードを使用してファセットに名前を付けます。この句は、結果のファセットに明確な名前または簡略化された名前を追加するのに役立ちます。[ネスト構造の集計](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query)クエリで、ファセットの名前を変更するためにも使用できます。

    `FACET ... AS` クエリでは、結果のファセット名が変更されますが（たとえば、テーブルのヘッダーとして表示される場合）、実際のファセット名自体は変更されません。

    ```
    FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type'
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-cases"
    title={<><InlineCode>FACET CASES</InlineCode> 句</>}
  >
    ```
    SELECT ...
      FACET CASES (
        WHERE <var>attribute</var> <var>operator</var> <var>value</var>, WHERE <var>attribute</var> <var>operator</var> <var>value</var>, ...
        )
      ...
    ```

    `FACET CASES`を使用して、[`FACET`](#sel-facet)で可能な範囲を超えた複雑な条件別にデータを取り出します。複数の条件はカンマ`,`で区切ります。たとえば、PageViewデータをクエリして、1秒未満、1秒から10秒、10秒を上回るといったカテゴリに`FACET CASES`を行うことができます。ケース内の複数の属性を組み合わせ、[`AS`](#sel-as)セレクタでケースにラベルを付けることができます。データ点は、最大で1つのファセットケースに追加されます。つまり、一致する最初のファセットになります。

    また、属性とともに[時間関数](/docs/query-data/nrql-new-relic-query-language/nrql-query-examples/group-results-across-time)を使用することもできます。また、`OR`演算子を使用して、指定したどのケースにも一致しないファセット結果を表示することもできます。

    <CollapserGroup>
      <Collapser
        id="facet-cases-basic"
        title={<>基本的な使用 <InlineCode>WHERE</InlineCode></>}
      >
        ```
        SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10)
        ```
      </Collapser>

      <Collapser
        id="facet-cases-mixnmatch"
        title="複数の属性に基づくグループ化"
      >
        この例は、トランザクション名に`login`が含まれる1つのバケットと、URLに`login`が含まれ、かつカスタムアトリビュートがユーザーが有料ユーザーであったことを示すもう1つのバケットに結果をグループ化します。

        ```
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid')
        ```
      </Collapser>

      <Collapser
        id="facet-cases-as-label"
        title={<>グループのラベル付け <InlineCode>AS</InlineCode></>}
      >
        この例は、結果に人間が読める名前をつけるために[`AS`](#sel-as)セレクタを使います。

        ```
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users')
        ```
      </Collapser>

      <Collapser
        id="facet-cases-with-or"
        title={<>ファセット不一致データ <InlineCode>OR</InlineCode></>}
      >
        この例では、`OR`演算子を使用して、どのケースにも一致しないファセット結果を表示しています。

        ```
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') OR name
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-order"
    title={<><InlineCode>FACET ... ORDER BY</InlineCode> 句</>}
  >
    NRQLでは、デフォルトは`SELECT`句の最初の集計で、クエリ内のファセットの選択をガイドします。`FACET ... ORDER BY`では、ORDER BY修飾子で集計関数を追加し、ファセットの選択方法を指定することで、このデフォルト動作をオーバーライドできます。具体的には、`LIMIT`句によって制限される前に、最終結果に含めるファセットの優先度をオーバーライドします。この句はクエリで使用できますが、アラートやストリーミングには使用できません。

    この例では、`FACET ... ORDER BY`を使用してアプリトランザクションの平均期間を見つける方法を示し、応答サイズが最大のアプリによる上位10（デフォルトの制限）の最大期間を示しています。この場合、`FACET ... ORDER BY`が使用されていない場合、クエリ結果には、アプリの選択とは関係のない応答サイズで、期間が最も長い上位10件が代わりに表示されます。

    ```
    FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize)
    ```

    <Callout variant="tip">
      `LIMIT`句が適用される前に操作が実行されるため、`FACET ... ORDER BY`は、最終的なクエリ結果の種類に影響を与えません。これは、非時系列クエリの結果で特に顕著になります。
    </Callout>

    <Callout variant="important">
      この場合の`ORDER BY`修飾子は、`ORDER BY`句とは機能が異なります。`FACET attribute1 ORDER BY attribute2`の形式に従うクエリを構文解析する場合、New Relicはこれらのクエリを`FACET ... ORDER BY`クエリとして読み取りますが、`ORDER BY`が`FACET`の直後に表示される場合に限定されます。それ以外の場合、`ORDER BY`はNew Relicによって句として解釈されます。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-limit"
    title={<><InlineCode>LIMIT</InlineCode> 句</>}
  >
    ```
    SELECT ...
      LIMIT count
      ...
    ```

    `LIMIT`句を使用して、`FACET`クエリで返されるファセット値の最大数、または`SELECT *`クエリで返される項目の最大数を制御します。この句は、単一の整数値を引数に取ります。`LIMIT`句が指定されない、または値が提供されない場合、リミットのデフォルト設定は、`FACET`クエリの場合は10、`SELECT *`クエリの場合は100となります。

    `LIMIT`句で許容される最大値は2,000です。

    <CollapserGroup>
      <Collapser title={<>使用したクエリ <InlineCode>LIMIT</InlineCode></>}>
        このクエリはセッション数上位20カ国を表示し、各国のWindowsユーザー限定でレスポンスタイムの95パーセンタイルを提供します。

        ```
        SELECT uniqueCount(session), percentile(duration, 95)
          FROM PageView WHERE userAgentOS = 'Windows'
          FACET countryCode LIMIT 20 SINCE YESTERDAY
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-offset"
    title={<><InlineCode>OFFSET</InlineCode> 句</>}
  >
    ```
    SELECT ...
      LIMIT count OFFSET count
      ...
    ```

    `OFFSET`句と`LIMIT`句を使用して、`SELECT *`または`SELECT column`クエリによって返される行の一部を制御します。`LIMIT`句と同様に、`OFFSET`は引数として単一の整数値を取ります。`OFFSET`は、クエリで選択された行が返される前に、スキップされる行数を設定します。これは`LIMIT`によって制約されます。

    `OFFSET` 行はスキップされ、直近のレコードから開始されます。

    たとえば、クエリ`SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1`は、最新の値を除き、`Minute_Report`から最後の5つの値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-order-by"
    title={<><InlineCode>ORDER BY</InlineCode> 句</>}
  >
    `ORDER BY`句を使用すると、行でイベント属性を選択するクエリで結果を並べ替える方法を指定できます。

    このクエリは、期間順にトランザクションを並べ替えます。

    ```
    FROM Transaction SELECT appName, duration ORDER BY duration
    ```

    デフォルトの並べ替え順序は昇順ですが、`ASC`または`DESC`の修飾子を追加することで変更できます。
  </Collapser>

  <Collapser
    className="freq-link"
    id="show-event-types"
    title={<><InlineCode>SHOW EVENT TYPES</InlineCode> 句</>}
  >
    ```
    SHOW EVENT TYPES...
    ```

    `SHOW EVENT TYPES` は、特定の時間範囲内にアカウントに存在するすべてのデータ型のリストを返します。これは、`SELECT`の代わりにクエリの最初の句として使用されます。

    <Callout variant="important">
      この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータ型を指します。
    </Callout>

    <CollapserGroup>
      <Collapser
        id="avg-resp-time-query"
        title="直近1日のデータ型"
      >
        このクエリは、直近1日のすべてのデータ型を返します。

        ```
        SHOW EVENT TYPES SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-since"
    title={<><InlineCode>SINCE</InlineCode> 句</>}
  >
    ```
    SELECT ...
      SINCE [numerical units AGO | phrase]
      ...
    ```

    **デフォルト**値は **1 時間前**です。

    `SINCE`句を使用して、返されたデータに対する時間範囲の開始を定義します。タイムゾーンは結果ではなく、クエリに対して指定できます。NRQLの結果はシステム時間に基づきます。

    NRQLを使用する場合、UTCタイムスタンプまたは相対時間範囲を設定できます。

    * タイムスタンプは`YYYY-MM-DD HH:MM:SS ZZZZ`の形式を使用します。たとえば、`FROM Transaction SELECT count(*) SINCE '2021-12-25 00:00:00 +0000' UNTIL '2021-12-25 23:59:59 +0000'`。
    * 当社は、以下の相対時間範囲をサポートしています：`YESTERDAY`、`TODAY`、`SUNDAY`、`MONDAY`、`TUESDAY`、`WEDNESDAY`、`THURSDAY`、`FRIDAY`、`SATURDAY`。例、`SINCE YESTERDAY UNTIL NOW`。
    * また、`YEAR`、`QUARTER`、`MONTH`、`WEEK`、`DAY`、`HOUR`、`MINUTE`、`SECOND`もサポートしています。この場合、`SINCE`を`THIS`または`LAST`と組み合わせることができます。たとえば、`SINCE LAST MONTH UNTIL THIS WEEK`。`SINCE 3 WEEKS AGO UNTIL 10 MINUTES AGO`のように、`AGO`を含めることもできます。
  </Collapser>

  <Collapser
    className="freq-link"
    id="slide-by"
    title={<><InlineCode>SLIDE BY</InlineCode> 句</>}
  >
    `SLIDE BY`句は、スライディングウィンドウと呼ばれる機能をサポートしています。スライディングウィンドウを使用すると、`SLIDE BY`データは、互いに重複する時間の「ウィンドウ」に収集されます。これらのウィンドウは、移動集計（移動平均など）が狭い時間枠からの集計よりも重要である場合に、変動の多い折れ線グラフを滑らかにするのに役立ちます。

    `SLIDE BY`を使用するには、`TIMESERIES`句の後のクエリにこの句を配置します。たとえば、このクエリは1分の`SLIDE BY`間隔で5分間のウィンドウにデータをプルします。つまり、各ウィンドウは5分間続きますが、ウィンドウ1は0分後に開始し、ウィンドウ2は1分後に開始し、ウィンドウ3は2分後に開始します。

    ```
    SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute
    ```

    `SLIDE BY`をいつ、どのように使用できるかについての詳細は、[スライディングウィンドウを使用してよりスムーズなグラフを作成する](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows)を参照してください。または、この短いビデオをご覧ください（約3分20秒）。

    <Video
      id="b9WVyb1wU6w"
      type="youtube"
    />

    <CollapserGroup>
      <Collapser
        id="sliding-window-max-auto"
        title={<><InlineCode>SLIDE BY</InlineCode>を<InlineCode>MAX</InlineCode>または<InlineCode>AUTO</InlineCode>間隔と使用</>}
      >
        スライディングウィンドウは、`MAX`または`AUTO`と組み合わせて使用できます。ただし、`MAX`または`AUTO`を`TIMESERIES`と`SLIDE BY`の間に配置することはできません。

        このクエリは、`SLIDE BY`ウィンドウ間隔を自動的に決定します。

        ```
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO
        ```

        このクエリはSLIDE BYウィンドウを最高間隔粒度に設定します。

        ```
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX
        ```

        <Callout variant="important">
          `AUTO`または`MAX`によって決定される`SLIDE BY`値は、ウィンドウサイズよりも大きいステップ間隔を生成する可能性があり、ギャップや予期しない結果を引き起こす可能性があります。
        </Callout>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timeseries"
    title={<><InlineCode>TIMESERIES</InlineCode> 句</>}
  >
    ```
    SELECT ...
      TIMESERIES integer units
      ...
    ```

    `TIMESERIES`句を使用して、指定期間単位の時系列としてデータを返します。`TIMESERIES`は特定のチャートを表示するために使用されるため、デフォルト値はありません。

    時間範囲を指定するには、`integer units`を使用します。例：

    * `TIMESERIES 1 minute`
    * `TIMESERIES 30 minutes`
    * `TIMESERIES 1 hour`
    * `TIMESERIES 30 seconds`

    `TIMESERIES` 以下の例に示すように、`MAX`、`AUTO`、`SLIDE BY`などの引数と組み合わせると、クエリ結果をさらに調整できます。

    <Callout variant="important">
      `average( )`または`percentile( )`などの関数では、集計ウィンドウを大きく設定することで、外れ値に対して大幅なスムージング効果が得られます。これは、クエリがスライディングウィンドウを使用するかどうかに関係なく当てはまります。
    </Callout>

    <CollapserGroup>
      <Collapser
        id="set-interval"
        title="設定した間隔を使用する"
      >
        指定された値は、グラフを分割する単位を示します。たとえば、以下のようにして1日のグラフを30分刻みで表示します。

        ```
        SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes
        ```
      </Collapser>

      <Collapser
        id="timeseries-auto"
        title="自動設定した間隔を使用する"
      >
        `TIMESERIES` は`AUTO`に設定することもでき、これによってグラフが適切な数の区分に分割されます。たとえば、1日のチャートは30分間隔で分割され、1週間のチャートは6時間間隔で分割されます。

        このクエリは、6時間間隔のデータ点で、1週間のクライアントサイドのトランザクションタイムの50パーセントタイルと90パーセンタイルを示す折れ線グラフを返します。

        ```
        SELECT average(duration), percentile(duration, 50, 90)
          FROM PageView SINCE 1 week AGO TIMESERIES AUTO
        ```
      </Collapser>

      <Collapser
        id="timeseries-max"
        title={<><InlineCode>MAX</InlineCode>間隔を使用</>}
      >
        `TIMESERIES`を`MAX`に設定することで時間枠が自動的に調整され、指定された期間に許可された間隔数を最大にできます。これによって、`TIMESERIES`バケットを手動で更新することなく時間枠を更新でき、認められた最大インターバル数に時間枠を分割できます。返される`TIMESERIES`バケットの最大数は366です。

        たとえば、以下のクエリでは4分間の間隔を作成していますが、これは1日のチャートの上限となります。

        ```
        SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-until"
    title={<><InlineCode>UNTIL</InlineCode> 句</>}
  >
    ```
    SELECT ...
      UNTIL integer units AGO
      ...
    ```

    **デフォルト**値は**NOW**です。`UNTIL`は、デフォルト以外の終了点を指定するためのみに使用してください。

    `UNTIL`句を使用して、データを返す時間範囲の終了時点を定義します。時間範囲を指定するとデータが保存されるようになり、時間範囲が終了した後に確認することができます。

    詳細情報と例については、[タイムピッカーを使用して時間設定を調整する](/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/#dash-time-picker)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-where"
    title={<><InlineCode>WHERE</InlineCode> 句</>}
  >
    `WHERE`句を使用して、結果をフィルタリングします。NRQLは、句で指定する条件を満たす結果を返します。

    ```
    SELECT function(attribute) ...
      WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ]
      [AND|OR ...]
      ...
    ```

    * 複数の条件を指定する場合は、条件を演算子`AND`または`OR`で区切ります。
    * [SQLのjoinをシミュレート](/docs/insights/nrql-new-relic-query-language/using-nrql/simulate-sql-join-functions-insights)する場合は、`WHERE`または`FACET`句でカスタムアトリビュートを使用します。

    <table id="where-operators">
      <thead>
        <tr>
          <th width={150}>
            **`WHERE`句が受け付ける演算子**
          </th>

          <th>
            **説明**
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `=`、`!=`、`<`、`<=`、`>`、 `>=`
          </td>

          <td>
            NRQLは標準的な比較演算子を受け付けます。

            例: `state = 'WA'`
          </td>
        </tr>

        <tr>
          <td>
            `AND`
          </td>

          <td>
            2つの条件の論理積を定義するために使用します。
          </td>
        </tr>

        <tr>
          <td>
            `OR`
          </td>

          <td>
            2つの条件の論理和を定義するために使用します。
          </td>
        </tr>

        <tr>
          <td>
            `IS NULL`
          </td>

          <td>
            属性がnull値を持つかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `IS NOT NULL`
          </td>

          <td>
            属性がnull値を持たないかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `IN`
          </td>

          <td>
            属性の文字列値が指定したセットに存在するかどうかを判断します。この方法を使用すると、複数の`WHERE`句を組み合わせた場合よりもパフォーマンスが向上します。

            例: `animalType IN ('cat', 'dog', 'fish')`
          </td>
        </tr>

        <tr>
          <td>
            `NOT IN`
          </td>

          <td>
            属性の文字列値が指定したセットに存在しないかどうかを判断します。この方法を使用すると、複数の`WHERE`句を組み合わせた場合よりもパフォーマンスが向上します。

            値は括弧で囲み、カンマで区切る必要があります。例：

            ```
            SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `LIKE`
          </td>

          <td>
            属性に指定のサブ文字列が含まれるかどうかを判断します。

            `LIKE`演算子の文字列引数は、文字列内の任意の位置にワイルドカードとしてパーセント記号（%）を受け付けます。サブ文字列が一致対象の文字列で開始（先頭に一致）または終了（末尾に一致）しない場合、ワイルドカードを文字列の先頭または末尾に指定する必要があります。

            **例：**

            `userAgentName LIKE 'IE%'`

            * IE

            * IE Mobile

              `userAgentName LIKE 'o%a%'`

            * Opera

            * Opera Mini

              `userAgentName LIKE 'o%a'`

            * Opera

              `userAgentName LIKE '%o%a%'`

            * Opera

            * Opera Mini

            * Mozilla Gecko
          </td>
        </tr>

        <tr>
          <td>
            `NOT LIKE`
          </td>

          <td>
            属性に指定のサブ文字列が含まれないかどうかを判断します。
          </td>
        </tr>

        <tr>
          <td>
            `RLIKE`
          </td>

          <td>
            属性に特定のRegexサブ文字列が含まれるかどうかを判断します。[RE2構文](https://github.com/google/re2/wiki/Syntax)を使用します。

            **例：**

            `appName RLIKE r'z.*|q.*''`

            `hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*'`

            * `z-app`

            * `q-app`

            * `ip-10-351-19-237`

            * `ip-10-351-2-41`

            * `ip-10-351-24-238`

            * `ip-10-351-14-15`

              <Callout variant="important">
                Regexではデフォルトで文字列全体マッチとなっているため、`^`と`$`は暗黙となり、追加する必要はありません。
              </Callout>
          </td>
        </tr>

        <tr>
          <td>
            `NOT RLIKE`
          </td>

          <td>
            属性に指定のRegexサブ文字列が含まれないかどうかを判断します。[RE2構文](https://github.com/google/re2/wiki/Syntax)を使用します。
          </td>
        </tr>
      </tbody>
    </table>

    <CollapserGroup>
      <Collapser
        id="query-3-conditions"
        title="3つの条件を使用したクエリの例"
      >
        このクエリは、過去24時間、米国およびカナダ国内のSafariユーザーについて、URLに`checkout`が含まれるページのブラウザレスポンスタイムを返します。

        ```
        SELECT histogram(duration, 50, 20) FROM PageView
        WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%'
        SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-metric-format"
    title={<><InlineCode>WITH METRIC_FORMAT</InlineCode> 句</>}
  >
    メトリックデータのクエリに関する情報については、[メトリクスのクエリを行う](#query-metrics)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timezone"
    title={<><InlineCode>WITH TIMEZONE</InlineCode> 句</>}
  >
    ```
    SELECT ... WITH TIMEZONE (selected zone)
      ...
    ```

    デフォルトで、クエリ結果は、現在使用しているブラウザのタイムゾーンで表示されます。

    `WITH TIMEZONE`句を使用すると、タイムゾーンが未指定のクエリ内で日付や時刻のタイムゾーンを選択できます。

    たとえば、`SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'`というクエリ句は、東部標準時の月曜日午前0時から東部標準時の火曜日午前0時までに記録されたデータを返します。

    <table style={{ width: "auto" }}>
      <thead>
        <tr>
          <th colSpan={4}>
            利用可能なタイムゾーンの選択
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            アフリカ/アビジャン
          </td>

          <td>
            アフリカ/アディスアベバ
          </td>

          <td>
            アフリカ/アルジェ
          </td>

          <td>
            アフリカ/ブランタイヤ
          </td>
        </tr>

        <tr>
          <td>
            アフリカ/カイロ
          </td>

          <td>
            アフリカ/ウィントフック
          </td>

          <td>
            米州/アダック
          </td>

          <td>
            米州/アンカレッジ
          </td>
        </tr>

        <tr>
          <td>
            米州/アラグアイナ
          </td>

          <td>
            米州/アルゼンチン/ブエノスアイレス
          </td>

          <td>
            アメリカ/ベリーズ
          </td>

          <td>
            アメリカ/ボゴタ
          </td>
        </tr>

        <tr>
          <td>
            アメリカ/カンポグランデ
          </td>

          <td>
            アメリカ/カンクン
          </td>

          <td>
            アメリカ/カラカス
          </td>

          <td>
            アメリカ/シカゴ
          </td>
        </tr>

        <tr>
          <td>
            アメリカ/チワワ
          </td>

          <td>
            アメリカ/ドーソンクリーク
          </td>

          <td>
            アメリカ/デンバー
          </td>

          <td>
            アメリカ/エンセナーダ
          </td>
        </tr>

        <tr>
          <td>
            アメリカ/グリーンベイ
          </td>

          <td>
            アメリカ/ゴットホープ
          </td>

          <td>
            アメリカ/グースベイ
          </td>

          <td>
            アメリカ/ハバナ
          </td>
        </tr>

        <tr>
          <td>
            アメリカ/ラパス
          </td>

          <td>
            アメリカ/ロサンゼルス
          </td>

          <td>
            アメリカ/ミクロン
          </td>

          <td>
            アメリカ/モンテビデオ
          </td>
        </tr>

        <tr>
          <td>
            アメリカ/ニューヨーク
          </td>

          <td>
            アメリカ/ノローニャ
          </td>

          <td>
            アメリカ/サンティアゴ
          </td>

          <td>
            アメリカ/サンパウロ
          </td>
        </tr>

        <tr>
          <td>
            アメリカ/セントジョンズ
          </td>

          <td>
            アジア/アナディル
          </td>

          <td>
            アジア/バンコク
          </td>

          <td>
            アジア/ベイルート
          </td>
        </tr>

        <tr>
          <td>
            アジア/ダマスカス
          </td>

          <td>
            アジア/ダッカ
          </td>

          <td>
            アジア/ドバイ
          </td>

          <td>
            アジア/ガザ
          </td>
        </tr>

        <tr>
          <td>
            アジア/香港
          </td>

          <td>
            アジア/イルクーツク
          </td>

          <td>
            アジア/エルサレム
          </td>

          <td>
            アジア/カブール
          </td>
        </tr>

        <tr>
          <td>
            アジア/カトマンズ
          </td>

          <td>
            アジア/コルカタ
          </td>

          <td>
            アジア/クラスノヤルスク
          </td>

          <td>
            アジア/マガダン
          </td>
        </tr>

        <tr>
          <td>
            アジア/ノボシビルスク
          </td>

          <td>
            アジア/ヤンゴン
          </td>

          <td>
            アジア/ソウル
          </td>

          <td>
            アジア/タシケント
          </td>
        </tr>

        <tr>
          <td>
            アジア/テヘラン
          </td>

          <td>
            アジア/東京
          </td>

          <td>
            アジア/ウラジオストク
          </td>

          <td>
            アジア/ヤクーツク
          </td>
        </tr>

        <tr>
          <td>
            アジア/エカテリンブルク
          </td>

          <td>
            アジア/エレバン
          </td>

          <td>
            大西洋/アゾレス
          </td>

          <td>
            大西洋/カーポベルデ
          </td>
        </tr>

        <tr>
          <td>
            大西洋/スタンリー
          </td>

          <td>
            オーストラリア/アデレード
          </td>

          <td>
            オーストラリア/ブリスベン
          </td>

          <td>
            オーストラリア/ダーウィン
          </td>
        </tr>

        <tr>
          <td>
            オーストラリア/ユークラ
          </td>

          <td>
            オーストラリア/ホバート
          </td>

          <td>
            オーストラリア/ロードハウ
          </td>

          <td>
            オーストラリア/パース
          </td>
        </tr>

        <tr>
          <td>
            チリ/イースター島
          </td>

          <td>
            その他/GMT+10
          </td>

          <td>
            その他/GMT+8
          </td>

          <td>
            その他/GMT-11
          </td>
        </tr>

        <tr>
          <td>
            その他/GMT-12
          </td>

          <td>
            ヨーロッパ/アムステルダム
          </td>

          <td>
            ヨーロッパ/ベルファスト
          </td>

          <td>
            ヨーロッパ/ベオグラード
          </td>
        </tr>

        <tr>
          <td>
            ヨーロッパ/ブリュッセル
          </td>

          <td>
            ヨーロッパ/ダブリン
          </td>

          <td>
            ヨーロッパ/リスボン
          </td>

          <td>
            ヨーロッパ/ロンドン
          </td>
        </tr>

        <tr>
          <td>
            ヨーロッパ/ミンスク
          </td>

          <td>
            ヨーロッパ/モスクワ
          </td>

          <td>
            太平洋/オークランド
          </td>

          <td>
            太平洋/チャタム
          </td>
        </tr>

        <tr>
          <td>
            太平洋/ガンビエ
          </td>

          <td>
            太平洋/キリバス
          </td>

          <td>
            太平洋/マルケサス
          </td>

          <td>
            太平洋/ミッドウェイ
          </td>
        </tr>

        <tr>
          <td>
            太平洋/ノーフォーク
          </td>

          <td>
            太平洋/トンガタプ
          </td>

          <td>
            UTC
          </td>
        </tr>
      </tbody>
    </table>

    詳細な情報と例については、[ダッシュボードとチャートで時間範囲を設定する](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets)を参照してください。
  </Collapser>
</CollapserGroup>

## メトリックデータをクエリ [#query-metrics]

メトリックデータはその他のデータ型より複雑です。それをうまくクエリする特定のヒントがあります。メトリックデータには2つの型があり、それぞれに以下の独自のクエリガイドラインがあります。

* [ディメンションメトリクスをクエリします](/docs/data-ingest-apis/get-data-new-relic/metric-api/view-query-you-metric-data)。これは、当社のメトリクスAPIとそのAPIを使用するソリューションの一部（たとえば、[Dropwizard インテグレーション](/docs/more-integrations/open-source-telemetry-integrations/dropwizard/dropwizard-reporter)または[Micrometerインテグレーション）により報告されます](/docs/more-integrations/open-source-telemetry-integrations/micrometer/micrometer-metrics-registry)。
* [クエリメトリックタイムスライスデータ](/docs/query-data/nrql-new-relic-query-language/nrql-query-tutorials/query-metric-timeslice-data-nrql)、当社のAPM、モバイルモニタリング、ブラウザモニタリングによって報告されるオリジナルのメトリックデータ型です。

メトリックデータのレポート方法の詳細は、[メトリックデータタイプ](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics)を参照してください。

## 関数 [#functions]

このセクションでは、NRQL関数、[集計関数](#aggregator-functions)と[非集計関数](#non-aggregator-functions)の両方について説明します。

### 集計関数 [#aggregator-functions]

集計関数を使用して、データをフィルタリング、集計します。以下を使用するためのヒント：

* New Relic Universityの[フィルタークエリ](http://newrelic.wistia.com/medias/8k4xbxlfwj)、[Apdexクエリ](http://newrelic.wistia.com/medias/46dvx1mkm0)、および[パーセンタイルクエリ](http://newrelic.wistia.com/medias/j3htrz66l0)のチュートリアルを参照してください。または、完全な[Writing NRQLクエリ](https://learn.newrelic.com/writing-nrql-queries)のオンラインコースにアクセスしてください。

* 同じクエリで集計関数を複数回使用している場合（例：`SELECT median(one_metric), median(another_metric)`）、結果の表示に問題が生じることがあります。この問題を解決するには、[`AS`関数](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-as)を使用します。例：

  ```
   SELECT median(one_metric) as 'med-a', median(another_metric) as 'med-b'
  ```

* データ型「型強制」には対応していません。[利用可能なデータ型変換関数](#type-conversion)の詳細を参照してください。

* 時間の経過に伴う結果の表示方法については、[時間の経過に伴う結果のグループ化](/docs/insights/new-relic-insights/features/cohort-analysis)を参照してください。

例：

```
SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
```

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="func-aggregationendtime"
    title={<InlineCode>aggregationendtime()</InlineCode>}
  >
    `aggregationendtime()`関数を使用して、関連集計の時刻を返します。より具体的には、`aggregationendtime()`関数は、指定した集計の、集計期間終了のタイムスタンプを提供します。たとえば、時系列クエリでは、1時間分のデータを含むデータポイントの場合、関数はその時間の終わりのタイムスタンプを返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-apdex"
    title={<InlineCode>apdex(attribute, t: )</InlineCode>}
  >
    `apdex`関数を使用して、単一のトランザクションまたはすべてのトランザクションの[Apdexスコア](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#score)を返します。[属性](/docs/insights/new-relic-insights/decorating-events/insights-attributes)には、[`duration`](/docs/insights/insights-data-sources/default-events-attributes/apm-default-event-attributes#txn-duration)または[`backendDuration`](/docs/insights/insights-data-sources/default-events-attributes/browser-default-events-attributes-insights#backend-duration)などのレスポンスタイムに基づく、任意の属性を指定できます。`t:`引数は、選択した属性と同じ時間単位で[Apdex T](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction)閾値を定義します。たとえば、属性が秒単位で測定される場合、`t`は秒単位の閾値になります。

    `apdex( )`関数が返すApdexスコアは、実行時間のみに基づくものです。APMエラーは考慮していません。エラーが含まれているにもかかわらず、トランザクションが[Apdex T](/docs/apm/new-relic-apm/getting-started/glossary#apdex_t)以下で完了する場合、そのトランザクションは`apdex ( )`関数によって[満足](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#bullet-satisfied)と評価されます。

    <CollapserGroup>
      <Collapser
        id="apdex-cust-attributes"
        title="特定の顧客の Apdexを取得する"
      >
        [定義済みカスタム属性](/docs/insights/new-relic-insights/decorating-events/insights-custom-attributes)がある場合は、それらの属性に基づいて絞り込むことができます。たとえば、特に重要な顧客のApdexを監視することができます。

        ```
        SELECT apdex(duration, t: 0.4) FROM Transaction
          WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago
        ```
      </Collapser>

      <Collapser
        id="apdex-transaction"
        title="特定のトランザクションのApdexを取得する"
      >
        `name`属性を使用して特定のトランザクションのスコア、または`name`を省略して総合的なApdexを返します。このクエリは、直近1時間の**Controller/notes/index**トランザクションのApdexスコアを返します。

        <img
          title="crop-apdex-function"
          alt="crop-apdex-function"
          src={screenApdexFunction}
        />

        <figcaption>
          `apdex`関数は、あなたのサイトに対するユーザーの満足度を測定する[Apdexスコア](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction)を返します。引数は、秒単位のレスポンスタイムの属性とApdex Tの閾値です。
        </figcaption>

        ```
        SELECT apdex(duration, t: 0.5) from Transaction
        WHERE name='Controller/notes/index' SINCE 1 hour ago
        ```
      </Collapser>

      <Collapser title="アプリ全体のApdexを取得する">
        このクエリの例では、直近3週間のアプリケーション全体のApdexを返します。

        ```
        SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-average"
    title={<InlineCode>average(attribute)</InlineCode>}
  >
    `average( )`関数を使用して、属性の平均値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数値が返されない場合は、null値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-buckets"
    title={<InlineCode>buckets(attribute, ceiling \[,number of buckets])</InlineCode>}
  >
    `buckets()`関数を使用して、`FACET`句ごとに分割されたデータを、範囲に基づきバケットに集計します。New Relicデータベースの数値として保存される属性ごとにバケットにまとめることができます。

    この関数は、以下の3つの引数を取ります。

    * 属性名

    * サンプル範囲の最大値。外れ値は最終バケットに表示されます。

    * バケットの合計数

      詳細と例については、[データをバケットに分割](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/segment-your-insights-data-buckets)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-bucket-percentile"
    title={<InlineCode>bucketPercentile(attribute)</InlineCode>}
  >
    `bucketPercentile( )`関数は、Prometheusの[`histogram_quantile`](https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile)関数のNRQL版です。次元メトリックデータとともに使用します。分位数の代わりにNew Relicパーセンタイルを返します。これは分位数\*100です。

    `bucketPercentile( )`関数を使用して、Prometheus形式のヒストグラムデータから分位数を計算します。

    バケット名を引数として取得し、バケットの境界とともにパーセンタイルをレポートします。

    ```
    SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago
    ```

    オプションで、引数としてパーセンタイル指定を追加できます。

    ```
    SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago
    ```

    複数のメトリックスを使用してPrometheusヒストグラムデータを構成しているため、関連する`<basename>`に関して特定のPrometheusメトリックスのクエリを行う必要があります。

    たとえば、`<basename>` `prometheus_http_request_duration_seconds`がNRQLを使用して、Prometheusヒストグラムからパーセンタイルを計算するには、`bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)`を使用します。\_bucketがサフィックスとして`<basename>`の最後に追加されていることに注意してください。

    詳細については、[Prometheus.ioドキュメント](https://prometheus.io/docs/concepts/metric_types/#histogram)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cardinality"
    title={<InlineCode>cardinality(attribute)</InlineCode>}
  >
    `cardinality( )`関数を使用して、[メトリック](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics)上のすべてのディメンション（属性）の組み合わせの数を取得します。

    次の3つの引数を取りますが、すべてオプションです。

    * メトリック名：ある場合は、`cardinality( )`は指定したメトリックのみを計算します。

    * インクルード：ある場合、Includeリストは濃度計算をこの属性に制限します。

    * エクスクルード：ある場合、Excludeリストによりこの属性は濃度計算で無視されます。

      ```
      SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list})
      ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-count"
    title={<InlineCode>count(\*)</InlineCode>}
  >
    `count( )`関数を使用して、使用可能レコード数を返します。これは単一の引数を受け入れます (`*`、属性、または定数値のいずれか)。現在、一般的なSQL動作に従い、その引数に対する値を持つすべてのレコードを計上します。

    `count(*)`は特定の属性を示すものではないため、結果はデフォルトの[「humanize」](/docs/insights/new-relic-insights/managing-dashboards-data/data-formatter-setting-default-formats-numeric-values#format)形式でフォーマットされます。
  </Collapser>

  <Collapser
    className="freq-link"
    id="derivative"
    title={<InlineCode>derivative(attribute \[,time interval])</InlineCode>}
  >
    `derivative()` は、所定のデータセットの変化率を検索します。線形最小二乗回帰を使用して変化率を計算し、微分係数を近似します。この計算では複数のデータポイントの比較が必要であるため、評価範囲にデータポイントが1つしかない場合、解が求められず、結果は`null`値になります。

    `time interval`は、変化率を計算する期間です。たとえば、`derivative(attributeName, 1 minute)`は1分あたりの変化率を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-dimensions"
    title={<InlineCode>{'dimensions(include: {attributes}, exclude: {attributes})'}</InlineCode>}
  >
    `dimensions( )`関数を使用して、データ型のすべての次元値を返します。

    オプションの引数を使用して、以下の特定の属性を明示的に含めたり、除外したりできます。

    * インクルード：ある場合、includeリストは`dimensions( )`をそれらの属性に限定します。

    * エクスクルード：ある場合、`dimensions( )`の計算ではそれらの属性は無視されます。

      ```
      FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions()
      ```

      `FACET`句とともに使用する場合、`dimensions( )`は、未集計クエリでのPrometheusの動作と同様に、イベントタイプで使用できるすべてのファセットについて一意の時系列を生成します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="latestrate"
    title={<InlineCode>latestrate(attribute, time interval)</InlineCode>}
  >
    `latestrate( )`関数を使用して、最後の2つのデータポイントに基づく値の変化率を返します。問題となる属性を最初の引数として受け取り、結果である変化率の時間の単位を2番目の引数として受け取ります。この関数は結果を`change in attribute/time interval`の単位で返します。

    この関数は、最先端の傾向を確認するために、属性の最新の変化率を提供するのに役立ちます。

    <CollapserGroup>
      <Collapser title="PageView期間の最新の変化率を取得する">
        このクエリは、最後の2つのデータポイントに基づいて期間の変化率を返します。`1 SECOND`引数であるため、`duration/second`の単位で返されます。

        ```
        SELECT latestrate(duration, 1 SECOND) FROM PageView
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-max"
    title={<InlineCode>max(attribute)</InlineCode>}
  >
    `max( )`関数を使用して、指定された時間範囲内に記録された数値属性の最大値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数値が返されない場合は、null値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-median"
    title={<InlineCode>median(attribute)</InlineCode>}
  >
    `median( )`関数を利用して、属性の中央値あるいは50パーセンタイルを返します。パーセンタイルクエリの詳細に関しては、[percentile()](#func-percentile)を参照してください。

    <Callout variant="tip">
      `median( )`クエリは、[クエリビルダー](/docs/chart-builder/use-chart-builder/get-started/introduction-chart-builder)を利用する場合にのみ利用できます。
    </Callout>

    <CollapserGroup>
      <Collapser title="中央値クエリ">
        このクエリは、中央値に関する折れ線グラフを生成します。

        ```
        SELECT median(duration) FROM PageView TIMESERIES AUTO
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-min"
    title={<InlineCode>min(attribute)</InlineCode>}
  >
    `min( )`関数を使用して、指定された時間範囲内に記録された数値属性の最小値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数値が返されない場合は、null値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-minOf"
    title={<InlineCode>minuteOf(attribute)</InlineCode>}
  >
    minuteOf()関数を使用して、有効なタイムスタンプ値を持つ属性の分の部分（つまり、0〜59秒）のみを抽出します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mod"
    title={<InlineCode>mod(attribute, divisor)</InlineCode>}
  >
    与えられた数値属性の値（最初の引数、すなわち被除数）を数値（2つ目の引数、すなわち除数）で割った後、`mod( )`関数を使用してfloor係数を返します。このモジュロ演算は、WHERE句の条件内で使用して結果の任意のサブセットにフィルターしたり、FACET句で結果セットをさらに分割したりする方法として使用できます。

    <CollapserGroup>
      <Collapser title={<><InlineCode>mod()</InlineCode> <InlineCode>WHERE</InlineCode>句条件内</>}>
        ```
        FROM Transaction SELECT * WHERE mod(port, 2) = 1
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title={<><InlineCode>mod()</InlineCode> <InlineCode>FACET</InlineCode>句内</>}>
        ```
        FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentage"
    title={<InlineCode>percentage(function(attribute), WHERE condition)</InlineCode>}
  >
    `percentage( )`関数を使用して、いくつかの条件に一致する目的のデータセットの割合を返します。

    最初の引数には、目的の属性に対する[集計関数](#functions)が必要です。必ず2つの引数を使用してください（最初の2つ以外の引数は無視されます）。属性が数値でない場合、この関数は100%を値として返します。

    ```
    FROM Transaction SELECT percentage(count(*), WHERE error is true ) AS 'Error Percent' Where host LIKE '%west%' EXTRAPOLATE
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentile"
    title={<InlineCode>percentile(attribute \[, percentile \[, ...]])</InlineCode>}
  >
    `percentile( )`関数を使用して、所定の指定パーセンタイルでの属性の概算値を返します。この関数は属性が必須であり、パーセンタイル点を表す引数はいくつでも指定できます。`percentile()`関数は、小数点以下3桁までの表示を可能にすることで、より厳密な内容を提供できます。パーセンタイルの閾値は小数点値として指定される場合があるものの、大半のデータセットにおいて、互いに0.1よりも近いパーセンタイルは解決されない点に注意してください。

    <img
      title="percentile.png"
      alt="percentile.png"
      src={percentile0}
    />

    <figcaption>
      パーセンタイルの表示例
    </figcaption>

    `TIMESERIES`を使用して、時系列でマッピングされたパーセンタイルで折れ線グラフを生成します。

    * `TIMESERIES`を省略して、パーセンタイルの集計値を示すビルボードと属性シートを生成します。

      パーセンタイルが指定されていない場合、デフォルトで95パーセンタイルとなります。50パーセンタイル値、つまり中央値のみを返すには、[median()](#func-median)を使用することもできます。

      <CollapserGroup>
        <Collapser title="基本的なパーセンタイルのクエリ">
          このクエリは、5、50、95パーセンタイルの折れ線を表示する折れ線グラフを生成します。

          ```
          SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="predictLinear"
    title={<InlineCode>predictLinear(attribute, \[,time interval])</InlineCode>}
  >
    `predictLinear()` は`derivative()`関数の拡張機能です。同様の方法の最小2乗線形回帰を使用して、データセットの将来値を予測します。

    * `time interval`は、クエリでどの程度将来まで扱うかを表します。たとえば、`predictLinear(attributeName, 1 hour)`は、1時間の線形予想をクエリの時間枠の将来に当てはめます。
    * 一般に、`predictLinear()`は、ディスクスペースのような増加が続く値や大きなトレンドの予想などで有用です。
    * `predictLinear()`は線形回帰のため、クエリを行っているデータセットに習熟していると、正確な長期的な予想を行えます。
    * 指数的または対数的、その他の非線形的に増加するデータセットでは、非常に短期的な予想でのみ有効な可能性が高いと言えます。
    * New Relicでは、`TIMESERIES`クエリで`predictLinear`を使用することを推奨していません。これは、各バケットがクエリ内の相対的な期間に基づき個別に予想を行う、つまり、そうしたクエリは時系列終了以後の予想は示さないためです。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-rate"
    title={<InlineCode>rate(function(attribute) \[,time interval])</InlineCode>}
  >
    `rate( )`関数を使用して、時間間隔ごとに所定のクエリの頻度またはレートを可視化します。たとえば、1時間の1分あたりのページビュー数や1日間の1時間あたりのサイトのユニークセッション数を把握する必要がある場合があります。

    * [`TIMESERIES`](#sel-timeseries)を使用して、時系列でマッピングされた評価を示す折れ線グラフを生成します。

    * [`TIMESERIES`](#sel-timeseries)を省略して、時間で平均化された単一の評価値を示すビルボードを生成します。

      過去6時間にわたる10分あたりのAPMトランザクションのスループット評価を示す折れ線グラフを生成する基本的なクエリを以下に示します。

      ```
      SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago
      TIMESERIES
      ```

      ここでは、さまざまな時間枠でデータを比較するために`rate`を使用する方法を説明する短いビデオ（3分21秒）を紹介します。

      <Video
        id="9UArmB4QiVM"
        type="youtube"
      />
  </Collapser>

  <Collapser
    className="freq-link"
    id="round"
    title={<InlineCode>round(attribute)</InlineCode>}
  >
    `round( )`関数を使用して、属性の丸め値を返します。

    オプションで、`round( )`は2番目の引数`to_nearest`を取り、最初の引数を2番目の引数の最も近い倍数に切り上げます。`to_nearest`は分数にすることができます。

    ```
    SELECT round(n [, to_nearest])
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="stddev"
    title={<InlineCode>stddev(attribute)</InlineCode>}
  >
    `stddev( )`関数を使用して、指定された時間範囲内に記録された数値属性の[標準偏差値](https://en.wikipedia.org/wiki/Standard_deviation)を返します。単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="stdvar"
    title={<InlineCode>stdvar(attribute)</InlineCode>}
  >
    `stdvar( )`関数を使用して、指定された時間範囲内に記録された数値属性の[標準分散](https://en.wikipedia.org/wiki/Variance)を返します。

    単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-sum"
    title={<InlineCode>sum(attribute)</InlineCode>}
  >
    `sum( )`関数を使用して、指定された時間範囲内に記録された数値属性の合計値を返します。

    単一の引数を取ります。最初の引数以外は無視されます。属性が数値でない場合は、ゼロを値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniqueCount"
    title={<InlineCode>uniqueCount(attribute)</InlineCode>}
  >
    `uniqueCount( )`関数を使用して、指定された時間範囲内に記録された属性のユニーク値の数を返します。

    <Callout variant="tip">
      クエリのパフォーマンスを最適化するため、この関数は256を超えるユニーク値を検査するクエリのおおよその結果を返します。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniques"
    title={<><InlineCode>uniques(attribute ,limit</InlineCode><InlineCode>)</InlineCode></>}
  >
    `uniques( )`関数を使用して、指定された時間範囲内に記録された属性のユニーク値のリストを返します。`facet`句と共に使用すると、各ファセット値ごとにユニーク属性値リストが返されます。

    `limit`パラメーターはオプションです。提供されない場合は、ファセットあたり1,000のユニーク属性値のデフォルトlimitが適用されます。最大10,000までの、別の`limit`値を指定できます。`uniques( )`関数は、limitに達するまで、発見したユニーク属性値の最初のセットを返します。このため、データセットに5,000のユニーク属性値があり、リミットが1,000に設定されている場合は、演算子はその頻度に関わらず、発見した最初の1,000のユニーク値を返します。

    クエリ結果で返すことのできる最大数は、`uniques( )`上限と`facet`上限を掛け合わせたものになります。以下のクエリでは、論理的に返すことができる値の最大数は500万です（5,000 x 1,000）。

    クエリするデータセットとクエリの複雑性に応じて、メモリ保護limitで非常に大きなクエリの実行が阻止される場合があります。

    ```
    From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000
    ```

    <CollapserGroup>
      <Collapser title={<>使用 <InlineCode>tuple</InlineCode></>}>
        少数の属性の独自の組み合わせを知りたい場合、`` SELECT uniques(tuple(x, y, ... z)) ...` ``形式でクエリを構築することで、値の独自のタプルをすべて取得して、それらの関係を維持することができます。以下のクエリでは、`tuple`が`index`と`cellName`で一緒に使用され、これらの2つの値が組み合わせで発生する一意の要素を見つけます。

        ```
        FROM NodeStatus SELECT uniques(tuple(index, cellName), 5)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-capture"
    title={<InlineCode>capture（属性、正規表現）</InlineCode>}
  >
    `capture()`を使用して、[RE2構文](https://github.com/google/re2/wiki/Syntax)の正規表現を使用して属性から値を抽出します。

    2つの引数が必要です。

    * 属性名

    * capture構文を使用した正規表現。NRQLの正規表現は、Pythonのような構文`r'...'`を使用します。

      キャプチャする場合は、RE2名前付きキャプチャ構文`...(?P<name> pattern )...`は、指定された名前で、含まれるパターンをキャプチャします。現在、サポートされているキャプチャグループは1つのみです。

      [正規表現キャプチャを使用してクエリ結果を改善する](https://newrelic.com/blog/how-to-relic/using-regex-capture)方法をお読みください。

      `capture()`を使用して、ダッシュボードの読みやすさを向上する方法を紹介する短いビデオ（3分05秒）もあります。

      <Video
        id="hOPrTWYgPHg"
        type="youtube"
      />

      詳しくは、以下の例をご覧ください。

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> <InlineCode>SELECT</InlineCode>句条件内</>}>
          以下では、ウェブサイトのドメイン名を選択し、https&#x3A;//と.comに続くパスを削除します。

          ```
          SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') FROM PageView SINCE 1 day ago
          ```

          以下では、エラーメッセージの最初のワードのみがキャプチャされます。

          ```
          SELECT capture(errorMessage, r'(?P<firstWord>\S+)\s.+') FROM Transaction SINCE 1 hour ago where errorMessage is not null
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> <InlineCode>FACET</InlineCode>句条件内</>}>
          キャプチャしたHTTPメソッドによって、以下がファセットされます。

          ```
          SELECT count(*) FROM Log WHERE message like '%HTTP%' FACET capture(message, r'.* "(?P<httpMethod>[A-Z]+) .*')
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> <InlineCode>WHERE</InlineCode>句条件内</>}>
          以下は、キャプチャされたジョブ名が`ExampleJob`である正規表現と一致する`message`属性を持つログイベントに基づいて、結果をフィルター処理します。

          ```
          SELECT message FROM Log WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' SINCE 10 minutes ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser title={<><InlineCode>capture()</InlineCode> 数字型変換</>}>
          以下では、ログラインからCPU時間の合計をキャプチャします。数学演算を実行するには、明示的に数値にキャストする必要があります。

          ```
          SELECT sum(numeric(capture(message, r'.*CpuTime:\s(?P<cpuTime>\d+)'))) FROM Log WHERE message like '%CpuTime:%' SINCE 1 hour ago
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>
</CollapserGroup>

### 非集計関数 [#non-aggregator-functions]

NRQLクエリ内の非数値データには非集計関数を使用します。

<CollapserGroup>
  <Collapser
    className="freq-link"
    title={<InlineCode>accountId()</InlineCode>}
  >
    `accountId()`関数を使用して、クエリされたデータに関連する[アカウントID](/docs/accounts/accounts-billing/account-structure/account-id)を返します。この関数は引数を取りません。以下にいくつかクエリを示します。

    <CollapserGroup>
      <Collapser title="各トランザクションイベントのアカウントIDの取得">
        このクエリは、返された各`Transaction`イベントに関連するアカウントIDを返します。

        ```
        SELECT accountId() FROM Transaction SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="各アカウントのトランザクションイベント数の取得">
        このクエリは、各アカウントIDに関連する最終日の`Transaction`イベント数を返します。

        ```
        SELECT count(*) FROM Transaction FACET accountId() SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="WHERE句で指定された各アカウントのトランザクションイベント数の取得">
        このクエリは、アカウントIDが、特に`1`、`2`、`3`のいずれかである最終日の`Transaction`イベント数を返します。

        ```
        SELECT count(*) FROM Transaction WHERE accountId() IN (1,2,3) SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    title={<InlineCode>earliest(attribute)</InlineCode>}
  >
    `earliest( )`関数を使用して、指定された時間範囲における属性の最も古い値を返します。

    単一の引数を取ります。最初の引数以外は無視されます。

    `FACET`と併用する場合、この関数は得られた各ファセットの属性の最新値を返します。

    <CollapserGroup>
      <Collapser title="PageView からユーザーエージェントごとに最も古い国を取得">
        このクエリは、PageView イベントからユーザーエージェントごとに最も古い国コードを返します。

        ```
        SELECT earliest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    title={<InlineCode>eventType()</InlineCode>}
  >
    ```
    ...WHERE eventType() = 'EventNameHere'...
    ...FACET eventType()...
    ```

    [FACET](#sel-facet)句で`eventType()`関数を使用し、選択したデータ型別に結果を取り出し、または[WHERE](#sel-where)句で特定のデータ型に結果をフィルタリングします。これは [filter()](#func-filter) や [percentage()](#func-percentage) 関数で特定のデータ型を対象とする際に特に便利です。

    <Callout variant="important">
      この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータ型を指します。
    </Callout>

    <CollapserGroup>
      <Collapser
        id="filter-eventtype"
        title={<><InlineCode>eventType()</InlineCode>を<InlineCode>filter()</InlineCode>関数で使用</>}
      >
        このクエリは、合計`Transaction`の結果あたりの合計`TransactionError`の結果の割合を返します。`eventType()`関数を使用して、filter()関数で特定のデータ型をターゲットにすることができます。

        ```
        SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago
        ```
      </Collapser>

      <Collapser
        id="facet-eventtype"
        title={<><InlineCode>eventType()</InlineCode>を使用 <InlineCode>FACET</InlineCode></>}
      >
        このクエリは、各データ型（`Transaction`および`TransactionError`）が返すレコード数を表示します。

        ```
        SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-filter"
    title={<InlineCode>filter(function(attribute), WHERE condition)</InlineCode>}
  >
    `filter()`関数を使用して、SELECT文内の集計関数の1つに結果を制限します。`filter()`は`FACET`や`TIMESERIES`とともに使用できます。フィルターは、`SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' ...`などの複数の異なる集計を選択する場合にのみ便利です。それ以外の場合は、標準`WHERE`句を使用するのが良いでしょう。

    <CollapserGroup>
      <Collapser title="オファーコードを使用した購入を分析する">
        `filter()`は、一連のトランザクションで購入された商品の中で、オファーコードを使用して購入された商品と、オファーコードを使用せずに購入された商品を比較するために使用できます。

        <img
          title="screenshot insights filter"
          alt="screenshot insights filter"
          src={screenshotInsightsFilter00}
        />

        <figcaption>
          `filter( )`関数を使用して、SELECT文内の集計関数の1つに結果を制限します。
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-funnel"
    title={<InlineCode>funnel(attribute, steps)</InlineCode>}
  >
    `funnel()`関数を使用して、ファネルチャートを生成します。属性を最初の引数として取ります。その後、カンマで区切られた[`WHERE`](#sel-where)句（オプションでラベル付け用に[`AS`](#sel-as)句を含める）としてステップを指定します。

    詳細な情報と例については、 [ファネルのドキュメント](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/funnels-evaluate-data-series-events)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getfield"
    title={<InlineCode>getField(attribute, field)</InlineCode>}
  >
    `getField()`関数を使用して、[メトリックデータ](/docs/telemetry-data-platform/understand-data/new-relic-data-types/#metrics)などの複合データ型からフィールドを抽出します。

    次の引数を取ります。

    <table>
      <thead>
        <tr>
          <th style={{ width: "500px" }}>
            メトリックタイプ
          </th>

          <th>
            サポートされているフィールド
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `summary`
          </td>

          <td>
            count、total、max、min、type
          </td>
        </tr>

        <tr>
          <td>
            `gauge`
          </td>

          <td>
            count、total、max、min、latest、type
          </td>
        </tr>

        <tr>
          <td>
            `distribution`
          </td>

          <td>
            count、total、max、min、type
          </td>
        </tr>

        <tr>
          <td>
            `counter`
          </td>

          <td>
            count、type
          </td>
        </tr>

        <tr>
          <td>
            `timeslice`
          </td>

          <td>
            count、total、totalExclusive、min、max
          </td>
        </tr>
      </tbody>
    </table>

    例：

    ```
    SELECT max(getField(mySummary, count)) from Metric
    ```

    ```
    SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-histogram"
    title={<InlineCode>histogram(attribute, ceiling \[,number of buckets])</InlineCode>}
  >
    `histogram( )`関数を使用して、ヒストグラムを生成します。この関数は、以下の3つの引数を取ります。

    * 属性名

    * サンプル範囲の最大値

    * バケットの合計数（1～500（500を含む））

      <CollapserGroup>
        <Collapser
          id="histogram-response-times"
          title="PageViewイベントからのレスポンスタイムのヒストグラム"
        >
          このクエリは20バケットにわたって10秒以内のレスポンスタイムのヒストグラムを生成します。

          ```
          SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="histogram-prometheus"
          title="Prometheusヒストグラムバケット"
        >
          `histogram( )` Prometheusヒストグラムバケットを受け取ります。

          ```
          SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="distribution-metric"
          title="New Relicディストリビューションメトリック"
        >
          `histogram( )` [ディストリビューションメトリック](/docs/data-ingest-apis/get-data-new-relic/metric-api/events-metrics-service-create-metrics#limits-rules)を入力として受け取ります。

          ```
          SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago
          ```
        </Collapser>

        <Collapser
          id="histogram-facet-heatmap"
          title="FACET句があるヒストグラム"
        >
          FACET句とともに`histogram( )`を使用し、ヒートマップチャートを生成します。

          ```
          SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="keyset"
    title={<InlineCode>keyset()</InlineCode>}
  >
    `keyset()`を使用すると、所定の時間範囲における所定のデータ型に対するすべての属性を表示できます。この関数は引数を取りません。文字列型キー、数値型キー、ブール型キー、およびすべてのキーをグループ化したJSON構造体を返します。

    <CollapserGroup>
      <Collapser title="データ型のすべての属性を表示">
        このクエリは、最終日からの`PageView`イベントで見つかった属性を返します。

        ```
        SELECT keyset() FROM PageView SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latest"
    title={<InlineCode>latest(attribute)</InlineCode>}
  >
    `latest( )`関数を使用して、指定された時間範囲における属性の最新値を返します。

    単一の引数を取ります。最初の引数以外は無視されます。

    `FACET`と併用する場合、この関数は得られた各ファセットの属性の最新値を返します。

    <CollapserGroup>
      <Collapser title="PageViewからユーザーエージェントごとに最新の国を取得">
        このクエリは、PageViewイベントからユーザーエージェントごとに最新の国コードを返します。

        ```
        SELECT latest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

## データ型変換

NRQLは「型強制」をサポートしていません。つまり、文字列として保存されたフロートは文字列として取り扱われ、フロート値を要求する関数に渡しても操作できません。

以下に示す関数で、数値を伴う文字列、または文字列を伴うブーリアン値をそれぞれ数またはブール型に変換できます。

* `numeric()`関数を用いて、文字列形式の数値を数値関数に変換します。この関数は、クエリ結果に数学関数を使用するクエリ、または`average()`などのNRQL集計関数に組み込むことができます。
* `boolean()`関数を使用して、「true」または「false」の文字列値を対応するブーリアン値に変換します。