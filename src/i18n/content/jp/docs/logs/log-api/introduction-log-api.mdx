---
title: Log APIの紹介
tags:
  - Logs
  - Log management
  - Log API
metaDescription: Use our Log API so you can send your monitored log data directly to New Relic via HTTP input.
translationType: machine
---

[ログ転送ソリューション](/docs/logs/forward-logs/) がニーズに合わない場合は、Log API を使用して HTTP エンドポイント経由で New Relic に直接ログデータを送信することができます。

Log API を試してみませんか？ [New Relic のアカウントを作成してください](https://newrelic.com/signup) 無料でご利用いただけます。クレジットカードは必要ありません。

## HTTPエンドポイント [#endpoint]

お使いのNew Relicアカウントに該当するエンドポイントを使用してください。

米国（US）のエンドポイント。

```
https://log-api.newrelic.com/log/v1
```

[European Union](/docs/using-new-relic/welcome-new-relic/get-started/introduction-eu-region-data-center) (EU)のエンドポイントです。

```
https://log-api.eu.newrelic.com/log/v1
```

## HTTP設定 [#setup]

Log APIを使ってログデータをNew Relicアカウントに送信する。

1. Get your [New Relic license key](/docs/apis/intro-apis/new-relic-api-keys/#ingest-license-key).
2. JSON ペイロードの [制限と制限文字](#limits) を確認してください。
3. 必須の [headers](#json-headers) と [body](#json-body) フィールドを使用して、JSON メッセージを生成します。
4. `Api-Key` または `License-Key` が [headers](#auth-headers) または [query parameters](#query-parameters) に含まれていることを確認してください。 [ログのJSONの例を参照](#log-attribute-examples).
5. JSON メッセージを `POST` リクエストで、New Relic アカウントの適切な HTTP エンドポイントに送信します。

* 米国： `https://log-api.newrelic.com/log/v1`
* EU： `https://log-api.eu.newrelic.com/log/v1`

6. いくつかのトラフィックを生成し、数分待ってから、 [あなたのアカウント](#what-next) のデータをチェックしてください。

当社のログ管理機能を有効にしてもデータが表示されない場合は、当社の [トラブルシューティング手順](/docs/logs/log-management/troubleshooting/no-log-data-appears-ui/) に従ってください。

## HTTPヘッダー [#json-headers]

HTTPヘッダーを作成する際には、以下のガイドラインを参考にしてください。

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        ヘッダー
      </th>

      <th>
        対応値
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `コンテンツタイプ`

        必須
      </td>

      <td>
        * `アプリケーション/json`
        * `json`
        * `アプリケーション/gzip`
        * `gzip`
      </td>
    </tr>
  </tbody>
</table>

Gzip 形式の JSON も受け付けます。圧縮されたJSONを送信する場合は、 `Content-Type: application/json` and `Content-Encoding: gzip` headersを含めてください。

## 認証 [#authentication]

[ライセンスキー](/docs/apis/intro-apis/new-relic-api-keys/#ingest-license-key) は、Log API へのリクエストを認証するためのもので、提出したログメッセージが書き込まれる New Relic アカウントを決定します。ライセンスキーは、HTTP ヘッダーまたはクエリ文字列パラメーターとして渡す必要があります。

### オプション1：HTTPヘッダーを使った認証 [#auth-header]

以下のようにカスタムHTTPヘッダーを追加して、ライセンスキーを渡します。

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        ヘッダー
      </th>

      <th>
        対応値
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `Api-Key`
      </td>

      <td>
        A New Relic [ライセンスキー](/docs/apis/intro-apis/new-relic-api-keys/#ingest-license-key) 。また、 [クエリパラメータで送信することもできます](#query-parameters) 。
      </td>
    </tr>
  </tbody>
</table>

### オプション 2: クエリ文字列パラメータを使用した認証 ("ヘッダレス" 認証 ) [#query-parameters]

ライセンスキーは、URLのクエリストリングパラメータとして渡すこともできます。これは、カスタムHTTPリクエストヘッダーを許可していないクラウドベースのソースからログを送信する際に便利です。

例： `https://LOG_API_ENDPOINT/log/v1?Api-Key=YOUR_API_KEY_HERE`

<table>
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        問い合わせパラメータ
      </th>

      <th>
        値
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `Api-Key`
      </td>

      <td>
        あなたの [ライセンスキー](/docs/apis/intro-apis/new-relic-api-keys/#ingest-license-key) 。また、 [HTTPヘッダーで送信することもできます](#auth-header) 。
      </td>
    </tr>
  </tbody>
</table>

## JSONボディ [#json-content]

JSONメッセージは、簡略化された属性セットまたは詳細な属性セットのいずれかを使用して送信できます。

<CollapserGroup>
  <Collapser
    id="simple-json"
    title="簡易JSONボディメッセージ"
  >
    簡易フォーマットを使ってJSONメッセージを作成する場合は、以下のように1つのJSONオブジェクトを送信します。

    <table>
      <thead>
        <tr>
          <th>
            フィールド
          </th>

          <th>
            値の種類
          </th>

          <th>
            形式
          </th>

          <th>
            必須
          </th>

          <th>
            メモ
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `"timestamp"`
          </td>

          <td>
            整数
          </td>

          <td>
            エポックからのミリ秒または秒のいずれか
          </td>

          <td>
            いいえ
          </td>

          <td>
            フィールドがミリ秒や秒単位で指定されていない場合、メッセージはインジェストタイムを使用してタイムスタンプが付与されます。
          </td>
        </tr>

        <tr>
          <td>
            `"メッセージ"`
          </td>

          <td>
            文字列
          </td>

          <td>
            任意の文字列
          </td>

          <td>
            いいえ
          </td>

          <td>
            これは、デフォルトで検索される **メインの** ログメッセージフィールドです。
          </td>
        </tr>

        <tr>
          <td>
            `"ログタイプ"`
          </td>

          <td>
            文字列
          </td>

          <td>
            任意の文字列
          </td>

          <td>
            いいえ
          </td>

          <td>
            ログを識別し、解析ルールに合致させるための主なフィールド
          </td>
        </tr>

        <tr>
          <td>
            `other_fields`

            (空白を入れてはいけません）
          </td>

          <td>
            文字列
          </td>

          <td>
            任意の文字列
          </td>

          <td>
            いいえ
          </td>

          <td>
            これらはログメッセージの属性となります。

            注：ログ管理では、属性名のホワイトスペースをサポートしていません。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="detailed-json"
    title="詳細なJSONボディメッセージ"
  >
    詳細フォーマットを使用してボディを作成する場合は、1つまたは複数のJSONオブジェクトを含む、 **JSON配列** でなければなりません。それぞれのJSONオブジェクトは、以下のフォーマットで構成されています。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            フィールド
          </th>

          <th>
            値の種類
          </th>

          <th>
            形式
          </th>

          <th>
            必須
          </th>

          <th>
            メモ
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `"共通"`
          </td>

          <td>
            オブジェクト
          </td>

          <td>
            [共通](#json-common) を参照してください。
          </td>

          <td>
            いいえ
          </td>

          <td>
            すべてのログメッセージに共通する属性
          </td>
        </tr>

        <tr>
          <td>
            `"ログ"`
          </td>

          <td>
            配列
          </td>

          <td>
            [ログ](#json-logs) を参照してください。
          </td>

          <td>
            はい
          </td>

          <td>
            ログエントリのある配列
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## 上限値および文字の制限 [#limits]

<Callout variant="caution">
  顧客向けのアプリケーションのコード内から当社のAPIを呼び出すことは避けてください。これは、パフォーマンスの問題を引き起こしたり、応答時間が遅い場合にアプリケーションをブロックする可能性があります。この方法で行う必要がある場合は、パフォーマンスの問題を回避するために、当社のAPIを非同期に呼び出してください。
</Callout>

Log APIに送信するログの制限。

* ペイロード合計サイズ: **POSTあたり最大1MB(10^6バイト)**。圧縮の使用を強く推奨します。
* ペイロードは** UTF-8 **としてエンコードする必要があります。
* イベントごとの属性の数。最大255個
* 属性名の長さ：255文字
* 属性値の長さ。最初の4,094文字はNRDBに `Log` イベントフィールドに同じ名前で格納されます。例えば `message` 。文字列値が4094文字を超える場合は、長い文字列を [blob](/docs/logs/ui-data/long-logs-blobs) として格納します。

特定の属性には、追加の制限があります。

* `accountId`: これは予約した属性名です。この名前が含まれている場合は、取り込み中に破棄されます。
* `entity.guid`、`entity.name`、および`entity.type`：これらの属性は、エンティティを識別するために内部で使用されます。メトリックデータポイントの属性セクションでこれらのキーとともに送信される値によって、UIのエンティティが見つからない、またはテレメトリが予期されるエンティティと関連していないなどの未定義の動作が発生する場合があります。詳細については、[エンティティの合成](/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/#entity-synthesis)を参照してください。
* `eventType`: これは予約された属性名です。これが含まれていると、インジェスト時にドロップされます。
* `timestamp`: Unixエポックのタイムスタンプである必要があります。タイムスタンプは、秒数かミリ秒数で定義できます。

<Callout variant="important">
  48時間以上前のタイムスタンプを持つペイロードはドロップされる可能性があります。
</Callout>

Log APIに送信されるログのレート制限。

* Log APIに送信されるHTTPリクエストの最大レート：300,000リクエスト/分
* Log APIに送信される非圧縮Log JSONバイトの最大レート：10GB/分

### レートリミット違反

レートリミットを超えると、Log APIの動作に影響が出ます。このような場合は、以下の手順に従ってください。

<CollapserGroup>
  <Collapser
    id="http-requests"
    title="毎分のHTTPリクエスト数"
  >
    アカウントの最大リクエストレートの制限を超えた場合、New Relic Log API は `429` レスポンスを1分間の残りの時間だけ返します。この応答には、 `Retry-After` ヘッダが含まれており、再送信や新しいデータを送信するまでの待ち時間を秒単位で示しています。

    この問題を解決するには、送信するデータポイントの数を減らすか、レートリミットの変更をリクエストしてください。その後のサブスクリプションの変更は、変更後のレートリミットに影響しません。アカウントの変更がレートリミットに影響を与える場合は、レートリミットを調整するよう当社に通知する必要があります。

    レートリミットの変更をリクエストするには、New Relic のアカウント担当者に連絡するか、 [Support ポータル](http://support.newrelic.com) にアクセスしてください。
  </Collapser>

  <Collapser
    id="json-bytes"
    title="JSONバイト/分"
  >
    アカウントで Log JSON の最大バイト数を超えると、New Relic Log API は `429` レスポンスを残りの時間分だけ返します。この応答には、 `Retry-After` ヘッダが含まれており、再送信や新しいデータを送信するまでの待ち時間を秒単位で示しています。

    この問題を解決するには、送信するログデータの量を減らすか、より大きな期間に分散させてみてください。

    レートリミットの変更をリクエストするには、New Relic のアカウント担当者に連絡するか、 [Support ポータル](http://support.newrelic.com) にアクセスしてください。
  </Collapser>
</CollapserGroup>

### ログのペイロードフォーマット [#payload-format]

有効なJSONペイロードであれば何でも受け付けます。ペイロードは、 **UTF-8** としてエンコードされている必要があります。

<Callout variant="important">
  ログ管理では、属性名のホワイトスペースをサポートしていません。例えば、 `{"Sample Attribute":"Value"}。` はエラーになります。
</Callout>

## JSONメッセージ属性 [#attributes]

<CollapserGroup>
  <Collapser
    id="json-common"
    title="共通のブロック属性"
  >
    これは、 [`ログ`](#json-logs) のすべてのログ・エントリに共通する属性を含むブロックです。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            フィールド
          </th>

          <th>
            値の種類
          </th>

          <th>
            形式
          </th>

          <th>
            必須
          </th>

          <th>
            メモ
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `"timestamp"`
          </td>

          <td>
            整数
          </td>

          <td>
            エポックからのミリ秒または秒数
          </td>

          <td>
            いいえ
          </td>

          <td>
            メッセージのタイムスタンプのデフォルトはインジェスト時刻
          </td>
        </tr>

        <tr>
          <td>
            `"属性"`
          </td>

          <td>
            オブジェクト
          </td>

          <td>
            JSON
          </td>

          <td>
            いいえ
          </td>

          <td>
            このサブオブジェクトは、メッセージの他のすべての属性を含みます。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="json-logs"
    title="ログのブロック属性"
  >
    これは、以下の形式のログエントリを含む配列です。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            フィールド
          </th>

          <th>
            値の種類
          </th>

          <th>
            形式
          </th>

          <th>
            必須
          </th>

          <th>
            メモ
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `"timestamp"`
          </td>

          <td>
            整数
          </td>

          <td>
            エポックからのミリ秒または秒数
          </td>

          <td>
            いいえ
          </td>

          <td>
            メッセージのタイムスタンプのデフォルトはインジェスト時刻
          </td>
        </tr>

        <tr>
          <td>
            `"属性"`
          </td>

          <td>
            オブジェクト
          </td>

          <td>
            JSON
          </td>

          <td>
            いいえ
          </td>

          <td>
            このサブオブジェクトは、メッセージの他のすべての属性を含みます。
          </td>
        </tr>

        <tr>
          <td>
            `"メッセージ"`
          </td>

          <td>
            文字列
          </td>

          <td>
            (任意の文字列)
          </td>

          <td>
            はい
          </td>

          <td>
            これは、デフォルトで検索されるメインのログメッセージフィールドです。
          </td>
        </tr>

        <tr>
          <td>
            `"ログ"`
          </td>

          <td>
            文字列
          </td>

          <td>
            (任意の文字列)
          </td>

          <td>
            いいえ
          </td>

          <td>
            この文字列を、インジェスト時にフィールド `メッセージ` として書き換えます。
          </td>
        </tr>

        <tr>
          <td>
            `"LOG"`
          </td>

          <td>
            文字列
          </td>

          <td>
            (任意の文字列)
          </td>

          <td>
            いいえ
          </td>

          <td>
            この文字列を、インジェスト時にフィールド `メッセージ` として書き換えます。
          </td>
        </tr>

        <tr>
          <td>
            `"MESSAGE"`
          </td>

          <td>
            文字列
          </td>

          <td>
            (任意の文字列)
          </td>

          <td>
            いいえ
          </td>

          <td>
            この文字列を、インジェスト時にフィールド `メッセージ` として書き換えます。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## JSONメッセージの属性解析 [#message-attribute-parsin]

当社のログ管理機能は、 `メッセージ` 属性を JSON として解析します。解析されたメッセージの結果のJSON属性は、イベントに追加されます。 `メッセージ` 属性が JSON でない場合は、そのままになります。

<Callout variant="important">
  属性名の中のホワイトスペースはサポートされていません。例えば、 `{"Sample Attribute":"Value"}。` はエラーになります。代わりに、 `{"Sample_Attribute":"Value"} のように使用してください。`.
</Callout>

以下は、 `メッセージ` 属性の例です。

```
{
    "timestamp": 1562767499238,
    "message": "{\"service-name\": \"login-service\", \"user\": {\"id\": 123, \"name\": \"alice\"}}"
}
```

として扱われます。

```
{
  "timestamp": 1562767499238,
  "message": "{\"service-name\": \"my-service\", \"user\": {\"id\": 123, \"name\": \"alice\"}}",
  "service-name": "my-service",
  "user": {
    "id": 123,
    "name": "alice"
  }
}
```

## ログJSONの例 [#log-attribute-examples]

属性は、文字列や数値などのスカラ型JSONです。また、複合（または [ネストした](https://www.digitalocean.com/community/tutorials/an-introduction-to-json#working-with-complex-types-in-json) ）オブジェクトにすることもできます。複合属性は、関連付けられた属性がフラット化された名前で保存されます。

例えば、ログエントリの属性に複合 `ユーザー` 属性がある場合を紹介します。

```
"attributes": {
    "action": "login",
    "user": {
        "id": 123,
        "name": "alice"
    }
}
```

これにより、以下の属性がログイベントとともに保存されます。

<table>
  <thead>
    <tr>
      <th>
        属性
      </th>

      <th>
        値
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `"アクション"`
      </td>

      <td>
        `"ログイン"`
      </td>
    </tr>

    <tr>
      <td>
        `"user.id"`
      </td>

      <td>
        `123`
      </td>
    </tr>

    <tr>
      <td>
        `"user.name"`
      </td>

      <td>
        `"alice"`
      </td>
    </tr>
  </tbody>
</table>

### ログのPOSTメッセージの例 [#log-attribute-example]

ログ `POST` メッセージの例です。

```
POST /log/v1 HTTP/1.1
Host: log-api.newrelic.com
Content-Type: application/json
Api-Key: <var><YOUR_LICENSE_KEY></var>
Accept: */*
Content-Length: 319
[{
   "common": {
     "attributes": {
       "logtype": "accesslogs",
       "service": "login-service",
       "hostname": "login.example.com"
     }
   },
   "logs": [{
       "timestamp": <var><TIMESTAMP_IN_UNIX_EPOCH></var>,
       "message": "User 'xyz' logged in"
     },{
       "timestamp": <var><TIMESTAMP_IN_UNIX_EPOCH</var><var>></var>,
       "message": "User 'xyz' logged out",
       "attributes": {
         "auditId": 123
       }
     }]
}]
```

この `POST` のメッセージでは、以下のようなログメッセージが New Relic に保存されます。

<table>
  <thead>
    <tr>
      <th>
        属性
      </th>

      <th>
        値
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `"ログタイプ"`
      </td>

      <td>
        `"accesslogs"`
      </td>
    </tr>

    <tr>
      <td>
        `"サービス"`
      </td>

      <td>
        `"login-service"`
      </td>
    </tr>

    <tr>
      <td>
        `"ホスト名"`
      </td>

      <td>
        `"login.example.com"`
      </td>
    </tr>
  </tbody>
</table>

ストアドログのブロック属性の例を示します。

<table>
  <thead>
    <tr>
      <th>
        属性
      </th>

      <th>
        値
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `"timestamp"`
      </td>

      <td>
        `1550086450124`
      </td>
    </tr>

    <tr>
      <td>
        `"メッセージ"`
      </td>

      <td>
        `"ユーザー「xyz」がログアウトしました。"`
      </td>
    </tr>

    <tr>
      <td>
        `"auditId"`
      </td>

      <td>
        `123`
      </td>
    </tr>
  </tbody>
</table>

### JSON POSTリクエストの例 [#example-post]

ここでは、JSONのPOSTリクエストの例を紹介します。

```
POST /log/v1 HTTP/1.1
   Host: log-api.newrelic.com
   Content-Type: application/json
   Api-Key: <var><YOUR_LICENSE_KEY></var>
   Accept: */*
   Content-Length: 133
   {
     "timestamp": <var><TIMESTAMP_IN_UNIX_EPOCH></var>,
     "message": "User '<var>xyz</var>' logged in",
     "logtype": "accesslogs",
     "service": "login-service",
     "hostname": "<var>login.example.com</var>"
   }
```

## 次のステップ [#what-next]

[New Relic One UI](/docs/logs/ui-data/use-logs-ui/) を使って、プラットフォーム全体のロギングデータを調べることができます。

* [logs in context](/docs/logs/logs-context/configure-logs-context-apm-agents/) の機能を使ってログを転送することで、アプリケーションとプラットフォームの両方のパフォーマンスデータをより深く把握することができます。
* [アラートの設定](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-alert-conditions/).
* [データのクエリ](/docs/query-your-data/explore-query-data/get-started/introduction-querying-new-relic-data/) と [ダッシュボードの作成](/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/).