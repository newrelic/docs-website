---
title: 内蔵のログ解析ルール
tags:
  - Logs
  - Log management
  - UI and data
metaDescription: 'A list of all New Relic''s log parsing rules, which you can use to easily parse common log formats.'
translationType: machine
---

New Relic は組み込みのルールに従って一般的なログ形式を解析できるため、独自の解析ルールを作成する必要はありません。ログ解析ルール、 [Grok](https://github.com/thekrakken/java-grok/tree/master/src/main/resources/patterns)パターン、および解析されるフィールドは次のとおりです。

* 組み込みのログ解析を有効にする[には、 `logtype`属性の追加](/docs/logs/ui-data/parsing#logtype)に関するドキュメントを参照してください。
* プログラムで解析ルールを管理するには、GraphQL形式のAPIであるNerdGraphを [api.newrelic.com/graphiql](https://api.newrelic.com/graphiql) でご利用いただけます。詳細については、 [NerdGraph チュートリアル](/docs/apis/nerdgraph/examples/nerdgraph-log-parsing-rules-tutorial) を参照して、解析ルールの作成、照会、削除を行ってください。

<CollapserGroup>
  <Collapser
    id="apache"
    title="Apache"
  >
    **ソース：** `logtype = 'apache'`

    **Grok:**

    ```grok
    %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent}
    ```

    **結果。**

    * `clientip`：クライアントのIPアドレス。
    * `verb`：HTTP動詞
    * `ident`：リクエストを行うクライアントのユーザーID
    * `response`：応答のHTTPステータスコード
    * `request`：作成中のURIとリクエスト
    * `httpversion`：リクエストのHTTPバージョン
    * `rawrequest`：データが投稿された場合の生のHTTPリクエスト
    * `bytes`：送信されたバイト数
    * `referrer`：HTTPリファラー
    * `agent`：クライアントのユーザーエージェント
  </Collapser>

  <Collapser
    id="apache_error"
    title="Apacheエラー"
  >
    **ソース：** `logtype = 'apache_error'`

    **Grok:**

    ```grok
    \[%{DATA:apache_error.timestamp}\] \[%{WORD:apache_error.source}:%{DATA:level}\] \[pid %{NUMBER:apache_error.pid}(:tid %{NUMBER:apache_error.tid})?\] (%{DATA:apache_error.sourcecode}\(%{NUMBER:apache_error.linenum}\): )?(?:\[client %{IPORHOST:apache_error.clientip}:%{POSINT:apache_error.port}\] ){0,1}%{GREEDYDATA:apache_error.message}
    ```

    **結果。**

    * `apache_error.timestamp`：ログステートメントのタイムスタンプ
    * `apache_error.source`：ソースモジュール
    * `level`：ログレベル
    * `apache_error.pid`：apache PID（プロセス識別子）
    * `apache_error.tid`：apache TID（スレッド識別子）
    * `apache_error.sourcecode`：apacheソースコード
    * `apache_error.linenum`：ソースコードの行番号
    * `apache_error.clientip`：クライアントのIPアドレス
    * `apache_error.port`：クライアントIPポート番号
    * `apache_error.message`：エラーメッセージ
  </Collapser>

  <Collapser
    id="application-load-balancer"
    title="アプリケーションロードバランサー"
  >
    **ソース：** `logtype = 'alb'`

    **Grok:**

    ```grok
    ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} "%{DATA:request}" "%{DATA:user_agent}" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} "%{DATA:trace_id}" "%{NOTSPACE:domain_name}" "%{NOTSPACE:chosen_cert_arn}" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} "%{NOTSPACE:actions_executed}" "%{NOTSPACE:redirect_url}" "%{NOTSPACE:error_reason}" (?:"|)%{DATA:target_port_list}(?:"|) (?:"|)%{DATA:target_status_code_list}(?:"|) "%{NOTSPACE:classification}" "%{NOTSPACE:classification_reason}"
    ```

    **結果。**

    <table>
      <thead>
        <tr>
          <th style={{ width: "250px" }}>
            フィールド
          </th>

          <th>
            定義
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `type`
          </td>

          <td>
            リクエストまたはコネクションのタイプです。可能な値は

            * `http`：HTTP
            * `https`：HTTP over SSL / TLS
            * `h2`：SSL/TLSを介したHTTP/2
            * `ws`：WebSocket
            * `wss`：SSL/TLSを介したWebSocket
          </td>
        </tr>

        <tr>
          <td>
            `elb`
          </td>

          <td>
            ロードバランサーのリソースID。アクセスログエントリを解析する場合は、リソースIDにスラッシュ（ `/` ）を含めることができることに注意してください。
          </td>
        </tr>

        <tr>
          <td>
            `client_ip`
          </td>

          <td>
            要求しているクライアントのIPアドレス
          </td>
        </tr>

        <tr>
          <td>
            `client_port`
          </td>

          <td>
            要求元のクライアントのIPポート
          </td>
        </tr>

        <tr>
          <td>
            `target_ip`
          </td>

          <td>
            このリクエストを処理したターゲットのIPアドレス。

            * クライアントが完全なリクエストを送信しなかった場合、ロードバランサーはリクエストをターゲットにディスパッチできず、この値は`-`に設定されます。
            * ターゲットがLambda関数の場合、この値は`-`に設定されます。
            * リクエストがAWSWAFによってブロックされている場合、この値は`-`に設定され、 `elb_status_code`の値は`403`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `target_port`
          </td>

          <td>
            このリクエストを処理したターゲットのIPポート。

            * クライアントが完全なリクエストを送信しなかった場合、ロードバランサーはリクエストをターゲットにディスパッチできず、この値は`-`に設定されます。
            * ターゲットがLambda関数の場合、この値は`-`に設定されます。
            * リクエストがAWSWAFによってブロックされている場合、この値は`-`に設定され、 `elb_status_code`の値は`403`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `target_port_list`
          </td>

          <td>
            このリクエストを処理したターゲットのIPアドレスとポート。

            * クライアントが完全なリクエストを送信しなかった場合、ロードバランサーはリクエストをターゲットにディスパッチできず、この値は`-`に設定されます。
            * ターゲットがLambda関数の場合、この値は`-`に設定されます。
            * リクエストがAWSWAFによってブロックされている場合、この値は`-`に設定され、 `elb_status_code`の値は`403`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `request_processing_time`
          </td>

          <td>
            ロードバランサーがリクエストを受信してからターゲットに送信するまでの経過時間の合計（秒単位、ミリ秒の精度）。

            * ロードバランサーがリクエストをターゲットにディスパッチできない場合、この値は`-1`に設定されます。これは、アイドルタイムアウトの前にターゲットが接続を閉じた場合、またはクライアントが不正な形式の要求を送信した場合に発生する可能性があります。
            * 登録されたターゲットがアイドルタイムアウトの前に応答しない場合、この値を`-1`に設定することもできます。
          </td>
        </tr>

        <tr>
          <td>
            `target_processing_time`
          </td>

          <td>
            ロードバランサーがターゲットにリクエストを送信してから、ターゲットがレスポンスヘッダーの送信を開始するまでの経過時間の合計（秒単位、ミリ秒の精度）。

            * ロードバランサーがリクエストをターゲットにディスパッチできない場合、この値は`-1`に設定されます。これは、アイドルタイムアウトの前にターゲットが接続を閉じた場合、またはクライアントが不正な形式の要求を送信した場合に発生する可能性があります。
            * 登録されたターゲットがアイドルタイムアウトの前に応答しない場合、この値を`-1`に設定することもできます。
          </td>
        </tr>

        <tr>
          <td>
            `response_processing_time`
          </td>

          <td>
            ロードバランサーがターゲットからレスポンスヘッダーを受信してから、クライアントへのレスポンスの送信を開始するまでに経過した時間の合計（秒単位、ミリ秒の精度）。ロードバランサーでのキューイング時間と、ロードバランサーからクライアントへの接続取得時間の両方が含まれます。

            ロードバランサーがターゲットにリクエストを送信できない場合、この値は`-1`に設定されます。これは、アイドルタイムアウトの前にターゲットが接続を閉じた場合、またはクライアントが不正な形式の要求を送信した場合に発生する可能性があります。
          </td>
        </tr>

        <tr>
          <td>
            `elb_status_code`
          </td>

          <td>
            ロードバランサーからのレスポンスのステータスコード
          </td>
        </tr>

        <tr>
          <td>
            `target_status_code_list`
          </td>

          <td>
            ターゲットからの応答のステータスコード。この値は、ターゲットへの接続が確立され、ターゲットが応答を送信した場合にのみ記録されます。それ以外の場合は、 `-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `received_bytes`
          </td>

          <td>
            クライアント（リクエスター）から受け取ったリクエストのサイズをバイト単位で表したもの。HTTPリクエストの場合、これにはヘッダーが含まれます。WebSocketの場合は、接続中のクライアントから受信したバイト数の合計です。
          </td>
        </tr>

        <tr>
          <td>
            `sent_bytes`
          </td>

          <td>
            クライアント（リクエスター）に送信されるレスポンスのサイズ（バイト）。HTTP リクエストの場合は、ヘッダーを含みます。WebSocket の場合は、接続中のクライアントに送信されたバイト数の合計です。
          </td>
        </tr>

        <tr>
          <td>
            `request`
          </td>

          <td>
            HTTPリクエスト
          </td>
        </tr>

        <tr>
          <td>
            `user_agent`
          </td>

          <td>
            二重引用符で囲まれた、リクエストを発信したクライアントを識別するUser-Agent文字列。この文字列は、1つまたは複数の製品識別子、製品/バージョンで構成されます。文字列の長さが8KBを超える場合は、切り捨てられます。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            SSL暗号。リスナーがHTTPSリスナーでない場合、この値は`-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            SSLプロトコル。リスナーがHTTPSリスナーでない場合、この値は`-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `target_group_arn`
          </td>

          <td>
            対象グループのAmazon Resource Name (ARN)
          </td>
        </tr>

        <tr>
          <td>
            `trace_id`
          </td>

          <td>
            二重引用符で囲まれた`X-Amzn-Trace-Id header`の内容
          </td>
        </tr>

        <tr>
          <td>
            `domain_name`
          </td>

          <td>
            TLSハンドシェイク中にクライアントによって提供されたSNIドメインで、二重引用符で囲まれています。クライアントがSNIをサポートしていない場合、またはドメインが証明書と一致せず、デフォルトの証明書がクライアントに提示される場合、この値は`-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `chosen_cert_arn`
          </td>

          <td>
            クライアントに提示する証明書のARNを二重引用符で囲んだもの。

            * セッションを再利用する場合は`session-reused`に設定してください。
            * リスナーがHTTPSリスナーでない場合は、 `-`に設定します。
          </td>
        </tr>

        <tr>
          <td>
            `matched_rule_priority`
          </td>

          <td>
            リクエストにマッチしたルールの優先度の値。

            * ルールが一致した場合、これは`1`から`50000`までの値です。
            * 一致するルールがなく、デフォルトのアクションが実行された場合、この値は`0`に設定されます。
            * ルールの評価中にエラーが発生した場合は、 `-1`に設定されます。
            * その他のエラーの場合は、 `-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `request_creation_time`
          </td>

          <td>
            ロードバランサーがクライアントからのリクエストを受信した時間（ISO 8601形式）。
          </td>
        </tr>

        <tr>
          <td>
            `actions_executed`
          </td>

          <td>
            リクエストの処理時に実行されるアクション。二重引用符で囲まれています。この値は、 `actions_taken`で説明されている値を含めることができるコンマ区切りのリストです。不正な形式のリクエストなど、アクションが実行されなかった場合、この値は`-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `redirect_url`
          </td>

          <td>
            二重引用符で囲まれた、HTTP応答のロケーションヘッダーのリダイレクトターゲットのURL。リダイレクトアクションが実行されなかった場合、この値は`-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `error_reason`
          </td>

          <td>
            二重引用符で囲まれたエラー理由コード。

            * リクエストが失敗した場合は、「エラー理由コード」に記載されているエラーコードのいずれかになります。
            * 実行されるアクションに認証アクションが含まれていない場合、またはターゲットがLambda関数でない場合、この値は`-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `classification`
          </td>

          <td>
            分類。
          </td>
        </tr>

        <tr>
          <td>
            `classification_reason`
          </td>

          <td>
            分類理由。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="cassandra"
    title="カサンドラ"
  >
    ソース： `logtype = 'cassandra'`

    Grok

    ```grok
    %{WORD:level}%{SPACE}\\[%{NOTSPACE:cassandra.thread}\\] %{TIMESTAMP_ISO8601:cassandra.timestamp} %{NOTSPACE:cassandra.source}:%{INT:cassandra.line.number} - %{GREEDYDATA:cassandra.message}
    ```

    ### 結果

    * `level`：メッセージのログレベル（すべて、トレース、デバッグ、情報、警告、エラー、オフ）
    * `cassandra.thread`：ログステートメントを発行するスレッドの名前
    * `cassandra.timestamp`：ログステートメントのタイムスタンプ
    * `cassandra.source`：ソースファイル名
    * `cassandra.line.number`：メッセージの行番号
    * `cassandra.message`：生のカサンドラメッセージ
  </Collapser>

  <Collapser
    id="cloudfront"
    title="CloudFront (標準ログ)"
  >
    **ソース：** `logtype = 'cloudfront-web'`

    **Grok:**

    ```
    ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end}
    ```

    **結果。**

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            フィールド
          </th>

          <th>
            定義
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            リクエストを処理したエッジの場所。各エッジの位置は、3文字のコードと任意に割り当てられた番号によって識別されます。たとえば、 `DFW3` 。

            この3文字のコードは、通常、エッジの位置の近くにある空港の国際航空運送協会の空港コードに対応しています。(これらの略語は将来的に変更される可能性があります）。
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            ヘッダーを含む、リクエストに応答してCloudFrontがビューアに提供した合計バイト数。たとえば、 `1045619` 。 WebSocket接続の場合、これは接続を介してサーバーからクライアントに送信される合計バイト数です。
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            IPv4またはIPv6形式のいずれかで要求を行ったビューアのIPアドレス。ビューアがHTTPプロキシまたはロードバランサを使用してリクエストを送信した場合、 `c_ip`の値はプロキシまたはロードバランサのIPアドレスです。 `X-Forwarded-For`も参照してください。
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            HTTPリクエストメソッド： `DELETE` 、 `GET` 、 `HEAD` 、 `OPTIONS` 、 `PATCH` 、 `POST` 、または`PUT` 。
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            CloudFrontディストリビューションのドメイン名。たとえば、 `d111111abcdef8.cloudfront.net` 。
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            パスとオブジェクトを識別するURIの部分。たとえば、 `/images/cat.jpg` 。 URLとクエリ文字列の疑問符は含まれていません。
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            HTTPステータスコード。たとえば、 `200` 。ステータスコード`000`は、CloudFrontがリクエストに応答する前に、ビューアが接続を閉じた（たとえば、ブラウザタブを閉じた）ことを示します。 CloudFrontがレスポンスの送信を開始した後にビューアが接続を閉じると、ログには該当するHTTPステータスコードが含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            リクエストを発信したドメインの名前です。一般的なリファラーには、検索エンジン、あなたのオブジェクトに直接リンクしている他のウェブサイト、あなた自身のウェブサイトなどがあります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            リクエストのUser-Agentヘッダーの値です。User-Agentヘッダーは、リクエストを送信したデバイスやブラウザの種類、該当する場合はどの検索エンジンかなど、リクエストの送信元を特定するものです。
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            URIのクエリ文字列部分（存在する場合）。 URIにクエリ文字列が含まれていない場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            名前と値のペアと関連する属性を含む、リクエストのクッキーヘッダ。

            * クッキーのロギングを有効にすると、お客様がどのクッキーをオリジンに転送するかに関わらず、CloudFrontはすべてのリクエストでクッキーをロギングします。
            * リクエストにCookieヘッダーが含まれていない場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            最後のバイトがエッジロケーションを離れた後、CloudFrontがレスポンスをどのように分類するか。場合によっては、CloudFrontがレスポンスを送信する準備ができてから、CloudFrontがレスポンスの送信を終了するまでの間に、結果タイプが変更されることがあります。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            リクエストを一意に識別する暗号化された文字列。応答ヘッダーでは、これは`x-amz-cf-id`です。
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            視聴者がこのリクエストのHostヘッダーに含めた値です。これは、リクエストのドメイン名です。

            * オブジェクトのURLにCloudFrontのドメイン名を使用している場合、このフィールドにはそのドメイン名が含まれます。
            * オブジェクトURLで`http://example.com/logo.png`などの代替ドメイン名を使用している場合、このフィールドには`example.com`などの代替ドメイン名が含まれます。代替ドメイン名を使用するには、それらをディストリビューションに追加する必要があります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            ビューアがリクエストで指定したプロトコル： `http` 、 `https` 、 `ws` 、または`wss` 。
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            視聴者がリクエストに含めたデータのバイト数（ヘッダーを含む）です。WebSocket接続の場合は、その接続でクライアントからサーバーに送信されたバイト数の合計です。
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            CloudFrontエッジサーバーが視聴者のリクエストを受信してから、CloudFrontがレスポンスの最後のバイトをエッジサーバーの出力キューに書き込むまでの秒数（1000分の1秒単位、例えば0.002）をサーバー上で計測したものです。

            視聴者から見ると、ネットワークの遅延やTCPのバッファリングにより、完全なオブジェクトを取得するまでの総時間はこの値よりも長くなります。
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            ビューアがHTTPプロキシまたはロードバランサを使用してリクエストを送信した場合、フィールド5の`c_ip`の値はプロキシまたはロードバランサのIPアドレスです。その場合、このフィールドはリクエストを発信したビューアのIPアドレスです。

            このフィールドには、必要に応じてIPv4アドレスとIPv6アドレスが含まれます。ビューアがHTTPプロキシまたはロードバランサを使用しなかった場合、 `x_forwarded_for`の値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            フィールド17の`cs_protocol`が`https`の場合、このフィールドには、クライアントとCloudFrontがリクエストとレスポンスを送信するためにネゴシエートしたSSL/TLSプロトコルが含まれます。可能な値は次のとおりです。

            * SSLv3

            * TLSv1

            * TLSv1.1

            * TLSv1.2

              フィールド17の`cs_protocol`が`http`の場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            フィールド17の`cs_protocol`が`https`の場合、このフィールドには、クライアントとCloudFrontがリクエストとレスポンスを暗号化するためにネゴシエートしたSSL/TLS暗号が含まれます。可能な値は次のとおりです。

            * `ECDHE-RSA-AES128-GCM-SHA256`

            * `ECDHE-RSA-AES128-SHA256`

            * `ECDHE-RSA-AES128-SHA`

            * `ECDHE-RSA-AES256-GCM-SHA384`

            * `ECDHE-RSA-AES256-SHA384`

            * `ECDHE-RSA-AES256-SHA`

            * `AES128-GCM-SHA256`

            * `AES256-GCM-SHA384`

            * `AES128-SHA256`

            * `AES256-SHA`

            * `AES128-SHA`

            * `DES-CBC3-SHA`

            * `RC4-MD5`

              フィールド17の`cs_protocol`が`http`の場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            視聴者にレスポンスを返す直前に、CloudFrontがレスポンスをどのように分類したか。可能な値は以下の通りです。

            * `Hit`：CloudFrontは、エッジキャッシュからビューアーにオブジェクトを提供しました。
            * `RefreshHit`：CloudFrontはエッジキャッシュでオブジェクトを検出しましたが、有効期限が切れていたため、CloudFrontはオリジンに連絡して、キャッシュに最新バージョンのオブジェクトがあることを確認しました。
            * `Miss`：エッジキャッシュ内のオブジェクトがリクエストを満たせなかったため、CloudFrontはリクエストをオリジンサーバーに転送し、結果をビューアに返しました。
            * `LimitExceeded`：CloudFrontの制限を超えたため、リクエストは拒否されました。
            * `CapacityExceeded`：リクエスト時にエッジロケーションにオブジェクトを提供するのに十分な容量がなかったため、CloudFrontは`503`エラーを返しました。
            * `Error`：通常、これは、リクエストの結果、クライアントエラー（ `sc_status`は`4xx` ）またはサーバーエラー（ `sc_status`は`5xx` ）が発生したことを意味します。 `x_edge_result_type`の値が`Error`で、このフィールドの値が`Error`で**ない**場合、クライアントはダウンロードを完了する前に切断します。
            * `Redirect`：CloudFrontはHTTPからHTTPSにリダイレクトします。 `sc_status`が`403`で、コンテンツの地理的分散を制限するようにCloudFrontを設定した場合、リクエストは制限された場所から送信された可能性があります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            視聴者がリクエストで指定したHTTPバージョン。可能な値は以下の通りです。

            * `HTTP/0.9`
            * `HTTP/1.0`
            * `HTTP/1.1`
            * `HTTP/2.0`
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            ディストリビューションにフィールドレベルの暗号化が設定されている場合、このフィールドには、リクエストボディが正常に処理されたかどうかを示すコードが含まれます。

            フィールドレベルの暗号化が配布用に構成されていない場合、値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `fle-encrypted-fields`
          </td>

          <td>
            CloudFrontが暗号化してオリジンに転送したフィールドの数。 CloudFrontは、データを暗号化するときに処理されたリクエストをオリジンにストリーミングするため、 `fle-status`の値がエラーであっても`fle-encrypted-fields`は値を持つことができます。

            フィールドレベルの暗号化が配布用に構成されていない場合、 `fle-encrypted-fields`の値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            視聴者からのリクエストのポート番号。
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            リクエストを受信してからレスポンスの最初のバイトを書き込むまでの秒数で、サーバー上で計測されます。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            `x-edge-result-type`**が**`Error`でない場合、このフィールドには`x-edge-result-type`と同じ値が含まれます。 `x-edge-result-type`**が**`Error`の場合、このフィールドには特定のタイプのエラーが含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            レスポンスのHTTP Content-Typeヘッダーの値です。
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            レスポンスの HTTP Content-Length ヘッダの値です。
          </td>
        </tr>

        <tr>
          <td>
            `sc_range_start`
          </td>

          <td>
            レスポンスに HTTP Content-Range ヘッダーが含まれている場合、このフィールドにはレンジの開始値が含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            レスポンスに HTTP Content-Range ヘッダーが含まれている場合、このフィールドには range end の値が格納されます。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="cloudfront-rtl"
    title="CloudFront (リアルタイム ログ)"
  >
    **ソース：** `logtype = 'cloudfront-rtl'`

    **Grok:**

    ```
    ^%{NOTSPACE:timestamp}.\d{3}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:cs_ip_version}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_cookie}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:c_country}%{SPACE}%{NOTSPACE:cs_accept_encoding}%{SPACE}%{NOTSPACE:cs_accept}%{SPACE}%{NOTSPACE:cache_behavior_path_pattern}%{SPACE}%{NOTSPACE:cs_headers}%{SPACE}%{NOTSPACE:cs_header_names}%{SPACE}%{NOTSPACE:cs_headers_count}$
    ```

    **結果。**

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            フィールド
          </th>

          <th>
            定義
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `timestamp`
          </td>

          <td>
            エッジ サーバーが要求への応答を終了した日時。
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            リクエストを行ったビューアーの IP アドレス (例: `192.0.2.183`または`2001:0db8:85a3:0000:0000:8a2e:0370:7334` 。ビューアが HTTP プロキシまたはロード バランサを使用してリクエストを送信した場合、このフィールドの値はプロキシまたはロード バランサの IP アドレスになります。`x-forwarded-for`フィールドも参照してください。
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            リクエストを受信してからレスポンスの最初のバイトを書き込むまでの秒数で、サーバー上で計測されます。
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            HTTPステータスコード。たとえば、 `200` 。ステータスコード`000`は、CloudFrontがリクエストに応答する前に、ビューアが接続を閉じた（たとえば、ブラウザタブを閉じた）ことを示します。 CloudFrontがレスポンスの送信を開始した後にビューアが接続を閉じると、ログには該当するHTTPステータスコードが含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            リクエストに応じてサーバーがビューアに送信した合計バイト数 (ヘッダーを含む)。WebSocket 接続の場合、これは接続を通じてサーバーからクライアントに送信された合計バイト数です。
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            ビューアから受け取った HTTP リクエスト メソッド。
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            ビューアー要求のプロトコル (http、https、ws、または wss)。
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            ビューアがリクエストの Host ヘッダーに含めた値。オブジェクト URL で CloudFront ドメイン名を使用している場合 (d111111abcdef8.cloudfront.net など)、このフィールドにはそのドメイン名が含まれています。オブジェクト URL ( [www.example.com](http://www.example.com)など) で代替ドメイン名 (CNAME) を使用している場合、このフィールドには代替ドメイン名が含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            クエリ文字列 (存在する場合) を含むが、ドメイン名を含まない、要求 URL 全体。たとえば、 `/images/cat.webp?mobile=true` .
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            ビューアーがリクエストに含めたデータの合計バイト数 (ヘッダーを含む)。WebSocket 接続の場合、これは接続でクライアントからサーバーに送信された合計バイト数です。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            リクエストを処理したエッジ ロケーション。各エッジ位置は、3 文字のコードと任意に割り当てられた番号 (DFW3 など) によって識別されます。通常、3 文字のコードは、エッジ ロケーションの地理的位置に近い空港の国際航空運送協会 (IATA) の空港コードに対応します。(これらの略語は将来変更される可能性があります。)
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            最後のバイトがエッジロケーションを離れた後、CloudFrontがレスポンスをどのように分類するか。場合によっては、CloudFrontがレスポンスを送信する準備ができてから、CloudFrontがレスポンスの送信を終了するまでの間に、結果タイプが変更されることがあります。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            リクエストを一意に識別する不透明な文字列。CloudFront は、この文字列も x-amz-cf-id 応答ヘッダーで送信します。
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            CloudFront ディストリビューションのドメイン名 (例: `d111111abcdef8.cloudfront.net` )。
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            サーバーで測定された、サーバーがビューアーの要求を受信してから、サーバーが応答の最後のバイトを出力キューに書き込むまでの秒数 (1000 分の 1 秒、たとえば 0.082)。ビューアの観点からは、完全な応答を取得するための合計時間は、ネットワークの遅延と TCP バッファリングのために、この値よりも長くなります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            ビューアがリクエストで指定した HTTP バージョン。可能な値には、 `HTTP/0.9` 、 `HTTP/1.0` 、 `HTTP/1.1` 、 `HTTP/2.0` 、および`HTTP/3.0`が含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `c_ip_version`
          </td>

          <td>
            リクエストの IP バージョン (IPv4 または IPv6)。
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            リクエストの User-Agent ヘッダーの値。User-Agent ヘッダーは、リクエストを送信したデバイスとブラウザのタイプ、またはリクエストが検索エンジンから来た場合はどの検索エンジンかなど、リクエストのソースを識別します。
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            リクエストの Referer ヘッダーの値。これは、リクエストを発信したドメインの名前です。一般的なリファラーには、検索エンジン、オブジェクトに直接リンクする他の Web サイト、および独自の Web サイトが含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            名前と値のペアおよび関連する属性を含む、リクエスト内の Cookie ヘッダー。
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            リクエスト URL のクエリ文字列部分 (存在する場合)。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            サーバーが応答をビューアに返す直前にどのように分類したか。x-edge-result-type フィールドも参照してください。可能な値は次のとおりです。

            * `Hit`: サーバーはオブジェクトをキャッシュからビューアに提供しました。
            * `RefreshHit`: サーバーはキャッシュ内にオブジェクトを見つけましたが、オブジェクトの有効期限が切れていたため、サーバーはオリジンに連絡して、キャッシュにオブジェクトの最新バージョンがあることを確認しました。
            * `Miss`: キャッシュ内のオブジェクトで要求を満たすことができなかったため、サーバーは要求をオリジン サーバーに転送し、結果をビューアーに返しました。
            * `LimitExceeded`: CloudFront クォータ (以前は制限と呼ばれていました) を超えたため、リクエストは拒否されました
            * `CapacityExceeded`: サーバーは、要求時にオブジェクトを提供するのに十分な容量がなかったため、503 エラーを返しました。
            * `Error`: 通常、これは、リクエストによってクライアント エラー (sc-status フィールドの値が 4xx の範囲内) またはサーバー エラー (sc-status フィールドの値が 5xx の範囲内) が発生したことを意味します。x-edge-result-type フィールドの値が Error で、このフィールドの値が Error でない場合、クライアントはダウンロードを完了する前に切断されました。
            * `Redirect`: サーバーは、配信設定に従って、ビューアを HTTP から HTTPS にリダイレクトしました。
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            ビューアが HTTP プロキシまたはロード バランサを使用してリクエストを送信した場合、c-ip フィールドの値はプロキシまたはロード バランサの IP アドレスです。その場合、このフィールドはリクエストを発信したビューアの IP アドレスです。このフィールドには、IPv4 アドレス (例: `192.0.2.183` ) または IPv6 アドレス (例: `2001:0db8:85a3:0000:0000:8a2e:0370:7334` ) が含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            リクエストで HTTPS が使用された場合、このフィールドには、ビューアとサーバーがリクエストとレスポンスを送信するためにネゴシエートした SSL/TLS プロトコルが含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            リクエストが HTTPS を使用した場合、このフィールドには、ビューアとサーバーがリクエストとレスポンスを暗号化するためにネゴシエートした SSL/TLS 暗号が含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            最後のバイトがサーバーを離れた後、サーバーがどのように応答を分類したか。場合によっては、サーバーが応答を送信する準備ができてから、応答の送信を終了するまでの間に、結果の型が変わることがあります。`x-edge-response-result-type`フィールドも参照してください。たとえば、HTTP ストリーミングで、サーバーがストリームのセグメントをキャッシュで見つけたとします。そのシナリオでは、このフィールドの値は通常`Hit`になります。ただし、サーバーがセグメント全体を配信する前に視聴者が接続を閉じた場合、最終的な結果のタイプ (およびこのフィールドの値) は`Error`になります。WebSocket 接続のこのフィールドの値は`Miss`になります。これは、コンテンツがキャッシュ可能ではなく、オリジンに直接プロキシされるためです。

            可能な値は次のとおりです。

            * `Hit`: サーバーはオブジェクトをキャッシュからビューアに提供しました。
            * `RefreshHit`: サーバーはキャッシュ内にオブジェクトを見つけましたが、オブジェクトの有効期限が切れていたため、サーバーはオリジンに連絡して、キャッシュにオブジェクトの最新バージョンがあることを確認しました。
            * `Miss`: キャッシュ内のオブジェクトで要求を満たすことができなかったため、サーバーは要求をオリジンに転送し、結果をビューアーに返しました。
            * `LimitExceeded`: CloudFront クォータ (以前は制限と呼ばれていました) を超えたため、リクエストは拒否されました。
            * `CapacityExceeded`: サーバーは、リクエスト時にオブジェクトを提供するのに十分な容量がなかったため、HTTP 503 ステータス コードを返しました。
            * `Error`: 通常、これは、リクエストによってクライアント エラー (sc-status フィールドの値が 4xx の範囲内) またはサーバー エラー (sc-status フィールドの値が 5xx の範囲内) が発生したことを意味します。`sc-status`フィールドの値が`200`の場合、またはこのフィールドの値が`Error`で`x-edge-response-result-type`フィールドの値が`Error`でない場合、HTTP リクエストは成功したが、クライアントがすべてのバイトを受信する前に切断されました。
            * `Redirect`: サーバーは、配信設定に従って、ビューアを HTTP から HTTPS にリダイレクトしました。
          </td>
        </tr>

        <tr>
          <td>
            `fle_encrypted_fields`
          </td>

          <td>
            サーバーが暗号化してオリジンに転送したフィールドレベルの暗号化フィールドの数。CloudFront サーバーは、データを暗号化するときに、処理されたリクエストをオリジンにストリーミングします。そのため、 `fle-status`の値がエラーであっても、このフィールドに値を設定できます。
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            フィールド レベルの暗号化がディストリビューションに設定されている場合、このフィールドには、リクエスト ボディが正常に処理されたかどうかを示すコードが含まれます。サーバーがリクエスト本文を正常に処理し、指定されたフィールドの値を暗号化し、リクエストをオリジンに転送すると、このフィールドの値は Processed になります。この場合、 `x-edge-result-type`の値はクライアント側またはサーバー側のエラーを示している可能性があります。

            このフィールドの可能な値は次のとおりです。 \* `ForwardedByContentType` : コンテンツ タイプが構成されていないため、サーバーは解析または暗号化なしでリクエストをオリジンに転送しました。

            * `ForwardedByQueryArgs`: サーバーは、フィールドレベルの暗号化の構成に含まれていないクエリ引数がリクエストに含まれているため、解析または暗号化を行わずにリクエストをオリジンに転送しました。
            * `ForwardedDueToNoProfile`: フィールドレベルの暗号化の構成でプロファイルが指定されていなかったため、サーバーは解析または暗号化なしでリクエストをオリジンに転送しました。
            * `MalformedContentTypeClientError`: Content-Type ヘッダーの値が無効な形式であるため、サーバーは要求を拒否し、HTTP 400 ステータス コードをビューアーに返しました。
            * `MalformedInputClientError`: サーバーはリクエストを拒否し、HTTP 400 ステータス コードをビューアに返しました。これは、リクエスト ボディの形式が無効であったためです。
            * `MalformedQueryArgsClientError`: サーバーはリクエストを拒否し、HTTP 400 ステータス コードをビューアに返しました。これは、クエリ引数が空であるか無効な形式であったためです。
            * `RejectedByContentType`: サーバーはリクエストを拒否し、HTTP 400 ステータス コードをビューアに返しました。これは、フィールド レベルの暗号化の設定でコンテンツ タイプが指定されていないためです。
            * `RejectedByQueryArgs`: フィールドレベルの暗号化の構成でクエリ引数が指定されていなかったため、サーバーは要求を拒否し、HTTP 400 ステータス コードをビューアに返しました。
            * `ServerError`: オリジン サーバーがエラーを返しました。リクエストがフィールド レベルの暗号化クォータ (以前は制限と呼ばれていました) を超えた場合、このフィールドには次のいずれかのエラー コードが含まれ、サーバーは HTTP ステータス コード 400 をビューアに返します。
            * `FieldLengthLimitClientError`: 暗号化するように構成されているフィールドが、許可されている最大長を超えています
            * `FieldNumberLimitClientError`: ディストリビューションが暗号化するように構成されているリクエストに、許可されているフィールド数を超える数が含まれています。
            * `RequestLengthLimitClientError`: 要求本文の長さが、フィールド レベルの暗号化が構成されている場合に許可される最大長を超えました。
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            レスポンスのHTTP Content-Typeヘッダーの値です。
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            レスポンスの HTTP Content-Length ヘッダの値です。
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-start`
          </td>

          <td>
            レスポンスに HTTP Content-Range ヘッダーが含まれている場合、このフィールドにはレンジの開始値が含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            レスポンスに HTTP Content-Range ヘッダーが含まれている場合、このフィールドには range end の値が格納されます。
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            視聴者からのリクエストのポート番号。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            `x-edge-result-type`フィールドの値が`Error`の場合、このフィールドには特定のタイプのエラーが含まれます。オブジェクトが Origin Shield キャッシュからビューアに提供された場合、このフィールドには`OriginShieldHit`が含まれます。それ以外の場合、このフィールドには`x-edge-result-type`と同じ値が含まれます。このフィールドの可能な値は次のとおりです。

            * `AbortedOrigin`: サーバーでオリジンに問題が発生しました。
            * `OriginCommError`: オリジンへの接続中、またはオリジンからのデータの読み取り中にリクエストがタイムアウトしました。
            * `ClientCommError`: サーバーとビューアー間の通信の問題により、ビューアーへの応答が中断されました。
            * `ClientGeoBlocked`: ディストリビューションは、視聴者の地理的な場所からの要求を拒否するように構成されています。
            * `ClientHungUpRequest`: リクエストの送信中にビューアが途中で停止しました。
            * `Error` – エラー タイプが他のどのカテゴリにも当てはまらないエラーが発生しました。このエラー タイプは、サーバーがキャッシュからエラー応答を提供するときに発生する可能性があります。
            * `InvalidRequest`: サーバーはビューアから無効なリクエストを受け取りました。
            * `InvalidRequestBlocked`: 要求されたリソースへのアクセスがブロックされています。
            * `InvalidRequestCertificate`: ディストリビューションは、HTTPS 接続が確立された SSL/TLS 証明書と一致しません。
            * `InvalidRequestHeader`: リクエストに無効なヘッダーが含まれていました。
            * `InvalidRequestMethod`: ディストリビューションは、使用された HTTP 要求メソッドを処理するように構成されていません。これは、ディストリビューションがキャッシュ可能なリクエストのみをサポートしている場合に発生する可能性があります。
            * `OriginConnectError`: サーバーはオリジンに接続できませんでした。
            * `OriginContentRangeLengthError`: オリジンの応答の Content-Length ヘッダーが Content-Range ヘッダーの長さと一致しません。
            * `OriginDnsError`: サーバーはオリジンのドメイン名を解決できませんでした。
            * `OriginError`: オリジンが誤った応答を返しました。
            * `OriginHeaderTooBigError`: オリジンから返されたヘッダーが大きすぎて、エッジ サーバーが処理できません。
            * `OriginInvalidResponseError`: オリジンが無効な応答を返しました。
            * `OriginReadError`: サーバーは起点から読み取ることができませんでした。
            * `OriginShieldHit`: オブジェクトは Origin Shield キャッシュからビューアに提供されました。
            * `OriginWriteError`: サーバーはオリジンに書き込めませんでした。
            * `OriginZeroSizeObjectError`: オリジンからサイズ 0 のオブジェクトが送信されたため、エラーが発生しました。
            * `SlowReaderOriginError`: ビューアーは、元のエラーの原因となったメッセージを読むのが遅かった.
          </td>
        </tr>

        <tr>
          <td>
            `c_country`
          </td>

          <td>
            視聴者の IP アドレスによって決定される、視聴者の地理的な場所を表す国コード。
          </td>
        </tr>

        <tr>
          <td>
            `cs_accept_encoding`
          </td>

          <td>
            ビューア リクエストの`Accept-Encoding`ヘッダーの値。
          </td>
        </tr>

        <tr>
          <td>
            `cs_accept`
          </td>

          <td>
            ビューア リクエストの`Accept`ヘッダーの値。
          </td>
        </tr>

        <tr>
          <td>
            `cache_behavior_path_pattern`
          </td>

          <td>
            ビューアのリクエストに一致したキャッシュ動作を識別するパス パターン。
          </td>
        </tr>

        <tr>
          <td>
            `cs_headers`
          </td>

          <td>
            ビューアー リクエストの HTTP ヘッダー (名前と値)。
          </td>
        </tr>

        <tr>
          <td>
            `cs_header_names`
          </td>

          <td>
            ビューアー リクエストの HTTP ヘッダーの名前 (値ではない)。
          </td>
        </tr>

        <tr>
          <td>
            `cs_headers_count`
          </td>

          <td>
            ビューア リクエストの HTTP ヘッダーの数。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="elastic-load-balancer"
    title="弾性ロードバランサー"
  >
    **ソース：** `logtype = 'elb'`

    **Grok:**

    ```grok
    ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} "%{DATA:request}" "%{DATA:user_agent}" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol}
    ```

    **結果。**

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            フィールド
          </th>

          <th>
            定義
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            リクエストを処理したエッジの場所。各エッジの位置は、3文字のコードと任意に割り当てられた番号によって識別されます。たとえば、 `DFW3` 。 3文字のコードは通常、エッジロケーションに近い空港の国際航空運送協会の空港コードに対応しています。 （これらの略語は将来変更される可能性があります。）
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            ヘッダーを含む、リクエストに応答してCloudFrontがビューアに提供した合計バイト数。たとえば、 `1045619` 。 WebSocket接続の場合、これは接続を介してサーバーからクライアントに送信される合計バイト数です。
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            リクエストを行ったビューアのIPアドレス。ビューアがHTTPプロキシまたはロードバランサを使用してリクエストを送信した場合、 `c_ip`の値はプロキシまたはロードバランサのIPアドレスです。
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            HTTPリクエストメソッド： `DELETE` 、 `GET` 、 `HEAD` 、 `OPTIONS` 、 `PATCH` 、 `POST` 、または`PUT` 。
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            CloudFrontディストリビューションのドメイン名。たとえば、 `d111111abcdef8.cloudfront.net` 。
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            パスとオブジェクトを識別するURIの部分。たとえば、 `/images/cat.jpg` 。 URLおよびクエリ文字列の疑問符（ `?` ）はログに含まれません。
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            HTTPステータスコード（たとえば、 `200` ）。ステータスコード`000`は、CloudFrontがリクエストに応答する前に、ビューアが接続を閉じた（たとえば、ブラウザタブを閉じた）ことを示します。

            CloudFrontがレスポンスの送信を開始した後にビューアーが接続を閉じた場合、ログには該当するHTTPステータスコードが含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            リクエストを発信したドメインの名前です。一般的なリファラーには、検索エンジン、あなたのオブジェクトに直接リンクしている他のWebサイト、あなた自身のWebサイトなどがあります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            リクエストのUser-Agentヘッダーの値です。User-Agentヘッダーは、リクエストを送信したデバイスやブラウザの種類、該当する場合はどの検索エンジンかなど、リクエストの送信元を特定するものです。
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            URIのクエリ文字列部分（存在する場合）。 URIにクエリ文字列が含まれていない場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            名前と値のペアと関連する属性を含む、リクエストのクッキーヘッダ。

            * クッキーのロギングを有効にすると、お客様がどのクッキーをオリジンに転送するかにかかわらず、CloudFrontはすべてのリクエストでクッキーをロギングします。
            * リクエストにCookieヘッダーが含まれていない場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            最後のバイトがエッジロケーションを離れた後、CloudFrontがレスポンスをどのように分類するか。場合によっては、CloudFrontがレスポンスを送信する準備ができてから、CloudFrontがレスポンスの送信を終了するまでの間に、結果タイプが変更されることがあります。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            リクエストを一意に識別する暗号化された文字列。応答ヘッダーでは、これは`x-amz-cf-id`です。
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            視聴者がこのリクエストのHostヘッダーに含めた値です。これは、リクエストのドメイン名です。

            * オブジェクトのURLにCloudFrontのドメイン名を使用している場合、このフィールドにはそのドメイン名が含まれます。
            * オブジェクトURLで`[http://example.com/logo.png`などの代替ドメイン名を使用している場合、このフィールドには`example.com`などの代替ドメイン名が含まれます。代替ドメイン名を使用するには、それらをディストリビューションに追加する必要があります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            ビューアがリクエストで指定したプロトコル： `http` 、 `https` 、 `ws` 、または`wss` 。
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            視聴者がリクエストに含めたデータのバイト数（ヘッダーを含む）です。WebSocket接続の場合は、その接続でクライアントからサーバーに送信されたバイト数の合計です。
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            CloudFrontエッジサーバーが視聴者のリクエストを受信してから、CloudFrontがレスポンスの最後のバイトをエッジサーバーの出力キューに書き込むまでの秒数（1000分の1秒単位、例えば0.002）をサーバー上で計測したものです。

            視聴者から見ると、ネットワークの遅延やTCPのバッファリングにより、完全なオブジェクトを取得するまでの総時間はこの値よりも長くなります。
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            ビューアがHTTPプロキシまたはロードバランサを使用してリクエストを送信した場合、フィールド5の`c_ip`の値はプロキシまたはロードバランサのIPアドレスです。その場合、このフィールドはリクエストを発信したビューアのIPアドレスです。このフィールドには、必要に応じてIPv4アドレスとIPv6アドレスが含まれます。

            ビューアがHTTPプロキシまたはロードバランサを使用しなかった場合、 `x_forwarded_for`の値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            フィールド17の`cs_protocol`が`https`の場合、このフィールドには、クライアントとCloudFrontがリクエストとレスポンスを送信するためにネゴシエートしたSSL/TLSプロトコルが含まれます。可能な値は次のとおりです。

            * SSLv3
            * TLSv1
            * TLSv1.1
            * TLSv1.2フィールド17の`cs_protocol`が`http`の場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            フィールド17の`cs_protocol`が`https`の場合、このフィールドには、クライアントとCloudFrontがリクエストとレスポンスを暗号化するためにネゴシエートしたSSL/TLS暗号が含まれます。可能な値は次のとおりです。

            * `ECDHE-RSA-AES128-GCM-SHA256`

            * `ECDHE-RSA-AES128-SHA256`

            * `ECDHE-RSA-AES128-SHA`

            * `ECDHE-RSA-AES256-GCM-SHA384`

            * `ECDHE-RSA-AES256-SHA384`

            * `ECDHE-RSA-AES256-SHA`

            * `AES128-GCM-SHA256`

            * `AES256-GCM-SHA384`

            * `AES128-SHA256`

            * `AES256-SHA`

            * `AES128-SHA`

            * `DES-CBC3-SHA`

            * `RC4-MD5`

              `cs_protocol`が`http`の場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            視聴者にレスポンスを返す直前に、CloudFrontがレスポンスをどのように分類したか。可能な値は以下の通りです。

            * `Hit`：CloudFrontは、エッジキャッシュからビューアーにオブジェクトを提供しました。
            * `RefreshHit`：CloudFrontはエッジキャッシュでオブジェクトを検出しましたが、有効期限が切れていたため、CloudFrontはオリジンに連絡して、キャッシュに最新バージョンのオブジェクトがあることを確認しました。
            * `Miss`：エッジキャッシュ内のオブジェクトがリクエストを満たせなかったため、CloudFrontはリクエストをオリジンサーバーに転送し、結果をビューアに返しました。
            * `LimitExceeded`：CloudFrontの制限を超えたため、リクエストは拒否されました。
            * `CapacityExceeded`：リクエスト時にエッジロケーションにオブジェクトを提供するのに十分な容量がなかったため、CloudFrontは`503`エラーを返しました。
            * `Error`：通常、これは、リクエストの結果、クライアントエラー（ `sc_status`は`4xx` ）またはサーバーエラー（ `sc_status`は`5xx` ）が発生したことを意味します。 `x_edge_result_type`の値が`Error`で、このフィールドの値が`Error`で**ない**場合、クライアントはダウンロードを完了する前に切断します。
            * `Redirect`：CloudFrontはHTTPからHTTPSにリダイレクトします。 `sc_status`が`403`で、コンテンツの地理的分散を制限するようにCloudFrontを設定した場合、リクエストは制限された場所から送信された可能性があります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            視聴者がリクエストで指定したHTTPバージョン。可能な値は以下の通りです。

            * `HTTP/0.9`
            * `HTTP/1.0`
            * `HTTP/1.1`
            * `HTTP/2.0`
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            フィールドレベルの暗号化がディストリビューションに設定されている場合、このフィールドには、リクエスト本文が正常に処理されたかどうかを示すコードが含まれます。フィールドレベルの暗号化が配布用に構成されていない場合、このフィールドの値はハイフン（ `-` ）です。

            CloudFrontがリクエスト本文を正常に処理し、指定されたフィールドの値を暗号化し、リクエストをオリジンに転送すると、このフィールドの値は`Processed`になります。この場合でも、 `x_edge_result_type`の値はクライアント側またはサーバー側のエラーを示している可能性があります。

            リクエストがフィールドレベルの暗号化制限を超えた場合、 `fle-status`には次のエラーコードのいずれかが含まれ、CloudFrontはHTTPステータスコード`400`をビューアに返します。
          </td>
        </tr>

        <tr>
          <td>
            `fle-encrypted-fields`
          </td>

          <td>
            CloudFrontが暗号化してオリジンに転送したフィールドの数。 CloudFrontは、データを暗号化するときに処理されたリクエストをオリジンにストリーミングするため、 `fle_status`の値がエラーであっても`fle_encrypted_fields`は値を持つことができます。

            フィールドレベルの暗号化が配布用に構成されていない場合、 `fle_encrypted_fields`の値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            視聴者からのリクエストのポート番号。
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            リクエストを受信してからレスポンスの最初のバイトを書き込むまでの秒数で、サーバー上で計測されます。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            `x_edge_result_type`**が**`Error`でない場合、このフィールドには`x_edge_result_type`と同じ値が含まれます。 `x_edge_result_type`**が**`Error`の場合、このフィールドには特定のタイプのエラーが含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            レスポンスのHTTP Content-Typeヘッダーの値です。
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            レスポンスの HTTP Content-Length ヘッダの値です。
          </td>
        </tr>

        <tr>
          <td>
            `sc_range_start`
          </td>

          <td>
            レスポンスに HTTP Content-Range ヘッダーが含まれている場合、このフィールドにはレンジの開始値が含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            レスポンスに HTTP Content-Range ヘッダーが含まれている場合、このフィールドには range end の値が格納されます。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="haproxy"
    title="HAProxy"
  >
    **ソース：** `logtype = 'haproxy_http'`

    **Grok:**

    ```grok
    %{HOSTPORT:client} \\[%{NOTSPACE:haproxy_timestamp}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{NUMBER:time_queue}/%{NUMBER:time_backend_connect}/%{NUMBER:time_duration} %{NUMBER:bytes_read} %{NOTSPACE:termination_state} %{NUMBER:actconn}/%{NUMBER:feconn}/%{NUMBER:beconn}/%{NUMBER:srvconn}/%{NUMBER:retries} %{NUMBER:srv_queue}/%{NUMBER:backend_queue}
    ```

    ```
    %{HOSTPORT:client} \\[%{NOTSPACE:haproxy_timestamp}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{NUMBER:time_client_req}/%{NUMBER:time_queue}/%{NUMBER:time_backend_connect}/%{NUMBER:time_server_response}/%{NUMBER:time_duration} %{NUMBER:status_code} %{NUMBER:bytes_read} %{NOTSPACE:captured_request_cookie} %{NOTSPACE:captured_response_cookie} %{NOTSPACE:termination_state_with_cookie_status} %{NUMBER:actconn}/%{NUMBER:feconn}/%{NUMBER:beconn}/%{NUMBER:srvconn}/%{NUMBER:retries} %{NUMBER:srv_queue}/%{NUMBER:backend_queue}?( \\\"%{GREEDYDATA:full_http_request}\\\")?( %{NOTSPACE:captured_response_headers})?
    ```

    **結果。**

    * `client`：このリクエストの送信元IP/ポート
    * `haproxy_timestamp`：このリクエストが受け入れられたときのタイムスタンプ
    * `frontend_name`：このリクエストで使用されたフロントエンドの名前
    * `backend_name`：このリクエストで使用されたバックエンドの名前
    * `server_name`：このリクエストで使用されたバックエンドグループのサーバー名
    * `time_client_req`：クライアントからの完全な要求を待機する時間（ミリ秒）
    * `time_queue`：キューでの待機時間（ミリ秒）
    * `time_backend_connect`：宛先サーバーへの接続を確立する時間（ms）
    * `time_server_response`：宛先サーバーが応答を送信する時間（ミリ秒）
    * `time_duration`：HAProxyでアクティブなリクエストの合計時間（ミリ秒）
    * `status_code`：HTTP応答コード
    * `bytes_read`：このリクエストで読み取られた合計バイト数
    * `captured_request_cookie`：リクエストからキャプチャされたCookie
    * `captured_response_cookie`：応答からキャプチャされたCookie
    * `termination_state`：切断時のセッション状態
    * `termination_state_with_cookie_status`：切断時のCookieステータスを含むセッション状態
    * `actconn`：アクティブな接続
    * `feconn`: フロントエンド接続
    * `beconn`: バックエンド接続
    * `srvconn`：サーバー接続
    * `retries`：再試行
    * `srv_queue`：サーバーキューサイズ
    * `backend_queue`: バックエンド キュー サイズ
    * `full_http_request`：完全なHTTPリクエストライン
    * `captured_response_headers`：応答からキャプチャされたヘッダー
  </Collapser>

  <Collapser
    id="ktranslate-health"
    title="KTranslate Health"
  >
    **ソース：** `logtype = 'ktranslate-health'`

    **Grok:**

    ```grok
    %{NOTSPACE:timestamp} ktranslate(/)?(%{GREEDYDATA:container_service})? \[%{NOTSPACE:severity}] %{GREEDYDATA:message}
    ```

    **結果。**

    * `timestamp`：ログの時間
    * `container_service`：ktranslateでコンテナを区別するために使用される一意の識別子。これは、Dockerの実行時にオプションの`--service_name`フラグを使用して設定されます
    * `severity`：ログ行の重大度
    * `message`：メッセージフィールドには、イベントに関する情報を提供する自由形式のメッセージが含まれます
  </Collapser>

  <Collapser
    id="linux_cron"
    title="Linux Cron（/ var / log / cron）"
  >
    **ソース：** `logtype = 'linux_cron'`

    **Grok:**

    ```grok
    %{SYSLOGTIMESTAMP:linux_cron.timestamp} %{NOTSPACE:linux_cron.hostname} %{DATA:linux_cron.process}(\[%{NUMBER:linux_cron.pid:integer}\])?: (\(%{DATA:linux_cron.user}\))?%{GREEDYDATA:linux_cron.message}
    ```

    **結果。**

    * `linux_cron.timestamp`：ログの時間
    * `linux_cron.hostname`：Linuxサーバーのホスト名
    * `linux_cron.process`：Linuxcronプロセス名
    * `linux_cron.pid`：Linux cron PID（プロセス識別子）
    * `linux_cron.user`：cronを実行したLinuxユーザー
    * `linux_cron.message`：ログメッセージ
  </Collapser>

  <Collapser
    id="linux_messages"
    title="Linuxメッセージ（/ var / log / messages）"
  >
    **ソース：** `logtype = 'linux_messages'`

    **Grok:**

    ```grok
    %{SYSLOGTIMESTAMP:linux_messages.timestamp} %{NOTSPACE:linux_messages.hostname} %{DATA:linux_messages.process}(\[%{NUMBER:linux_messages.pid:integer}\])?: %{GREEDYDATA:linux_messages.message}
    ```

    **結果。**

    * `linux_messages.timestamp`：ログの時間
    * `linux_messages.hostname`：Linuxサーバーのホスト名
    * `linux_messages.process`：Linuxプロセス名
    * `linux_messages.pid`：Linux PID（プロセス識別子）
    * `linux_messages.message`：ログメッセージ
  </Collapser>

  <Collapser
    id="iis"
    title="マイクロソフトIIS"
  >
    **ソース：** `logtype = 'iis_w3c'`

    **Grok:**

    ```grok
    %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken}
    ```

    **結果。**

    IISでは、いくつかの[構成オプション](https://docs.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms524877(v=vs.90))を使用できます。デフォルト以外のオプションを構成した場合、Grokパターンはログを解析しません。この場合、[カスタム解析](/docs/logs/ui-data/parsing/#custom-parsing)を使用することをお勧めします。
  </Collapser>

  <Collapser
    id="mongodb"
    title="Mongodb"
  >
    **ソース：** `logtype = 'mongodb'`

    **Grok:**

    ```grok
    %{TIMESTAMP_ISO8601:mongodb.timestamp} %{WORD:mongodb.severity} %{WORD:mongodb.component} *\[%{WORD:mongodb.context}\] %{GREEDYDATA:mongodb.message}
    ```

    **結果。**

    * `mongodb.timestamp`：ログステートメントのタイムスタンプ
    * `mongodb.severity`：ログステートメントの重大度レベル（F =致命的、E =エラー、W =警告、I =情報、D1-5 =デバッグ）
    * `mongodb.component`：ログステートメントを発行するスレッドのカテゴリ
    * `mongodb.context`：ログステートメントを発行するスレッドの名前
    * `mongodb.message`：生のmongodbメッセージ
  </Collapser>

  <Collapser
    id="monit"
    title="Monit"
  >
    **ソース：** `logtype = 'monit'`

    **Grok:**

    ```grok
    \\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message}
    ```

    **結果。**

    * `state`：ログ行の重大度
    * `message`： メッセージ
  </Collapser>

  <Collapser
    id="mysql-error"
    title="MySQLエラー"
  >
    **ソース：** `logtype = 'mysql-error'`

    **Grok:**

    ```grok
    \\[%{WORD:log_level}\\]
    ```

    **結果。**

    * `log_level`：ログ行の重大度
  </Collapser>

  <Collapser
    id="nginx"
    title="NGINX"
  >
    **ソース：** `logtype = 'nginx'`

    **Grok:**

    ```grok
    %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent}
    ```

    **結果。**

    * `clientip`：クライアントのIPアドレス
    * `verb`：HTTP動詞
    * `ident`：リクエストを行うクライアントのユーザーID
    * `response`：応答のHTTPステータスコード
    * `request`：作成中のURIとリクエスト
    * `httpversion`：リクエストのHTTPバージョン
    * `rawrequest`：データが投稿された場合の生のHTTPリクエスト
    * `bytes`：送信されたバイト数
    * `referrer`：HTTPリファラー
    * `agent`：クライアントのユーザーエージェント
  </Collapser>

  <Collapser
    id="nginx-error"
    title="NGINXエラー"
  >
    **ソース：** `logtype = 'nginx-error'`

    **Grok:**

    ```grok
    ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \[%{WORD:severity}\] %{POSINT:pid}#%{NUMBER}: \*%{NUMBER} %{GREEDYDATA:errormessage} client: %{IPORHOST:client}, server: %{NOTSPACE:server}, request: (\\)?"%{DATA:request}", (?:, upstream: \"%{URI:upstream}\")?host: (\\)?"%{NOTSPACE:host}(\\)?"(, referrer: (\\)?"%{URI:referrer}(\\)?")?
    ```

    **結果。**

    * `severity`：ログ行の重大度
    * `pid`：サーバープロセスID
    * `errormessage`：エラーメッセージ
    * `clientip`：呼び出し元クライアントのIPアドレス
    * `server`：サーバーのIPアドレス
    * `request`：完全なリクエスト
    * `upstream`：アップストリームURI
    * `host`：サーバーのホスト名
    * `referrer`：HTTPリファラー
  </Collapser>

  <Collapser
    id="postgresql"
    title="Postgresql"
  >
    ソース： `logtype = 'postgresql'`

    Grok:

    ```grok
    %{DATA:postgresql.timestamp} \[%{NUMBER:postgresql.pid}\] %{WORD:level}:\s+%{GREEDYDATA:postgresql.message}
    ```

    ### 結果

    * `postgresql.timestamp`：ログのタイムスタンプ
    * `postgresql.pid`：サーバープロセスID
    * `level`：メッセージのログレベル
    * `postgresql.message`：ログメッセージ
  </Collapser>

  <Collapser
    id="rabbitmq"
    title="ラビットエムキュー"
  >
    **ソース：** `logtype = 'rabbitmq'`

    **Grok:**

    ```grok
    %{TIMESTAMP_ISO8601:rabbitmq.timestamp} \[%{LOGLEVEL:level}\] \<%{DATA:rabbitmq.pid}\> %{GREEDYDATA:rabbitmq.message}
    ```

    **結果。**

    * `rabbitmq.timestamp`：ログのタイムスタンプ
    * `level`：メッセージのログレベル（デバッグ、情報、警告、エラー、クリティカル、なし）
    * `rabbitmq.pid`：ログ行のプロセスID
    * `rabbitmq.message`：rabbitmqエラーメッセージ
  </Collapser>

  <Collapser
    id="redis"
    title="Redis"
  >
    **ソース：** `logtype = 'redis'`

    **Grok:**

    ```grok
    %{POSINT:redis.pid}:%{NOTSPACE:redis.role} (?<redistimestamp>[\d-]+ [a-zA-Z]+ [\d]+ [\d:]+.[\d]{3}) %{NOTSPACE:level} %{GREEDYDATA:redis.message}
    ```

    **結果。**

    * `redis.pid`：ログ行のプロセスID
    * `redis.role`：インスタンスのロール（Xセンチネル、C RDB / AOF書き込み子、Sスレーブ、Mマスター）
    * `redistimestamp`：ログのタイムスタンプ
    * `level`：メッセージのログレベル（。debug、-verbose、\* Notice、＃warning）
    * `redis.message`：redisエラーメッセージ
  </Collapser>

  <Collapser
    id="route53"
    title="ルート53"
  >
    **ソース：** `logtype = 'route-53'`

    **Grok:**

    ```grok
    %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet}
    ```

    **結果。**

    * `log_format_version`：ログのバージョン管理された形式。
    * `zone_id`：このログのすべてのDNSクエリに関連付けられているホストゾーンのID。
    * `query`：リクエストで指定されたドメインまたはサブドメイン。
    * `query_type`：リクエストで指定されたDNSレコードタイプ、または`ANY`のいずれか。
    * `response_code`：DNSクエリに応答してRoute53が返したDNS応答コード。
    * `protocol`：クエリの送信に使用されたプロトコル（TCPまたはUDP）。
    * `edge_location`：クエリに応答したRoute53エッジの場所。各エッジの位置は、3文字のコードと任意の番号で識別されます。たとえば、 `DFW3` 。 3文字のコードは通常、エッジロケーションに近い空港の国際航空運送協会の空港コードに対応しています。 （これらの略語は将来変更される可能性があります。）
    * `resolver_ip`：Route53にリクエストを送信したDNSリゾルバーのIPアドレス。
    * `edns_client_subnet`：DNSリゾルバーから利用可能な場合、要求の発信元のクライアントの部分的なIPアドレス。
  </Collapser>

  <Collapser
    id="syslog-rfc5424"
    title="シスログ RFC-5424"
  >
    **ソース：** `logtype = 'syslog-rfc5424'`

    **Grok:**

    ```grok
    <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\-|%{NOTSPACE:app.name}) +(?:\\-|%{NOTSPACE:procid}) (?:\\-|%{NOTSPACE:msgid}) +(?:\[%{DATA:structured.data}\]|-|) +%{GREEDYDATA:message}
    ```

    **結果。**

    * `pri`：優先度は、メッセージ機能と重大度の両方を表します。
    * `version`：Syslogプロトコルバージョン。
    * `log.timestamp`：元のタイムスタンプ。
    * `hostname`：最初にSyslogメッセージを送信したマシン。
    * `app.name`：メッセージを発信したデバイスまたはアプリケーション。
    * `procid`：Syslogシステムに関連付けられているプロセス名またはプロセスID。
    * `msgid`：メッセージのタイプを識別します。
    * `structured.data`：構造化データ文字列値。
    * `sd.sd-id.sd-param-name`： `structured.data`コンテンツも、事前定義された命名規則に従って個別の属性に解析されます： `sd.sd-id.sd-param-name` 。以下の構造化データ解析の例を参照してください。
    * `message`：イベントに関する情報を提供する自由形式のメッセージ。

    **構造化データのパーシング例**

    構造化データ`[example one="1" two="2"]`は、次の2つの異なる属性に解析されます。

    ```
    sd.example.one: "1"
    sd.example.two: "2"
    ```

    同じ構造化データブロックに重複するパラメータ名が含まれている場合は、属性名にインデックスベースのサフィックスも追加されます。たとえば、構造化データ`[example number="1" number="2"]`は次のように解析されます。

    ```
    sd.example.number.0: "1"
    sd.example.number.1: "2"
    ```

    エンタープライズ番号が割り当てられた構造化データの場合、追加の属性も解析されます。たとえば、構造化データ`[example@123 number="1"]`は次のように解析されます。

    ```
    sd.example.enterprise.number: 123
    sd.example.number: "1"
    ```
  </Collapser>
</CollapserGroup>