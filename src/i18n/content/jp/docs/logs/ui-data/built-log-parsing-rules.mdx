---
title: 内蔵のログ解析ルール
tags:
  - Logs
  - Log management
  - UI and data
metaDescription: 'A list of all New Relic''s log parsing rules, which you can use to easily parse common log formats.'
translationType: machine
---

New Relic では、一般的なログフォーマットを内蔵のルールに従って解析することができるため、独自の解析ルールを作成する必要がありません。ここでは、ログの解析ルール、その [Grok](https://grokdebug.herokuapp.com/patterns# "リンクが新しいウィンドウで開きます。") パターン、そしてどのフィールドが解析されるかを紹介します。

* 組み込みのログ解析を有効にする[には、 `logtype`属性の追加](/docs/logs/ui-data/parsing#logtype)に関するドキュメントを参照してください。
* プログラムで解析ルールを管理するには、GraphQL形式のAPIであるNerdGraphを [api.newrelic.com/graphiql](https://api.newrelic.com/graphiql) でご利用いただけます。詳細については、 [NerdGraph チュートリアル](/docs/apis/nerdgraph/examples/nerdgraph-log-parsing-rules-tutorial) を参照して、解析ルールの作成、照会、削除を行ってください。

<CollapserGroup>
  <Collapser
    id="apache"
    title="アパッチ"
  >
    ソース： `logtype = 'apache'`

    Grok:

    ```grok
    %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent}
    ```

    **結果。**

    * `clientip`：クライアントのIPアドレス。
    * `verb`：HTTP動詞
    * `ident`：リクエストを行うクライアントのユーザーID
    * `response`：応答のHTTPステータスコード
    * `request`：作成中のURIとリクエスト
    * `httpversion`：リクエストのHTTPバージョン
    * `rawrequest`：データが投稿された場合の生のHTTPリクエスト
    * `bytes`：送信されたバイト数
    * `referrer`：HTTPリファラー
    * `agent`：クライアントのユーザーエージェント
  </Collapser>

  <Collapser
    id="apache_error"
    title="Apacheエラー"
  >
    ソース： `logtype = 'apache_error'`

    Grok:

    ```grok
    \[%{DATA:apache_error.timestamp}\] \[%{WORD:apache_error.source}:%{DATA:level}\] \[pid %{NUMBER:apache_error.pid}(:tid %{NUMBER:apache_error.tid})?\] (%{DATA:apache_error.sourcecode}\(%{NUMBER:apache_error.linenum}\): )?(?:\[client %{IPORHOST:apache_error.clientip}:%{POSINT:apache_error.port}\] ){0,1}%{GREEDYDATA:apache_error.message}
    ```

    ### 結果

    * `apache_error.timestamp`：ログステートメントのタイムスタンプ
    * `apache_error.source`：ソースモジュール
    * `level`：ログレベル
    * `apache_error.pid`：apache PID（プロセス識別子）
    * `apache_error.tid`：apache TID（スレッド識別子）
    * `apache_error.sourcecode`：apacheソースコード
    * `apache_error.linenum`：ソースコードの行番号
    * `apache_error.clientip`：クライアントのIPアドレス
    * `apache_error.port`：クライアントIPポート番号
    * `apache_error.message`：エラーメッセージ
  </Collapser>

  <Collapser
    id="application-load-balancer"
    title="アプリケーションロードバランサー"
  >
    ソース： `logtype = 'alb'`

    Grok:

    ```grok
    ^%{NOTSPACE:type} %{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:target_ip}:%{NOTSPACE:target_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:target_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:target_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} "%{DATA:request}" "%{DATA:user_agent}" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol} %{NOTSPACE:target_group_arn} "%{DATA:trace_id}" "%{NOTSPACE:domain_name}" "%{NOTSPACE:chosen_cert_arn}" %{NOTSPACE:matched_rule_priority} %{TIMESTAMP_ISO8601:request_creation_time} "%{NOTSPACE:actions_executed}" "%{NOTSPACE:redirect_url}" "%{NOTSPACE:error_reason}" (?:"|)%{DATA:target_port_list}(?:"|) (?:"|)%{DATA:target_status_code_list}(?:"|) "%{NOTSPACE:classification}" "%{NOTSPACE:classification_reason}"
    ```

    ### 結果

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            フィールド
          </th>

          <th>
            定義
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `type`
          </td>

          <td>
            リクエストまたはコネクションのタイプです。可能な値は

            * `http`：HTTP
            * `https`：HTTP over SSL / TLS
            * `h2`：SSL/TLSを介したHTTP/2
            * `ws`：WebSocket
            * `wss`：SSL/TLSを介したWebSocket
          </td>
        </tr>

        <tr>
          <td>
            `elb`
          </td>

          <td>
            ロードバランサーのリソースID。アクセスログエントリを解析する場合は、リソースIDにスラッシュ（ `/` ）を含めることができることに注意してください。
          </td>
        </tr>

        <tr>
          <td>
            `client`
          </td>

          <td>
            リクエストしたクライアントのIPアドレスとポート
          </td>
        </tr>

        <tr>
          <td>
            `target`
          </td>

          <td>
            このリクエストを処理したターゲットのIPアドレスとポート。

            * クライアントが完全なリクエストを送信しなかった場合、ロードバランサーはリクエストをターゲットにディスパッチできず、この値は`-`に設定されます。
            * ターゲットがLambda関数の場合、この値は`-`に設定されます。
            * リクエストがAWSWAFによってブロックされている場合、この値は`-`に設定され、 `elb_status_code`の値は`403`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `request_processing_time`
          </td>

          <td>
            ロードバランサーがリクエストを受信してからターゲットに送信するまでの経過時間の合計（秒単位、ミリ秒の精度）。

            * ロードバランサーがリクエストをターゲットにディスパッチできない場合、この値は`-1`に設定されます。これは、アイドルタイムアウトの前にターゲットが接続を閉じた場合、またはクライアントが不正な形式の要求を送信した場合に発生する可能性があります。
            * 登録されたターゲットがアイドルタイムアウトの前に応答しない場合、この値を`-1`に設定することもできます。
          </td>
        </tr>

        <tr>
          <td>
            `target_processing_time`
          </td>

          <td>
            ロードバランサーがターゲットにリクエストを送信してから、ターゲットがレスポンスヘッダーの送信を開始するまでの経過時間の合計（秒単位、ミリ秒の精度）。

            * ロードバランサーがリクエストをターゲットにディスパッチできない場合、この値は`-1`に設定されます。これは、アイドルタイムアウトの前にターゲットが接続を閉じた場合、またはクライアントが不正な形式の要求を送信した場合に発生する可能性があります。
            * 登録されたターゲットがアイドルタイムアウトの前に応答しない場合、この値を`-1`に設定することもできます。
          </td>
        </tr>

        <tr>
          <td>
            `response_processing_time`
          </td>

          <td>
            ロードバランサーがターゲットからレスポンスヘッダーを受信してから、クライアントへのレスポンスの送信を開始するまでに経過した時間の合計（秒単位、ミリ秒の精度）。ロードバランサーでのキューイング時間と、ロードバランサーからクライアントへの接続取得時間の両方が含まれます。

            ロードバランサーがターゲットにリクエストを送信できない場合、この値は`-1`に設定されます。これは、アイドルタイムアウトの前にターゲットが接続を閉じた場合、またはクライアントが不正な形式の要求を送信した場合に発生する可能性があります。
          </td>
        </tr>

        <tr>
          <td>
            `elb_status_code`
          </td>

          <td>
            ロードバランサーからのレスポンスのステータスコード
          </td>
        </tr>

        <tr>
          <td>
            `target_status_code`
          </td>

          <td>
            ターゲットからの応答のステータスコード。この値は、ターゲットへの接続が確立され、ターゲットが応答を送信した場合にのみ記録されます。それ以外の場合は、 `-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `received_bytes`
          </td>

          <td>
            クライアント（リクエスター）から受け取ったリクエストのサイズをバイト単位で表したもの。HTTPリクエストの場合、これにはヘッダーが含まれます。WebSocketの場合は、接続中のクライアントから受信したバイト数の合計です。
          </td>
        </tr>

        <tr>
          <td>
            `sent_bytes`
          </td>

          <td>
            クライアント（リクエスター）に送信されるレスポンスのサイズ（バイト）。HTTP リクエストの場合は、ヘッダーを含みます。WebSocket の場合は、接続中のクライアントに送信されたバイト数の合計です。
          </td>
        </tr>

        <tr>
          <td>
            `method`
          </td>

          <td>
            リクエストのHTTP動詞
          </td>
        </tr>

        <tr>
          <td>
            `uri`
          </td>

          <td>
            リクエストがターゲットとしていたURI
          </td>
        </tr>

        <tr>
          <td>
            `http_version`
          </td>

          <td>
            リクエストのHTTPバージョン番号
          </td>
        </tr>

        <tr>
          <td>
            `user_agent`
          </td>

          <td>
            二重引用符で囲まれた、リクエストを発信したクライアントを識別するUser-Agent文字列。この文字列は、1つまたは複数の製品識別子、製品/バージョンで構成されます。文字列の長さが8KBを超える場合は、切り捨てられます。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            SSL暗号。リスナーがHTTPSリスナーでない場合、この値は`-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            SSLプロトコル。リスナーがHTTPSリスナーでない場合、この値は`-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `target_group_arn`
          </td>

          <td>
            対象グループのAmazon Resource Name (ARN)
          </td>
        </tr>

        <tr>
          <td>
            `trace_id`
          </td>

          <td>
            二重引用符で囲まれた`X-Amzn-Trace-Id header`の内容
          </td>
        </tr>

        <tr>
          <td>
            `domain_name`
          </td>

          <td>
            TLSハンドシェイク中にクライアントによって提供されたSNIドメインで、二重引用符で囲まれています。クライアントがSNIをサポートしていない場合、またはドメインが証明書と一致せず、デフォルトの証明書がクライアントに提示される場合、この値は`-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `chosen_cert_arn`
          </td>

          <td>
            クライアントに提示する証明書のARNを二重引用符で囲んだもの。

            * セッションを再利用する場合は`session-reused`に設定してください。
            * リスナーがHTTPSリスナーでない場合は、 `-`に設定します。
          </td>
        </tr>

        <tr>
          <td>
            `matched_rule_priority`
          </td>

          <td>
            リクエストにマッチしたルールの優先度の値。

            * ルールが一致した場合、これは`1`から`50000`までの値です。
            * 一致するルールがなく、デフォルトのアクションが実行された場合、この値は`0`に設定されます。
            * ルールの評価中にエラーが発生した場合は、 `-1`に設定されます。
            * その他のエラーの場合は、 `-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `request_creation_time`
          </td>

          <td>
            ロードバランサーがクライアントからのリクエストを受信した時間（ISO 8601形式）。
          </td>
        </tr>

        <tr>
          <td>
            `actions_executed`
          </td>

          <td>
            リクエストの処理時に実行されるアクション。二重引用符で囲まれています。この値は、 `actions_taken`で説明されている値を含めることができるコンマ区切りのリストです。不正な形式のリクエストなど、アクションが実行されなかった場合、この値は`-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `redirect_url`
          </td>

          <td>
            二重引用符で囲まれた、HTTP応答のロケーションヘッダーのリダイレクトターゲットのURL。リダイレクトアクションが実行されなかった場合、この値は`-`に設定されます。
          </td>
        </tr>

        <tr>
          <td>
            `error_reason`
          </td>

          <td>
            二重引用符で囲まれたエラー理由コード。

            * リクエストが失敗した場合は、「エラー理由コード」に記載されているエラーコードのいずれかになります。
            * 実行されるアクションに認証アクションが含まれていない場合、またはターゲットがLambda関数でない場合、この値は`-`に設定されます。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="cloudfront"
    title="クラウドフロント"
  >
    **ソース：** `logtype = 'cloudfront-web'`

    **Grok:**

    ```
    ^%{NOTSPACE:date}%{SPACE}%{NOTSPACE:time}%{SPACE}%{NOTSPACE:x_edge_location}%{SPACE}%{NOTSPACE:sc_bytes}%{SPACE}%{NOTSPACE:c_ip}%{SPACE}%{NOTSPACE:cs_method}%{SPACE}%{NOTSPACE:cs_host}%{SPACE}%{NOTSPACE:cs_uri_stem}%{SPACE}%{NOTSPACE:sc_status}%{SPACE}%{NOTSPACE:cs_referer}%{SPACE}%{NOTSPACE:cs_user_agent}%{SPACE}%{NOTSPACE:cs_uri_query}%{SPACE}%{NOTSPACE:cs_Cookie}%{SPACE}%{NOTSPACE:x_edge_result_type}%{SPACE}%{NOTSPACE:x_edge_request_id}%{SPACE}%{NOTSPACE:x_host_header}%{SPACE}%{NOTSPACE:cs_protocol}%{SPACE}%{NOTSPACE:cs_bytes}%{SPACE}%{NOTSPACE:time_taken}%{SPACE}%{NOTSPACE:x_forwarded_for}%{SPACE}%{NOTSPACE:ssl_protocol}%{SPACE}%{NOTSPACE:ssl_cipher}%{SPACE}%{NOTSPACE:x_edge_response_result_type}%{SPACE}%{NOTSPACE:cs_protocol_version}%{SPACE}%{NOTSPACE:fle_status}%{SPACE}%{NOTSPACE:fle_encrypted_fields}%{SPACE}%{NOTSPACE:c_port}%{SPACE}%{NOTSPACE:time_to_first_byte}%{SPACE}%{NOTSPACE:x_edge_detailed_result_type}%{SPACE}%{NOTSPACE:sc_content_type}%{SPACE}%{NOTSPACE:sc_content_len}%{SPACE}%{NOTSPACE:sc_range_start}%{SPACE}%{NOTSPACE:sc_range_end}
    ```

    **結果。**

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            フィールド
          </th>

          <th>
            定義
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            リクエストを処理したエッジの場所。各エッジの位置は、3文字のコードと任意に割り当てられた番号によって識別されます。たとえば、 `DFW3` 。

            この3文字のコードは、通常、エッジの位置の近くにある空港の国際航空運送協会の空港コードに対応しています。(これらの略語は将来的に変更される可能性があります）。
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            ヘッダーを含む、リクエストに応答してCloudFrontがビューアに提供した合計バイト数。たとえば、 `1045619` 。 WebSocket接続の場合、これは接続を介してサーバーからクライアントに送信される合計バイト数です。
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            IPv4またはIPv6形式のいずれかで要求を行ったビューアのIPアドレス。ビューアがHTTPプロキシまたはロードバランサを使用してリクエストを送信した場合、 `c_ip`の値はプロキシまたはロードバランサのIPアドレスです。 `X-Forwarded-For`も参照してください。
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            HTTPリクエストメソッド： `DELETE` 、 `GET` 、 `HEAD` 、 `OPTIONS` 、 `PATCH` 、 `POST` 、または`PUT` 。
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            CloudFrontディストリビューションのドメイン名。たとえば、 `d111111abcdef8.cloudfront.net` 。
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            パスとオブジェクトを識別するURIの部分。たとえば、 `/images/cat.jpg` 。 URLとクエリ文字列の疑問符は含まれていません。
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            HTTPステータスコード。たとえば、 `200` 。ステータスコード`000`は、CloudFrontがリクエストに応答する前に、ビューアが接続を閉じた（たとえば、ブラウザタブを閉じた）ことを示します。 CloudFrontがレスポンスの送信を開始した後にビューアが接続を閉じると、ログには該当するHTTPステータスコードが含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            リクエストを発信したドメインの名前です。一般的なリファラーには、検索エンジン、あなたのオブジェクトに直接リンクしている他のウェブサイト、あなた自身のウェブサイトなどがあります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            リクエストのUser-Agentヘッダーの値です。User-Agentヘッダーは、リクエストを送信したデバイスやブラウザの種類、該当する場合はどの検索エンジンかなど、リクエストの送信元を特定するものです。
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            URIのクエリ文字列部分（存在する場合）。 URIにクエリ文字列が含まれていない場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            名前と値のペアと関連する属性を含む、リクエストのクッキーヘッダ。

            * クッキーのロギングを有効にすると、お客様がどのクッキーをオリジンに転送するかに関わらず、CloudFrontはすべてのリクエストでクッキーをロギングします。
            * リクエストにCookieヘッダーが含まれていない場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            最後のバイトがエッジロケーションを離れた後、CloudFrontがレスポンスをどのように分類するか。場合によっては、CloudFrontがレスポンスを送信する準備ができてから、CloudFrontがレスポンスの送信を終了するまでの間に、結果タイプが変更されることがあります。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            リクエストを一意に識別する暗号化された文字列。応答ヘッダーでは、これは`x-amz-cf-id`です。
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            視聴者がこのリクエストのHostヘッダーに含めた値です。これは、リクエストのドメイン名です。

            * オブジェクトのURLにCloudFrontのドメイン名を使用している場合、このフィールドにはそのドメイン名が含まれます。
            * オブジェクトURLで`http://example.com/logo.png`などの代替ドメイン名を使用している場合、このフィールドには`example.com`などの代替ドメイン名が含まれます。代替ドメイン名を使用するには、それらをディストリビューションに追加する必要があります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            ビューアがリクエストで指定したプロトコル： `http` 、 `https` 、 `ws` 、または`wss` 。
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            視聴者がリクエストに含めたデータのバイト数（ヘッダーを含む）です。WebSocket接続の場合は、その接続でクライアントからサーバーに送信されたバイト数の合計です。
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            CloudFrontエッジサーバーが視聴者のリクエストを受信してから、CloudFrontがレスポンスの最後のバイトをエッジサーバーの出力キューに書き込むまでの秒数（1000分の1秒単位、例えば0.002）をサーバー上で計測したものです。

            視聴者から見ると、ネットワークの遅延やTCPのバッファリングにより、完全なオブジェクトを取得するまでの総時間はこの値よりも長くなります。
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            ビューアがHTTPプロキシまたはロードバランサを使用してリクエストを送信した場合、フィールド5の`c_ip`の値はプロキシまたはロードバランサのIPアドレスです。その場合、このフィールドはリクエストを発信したビューアのIPアドレスです。

            このフィールドには、必要に応じてIPv4アドレスとIPv6アドレスが含まれます。ビューアがHTTPプロキシまたはロードバランサを使用しなかった場合、 `x_forwarded_for`の値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            フィールド17の`cs_protocol`が`https`の場合、このフィールドには、クライアントとCloudFrontがリクエストとレスポンスを送信するためにネゴシエートしたSSL/TLSプロトコルが含まれます。可能な値は次のとおりです。

            * SSLv3

            * TLSv1

            * TLSv1.1

            * TLSv1.2

              フィールド17の`cs_protocol`が`http`の場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            フィールド17の`cs_protocol`が`https`の場合、このフィールドには、クライアントとCloudFrontがリクエストとレスポンスを暗号化するためにネゴシエートしたSSL/TLS暗号が含まれます。可能な値は次のとおりです。

            * `ECDHE-RSA-AES128-GCM-SHA256`

            * `ECDHE-RSA-AES128-SHA256`

            * `ECDHE-RSA-AES128-SHA`

            * `ECDHE-RSA-AES256-GCM-SHA384`

            * `ECDHE-RSA-AES256-SHA384`

            * `ECDHE-RSA-AES256-SHA`

            * `AES128-GCM-SHA256`

            * `AES256-GCM-SHA384`

            * `AES128-SHA256`

            * `AES256-SHA`

            * `AES128-SHA`

            * `DES-CBC3-SHA`

            * `RC4-MD5`

              フィールド17の`cs_protocol`が`http`の場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            視聴者にレスポンスを返す直前に、CloudFrontがレスポンスをどのように分類したか。可能な値は以下の通りです。

            * `Hit`：CloudFrontは、エッジキャッシュからビューアーにオブジェクトを提供しました。
            * `RefreshHit`：CloudFrontはエッジキャッシュでオブジェクトを検出しましたが、有効期限が切れていたため、CloudFrontはオリジンに連絡して、キャッシュに最新バージョンのオブジェクトがあることを確認しました。
            * `Miss`：エッジキャッシュ内のオブジェクトがリクエストを満たせなかったため、CloudFrontはリクエストをオリジンサーバーに転送し、結果をビューアに返しました。
            * `LimitExceeded`：CloudFrontの制限を超えたため、リクエストは拒否されました。
            * `CapacityExceeded`：リクエスト時にエッジロケーションにオブジェクトを提供するのに十分な容量がなかったため、CloudFrontは`503`エラーを返しました。
            * `Error`：通常、これは、リクエストの結果、クライアントエラー（ `sc_status`は`4xx` ）またはサーバーエラー（ `sc_status`は`5xx` ）が発生したことを意味します。 `x_edge_result_type`の値が`Error`で、このフィールドの値が`Error`で**ない**場合、クライアントはダウンロードを完了する前に切断します。
            * `Redirect`：CloudFrontはHTTPからHTTPSにリダイレクトします。 `sc_status`が`403`で、コンテンツの地理的分散を制限するようにCloudFrontを設定した場合、リクエストは制限された場所から送信された可能性があります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            視聴者がリクエストで指定したHTTPバージョン。可能な値は以下の通りです。

            * `HTTP/0.9`
            * `HTTP/1.0`
            * `HTTP/1.1`
            * `HTTP/2.0`
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            ディストリビューションにフィールドレベルの暗号化が設定されている場合、このフィールドには、リクエストボディが正常に処理されたかどうかを示すコードが含まれます。

            フィールドレベルの暗号化が配布用に構成されていない場合、値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `fle-encrypted-fields`
          </td>

          <td>
            CloudFrontが暗号化してオリジンに転送したフィールドの数。 CloudFrontは、データを暗号化するときに処理されたリクエストをオリジンにストリーミングするため、 `fle-status`の値がエラーであっても`fle-encrypted-fields`は値を持つことができます。

            フィールドレベルの暗号化が配布用に構成されていない場合、 `fle-encrypted-fields`の値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            視聴者からのリクエストのポート番号。
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            リクエストを受信してからレスポンスの最初のバイトを書き込むまでの秒数で、サーバー上で計測されます。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            `x-edge-result-type`**が**`Error`でない場合、このフィールドには`x-edge-result-type`と同じ値が含まれます。 `x-edge-result-type`**が**`Error`の場合、このフィールドには特定のタイプのエラーが含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            レスポンスのHTTP Content-Typeヘッダーの値です。
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            レスポンスの HTTP Content-Length ヘッダの値です。
          </td>
        </tr>

        <tr>
          <td>
            `sc_range_start`
          </td>

          <td>
            レスポンスに HTTP Content-Range ヘッダーが含まれている場合、このフィールドにはレンジの開始値が含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            レスポンスに HTTP Content-Range ヘッダーが含まれている場合、このフィールドには range end の値が格納されます。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="elastic-load-balancer"
    title="弾性ロードバランサー"
  >
    ソース： `logtype = 'elb'`

    Grok:

    ```grok
    ^%{TIMESTAMP_ISO8601:time} %{NOTSPACE:elb} %{NOTSPACE:client_ip}:%{NOTSPACE:client_port} ((%{NOTSPACE:backend_ip}:%{NOTSPACE:backend_port})|-) %{NOTSPACE:request_processing_time} %{NOTSPACE:backend_processing_time} %{NOTSPACE:response_processing_time} %{NOTSPACE:elb_status_code} %{NOTSPACE:backend_status_code} %{NOTSPACE:received_bytes} %{NOTSPACE:sent_bytes} "%{DATA:request}" "%{DATA:user_agent}" %{NOTSPACE:ssl_cipher} %{NOTSPACE:ssl_protocol}
    ```

    ### 結果

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            フィールド
          </th>

          <th>
            定義
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `x_edge_location`
          </td>

          <td>
            リクエストを処理したエッジの場所。各エッジの位置は、3文字のコードと任意に割り当てられた番号によって識別されます。たとえば、 `DFW3` 。 3文字のコードは通常、エッジロケーションに近い空港の国際航空運送協会の空港コードに対応しています。 （これらの略語は将来変更される可能性があります。）
          </td>
        </tr>

        <tr>
          <td>
            `sc_bytes`
          </td>

          <td>
            ヘッダーを含む、リクエストに応答してCloudFrontがビューアに提供した合計バイト数。たとえば、 `1045619` 。 WebSocket接続の場合、これは接続を介してサーバーからクライアントに送信される合計バイト数です。
          </td>
        </tr>

        <tr>
          <td>
            `c_ip`
          </td>

          <td>
            リクエストを行ったビューアのIPアドレス。ビューアがHTTPプロキシまたはロードバランサを使用してリクエストを送信した場合、 `c_ip`の値はプロキシまたはロードバランサのIPアドレスです。
          </td>
        </tr>

        <tr>
          <td>
            `cs_method`
          </td>

          <td>
            HTTPリクエストメソッド： `DELETE` 、 `GET` 、 `HEAD` 、 `OPTIONS` 、 `PATCH` 、 `POST` 、または`PUT` 。
          </td>
        </tr>

        <tr>
          <td>
            `cs_host`
          </td>

          <td>
            CloudFrontディストリビューションのドメイン名。たとえば、 `d111111abcdef8.cloudfront.net` 。
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_stem`
          </td>

          <td>
            パスとオブジェクトを識別するURIの部分。たとえば、 `/images/cat.jpg` 。 URLおよびクエリ文字列の疑問符（ `?` ）はログに含まれません。
          </td>
        </tr>

        <tr>
          <td>
            `sc_status`
          </td>

          <td>
            HTTPステータスコード（たとえば、 `200` ）。ステータスコード`000`は、CloudFrontがリクエストに応答する前に、ビューアが接続を閉じた（たとえば、ブラウザタブを閉じた）ことを示します。

            CloudFrontがレスポンスの送信を開始した後にビューアーが接続を閉じた場合、ログには該当するHTTPステータスコードが含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `cs_referer`
          </td>

          <td>
            リクエストを発信したドメインの名前です。一般的なリファラーには、検索エンジン、あなたのオブジェクトに直接リンクしている他のWebサイト、あなた自身のWebサイトなどがあります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_user_agent`
          </td>

          <td>
            リクエストのUser-Agentヘッダーの値です。User-Agentヘッダーは、リクエストを送信したデバイスやブラウザの種類、該当する場合はどの検索エンジンかなど、リクエストの送信元を特定するものです。
          </td>
        </tr>

        <tr>
          <td>
            `cs_uri_query`
          </td>

          <td>
            URIのクエリ文字列部分（存在する場合）。 URIにクエリ文字列が含まれていない場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `cs_cookie`
          </td>

          <td>
            名前と値のペアと関連する属性を含む、リクエストのクッキーヘッダ。

            * クッキーのロギングを有効にすると、お客様がどのクッキーをオリジンに転送するかにかかわらず、CloudFrontはすべてのリクエストでクッキーをロギングします。
            * リクエストにCookieヘッダーが含まれていない場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_result_type`
          </td>

          <td>
            最後のバイトがエッジロケーションを離れた後、CloudFrontがレスポンスをどのように分類するか。場合によっては、CloudFrontがレスポンスを送信する準備ができてから、CloudFrontがレスポンスの送信を終了するまでの間に、結果タイプが変更されることがあります。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_request_id`
          </td>

          <td>
            リクエストを一意に識別する暗号化された文字列。応答ヘッダーでは、これは`x-amz-cf-id`です。
          </td>
        </tr>

        <tr>
          <td>
            `x_host_header`
          </td>

          <td>
            視聴者がこのリクエストのHostヘッダーに含めた値です。これは、リクエストのドメイン名です。

            * オブジェクトのURLにCloudFrontのドメイン名を使用している場合、このフィールドにはそのドメイン名が含まれます。
            * オブジェクトURLで`[http://example.com/logo.png`などの代替ドメイン名を使用している場合、このフィールドには`example.com`などの代替ドメイン名が含まれます。代替ドメイン名を使用するには、それらをディストリビューションに追加する必要があります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol`
          </td>

          <td>
            ビューアがリクエストで指定したプロトコル： `http` 、 `https` 、 `ws` 、または`wss` 。
          </td>
        </tr>

        <tr>
          <td>
            `cs_bytes`
          </td>

          <td>
            視聴者がリクエストに含めたデータのバイト数（ヘッダーを含む）です。WebSocket接続の場合は、その接続でクライアントからサーバーに送信されたバイト数の合計です。
          </td>
        </tr>

        <tr>
          <td>
            `time_taken`
          </td>

          <td>
            CloudFrontエッジサーバーが視聴者のリクエストを受信してから、CloudFrontがレスポンスの最後のバイトをエッジサーバーの出力キューに書き込むまでの秒数（1000分の1秒単位、例えば0.002）をサーバー上で計測したものです。

            視聴者から見ると、ネットワークの遅延やTCPのバッファリングにより、完全なオブジェクトを取得するまでの総時間はこの値よりも長くなります。
          </td>
        </tr>

        <tr>
          <td>
            `x_forwarded_for`
          </td>

          <td>
            ビューアがHTTPプロキシまたはロードバランサを使用してリクエストを送信した場合、フィールド5の`c_ip`の値はプロキシまたはロードバランサのIPアドレスです。その場合、このフィールドはリクエストを発信したビューアのIPアドレスです。このフィールドには、必要に応じてIPv4アドレスとIPv6アドレスが含まれます。

            ビューアがHTTPプロキシまたはロードバランサを使用しなかった場合、 `x_forwarded_for`の値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_protocol`
          </td>

          <td>
            フィールド17の`cs_protocol`が`https`の場合、このフィールドには、クライアントとCloudFrontがリクエストとレスポンスを送信するためにネゴシエートしたSSL/TLSプロトコルが含まれます。可能な値は次のとおりです。

            * SSLv3
            * TLSv1
            * TLSv1.1
            * TLSv1.2フィールド17の`cs_protocol`が`http`の場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `ssl_cipher`
          </td>

          <td>
            フィールド17の`cs_protocol`が`https`の場合、このフィールドには、クライアントとCloudFrontがリクエストとレスポンスを暗号化するためにネゴシエートしたSSL/TLS暗号が含まれます。可能な値は次のとおりです。

            * `ECDHE-RSA-AES128-GCM-SHA256`

            * `ECDHE-RSA-AES128-SHA256`

            * `ECDHE-RSA-AES128-SHA`

            * `ECDHE-RSA-AES256-GCM-SHA384`

            * `ECDHE-RSA-AES256-SHA384`

            * `ECDHE-RSA-AES256-SHA`

            * `AES128-GCM-SHA256`

            * `AES256-GCM-SHA384`

            * `AES128-SHA256`

            * `AES256-SHA`

            * `AES128-SHA`

            * `DES-CBC3-SHA`

            * `RC4-MD5`

              `cs_protocol`が`http`の場合、このフィールドの値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_response_result_type`
          </td>

          <td>
            視聴者にレスポンスを返す直前に、CloudFrontがレスポンスをどのように分類したか。可能な値は以下の通りです。

            * `Hit`：CloudFrontは、エッジキャッシュからビューアーにオブジェクトを提供しました。
            * `RefreshHit`：CloudFrontはエッジキャッシュでオブジェクトを検出しましたが、有効期限が切れていたため、CloudFrontはオリジンに連絡して、キャッシュに最新バージョンのオブジェクトがあることを確認しました。
            * `Miss`：エッジキャッシュ内のオブジェクトがリクエストを満たせなかったため、CloudFrontはリクエストをオリジンサーバーに転送し、結果をビューアに返しました。
            * `LimitExceeded`：CloudFrontの制限を超えたため、リクエストは拒否されました。
            * `CapacityExceeded`：リクエスト時にエッジロケーションにオブジェクトを提供するのに十分な容量がなかったため、CloudFrontは`503`エラーを返しました。
            * `Error`：通常、これは、リクエストの結果、クライアントエラー（ `sc_status`は`4xx` ）またはサーバーエラー（ `sc_status`は`5xx` ）が発生したことを意味します。 `x_edge_result_type`の値が`Error`で、このフィールドの値が`Error`で**ない**場合、クライアントはダウンロードを完了する前に切断します。
            * `Redirect`：CloudFrontはHTTPからHTTPSにリダイレクトします。 `sc_status`が`403`で、コンテンツの地理的分散を制限するようにCloudFrontを設定した場合、リクエストは制限された場所から送信された可能性があります。
          </td>
        </tr>

        <tr>
          <td>
            `cs_protocol_version`
          </td>

          <td>
            視聴者がリクエストで指定したHTTPバージョン。可能な値は以下の通りです。

            * `HTTP/0.9`
            * `HTTP/1.0`
            * `HTTP/1.1`
            * `HTTP/2.0`
          </td>
        </tr>

        <tr>
          <td>
            `fle_status`
          </td>

          <td>
            フィールドレベルの暗号化がディストリビューションに設定されている場合、このフィールドには、リクエスト本文が正常に処理されたかどうかを示すコードが含まれます。フィールドレベルの暗号化が配布用に構成されていない場合、このフィールドの値はハイフン（ `-` ）です。

            CloudFrontがリクエスト本文を正常に処理し、指定されたフィールドの値を暗号化し、リクエストをオリジンに転送すると、このフィールドの値は`Processed`になります。この場合でも、 `x_edge_result_type`の値はクライアント側またはサーバー側のエラーを示している可能性があります。

            リクエストがフィールドレベルの暗号化制限を超えた場合、 `fle-status`には次のエラーコードのいずれかが含まれ、CloudFrontはHTTPステータスコード`400`をビューアに返します。
          </td>
        </tr>

        <tr>
          <td>
            `fle-encrypted-fields`
          </td>

          <td>
            CloudFrontが暗号化してオリジンに転送したフィールドの数。 CloudFrontは、データを暗号化するときに処理されたリクエストをオリジンにストリーミングするため、 `fle_status`の値がエラーであっても`fle_encrypted_fields`は値を持つことができます。

            フィールドレベルの暗号化が配布用に構成されていない場合、 `fle_encrypted_fields`の値はハイフン（ `-` ）です。
          </td>
        </tr>

        <tr>
          <td>
            `c_port`
          </td>

          <td>
            視聴者からのリクエストのポート番号。
          </td>
        </tr>

        <tr>
          <td>
            `time_to_first_byte`
          </td>

          <td>
            リクエストを受信してからレスポンスの最初のバイトを書き込むまでの秒数で、サーバー上で計測されます。
          </td>
        </tr>

        <tr>
          <td>
            `x_edge_detailed_result_type`
          </td>

          <td>
            `x_edge_result_type`**が**`Error`でない場合、このフィールドには`x_edge_result_type`と同じ値が含まれます。 `x_edge_result_type`**が**`Error`の場合、このフィールドには特定のタイプのエラーが含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_type`
          </td>

          <td>
            レスポンスのHTTP Content-Typeヘッダーの値です。
          </td>
        </tr>

        <tr>
          <td>
            `sc_content_len`
          </td>

          <td>
            レスポンスの HTTP Content-Length ヘッダの値です。
          </td>
        </tr>

        <tr>
          <td>
            `sc_range_start`
          </td>

          <td>
            レスポンスに HTTP Content-Range ヘッダーが含まれている場合、このフィールドにはレンジの開始値が含まれます。
          </td>
        </tr>

        <tr>
          <td>
            `sc-range-end`
          </td>

          <td>
            レスポンスに HTTP Content-Range ヘッダーが含まれている場合、このフィールドには range end の値が格納されます。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="haproxy"
    title="HAProxy"
  >
    ソース： `logtype = 'haproxy_http'`

    Grok:

    ```grok
    %{HOSTPORT:client} \\[%{NOTSPACE:haproxy_timestamp}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{NUMBER:time_queue}/%{NUMBER:time_backend_connect}/%{NUMBER:time_duration} %{NUMBER:bytes_read} %{NOTSPACE:termination_state} %{NUMBER:actconn}/%{NUMBER:feconn}/%{NUMBER:beconn}/%{NUMBER:srvconn}/%{NUMBER:retries} %{NUMBER:srv_queue}/%{NUMBER:backend_queue}
    ```

    ```
    %{HOSTPORT:client} \\[%{NOTSPACE:haproxy_timestamp}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{NUMBER:time_client_req}/%{NUMBER:time_queue}/%{NUMBER:time_backend_connect}/%{NUMBER:time_server_response}/%{NUMBER:time_duration} %{NUMBER:status_code} %{NUMBER:bytes_read} %{NOTSPACE:captured_request_cookie} %{NOTSPACE:captured_response_cookie} %{NOTSPACE:termination_state_with_cookie_status} %{NUMBER:actconn}/%{NUMBER:feconn}/%{NUMBER:beconn}/%{NUMBER:srvconn}/%{NUMBER:retries} %{NUMBER:srv_queue}/%{NUMBER:backend_queue}?( \\\"%{GREEDYDATA:full_http_request}\\\")?( %{NOTSPACE:captured_response_headers})?
    ```

    ### 結果

    * `client`：このリクエストの送信元IP/ポート
    * `haproxy_timestamp`：このリクエストが受け入れられたときのタイムスタンプ
    * `frontend_name`：このリクエストで使用されたフロントエンドの名前
    * `backend_name`：このリクエストで使用されたバックエンドの名前
    * `server_name`：このリクエストで使用されたバックエンドグループのサーバー名
    * `time_client_req`：クライアントからの完全な要求を待機する時間（ミリ秒）
    * `time_queue`：キューでの待機時間（ミリ秒）
    * `time_backend_connect`：宛先サーバーへの接続を確立する時間（ms）
    * `time_server_response`：宛先サーバーが応答を送信する時間（ミリ秒）
    * `time_duration`：HAProxyでアクティブなリクエストの合計時間（ミリ秒）
    * `status_code`：HTTP応答コード
    * `bytes_read`：このリクエストで読み取られた合計バイト数
    * `captured_request_cookie`：リクエストからキャプチャされたCookie
    * `captured_response_cookie`：応答からキャプチャされたCookie
    * `termination_state`：切断時のセッション状態
    * `termination_state_with_cookie_status`：切断時のCookieステータスを含むセッション状態
    * `actconn`：アクティブな接続
    * `feconn`：フロントエンド接続
    * `beconn`：バックエンド接続
    * `srvconn`：サーバー接続
    * `retries`：再試行
    * `srv_queue`：サーバーキューサイズ
    * `backend_queue`：バックエンドキューのサイズ
    * `full_http_request`：完全なHTTPリクエストライン
    * `captured_response_headers`：応答からキャプチャされたヘッダー
  </Collapser>

  <Collapser
    id="ktranslate-health"
    title="KTranslate Health"
  >
    ソース： `logtype = 'ktranslate-health'`

    Grok:

    ```grok
    %{NOTSPACE:timestamp} ktranslate(/)?(%{GREEDYDATA:container_service})? \[%{NOTSPACE:severity}] %{GREEDYDATA:message}
    ```

    ### 結果

    * `timestamp`：ログの時間
    * `container_service`：ktranslateでコンテナを区別するために使用される一意の識別子。これは、Dockerの実行時にオプションの`--service_name`フラグを使用して設定されます
    * `severity`：ログ行の重大度
    * `message`：メッセージフィールドには、イベントに関する情報を提供する自由形式のメッセージが含まれます
  </Collapser>

  <Collapser
    id="iis"
    title="マイクロソフトIIS"
  >
    ソース： `logtype = 'iis_w3c'`

    Grok:

    ```grok
    %{TIMESTAMP_ISO8601:log_timestamp} %{NOTSPACE:server_ip} %{WORD:method} %{NOTSPACE:uri} %{NOTSPACE:uri_query} %{NOTSPACE:server_port} %{NOTSPACE:username} %{NOTSPACE:client_ip} %{NOTSPACE:user_agent} %{NOTSPACE:referer} %{NOTSPACE:status} %{NOTSPACE:substatus} %{NOTSPACE:win32_status} %{NOTSPACE:time_taken}
    ```

    <Callout variant="important">
      IISでは、いくつかの<a href="https://docs.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms524877(v=vs.90)">構成オプション</a>を使用できます。デフォルト以外のオプションを構成した場合、Grokパターンはログを解析しません。この場合、 <a href="https://docs.newrelic.com/docs/logs/ui-data/parsing/#custom-parsing">カスタム解析</a>を使用することをお勧めします。
    </Callout>
  </Collapser>

  <Collapser
    id="mongodb"
    title="Mongodb"
  >
    ソース： `logtype = 'mongodb'`

    Grok:

    ```grok
    %{TIMESTAMP_ISO8601:mongodb.timestamp} %{WORD:mongodb.severity} %{WORD:mongodb.component} *\[%{WORD:mongodb.context}\] %{GREEDYDATA:mongodb.message}
    ```

    ### 結果

    * `mongodb.timestamp`：ログステートメントのタイムスタンプ
    * `mongodb.severity`：ログステートメントの重大度レベル（F =致命的、E =エラー、W =警告、I =情報、D1-5 =デバッグ）
    * `mongodb.component`：ログステートメントを発行するスレッドのカテゴリ
    * `mongodb.context`：ログステートメントを発行するスレッドの名前
    * `mongodb.message`：生のmongodbメッセージ
  </Collapser>

  <Collapser
    id="monit"
    title="Monit"
  >
    ソース： `logtype = 'monit'`

    Grok:

    ```grok
    \\[%{NOTSPACE:tz} %{SYSLOGTIMESTAMP:nr_timestamp}\\] %{WORD:state}%{SPACE}: %{GREEDYDATA:message}
    ```

    ### 結果

    * `state`：ログ行の重大度
    * `message`： メッセージ
  </Collapser>

  <Collapser
    id="mysql-error"
    title="MySQLエラー"
  >
    ソース： `logtype = 'mysql-error'`

    Grok:

    ```grok
    \\[%{WORD:log_level}\\]
    ```

    ### 結果

    * `log_level`：ログ行の重大度
  </Collapser>

  <Collapser
    id="nginx"
    title="NGINX"
  >
    ソース： `logtype = 'nginx'`

    Grok:

    ```grok
    %{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer} %{QS:agent}
    ```

    ### 結果

    * `clientip`：クライアントのIPアドレス
    * `verb`：HTTP動詞
    * `ident`：リクエストを行うクライアントのユーザーID
    * `response`：応答のHTTPステータスコード
    * `request`：作成中のURIとリクエスト
    * `httpversion`：リクエストのHTTPバージョン
    * `rawrequest`：データが投稿された場合の生のHTTPリクエスト
    * `bytes`：送信されたバイト数
    * `referrer`：HTTPリファラー
    * `agent`：クライアントのユーザーエージェント
  </Collapser>

  <Collapser
    id="nginx-error"
    title="NGINXエラー"
  >
    ソース： `logtype = 'nginx-error'`

    Grok:

    ```grok
    ^(?<timestamp>%{YEAR:year}[./-]%{MONTHNUM:month}[./-]%{MONTHDAY:day}[- ]%{TIME:time}) \\[%{LOGLEVEL:severity}\\] %{POSINT:pid}#%{NUMBER}: %{GREEDYDATA:errormessage}(?:, client: (?<client>%{IP:clientip}|%{HOSTNAME:hostname}))(?:, server: %{IPORHOSTORUNDERSCORE:server})(?:, request: %{QS:request})?(?:, upstream: \"%{URI:upstream}\")?(?:, host: %{QS:host})?(?:, referrer: \"%{URI:referrer}\")?$
    ```

    ### 結果

    * `severity`：ログ行の重大度
    * `pid`：サーバープロセスID
    * `errormessage`：エラーメッセージ
    * `clientip`：呼び出し元クライアントのIPアドレス
    * `server`：サーバーのIPアドレス
    * `request`：完全なリクエスト
    * `upstream`：アップストリームURI
    * `host`：サーバーのホスト名
    * `referrer`：HTTPリファラー
  </Collapser>

  <Collapser
    id="rabbitmq"
    title="ラビットエムキュー"
  >
    ソース： `logtype = 'rabbitmq'`

    Grok

    ```grok
    %{TIMESTAMP_ISO8601:rabbitmq.timestamp} \[%{LOGLEVEL:rabbitmq.log.level}\] \<%{DATA:rabbitmq.pid}\> %{GREEDYDATA:rabbitmq.message}
    ```

    ### 結果

    * `redistimestamp`：ログのタイムスタンプ
    * `rabbitmq.log.level`：メッセージのログレベル（デバッグ、情報、警告、エラー、クリティカル、なし）
    * `rabbitmq.pid`：ログ行のプロセスID
    * `rabbitmq.message`：rabbitmqエラーメッセージ
  </Collapser>

  <Collapser
    id="redis"
    title="Redis"
  >
    ソース： `logtype = 'redis'`

    Grok:

    ```grok
    %{POSINT:redis.pid}:%{NOTSPACE:redis.role} (?<redistimestamp>[\d-]+ [a-zA-Z]+ [\d]+ [\d:]+.[\d]{3}) %{NOTSPACE:redis.log.level} %{GREEDYDATA:redis.message}
    ```

    ### 結果

    * `redis.pid`：ログ行のプロセスID
    * `redis.role`：インスタンスのロール（Xセンチネル、C RDB / AOF書き込み子、Sスレーブ、Mマスター）
    * `redistimestamp`：ログのタイムスタンプ
    * `redis.log.level`：メッセージのログレベル（。debug、-verbose、\* Notice、＃warning）
    * `redis.message`：redisエラーメッセージ
  </Collapser>

  <Collapser
    id="route53"
    title="ルート53"
  >
    ソース： `logtype = 'route-53'`

    Grok:

    ```grok
    %{NUMBER:log_format_version} %{TIMESTAMP_ISO8601} %{WORD:zone_id} %{IPORHOST:query} %{WORD:query_type} %{WORD:response_code} %{WORD:protocol} %{WORD:edge_location} %{IP:resolver_ip} %{GREEDYDATA:edns_client_subnet}
    ```

    ### 結果

    * `log_format_version`：ログのバージョン管理された形式。
    * `zone_id`：このログのすべてのDNSクエリに関連付けられているホストゾーンのID。
    * `query`：リクエストで指定されたドメインまたはサブドメイン。
    * `query_type`：リクエストで指定されたDNSレコードタイプ、または`ANY`のいずれか。
    * `response_code`：DNSクエリに応答してRoute53が返したDNS応答コード。
    * `protocol`：クエリの送信に使用されたプロトコル（TCPまたはUDP）。
    * `edge_location`：クエリに応答したRoute53エッジの場所。各エッジの位置は、3文字のコードと任意の番号で識別されます。たとえば、 `DFW3` 。 3文字のコードは通常、エッジロケーションに近い空港の国際航空運送協会の空港コードに対応しています。 （これらの略語は将来変更される可能性があります。）
    * `resolver_ip`：Route53にリクエストを送信したDNSリゾルバーのIPアドレス。
    * `edns_client_subnet`：DNSリゾルバーから利用可能な場合、要求の発信元のクライアントの部分的なIPアドレス。
  </Collapser>

  <Collapser
    id="syslog-rfc5424"
    title="シスログ RFC-5424"
  >
    ソース： `logtype = 'syslog-rfc5424'`

    Grok:

    ```grok
    <%{NONNEGINT:pri}>%{NONNEGINT:version} +(?:%{TIMESTAMP_ISO8601:log.timestamp}|-) +(?:%{HOSTNAME:hostname}|-) +(?:\\-|%{NOTSPACE:app.name}) +(?:\\-|%{NOTSPACE:procid}) (?:\\-|%{NOTSPACE:msgid}) +(?:\[%{DATA:structured.data}\]|-|) +%{GREEDYDATA:message}
    ```

    ### 結果

    * `pri`：優先度は、メッセージ機能と重大度の両方を表します。

    * `version`：Syslogプロトコルバージョン。

    * `log.timestamp`：元のタイムスタンプ。

    * `hostname`：最初にSyslogメッセージを送信したマシン。

    * `app.name`：メッセージを発信したデバイスまたはアプリケーション。

    * `procid`：Syslogシステムに関連付けられているプロセス名またはプロセスID。

    * `msgid`：メッセージのタイプを識別します。

    * `structured.data`：構造化データ文字列値。

    * `sd.<var>sd-id</var>.<var>sd-param-name</var>`： `structured.data`コンテンツも、事前定義された命名規則に従って個別の属性に解析されます： `sd.<var>sd-id</var>.<var>sd-param-name</var>` 。以下の構造化データ解析の例を参照してください。

    * `message`：イベントに関する情報を提供する自由形式のメッセージ。

      #### 構造化データのパーシング例

      構造化データ`[example one="1" two="2"]`は、次の2つの異なる属性に解析されます。

      ```
      sd.example.one: "1"
      sd.example.two: "2"
      ```

      同じ構造化データブロックに重複するパラメータ名が含まれている場合は、属性名にインデックスベースのサフィックスも追加されます。たとえば、構造化データ`[example number="1" number="2"]`は次のように解析されます。

      ```
      sd.example.number.0: "1"
      sd.example.number.1: "2"
      ```

      エンタープライズ番号が割り当てられた構造化データの場合、追加の属性も解析されます。たとえば、構造化データ`[example@123 number="1"]`は次のように解析されます。

      ```
      sd.example.enterprise.number: 123
      sd.example.number: "1"
      ```
  </Collapser>
</CollapserGroup>