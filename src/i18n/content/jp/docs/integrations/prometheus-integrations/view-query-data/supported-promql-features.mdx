---
title: サポート対象のPromQL機能
tags:
  - Integrations
  - Prometheus integrations
  - View and query data
---

New RelicはPromQLスタイルのクエリをサポートしています。また、クエリビルダーは、PromQL構文クエリを最も近似したNRQLクエリに変換するPromQLスタイルのクエリモードを備えています。Although the method of approximation means that a handful of edge cases are not fully supported, it provides coverage for an overwhelming majority of queries, supporting over 99.5% of queries across the 7.8 million top Grafana dashboard downloads.

PromQLクエリの使用方法、および標準の PromQL と PromQL に類似したクエリ言語の違いについて学習してください。

<Callout variant="important">
  Prometheusのクエリと演算子についての一般的な情報に関しては、[Prometheus.io](https://prometheus.io/docs/prometheus/latest/querying/operators/)ドキュメントをご覧ください。
</Callout>

## サポートされている機能 [#features]

当社は、次の集計/算術/数学/率様関数をサポートしています。PrometheusとPromQLのサポートを引き続き拡張する中で、リストは更新されます。

<CollapserGroup>
  <Collapser
    id=""
    title="集計演算子と関数"
  >
    * 集計演算子：

      * [`avg()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`count()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`min()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`max()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`quantile()`](https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`stddev()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * `stdvar()`
      * [`sum()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
      * [`topk()`](http://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)

      集計関数：

      * `histogram_quantile()`
    * `<aggregation>_over_time()` 関数:

      * [`avg_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`count_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`min_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`max_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`quantile_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`stdev_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`stvar_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
      * [`sum_over_time`](https://prometheus.io/docs/prometheus/latest/querying/functions/#aggregation_over_time)
  </Collapser>

  <Collapser
    id=""
    title="算術バイナリー演算子"
  >
    * [`+`（足し算）](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`-`（引き算）](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`*`（掛け算）](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`/`（割り算）](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`%`（パーセント）](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
    * [`^`（べき乗）](https://prometheus.io/docs/prometheus/latest/querying/operators/#arithmetic-binary-operators)
  </Collapser>

  <Collapser title="論理演算子">
    * [`and`](https://prometheus.io/docs/prometheus/latest/querying/operators/#logical-set-binary-operators)
    * [`or`](https://prometheus.io/docs/prometheus/latest/querying/operators/#logical-set-binary-operators)
  </Collapser>

  <Collapser
    id=""
    title="日付/時間関数"
  >
    * `day_of_month()`
    * `day_of_week()`
    * [`days_in_month()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#days_in_month)
    * `hour()`
    * `minute()`
    * `month()`
    * `time()`
    * `timestamp()`
    * `year()`
  </Collapser>

  <Collapser
    id=""
    title="数学関数"
  >
    * [`abs()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#abs)
    * [`ceil()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#ceil)
    * [`clamp_max()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#clamp_max)
    * [`clamp_min()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#clamp_min)
    * [`exp()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#exp)
    * [`floor()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#floor)
    * [`ln()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#ln)
    * [`log10()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#log10)
    * [`log2()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#log2)
    * [`round()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#round)
    * [`sqrt()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#sqrt)
  </Collapser>

  <Collapser
    id=""
    title="率様関数"
  >
    * [`delta()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#delta)
    * [`deriv()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#deriv)
    * [`idelta()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#idelta)
    * [`increase()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#increase)
    * [`irate()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#irate)
    * [`rate()`](https://prometheus.io/docs/prometheus/latest/querying/functions/#rate)
  </Collapser>

  <Collapser title="予測関数">
    * `predict_linear`
  </Collapser>

  <Collapser
    id=""
    title="時系列セレクター"
  >
    当社は、次のものを含むPromQL時系列セレクターをサポートしています。

    * [instant vectorセレクター](https://prometheus.io/docs/prometheus/latest/querying/basics/#instant-vector-selectors)
    * [range seriesセレクター](https://prometheus.io/docs/prometheus/latest/querying/basics/#range-vector-selectors)
    * [`オフセット`修飾](https://prometheus.io/docs/prometheus/latest/querying/basics/#offset-modifier)

    <Callout variant="important">
      クエリのすべてのベクターのオフセット値が同じ場合、当社は`オフセット`クエリしかサポートしません。
    </Callout>
  </Collapser>
</CollapserGroup>

## PromQLのトラブルシューティング [#troubleshooting]

このセクションでは、PromQLとPromQLスタイルクエリの動作の違いと、この違いにどのように対処するかについて説明します。This is particularly relevant if you want to use advanced queries and our [PromQL-style mode](/docs/query-your-data/explore-query-data/chart-builder/use-advanced-promql-mode-specify-data) in the query builder.

### メトリックのタイプ [#metric-types]

Prometheusの推奨では、ゲージではdelta()のような関数のみを、またカウンターではrate()やincrease()などその他の関数のみを使用するよう指摘していますが、Prometheusでのクエリは、この指示に従わなくても大半の場合に機能します。

ただし、NRDBはPromQLスタイルの集計カウンターを`delta`カウンターに変換するため、当社の実装では間違ったデータタイプでこうした関数を使用できず、異なる/正しくない答えが生じます。

このため、PromQLスタイルのクエリで作業を行う場合、Prometheusのこうした推奨に従わない場合でも、すべてのPrometheusの推奨に従うようにしてください。

### 制限 [#limits]

* すべてのユーザーについてシステムの安定性とパフォーマンスを確保するため、当社はどのクエリを実行できるかについて制限を設けています。すべての場合で、範囲クエリで366段階の制限を施行します。また、デフォルトで、クエリから100の時系列のみを返すようになっています。
* 数を増やす（または減らす）場合、クエリに明示的に`topk()` を追加する必要があります。（PromQLスタイルのクエリでの`topk()`実装は、Prometheusの実装とは異なることにご注意ください。）
* 当社では、クエリが使用できる合計メモリを制限しています。つまり、多数の時間ステップや多数の時系列のリクエストは、特に、単純な算術集計より計算に非常に多くのメモリを必要とする一意の`count`や`quantile`のような集計と組み合わされる場合に、却下される場合があります。

### Range vectorセレクター（スライディングウィンドウおよび平滑化動作） [#range-vector]

We provide support for sliding window timeseries aggregations. For more information, see our [NRQL syntax, clauses, and functions resource](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions#slide-by) and our [sliding windows deep dive](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows).

For information on translating between NRQL and our PromQL-style language, see [Translate PromQL queries to NRQL](/docs/integrations/prometheus-integrations/view-query-data/translate-promql-queries-nrql).

### Query range and data scraping intervals [#query-range]

* The range of your query in PromQL must be larger than the duration of the step size of the query to avoid the error "`TIMESERIES` bucket size is larger than the current time window".
* We inspect data up to one minute old when servicing instant queries. If your scrape interval is greater than 1 minute, some queries may result in **No data found**. Avoid this by sending data at least once per minute.
* If the timeseries unit for your NRQL query is less than the scrape interval for your application, some periods will lack data, and the resulting graph may be jagged or contain peaks and valleys. In general, set the step size to your scrape interval, or higher.

## その他のヘルプ [#more_help]

さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください：

* [Explorers Hub](https://discuss.newrelic.com/)を参照して、コミュニティから支援を受け、ディスカッションに参加してください。
* [当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます](/docs/using-new-relic/welcome-new-relic/get-started/find-help-use-support-portal)。
* Linux、Windows、およびmacOSのトラブルシューティングツールである[New Relic Diagnosticsを実行します](/docs/using-new-relic/cross-product-functions/troubleshooting/new-relic-diagnostics)。
* New Relicの[データセキュリティ](/docs/security)と[ライセンス](/docs/licenses)ドキュメントを見直してください。
