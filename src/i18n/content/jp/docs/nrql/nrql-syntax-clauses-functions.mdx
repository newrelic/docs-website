---
title: NRQLリファレンス
tags:
  - Query your data
  - 'NRQL: New Relic Query Language'
  - Get started
metaDescription: 'A detailed reference list of clauses and functions in NRQL, the New Relic query language.'
freshnessValidatedDate: never
translationType: human
---

優れた[NRQL](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language)クエリを記述するには、当社のさまざまなNRQL句と関数がどのように機能するかを理解すると有益です。このドキュメントには、NRQL句と関数の定義、およびその使用方法の例が記載されています。

基本的なNRQL構文ルールをお探しですか？ [NRQLの使用方法](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-how-nrql-works)を参照してください。チュートリアルについては、[NRQL入門チュートリアル](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-tutorial)を参照してください。

## クエリの構成要素 [#clauses]

[基本的なNRQL構文ドキュメント](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-how-nrql-works/#syntax)に記載されているように、すべてのNRQLクエリには`SELECT`句と`FROM`句が含まれています（他の句はすべてオプション）。以下の句の定義には、NRQLクエリの例も含まれます。

### DELETEキーワード [#delete]

New Relicクエリ言語（NRQL）の`DELETE`キーワードは、Pipeline Control内の特定のデータと属性を削除するために使用されます。これは、New Relicデータベース（NRDB）に取り込まれるデータを管理するのに役立ちます。

`DELETE`キーワードは、削除するデータまたは属性を指定するためにNRQLクエリに適用されます。以下に例をいくつか挙げます。

以下にいくつか例を挙げます。

* **特定のメトリクスの削除：**

  ```sql
  DELETE FROM Metric 
  WHERE metricName = 'newrelic.goldenmetrics.infra.kubernetes_pod.podScheduled'
  ```

  * 指定された名前のメトリクスを削除します。

* **特定のスパンの削除：**

  ```sql
  DELETE FROM Span WHERE appName = 'external-usage-consumer (test-odd-wire)'
  ```

  * 指定されたアプリケーションに関連付けられたスパンを削除します。

* **特定のエージェント更新の削除：**

  ```sql
  DELETE FROM AgentUpdate WHERE a = 'b'
  ```

  * 属性`a`が`b`に等しいエージェントの更新を削除します。

### 必要な句 [#required]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="state-select"
    title={<>必須：<InlineCode>
      SELECT
    </InlineCode>文</>
    }
  >
    ```sql
    SELECT attribute ...
    ```

    ```sql
    SELECT function(attribute) ...
    ```

    `SELECT`は、[属性](/docs/using-new-relic/welcome-new-relic/get-started/glossary/#attribute)または[関数](#functions)を指定することによって、データ型のどの部分をクエリするかを指定します。その後、カンマ区切りの1つ以上の引数が続きます。各引数では、以下を実行できます。

    * ワイルドカードとして`*`を使用することで、利用可能なすべての属性値を取得。例：`SELECT * FROM Transaction`。
    * 指定した属性、または カンマ区切りのリストで指定した複数の属性に関連する値を取得。
    * [集計関数](#functions)を選択することで、指定した属性から集計値を取得。
    * [`AS`句](#sel-as)で、各引数で返された結果にラベル付け。

    [基本的な数学関数とともに`SELECT`を使用する](/docs/query-data/nrql-new-relic-query-language/getting-started/nrql-math-using-select)こともできます。

    <CollapserGroup>
      <Collapser id="avg-resp-time-query" title="直近1週間の平均レスポンスタイム">
        このクエリは、直近1週間の平均応答時間を返します。

        ```sql
        SELECT average(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>

    同じ`SELECT`ステートメントに、 `*`ワイルドカードと個々の属性、[関数](#non-aggregator-functions)、数式、[NRQL変数](#with-as-nrql-var)の両方を含めることができます。`*`は`SELECT`リストの先頭または末尾に表示される場合があり、選択した追加の列はそれぞれ結果テーブルの先頭または末尾に表示されます。

    ```sql
    SELECT *, attribute, function(attribute), attribute1 + attribute2 FROM ...
    ```

    ```sql
    WITH attribute1 + attribute2 AS attrSum SELECT attrSum, attribute, function(attribute), * FROM ...
    ```

    <CollapserGroup>
      <Collapser
        id="select-star-with-columns-query"
        title={<><InlineCode>
          SELECT *
        </InlineCode> with additional columns</>
        }
      >
        このクエリは、先頭に追加の列が付いた、使用可能なすべてのPageView属性を返します。

        ```sql
        WITH concat('(', asnLatitude, ', ', asnLongitude, ')') AS coordinates
        SELECT coordinates, city, connectionSetupDuration + pageRenderingDuration AS partialDuration, *
        FROM PageView
        ```

        <img title="select star with additional columns" alt="select star with additional columns" src="/images/nrql_screenshot-select-star-with-additional-columns.webp" />

        <figcaption>
          <InlineCode>
            SELECT \*
          </InlineCode> with additional columns example
        </figcaption>
      </Collapser>
    </CollapserGroup>

    <Callout variant="tip">
      `SELECT`リストでは、`*`とともに[非集計関数](#non-aggregator-functions)のみがサポートされます。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-from"
    title={<>必須：<InlineCode>
      FROM
    </InlineCode>句</>
    }
  >
    ```sql
    SELECT ...
    FROM data type
    ...
    ```

    `FROM`句を使用して、クエリする[データ型](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql#what-you-can-query)を指定します。クエリは`FROM`または[`SELECT`](#state-select)で開始できます。カンマ区切りのリストの複数のデータタイプにまたがる同じ属性の値をマージできます。

    <CollapserGroup>
      <Collapser id="one-event" title="1つのデータ型のクエリ">
        このクエリは、直近7日間の[APMトランザクション](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults)の全カウント数を返します。

        ```sql
        SELECT count(*) FROM Transaction SINCE 7 days ago
        ```
      </Collapser>

      <Collapser id="multiple-events" title="複数のデータ型のクエリ">
        このクエリは、直近3日間の[APMトランザクション](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults)と[ブラウザイベント](/docs/insights/new-relic-insights/decorating-events/browser-default-attributes-insights#browser-attributes-table)の全カウント数を返します。

        ```sql
        SELECT count(*) FROM Transaction, PageView SINCE 3 days ago
        ```
      </Collapser>

      <Collapser id="from-lookups" title="ルックアップテーブルからのデータのクエリ">
        [`lookup()`](#func-lookup)をご覧ください。
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### オプション句 [#optional]

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="sel-as"
    title={<><InlineCode>
      AS
    </InlineCode> 句</>
    }
  >
    ```sql
    SELECT ...
    AS 'label'
    ...
    ```

    `AS`句を使用して、シングルクォート区切りの文字列で属性、集計、ファネル内のステップ、または数学関数の結果にラベルを付けます。このラベルは結果のチャートで使用されます。`FACET`句が使用されている場合、時系列グラフの`AS`句のラベルは表示されないことに注意してください。

    <CollapserGroup>
      <Collapser
        id="math-as"
        title={<>数学関数とを使用したクエリ <InlineCode>
          AS
        </InlineCode></>
        }
      >
        このクエリはセッションごとのページ数を返します。

        ```sql
        SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session'
        FROM PageView
        ```
      </Collapser>

      <Collapser
        id="funnel-as"
        title={<>ファネルとを使用したクエリ <InlineCode>
          AS
        </InlineCode></>
        }
      >
        このクエリは、過去1週間でサイトのメインページと採用情報ページの両方を訪れた人の数を返します。

        ```sql
        SELECT funnel(SESSION,
          WHERE name = 'Controller/about/main' AS 'Step 1',
          WHERE name = 'Controller/about/careers' AS 'Step 2')
        FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-compare"
    title={<><InlineCode>
      COMPARE WITH
    </InlineCode> 句</>
    }
  >
    ```sql
    SELECT ... 
    (SINCE or UNTIL) (integer units) AGO
    COMPARE WITH (integer units) AGO
    ...
    ```

    `COMPARE WITH`句を使用すると、2つの異なる時間範囲の値を比較できます。

    `COMPARE WITH` には`SINCE`または`UNTIL`文が必要です。`COMPARE WITH`で指定された時間は、`SINCE`または`UNTIL`で指定した時間に相対します。たとえば、`SINCE 1 day ago COMPARE WITH 1 day ago`昨日を一昨日と比較します。

    `COMPARE WITH`値の時間範囲は、常に`SINCE`または`UNTIL`で指定されたものと同じになります。たとえば、`SINCE 2 hours ago COMPARE WITH 4 hours ago`は午後3時〜5時までと午前11時〜午後1時までを比較できます。

    `COMPARE WITH` 結果は、折れ線グラフまたはビルボードで表示できます。

    * `TIMESERIES`を使用すると、`COMPARE WITH`は比較内容を経時的にマッピングした折れ線グラフを作成します。
    * `TIMESERIES`がない場合、`COMPARE WITH`は現在値と`COMPARE WITH`値からの増減率でビルボードを生成します。

    <DNT>**Example**</DNT>このクエリは、過去1週間の95パーセンタイルと1週間前の同じ範囲の比較を表示する折れ線グラフでデータを返します。最初は単一値、次は折れ線グラフです。

    ```sql
    SELECT percentile(duration, 95) FROM PageView
    SINCE 1 week ago COMPARE WITH 1 week AGO

    SELECT percentile(duration, 95) FROM PageView
    SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO
    ```

    <Callout variant="important">
      `COMPARE WITH`を使用する`FACET`クエリの場合、結果のファセットは、比較される前の時間範囲ではなく、`SINCE`および`UNTIL`を使用して指定された時間範囲に基づいて選択されます。以前の時間範囲のみに対する`FACET`クエリの結果には、別のファセットのセットが含まれる場合があります。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="extrapolate"
    title={<><InlineCode>
      EXTRAPOLATE
    </InlineCode> 句</>
    }
  >
    この句は以下のデータ型で使用できます。

    * `Transaction`

    * `TransactionError`

    * <InlinePopover type="apm" />エージェントAPIで報告されたカスタムイベント

      `EXTRAPOLATE`の目的は、クエリ結果がシステム内のアクティビティ全体をより厳密に表現できるよう、[イベントデータのAPMエージェントサンプリング](/docs/agents/manage-apm-agents/agent-data/new-relic-events-limits-sampling)の影響を数学的に補うことです。

      この句は、APMエージェントが[収集サイクル](/docs/using-new-relic/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#event-data)の報告限度をしばしば超過する多くの[イベント](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#harvest-cycle)を報告する際に便利です。その場合、エージェントはイベントのサンプリングを開始します。

      `EXTRAPOLATE`に対応したNRQLクエリでこれを使用する場合、<DNT>**reported events**</DNT>と<DNT>**total events**</DNT>の比率で、合計未サンプルデータの近似を推定します。この句に未対応であるか、サンプルデータを使用していないNRQLでこれを使用する場合、結果に影響を与えません。

      <Callout variant="important">
        `EXTRAPOLATE`は、（スループットまたはエラー率など）同種データに対して最も有用である点に注意してください。（`uniqueCount()`または`uniques()`など）特徴的なものの数を外挿する際には有効ではありません。
      </Callout>

      この句は、以下のいずれかの[集計関数](/docs/insights/nrql-new-relic-query-language/nrql-reference/nrql-syntax-components-functions#functions)を使用するNRQLクエリでのみ機能します。

    * `apdex`

    * `average`

    * `count`

    * `histogram`

    * `sum`

    * `percentage` （引数として取る関数が`EXTRAPOLATE`に対応している場合）

    * `rate` （引数として取る関数が`EXTRAPOLATE`に対応している場合）

    * `stddev`

      <CollapserGroup>
        <Collapser id="extrapolate-example-1" title="スループットの推定の例">
          `interestingApplication`という名前のサービスの推定スループットを示すクエリ。

          ```sql
          SELECT count(*) FROM Transaction WHERE appName = 'interestingApplication' 
          SINCE 60 minutes ago EXTRAPOLATE
          ```
        </Collapser>

        <Collapser id="extrapolate-example-2" title="時系列としてのスループットの推定の例">
          トランザクション名ごとに、時系列として表示する`interestingApplication`という名前のサービスの推定スループットを示すクエリ。

          ```sql
          SELECT count(*) FROM Transaction WHERE appName = 'interestingApplication'
          SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet"
    title={<><InlineCode>
      FACET
    </InlineCode> 句</>
    }
  >
    ```sql
    SELECT ...
    FACET attribute
    ...
    ```

    `FACET`を使用すると、結果を属性値で分割してグループ化できます。たとえば、`PageView`データで`deviceType`別に`FACET`を行い、トラフィックの何割が携帯電話、タブレット、およびデスクトップデバイスから発生しているかを把握することができます。

    `LIMIT`句を使用して、表示するファセットの数を指定します（デフォルトは10）。より複雑なグループ化に関しては、[`FACET CASES`](#sel-facet-cases)を使用します。`FACET`句は、カンマで区切られた最大5つの属性をサポートします。

    ファセットは、`SELECT`句で指定した最初のフィールドの降順で並べ替えられます。5,000件以上のユニーク値を持つ属性をファセットに指定した場合、ファセット値のサブセットを選択し、それらをクエリタイプに従って並べ替えます。時系列グラフがデータを返さない場合（NRQLが一致するデータがない、無効なNRQLなど）、 `FROM`句の最初のテーブルに一致するラベルを持つ平坦な線のみが表示されることに注意してください。

    `min()`、`max()`、`percentile()`、`average()`、または`count()`を選択すると、`FACET`はこれらの関数を使用してファセットの選択方法とソート方法を決定します。その他の[関数](#functions)を選択すると、`FACET`はファセット対象の属性の発生頻度に基づいて、ファセットの選択方法とソート方法を決定します。

    <CollapserGroup>
      <Collapser
        id="faceted-query"
        title={<>使用したファセットクエリ <InlineCode>
          count()
        </InlineCode></>
        }
      >
        このクエリは、ページビュー数が最も多い都市を表示します。このクエリは、都市ごとのページビューの合計数を使用してファセットの選択方法と並べ替え方法を決定します。

        ```sql
        SELECT count(*) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="uniquecount"
        title={<>使用したファセットクエリ <InlineCode>
          uniqueCount()
        </InlineCode></>
        }
      >
        このクエリは、最も多数のユニークURLにアクセスしている都市を表示します。このクエリは、特定の都市が結果に表れる合計回数を使用して、ファセットの選択方法と並べ替え方法を決定します。

        ```sql
        SELECT uniqueCount(pageUrl) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser id="cohort-analysis" title="時間範囲で結果をグループ化">
        [高度なセグメンテーション](/docs/insights/new-relic-insights/features/advanced-segmentation)や[コホート分析](/docs/insights/new-relic-insights/features/cohort-analysis-grouping-results-across-time)では、バケット機能でファセットすることでデータをより効率的に分割することができます。

        コホート分析は、タイムスタンプに基づいて結果をグループ化する方法です。指定範囲日時に対応するバケットに結果を分割することができます。
      </Collapser>
    </CollapserGroup>

    <Callout variant="important">
      関数を使用して属性値を集計する場合、クエリの最初の関数で集計される属性にnull以外の値が含まれていることを確認してください。ファセットは、最初の関数の属性のnull以外の値を含む行に対してのみ選択されます。

      例:

      ```sql
      FROM Event SELECT average(attribute) FACET name
      ```

      名前は、nullでない属性の行からのみ選択されます。

      次のクエリを実行して、関数で使用している属性にnull以外の値が含まれているかどうかを確認します。

      ```sql
      FROM Event SELECT attribute, name WHERE attribute IS NOT NULL
      ```
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="facet-as"
    title={<><InlineCode>
      FACET ... AS
    </InlineCode> 句</>
    }
  >
    `FACET ... AS`句では、クエリで`AS`キーワードを使用してファセットに名前を付けます。この句は、結果のファセットに明確な名前または簡略化された名前を追加するのに役立ちます。[ネスト構造の集計](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query)クエリで、ファセットの名前を変更するためにも使用できます。

    `FACET ... AS` クエリでは、結果のファセット名が変更されますが（たとえば、テーブルのヘッダーとして表示される場合）、実際のファセット名自体は変更されません。

    ```sql
    FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type'
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-cases"
    title={<><InlineCode>
      FACET CASES
    </InlineCode> 句</>
    }
  >
    ```sql
    SELECT ...
    FACET CASES 
    (
      WHERE attribute operator value, 
      WHERE attribute operator value, 
      ...
    )
    ...
    ```

    [`FACET`](#sel-facet)で可能な条件よりも複雑な条件でデータを分類するには、 `FACET CASES`を使用します。複数の条件はカンマ`,`で区切ります。 たとえば、`PageView`データをクエリして、1秒未満、1秒から10秒、10秒を上回るといったカテゴリに`FACET CASES`を行うことができます。ケース内の複数の属性を組み合わせ、[`AS`](#sel-as)セレクタでケースにラベルを付けることができます。データポイントは、最大で1つのファセットケースに追加されます。つまり、一致する最初のファセットになります。

    また、属性とともに[時間関数](/docs/query-data/nrql-new-relic-query-language/nrql-query-examples/group-results-across-time)を使用することもできます。また、`OR`演算子を使用して、指定したどのケースにも一致しないファセット結果を表示することもできます。

    <CollapserGroup>
      <Collapser
        id="facet-cases-basic"
        title={<>基本的な使用 <InlineCode>
          WHERE
        </InlineCode></>
        }
      >
        ```sql
        SELECT count(*) FROM PageView 
        FACET CASES 
        (
          WHERE duration < 1, 
          WHERE duration > 1 AND duration < 10, 
          WHERE duration > 10
        )
        ```
      </Collapser>

      <Collapser id="facet-cases-mixnmatch" title="複数の属性に基づくグループ化">
        この例は、トランザクション名に`login`が含まれる1つのバケットと、URLに`login`が含まれ、かつカスタムアトリビュートがユーザーが有料ユーザーであったことを示すもう1つのバケットに結果をグループ化します。

        ```sql
        SELECT count(*) FROM Transaction 
        FACET CASES 
        (
          WHERE name LIKE '%login%', 
          WHERE name LIKE '%feature%' AND customer_type = 'Paid'
        )
        ```
      </Collapser>

      <Collapser
        id="facet-cases-as-label"
        title={<>グループのラベル付け <InlineCode>
          AS
        </InlineCode></>
        }
      >
        この例は、結果に人間が読める名前をつけるために[`AS`](#sel-as)セレクタを使います。

        ```sql
        SELECT count(*) FROM Transaction 
        FACET CASES 
        (
          WHERE name LIKE '%login%' AS 'Total Logins', 
          WHERE name LIKE '%feature%' AND customer_type = 'Paid' AS 'Feature Visits from Paid Users'
        )
        ```
      </Collapser>

      <Collapser
        id="facet-cases-with-or"
        title={<>ファセット不一致データ <InlineCode>
          OR
        </InlineCode></>
        }
      >
        この例では、`OR`演算子を使用して、どのケースにも一致しないファセット結果を表示しています。

        ```sql
        SELECT count(*) FROM Transaction 
        FACET CASES 
        (
          WHERE name LIKE '%login%', 
          WHERE name LIKE '%feature%' AND customer_type = 'Paid'
        ) 
        OR name
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-order"
    title={<><InlineCode>
      FACET ... ORDER BY
    </InlineCode> 句</>
    }
  >
    NRQLでは、デフォルトは`SELECT`句の最初の集計で、クエリ内のファセットの選択をガイドします。`FACET ... ORDER BY`では、`ORDER BY`修飾子で集計関数を追加し、ファセットの選択方法を指定することで、このデフォルト動作をオーバーライドできます。具体的には、`LIMIT`句によって制限される前に、最終結果に含めるファセットの優先度をオーバーライドします。この句はクエリには使用できますが、アラートやストリーミングには使用できません。

    この例では、`FACET ... ORDER BY`を使用してアプリトランザクションの平均期間を見つける方法を示し、応答サイズが最大のアプリによる上位10（デフォルトの制限）の最大期間を示しています。この場合、`FACET ... ORDER BY`が使用されていない場合、クエリ結果には、アプリの選択とは関係のない応答サイズで、期間が最も長い上位10件が代わりに表示されます。

    ```sql
    FROM Transaction SELECT average(duration) TIMESERIES 
    FACET appName ORDER BY max(responseSize)
    ```

    `FACET ... ORDER BY`句を使用する場合、`ASC`修飾子と`DESC`修飾子を追加して、並べ替え順序を変更することはできません。デフォルトでは、この句は`DESC`を使用します。

    <Callout variant="tip">
      `LIMIT`句が適用される前に操作が実行されるため、`FACET ... ORDER BY`は、最終的なクエリ結果の種類に影響を与えません。これは、非時系列クエリの結果で特に顕著になります。
    </Callout>

    <Callout variant="important">
      この場合の`ORDER BY`修飾子は、`ORDER BY`句とは機能が異なります。`FACET attribute1 ORDER BY attribute2`の形式に従うクエリを構文解析する場合、New Relicはこれらのクエリを`FACET ... ORDER BY`クエリとして読み取りますが、`ORDER BY`が`FACET`の直後に表示される場合に限定されます。それ以外の場合、`ORDER BY`はNew Relicによって句として解釈されます。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-join"
    title={<><InlineCode>
      JOIN
    </InlineCode> 句</>
    }
  >
    `JOIN`句を使用して、1つのイベントタイプのデータを共通の属性またはキーに基づくサブクエリの結果と結合します。

    ```sql
    FROM Event [INNER|LEFT] JOIN (SELECT... FROM...) ON [key =] key SELECT ...
    ```

    サブクエリ結合には、簡単なルールがいくつかあります。

    * `JOIN`句は、常に[`FROM`](#sel-from)句の直後に置く必要があります。
    * 結合タイプ（`INNER`または`LEFT`）の接頭辞はオプションです。省略した場合、結合タイプはデフォルトで`INNER`になります。
    * [サブクエリ](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql)を含む括弧は、`JOIN`の直後に置く必要があります。
    * `ON`句はサブクエリの直後に置く必要があります。

    <table id="join-types">
      <thead>
        <tr>
          <th colSpan={2}>
            <DNT>
              **Join types**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td style={{ width: "300px" }}>
            `INNER`
          </td>

          <td>
            結果には、結合されたサブクエリの結果に一致する値を持つ、外部クエリの値のみが含まれます。これはデフォルトの結合タイプです。
          </td>
        </tr>

        <tr>
          <td>
            `LEFT`
          </td>

          <td>
            結果には、結合されたサブクエリと一致しない外部クエリのイベントが含まれます。
          </td>
        </tr>
      </tbody>
    </table>

    <table id="join-on">
      <thead>
        <tr>
          <th colSpan={2}>
            <DNT>
              **Join `ON` clause**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td style={{ width: "300px" }}>
            `ON parentKey = subqueryKey`
          </td>

          <td>
            サブクエリと外部クエリで比較するキーの値を定義します。使用できる唯一の比較演算子は等価です。

            * 左側は常に親クエリで使用されるキーであり、属性または関数の場合があります。
            * 右側はサブクエリのキーの値に使用され、識別子である必要があります。
          </td>
        </tr>

        <tr>
          <td>
            `ON key`
          </td>

          <td>
            これは、キー識別子が両方のコンテキストで同じ場合の簡略構文です。`ON key = key`に相当します。
          </td>
        </tr>
      </tbody>
    </table>

    考慮すべき制限事項：

    * 結合されたサブクエリのデフォルトの[`LIMIT`](#sel-limit)は10で、最大`LIMIT`は5,000です。外部クエリの`LIMIT`は内部クエリに影響を及ぼしません。
    * 結合サブクエリでの`TIMESERIES`の使用はサポートされていません。外部クエリで`TIMESERIES`を使用する場合、結合されたサブクエリはクエリの全期間に単一の結果を提供することに注意してください。
    * すべてのサブクエリと同様に、結合されたサブクエリはアラート条件では使用できません。
    * `SELECT *`は親クエリではサポートされていますが、結合されたサブクエリではサポートされていません。
    * 結合のカーディナリティは1:100に制限されています。つまり、1つの結合キーはサブクエリ結果の100行以上にマップできません。

    `JOIN`句の詳細については、[NRQLサブクエリ結合](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/subquery-joins)チュートリアルを参照してください。

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          INNER JOIN
        </InlineCode> ファセットサブクエリの使用</>
        }
        id="example-faceted-inner-join"
      >
        このクエリは、`PageView`イベントタイプの`browserTransactionName`によってファセットされたイベント数を検索し、次に`PageAction`イベントタイプの`currentUrl`によってファセットされたイベント数を検索します。これにより、共通の`session`属性値に基づいて2つのイベントタイプが結合されます。

        ```sql
        FROM PageView
        JOIN 
        (
          FROM PageAction 
          SELECT count(*) 
          FACET session, currentUrl
        ) 
        ON session
        SELECT count(*) FACET browserTransactionName, currentUrl
        ```

        <img title="screenshot faceted inner join" alt="screenshot faceted inner join" src="/images/nrql_screenshot-crop_example-faceted-inner-join.webp" />

        <figcaption>
          ファセット<InlineCode>
            INNER JOIN
          </InlineCode>の例
        </figcaption>
      </Collapser>

      <Collapser
        title={<><InlineCode>
          LEFT JOIN
        </InlineCode> ファセットサブクエリの使用</>
        }
      >
        この例では、[ファセット`INNER JOIN`の例](#example-faceted-inner-join)と同じデータをクエリしますが、`LEFT JOIN`クエリとして、結果には`PageAction`サブクエリの結果に一致する`session`値を持たない項目が`PageView`テーブルに含まれます。

        ```sql
        FROM PageView
        LEFT JOIN 
        (
          FROM PageAction 
          SELECT count(*) 
          FACET session, currentUrl
        ) 
        ON session
        SELECT count(*) FACET browserTransactionName, currentUrl
        ```

        <img title="screenshot faceted left join" alt="screenshot faceted left join" src="/images/nrql_screenshot-crop_example-faceted-left-join.webp" />

        <figcaption>
          ファセット<InlineCode>
            LEFT JOIN
          </InlineCode>の例
        </figcaption>
      </Collapser>

      <Collapser
        title={<><InlineCode>
          INNER JOIN
        </InlineCode> 非集計サブクエリの使用</>
        }
      >
        ここでは、非集計の行単位サブクエリを実行します。外部クエリでは、`PageAction`イベントタイプの`currentUrl`によってファセットされたイベント数を検索し、次に`PageView`イベントタイプの`browserTransactionNamed`によってファセットされたイベント数を検索します。これにより、共通の`session`属性値に基づいて2つのイベントタイプが結合されます。

        `session`値`34d5ce6acf4c60be`には、サブクエリの`PageView`イベントタイプからの2つの`browserTransactionName`値があり、結果に行が追加されます。

        ```sql
        FROM PageAction
        LEFT JOIN 
        (
          FROM PageView 
          SELECT session, browserTransactionName 
          LIMIT MAX
        ) 
        ON session
        SELECT count(*) FACET session, currentUrl, browserTransactionName LIMIT MAX
        ```

        <img title="screenshot columnar inner join" alt="screenshot columnar inner join" src="/images/nrql_screenshot-crop_example-columnar-inner-join.webp" />

        <figcaption>
          非集計<InlineCode>
            INNER JOIN
          </InlineCode>の例
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-limit"
    title={<><InlineCode>
      LIMIT
    </InlineCode> 句</>
    }
  >
    ```sql
    SELECT ...
    LIMIT count
    ...
    ```

    `LIMIT`句を使用して、`FACET`クエリで返されるファセット値の最大数、または`SELECT *`クエリで返される項目の最大数を制御します。この句は、単一の整数値を引数に取ります。`LIMIT`句が指定されない、または値が提供されない場合、リミットのデフォルト設定は、`FACET`クエリの場合は10、`SELECT *`クエリの場合は100となります。

    `LIMIT`句で許容される最大値は5,000です。クエリでは、特定の値の代わりに`LIMIT MAX`句を使用できます。これにより、デフォルトで現在の最大値が自動設定されます。これを使用すると、将来的に変更される場合でも、常に最大数の結果を投稿できます。クエリの動作を変更しないようにするには、`LIMIT MAX`を使用する代わりに明示的な値を指定します。

    <CollapserGroup>
      <Collapser
        title={<>使用したクエリ <InlineCode>
          LIMIT
        </InlineCode></>
        }
      >
        このクエリはセッション数上位20カ国を表示し、各国のWindowsユーザー限定でレスポンスタイムの95パーセンタイルを提供します。

        ```sql
        SELECT uniqueCount(session), percentile(duration, 95)
        FROM PageView WHERE userAgentOS = 'Windows'
        FACET countryCode LIMIT 20 SINCE YESTERDAY
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-offset"
    title={<><InlineCode>
      OFFSET
    </InlineCode> 句</>
    }
  >
    ```sql
    SELECT ...
    LIMIT count OFFSET count
    ...
    ```

    `OFFSET`句と`LIMIT`句を使用して、`SELECT *`または`SELECT column`クエリによって返される行の一部を制御します。`LIMIT`句と同様に、`OFFSET`は引数として単一の整数値を取ります。`OFFSET`は、クエリで選択された行が返される前に、スキップされる行数を設定します。これは`LIMIT`によって制約されます。

    `OFFSET` 行はスキップされ、直近のレコードから開始されます。

    たとえば、クエリ`SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1`は、最新の値を除き、`Minute_Report`から最後の5つの値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-order-by"
    title={<><InlineCode>
      ORDER BY
    </InlineCode> 句</>
    }
  >
    `ORDER BY`句を使用すると、行でイベント属性を選択するクエリで結果を並べ替える方法を指定できます。

    このクエリは、2つの特定のトランザクション属性を期間別に並べ替えます。

    ```sql
    FROM Transaction SELECT appName, duration ORDER BY duration
    ```

    デフォルトの並べ替え順序は昇順ですが、`ASC`または`DESC`の修飾子を追加することで変更できます。

    このクエリは、すべてのトランザクション属性を期間別の降順に並べ替えます。

    ```sql
    FROM Transaction SELECT * ORDER BY duration DESC
    ```

    <Callout variant="important">
      `ORDER BY`句は`FACET`クエリには適用されません。ファセット選択の指針となる`FACET ... ORDER BY`句と混同しないでください。詳細については、[`FACET ... ORDER BY`](#sel-facet-order)を参照してください。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="#sel-prediction"
    title={<><InlineCode>
      PREDICT
    </InlineCode> 句</>
    }
  >
    ```sql
    FROM Transaction SELECT count(*) WHERE error IS TRUE TIMESERIES PREDICT
    ...
    ```

    `PREDICT`句を使用すると、履歴データに基づいて将来のデータ傾向の予測を折れ線グラフに追加できます。この句を使用する場合は、次の点を考慮してください。

    * `TIMESERIES`句を含むクエリにのみ適用されます。
    * 予測データポイントの間隔として`TIMESERIES <time period>`を使用します。
    * パブリックプレビュー中は[メトリックタイムスライスデータ](/docs/data-analysis/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#timeslice-data)はサポートされません。

    <Callout variant="important">
      `PREDICT`句は、[`COMPARE WITH`](/docs/nrql/nrql-syntax-clauses-functions/#sel-compare)句や[サブクエリ](/docs/nrql/using-nrql/subqueries-in-nrql/)内の [ネストされた集計](/docs/nrql/using-nrql/nested-aggregation-make-ordered-computations-single-query)と併用することはできません。
    </Callout>

    `PREDICT`をいつ、どのように使用できるかについての詳細は、[NRQL予測](/docs/query-your-data/explore-query-data/use-charts/nrql-predictions/)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="show-event-types"
    title={<><InlineCode>
      SHOW EVENT TYPES
    </InlineCode> 句</>
    }
  >
    ```sql
    SHOW EVENT TYPES...
    ```

    `SHOW EVENT TYPES` は、特定の時間範囲内にアカウントに存在するすべてのデータ型のリストを返します。これは、`SELECT`の代わりにクエリの最初の句として使用されます。

    <Callout variant="important">
      この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータ型を指します。
    </Callout>

    <CollapserGroup>
      <Collapser id="avg-resp-time-query" title="直近1日のデータ型">
        このクエリは、直近1日のすべてのデータ型を返します。

        ```sql
        SHOW EVENT TYPES SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-since"
    title={<><InlineCode>
      SINCE
    </InlineCode> 句</>
    }
  >
    ```sql
    SELECT ...
    SINCE [numerical units AGO | phrase]
    ...
    ```

    <DNT>**default**</DNT>値は<DNT>**1 hour ago**</DNT>です。

    `SINCE`句を使用して、返されたデータに対する時間範囲の包括的な開始を定義します。タイムゾーンは結果ではなく、クエリに対して指定できます。NRQLの結果はシステム時間に基づきます。

    NRQLを使用する場合、UTCタイムスタンプ、相対時間、または`DateTime`文字列を設定できます。[時間の指定](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/#spec-time)を参照してください。

    以下も参照してください。

    * [クエリの時間範囲の設定](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/)
    * [UNTIL](#sel-until)
  </Collapser>

  <Collapser
    className="freq-link"
    id="slide-by"
    title={<><InlineCode>
      SLIDE BY
    </InlineCode> 句</>
    }
  >
    `SLIDE BY`句は、スライディングウィンドウと呼ばれる機能をサポートしています。スライディングウィンドウを使用すると、`SLIDE BY`データは、互いに重複する時間の「ウィンドウ」に収集されます。これらのウィンドウは、移動集計（移動平均など）が狭い時間枠からの集計よりも重要である場合に、変動の多い折れ線グラフを滑らかにするのに役立ちます。

    `SLIDE BY`を使用するには、`TIMESERIES`句の後のクエリにこの句を配置します。たとえば、このクエリは1分の`SLIDE BY`間隔で5分間のウィンドウにデータをプルします。つまり、各ウィンドウは5分間続きますが、ウィンドウ1は0分後に開始し、ウィンドウ2は1分後に開始し、ウィンドウ3は2分後に開始します。

    ```sql
    SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute
    ```

    `SLIDE BY`をいつ、どのように使用できるかについての詳細は、[スライディングウィンドウを使用してよりスムーズなグラフを作成する](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows)を参照してください。または、この短いビデオをご覧ください（約3分20秒）。

    <Video id="b9WVyb1wU6w" type="youtube" />

    <CollapserGroup>
      <Collapser
        id="sliding-window-max-auto"
        title={<><InlineCode>
          SLIDE BY
        </InlineCode>を<InlineCode>
          MAX
        </InlineCode>または<InlineCode>
          AUTO
        </InlineCode>間隔と使用</>
        }
      >
        スライディングウィンドウは、`MAX`または`AUTO`と組み合わせて使用できます。ただし、`MAX`または`AUTO`を`TIMESERIES`と`SLIDE BY`の間に配置することはできません。

        このクエリは、`SLIDE BY`ウィンドウ間隔を自動的に決定します。

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO
        ```

        このクエリは、 `SLIDE BY`ウィンドウを最大の間隔粒度に設定します。

        ```sql
        SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX
        ```

        <Callout variant="important">
          `AUTO`または`MAX`によって決定される`SLIDE BY`値は、ウィンドウサイズよりも大きいステップ間隔を生成する可能性があり、ギャップや予期しない結果を引き起こす可能性があります。
        </Callout>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timeseries"
    title={<><InlineCode>
      TIMESERIES
    </InlineCode> 句</>
    }
  >
    ```sql
    SELECT ...
    TIMESERIES integer units
    ...
    ```

    `TIMESERIES`句を使用して、指定期間単位の時系列としてデータを返します。`TIMESERIES`は特定のチャートを表示するために使用されるため、デフォルト値はありません。

    時間範囲を指定するには、`integer units`を使用します。例：

    * `TIMESERIES 1 minute`
    * `TIMESERIES 30 minutes`
    * `TIMESERIES 1 hour`
    * `TIMESERIES 30 seconds`

    `TIMESERIES` 以下の例に示すように、`MAX`、`AUTO`、`SLIDE BY`などの引数と組み合わせると、クエリ結果をさらに調整できます。

    <Callout variant="important">
      `average()`または`percentile()`などの関数では、集計ウィンドウを大きく設定することで、外れ値に対して大幅なスムージング効果が得られます。これは、クエリがスライディングウィンドウを使用するかどうかに関係なく当てはまります。
    </Callout>

    <CollapserGroup>
      <Collapser id="set-interval" title="設定した間隔を使用する">
        指定された値は、グラフを分割する単位を示します。たとえば、以下のようにして1日のグラフを30分刻みで表示します。

        ```sql
        SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes
        ```
      </Collapser>

      <Collapser id="timeseries-auto" title="自動設定した間隔を使用する">
        `TIMESERIES` は`AUTO`に設定することもでき、これによってグラフが適切な数の区分に分割されます。たとえば、1日のチャートは30分間隔で分割され、1週間のチャートは6時間間隔で分割されます。

        このクエリは、6時間間隔のデータ点で、1週間のクライアントサイドのトランザクションタイムの50パーセントタイルと90パーセンタイルを示す折れ線グラフを返します。

        ```sql
        SELECT average(duration), percentile(duration, 50, 90)
        FROM PageView SINCE 1 week AGO TIMESERIES AUTO
        ```
      </Collapser>

      <Collapser
        id="timeseries-max"
        title={<><InlineCode>
          MAX
        </InlineCode>間隔を使用</>
        }
      >
        `TIMESERIES`を`MAX`に設定することで時間枠が自動的に調整され、指定された期間に許可された間隔数を最大にできます。これによって、`TIMESERIES`バケットを手動で更新することなく時間枠を更新でき、認められた最大インターバル数に時間枠を分割できます。返される`TIMESERIES`バケットの最大数は366です。

        たとえば、以下のクエリでは4分間の間隔を作成していますが、これは1日のチャートの上限となります。

        ```sql
        SELECT average(duration) FROM Transaction SINCE 1 day ago TIMESERIES MAX
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-until"
    title={<><InlineCode>
      UNTIL
    </InlineCode> 句</>
    }
  >
    ```sql
    SELECT ...
    UNTIL integer units AGO
    ...
    ```

    `UNTIL`句を使用して、クエリする時間範囲の終了を定義します。この値は排他的です。つまり、時間範囲は指定された瞬間までになりますが、その瞬間は含まれません。

    <DNT>**default**</DNT>値は<DNT>**NOW**</DNT>です。 `UNTIL`は、デフォルト以外の終了点を指定するためのみに使用してください。

    以下も参照してください。

    * [クエリの時間範囲の設定](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/)
    * [SINCE](#sel-since)
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-where"
    title={<><InlineCode>
      WHERE
    </InlineCode> 句</>
    }
  >
    `WHERE`句を使用して、結果をフィルタリングします。NRQLは、句で指定する条件を満たす結果を返します。

    ```sql
    SELECT function(attribute) ...
    WHERE attribute [operator 'value' | IN ('value' [, 'value']) | IS [NOT] NULL ]
    [AND|OR ...]
    ...
    ```

    * 複数の条件を指定する場合は、条件を演算子`AND`または`OR`で区切ります。

    <table id="where-operators">
      <thead>
        <tr>
          <th width={150}>
            <DNT>
              **Operators that the `WHERE` clause accepts**
            </DNT>
          </th>

          <th>
            <DNT>
              **Description**
            </DNT>
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `=`、`!=`、`<`、`<=`、`>`、 `>=`
          </td>

          <td>
            NRQLは標準的な比較演算子を受け付けます。例： `state = 'WA'`

            ブール値を持つ属性の場合、`=`ではなく`IS`を使用します。
          </td>
        </tr>

        <tr>
          <td>
            `AND`
          </td>

          <td>
            2つの条件の論理積を定義するために使用します。
          </td>
        </tr>

        <tr>
          <td>
            `OR`
          </td>

          <td>
            2つの条件の論理和を定義するために使用します。
          </td>
        </tr>

        <tr>
          <td>
            `IS NULL`
          </td>

          <td>
            属性がnull値を持つかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `IS NOT NULL`
          </td>

          <td>
            属性がnull値を持たないかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `IS TRUE`
          </td>

          <td>
            属性が`true`のブール値を持つかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `IS FALSE`
          </td>

          <td>
            属性が`false`のブール値を持つかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `IN`
          </td>

          <td>
            属性の文字列値が指定したセットに存在するかどうかを判断します。この方法を使用すると、複数の`WHERE`句を組み合わせた場合よりもパフォーマンスが向上します。

            例:

            ```sql
            animalType IN ('cat', 'dog', 'fish')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `NOT IN`
          </td>

          <td>
            属性の文字列値が指定したセットに存在しないかどうかを判断します。この方法を使用すると、複数の`WHERE`句を組み合わせた場合よりもパフォーマンスが向上します。

            値は括弧で囲み、カンマで区切る必要があります。例：

            ```sql
            SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `LIKE`
          </td>

          <td>
            属性に指定のサブ文字列が含まれるかどうかを判断します。

            `LIKE`演算子の文字列引数では、文字列内の任意の位置でワイルドカードとしてパーセント記号（`%`）を使用できます。

            以下の点に留意してください。

            * `LIKE`演算子は大文字と小文字を区別しません。

            * ワイルドカードを含めない場合は、その文字列の大文字と小文字が区別されません。たとえば、ワイルドカードを使用しない次のクエリ`B`と`b`は区別されません。

              ```sql
              FROM foo
              SELECT *
              WHERE bar LIKE 'B'
              ```

            <DNT>
              **Examples:**
            </DNT>

            `userAgentName LIKE 'IE%'`

            * IE

            * IE Mobile

              `userAgentName LIKE 'o%a%'`

            * Opera

            * Opera Mini

              `userAgentName LIKE 'o%a'`

            * Opera

              `userAgentName LIKE '%o%a%'`

            * Opera

            * Opera Mini

            * Mozilla Gecko
          </td>
        </tr>

        <tr>
          <td>
            `NOT LIKE`
          </td>

          <td>
            属性に指定のサブ文字列が含まれないかどうかを判断します。
          </td>
        </tr>

        <tr>
          <td>
            `RLIKE`
          </td>

          <td>
            属性に特定のRegexサブ文字列が含まれるかどうかを判断します。[RE2構文](https://github.com/google/re2/wiki/Syntax)を使用します。

            <DNT>
              **Examples:**
            </DNT>

            `appName RLIKE r'z.*|q.*'`

            * `z-app`

            * `q-app`

              `hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*'`

            * `ip-10-351-19-237`

            * `ip-10-351-2-41`

            * `ip-10-351-24-238`

            * `ip-10-351-14-15`

              <Callout variant="important">
                Regexではデフォルトで文字列全体マッチとなっているため、`^`と`$`は暗黙となり、追加する必要はありません。
              </Callout>
          </td>
        </tr>

        <tr>
          <td>
            `NOT RLIKE`
          </td>

          <td>
            属性に指定のRegexサブ文字列が含まれないかどうかを判断します。[RE2構文](https://github.com/google/re2/wiki/Syntax)を使用します。
          </td>
        </tr>
      </tbody>
    </table>

    <CollapserGroup>
      <Collapser id="query-3-conditions" title="3つの条件を使用したクエリの例">
        このクエリは、過去24時間、米国およびカナダ国内のSafariユーザーについて、URLに`checkout`が含まれるページのブラウザレスポンスタイムを返します。

        ```sql
        SELECT histogram(duration, 50, 20) FROM PageView
        WHERE countryCode IN ('CA', 'US') AND userAgentName = 'Safari' AND pageUrl LIKE '%checkout%'
        SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-metric-format"
    title={<><InlineCode>
      WITH METRIC_FORMAT
    </InlineCode> 句</>
    }
  >
    メトリックデータのクエリに関する情報については、[メトリクスのクエリを行う](#query-metrics)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-as-nrql-var"
    title={<><InlineCode>
      WITH ... AS
    </InlineCode> 句（NRQL環境変数）</>
    }
  >
    ```sql
    FROM ...
    WITH function(attribute) AS var
    SELECT var
    ...
    ```

    `WITH ... AS`句を使用してNRQL環境変数を定義し、クエリ内のどこでも参照できる環境変数として値を格納します。いくつかのルールとヒント：

    * `WITH ... AS`句は、`FROM`/`SELECT`句の前、間、直後に実行できます。
    * 環境変数として設定できるのは、行単位の関数（`capture()`など）のみです。集計関数（`average()`など）はサポートされていません。
    * `WITH`は1つしか使用できませんが、コンマで区切られている限り、複数のNRQL環境変数を使用できます。
    * 定義されたNRQL環境変数が既存の属性と同じ名前を使用する場合、環境変数が優先されます。
    * 環境変数名に`%`記号を含めることはできません。

    <Callout variant="important">
      [イベント対メトリクス](/docs/data-apis/convert-to-metrics/analyze-monitor-data-trends-metrics/)ルールは、[NRQLクエリ](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/)の`WITH ... AS`句をサポートしません。
    </Callout>

    以下にいくつかクエリを示します。

    <CollapserGroup>
      <Collapser id="basic-nrql-var" title="環境変数の基本的な使用">
        ```sql
        FROM Transaction
        WITH duration * 1000 AS millisec
        SELECT millisec
        ```
      </Collapser>

      <Collapser id="multiple-nrql-var" title="複数の環境変数の使用">
        ```sql
        FROM Log
        WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice)
        SELECT itemId, unitPrice
        ```

        [アンカー解析](#func-aparse)（`aparse()`）の詳細をご覧ください。
      </Collapser>

      <Collapser id="nrql-var-other-clauses" title="他の句での環境変数の使用">
        この例では、NRQL環境変数`unitPrice`を使用して、抽出された文字列を数値に変換する別の環境変数`unitPriceNum`を作成します。この環境変数は、`SELECT`、`WHERE`および`FACET`句で使用されます。

        ```sql
        FROM Log
        WITH aparse(message, '%itemId":"*","unitPrice":*}%') AS (itemId, unitPrice),
          numeric(unitPrice) AS unitPriceNum
        SELECT sum(unitPriceNum)
        FACET itemId
        WHERE unitPriceNum < 100
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timezone"
    title={<><InlineCode>
      WITH TIMEZONE
    </InlineCode> 句</>
    }
  >
    ```sql
    SELECT ... WITH TIMEZONE (selected zone)
    ...
    ```

    `WITH TIMEZONE`句を使用すると、タイムゾーンが未指定のクエリ内で日付や時刻のタイムゾーンを選択できます。

    日時にタイムゾーンを指定せずに`WITH TIMEZONE`句を含めると、`since`句と`until`句は指定されたタイムゾーンを保持します。

    `WITH TIMEZONE`句を含めなくても、日時文字列にタイムゾーンを含めると、日時文字列のタイムゾーンが保持されます。

    <Callout variant="important">
      タイムゾーンが指定されていない場合、デフォルトのタイムゾーンは常にUTCです。結果の生のタイムスタンプ値（JSONビューで表示）は常にUTCです。UIには、アカウント設定で指定したタイムゾーンで結果が表示されます。タイムスタンプ文字列のタイムゾーンは常に機能します。これは、`WITH TIMEZONE`ゾーンより優先されます。
    </Callout>

    たとえば、クエリ句`SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'`は、米国/ニューヨーク時間の月曜日の午前0時から、米国/ニューヨーク時間の火曜日の午前0時までに記録されたデータを返します。

    クエリのタイムスパン句の例をいくつか紹介します。

    * `WITH TIMEZONE`句を使用した日時文字列にタイムゾーンがありません。

      ```sql
      SINCE today UNTIL '2022-05-19T12:00' WITH TIMEZONE 'America/Los_Angeles'
      ```

      これは、`"beginTime": "2022-05-19T07:00:00Z"`と`"endTime": "2022-05-19T19:00:00Z"`として解決されます。

    * `WITH TIMEZONE`句を使用しない日時文字列のタイムゾーン：

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500'
      ```

      これは、`"beginTime": "2022-05-19T00:00:00Z"`と`"endTime": "2022-05-19T17:00:00Z"`として解決されます。

    * 夏時間の-0700である米国/ロサンゼルスという`WITH TIMEZONE`句を使用した、日時文字列のタイムゾーン：

      ```sql
      SINCE today UNTIL '2022-05-19T12:00-0500' WITH TIMEZONE 'America/Los_Angeles'
      ```

      これは、`"beginTime": "2022-05-19T07:00:00Z"`と`"endTime": "2022-05-19T19:00:00Z"`として解決されます。

    利用可能な[ゾーンID](/docs/query-your-data/nrql-new-relic-query-language/get-started/query-time-range/#timezones-ids)のリストを参照してください。

    詳細な情報と例については、[ダッシュボードとチャートで時間範囲を設定する](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets)を参照してください。
  </Collapser>
</CollapserGroup>

## メトリックデータをクエリ [#query-metrics]

メトリックデータはその他のデータ型より複雑です。それをうまくクエリする特定のヒントがあります。メトリックデータには2つの型があり、それぞれに以下の独自のクエリガイドラインがあります。

* [ディメンションメトリクスをクエリします](/docs/data-ingest-apis/get-data-new-relic/metric-api/view-query-you-metric-data)。これは、当社のメトリクスAPIとそのAPIを使用するソリューションの一部（たとえば、[Dropwizard インテグレーション](/docs/more-integrations/open-source-telemetry-integrations/dropwizard/dropwizard-reporter)または[Micrometerインテグレーション）により報告されます](/docs/more-integrations/open-source-telemetry-integrations/micrometer/micrometer-metrics-registry)。
* [クエリメトリックタイムスライスデータ](/docs/query-data/nrql-new-relic-query-language/nrql-query-tutorials/query-metric-timeslice-data-nrql)、当社のAPM、モバイルモニタリング、<InlinePopover type="browser" /> によって報告されるオリジナルのメトリックデータ型です。

メトリックデータのレポート方法の詳細は、[メトリックデータタイプ](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics)を参照してください。

## 関数 [#functions]

このセクションでは、NRQL関数、[集計関数](#aggregator-functions)と[非集計関数](#non-aggregator-functions)の両方について説明します。

### 集計関数 [#aggregator-functions]

集計関数を使用して、データをフィルタリング、集計します。以下を使用するためのヒント：

* 同じクエリで集計関数を複数回使用している場合（例：`SELECT median(one_metric), median(another_metric)`）、結果の表示に問題が生じることがあります。この問題を解決するには、[`AS`関数](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/#sel-as)を使用します。例：
  ```sql
  SELECT median(one_metric) AS 'med-a', median(another_metric) AS 'med-b'
  ```
* データ型「型強制」には対応していません。[利用可能なデータ型変換関数](#type-conversion)の詳細を参照してください。
* 時間の経過に伴う結果の表示方法については、[時間の経過に伴う結果のグループ化](/docs/insights/new-relic-insights/features/cohort-analysis)を参照してください。

例：

```sql
SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
```

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="func-aggregationendtime"
    title={<InlineCode>aggregationendtime()</InlineCode>
    }
  >
    `aggregationendtime()`関数を使用して、関連集計の時刻を返します。より具体的には、`aggregationendtime()`関数は、指定した集計の、集計期間終了のタイムスタンプを提供します。たとえば、時系列クエリでは、1時間分のデータを含むデータポイントの場合、関数はその時間の終わりのタイムスタンプを返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-apdex"
    title={<InlineCode>apdex(attribute, t: )</InlineCode>
    }
  >
    `apdex`関数を使用して、単一のトランザクションまたはすべてのトランザクションの[Apdexスコア](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#score)を返します。デフォルトの<DNT>Apdex</DNT>スコアは0.5秒です。[属性](/docs/insights/new-relic-insights/decorating-events/insights-attributes)には、[`duration`](/docs/insights/insights-data-sources/default-events-attributes/apm-default-event-attributes#txn-duration)または[`backendDuration`](/docs/insights/insights-data-sources/default-events-attributes/browser-default-events-attributes-insights#backend-duration)などのレスポンスタイムに基づく任意の属性を指定できます。`t:`引数は、選択した属性と同じ時間単位で[`Apdex T`](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction)閾値を定義します。たとえば、属性が秒単位で測定される場合、`t`が秒単位の閾値になります。

    `apdex()`関数が返す<DNT>Apdex</DNT>スコアは、実行時間のみに基づくものです。APMエラーは考慮していません。もしトランザクションにエラーが含まれていても、それが[Apdex T](/docs/apm/new-relic-apm/getting-started/glossary#apdex_t)以下で完了する場合、そのトランザクションは`apdex()`関数によって[満足](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#bullet-satisfied)と評価されます。

    <CollapserGroup>
      <Collapser id="apdex-cust-attributes" title="特定の顧客の Apdexを取得する">
        [定義済みカスタム属性](/docs/insights/new-relic-insights/decorating-events/insights-custom-attributes)がある場合は、それらの属性に基づいて絞り込むことができます。たとえば、特に重要な顧客のApdexを監視することができます。

        ```sql
        SELECT apdex(duration, t: 0.4) FROM Transaction
        WHERE customerName = 'ReallyImportantCustomer' SINCE 1 day ago
        ```
      </Collapser>

      <Collapser id="apdex-transaction" title="特定のトランザクションのApdexを取得する">
        `name`属性を使用して特定のトランザクションのスコア、または`name`を省略して総合的なApdexを返します。このクエリは、直近1時間の<DNT>**Controller/notes/index**</DNT>トランザクションのApdexスコアを返します。

        <img title="crop-apdex-function" alt="crop-apdex-function" src="/images/queries-nrql_screenshot-full_apdex-NRQL-query-builder.webp" />

        <figcaption>
          `apdex`関数は、あなたのサイトに対するユーザーの満足度を測定する[Apdexスコア](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction)を返します。引数は、秒単位のレスポンスタイムの属性とApdex Tの閾値です。
        </figcaption>

        ```sql
        SELECT apdex(duration, t: 0.5) from Transaction
        WHERE name = 'Controller/notes/index' SINCE 1 hour ago
        ```
      </Collapser>

      <Collapser title="アプリ全体のApdexを取得する">
        このクエリの例では、直近3週間のアプリケーション全体のApdexを返します。

        ```sql
        SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-average"
    title={<InlineCode>average(attribute)</InlineCode>
    }
  >
    `average()`関数を使用して、属性の平均値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数値が返されない場合は、null値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-bucket-percentile"
    title={<InlineCode>bucketPercentile(attribute)</InlineCode>
    }
  >
    `bucketPercentile()`関数は、Prometheusの[`histogram_quantile`](https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile)関数のNRQL版です。次元メトリックデータとともに使用します。分位数の代わりにNew Relicパーセンタイルを返します。これは分位数\*100です。

    `bucketPercentile()`関数を使用して、Prometheus形式のヒストグラムデータから分位数を計算します。

    バケット名を引数として取得し、バケットの境界とともにパーセンタイルをレポートします。

    ```sql
    SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago
    ```

    オプションで、引数としてパーセンタイル指定を追加できます。

    ```sql
    SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago
    ```

    複数のメトリックスを使用してPrometheusヒストグラムデータを構成しているため、関連する`<basename>`に関して特定のPrometheusメトリックスのクエリを行う必要があります。

    たとえば、`<basename>` `prometheus_http_request_duration_seconds`が、NRQLを使用してPrometheusヒストグラムからパーセンタイルを計算するには、`bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)`を使用します。`_bucket`がサフィックスとして`<basename>`の最後に追加されていることに注意してください。

    詳細については、[Prometheus.ioドキュメント](https://prometheus.io/docs/concepts/metric_types/#histogram)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cardinality"
    title={<InlineCode>cardinality([metric_name, include:{`{attribute_list}`}, exclude:{`{attribute_list}`}])</InlineCode>
    }
  >
    `cardinality()`関数を使用して、[メトリック](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics)上のすべてのディメンション（属性）の組み合わせの数を取得します。

    次の3つの引数を取りますが、すべてオプションです。

    * メトリック名：ある場合は、`cardinality()`は指定したメトリックのみを計算します。
    * インクルード：ある場合、Includeリストは濃度計算をこの属性に制限します。
    * エクスクルード：ある場合、Excludeリストによりこの属性は濃度計算で無視されます。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cdfPercentage"
    title={<InlineCode>cdfPercentage(attribute, threshold [, threshold [, ...]])</InlineCode>
    }
  >
    `cdfPercentage()` は[累積分布関数](https://en.wikipedia.org/wiki/Cumulative_distribution_function)の実装であり、`attribute`値のパーセンテージ（値が1以下または`thresholds`を超える）を返します。

    `cdfPercentage()` `attribute`引数に基づいて集計され、数値属性または分布メトリクス属性のいずれかになります。1つのクエリ内の混合型が受け入れられます。他の型（文字列など）は無視されます。最大10個の閾値を指定できます。

    <CollapserGroup>
      <Collapser title="特定の閾値よりも速く初期表示時間の割合を取得する">
        このクエリは、`firstPaint`が0.5秒以下のイベントの割合と、`firstPaint`が1秒以下のイベントの割合を返します。

        ```sql
        FROM PageView SELECT cdfPercentage(firstPaint, 0.5, 1.0)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-count"
    title={<InlineCode>count(*)</InlineCode>
    }
  >
    `count()`関数を使用して、使用可能レコード数を返します。これは単一の引数を受け入れます (`*`、属性、または定数値のいずれか)。現在、一般的なSQL動作に従い、その引数に対する値を持つすべてのレコードを計上します。

    `count(*)`は特定の属性を示すものではないため、結果はデフォルトの[「humanize」](/docs/insights/new-relic-insights/managing-dashboards-data/data-formatter-setting-default-formats-numeric-values#format)形式でフォーマットされます。
  </Collapser>

  <Collapser
    className="freq-link"
    id="derivative"
    title={<InlineCode>derivative(attribute [,time interval])</InlineCode>
    }
  >
    `derivative()` は、所定のデータセットの変化率を検索します。線形最小二乗回帰を使用して変化率を計算し、微分係数を近似します。この計算では複数のデータポイントの比較が必要であるため、評価範囲にデータポイントが1つしかない場合、解が求められず、結果は`null`値になります。

    `time interval`は、変化率を計算する期間です。たとえば、`derivative(attributeName, 1 minute)`は1分あたりの変化率を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="earliest-func"
    title={<InlineCode>earliest(attribute)</InlineCode>
    }
  >
    `earliest()`関数を使用して、指定された時間範囲における属性の最も古い値を返します。

    単一の引数を取ります。

    `FACET`と併用する場合、この関数は得られた各ファセットの属性の最も古い値を返します。

    <Callout variant="tip">
      複数のイベントまたはメトリクスが同じ最も早いタイムスタンプを共有する場合、返される結果はランダムであり、クエリの実行ごとに異なる場合があります。より一貫した結果を得るには、これらのイベントまたはメトリクスに対して異なる値を持つ属性でファセットを作成してください。
    </Callout>

    <CollapserGroup>
      <Collapser title="PageView からユーザーエージェントごとに最も古い国を取得">
        このクエリは、`PageView`イベントからユーザーエージェントごとに最も古い国コードを返します。

        ```sql
        SELECT earliest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-filter"
    title={<InlineCode>filter(function(attribute), WHERE condition)</InlineCode>
    }
  >
    `filter()`関数を使用して、`SELECT`文内の集計関数の1つに結果を制限します。`filter()`は、`FACET`や`TIMESERIES`とともに使用できます。フィルターは、次のような複数の異なる集計を選択する場合にのみ役立ちます。

    ```sql
    SELECT filter(sum(x), WHERE attribute = 'a') AS 'A',
      filter(sum(x), WHERE attribute = 'b') AS 'B' ...
    ```

    それ以外の場合は、標準`WHERE`句を使用するのが良いでしょう。

    <CollapserGroup>
      <Collapser title="オファーコードを使用した購入を分析する">
        `filter()`は、一連のトランザクションで購入された商品の中で、オファーコードを使用して購入された商品と、オファーコードを使用せずに購入された商品を比較するために使用できます。

        <img title="screenshot insights filter" alt="screenshot insights filter" src="/images/queries-nrql_screenshot-full_filter-NRQL-query-builder.webp" />

        <figcaption>
          `filter()`関数を使用して、`SELECT`文内の集計関数の1つに結果を制限します。
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-funnel"
    title={<InlineCode>funnel(attribute, steps)</InlineCode>
    }
  >
    `funnel()`関数を使用して、ファネルチャートを生成します。属性を最初の引数として取ります。その後、カンマで区切られた[`WHERE`](#sel-where)句（オプションでラベル付け用に[`AS`](#sel-as)句を含める）としてステップを指定します。

    詳細な情報と例については、 [ファネルのドキュメント](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/funnels-evaluate-data-series-events)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-histogram"
    title={<InlineCode>histogram(attribute[, width: n][, buckets: n][, start: n])</InlineCode>
    }
  >
    `histogram()`関数を使用して、ヒストグラムを生成します。これは、データセットのディストリビューションの可視化に役立ちます。データセットを指定された数のバケットに分割し、各バケットに含まれるデータポイントの数をカウントします。

    引数：

    * `attribute` 1番目の引数は必須で、各ヒストグラムのバケット範囲内の値をカウントする属性を指定します。

    * `width:` サンプル範囲の幅を示します。範囲の最大値は、`start`引数値にこの`width`値を加えた値になります。

      * 位置引数（ラベルなし）を使用する場合、`width`が2番目の引数になります。
      * *デフォルト：* `10`

    * `buckets:` バケットの合計数（`1`～`500`の間）。

      * 位置引数（ラベルなし）を使用する場合、`buckets`が3番目の引数になります。
      * *デフォルト：* `40`

    * `start:` ヒストグラム範囲の開始値。

      * 位置引数（ラベルなし）を使用する場合、`start`が4番目の引数になります。
      * *デフォルト：* `0`

    <Callout variant="tip" title="注意">
      定義されたヒストグラムの範囲外の値は、最初または最後のバケットに含められます。最初のバケット数にはヒストグラム範囲より小さい値が含まれ、最後のバケット数にはヒストグラム範囲より大きい値が含まれます。ヒストグラムの結果からこれらの値を除外するには、クエリのwhere句にフィルターを含めます。（例： `WHERE attribute >= [start] AND attribute <= [start + width]` ）
    </Callout>

    <CollapserGroup>
      <Collapser id="histogram-response-times-defaults" title="PageViewイベントからのレスポンスタイムのヒストグラム">
        このクエリは、40バケットにわたって10秒以内のレスポンスタイムのヒストグラムを生成します。すなわち、各バケットが0.25秒の範囲の値をカバーします。（10/40＝0.25）。10秒を超える期間の値は最後のバケットに含められます。期間がゼロ未満になるような場合があれば、その値は最初のバケットに含まれます。

        ```sql
        SELECT histogram(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-response-times" title="幅：5、バケット：10のヒストグラム">
        これらの同様のクエリは、10バケットにわたって5秒以内のレスポンスタイムのヒストグラムを生成します。

        ```sql
        SELECT histogram(duration, 5, 10) FROM PageView SINCE 1 week ago
        ```

        ```sql
        SELECT histogram(duration, width: 5, buckets: 10) FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-response-times-1to4" title="幅：3、バケット：3、開始：1のヒストグラム">
        これらの同様のクエリは、3バケットにわたって1～4秒のレスポンスタイムのヒストグラムを生成します。

        バケットの構成は次のとおりです。

        <table>
          <thead>
            <tr>
              <th />

              <th>
                バケット1
              </th>

              <th>
                バケット2
              </th>

              <th>
                バケット3
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                バケットの範囲
              </td>

              <td>
                1〜2
              </td>

              <td>
                2〜3
              </td>

              <td>
                3〜4
              </td>
            </tr>

            <tr>
              <td>
                カウントされる値
              </td>

              <td>
                2未満
              </td>

              <td>
                2以上3未満
              </td>

              <td>
                3以上
              </td>
            </tr>
          </tbody>
        </table>

        ```sql
        SELECT histogram(duration, 3, 3, 1) 
        FROM PageView SINCE 1 week ago
        ```

        ```sql
        SELECT histogram(duration, width: 3, buckets: 3, start: 1) 
        FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-prometheus" title="Prometheusヒストグラムバケット">
        `histogram()` Prometheusヒストグラムバケットを受け取ります。

        ```sql
        SELECT histogram(duration_bucket, 10, 20) 
        FROM Metric SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="distribution-metric" title="New Relicディストリビューションメトリック">
        `histogram()` [ディストリビューションメトリック](/docs/data-ingest-apis/get-data-new-relic/metric-api/events-metrics-service-create-metrics#limits-rules)を入力として受け取ります。

        ```sql
        SELECT histogram(myDistributionMetric, 10, 20) 
        FROM Metric SINCE 1 week ago
        ```
      </Collapser>

      <Collapser id="histogram-facet-heatmap" title="FACET句があるヒストグラム">
        `FACET`句とともに`histogram()`を使用し、ヒートマップチャートを生成します。

        ```sql
        SELECT histogram(duration) 
        FROM PageView FACET appName SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="keyset"
    title={<InlineCode>keyset()</InlineCode>
    }
  >
    `keyset()`を使用すると、所定の時間範囲における所定のデータ型に対するすべての属性を表示できます。この関数は引数を取りません。文字列型キー、数値型キー、ブール型キー、およびすべてのキーをグループ化したJSON構造体を返します。

    <CollapserGroup>
      <Collapser title="データ型のすべての属性を表示">
        このクエリは、最終日からの`PageView`イベントで見つかった属性を返します。

        ```sql
        SELECT keyset() FROM PageView SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latest"
    title={<InlineCode>latest(attribute)</InlineCode>
    }
  >
    `latest()`関数を使用して、指定された時間範囲における属性の最新値を返します。

    単一の引数を取ります。

    `FACET`と併用する場合、この関数は得られた各ファセットの属性の最新値を返します。

    <Callout variant="tip">
      複数のイベントまたはメトリクスが同じ最新のタイムスタンプを持つ場合、返される結果はランダムであり、クエリの実行ごとに異なる場合があります。より一貫した結果を得るには、これらのイベントまたはメトリクスに対して異なる値を持つ属性でファセットを作成してください。
    </Callout>

    <CollapserGroup>
      <Collapser title="PageViewからユーザーエージェントごとに最新の国を取得">
        このクエリは、`PageView`イベントからユーザーエージェントごとに最新の国コードを返します。

        ```sql
        SELECT latest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="latestrate"
    title={<InlineCode>latestrate(attribute, time interval)</InlineCode>
    }
  >
    `latestrate()`関数を使用して、最後の2つのデータポイントに基づく値の変化率を返します。問題となる属性を最初の引数として受け取り、結果である変化率の時間の単位を2番目の引数として受け取ります。この関数は結果を`change in attribute/time interval`の単位で返します。

    この関数は、最先端の傾向を確認するために、属性の最新の変化率を提供するのに役立ちます。

    <CollapserGroup>
      <Collapser title="PageView期間の最新の変化率を取得する">
        このクエリは、最後の2つのデータポイントに基づいて期間の変化率を返します。`1 SECOND`引数であるため、`duration/second`の単位で返されます。

        ```sql
        SELECT latestrate(duration, 1 SECOND) FROM PageView
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-max"
    title={<InlineCode>max(attribute)</InlineCode>
    }
  >
    `max()`関数を使用して、指定された時間範囲内に記録された数値属性の最大値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数値が返されない場合は、null値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-median"
    title={<InlineCode>median(attribute)</InlineCode>
    }
  >
    `median()`関数を利用して、属性の中央値あるいは50パーセンタイルを返します。パーセンタイルクエリの詳細に関しては、[`percentile()`](#func-percentile)を参照してください。

    <CollapserGroup>
      <Collapser title="中央値クエリ">
        このクエリは、中央値に関する折れ線グラフを生成します。

        ```sql
        SELECT median(duration) FROM PageView TIMESERIES AUTO
        ```
      </Collapser>
    </CollapserGroup>

    [`JOIN`](#sel-join)句の中央値：

    * 中央値は単に`percentile(attribute, 50)`のショートカットであるため、結合サブクエリからの`median()`の結果は複合データ型であり、50パーセンタイル値をその計算値にマップします。

      [`getField()`](#func-getfield)関数を使用すると、外部クエリの実際の中央値を参照できます。マップされたキーは二重値の文字列表現であるため、`median()`の場合は`'50.0'`になります。

      <CollapserGroup>
        <Collapser title="結合中央値クエリ">
          ```sql
          FROM PageView
          JOIN (FROM PageAction SELECT median(timeSinceLoad) FACET session, currentUrl) ON session
          SELECT latest(getField(median, '50.0')) AS median
          FACET browserTransactionName, currentUrl
          ```

          <img title="screenshot joined median" alt="screenshot joined median" src="/images/nrql_screenshot-crop_example-joined-median.webp" />
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-min"
    title={<InlineCode>min(attribute)</InlineCode>
    }
  >
    `min()`関数を使用して、指定された時間範囲内に記録された数値属性の最小値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数値が返されない場合は、null値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentage"
    title={<InlineCode>percentage(function(attribute), WHERE condition)</InlineCode>
    }
  >
    `percentage()`関数を使用して、いくつかの条件に一致する目的のデータセットの割合を返します。

    この関数は正確に2つの引数を必要とします (最初の2つ以降の引数は無視されます)。最初の引数には、対象属性に対する[集計関数](#functions)が必要です。属性が数値でない場合、この関数は100%の値を返します。2 番目の引数には`WHERE`句が必要です。

    ```sql
    FROM Transaction 
    SELECT percentage(count(*), WHERE error is true ) AS 'Error Percent' 
    WHERE host LIKE '%west%' EXTRAPOLATE
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentile"
    title={<InlineCode>percentile(attribute [, percentile [, ...]])</InlineCode>
    }
  >
    `percentile()`関数を使用して、所定の指定パーセンタイルでの属性の概算値を返します。この関数は属性が必須であり、パーセンタイル点を表す引数はいくつでも指定できます。`percentile()`関数は、小数点以下3桁までの表示を可能にすることで、より厳密な内容を提供できます。パーセンタイルの閾値は小数点値として指定される場合があるものの、大半のデータセットにおいて、互いに0.1よりも近いパーセンタイルは解決されない点に注意してください。

    <img title="percentile.png" alt="percentile.png" src="/images/queries-nrql_screenshot-full_percentile-NRQL-query-builder.webp" />

    <figcaption>
      パーセンタイルの表示例
    </figcaption>

    `TIMESERIES`を使用して、時系列でマッピングされたパーセンタイルで折れ線グラフを生成します。

    * `TIMESERIES`を省略して、パーセンタイルの集計値を示すビルボードと属性シートを生成します。

      パーセンタイルが指定されていない場合、デフォルトで95番パーセンタイルとなります。50パーセンタイル値、つまり中央値のみを返すには、[`median()`](#func-median)を使用することもできます。

      <CollapserGroup>
        <Collapser title="基本的なパーセンタイルのクエリ">
          このクエリは、5、50、95パーセンタイルの折れ線を表示する折れ線グラフを生成します。

          ```sql
          SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO
          ```
        </Collapser>
      </CollapserGroup>

    [`JOIN`](#sel-join)句のパーセンタイル：

    * 結合サブクエリでパーセンタイルを使用する場合、サブクエリの結果は複合データ型であり、各パーセンタイルをその計算値にマップします。

      [`getField()`](#func-getfield)関数を使用して、外部クエリで個々のパーセンタイル値を参照できます。マップされたキーは二重値の文字列表現であるため、整数に`.0`を追加する必要があります。たとえば、95パーセンタイル値のキーは`'95.0'`です。

      <CollapserGroup>
        <Collapser title="結合パーセンタイルクエリ">
          ```sql
          FROM PageView
          JOIN 
          (
            FROM PageAction 
            SELECT percentile(timeSinceLoad, 95, 99.5) AS pctl
            FACET session, currentUrl
          ) 
          ON session
          SELECT latest(getField(pctl, '95.0')) AS `95th`, 
            latest(getField(pctl, '99.5')) AS `99.5th`
          FACET browserTransactionName, currentUrl
          ```

          <img title="screenshot joined percentile" alt="screenshot joined percentile" src="/images/nrql_screenshot-crop_example-joined-percentile.webp" />
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="predictLinear"
    title={<InlineCode>predictLinear(attribute, [,time interval])</InlineCode>
    }
  >
    `predictLinear()` は`derivative()`関数の拡張機能です。同様の方法の最小2乗線形回帰を使用して、データセットの将来値を予測します。

    * `time interval`は、クエリでどの程度将来まで扱うかを表します。たとえば、`predictLinear(attributeName, 1 hour)`は、1時間の線形予想をクエリの時間枠の将来に当てはめます。
    * 一般に、`predictLinear()`は、ディスクスペースのような増加が続く値や大きなトレンドの予想などで有用です。
    * `predictLinear()`は線形回帰のため、クエリを行っているデータセットに習熟していると、正確な長期的な予想を行えます。
    * 指数的または対数的、その他の非線形的に増加するデータセットでは、非常に短期的な予想でのみ有効な可能性が高いと言えます。
    * New Relicでは、`TIMESERIES`クエリで`predictLinear`を使用することを推奨していません。これは、各バケットがクエリ内の相対的な期間に基づき個別に予想を行う、つまり、そうしたクエリは時系列終了以後の予想は示さないためです。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-rate"
    title={<InlineCode>rate(function(attribute) [,time interval])</InlineCode>
    }
  >
    `rate()`関数を使用して、時間間隔ごとに所定のクエリの頻度またはレートを可視化します。たとえば、1時間の1分あたりのページビュー数や1日間の1時間あたりのサイトのユニークセッション数を把握する必要がある場合があります。

    * [`TIMESERIES`](#sel-timeseries)を使用して、時系列でマッピングされた評価を示す折れ線グラフを生成します。

    * [`TIMESERIES`](#sel-timeseries)を省略して、時間で平均化された単一の評価値を示すビルボードを生成します。

      過去6時間にわたる10分あたりのAPMトランザクションのスループット評価を示す折れ線グラフを生成する基本的なクエリを以下に示します。

      ```sql
      SELECT rate(count(*), 10 minute) FROM Transaction 
      SINCE 6 hours ago TIMESERIES
      ```

      ここでは、さまざまな時間枠でデータを比較するために`rate`を使用する方法を説明する短いビデオ（3分21秒）を紹介します。

      <Video id="9UArmB4QiVM" type="youtube" />
  </Collapser>

  <Collapser
    className="freq-link"
    id="stdvar"
    title={<InlineCode>stdvar(attribute)</InlineCode>
    }
  >
    `stdvar()`関数を使用して、指定された時間範囲内に記録された数値属性の[標準分散](https://en.wikipedia.org/wiki/Variance)を返します。

    単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-sum"
    title={<InlineCode>sum(attribute)</InlineCode>
    }
  >
    `sum()`関数を使用して、指定された時間範囲内に記録された数値属性の合計値を返します。

    単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniqueCount"
    title={<InlineCode>uniqueCount(属性, [, 属性 [, ...]] [, 精度: 数値])</InlineCode>
    }
  >
    `uniqueCount()`関数を使用して、指定された時間範囲内に記録された属性のユニーク値の数を取得します。複数の属性値の一意の組み合わせをカウントするには、関数でそれらの属性を指定します。最大32個の属性を含めることができます。この関数は、`precision`引数なしで呼び出すと、最大256個のユニーク値の正確な結果を提供します。ユニーク値が256個を超える場合、結果は概算となります。正確な結果を得るために閾値を増やすには、256から50,000個の範囲内で`precision`値を指定できます。ユニーク値が設定された閾値を超えると、関数は[HyperLogLog確率的データ構造](https://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf)を使用して概算結果を提供します。

    <Callout variant="tip" title="注意">
      **256 個の値での正確なカウントの仕組み**：256 個未満の一意の文字列値をカウントする場合、 `uniqueCount()`はハッシュベースのカウント方法を使用して一意性を判断します。このメソッドは、各文字列の文字から32ビットの整数ハッシュコードを生成します。このアプローチはほとんどの文字列のハッシュ値を効率的に分散しますが、ハッシュの衝突が発生することもあります。つまり、2 つの異なる文字列が同じハッシュコードを生成する可能性があります。これは、互いに非常に類似した文字列をカウントする場合に発生する可能性が高くなります。まれにハッシュ衝突が発生する場合、関数は一意の値の実際の数をわずかに過少にカウントすることがあります。
    </Callout>

    属性を指定して`uniqueCount()`関数を使用し、オプションで次のように精度引数を設定します。

    ```sql
    uniqueCount(attribute, [, attribute [, ...]] [, precision: number])
    ```

    * **プロパティ**：ユニーク値をカウントする属性を指定するか、値の一意の組み合わせをカウントする複数の属性を指定します。最大32個の属性を指定できます。
    * **精度**：正確な結果の閾値を設定する数値を指定します。最大50,000までの値を設定できます。

    `precision`引数のないクエリの例：

    ```sql
    SELECT uniqueCount(accountId) FROM Transaction SINCE 1 day ago
    ```

    `precision`引数を使用したクエリの例：

    ```sql
    SELECT uniqueCount(appName, name, clusterName, precision: 1000) FROM Transaction SINCE 1 day ago
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniques"
    title={<><InlineCode>
      uniques(attribute [,limit]
    </InlineCode><InlineCode>
      )
    </InlineCode></>
    }
  >
    `uniques()`関数を使用して、指定された時間範囲内に記録された属性のユニーク値のリストを返します。`facet`句と共に使用すると、各ファセット値ごとにユニーク属性値リストが返されます。

    `limit`パラメーターはオプションです。提供されない場合は、ファセットあたり1,000のユニーク属性値のデフォルトlimitが適用されます。最大10,000までの、別の`limit`値を指定できます。`uniques()`関数は、limitに達するまで、発見したユニーク属性値の最初のセットを返します。このため、データセットに5,000のユニーク属性値があり、リミットが1,000に設定されている場合は、演算子はその頻度に関わらず、発見した最初の1,000のユニーク値を返します。

    クエリ結果で返すことのできる最大数は、`uniques()`上限と`facet`上限を掛け合わせたものになります。以下のクエリでは、論理的に返すことができる値の最大数は500万です（5,000 x 1,000）。

    クエリするデータセットとクエリの複雑性に応じて、メモリ保護limitで非常に大きなクエリの実行が阻止される場合があります。

    ```sql
    From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000
    ```

    <CollapserGroup>
      <Collapser
        title={<>使用 <InlineCode>
          tuple
        </InlineCode></>
        }
      >
        少数の属性の独自の組み合わせを知りたい場合、`SELECT uniques(tuple(x, y, ... z)) ...`形式でクエリを構築することで、値の独自のタプルをすべて取得して、それらの関係を維持することができます。以下のクエリでは、`tuple`が`index`と`cellName`で一緒に使用され、これらの2つの値が組み合わせで発生する一意の要素を見つけます。

        ```sql
        FROM NodeStatus SELECT uniques(tuple(index, cellName), 5)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

### 非集計関数 [#non-aggregator-functions]

非集計関数を使用して、 NRQLクエリ内の各データポイントの値を返します。

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="acct-type"
    title={<InlineCode>accountId()</InlineCode>
    }
  >
    `accountId()`関数を使用して、クエリされたデータに関連する[アカウントID](/docs/accounts/accounts-billing/account-structure/account-id)を返します。この関数は引数を取りません。以下にいくつかクエリを示します。

    <CollapserGroup>
      <Collapser title="各トランザクションイベントのアカウントIDの取得">
        このクエリは、返された各`Transaction`イベントに関連するアカウントIDを返します。

        ```sql
        SELECT accountId() FROM Transaction SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="各アカウントのトランザクションイベント数の取得">
        このクエリは、各アカウントIDに関連する最終日の`Transaction`イベント数を返します。

        ```sql
        SELECT count(*) FROM Transaction FACET accountId() SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser title="WHERE句で指定された各アカウントのトランザクションイベント数の取得">
        このクエリは、アカウントIDが、特に`1`、`2`、`3`のいずれかである最終日の`Transaction`イベント数を返します。

        ```sql
        SELECT count(*) FROM Transaction WHERE accountId() IN (1,2,3) SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-aparse"
    title={<><InlineCode>
      aparse(attribute, pattern)
    </InlineCode></>
    }
  >
    アンカー解析関数、`aparse()`を使用して、文字列から特定の値を抽出します。これは`capture()`の代替手段です。

    `aparse()` 次の2つの引数が必要です。

    * 文字列属性
    * アンカー文字列と抽出文字を含むパターン文字列。たとえば、`www.*.com`を使用して、URLからドメインを抽出できます

    `aparse()`を使用する場合、パターン文字列には、上記の`www.`や`.com`のようなアンカーを含めて、目的の抽出文字列（`*`で示される）の場所を識別する必要があります。

    `aparse()` はパターン文字列で次の文字を使用します。

    * `%`: `LIKE`句に表示されているように、非キャプチャワイルドカード
    * `*`: 正規表現キャプチャの使用に似たワイルドカードのキャプチャ

    実際には、アンカー文字列は文字列属性の中央に発生し、先頭や末尾には発生しません。

    この場合、`%`のワイルドカードを使用して、不要な値（`%www.*.com%`など）を無視します。

    `capture()`と同様に、`aparse()`の結果はすべて文字列です。これらの結果を数学関数で使用するには、`numeric()`関数でキャストする必要があります。

    注： `aparse()`は大文字と小文字を区別しません。

    <CollapserGroup>
      <Collapser title="基本的な使用" id="aparse-basic" className="freq-link">
        ```sql
        FROM PageView
        SELECT aparse(browserTransactionName, 'website.com/*')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>
          aparse()
        </InlineCode> 特定の値</>
        }
        id="aparse-specific-values"
        className="freq-link"
      >
        文字列の中央から値を抽出するには、パターン文字列の先頭と末尾で非キャプチャワイルドカード`%`を使用します。例：

        ```sql
        FROM Log
        SELECT count(*)
        FACET aparse(string, '%"itemId":"*"%')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>
          aparse()
        </InlineCode> 複数の値</>
        }
        id="aparse-multiple-values"
        className="freq-link"
      >
        複数の値を環境変数として抽出する場合は、順序が重要であることに注意してください。例:

        ```sql
        FROM Log
        WITH aparse(string, 'POST: * body: {"itemId":"*","unitPrice":*}\n') AS (url, itemId, unitPrice)
        SELECT url, itemId, unitPrice
        ```

        環境変数の詳細については、[NRQL環境変数](#with-as-nrql-var)を参照してください。
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-blob"
    title={<InlineCode>blob(attribute)</InlineCode>
    }
  >
    BLOBタイプ属性で`blob()`関数を使用して、その属性のBase-64エンコード文字列を返します。

    この機能には次の制限があります。

    * `blob()`への呼び出しを含むクエリの最大`LIMIT`値は20です

    * `blob()` クエリの`WHERE`句では呼び出すことができません

    * `blob()` ファセットクエリや時系列クエリでは使用できません

      これがログでどのように使用されるかについて詳しくは、[長いログ（BLOB）内のデータの検索](/docs/logs/log-management/ui-data/long-logs-blobs)を参照してください。

      Base-64でエンコードされたBLOBをデコードするには、[`decode()`関数](#func-decode)を参照してください。

      <CollapserGroup>
        <Collapser
          title={<>拡張ログでの<InlineCode>
            blob()
          </InlineCode>の使用</>
          }
        >
          ```sql
          SELECT message, blob(`newrelic.ext.message`) 
          FROM Log WHERE newrelic.ext.message IS NOT NULL
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-buckets"
    title={<InlineCode>buckets(attribute, ceiling [,number of buckets])</InlineCode>
    }
  >
    `buckets()`関数を使用して、`FACET`句ごとに分割されたデータを、範囲に基づきバケットに集計します。New Relicデータベースの数値として保存される属性ごとにバケットにまとめることができます。

    この関数は、以下の3つの引数を取ります。

    * 属性名

    * サンプル範囲の最大値（外れ値は最終バケットに表示されます）

    * バケットの合計数

      詳細と例については、[データをバケットに分割](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/segment-your-insights-data-buckets)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-concat"
    title={<InlineCode>concat(属性, [, 属性 [, ...]][, 精度: ]))</InlineCode>
    }
  >
    `concat()`関数を使用して、引数を連結した結果の文字列を返します。

    数値、ブーリアン、タプル、または配列型の引数を20個まで指定できます。Null引数とサポートされていないタイプの引数は無視されます。引数が指定されていない場合、結果は空の文字列になります。

    浮動小数点数値を連結する際に含まれる小数点以下の桁数を制限するために、オプションの精度引数を提供することができます。

    結果の文字列の長さは最大4096文字です。

    <CollapserGroup>
      <Collapser title="書式設定された文字列として「PageView」から複数の期間値を取得">
        このクエリは、1つの文字列として小数点以下2桁とラベルで書式設定された`PageView`イベントから、バックエンドとネットワーク期間を返します。

        ```sql
        FROM PageView 
        SELECT concat('Backend Duration: ', backendDuration, ', Network Duration: ', networkDuration, precision: 2)
        ```

        これにより、次のような形式で回答が返されます。

        `Backend Duration: 0.69, Network Duration: 0`
      </Collapser>

      <Collapser title="書式設定された文字列によるファセットクエリの結果">
        このクエリは、ユーザーの都市、地域、国で構成される文字列でファセット化された、 `PageView`イベントからの平均接続セットアップ時間を返します。

        ```sql
        FROM PageView SELECT average(connectionSetupDuration) 
        FACET concat(city, ', ', regionCode, ' ', countryCode) 
        WHERE countryCode IN ('US', 'CA')
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-convert"
    title={<InlineCode>convert(attribute, fromUnits, toUnits)</InlineCode>
    }
  >
    `convert()`関数を使用して、指定された入力値に対して指定された単位間の単位変換を実行します。

    時間、長さ、重量、体積、データの一般的な単位と略語は、OpenTelemetry仕様に合わせて[UCUM 標準](https://ucum.org/ucum)を使用してサポートされています。便宜上、標準化された略語は、`ft_us`、`kilobytes`、および`µs`に加えて、`ft`などの自然言語の代替手段によって強化されています。

    単位では大文字と小文字が区別*されます*。仕様で大文字が要求されない限り、すべての単位は小文字です。たとえば、データ単位`'bits'`はビットに対して有効ですが、`'By'`のバイトに対しては大文字の`B`が必要です。

    最大の時間単位はユリウス`year`で、常に365.25日です。

    <CollapserGroup>
      <Collapser title="属性をミリ秒から分に変換">
        ```sql
        FROM Transaction SELECT convert(duration, 'ms', 'min') AS durationMin
        ```
      </Collapser>

      <Collapser title="重量合計をグラムからポンドに変換">
        ```sql
        FROM Product SELECT convert(sum(itemWeight), 'grams', 'lbs')
        ```
      </Collapser>

      <Collapser title="保存された時間単位と秒間の変換">
        このクエリでは、イベント自体に文字列属性として単位情報が格納されており、値を秒に標準化したいと想定しています。

        ```sql
        FROM Metric 
        SELECT average(convert(apm.mobile.external.duration, unit, 's')) 
        WHERE appName = 'my-application'
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-capture"
    title={<InlineCode>capture（属性、正規表現）</InlineCode>
    }
  >
    `capture()`を使用して、[RE2構文](https://github.com/google/re2/wiki/Syntax)の正規表現を使用して属性から値を抽出します。

    2つの引数が必要です。

    * 属性名

    * キャプチャ構文を使用した正規表現（NRQLの正規表現はPythonのような構文`r'...'`を使用します）

      キャプチャする場合は、RE2名前付きキャプチャ構文`...(?P<name> pattern )...`は、指定された名前で、含まれるパターンをキャプチャします。

      複数の値をキャプチャするには、正規表現で追加のキャプチャグループを指定します。例: `...(?P<name1> pattern1)...(?P<name2> pattern2)...`

      注：複数の値をキャプチャする場合、各キャプチャ文では最大16個のキャプチャグループ、各NRQLクエリでは最大5個のキャプチャ文を持つことができます。

      [正規表現キャプチャを使用してクエリ結果を改善する](https://newrelic.com/blog/how-to-relic/using-regex-capture)方法をお読みください。

      <Callout variant="tip">
        正規表現は入力全体と一致する必要があります。キャプチャ式が期待される結果を抽出しない場合は、最初または最後に`.*`が必要かどうかを確認します。これは、部分一致正規表現のパターンです。ただし、部分一致正規表現は、クエリの実行を遅らせることがあります。
      </Callout>

      `capture()`を使用して、ダッシュボードの読みやすさを向上する方法を紹介する短いビデオ（3分05秒）もあります。

      <Video id="hOPrTWYgPHg" type="youtube" />

      詳しくは、以下の例をご覧ください。

      <CollapserGroup>
        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> <InlineCode>
            SELECT
          </InlineCode>句条件内</>
          }
        >
          以下では、ウェブサイトのドメイン名を選択し、`https://`とに続くパスを削除します。 `.com`

          ```sql
          SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') 
          FROM PageView SINCE 1 day ago
          ```

          以下では、エラーメッセージの最初のワードのみがキャプチャされます。

          ```sql
          SELECT capture(errorMessage, r'(?P<firstWord>\S+)\s.+') 
          FROM Transaction 
          WHERE errorMessage IS NOT NULL
          SINCE 1 hour ago 
          ```
        </Collapser>

        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> <InlineCode>
            FACET
          </InlineCode>句条件内</>
          }
        >
          キャプチャしたHTTPメソッドによって、以下がファセットされます。

          ```sql
          SELECT count(*) FROM Log 
          WHERE message LIKE '%HTTP%' 
          FACET capture(message, r'.* "(?P<httpMethod>[A-Z]+) .*')
          ```
        </Collapser>

        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> <InlineCode>
            WHERE
          </InlineCode>句条件内</>
          }
        >
          以下は、キャプチャされたジョブ名が`ExampleJob`である正規表現と一致する`message`属性を持つログイベントに基づいて、結果をフィルター処理します。

          ```sql
          SELECT message FROM Log 
          WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' 
          SINCE 10 minutes ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> 数字型変換</>
          }
        >
          以下では、ログラインからCPU時間の合計をキャプチャします。数学演算を実行するには、明示的に数値にキャストする必要があります。

          ```sql
          SELECT sum(numeric(capture(message, r'.*CpuTime:\s(?P<cpuTime>\d+)'))) 
          FROM Log 
          WHERE message LIKE '%CpuTime:%' SINCE 1 hour ago
          ```
        </Collapser>
      </CollapserGroup>

      <CollapserGroup>
        <Collapser
          title={<><InlineCode>
            capture()
          </InlineCode> NRQL環境変数を含む複数の値</>
          }
        >
          この例では、NRQL環境変数を使用して、ログメッセージからキャプチャした複数の値を格納します。

          ```sql
          FROM Log
          WITH capture(message, r'POST to carts: (?P<URL>.*) body: {"itemId":"(?P<UUID>.*)","unitPrice":(?P<unitPrice>.*)}.*')
            AS (URL, UUID, unitPrice)
          SELECT URL, UUID, unitPrice
          WHERE URL IS NOT NULL
          ```

          NRQL環境変数の詳細については、[こちら](#with-as-nrql-var)をご覧ください。
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-decode"
    title={<InlineCode>decode(input, encoding)</InlineCode>
    }
  >
    `decode()`を使用して、文字列とBLOBに対してBase-64変換を実行します。入力値（最初の引数）は、エンコーディング（2番目の引数）で指定されたBase-64標準を使用してデコードされます。

    次の文字列値は、サポートされているエンコードパラメーターです。

    * 「base64」：[RFC4648 Base-64標準](https://datatracker.ietf.org/doc/html/rfc4648#section-4)を使用

    * 「base64mime」：[RFC2045 Base-64 標準（MIME）](https://datatracker.ietf.org/doc/html/rfc2045)を使用

    * 「base64url」：[URLおよびファイル名に安全なアルファベットを用いたRFC4648 Base-64標準](https://datatracker.ietf.org/doc/html/rfc4648#section-5)を使用

      `blob()` `WHERE`または`FACET`句では許可されないため、BLOBタイプの`decode()`、`WHERE`句またはファセットクエリではサポートされません。

      文字列をエンコードするには、[`encode()`関数](#func-encode)を参照してください。

      <CollapserGroup>
        <Collapser
          title={<>文字列属性での<InlineCode>
            decode()
          </InlineCode>の使用</>
          }
        >
          ```sql
          FROM Span SELECT entity.guid, decode(entity.guid, 'base64') 
          WHERE entity.guid IS NOT NULL
          ```
        </Collapser>

        <Collapser
          title={<>での<InlineCode>
            decode()
          </InlineCode>の使用 <InlineCode>
            FACET
          </InlineCode></>
          }
        >
          ```sql
          FROM Span SELECT count(*) 
          WHERE entity.guid IS NOT NULL 
          FACET entity.guid, decode(entity.guid, 'base64')
          ```
        </Collapser>

        <Collapser
          title={<><InlineCode>
            WHERE
          </InlineCode>句での<InlineCode>
            decode()
          </InlineCode>の使用</>
          }
        >
          ```sql
          FROM Span SELECT count(*) 
          WHERE entity.guid IS NOT NULL 
          AND decode(entity.guid, 'base64') NOT LIKE '%APM%'
          ```
        </Collapser>

        <Collapser
          title={<>BLOBタイプ属性での<InlineCode>
            decode()
          </InlineCode>の使用</>
          }
        >
          ```sql
          FROM Log
          WITH blob(`newrelic.ext.message`) AS encodedBlob,
          decode(encodedBlob, 'base64') AS decodedBlob
          SELECT encodedBlob, decodedBlob
          WHERE newrelic.ext.message IS NOT NULL
          LIMIT 10
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-dimensions"
    title={<InlineCode>{`dimensions(include: {attributes}, exclude: {attributes})`}</InlineCode>
    }
  >
    `dimensions()`関数を使用して、データ型のすべての次元値を返します。

    オプションの引数を使用して、以下の特定の属性を明示的に含めたり、除外したりできます。

    * `include`：存在する場合、includeリストの属性は`dimensions()`に限定されます。

    * `exclude`：存在する場合、`dimensions()`の計算ではそれらの属性は無視されます。

      ```sql
      FROM Metric SELECT count(node_filesystem_size) 
      TIMESERIES FACET dimensions()
      ```

      `FACET`句とともに使用する場合、`dimensions()`は、未集計クエリでのPrometheusの動作と同様に、イベントタイプで使用できるすべてのファセットについて一意の時系列を生成します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-encode"
    title={<InlineCode>encode(input, encoding)</InlineCode>
    }
  >
    `encode()`を使用して、文字列に対してBase-64変換を実行します。入力値（最初の引数）は、エンコーディング（2番目の引数）で指定されたBase-64標準を使用してエンコードされます。

    次の文字列値は、サポートされているエンコードパラメーターです。

    * 「base64」：[RFC4648 Base-64標準](https://datatracker.ietf.org/doc/html/rfc4648#section-4)を使用

    * 「base64mime」：[RFC2045 Base-64 標準（MIME）](https://datatracker.ietf.org/doc/html/rfc2045)を使用

    * 「base64url」：[URLおよびファイル名に安全なアルファベットを用いたRFC4648 Base-64標準](https://datatracker.ietf.org/doc/html/rfc4648#section-5)を使用

      文字列またはBLOBをデコードするには、[`decode()`関数](#func-decode)を参照してください。`encode()`はBLOBではサポートされていません。

      <CollapserGroup>
        <Collapser
          title={<>属性での<InlineCode>
            encode()
          </InlineCode>の使用</>
          }
        >
          ```sql
          FROM PageView SELECT session, encode(session, 'base64')
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cidraddress"
    title={<InlineCode>cidrAddress(attribute [, number [, cidrFormat])</InlineCode>
    }
  >
    `cidrAddress()`関数を使用して、CIDR IPアドレスからベースネットワークアドレスを取得します。

    `cidrAddress()` 次の引数を取ります。

    * `attribute` - IPアドレスそのもの、またはCIDR表記のプレフィックス長を含む文字列値。

      * これには、文字列属性または引用符で囲まれた文字列リテラルを指定できます
      * IPアドレスはIPv4アドレスである必要があります

    * `number` - プレフィックスの長さを表す整数値。

      * これは、整数属性または整数値です
      * 属性パラメーターがCIDR表記である場合、このパラメーターはオプションであり、CIDR文字列で指定されたプレフィックス長よりも優先されます

    * `cidrFormat` - ネットワークアドレス出力をCIDR表記形式にするかどうかを決定するために使用されるオプションのブール値。これはデフォルトでtrueになります。

      `cidrAddress()`関数は、属性パラメーターと数値パラメーターに有効なIPアドレスとプレフィックス長が含まれている限り、値を返します。パラメーター入力が無効な場合、`cidrAddress()` `null`を返します。

      <CollapserGroup>
        <Collapser title="最も多くのリクエストを処理しているサブネットを見つける">
          次のクエリは、 [SyntheticRequest](/attribute-dictionary/?event=SyntheticRequest)イベントタイプからのほとんどのリクエストを処理しているサブネットを返します。

          ```sql
          FROM SyntheticRequest SELECT count(*) FACET cidrAddress(serverIPAddress, 24)
          ```

          これにより、次のような形式で回答が返されます。

          <table>
            <thead>
              <tr>
                <th>
                  Cidr Address of Server IPAddress
                </th>

                <th>
                  Count
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  10.0.0.0/24
                </td>

                <td>
                  6k
                </td>
              </tr>

              <tr>
                <td>
                  10.10.1.0/24
                </td>

                <td>
                  4k
                </td>
              </tr>

              <tr>
                <td>
                  10.0.14.0/24
                </td>

                <td>
                  1k
                </td>
              </tr>
            </tbody>
          </table>
        </Collapser>

        <Collapser title="CIDR範囲内に存在するすべてのIPアドレスをクエリする">
          このクエリは、10.0.0.0～10.0.0.255のCIDR範囲内に存在する、[`serverIPAddress`](/attribute-dictionary/?event=SyntheticRequest&attribute=serverIPAddress)属性のすべてのIPアドレスを返します。

          ```sql
          FROM SyntheticRequest SELECT uniques(serverIPAddress) 
          WHERE cidrAddress(serverIPAddress, 24) = '10.0.0.0/24'
          ```
        </Collapser>

        <Collapser title="クエリ結果から特定のCIDR範囲に存在するIPアドレスをフィルタリングする">
          このクエリは、CIDR範囲10.0.0.0/24または10.10.1.0/24に該当する[`serverIPAddress`](/attribute-dictionary/?event=SyntheticRequest&attribute=serverIPAddress)値を含むレコードを除外しながら、すべてのレコードの数を返します。

          ```sql
          FROM SyntheticRequest SELECT count(*) 
          WHERE cidrAddress(serverIPAddress, 24) NOT IN ('10.0.0.0/24', '10.10.1.0/24')
          ```
        </Collapser>
      </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="event-type"
    title={<InlineCode>eventType()</InlineCode>
    }
  >
    ```sql
    ...WHERE eventType() = 'EventNameHere'...
    ...FACET eventType()...
    ```

    [`FACET`](#sel-facet)句で`eventType()`関数を使用し、選択したデータ型別に結果を取り出し、または[`WHERE`](#sel-where)句で特定のデータ型に結果をフィルタリングします。これは、[`filter()`](#func-filter)や[`percentage()`](#func-percentage)関数で特定のデータ型を対象とする際に特に便利です。

    <Callout variant="important">
      この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータ型を指します。
    </Callout>

    <CollapserGroup>
      <Collapser
        id="filter-eventtype"
        title={<><InlineCode>
          eventType()
        </InlineCode>を<InlineCode>
          filter()
        </InlineCode>関数で使用</>
        }
      >
        このクエリは、合計`Transaction`の結果あたりの合計`TransactionError`の結果の割合を返します。`eventType()`関数を使用して、`filter()`関数で特定のデータ型をターゲットにすることができます。

        ```sql
        SELECT 100 * filter(count(*), WHERE eventType() = 'TransactionError') / filter(count(*), WHERE eventType() = 'Transaction') 
        FROM Transaction, TransactionError 
        WHERE appName = 'App.Prod' 
        TIMESERIES 2 Minutes SINCE 6 hours ago
        ```
      </Collapser>

      <Collapser
        id="facet-eventtype"
        title={<><InlineCode>
          eventType()
        </InlineCode>を使用 <InlineCode>
          FACET
        </InlineCode></>
        }
      >
        このクエリは、各データ型（`Transaction`および`TransactionError`）が返すレコード数を表示します。

        ```sql
        SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getfield"
    title={<InlineCode>getField(attribute, field)</InlineCode>
    }
  >
    `getField()`関数を使用して、配列から要素を抽出したり、[ディメンションメトリクスデータ](/docs/data-apis/understand-data/metric-data/metric-data-type)などの複合データ型からフィールドを抽出したりできます。

    `getField()` 次の引数を取ります。

    * `attribute` - 配列または複合データ型。
    * `field` - 配列要素のインデックスまたは複合データ型のフィールド名。

    角括弧`[ ]` `getField()`の省略形として使用することもできます。

    <CollapserGroup>
      <Collapser title="配列から要素の抽出">
        <Callout variant="important">
          配列のインデックスは`0`から始まります。
        </Callout>

        **例**\
        `durations`属性に格納されている配列`[100, 110, 90, 100, 105]`を検討します。以下のクエリは`90`を返します。

        ```sql
        SELECT getField(durations, 2) FROM Foo
        ```

        `getField()`省略表記を使用した次のクエリも`90`を返します。

        ```sql
        SELECT durations[2] FROM Foo
        ```
      </Collapser>

      <Collapser title="複合データ型からフィールドの抽出">
        サポートされている複合データ型とそのフィールドは次のとおりです。

        <table>
          <thead>
            <tr>
              <th style={{ width: "500px" }}>
                メトリックタイプ
              </th>

              <th>
                サポートされているフィールド
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                `summary`
              </td>

              <td>
                `count`、`total`、`max`、`min`、 `type`
              </td>
            </tr>

            <tr>
              <td>
                `gauge`
              </td>

              <td>
                `count`、`total`、`max`、`min`、`latest`、 `type`
              </td>
            </tr>

            <tr>
              <td>
                `distribution`
              </td>

              <td>
                `count`、`total`、`max`、`min`、 `type`
              </td>
            </tr>

            <tr>
              <td>
                `count`
              </td>

              <td>
                `count`、 `type`
              </td>
            </tr>

            <tr>
              <td>
                `cumulativeCount`
              </td>

              <td>
                `count`、`cumulative`、 `type`
              </td>
            </tr>

            <tr>
              <td>
                `timeslice`
              </td>

              <td>
                `count`、`total`、`totalExclusive`、`min`、`max`、 `sumOfSquares`
              </td>
            </tr>
          </tbody>
        </table>

        **例**

        ```sql
        SELECT max(getField(mySummary, count)) FROM Metric
        ```

        ```sql
        SELECT sum(mySummary) FROM Metric where getField(mySummary, count) > 10
        ```

        `getField()`の省略表記を使用したクエリ：

        ```sql
        SELECT max(mySummary[count]) FROM Metric
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-getCdfCount"
    title={<InlineCode>getCdfCount(attribute, threshold)</InlineCode>
    }
  >
    `getCdfCount()` は[累積分布関数](https://en.wikipedia.org/wiki/Cumulative_distribution_function)の実装であり、`threshold`以下の`attribute`の値の数を返します。

    許可される閾値は1つだけです。`Attribute`は、数値属性または分布メトリクス属性のいずれかです。1つのクエリ内の混合型が受け入れられます。

    数値型の場合、属性が閾値以下の場合は1を返し、それ以外の場合は0を返します。分布の場合は、分布によって表されるデータセット内のカウントを返します。他のすべての型では、0を返します。

    <CollapserGroup>
      <Collapser title="閾値よりも速く初期表示時間数を取得する">
        このクエリは、`firstPaint`が1秒以下のイベント数を返します。

        ```sql
        FROM PageView SELECT sum(getCdfCount(firstPaint, 1.0))
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-if"
    title={<><InlineCode>
      if(condition, trueValue [, falseValue])
    </InlineCode></>
    }
  >
    `if()`を使用して、クエリ全体でif-then-elseコントロールフロー操作を実行します。

    `if()` 次の3つの引数が必要です。

    * `condition` - `true`またはfalseで評価できる式。 `false`
    * `trueValue` - ブール式が true の場合、この値が返されます。 `true`
    * `falseValue` - ブール式が`false`の場合にこのオプション値が返され、そうでない場合は`NULL`が返されます。

    <CollapserGroup>
      <Collapser title="基本的な使用">
        ```sql
        FROM Log
        SELECT count(*)
        FACET if(level_name = 'ERROR', 'ERROR', 'NOT_ERROR')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>
          AND
        </InlineCode>およびと併用 <InlineCode>
          OR
        </InlineCode></>
        }
      >
        ```sql
        FROM Log
        SELECT count(*)
        FACET if(level_name = 'INFO' OR level_name = 'WARNING', 'NOT_ERROR', 'ERROR')
        ```
      </Collapser>

      <Collapser
        title={<>ネストされた <InlineCode>
          If()
        </InlineCode></>
        }
      >
        ネストされた`if()`関数を使用して、条件付きロジックを追加します。

        ```sql
        FROM Transaction SELECT count(*)
        FACET if(appName LIKE '%java%', 'Java',
            if(appName LIKE '%kafka%', 'Kafka', 'Other'))
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-jparse"
    title={<InlineCode>jparse(attribute [, path])</InlineCode>
    }
  >
    JSON解析関数`jparse()`を使用して文字列値を解析し、NRQLの他のファーストクラスの値型と同様に処理できる値のマップ/リスト（またはネストされた構造）を生成します。

    `jparse()` 次の2つの引数が必要です。

    * `attribute` - JSON文字列値。
    * `path` - `attribute`パラメーター内のJSONの特定の部分を直接参照するために使用されるオプションの文字列値。以下の[JSON解析パス構文リファレンス](#json-parse-path-syntax-reference)のセクションを参照してください。

    `jparse()`関数は、[RFC 8259形式](https://datatracker.ietf.org/doc/html/rfc8259#section-2)に従って JSON値を解析します。`jparse()`関数を`path`パラメーターなしで使用すると、逆シリアル化されたJSON値が返されます。

    角括弧を使用すると、キー/インデックスを介して`jparse()`の結果から個々の値を抽出し、`WITH`句を使用してJSONキーを属性に直接マッピングできます。

    <CollapserGroup>
      <Collapser id="jparse-square-bracket-syntax" title="角括弧構文を使用したキー/インデックスの参照">
        <DNT>
          **Referencing a key**
        </DNT>

        次のクエリは、`jsonString`属性内のキー`userNames`を参照し、`['abc', 'xyz']`を返します。

        ```sql
        WITH '{"userNames": ["abc", "xyz"]}' AS jsonString SELECT jparse(jsonString)[userNames]
        ```

        <DNT>
          **Referencing an index**
        </DNT>

        次のクエリは、`jsonString`属性内のインデックス`0`を参照し、`'abc'`を返します。

        ```sql
        WITH '["abc", "xyz"]' AS jsonString SELECT jparse(jsonString)[0]
        ```
      </Collapser>

      <Collapser id="mapping-json-keys-to-attributes" title="JSONキーを属性にマッピングする">
        次のクエリでは、`WITH`句で`jparse()`を使用してJSONキー`userName`と`id`をNRQL変数にマップし、クエリの残りの部分で使用できるようにします。

        ```sql
        WITH '{"userName": "test", "unused": null, "id": 100}' AS jsonString, jparse(jsonString) AS (userName, id) SELECT userName, id
        ```
      </Collapser>
    </CollapserGroup>

    JSON文字列から特定の値を解析するには、`path`パラメーターを使用できます。

    <Collapser id="json-parse-path-syntax-reference" title="JSON解析パス構文リファレンス">
      JSONデータは、単純ではない形状で複数のレイヤーにネストされるのが一般的です。パス構文を使用すると、JSONデータの特定の部分を直接参照できます。

      データ例：

      ```json
      {
        "valueA": "test",
        "valueB": {
          "nestedValue1": [1, 2, 3],
          "nestedValue2": 100
        },
        "valueC": [
          { "id": 1, "label": "A", "other": 7 },
          { "id": 2, "label": "B", "other": 9 },
          { "id": 3, "label": "C", "other": 13 }
        ]
      }
      ```

      上記のデータを使用したパス構文の例：

      <table id="join-types">
        <thead>
          <tr>
            <th>
              <DNT>
                **Path Syntax Example**
              </DNT>
            </th>

            <th>
              <DNT>
                **Result Description**
              </DNT>
            </th>

            <th>
              <DNT>
                **Result**
              </DNT>
            </th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              `valueA`
            </td>

            <td>
              キーの値を返します
            </td>

            <td>
              `"test"`
            </td>
          </tr>

          <tr>
            <td>
              `["valueA"]`
            </td>

            <td>
              キーの値を返します
            </td>

            <td>
              `"test"`
            </td>
          </tr>

          <tr>
            <td>
              `[valueA, valueC]`
            </td>

            <td>
              キー値のリストを返します
            </td>

            <td>
              `["test", [{"id": 1…}, {"id": 2…}], {"id": 3…}]]`
            </td>
          </tr>

          <tr>
            <td>
              `valueB.nestedValue2`
            </td>

            <td>
              キーの値を返します
            </td>

            <td>
              `100`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[0]`
            </td>

            <td>
              インデックス0のリスト値を返します。 `0`
            </td>

            <td>
              `{"id": 1…}`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[0,2]`
            </td>

            <td>
              インデックス`0`および\{2}のリスト値を返します。 `2`
            </td>

            <td>
              `[{"id": 1…}, {"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[0:2]`
            </td>

            <td>
              2番目のインデックスの値を除いた、最初のインデックスから2番目までのリスト値の範囲を返します。この場合、インデックス`0`と`1`のリスト値が返されます。
            </td>

            <td>
              `[{"id": 1…}, {"id": 2…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[:2]`
            </td>

            <td>
              2番目のインデックスの値を除いた、先頭から2番目のインデックスまでのリスト値の範囲を返します。この場合、インデックス`0`と`1`のリスト値が返されます。
            </td>

            <td>
              `[{"id": 1…}, {"id": 2…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[:-2]`
            </td>

            <td>
              最後の*n*を除くすべてのリスト値を返します。ここで、*n*はコロンの後の負の数です（つまり`[:-n]`）。この場合、インデックス`0`のリスト値が返されます。
            </td>

            <td>
              `[{"id": 1…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[1:]`
            </td>

            <td>
              指定されたインデックスからリストの末尾までのリスト値の範囲を返します。この場合、インデックス`1`と`2`のリスト値が返されます。
            </td>

            <td>
              `[{"id": 2…}, {"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[-1:]`
            </td>

            <td>
              **最後のn個のリスト値を返します。ここで、*n*はコロンの前の負の数です（つまり、`[-n:]`）。この場合、インデックス`2`のリスト値が返されます。
            </td>

            <td>
              `[{"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[*]`
            </td>

            <td>
              すべてのリスト値を返します
            </td>

            <td>
              `[{"id": 1…}, {"id": 2…}, {"id": 3…}]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[*].id`
            </td>

            <td>
              すべてのリストメンバーから指定されたキー値を返します。この場合、「`id`」キーの値です。
            </td>

            <td>
              `[1, 2, 3]`
            </td>
          </tr>

          <tr>
            <td>
              `valueC[*]["label", "other"]`
            </td>

            <td>
              すべてのリストメンバーから指定されたキーを返します。この場合、「`label`」キーおよび「`other`」の値です。
            </td>

            <td>
              `[["A", 7],…]`
            </td>
          </tr>
        </tbody>
      </table>
    </Collapser>

    例：

    <CollapserGroup>
      <Collapser id="basic-jparse-example" title="基本的な例">
        次のクエリは、`jsonString`属性内のJSON文字列を解析します。

        ```sql
        WITH '{"user": {"name": "John", "id": 5}}' AS jsonString SELECT jparse(jsonString)
        ```

        このクエリは、逆シリアル化されたJSON文字列を返します。

        ```json
        {"user":{"name":"John","id":5}}
        ```
      </Collapser>

      <Collapser id="parse-specific-value-from-log-message" title="ログメッセージから特定の値を解析する">
        よくある問題は、ログメッセージ内に構造化された豊富なデータが隠れていることです。[`aparse()`](#func-aparse)と`jparse()`を利用してノイズを取り除き、特定の値を見つけることができます。

        次のクエリ：

        1. `aparse()`を呼び出して、`logMessage`属性からJSONデータを抽出します。
        2. `jparse()`と`user.name`パスパラメーターを使用して、抽出されたJSONデータから`user.name`フィールドを解析します。

        ```sql
        WITH '1693242121842: value=\'{"user": {"name": "John", "id": 5}}\', useless=stuff' AS logMessage, aparse(logMessage, '%: value=\'*\'%') AS jsonString SELECT jparse(jsonString, 'user.name')
        ```
      </Collapser>

      <Collapser id="parse-multiple-values-from-json" title="JSON文字列から複数のネストされた値を解析する">
        次のクエリは、`jsonString`属性内のオブジェクトのリストから各`id`フィールドを解析し、これらの値を配列として出力します。

        ```sql
        WITH '{"users": [{"name": "A", "id": 5}, {"name": "B", "id": 10}]}' AS jsonString, jparse(jsonString, 'users[*].id') AS ids SELECT ids
        ```

        上記のクエリは`[5, 10]`を返します。
      </Collapser>
    </CollapserGroup>

    *関連関数：* [`mapKeys()`](#func-mapKeys)、[`mapValues()`](#func-mapValues)
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-length"
    title={<InlineCode>length（属性）</InlineCode>
    }
  >
    `length()`関数を使用して、文字列値の長さまたは配列値の要素数を返します。

    単一の引数を取ります。

    <CollapserGroup>
      <Collapser title="PageViewからURLの長さを取得する">
        このクエリは、`PageView`イベントから各URL文字列の長さを返します。

        ```sql
        SELECT length(pageUrl) FROM PageView
        ```
      </Collapser>

      <Collapser title="配列の長さを取得する">
        `countries`属性に格納されている配列`["US", "CA", "UK"]`を検討します。

        ```sql
        SELECT length(countries) FROM Foo
        ```

        上記のクエリのlength(countries)は`3`を返します。
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-contains"
    title={<InlineCode>contains(attribute, element)</InlineCode>
    }
  >
    配列内に要素が存在するかどうかを確認するには、 `contains()`関数を使用します。

    `contains()` 次の引数を取ります。

    * `attribute` - 配列
    * `element` - 配列を確認する要素

    <CollapserGroup>
      <Collapser title="配列に要素が含まれているかどうかを確認する">
        `guids`属性に格納されている配列`["9999-1234-9999", "3333-7890-3333", "5555-3456-555"]`を検討します。

        ```sql
        SELECT contains(guids, '5555-3456-555') FROM Foo
        ```

        `contains(guids, '5555-3456-555')` 上記のクエリでは`TRUE`を返します。
      </Collapser>

      <Collapser title="含まれる項目をcount(*)でフィルタリングする">
        `Transaction`イベントタイプ内の`guids`属性に格納されている配列`["9999-1234-9999", "3333-7890-3333", "5555-3456-555"]`を検討します。

        ```sql
        SELECT count(*) FROM Transaction WHERE contains(guids, '9999-1234-9999')
        ```

        上記の記述は、`"9999-1234-9999"` guidを含む一連のカウントを返します。
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-lookup"
    title={<InlineCode>ルックアップ（テーブル）</InlineCode>
    }
  >
    [ルックアップテーブルをアップロード](/docs/logs/ui-data/lookup-tables-ui)した場合、テーブル名でこの機能を使用すると、クエリ内テーブルのデータにアクセスできます。クエリの例を以下に示します。

    ```sql
    FROM Log
    SELECT count(*)
    WHERE hostname IN (FROM lookup(myHosts) SELECT uniques(myHost))
    ```

    詳細については、[ルックアップテーブルデータのクエリ方法](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/lookups)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-lower"
    title={<InlineCode>lower(str)</InlineCode>
    }
  >
    `lower()`関数を使用して、文字列値のアルファベット文字をすべて小文字に変更します。

    引数：

    * `str` - 小文字にする文字列値。

      * これは、引用符内のリテラル文字列、クエリされた文字列属性、文字列を返す関数、または単一の文字列値を返すサブクエリなどの文字列に評価されるものなら何でもかまいません。
      * この引数がnullと評価される場合は、`lower()`関数はnullを返します。

      <CollapserGroup>
        <Collapser title="文字列を小文字にする">
          このクエリは、クエリのさまざまな部分で`lower()`関数を使用する方法を示します。

          ```sql
          FROM PageAction
          SELECT latest(lower(actionName))
          WHERE lower(actionName) = lower('acmePageRenderedEvent') OR lower(actionName) = lower('SubmitLogin')
          FACET concat(actionName, ':', lower(actionName))
          ```

          <img title="screenshot lower()" alt="screenshot lower()" src="/images/lowerExample.webp" />

          <figcaption>
            <InlineCode>
              lower(str)
            </InlineCode> 例
          </figcaption>
        </Collapser>
      </CollapserGroup>

      *関連機能：[<InlineCode>
        upper()
      </InlineCode>](#func-upper)*
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mapKeys"
    title={<InlineCode>mapKeys(attribute)</InlineCode>
    }
  >
    `attribute`パラメーター内の入力としてマップが指定された場合、`mapKeys()`関数を使用してキーのリストを返します。

    <CollapserGroup>
      <Collapser id="extract-list-of-keys" title="JSON文字列内のキーのリストを抽出する">
        ```sql
        WITH '{"userResult1": 100, "userResult2": 200, "userResult3": 4}' AS jsonString SELECT mapKeys(jparse(jsonString)) AS keys
        ```

        上記のクエリ：

        1. `jparse()`関数を使用して、`jsonString`属性内のJSON文字列をマップに逆シリアル化する
        2. `mapKeys()`関数を呼び出して、このマップ内のすべてのキーのリストを抽出する
        3. このキーのリストを`keys`属性にバインドする

        上記のクエリを実行すると、`keys`にはリスト`['userResult1', 'userResult2', 'userResult3']`が含まれます。
      </Collapser>

      <Collapser id="extract-list-of-keys-with-nested-keys" title="ネストされたキーを含むJSON文字列からキーのリストを抽出する">
        ```sql
        WITH '{"value1": "test", "value2": {"nestedValue1": [1, 2, 3], "nestedValue2": 100}}' AS jsonString SELECT mapKeys(jparse(jsonString)) AS keys
        ```

        上記のクエリは、`jsonString`属性内のJSON文字列から最も外側のキーのみを抽出します。クエリを実行すると、`keys`にはリスト`['value1', 'value2']`が含まれます。
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mapValues"
    title={<InlineCode>mapValues(attribute)</InlineCode>
    }
  >
    `attribute`パラメーター内の入力としてマップが指定された場合、`mapValues()`関数を使用して値のリストを返します。

    <CollapserGroup>
      <Collapser id="extract-list-of-values" title="JSON文字列内の値のリストを抽出する">
        ```sql
        WITH '{"userResult1": 100, "userResult2": 200, "userResult3": 4}' AS jsonString SELECT mapValues(jparse(jsonString)) AS values
        ```

        上記のクエリ：

        1. `jparse()`関数を使用して、`jsonString`属性内のJSON文字列をマップに逆シリアル化する
        2. `mapValues()`関数を呼び出して、このマップ内のすべての値のリストを抽出する
        3. この値のリストを`values`属性にバインドする

        上記のクエリを実行すると、`values`にはリスト`[100, 200, 4]`が含まれます。
      </Collapser>

      <Collapser id="extract-list-of-values-with-nested-values" title="ネストされた値を含むJSON文字列から値のリストを抽出する">
        ```sql
        WITH '{"value1": "test", "value2": {"nestedValue1": [1, 2, 3], "nestedValue2": 100}}' AS jsonString SELECT mapValues(jparse(jsonString)) AS values
        ```

        上記のクエリは、`jsonString`属性内のJSON文字列から最も外側の値を抽出します。クエリを実行すると、`values`には`"test"`文字列とネストされたオブジェクトのリストが含まれます。

        これはJSONビューで確認できます。

        ```json
        "contents": [
          {
            "function": "alias",
            "alias": "values",
            "contents": {
              "constant": [
                "test",
                {
                  "nestedValue1": [
                    1,
                    2,
                    3
                  ],
                  "nestedValue2": 100
                }
              ]
            }
          }
        ],
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-minOf"
    title={<InlineCode>minutesOf（属性）、hourOf（属性）など。</InlineCode>
    }
  >
    `minuteOf()`関数を使用して、有効なタイムスタンプ値を持つ属性の分の部分（つまり、0〜59分）のみを抽出します。これは、`hourOf()`、`weekOf()`などの関数でも機能します。時間ベースの関数の完全なリストについては、[時間範囲で結果をグループ化のドキュメント](/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-group-results-across-time/#cohorts)の表を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-mod"
    title={<InlineCode>mod(attribute, divisor)</InlineCode>
    }
  >
    与えられた数値属性の値（最初の引数、すなわち被除数）を数値（2つ目の引数、すなわち除数）で割った後、`mod()`関数を使用してfloor係数を返します。このモジュロ演算は、`WHERE`句の条件内で使用して結果の任意のサブセットにフィルターしたり、`FACET`句で結果セットをさらに分割したりする方法として使用できます。

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          mod()
        </InlineCode> <InlineCode>
          WHERE
        </InlineCode>句条件内</>
        }
      >
        ```sql
        FROM Transaction SELECT * WHERE mod(port, 2) = 1
        ```
      </Collapser>
    </CollapserGroup>

    <CollapserGroup>
      <Collapser
        title={<><InlineCode>
          mod()
        </InlineCode> <InlineCode>
          FACET
        </InlineCode>句内</>
        }
      >
        ```sql
        FROM NrConsumption SELECT uniques(hostId, 10000) 
        SINCE 1 day AGO FACET mod(hostId, 10)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-position"
    title={<InlineCode>position(str, substr [, occurrence])</InlineCode>
    }
  >
    `position()`関数を使用して、文字列内の部分文字列の位置を見つけます。一致では大文字と小文字が区別されます。

    引数：

    * `str` - 部分文字列を検索する文字列。

      * これは、引用符内のリテラル文字列、クエリされた文字列属性、文字列を返す関数、または単一の文字列値を返すサブクエリなどの文字列に評価されるものなら何でもかまいません。

    * `substr` - 文字列内で検索する文字列。

    * `occurrence` - 部分文字列の出現する位置を返します。

      * *デフォルト*： `0`
      * 正の場合、ゼロベースで文字列の先頭からn番目に出現する部分文字列を検索します。
      * 負の場合、文字列の末尾からn番目に出現する部分文字列を検索します。最後に出現する部分文字列は-1になります。

      Alias：<InlineCode>
        indexOf(str, substr \[, occurrence])
      </InlineCode> - `indexOf()`は`position()`関数の代替名です

      戻り値：

      * 文字列内での部分文字列の開始文字の0ベースのインデックス
      * strがnull、substrがnull、または参照されたsubstrが見つからない場合は、Nullが返されます。

    <CollapserGroup>
      <Collapser title="URL内の部分文字列の位置インデックスを検索します。">
        このクエリは、<InlineCode>
          position()
        </InlineCode>関数を使用して文字列内のさまざまな部分文字列の位置インデックスを検索する方法を示します。ここでは、[<InlineCode>
          position()
        </InlineCode>](#func-substring)関数の引数内での<InlineCode>
          substring()
        </InlineCode>関数の使用も示します。

        ```sql
        FROM PageView
        WITH position(pageUrl, ':') AS FirstColon,
          position(pageUrl, '/', 1) + 1 AS DomainBegin, 
          position(pageUrl, '/', 2) AS DomainEnd, 
          DomainEnd - DomainBegin AS DomainLength
        SELECT pageUrl, FirstColon, substring(pageUrl, 0, FirstColon) AS Protocol,
          DomainBegin, DomainEnd, DomainLength, substring(pageUrl, DomainBegin, DomainLength) AS Domain,
          position(pageUrl, '/', -1) AS LastSlash, 
          substring(pageUrl, position(pageUrl, '/', -1)) AS PathEnd
        ```

        <img title="screenshot position()" alt="screenshot position()" src="/images/positionExample.webp" />

        <figcaption>
          <InlineCode>
            position(str, substr \[, occurrence])
          </InlineCode> 例
        </figcaption>
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="round"
    title={<InlineCode>round(attribute)</InlineCode>
    }
  >
    `round()`関数を使用して、属性の丸め値を返します。

    オプションで、`round()`は2番目の引数`to_nearest`を取り、最初の引数を2番目の引数の最も近い倍数に切り上げます。`to_nearest`は分数にすることができます。

    ```sql
    SELECT round(n [, to_nearest])
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="stddev"
    title={<InlineCode>stddev(attribute)</InlineCode>
    }
  >
    `stddev()`関数を使用して、指定された時間範囲内に記録された数値属性の[標準偏差値](https://en.wikipedia.org/wiki/Standard_deviation)を返します。単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="abs"
    title={<InlineCode>abs(attribute)</InlineCode>
    }
  >
    `abs()`関数を使用して、 `attribute`の[絶対値](https://en.wikipedia.org/wiki/Absolute_value)を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="floor"
    title={<InlineCode>floor(attribute)</InlineCode>
    }
  >
    `floor()`関数を使用して、切り捨てにより`attribute`に最も近い整数を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="ceil"
    title={<InlineCode>ceil(attribute)</InlineCode>
    }
  >
    `ceil()`関数を使用して、切り上げて`attribute`に最も近い整数を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="clamp_max"
    title={<InlineCode>clamp_max(attribute, limit)</InlineCode>
    }
  >
    `clamp_max()`関数を使用して、 `attribute`の値に上限を設定します。

    `clamp_max()` 次の引数を取ります。

    * `attribute` - 数値属性。
    * `limit` - `attribute`値の上限。

    **例**\
    `clamp_max()`を使用すると、外れ値によって時系列グラフのスケールが歪まないようにすることができます。

    ```sql
      SELECT clamp_max(average(duration), 10) FROM Transaction TIMESERIES
    ```

    上記のクエリは、10を超えない限り`duration`を返しますが、10を超える場合は10を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="clamp_min"
    title={<InlineCode>clamp_min(attribute, limit)</InlineCode>
    }
  >
    `clamp_min()`関数を使用して、 `attribute`の値に下限を設定します。

    `clamp_min()` 次の引数を取ります。

    * `attribute` - 数値属性。
    * `limit` - `attribute`値の下限。

    **例**\
    `clamp_min()`を使用すると、外れ値によって時系列グラフのスケールが歪まないようにすることができます。

    ```sql
      SELECT clamp_min(average(duration), 1) FROM Transaction TIMESERIES
    ```

    上記のクエリは、1未満の場合は1を返しますが、1未満の場合は`duration`を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="pow"
    title={<InlineCode>pow(attribute, exponent)</InlineCode>
    }
  >
    `pow()`関数を使用して、 `attribute`を`exponent`累乗します。

    `pow()` 次の引数を取ります。

    * `attribute` - 数値属性。
    * `exponent` - `attribute`を累乗する数値属性。

    **例**\
    以下のクエリは、`duration`の4乗を返します。

    ```sql
      SELECT pow(duration, 4) FROM Transaction
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sqrt"
    title={<InlineCode>sqrt(attribute)</InlineCode>
    }
  >
    `sqrt()`関数を使用して、 `attribute`の[平方根](https://en.wikipedia.org/wiki/Square_root)を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="exp"
    title={<InlineCode>exp(attribute)</InlineCode>
    }
  >
    `exp()`関数を使用して、 `attribute`の[自然指数関数](https://en.wikipedia.org/wiki/Exponential_function)を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="ln"
    title={<InlineCode>ln(attribute)</InlineCode>
    }
  >
    `ln()`関数を使用して、 `attribute`の[自然対数](https://en.wikipedia.org/wiki/Natural_logarithm)を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="log2"
    title={<InlineCode>log2(attribute)</InlineCode>
    }
  >
    `log2()`関数を使用して、 `attribute`の[2を底とする対数](https://en.wikipedia.org/wiki/Binary_logarithm)を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="log10"
    title={<InlineCode>log10(attribute)</InlineCode>
    }
  >
    `log10()`関数を使用して、 `attribute`の[10を底とする対数](https://en.wikipedia.org/wiki/Common_logarithm)を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="log"
    title={<InlineCode>log(attribute, base)</InlineCode>
    }
  >
    `log()`関数を使用して、底が`base`である`attribute`の対数を計算します。

    `log()` 次の引数を取ります。

    * `attribute` - 数値属性。
    * `base` - `attribute`の対数を計算するときに底として使用する数値属性。

    **例**\
    以下のクエリは、4を底とする`duration`の対数を計算します。

    ```sql
      SELECT log(duration, 4) FROM Transaction
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-string"
    title={<InlineCode>string(attribute [, precision: ])</InlineCode>
    }
  >
    `string()`関数を使用して、数値、ブーリアン値、タプル値、または配列値を文字列値に変換します。

    次の2つの引数を取り、1つはオプションです。

    * 属性名
    * 精度：存在する場合、浮動小数点数値を変換する際に含まれる小数点以下の桁数に制限を適用します。

    <CollapserGroup>
      <Collapser title="文字列以外のクエリ結果を文字列値として取得">
        このクエリは、PageView期間を小数第2位までの文字列として返します。

        ```sql
        FROM PageView SELECT string(duration, precision: 2)
        ```
      </Collapser>

      <Collapser title="文字列以外の集計関数の結果を文字列値として取得">
        このクエリは、PageView期間の平均を小数第2位までの文字列として返します。

        ```sql
        FROM PageView SELECT string(average(duration), precision: 2)
        ```
      </Collapser>

      <Collapser title="切り捨てなしの浮動小数点数によるファセットクエリの結果">
        `string()`を使用して、小数点以下の桁数を失うことなく浮動小数点値でファセットします。

        ```sql
        FROM PageView SELECT count(*) 
        FACET string(tuple(asnLatitude, asnLongitude), precision: 2)
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-substring"
    title={<InlineCode>substring(str, start [, length])</InlineCode>
    }
  >
    `substring()`関数を使用して文字列の一部を抽出します。

    引数：

    * `str` - 部分文字列を抽出する文字列。

      * これは、引用符内のリテラル文字列、クエリされた文字列属性、文字列を返す関数、または単一の文字列値を返すサブクエリなどの文字列に評価されるものなら何でもかまいません。
      * この引数がnullと評価される場合は、`substring()`関数はnullを返します。

    * `start` - 抽出を開始する文字列内の位置。

      * 文字列の最初の文字位置は0です。
      * 負の値は、文字列の末尾の文字位置が-1で、文字列の末尾に相対的な位置を検索します。
      * startが文字列の長さより長いか等しい場合、`substring()`関数は空の文字列を返します。
      * startが負で、その絶対値が文字列の長さより長い場合、抽出された部分文字列の位置は0から開始されます。

    * `length` - 文字列から抽出する部分文字列の長さまたは文字数。

      * *オプション* - 長さが指定されていない場合、解決された開始位置の後の文字列のすべての文字が含まれます。

      <CollapserGroup>
        <Collapser title="文字列のさまざまな部分を抽出">
          このクエリはセッション値の一部を返します。

          ```sql
          FROM PageView
          SELECT session, substring(session, 0, 3) AS First3,
            substring(session, 3) AS After3rd,
            substring(session, -3) AS Last3
          ```

          <img title="screenshot substring()" alt="screenshot substring()" src="/images/substringExample.webp" />

          <figcaption>
            <InlineCode>
              substring(str, start \[, length])
            </InlineCode> 例
          </figcaption>
        </Collapser>
      </CollapserGroup>

      *<InlineCode>
        position()
      </InlineCode>と<InlineCode>
        substring()
      </InlineCode>を一緒に使用する例については、[<InlineCode>
        position()
      </InlineCode>](#func-position)関数を参照してください。*
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-toDatetime"
    title={<InlineCode>toDatetime(timestamp[, pattern [, timezone]])</InlineCode>
    }
  >
    `toDatetime()`関数を使用して、タイムスタンプを書式設定されたdatetime文字列に変換します。

    `toDatetime()` 次の引数を取ります。

    * `timestamp` - datetime文字列に変換される数値タイムスタンプ。これは数値または属性にすることができ、内部的に`long`に変換されます。
    * `pattern` - 結果のフォーマットに使用されるオプションの日時パターン。パターン文字列の構築方法については、[DatetimeFormatterドキュメント](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html)の*書式設定と解析のパターン*のセクションを参照してください。
      * これは定数文字列値である必要があり、パターンが指定されていない場合はデフォルトの`yyyy-MM-dd'T'HH:mm:ss.SSSXXX`になります
    * `timezone` - datetime文字列を解釈するために使用されるオプションのタイムゾーン値（例：UTC）。
      * これは定数文字列値である必要があり、デフォルトはUTC、または利用可能な場合は`WITH TIMEZONE`で指定された値になります

    入力が有効な数値である限り、`toDatetime()`関数は常に値を返します。

    Alias：`fromTimestamp()`は`toDatetime()`関数の代替名です。

    例：

    <CollapserGroup>
      <Collapser title="デフォルトのパターンを使用してタイムスタンプを変換する">
        次のクエリは、デフォルトのパターン`yyyy-MM-dd'T'HH:mm:ss.SSSXXX`を使用して`timestampValue`属性を変換します。これにより、datetime文字列`1970-01-01T00:20:34.567Z`が返されます。

        ```sql
        WITH 1234567 AS timestampValue SELECT toDatetime(timestampValue)
        ```
      </Collapser>

      <Collapser title="タイムゾーンパラメーターを使用してタイムスタンプを変換する">
        次のクエリは、タイムゾーンが「America/Los\_Angeles」に設定されたパターン文字列`yyyy-MM-dd`を使用して、 `timestampValue`属性を変換します。これにより、datetime文字列`1969-12-31`が返されます。

        ```sql
        WITH 1234567 AS timestampValue SELECT toDatetime(timestampValue, 'yyyy-MM-dd', timezone:'America/Los_Angeles')
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>
          WITH TIMEZONE
        </InlineCode>句のタイムゾーンを使用してタイムスタンプを変換する</>
        }
      >
        次のクエリは、`WITH TIMEZONE`句で指定されたタイムゾーンを使用して`timestampValue`属性を変換します。これにより、datetime文字列`1969-12-31`が返されます。

        ```sql
        WITH 1234567 AS timestampValue SELECT toDatetime(timestampValue, 'yyyy-MM-dd') FROM Event WITH TIMEZONE 'America/Los_Angeles'
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-toTimestamp"
    title={<InlineCode>toTimestamp(datestring[, pattern [, timezone]])</InlineCode>
    }
  >
    `toTimestamp()`関数を使用して、datetime文字列からタイムスタンプをエポックミリ秒単位で解析します。

    `toTimestamp()` 次の引数を取ります。

    * `datestring` - タイムスタンプ（エポックミリ秒）に変換されるdatetime文字列。これには、文字列属性または引用符で囲まれた文字列リテラルを指定できます
    * `pattern` - datestringパラメーターの解析に使用されるオプションの日時パターン。パターン文字列の構築方法については、[DatetimeFormatterドキュメント](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html)の*書式設定と解析のパターン*のセクションを参照してください。
      * これは定数文字列値である必要があり、パターンが指定されていない場合はデフォルトの`yyyy-MM-dd'T'HH:mm:ss[.SSS][XXX]`になります
    * `timezone` - datestringパラメーターを解釈するために使用されるオプションのタイムゾーン値（例：PST）。
      * これは定数文字列値である必要があり、デフォルトはUTC、または利用可能な場合は`WITH TIMEZONE`で指定された値になります

    Alias：`fromDatetime()`は`toTimestamp()`関数の代替名です。

    <Callout variant="tip">
      見つかった文字列が指定されたパターンと一致しない場合は、`null`が返されます。さまざまなパターンのdatetime文字列がある場合は、`OR`を使用して値の 1 つがnull以外になるまでカスケードすることにより、結果を結合できます。オプションのパターンセグメントを使用することもできます。デフォルトのパターンでは、角括弧を使用して、ミリ秒とゾーンオフセットの部分をオプションにします。
    </Callout>

    <CollapserGroup>
      <Collapser id="partial-datetime-interpretation" title="datetime文字列を解析する際の部分的な日時解釈">
        <table>
          <thead>
            <tr>
              <th>
                シナリオ
              </th>

              <th>
                詳細
              </th>

              <th>
                サンプルパターン
              </th>

              <th>
                サンプル日時
              </th>

              <th>
                解決後
              </th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                タイムゾーンがありません
              </td>

              <td>
                タイムゾーン引数、または`WITH TIMEZONE`値を使用します。デフォルトは`UTC`です。
              </td>

              <td>
                yyyy-MM-dd HH:mm:ss.SSS
              </td>

              <td>
                2023-10-18 15:27:03.123
              </td>

              <td>
                2023-10-18T15:27:03.123Z
              </td>
            </tr>

            <tr>
              <td rowspan="8">
                日時フィールドがありません
              </td>

              <td rowspan="8">
                欠落している時刻フィールドは0に置き換えられます。欠落している日付フィールドは1に置き換えられます。フィールドが存在する場合は、より優先順位の高いフィールドもすべて存在する必要があります。<br />注：日付と四半期のパターンがサポートされています。
              </td>

              <td>
                yyyy-MM-dd HH:mm:ss
              </td>

              <td>
                2023-10-18 15:27:03
              </td>

              <td>
                2023-10-18T15:27:03.000Z
              </td>
            </tr>

            <tr>
              <td>
                yyyy-MM-dd HH:mm
              </td>

              <td>
                2023-10-18 15:27
              </td>

              <td>
                2023-10-18T15:27:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                yyyy-MM-dd HH
              </td>

              <td>
                2023-10-18 15
              </td>

              <td>
                2023-10-18T15:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                yyyy-MM-dd
              </td>

              <td>
                2023-10-18
              </td>

              <td>
                2023-10-18T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                yyyy &apos;day&apos; D
              </td>

              <td>
                2023 day 291
              </td>

              <td>
                2023-10-18T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                yyyy-MM
              </td>

              <td>
                2023-10
              </td>

              <td>
                2023-10-01T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                yyyyqqq
              </td>

              <td>
                2023 Q4
              </td>

              <td>
                2023-10-01T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                yyyy
              </td>

              <td>
                2023
              </td>

              <td>
                2023-01-01T00:00:00.000Z
              </td>
            </tr>

            <tr>
              <td rowspan="3">
                時間のみ
              </td>

              <td rowspan="3">
                日付なしで時刻パターンが使用された場合、ミリ秒単位のUnixタイムスタンプが計算されます。<br />注：タイムゾーンの調整は引き続き適用されます。
              </td>

              <td>
                HH:mm
              </td>

              <td>
                00:30
              </td>

              <td>
                1971-01-01T00:30:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                HH:mm O
              </td>

              <td>
                00:30 GMT-1
              </td>

              <td>
                1971-01-01T01:30:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                HH:mm O
              </td>

              <td>
                00:30 GMT+1
              </td>

              <td>
                1969-12-31T23:30:00.000Z
              </td>
            </tr>

            <tr>
              <td rowspan="3">
                12時間
              </td>

              <td rowspan="3">
                12時間パターン（小文字のh）が使用される場合は、am/pmのパターン（a）も使用する必要があります。<br />注：datetime文字列内ではAM/PMは大文字である必要があります。
              </td>

              <td>
                yyyy-MM-dd h:mm a
              </td>

              <td>
                2023-10-18 3:27 PM
              </td>

              <td>
                2023-10-18T15:27:00.000Z
              </td>
            </tr>

            <tr>
              <td>
                yyyy-MM-dd h:mm
              </td>

              <td>
                2023-10-18 3:27
              </td>

              <td>
                サポートされていないパターン
              </td>
            </tr>

            <tr>
              <td>
                yyyy-MM-dd h:mm a
              </td>

              <td>
                2023-10-18 3:27 pm
              </td>

              <td>
                null（pmが小文字のため）
              </td>
            </tr>

            <tr>
              <td>
                フィールドの優先順位
              </td>

              <td>
                フィールドが存在する場合は、より優先順位の高いフィールドもすべて存在する必要があります。
              </td>

              <td>
                yyyydd
              </td>

              <td>
                2023 18
              </td>

              <td>
                サポートされていないパターン（ddは月の日であり、月が欠落しています）
              </td>
            </tr>
          </tbody>
        </table>
      </Collapser>
    </CollapserGroup>

    例：

    <CollapserGroup>
      <Collapser title="デフォルトのパターンを使用してdatetime文字列を解析する">
        次のクエリは、デフォルトのパターン`yyyy-MM-dd'T'HH:mm:ss[.SSS][XXX]`を使用して、datetime文字列「2023-10-18T15:27:03.123Z」を解析します。これにより、タイムスタンプ値`1697642823123`が返されます。

        ```sql
        SELECT toTimestamp('2023-10-18T15:27:03.123Z') 
        FROM Event
        ```
      </Collapser>

      <Collapser title="タイムゾーンパラメーターを使用してdatetime文字列を解析する">
        次のクエリは、タイムゾーンを「America/Los\_Angeles」に設定してdatetime文字列「2023-11-03 11:00:32」を解析します。これにより、タイムスタンプ値`1699034432000`が返されます。

        ```sql
        SELECT toTimestamp('2023-11-03 11:00:32', 'yyyy-MM-dd HH:mm:ss', timezone:'America/Los_Angeles') 
        FROM Event
        ```
      </Collapser>

      <Collapser
        title={<><InlineCode>
          WITH TIMEZONE
        </InlineCode>句のタイムゾーンを使用してdatetime文字列を解析する</>
        }
      >
        次のクエリは、`WITH TIMEZONE`句で指定されたタイムゾーンを使用して、datetime文字列「2023-11-03 11:00:32」を解析します。これにより、タイムスタンプ値`1699034432000`が返されます。

        ```sql
        SELECT toTimestamp('2023-11-03 11:00:32', 'yyyy-MM-dd HH:mm:ss') 
        FROM Event WITH TIMEZONE 'America/Los_Angeles'
        ```
      </Collapser>
    </CollapserGroup>

    <Callout variant="important">
      UIは、`toTimestamp()`値をタイムスタンプとして自動的に検出し、日時値としてフォーマットします。実際の数値タイムスタンプを表示するには、`toTimestamp()`関数を`string()`関数でラップします。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-upper"
    title={<InlineCode>upper(str)</InlineCode>
    }
  >
    `upper()`関数を使用して、文字列値のアルファベット文字をすべて大文字に変更します。

    引数：

    * `str` - 大文字にする文字列値。

    * これは、引用符内のリテラル文字列、クエリされた文字列属性、文字列を返す関数、または単一の文字列値を返すサブクエリなどの文字列に評価されるものなら何でもかまいません。

    * この引数がnullと評価される場合は、`upper()`関数はnullを返します。

      <CollapserGroup>
        <Collapser title="文字列を大文字にする">
          このクエリは、クエリのさまざまな部分で`upper()`関数を使用する方法を示します。

          ```sql
          FROM PageAction
          SELECT latest(upper(actionName))
          WHERE upper(actionName) = upper('acmePageRenderedEvent') OR upper(actionName) = upper('SubmitLogin')
          FACET concat(actionName, ':', upper(actionName))
          ```

          <img title="screenshot upper()" alt="screenshot upper()" src="/images/upperExample.webp" />

          <figcaption>
            <InlineCode>
              upper(str)
            </InlineCode> 例
          </figcaption>
        </Collapser>
      </CollapserGroup>

      *関連関数：[<InlineCode>
        lower()
      </InlineCode>](#func-lower)*
  </Collapser>
</CollapserGroup>

## データ型変換 [#type-conversion]

NRQLは「型強制」をサポートしていません。つまり、文字列として保存されたフロートは文字列として取り扱われ、フロート値を要求する関数に渡しても操作できません。

以下に示す関数で、数値を伴う文字列、または文字列を伴うブーリアン値を同等の数値またはブーリアン値に変換したり、文字列以外の値を文字列値に変換したりできます。

* `numeric()`関数を使用して、文字列形式の数値を数値に変換します。この関数は、クエリ結果に対して数学関数を使用するクエリ、または`average()`などの NRQL集計関数に組み込むことができます。NRQLの値が[ゲージ形式](/docs/data-apis/understand-data/metric-data/metric-data-type/)の場合、 `numeric()`は機能しないことに注意してください。代わりに、次の互換性のあるクエリ関数のいずれかを使用する必要があります。
* `latest()`
* `min()`
* `max()`
* `sum()`
* `count()`
* `average()`
* `boolean()`関数を使用して、`"true"`または`"false"`の文字列値を対応するブーリアン値に変換します。
* `string()`関数を使用して、数値、ブーリアン値、タプル値、または配列値を文字列値に変換します。詳細については、上記の[`string()`](#func-string)を参照してください。

## コメント [#comments]

NRQLクエリを記述する際にコメントを追加すると、チームメンバーがクエリをさらに理解して使用できるようになります。

構文の詳細は以下のとおりです。

* `--` 2つのダッシュは、同じ行にあるこのインジケーターの右側にあるすべてのテキストをコメントアウトします。
* `//` 2つのスラッシュは、同じ行にあるこのインジケーターの右側にあるすべてのテキストをコメントアウトします。
* `/* */` これらの文字セットの間にあるテキストはすべてコメントアウトされます。このインジケーターは複数の行に適用できます。

コメントはどこにでも表示されるわけではありません。「最近のクエリ」や「クエリを表示」などの一部のビューにはコメントは表示されません。

コメントを含むクエリの例：

```sql
FROM Transaction SELECT uniqueCount(appId) -- This will return the number of unique App IDs
```

```sql
FROM TransactionError
SELECT count(*) SINCE 1 day ago // Transaction Error for the past day
```

```sql
FROM TransactionTrace /* This data may be incomplete;
If so, run a query of Transaction */
SELECT count(*)
```

## 関連ドキュメント [#related-docs]

NRQL構文とルールを理解するためのその他の人気リソースには、以下が含まれます。

* New Relic Universityの[NRQL教育コース](https://learn.newrelic.com/writing-nrql-queries)
* [`Metric`データ型のクエリ方法を習得](/docs/telemetry-data-platform/get-data/apis/query-metric-data-type)
* [サブクエリを使用](/docs/query-your-data/nrql-new-relic-query-language/get-started/subqueries-in-nrql)
* [ファネルを使用して一連の関連データを評価する](/docs/insights/new-relic-insights/features/funnels)