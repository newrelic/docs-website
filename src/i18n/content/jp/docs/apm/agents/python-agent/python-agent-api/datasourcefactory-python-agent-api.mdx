---
title: data_source_factory (PythonエージェントAPI)
type: apiDoc
shortDescription: ファクトリーとして定義されたデータソースをラップします。
tags:
  - Agents
  - Python agent
  - Python agent API
metaDescription: 'Python API: This call is used to wrap a data source defined as a factory.'
translationType: machine
---

## 構文

```py
data_source_factory(name=None, **properties)
```

ファクトリーとして定義されたデータソースをラップします。

## 説明

データ ソース API は、 `record_custom_metric`によって実装される [](/docs/data-analysis/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#timeslice-data)[プッシュ スタイル API](/docs/agents/python-agent/supported-features/python-custom-metrics#push-versus-pull-interfaces) ではなく、プル スタイル API を使用してメトリクスのタイムスライス データを生成する方法を提供します。カスタム メトリックにデータ ソースを使用する理由とその方法の詳細については、 [「カスタム メトリック データ ソース」](/docs/agents/python-agent/supported-features/python-custom-metrics#custom-metric-data-sources)を参照してください。

`data_source_factory` デコレータは、ファクトリとして定義されたデータ ソースをラップします。デコレータはクラスまたは関数に適用できます。クラス コンストラクターまたは関数は、 `settings` (データ ソースの構成設定) と `environ` (データ ソースが使用されているコンテキストに関する情報) の引数を受け入れる必要があります。

結果として得られるオブジェクトは、各サンプルのメトリクスを持つイテレート可能なジェネレータを直接返す呼び出し可能なものでなければなりません。

## パラメーター

<table>
  <thead>
    <tr>
      <th width="25%">
        パラメータ
      </th>

      <th>
        説明
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `name`

        _ストリング_
      </td>

      <td>
        オプションです。データソースの名前です。これはロギングの目的でのみ使用されます。提供されていない場合は、装飾された関数から派生した呼び出し可能な名前がデフォルトとなります。
      </td>
    </tr>

    <tr>
      <td>
        `properties`

        _辞書_
      </td>

      <td>
        オプションです。データソース・ファクトリに渡す追加のプロパティ。

        辞書に登録できるフィールドは以下の通りです。

        * `count`
        * `total`
        * `min`
        * `max`
        * `sum_of_squares`
      </td>
    </tr>
  </tbody>
</table>

## 戻り値

関数を返します。

## 例

### data_source_factoryの例 [#example]

例を挙げると

```py
import os
import time
import multiprocessing

@newrelic.agent.data_source_factory(name='CPU Usage')
class CPUMetricsDataSource(object):

    def __init__(self, settings, environ):
        self.last_timestamp = None
        self.times = None
 
    def start(self):
        self.last_timestamp = time.time()
        self.times = os.times()
 
    def stop(self):
        self.last_timestamp = None
        self.times = None

    def __call__(self):
        if self.times is None:
            return

        now = time.time()
        new_times = os.times()
        elapsed_time = now - self.last_timestamp
        user_time = new_times[0] - self.times[0]
        utilization = user_time / (elapsed_time*multiprocessing.cpu_count())
        self.last_timestamp = now
        self.times = new_times

        yield ('Custom/CPU/User Time', user_time)
        yield ('Custom/CPU/User/Utilization', utilization)

newrelic.agent.register_data_source(CPUMetricsDataSource)
```