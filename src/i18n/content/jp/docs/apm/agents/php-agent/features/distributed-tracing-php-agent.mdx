---
title: PHPエージェントの分散型トレーシング
tags:
  - Agents
  - PHP agent
  - Features
metaDescription: 'For New Relic''s PHP agent: how to enable distributed tracing and manually instrument applications to get them to show up in a distributed trace.'
translationType: machine
---

<Callout variant="important">
  PHP Agentバージョン9.21.0.311以降、分散トレースはデフォルトで有効になっており、スパン数はデフォルトで2000、最大で10000に設定できるようになりました。これにより、非推奨となるクロスアプリケーショントレースが置き換えられます。分散トレース設定が取り込みのニーズに対応していることを確認してください。
</Callout>

New Relic の PHP エージェントは、 [分散型トレース](/docs/apm/distributed-tracing/getting-started/introduction-distributed-tracing) (PHP エージェント バージョン 9.8 以降、 [W3C Trace Context](/docs/understand-dependencies/distributed-tracing/get-started/introduction-distributed-tracing#w3c-support) を含む) をサポートしています。これにより、リクエストが分散システムを通過する際の経路を確認することができます。このドキュメントでは、PHP アプリケーションやサービスで分散型トレースを有効にするための PHP 固有のヒントを紹介します。

## PHPの分散型トレーシングを有効にする [#enable-distributed]

<Callout variant="important">
  分散トレースを有効にすると、アプリケーション間のトレースが暗黙的に無効になります。 PHPエージェントは、 [クロスアプリケーショントレース構成値](/docs/agents/php-agent/configuration/php-agent-configuration#inivar-cross-app-tracer-enabled)を無視し、この値が`false`に設定されているかのように動作します。
</Callout>

PHP エージェントの分散トレースを有効または無効にするには、以下の手順に従います。

1. [該当する場合は、PHPエージェント](/docs/agents/php-agent/installation/upgrade-php-agent) をアップデートして、分散型トレーシングをサポートするようにしてください（バージョン8.4以降、ただし、最も完全な機能を得るためにはバージョン9.8以降を推奨します）。

2. [トランザクショントレーサー](/docs/agents/php-agent/configuration/php-agent-configuration#inivar-tt-settings)構成オプションが有効になっていることを確認します（デフォルトは`true` ）。

   ```
   newrelic.transaction_tracer.enabled = true
   ```

3. [`distributed_tracing_enabled`](/docs/agents/php-agent/configuration/php-agent-configuration#inivar-distributed-enabled)構成オプションを使用してPHPエージェントの分散トレースを有効（または無効）にします。

   ```
   newrelic.distributed_tracing_enabled = true
   ```

4. [トランザクショントレーサーの閾値](/docs/agents/php-agent/configuration/php-agent-configuration#inivar-tt-threshold) の値を適切な値に設定する。 **推奨。**

   * すべてのトランザクションを分散トレースの対象にする場合は、この値を`0`秒に設定します。
   * 実行時間の長いトランザクションのトレースのみに関心がある場合、またはトランザクションごとにトレースを生成すると許容できないアプリケーションパフォーマンスが発生する場合は、この値を`0`秒より高く設定します。

   例えば：

   ```
   newrelic.transaction_tracer.threshold = 0
   ```

5. オプションで、W3Cトレースコンテキストトレースのみが必要な場合は、 `newrelic.distributed_tracing_exclude_newrelic_header`構成オプションを使用してNew RelicDistributedTracingヘッダーを無効にできます。

   `newrelic.distributed_tracing_exclude_newrelic_header = 1`

6. コンフィグレーションの設定でスパンを有効にします。

   newrelic.span_events_enabled = true

7. エージェントが新しく設定された値を取り込むために、必ずウェブサーバー（またはその他のPHP SAPI）を再起動してください。

## インフィニット トレースの有効化

Infinite Tracing (PHP エージェント バージョン 9.12 以降) は、分散型トレーシングを拡張し、New Relic Edge と呼ばれる AWS 上のサービスクラスタで動作するトレースオブザーバーにスパンデータを収集します。PHP エージェントは、すべてのスパンをトレースオブザーバーに送信し、それらをトレースにまとめて New Relic で表示できるようにします。

Infinite Tracingを有効にするには、分散型トレーシングを有効にし、以下の追加設定を行います。

newrelic.span_events_enabled = true  
newrelic.infinite_tracing.trace_observer.host="<var> YOUR_TRACE_OBSERVER_HOST"</var>

## 自動分散型トレーシング装置の活用

PHPエージェントは、いくつかのネイティブなPHP関数やサードパーティのHTTPクライアントを自動的に計測し、分散されたトレース情報を提供します。これらは以下の通りです。

* PHP関数[`file_get_contents`](http://php.net/manual/en/function.file-get-contents.php)
* PHP関数[`curl_exec`](http://php.net/manual/en/function.curl-exec.php)および[`curl_multi_exec`](http://php.net/manual/en/function.curl-multi-exec.php)
* ガズル4、ガズル5、ガズル6
* Drupalの `drupal_http_request function`
* Laravelのキュー・ジョブ

## トレースの詳細レベルの設定 [#performance]

分散トレーシングのサポートは、PHPエージェントの [トランザクショントレーサー](/docs/agents/php-agent/configuration/php-agent-configuration#inivar-tt-enable) に依存します。 [分散トレーシングが有効になっている場合](#enable-distributed) 、 [スパン](/docs/apm/distributed-tracing/ui-data/distributed-tracing-attributes) は、トランザクショントレーサーが見る各セグメントに対して作成されます。

[スパンがサンプリングさ](/docs/apm/distributed-tracing/getting-started/how-new-relic-distributed-tracing-works)れると、PHPエージェントは、外部呼び出しに関連するスパンを他のスパンよりも優先し、期間の降順で記録されます。トランザクションごとにサンプリングされるスパンの最大数を決定するため[のini設定](/docs/agents/php-agent/configuration/php-agent-configuration#inivar-span-events-max-samples-stored)があり、パフォーマンスに影響を与える可能性があります。

PHP関数呼び出しについて報告されている重要でないスパンが多すぎる場合は、 [`newrelic.transaction_tracer.detail`](/docs/agents/php-agent/configuration/php-agent-configuration#inivar-tt-detail)を`0`に設定することで、トランザクショントレーサーの詳細を減らすことができます。次に、 [`newrelic.transaction_tracer.custom`](/docs/agents/php-agent/configuration/php-agent-configuration#inivar-tt-custom)構成設定または[`newrelic_add_custom_tracer`](/docs/agents/php-agent/php-agent-api/newrelic_add_custom_tracer) APIメソッドを使用して、トレースに追加する特定のPHP関数またはメソッドのトレースセグメントとスパンを追加できます。

<Callout variant="important">
  PHPエージェントバージョン8.4〜8.7の場合：分散トレースが有効になっている場合、これらのバージョンは[`newrelic.transaction_tracer.detail`](/docs/agents/php-agent/configuration/php-agent-configuration#inivar-tt-detail)が`0`に設定されているかのように動作します（上記のとおり）。その結果、PHP関数呼び出しはスパンを生成しません。 PHP関数呼び出しに関連するスパンを取得するには、バージョン9.0以降に更新してください。
</Callout>

## トレースの詳細についてログを調べる [#logs-context]

ログとアプリケーションのデータを統合して、トラブルシューティングをより簡単かつ迅速に行うことができます。[コンテキストのログ](/docs/logs/logs-context/configure-logs-context-php/)では、エラーとトレースに関連するログメッセージをアプリケーションのUIで直接表示できます。

1. **Transactions**ページでトレースをクリックして、[**Trace details**ページ](/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page)に移動します。
2. トレースの詳細ページで、**See logs**をクリックします。
3. 各ログメッセージに関連する詳細を表示するには、メッセージを直接クリックしてください。

また、Kubernetesクラスターなどの[インフラストラクチャデータ](/docs/logs/forward-logs/forward-your-logs-using-infrastructure-agent/)のコンテキストでログを表示することもできます。別のUIページに切り替える必要はありません。

## アプリケーションやサービスを手動でインストルメントする [#manual]

<Callout variant="important">
  バージョン9.8では、W3C Trace Contextのサポートが追加されました。これに伴い、アプリケーションを手動でインストルメントするためのAPIは、JSONペイロード関連の関数から

  `newrelic_create_distributed_trace_payload()` および `newrelic_accept_distributed_trace_payload($payload),`

  ヘッダー配列フォーム`newrelic_insert_distributed_trace_headers($outbound_headers)`および`newrelic_accept_distributed_trace_headers($inbound_headers)`に。

  JSON関数は現在、非推奨とされており、将来のリリースで削除される予定です。
</Callout>

サポートされていないライブラリを使用している場合や、HTTPベースではない分散システムコンポーネント(メッセージングキューなど)を使用している場合は、PHPエージェントAPIを使用して、分散トレースに含めるべきトランザクションを手動で特定することができます。これは、2つのステップで行います。

1. サービスやアプリケーションを変更して、 **create** or **insert** 分散型トレースデータ
2. **他のトランザクションやリクエストによって作成された** 分散型トレースデータを受け入れるように、サービスやアプリケーションを変更します。

以下の例では、一般的なメッセージ/ジョブキューを使用しています。実際の詳細は、分散トレースにどのようなシステムを追加しようとしているかによって異なりますが、基本的なコンセプトは同じです。また、ジョブキューを例に挙げましたが、これらのメソッドは **任意の** 分散システムコンポーネントに使用することができます。

<Callout variant="tip">
  **ペイロードの作成** や **ヘッダーの挿入** では、このリクエストやトランザクション、リクエストを分散型トレースに参加させたいことを New Relic に伝えています。 **accept** とすると、現在のリクエストやトランザクションとその親のリクエストやトランザクションをリンクさせていることになる。
</Callout>

より詳細な情報を得るため、またはサービス間の接続を確認するために手動でインスツルメンテーションを使用する場合の詳細については、 [分散型トレースAPIに関するドキュメント](/docs/apm/distributed-tracing/enable-configure/enable-distributed-tracing#agent-apis) を参照してください。

### ヘッダーAPI

<CollapserGroup>
  <Collapser
    id="example-dt-create"
    title="分散型トレースヘッダの挿入"
  >
    アプリケーションのどこかに、以下のようなコードがあると思います。

    ```
    // create a job object
    $job = new \Generic\Queue\Job;

    // set the information needed to run the queue job
    $job->setData('info', $info);

    // save the job
    $job->save();
    ```

    このジョブを分散トレースに表示する場合は、 `newrelic_insert_distributed_trace_headers`を使用して分散トレースヘッダーを配列に挿入してから、それらのヘッダーをジョブのデータに追加する必要があります。

    ```
    $outbound_headers = array();
    if (newrelic_insert_distributed_trace_headers($outbound_headers)) {

        // create a job object
        $job = new \Generic\Queue\Job;

        // set the information needed to run the queue job
        $job->setData('info', $info);

        // add the headers to the job data
        $job->setData('nr_dt_headers', $outbound_headers);

        // save the job
        $job->save();
    } else {
        echo "Unable to obtain distributed tracing headers";
    }
    ```

    <Callout variant="tip">
      ヒント： `newrelic_insert_distributed_trace_headers()`を介して作成されたヘッダーはHTTPセーフです。
    </Callout>

    これがステップ1です。ディストリビューション・トレース・ヘッダーを挿入しました。
  </Collapser>

  <Collapser
    id="example-dt-accept"
    title="配布されたトレーシングヘッダを受け入れる"
  >
    次に、アプリケーションスタックのどこかに、以下のようなキューランナーがあります。

    ```
    // create the job runner
    $jobRunner = \Generic\Queue\Runner;

    // grab jobs until there aren't any
    while($job = $jobRunner->next()) {
        // run the job
        $job->run();
    }
    ```

    分散トレースヘッダーを受け入れるには、 `newrelic_accept_distributed_trace_headers`関数を使用します

    ```
    // create the job runner
    $jobRunner = \Generic\Queue\Runner;

    while($job = $jobRunner->next()) {
        $inbound_headers = $job->getData('nr_dt_headers');
        if($inbound_headers) {
            newrelic_accept_distributed_trace_headers($inbound_headers);
        }
        $job->run();
    }
    ```
  </Collapser>
</CollapserGroup>

### ペイロードAPI（非推奨）

<CollapserGroup>
  <Collapser
    id="example-dt-create"
    title="分散型トレースペイロードの作成"
  >
    アプリケーションのどこかに、以下のようなコードがあると思います。

    ```
    // create a job object
    $job = new \Generic\Queue\Job;

    // set the information needed to run the queue job
    $job->setData('info', $info);

    // save the job
    $job->save();
    ```

    このジョブを分散トレースに表示する場合は、 `newrelic_create_distributed_trace_payload`を使用して分散トレースペイロードを作成し、そのペイロードをジョブのデータに追加する必要があります。

    ```
    $payload = newrelic_create_distributed_trace_payload();

    // create a job object
    $job = new \Generic\Queue\Job;

    // set the information needed to run the queue job
    $job->setData('info', $info);

    // add the payload data to the job data as a text json string
    $job->setData('dt_payload', $payload->Text());

    // save the job
    $job->save();
    ```

    これがステップ1です。分散型トレースのペイロードを作成しました。
  </Collapser>

  <Collapser
    id="example-dt-accept"
    title="分散型トレーシングのペイロードを受け入れる"
  >
    次に、アプリケーションスタックのどこかに、以下のようなキューランナーがあります。

    ```
    // create the job runner
    $jobRunner = \Generic\Queue\Runner;

    // grab jobs until there aren't any
    while($job = $jobRunner->next()) {
        // run the job
        $job->run();
    }
    ```

    分散トレースペイロードを受け入れるには、 `newrelic_accept_distributed_trace_payload`関数を使用します

    ```
    // create the job runner
    $jobRunner = \Generic\Queue\Runner;

    while($job = $jobRunner->next()) {
        $payload = $job->getData('dt_payload');
        if($payload) {
            newrelic_accept_distributed_trace_payload($payload);
        }
        $job->run();
    }
    ```
  </Collapser>

  <Collapser
    id="example-dt-accept"
    title="オプションHTTPセーフなペイロード文字列の使用"
  >
    HTTPセーフ文字列を必要とするメカニズム（HTTPヘッダー、URLクエリ文字列、POSTフィールドなど）を介してペイロードを転送する必要がある場合、APIには、文字列のHTTPセーフバージョンを作成して受け入れる分散型のトレースメソッドと関数が含まれています。

    ```
    // create the HTTP safe payload string 
    $payload = newrelic_create_distributed_trace_payload();
    $httpSafePayload = $payload->httpSafe();

    // ...

    // accept the HTTP safe payload string
    newrelic_accept_distributed_trace_payload_httpsafe($httpSafePayload);
    ```
  </Collapser>
</CollapserGroup>

## コマンドラインPHPプログラム [#command-line]

PHPコマンドラインから実行されるPHPプログラムは、常にエージェントの分散トレーサーによってサンプリングされます。実行するプログラムによっては、これらのプロセスで、分散トレースのコレクションに過剰な表現が見られる場合があります。このような状況では、 `newrelic.ini files`の[`per-directory newrelic.enabled`](/docs/agents/php-agent/configuration/php-agent-configuration)設定を使用して、コマンドラインインストルメンテーションを無効にすることを選択できます。