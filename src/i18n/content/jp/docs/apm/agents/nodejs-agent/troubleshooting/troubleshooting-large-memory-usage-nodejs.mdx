---
title: メモリ使用量が多い場合のトラブルシューティング (Node.js)
type: troubleshooting
tags:
  - Agents
  - Nodejs agent
  - Troubleshooting
metaDescription: If you installed the New Relic Node.js agent and your application's memory usage increases read this troubleshooting doc for potential causes and solutions.
translationType: machine
---

## 問題

New Relic Node.js エージェントをインストールしたところ、Node.js アプリケーションのメモリ使用量が増加しました。

## 解決策

このメモリの増加にはいくつかの原因が考えられ、それぞれに解決策があります。

<CollapserGroup>
  <Collapser
    id="slab"
    title="TLSのメモリバッファの割り当てによる増加"
  >
    Node.jsアプリケーションが、SSLやHTTPSを含む何らかの形の暗号化を初めて使用する際には、 [スラブバッファ](http://en.wikipedia.org/wiki/Slab_allocation) が作成されます。このバッファのデフォルトサイズは10MBです。

    受信リクエストに対するSSLの終端が別のルーター層で行われる環境で動作するアプリケーションでは、通常、このオーバーヘッドは発生しません。Heroku や AWS のようなクラウド・サービスは、しばしばこのように動作します。しかし、Node.js のエージェントは New Relic のサービスに HTTPS でアウトバウンド・データを送信しており、これがスラブ・バッファの割り当てのきっかけとなっています。

    **ソリューション**

    場合によっては、スラブバッファをデフォルトの10MBよりも小さくすることができます。

    スラブバッファのサイズを設定するには、 [tls.SLAB_BUFFER_SIZE](http://nodejs.org/api/tls.html#tls_tls_slab_buffer_size).

    <Callout variant="caution">
      New Relic エージェントを使用する場合は、スラブバッファサイズを 128 KB 未満に設定しないでください。SSLやHTTPSなどの暗号を使ってサービスやクライアントと通信するアプリでは、スラブバッファの割り当てを減らしてはいけません。
    </Callout>
  </Collapser>

  <Collapser
    id="cluster"
    title="クラスタワーカーのスラブ割り当てによる増加"
  >
    Node.jsは、 [クラスタモジュール](http://nodejs.org/api/cluster.html) を提供しています。これにより、ホスト上で利用可能なすべてのプロセッサコアを使用して、リクエストを並行して処理することができます。しかし、各クラスタワーカーは、SSL トランザクション用に独自のスラブバッファを割り当て、Node.js エージェントデータのコピーを保持します。このため、使用するクラスター・ワーカーの数だけメモリ・オーバーヘッドが増加します。

    これは、ホストが複数のNode.jsアプリケーションを同時に実行する場合にも当てはまります。

    **ソリューション**

    クラウドサービスプロバイダーの中には、実際に使用できるプロセッサコア数よりも多くのプロセッサコアを使用する環境を使用しているところがあります。クラスターワーカーの数を減らしたり、クラスターのサポートを受けずに動作させたりすることで、パフォーマンスに影響を与えることなくメモリ使用量を減らすことができます。
  </Collapser>

  <Collapser
    id="log"
    title="ディスクに保存されたログメッセージによる増加"
  >
    ログメッセージはデフォルトではディスクに記録されます。メッセージデータの処理方法により、メッセージオブジェクトはガベージコレクションのために **Old-pointer-space** に移動されることがあります。これは、オブジェクトへの参照がすべてなくなった後も、しばらくの間、オブジェクトがメモリ内に残ることを意味します。これにより、プロセスが常に消費するメモリの量が多くなります。また、ガベージコレクションのために追加の処理時間が使われます。

    **ソリューション**

    お使いの Node.js のバージョンによっては、エージェントのデフォルトが **trace** または **info** のログレベルになっている場合があります。ログの冗長度を **info** または **warn** レベルまで下げると、メモリ使用量とガベージコレクションにかかる時間が顕著に減少します。
  </Collapser>

  <Collapser
    id="mongo"
    title="MongoDBのカーソルが流出することによる増加"
  >
    多くのデータベースドライバは、 **カーソル** と呼ばれる抽象的な機能を使用しています。カーソルは、クエリの結果を繰り返し実行する機能を提供します。例えば、 **mongodb** ドライバは、 **find** クエリを実行する際にカーソルを提供します。

    カーソルは、Node.js のランタイムではオブジェクトとして、MongoDB サーバーではエンティティとして存在します。アプリケーションがカーソルを使い終わったら、サーバーとクライアントアプリケーションの両方でリソースを解放するためにカーソルを閉じる必要があります。

    Node.jsでは、サーバーでカーソルを閉じることなく、アプリケーションでリソースを解放するために、カーソルをガベージ・コレクションすることが可能です。これは、アプリケーションでは気づかれないかもしれません。しかし、New Relic Node.js エージェントは、結果の反復処理にかかる時間を測定するために、開いているカーソルを追跡します。アプリケーションが使用するすべてのカーソルを閉じないと、エージェントは古いカーソルを追跡し続け、メモリをリークしてしまいます。

    **ソリューション**

    アプリケーションがクエリの結果の処理を終えた後、cursor.close()を呼び出して、アプリケーションで作成されたすべてのカーソルが閉じられるようにします。
  </Collapser>

  <Collapser
    id="agent"
    title="エージェントのデータ保存による増加"
  >
    Node.jsエージェントは、アプリが処理する各トランザクションのデータを記録します。データは通常、トランザクション名でグループ化されます。エージェントが使用するメモリは、1分ごとの収穫サイクルで記録される異なるトランザクションの数に応じて増加します。

    また、各トランザクションの間、より多くのデータが保持されますが、最終的にはトランザクションの完了時に破棄されます。エージェントが使用するメモリは、アプリケーションが処理する同時トランザクションの数に応じて増加します。

    **ソリューション**

    エージェントデータストレージがメモリ使用量の増加の原因であると判明した場合、ホストにメモリを追加するか、より大きなクラウドインスタンスに変更することで対処できます。
  </Collapser>
</CollapserGroup>
