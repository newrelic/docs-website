---
title: APMはコンテキストにログインします
metaDescription: 'Get relevant logs, traces, errors, and other linking metadata within the context of your app or host, without additional configuration or context switching in New Relic.'
translationType: machine
---

import apmLogsOverview from 'images/apm_screenshot-full_logs-overview.png'

import apmViewLimitsUsage from 'images/apm_screenshot-full_view-limits-usage.png'

import apmApmsummaryViewLogs from 'images/apm_screenshot-crop_apmsummary-view-logs-.png'

import apmLogsPatterns from 'images/apm_screenshot-crop_logs-patterns.png'

import apmLogsContextPatternsTwo from 'images/apm_screenshot-crop_logs-context-patterns-two.png'

import apmLogsCroppedUi from 'images/apm_screenshot-crop_logs-cropped-ui.png'

[ログを New Relic に報告するには、いくつかの方法](/docs/logs/get-started/get-started-log-management)があります。APM エージェントを使用することは、特に他のログ管理ツールを使用する必要がないという利点を重視する小規模なチームや DevOps チームにとって、一般的な方法の 1 つです。

## APMはコンテキストにログインします [#apm-logs-defined]

当社の APM エージェントには、 **logs in context**という機能があります。この機能の利点の詳細について[は、コンテキスト内のログを](/docs/logs/logs-context/logs-in-context)参照してください。

APM エージェントの場合、コンテキスト内のログ機能は次の 2 つのことを行います。

* 重要な New Relic メタデータ ( `span.id` 、 `trace.id` 、 `hostname` 、 `entity.guid` 、 `entity.name`など) でアプリ ログを装飾します。これにより、他の New Relic プラットフォーム エクスペリエンスとの関連でログを確認できます。
* ログを New Relic に直接転送するため、サードパーティのツールは必要ありません。

APM エージェントの新しいバージョンでは、これらの機能が両方ともデフォルトで有効になっているため、サポートされているフレームワーク用の APM エージェントをインストールすると、すぐに使用できるアプリケーション ログ レポートが取得されます。

特定の APM エージェントに対して、この機能の一方または両方を無効にすることもできます。たとえば、APM エージェントに New Relic メタデータを追加させて、ログ装飾機能を使用できるようにしたい場合がありますが、ログ転送を無効にして、代わりに別のログ エージェント (たとえば、当社のインフラストラクチャ エージェント、またはサードパーティのログ記録エージェント）。設定手順はエージェントごとに異なります。ログを無効にする方法については、「 [APM の自動ログを管理する](/docs/logs/logs-context/disable-automatic-logging)」を参照してください。

状況に応じたログの力について詳しく[は、ユースケースの例](#response-time-example)をご覧ください。この例では、エンジニアリング チームがアプリの応答時間の遅さとエラー率の上昇のトラブルシューティングにどのように使用したかを説明しています。

ログ レポート オプションの概要については、「[ログ](/docs/logs/get-started/get-started-log-management#integrate-logs)の概要」を参照してください。

コンテキスト内のログがアプリとホストの問題の根本原因を見つけるのにどのように役立つかを確認するには、次の短いビデオ（約3:40分）をご覧ください。

<Video
  id="Vgae-GrlZWg"
  type="youtube"
/>

## 始めましょう [#get-started]

コンテキストでAPMログを設定するには：

1. New Relicアカウントをまだお持ちでない場合は、[New Relicアカウントを新たに作成します](https://newrelic.com/signup)。永久無料です。
2. APM エージェントをインストールし、APM[エージェントのバージョンが最新](#agents)であることを確認します。
3. APM エージェントの最新バージョンでは、ログ イン コンテキスト (メタデータの追加と転送) がデフォルトで有効になっています。ログを正しく機能させるために、エージェント構成ファイルを更新する必要がある場合があります。詳細については[、エージェントのログを有効にする を](#agents)参照してください。

それでおしまい！APM UI に移動し、関連するログ データを探して、コンテキスト内の APM ログを使用してアプリケーションのトラブルシューティングを開始します。

<img
  title="APM logs in context UI options"
  alt="Screenshot of APM Summary page with logs in context options"
  src={apmLogsOverview}
/>

<figcaption>
  New RelicのAPM**サマリー**ページから、ログ、トレース、エラーにドリルダウンします。
</figcaption>

## APMエージェントのAPI [#agent-apis]

ロギング フレームワークが既存のログ イン コンテキスト ソリューションで利用できない場合は、 [API 呼び出しを使用してロギング ライブラリを構成し、ログ](/docs/logs/logs-context/annotate-logs-logs-context-using-apm-agent-apis)に注釈を付けることができます。

## APMエージェントログの構成 [#agents]

最新の APM エージェントでは、コンテキスト内のログ (ログ装飾とログ転送) がデフォルトで有効になっています。コンテキスト内のログとログ転送をサポートする APM エージェントに関する情報と、そのドキュメントへのリンクを次に示します。

* エージェント[v3.17.0以降](/docs/release-notes/agent-release-notes/go-release-notes)の[コンテキストプロシージャにログを記録する](/docs/logs/logs-context/configure-logs-context-go)
* エージェント[v7.6.0以降](/docs/release-notes/agent-release-notes/java-release-notes)の[コンテキストプロシージャにJavaがログインします](/docs/logs/logs-context/java-configure-logs-context-all)
* [.NETは](/docs/logs/logs-context/net-configure-logs-context-all)、エージェント[v9.8.0以降](/docs/release-notes/agent-release-notes/net-release-notes)のコンテキストプロシージャにログインします
* [Node.jsは](/docs/logs/logs-context/configure-logs-context-nodejs)、エージェント[v8.11.0以降](/docs/release-notes/agent-release-notes/nodejs-release-notes)のコンテキストプロシージャにログインします
* エージェント[v10.1.0 以降](/docs/release-notes/agent-release-notes/php-release-notes)の[コンテキスト プロシージャでの PHP ログ](/docs/logs/logs-context/configure-logs-context-php)
* [Pythonは](/docs/logs/logs-context/configure-logs-context-python)、エージェント[v7.12.0.176](/docs/release-notes/agent-release-notes/python-release-notes)のコンテキストプロシージャにログインします
* [Rubyは](/docs/logs/logs-context/configure-logs-context-ruby)、エージェント[v8.6.0以降](/docs/release-notes/agent-release-notes/ruby-release-notes)のコンテキストプロシージャにログインします

APM ログ転送を使用できない、または使用したくない場合は、[別のソリューションを使用してログを転送できます](/docs/logs/get-started/get-started-log-management#integrate-logs)。

## 既知の制限 [#limitations]

APMログインコンテキストは、APMエージェントログデータを自動的に転送し、デフォルトで有効になっています。これは、セキュリティ、コンプライアンス、請求、またはシステムパフォーマンスに悪影響を与える可能性があります。詳細について、またはデフォルト設定を調整する必要がある場合は、手順に従って[自動ロギングを無効に](/docs/logs/logs-context/disable-automatic-logging)してください。

その他の既知の制限事項を次に示します。

* 起動ログは、エージェントがロードされるまで利用できません。
* Kubernetes を使用している場合は、Kubernetes API からではなく、インストルメンテーションを介してログを装飾することに注意してください。これは、ファイルシステムへのログの書き込みとは別のものです。ログがホストに触れたり、API を呼び出すことができる場所に存在したりすることはありません。
* アプリケーションから例外がスローされた場合、現在、Java または .NET エージェントのコンテキストで関連するログにスタック トレースは表示されません。回避策として、ドロップ フィルタ ルールを変更できます。
* Fluentd は、ログを生成したエンティティから`processID`を追加できますが、APM ログはそれを確認できません。また、Kubernetes では API を呼び出してメタデータを追加しますが、このデータはアプリケーション内から見ることはできません。エンティティ メタデータが必要な場合は、コンテキストで自動ログを使用することをお勧めしますが、アプリケーションからログを送信しないでください。代わりに、引き続き Fluentd、Fluent Bit、または別のソリューションを使用してログ ファイルを転送してください。

## データのプライバシーを確保する [#data-privacy]

<Callout variant="caution">
  New Relicに送信するログデータはユーザーが管理するため、組織のセキュリティガイドラインに従って、個人識別情報（PII）、保護された健康情報（PHI）、またはその他の機密データの送信をマスク、難読化、または防止してください。
</Callout>

ログ取り込みパイプラインは、クレジットカード、社会保障番号、国民IDなどを自動的にマスクします。詳細については、ログ管理[に関するセキュリティドキュメント](/docs/logs/get-started/new-relics-log-management-security-privacy)を参照してください。

難読化機能を使用して、ログ内の機密データをマスクまたはハッシュするカスタムルールを作成することもできます。これは、機密データへのアクセスを制限することが非現実的または不可能な場合、または一部のデータをNewRelicによって保存してはならない場合に重要です。詳細については、[難読化のドキュメント](/docs/logs/ui-data/obfuscation-ui/)をお読みください。

## ログの重複を防ぐ [#duplicate-logs]

コンテキスト機能でログを使用すると、データの取り込みが増加します。アカウントの料金モデルによっては、これが取り込み制限と請求に影響を与える可能性があります。

<Callout variant="caution">
  APMエージェントを使用してアプリケーションから直接ログを送信する場合は、それらのアプリケーションから現在ログを収集しているログ転送ソリューションを無効にするか、変更する必要があります。そうしないと、重複したログが送信され、二重請求が発生します。
</Callout>

重複ログの送信を回避する方法の詳細については、[アップグレードガイド](https://docs.newrelic.com/docs/logs/logs-context/upgrade-to-automatic-logs-context/)を確認してください。

詳細については、手順に従って[特定のログフォワーダー](/docs/logs/forward-logs/enable-log-management-new-relic#log-forwarding)を無効にしてください。

## 摂取制限を管理する [#ingest]

**例：**エンジニアリングチームがアプリの問題のトラブルシューティングを行っているため、APMエージェントによって収集されるログの量を一時的に増やして、より詳細なログを提供します。ただし、上限を数日間実行したままにすると、不要なデータが送信され、請求額が増える可能性があります。

予期しない事態を回避するために、 [NRQLクエリ](/docs/accounts/accounts-billing/new-relic-one-pricing-billing/usage-queries-alerts/#data-queries)を使用して[アラート条件](/docs/accounts/accounts-billing/new-relic-one-pricing-billing/usage-queries-alerts/#alerts)を作成し、取り込み制限を追跡することをお勧めします。例えば：

<CollapserGroup>
  <Collapser
    id="limits-ui"
    title="UIでデータ制限と使用状況を表示する"
  >
    [UI でデータ制限を確認するには](/docs/data-apis/manage-data/view-system-limits):[ユーザー メニュー](/docs/accounts/accounts-billing/general-account-settings/intro-account-settings)から、\[**データの管理] > \[制限**] をクリックします。または、使用状況を表示するには、\[使用状況を**表示] をクリックします**。

    <img
      title="View data and usage from UI"
      alt="Screenshot of View data and usage page in UI"
      src={apmViewLimitsUsage}
    />
  </Collapser>

  <Collapser
    id="query-estimate"
    title="NRQLクエリ：推定コストの例"
  >
    [コスト関連のクエリ](/docs/accounts/accounts-billing/new-relic-one-pricing-billing/usage-queries-alerts#estimated-cost)を参照してください。
  </Collapser>

  <Collapser
    id="nrql-alert"
    title="NRQLアラート：使用しきい値の例"
  >
    使用量がギガバイトのデータの固定月間しきい値を超えたときにアラートを作成するには、次の[NRQLクエリ](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/)をアラート条件に追加します。

    ```
    FROM NrMTDConsumption SELECT latest(GigabytesIngested) WHERE productLine = 'DataPlatform'
    ```
  </Collapser>
</CollapserGroup>

## 例：コンテキストでのログの力 [#response-time-example]

これは、問題の根本原因を突き止めるためにコンテキストでAPMログを使用する詳細な使用例です。

**シナリオ例：**オンコールエンジニアは、アプリの応答時間の短さとエラー率の上昇に関するNewRelicアラート通知を受け取ります。エラーと遅延の増加の背後にある根本的な原因を発見する必要があるため、問題のあるホストを負荷分散からローテーションするか、最新のリリースをロールバックするかを決定できます。

トラブルシューティングを開始するには、NewRelicUIに移動します。

<CollapserGroup>
  <Collapser
    id="when"
    title="エラーはいつどこで始まりましたか？"
  >
    エンジニアがアプリの**APMの概要**ページを見ると、応答時間の増加につながるさらに多くのエラーログが表示されます。彼らは、ログが問題の根本的な原因を明らかにできるかどうかを確認したいと考えています。

    <img
      title="APM Summary errors in UI"
      alt="Screenshot of APM Summary errors in UI"
      src={apmApmsummaryViewLogs}
    />

    **問題に関連するものをどのようにすばやく判断できますか？**

    彼らはログ収集を設定していません。ただし、アプリのJavaエージェントは最近更新され、コンテキストにAPMログが含まれるようになったため、アプリはログとリンクメタデータを自動的に受信するようになりました。 UIに表示されるメトリックは、ログの重大度によるカウントをファセットします。 （これは、Javaエージェントの組み込みのログ装飾機能によって設定されます。）

    **どのエンティティが関連していますか？**

    同じUIページで、**ログ**チャートをクリックして、NewRelicExplorerでエンティティの**ログの概要**ビューを確認できるようにします。このビューには、インストルメント化されたログが収集されたとき、およびそれらのログの重大度レベルが`Error`以下のときが表示されます。また、ログパターンのリストと、すべてのログの何パーセントが各パターンに適合するかを示します。
  </Collapser>

  <Collapser
    id="patterns"
    title="ログにはどのようなパターンが現れますか？"
  >
    **ログパターン**UIでは、まれなエラーメッセージが頻繁に発生し始め、リストに表示されるようになりました。これにより、エンジニアは、ノイズの多いステータスの更新ではなく、問題のあるログに集中できます。

    <img
      title="Logs patterns UI"
      alt="Screenshot of Log patterns UI"
      src={apmLogsContextPatternsTwo}
    />

    **彼らはどのパターンに焦点を当てるべきですか？**

    エンジニアは興味深いログパターンに気づき、このパターンに一致するログのみを表示したいと考えています。彼らはそれをクリックして、表示されているログにフィルターとしてパターンの値を追加します。これにより、焦点が狭くなります。
  </Collapser>

  <Collapser
    id="log-details"
    title="ログの詳細で何が明らかになりますか？"
  >
    エンジニアは、ログレコードに含まれるすべての値を確認したいので、\[**ログの詳細**]ビューをクリックします。これは、ログ自体に意味があることを検証するのに役立ちます。また、アプリが実行されているKubernetes環境にドリルダウンしたり、ログレコードに関連する分散トレースやAPMエラーに直接ドリルダウンしたりすることもできます。

    <img
      title="Log details in APM UI"
      alt="Screenshot of Log details in APM UI"
      src={apmLogsPatterns}
    />

    エンジニアは、完全なスタックトレースを確認できるAPMエラーを確認することにしました。また、**エラー受信ボックス**UIからログを表示することもできます。

    <img
      title="Logs from Errors inbox UI"
      alt="Screenshot of logs from Errors inbox UI"
      src={apmLogsCroppedUi}
    />
  </Collapser>

  <Collapser
    id="log-sampling"
    title="トラブルシューティングに役立つ追加のテストデータは何ですか？"
  >
    トラブルシューティングチームは原因を特定するためにテストを実行していますが、テストトランザクションのすべてのログが収集されているわけではありません。 Javaエージェントの構成ファイルのデフォルトのログコレクション（ `application_logging:forwarding:max_samples_stored:`では1分あたり約10,000ログ）は、サービスに問題があることを検証するのに役立ちました。しかし今、彼らはより詳細なトラブルシューティングのためにサンプリングをより高い数に上げる必要があります。
  </Collapser>

  <Collapser
    id="next-steps"
    title="問題が解決しました。それで？"
  >
    トラブルシューティングチームは、問題が最近導入された変更に起因すると判断したため、そのコードをロールバックします。リソースを節約し、費用を取り込むために、構成ファイルで`application_logging:forwarding:max_samples_stored:`のログ収集を拒否しますが、問題が再発する場合に備えてログサンプリングを実行し続けます。

    トラブルシューティングチームはまた、このアプリにフィルターされた**ログパターン**ページを指すようにRunbookを更新し、Runbook [をアラート条件に追加します](/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/provide-runbook-instructions-alert-activity/)。次回、この状況に似たアラートを受け取ったときに、学習したこれらのレッスンを使用して、トラブルシューティングを迅速に行うことができます。
  </Collapser>
</CollapserGroup>