---
title: OpenTelemetryのNew Relic
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
  - Logs
metaDescription: Details on how New Relic works with OpenTelemetry logs
freshnessValidatedDate: '2024-05-17T00:00:00.000Z'
translationType: machine
---

このドキュメントでは、New Relic が専用の OTLP エンドポイントを通じて受信した OpenTelemetry ログを処理する方法に焦点を当てています。

OpenTelemetry ログを New Relic に送信するための一般的なワークフローは 2 つあります。

* [コレクターに直接](https://opentelemetry.io/docs/specs/otel/logs/#direct-to-collector):

  * アプリケーションは、ログを New Relic OTLP エンドポイントに直接送信できます。
  * 具体的な実装の詳細については、関連する[OpenTelemetry 言語ドキュメント](https://opentelemetry.io/docs/languages/)を参照してください。New Relic を使用したサービスの監視の詳細については、 [OpenTelemetry APM 監視を](/docs/opentelemetry/get-started/apm-monitoring/opentelemetry-apm-intro/)参照してください。

* [ファイルまたは`stdout`経由](https://opentelemetry.io/docs/specs/otel/logs/#via-file-or-stdout-logs):

  * この方法では、ファイルまたは標準出力 ( `stdout` ) に書き込まれたアプリケーション ログをスクレイピングします。

  * このタスクには通常、OpenTelemetry コレクターが使用されます。 スクレイピングされたログは New Relic OTLP エンドポイントに転送されます。

  * 詳細な設定情報については、次のOpenTelemetryリソースを参照してください。

    * [OpenTelemetry コレクター](https://opentelemetry.io/docs/collector/)
    * [Kubernetes を使用したファイルログ レシーバー](https://opentelemetry.io/docs/kubernetes/collector/components/#filelog-receiver)
    * [Log4j2 を使用した Java アプリケーションのワークフローを示す実用的な例](https://github.com/newrelic/newrelic-opentelemetry-examples/tree/main/other-examples/java/logs-in-context-log4j2)

選択した収集方法に関係なく、統合を成功させるには、ログをこのエージェントにエクスポートするようにログ ソースを構成する必要があります。 続行する前に、必ず [デバイスの設定要件](/docs/opentelemetry/best-practices/opentelemetry-otlp/#configure-endpoint-port-protocol)を確認してください。

## OTLP ログレコードのマッピング [#otlp-log-mapping]

New Relic は OTLP ログ レコードを`Log`データ型にマッピングします。 以下の表は[、 `LogRecord` proto メッセージ](https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/logs/v1/logs.proto)のフィールドが New Relic `Log`にどのようにマッピングされるかを示しています。

<table>
  <thead>
    <tr>
      <th>
        OTLP `logs.proto`フィールド
      </th>

      <th>
        New Relic `Log`フィールド
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `ResourceLogs.Resource.attributes`
      </td>

      <td>
        各キー値は`Log`フィールドの属性である**\[1]**
      </td>
    </tr>

    <tr>
      <td>
        `ScopeLogs.InstrumentationScope.name`
      </td>

      <td>
        `otel.library.name`
      </td>
    </tr>

    <tr>
      <td>
        `ScopeLogs.InstrumentationScope.version`
      </td>

      <td>
        `otel.library.version`
      </td>
    </tr>

    <tr>
      <td>
        `ScopeLogs.InstrumentationScope.attributes`
      </td>

      <td>
        各キー値は`Log`フィールドの属性である**\[1]**
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.time_unix_nanos`
      </td>

      <td>
        `timestamp` **\[2]**
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.severity_number`
      </td>

      <td>
        `severity.number`
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.severity_text`
      </td>

      <td>
        `severity.text`
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.body`
      </td>

      <td>
        `message`、および解析された属性**\[3]**
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.attributes`
      </td>

      <td>
        各キー値は`Log`フィールドの属性である**\[1]**
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.dropped_attribute_count`
      </td>

      <td>
        `otel.dropped_attributes_count`
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.flags`
      </td>

      <td>
        `w3c.flags` （整数）
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.trace_id`
      </td>

      <td>
        `trace.id`
      </td>
    </tr>

    <tr>
      <td>
        `LogRecord.span_id`
      </td>

      <td>
        `span.id`
      </td>
    </tr>
  </tbody>
</table>

### 表の脚注 [#otlp-mapping-notes]

**\[1]**リソース属性、スコープ属性、ログレコード属性、最上位ログレコードフィールド、および`LogRecord.body` **\[3]**からの解析された属性に競合がある場合、優先順位（最高から最低）は次のようになります： `LogRecord.body`からの解析された属性 -> 最上位`LogRecord.*`フィールド > `LogRecord.attributes` > `ScopeLogs.InstrumentationScope.attributes` > `ResourceLogs.Resource.attributes` 。

**\[2]** `LogRecord.time_unix_nanos`が存在しない場合は、 `timestamp` New Relicがデータを受信した時刻に設定されます。

**\[3]**[ログ解析は](/docs/logs/ui-data/parsing/)`LogRecord.body`に適用され、プレーンログテキストから属性を抽出しようとします。 たとえば、JSON 構造化ログ形式が使用される場合、キー値は結果のログの属性になります。 これは、ファイルまたは`stdout`からログを収集する場合に特に便利です。 この場合、ログ レコードに関連付けられたリソース属性 ( [APM サービス相関](#service-correlation)に必要) がなく、 `LogRecord.trace_id` / `LogRecord.span_id`の値 ([トレース相関](#trace-correlation)に必要) がないのが一般的です。 必要なフィールドを正常に解析できれば、相関関係は意図したとおりに機能します。

## OpenTelemetry APM サービスとの相関 [#service-correlation]

ログは、 [必要な属性](/docs/opentelemetry/best-practices/opentelemetry-best-practices-resources/#required-attributes)が含まれている場合、サービス エンティティと相関関係にあります。 通常、これらは`ResourceLogs.Resource.attributes`などのログのリソース属性から取得されますが、 [OTLP マッピングの脚注 3](#otlp-mapping-notes)で説明されているように`LogRecord.body`から解析することもできます。

サービスのログを表示するには、そのサービスの[ログ ページ](/docs/logs/ui-data/use-logs-ui/)に移動します。

## トレースとの相関 [#trace-correlation]

`trace.id`属性と`span.id`属性を解決できる場合、ログはトレースと相関付けられます。 通常、これらは`LogRecord.trace_id`フィールドと`LogRecord.span_id`フィールドから取得されますが、 [OTLP マッピング](#otlp-mapping-notes)の脚注 3 で説明されているように`LogRecord.body`から解析することもできます。

特定のトレースのコンテキストで記録されたログを表示するには、次の 2 つのオプションがあります。

* [トレースの詳細ページ](/docs/distributed-tracing/ui-data/trace-details/#view-your-logs) 内の** Logs** \[ログ]タブに移動します。
* サービスの[ログ ページ](/docs/logs/ui-data/use-logs-ui/)に移動し、ログをクリックしてログの詳細を開きます。 トレースに関連付けられている場合は、**Log details**\[ログの詳細]から**Trace details**\[トレースの詳細]に移動できます。
