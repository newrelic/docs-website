---
title: New Relic の OpenTelemetry トレース
tags:
  - Integrations
  - Open source telemetry integrations
  - OpenTelemetry
metaDescription: Details on how New Relic works with OpenTelemetry traces
freshnessValidatedDate: '2024-05-23T00:00:00.000Z'
translationType: machine
---

OpenTelemetry 、トレース テレメトリを記録するための[API](https://opentelemetry.io/docs/specs/otel/trace/api/) 、スパン データをエクスポートするための[SDK](https://opentelemetry.io/docs/specs/otel/trace/sdk/) 、アプリケーション境界を越えてトレースするための[コンテキスト トレース](https://opentelemetry.io/docs/specs/otel/context/api-propagators/)など、豊富なトレース エコシステムを提供します。

このページでは、New Relic が New Relic OTLP エンドポイント経由で受信した OpenTelemetry スパンをどのように処理するかについて説明します。 OpenTelemetryをNew Relicに送信するには、OTLP エンドポイント経由でNew Relic OpenTelemetryにデータをエクスポートするように Trace ソースを設定する必要があります。 次のページを参照してください。

* エンドポイント設定の要件については、 [New Relic OTLP エンドポイント](/docs/opentelemetry/best-practices/opentelemetry-otlp)を参照してください。
* OpenTelemetryを使用してサービスを構成する手順については、 [OpenTelemetry APM監視」](/docs/opentelemetry/get-started/apm-monitoring/opentelemetry-apm-intro)を参照してください。

## OTLPスパンマッピング [#otlp-mapping]

New Relic は OTLP スパンを`Span`データ型にマッピングします。 次の表は、 [トレース プロトコル メッセージ定義](https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/trace/v1/trace.proto)のフィールドがどのように解釈されるかを示しています。

<table>
  <thead>
    <tr>
      <th>
        OTLPプロトフィールド
      </th>

      <th>
        New Relic `Span`フィールド
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `ResourceSpans.Resource.attributes`
      </td>

      <td>
        各キー値は`Span`の属性である**\[1]**
      </td>
    </tr>

    <tr>
      <td>
        `ScopeSpans.InstrumentationScope.name`
      </td>

      <td>
        `otel.library.name`
      </td>
    </tr>

    <tr>
      <td>
        `ScopeSpans.InstrumentationScope.version`
      </td>

      <td>
        `otel.library.version`
      </td>
    </tr>

    <tr>
      <td>
        `ScopeSpans.InstrumentationScope.attributes`
      </td>

      <td>
        各キー値は`Span`の属性である**\[1]**
      </td>
    </tr>

    <tr>
      <td>
        `Span.trace_id`
      </td>

      <td>
        `trace.id`
      </td>
    </tr>

    <tr>
      <td>
        `Span.span_id`
      </td>

      <td>
        `id`
      </td>
    </tr>

    <tr>
      <td>
        `Span.trace_state`
      </td>

      <td>
        `w3c.tracestate`
      </td>
    </tr>

    <tr>
      <td>
        `Span.parent_span_id`
      </td>

      <td>
        `parent.id`
      </td>
    </tr>

    <tr>
      <td>
        `Span.name`
      </td>

      <td>
        `name`
      </td>
    </tr>

    <tr>
      <td>
        `Span.kind`
      </td>

      <td>
        `span.kind`
      </td>
    </tr>

    <tr>
      <td>
        `Span.start_time_unix_nano`
      </td>

      <td>
        `timestamp`
      </td>
    </tr>

    <tr>
      <td>
        `Span.end_time_unix_nano`
      </td>

      <td>
        `duration.ms` ( `Span.start_time_unix_nano`で計算)
      </td>
    </tr>

    <tr>
      <td>
        `Span.attributes`
      </td>

      <td>
        各キー値は`Span`の属性である**\[1]**
      </td>
    </tr>

    <tr>
      <td>
        `Span.dropped_attribute_count`
      </td>

      <td>
        `otel.dropped_attributes_count`
      </td>
    </tr>

    <tr>
      <td>
        `Span.events`
      </td>

      <td>
        各イベントは`SpanEvent`として記録され、 `span.id` / `trace.id`はソーススパンを参照し、カウントは次のように保存されます。 `nr.spanEventCount`
      </td>
    </tr>

    <tr>
      <td>
        `Span.events[*].time_unix_nano`
      </td>

      <td>
        `timestamp`として保存 `SpanEvent`
      </td>
    </tr>

    <tr>
      <td>
        `Span.events[*].name`
      </td>

      <td>
        `name`として保存 `SpanEvent`
      </td>
    </tr>

    <tr>
      <td>
        `Span.events[*].attributes`
      </td>

      <td>
        各キー値は、 `SpanEvent`
      </td>
    </tr>

    <tr>
      <td>
        `Span.events[*].dropped_attributes_count`
      </td>

      <td>
        `ote.dropped_Attributes_count`として保存 `SpanEvent`
      </td>
    </tr>

    <tr>
      <td>
        `Span.dropped_events_count`
      </td>

      <td>
        `otel.dropped_events_count`
      </td>
    </tr>

    <tr>
      <td>
        `Span.status.message`
      </td>

      <td>
        `otel.status_description`
      </td>
    </tr>

    <tr>
      <td>
        `Span.status.code`
      </td>

      <td>
        `otel.status_code`
      </td>
    </tr>
  </tbody>
</table>

### 表の脚注 [#otlp-mapping-notes]

**\[1]**リソース属性、スコープ属性、スパン属性、および最上位のスパンフィールドで競合が発生した場合、優先順位（最高から最低）は、最上位の`Span.*`フィールド&gt; `Span.attributes` &gt; `ScopeSpans.InstrumentationScope.attributes` &gt; `ResourceSpans.Resource.attributes`となります。

[OTLP](/docs/opentelemetry/best-practices/opentelemetry-otlp/#otlp-attribute-types) New Relicエンドポイントでサポートされるプロパティ タイプ の詳細については「OTLP[ プロパティ](/docs/opentelemetry/best-practices/opentelemetry-otlp/#attribute-limits) タイプ」を、プロパティに対して実行される検証の詳細については 「OTLP プロパティ制限」を 参照してください。

## スパンのリンク [#span-links]

New Relic は OpenTelemetry[スパン リンク](https://opentelemetry.io/docs/concepts/signals/traces/#span-links)をサポートしており、これにより直接の親子関係のないスパン間の因果関係を作成できます。スパン リンクは、メッセージキュー、イベント ストリーム、バッチ処理システムなどの非同期境界を越えて分割されるディストリビューティッド（分散）トレーシングを理解するために不可欠です。

### スパンリンクを使用する場合 [#when-to-use]

次のシナリオで span リンクを使用します。

* <DNT>**Message queue producers and consumers**</DNT>: AWS SQS、RabbitMQ、Kafka などのキューからのメッセージを処理するときに、消費スパンを生成スパンにリンクします。
* <DNT>**Fan-in patterns**</DNT>: 複数のプロデューサー トレースを、その出力を集約する単一のコンシューマー トレースにリンクします。
* <DNT>**Batch processing**</DNT>: バッチ処理されたメッセージを個々の元のトレースに返すリンク スパン。
* <DNT>**Long-running workflows**</DNT>: 通常のトレース期間の制限を超えるワークフロー ステップにまたがる接続。

### スパンリンクの実装 [#implementing-span-links]

OpenTelemetryメーターにスパン リンクを実装するには、次の手順を実行する必要があります。

1. 受信メッセージまたはイベントからトレースコンテキストを抽出する
2. 消費者で新しいスパンを開始するときにスパン リンクを作成します。
3. トレースコンテキストがメッセージングインフラストラクチャを通じて伝播されることを確認する

次の例は、さまざまな言語で span リンクを実装する方法を示しています。

<CollapserGroup>
  <Collapser id="python-span-links" title="Python">
    ```python
    from opentelemetry import trace
    from opentelemetry.trace import Link, SpanContext, TraceFlags
    from opentelemetry.trace.propagation.tracecontext import TraceContextTextMapPropagator

    tracer = trace.get_tracer(__name__)
    propagator = TraceContextTextMapPropagator()

    # Producer: Publishing a message with trace context
    def publish_message(queue, message_body):
        with tracer.start_as_current_span("publish_message") as span:
            # Prepare message with trace context headers
            carrier = {}
            propagator.inject(carrier)

            # Add carrier headers to your message metadata
            message = {
                'body': message_body,
                'headers': carrier
            }

            queue.publish(message)
            span.set_attribute("messaging.destination", queue.name)
            span.set_attribute("messaging.system", "custom_queue")

    # Consumer: Processing a message with span link
    def process_message(message):
        # Extract trace context from message headers
        carrier = message.get('headers', {})
        ctx = propagator.extract(carrier)

        # Get the span context from the extracted context
        span_context = trace.get_current_span(ctx).get_span_context()

        # Create a new span with a link to the producer span
        links = []
        if span_context.is_valid:
            links = [Link(span_context)]

        with tracer.start_as_current_span(
            "process_message",
            links=links
        ) as span:
            # Process the message
            result = handle_message(message['body'])

            span.set_attribute("messaging.system", "custom_queue")
            span.set_attribute("messaging.operation", "process")

            return result
    ```

    AWS SQS の場合:

    ```python
    import boto3
    from opentelemetry.trace.propagation.tracecontext import TraceContextTextMapPropagator

    sqs = boto3.client('sqs')
    propagator = TraceContextTextMapPropagator()

    # Publishing to SQS
    def send_sqs_message(queue_url, message_body):
        with tracer.start_as_current_span("sqs_publish") as span:
            carrier = {}
            propagator.inject(carrier)

            # SQS message attributes for trace context
            message_attributes = {
                'traceparent': {
                    'StringValue': carrier.get('traceparent', ''),
                    'DataType': 'String'
                }
            }

            if 'tracestate' in carrier:
                message_attributes['tracestate'] = {
                    'StringValue': carrier['tracestate'],
                    'DataType': 'String'
                }

            sqs.send_message(
                QueueUrl=queue_url,
                MessageBody=message_body,
                MessageAttributes=message_attributes
            )

    # Consuming from SQS
    def process_sqs_message(message):
        # Extract trace context from SQS message attributes
        carrier = {}
        if 'MessageAttributes' in message:
            attrs = message['MessageAttributes']
            if 'traceparent' in attrs:
                carrier['traceparent'] = attrs['traceparent']['StringValue']
            if 'tracestate' in attrs:
                carrier['tracestate'] = attrs['tracestate']['StringValue']

        ctx = propagator.extract(carrier)
        span_context = trace.get_current_span(ctx).get_span_context()

        links = [Link(span_context)] if span_context.is_valid else []

        with tracer.start_as_current_span(
            "sqs_process",
            links=links
        ) as span:
            # Process message
            body = message['Body']
            return handle_message(body)
    ```
  </Collapser>

  <Collapser id="java-span-links" title="Java">
    ```java
    import io.opentelemetry.api.trace.Span;
    import io.opentelemetry.api.trace.SpanBuilder;
    import io.opentelemetry.api.trace.SpanContext;
    import io.opentelemetry.api.trace.Tracer;
    import io.opentelemetry.context.Context;
    import io.opentelemetry.context.propagation.TextMapGetter;
    import io.opentelemetry.context.propagation.TextMapPropagator;
    import io.opentelemetry.context.propagation.TextMapSetter;

    public class MessageProcessor {
        private final Tracer tracer;
        private final TextMapPropagator propagator;

        // Producer: Publishing a message with trace context
        public void publishMessage(Queue queue, String messageBody) {
            Span span = tracer.spanBuilder("publish_message")
                .startSpan();

            try (var scope = span.makeCurrent()) {
                // Inject trace context into message headers
                Map<String, String> headers = new HashMap<>();
                propagator.inject(Context.current(), headers,
                    (carrier, key, value) -> carrier.put(key, value));

                Message message = new Message(messageBody, headers);
                queue.publish(message);

                span.setAttribute("messaging.destination", queue.getName());
                span.setAttribute("messaging.system", "custom_queue");
            } finally {
                span.end();
            }
        }

        // Consumer: Processing a message with span link
        public void processMessage(Message message) {
            // Extract trace context from message headers
            Context extractedContext = propagator.extract(
                Context.current(),
                message.getHeaders(),
                (carrier, key) -> carrier.get(key)
            );

            // Get the span context from extracted context
            SpanContext producerSpanContext = Span.fromContext(extractedContext)
                .getSpanContext();

            // Create span with link to producer
            SpanBuilder spanBuilder = tracer.spanBuilder("process_message");

            if (producerSpanContext.isValid()) {
                spanBuilder.addLink(producerSpanContext);
            }

            Span span = spanBuilder.startSpan();

            try (var scope = span.makeCurrent()) {
                handleMessage(message.getBody());

                span.setAttribute("messaging.system", "custom_queue");
                span.setAttribute("messaging.operation", "process");
            } finally {
                span.end();
            }
        }

        // AWS SQS example
        public void processSQSMessage(
            software.amazon.awssdk.services.sqs.model.Message sqsMessage
        ) {
            Map<String, String> carrier = new HashMap<>();

            // Extract trace context from SQS message attributes
            sqsMessage.messageAttributes().forEach((key, value) -> {
                if (key.equals("traceparent") || key.equals("tracestate")) {
                    carrier.put(key, value.stringValue());
                }
            });

            Context extractedContext = propagator.extract(
                Context.current(),
                carrier,
                (c, k) -> c.get(k)
            );

            SpanContext producerSpanContext = Span.fromContext(extractedContext)
                .getSpanContext();

            SpanBuilder spanBuilder = tracer.spanBuilder("sqs_process");

            if (producerSpanContext.isValid()) {
                spanBuilder.addLink(producerSpanContext);
            }

            Span span = spanBuilder.startSpan();

            try (var scope = span.makeCurrent()) {
                handleMessage(sqsMessage.body());
                span.setAttribute("messaging.system", "AmazonSQS");
            } finally {
                span.end();
            }
        }
    }
    ```
  </Collapser>

  <Collapser id="nodejs-span-links" title="Node.js">
    ```javascript
    const { trace, context, SpanKind } = require('@opentelemetry/api');
    const { W3CTraceContextPropagator } = require('@opentelemetry/core');

    const tracer = trace.getTracer('message-processor');
    const propagator = new W3CTraceContextPropagator();

    // Producer: Publishing a message with trace context
    async function publishMessage(queue, messageBody) {
      const span = tracer.startSpan('publish_message', {
        kind: SpanKind.PRODUCER
      });

      return context.with(trace.setSpan(context.active(), span), async () => {
        try {
          // Inject trace context into message headers
          const carrier = {};
          propagator.inject(
            context.active(),
            carrier,
            {
              set: (carrier, key, value) => {
                carrier[key] = value;
              }
            }
          );

          const message = {
            body: messageBody,
            headers: carrier
          };

          await queue.publish(message);

          span.setAttribute('messaging.destination', queue.name);
          span.setAttribute('messaging.system', 'custom_queue');
        } finally {
          span.end();
        }
      });
    }

    // Consumer: Processing a message with span link
    async function processMessage(message) {
      // Extract trace context from message headers
      const extractedContext = propagator.extract(
        context.active(),
        message.headers || {},
        {
          get: (carrier, key) => carrier[key]
        }
      );

      // Get the span context from extracted context
      const producerSpan = trace.getSpan(extractedContext);
      const producerSpanContext = producerSpan?.spanContext();

      // Create span with link
      const links = [];
      if (producerSpanContext && trace.isSpanContextValid(producerSpanContext)) {
        links.push({
          context: producerSpanContext
        });
      }

      const span = tracer.startSpan(
        'process_message',
        {
          kind: SpanKind.CONSUMER,
          links: links
        }
      );

      return context.with(trace.setSpan(context.active(), span), async () => {
        try {
          await handleMessage(message.body);

          span.setAttribute('messaging.system', 'custom_queue');
          span.setAttribute('messaging.operation', 'process');
        } finally {
          span.end();
        }
      });
    }

    // AWS SQS example using AWS SDK v3
    const { SQSClient, SendMessageCommand, ReceiveMessageCommand } = require('@aws-sdk/client-sqs');

    async function sendSQSMessage(queueUrl, messageBody) {
      const span = tracer.startSpan('sqs_publish');

      return context.with(trace.setSpan(context.active(), span), async () => {
        try {
          const carrier = {};
          propagator.inject(context.active(), carrier, {
            set: (c, k, v) => { c[k] = v; }
          });

          const messageAttributes = {
            traceparent: {
              StringValue: carrier.traceparent || '',
              DataType: 'String'
            }
          };

          if (carrier.tracestate) {
            messageAttributes.tracestate = {
              StringValue: carrier.tracestate,
              DataType: 'String'
            };
          }

          const client = new SQSClient({});
          await client.send(new SendMessageCommand({
            QueueUrl: queueUrl,
            MessageBody: messageBody,
            MessageAttributes: messageAttributes
          }));
        } finally {
          span.end();
        }
      });
    }

    async function processSQSMessage(message) {
      const carrier = {};

      if (message.MessageAttributes) {
        if (message.MessageAttributes.traceparent) {
          carrier.traceparent = message.MessageAttributes.traceparent.StringValue;
        }
        if (message.MessageAttributes.tracestate) {
          carrier.tracestate = message.MessageAttributes.tracestate.StringValue;
        }
      }

      const extractedContext = propagator.extract(context.active(), carrier, {
        get: (c, k) => c[k]
      });

      const producerSpanContext = trace.getSpan(extractedContext)?.spanContext();
      const links = producerSpanContext && trace.isSpanContextValid(producerSpanContext)
        ? [{ context: producerSpanContext }]
        : [];

      const span = tracer.startSpan('sqs_process', { links });

      return context.with(trace.setSpan(context.active(), span), async () => {
        try {
          await handleMessage(message.Body);
          span.setAttribute('messaging.system', 'AmazonSQS');
        } finally {
          span.end();
        }
      });
    }
    ```
  </Collapser>

  <Collapser id="go-span-links" title="Go">
    ```go
    package main

    import (
        "context"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/trace"
    )

    var (
        tracer     = otel.Tracer("message-processor")
        propagator = propagation.TraceContext{}
    )

    // Producer: Publishing a message with trace context
    func publishMessage(ctx context.Context, queue Queue, messageBody string) error {
        ctx, span := tracer.Start(ctx, "publish_message")
        defer span.End()

        // Inject trace context into message headers
        carrier := propagation.MapCarrier{}
        propagator.Inject(ctx, carrier)

        message := Message{
            Body:    messageBody,
            Headers: map[string]string(carrier),
        }

        err := queue.Publish(message)

        span.SetAttributes(
            attribute.String("messaging.destination", queue.Name()),
            attribute.String("messaging.system", "custom_queue"),
        )

        return err
    }

    // Consumer: Processing a message with span link
    func processMessage(ctx context.Context, message Message) error {
        // Extract trace context from message headers
        carrier := propagation.MapCarrier(message.Headers)
        extractedCtx := propagator.Extract(ctx, carrier)

        // Get the span context from extracted context
        producerSpanContext := trace.SpanContextFromContext(extractedCtx)

        // Create span with link
        var links []trace.Link
        if producerSpanContext.IsValid() {
            links = []trace.Link{
                {
                    SpanContext: producerSpanContext,
                },
            }
        }

        ctx, span := tracer.Start(
            ctx,
            "process_message",
            trace.WithLinks(links...),
        )
        defer span.End()

        err := handleMessage(message.Body)

        span.SetAttributes(
            attribute.String("messaging.system", "custom_queue"),
            attribute.String("messaging.operation", "process"),
        )

        return err
    }

    // AWS SQS example
    func processSQSMessage(ctx context.Context, sqsMessage *sqs.Message) error {
        // Extract trace context from SQS message attributes
        carrier := propagation.MapCarrier{}

        if sqsMessage.MessageAttributes != nil {
            if tp, ok := sqsMessage.MessageAttributes["traceparent"]; ok {
                carrier["traceparent"] = *tp.StringValue
            }
            if ts, ok := sqsMessage.MessageAttributes["tracestate"]; ok {
                carrier["tracestate"] = *ts.StringValue
            }
        }

        extractedCtx := propagator.Extract(ctx, carrier)
        producerSpanContext := trace.SpanContextFromContext(extractedCtx)

        var links []trace.Link
        if producerSpanContext.IsValid() {
            links = []trace.Link{
                {SpanContext: producerSpanContext},
            }
        }

        ctx, span := tracer.Start(
            ctx,
            "sqs_process",
            trace.WithLinks(links...),
        )
        defer span.End()

        err := handleMessage(*sqsMessage.Body)

        span.SetAttributes(
            attribute.String("messaging.system", "AmazonSQS"),
        )

        return err
    }
    ```
  </Collapser>

  <Collapser id="dotnet-span-links" title=".NET">
    ```csharp
    using System.Diagnostics;
    using OpenTelemetry;
    using OpenTelemetry.Context.Propagation;

    public class MessageProcessor
    {
        private static readonly ActivitySource ActivitySource = new("MessageProcessor");
        private static readonly TextMapPropagator Propagator = Propagators.DefaultTextMapPropagator;

        // Producer: Publishing a message with trace context
        public async Task PublishMessage(IQueue queue, string messageBody)
        {
            using var activity = ActivitySource.StartActivity("publish_message", ActivityKind.Producer);

            // Inject trace context into message headers
            var carrier = new Dictionary<string, string>();
            Propagator.Inject(
                new PropagationContext(activity.Context, Baggage.Current),
                carrier,
                (c, key, value) => c[key] = value
            );

            var message = new Message
            {
                Body = messageBody,
                Headers = carrier
            };

            await queue.PublishAsync(message);

            activity?.SetTag("messaging.destination", queue.Name);
            activity?.SetTag("messaging.system", "custom_queue");
        }

        // Consumer: Processing a message with span link
        public async Task ProcessMessage(Message message)
        {
            // Extract trace context from message headers
            var propagationContext = Propagator.Extract(
                default,
                message.Headers ?? new Dictionary<string, string>(),
                (carrier, key) => carrier.TryGetValue(key, out var value) ? new[] { value } : Array.Empty<string>()
            );

            var producerContext = propagationContext.ActivityContext;

            // Create span with link
            var links = new List<ActivityLink>();
            if (producerContext != default)
            {
                links.Add(new ActivityLink(producerContext));
            }

            using var activity = ActivitySource.StartActivity(
                "process_message",
                ActivityKind.Consumer,
                parentContext: default,
                links: links
            );

            await HandleMessage(message.Body);

            activity?.SetTag("messaging.system", "custom_queue");
            activity?.SetTag("messaging.operation", "process");
        }

        // AWS SQS example
        public async Task ProcessSQSMessage(Amazon.SQS.Model.Message sqsMessage)
        {
            // Extract trace context from SQS message attributes
            var carrier = new Dictionary<string, string>();

            if (sqsMessage.MessageAttributes != null)
            {
                if (sqsMessage.MessageAttributes.TryGetValue("traceparent", out var tp))
                {
                    carrier["traceparent"] = tp.StringValue;
                }
                if (sqsMessage.MessageAttributes.TryGetValue("tracestate", out var ts))
                {
                    carrier["tracestate"] = ts.StringValue;
                }
            }

            var propagationContext = Propagator.Extract(
                default,
                carrier,
                (c, key) => c.TryGetValue(key, out var value) ? new[] { value } : Array.Empty<string>()
            );

            var links = new List<ActivityLink>();
            if (propagationContext.ActivityContext != default)
            {
                links.Add(new ActivityLink(propagationContext.ActivityContext));
            }

            using var activity = ActivitySource.StartActivity(
                "sqs_process",
                ActivityKind.Consumer,
                parentContext: default,
                links: links
            );

            await HandleMessage(sqsMessage.Body);

            activity?.SetTag("messaging.system", "AmazonSQS");
        }
    }
    ```
  </Collapser>
</CollapserGroup>

### スパンリンクのベストプラクティス [#span-links-best-practices]

スパン リンクを実装する場合は、次のベストプラクティスに従ってください。

1. <DNT>**Always propagate trace context**</DNT>: W3Ct レースコンテキスト (`traceparent`および`tracestate`ヘッダー) がメッセージ ヘッダーまたはメタデータに含まれていることを確認してください。

2. <DNT>**Validate span context**</DNT>: スパン リンクを作成する前に、抽出されたスパン コンテキストが有効かどうかを常に確認します。無効なコンテキストではリンクを作成しないでください。

3. <DNT>**Use appropriate span kinds**</DNT>: メッセージ公開スパンの種類を`PRODUCER`に設定し、メッセージ処理スパンの種類を`CONSUMER`設定します。

4. <DNT>**Add messaging attributes**</DNT>: コンテキストを提供するために、メッセージング システムのセマンティック規則 (`messaging.system` 、 `messaging.destination` 、 `messaging.operation`など) を含めます。

5. <DNT>**Consider sampling**</DNT>: リンクされたトレースは両方ともサンプリングしないと New Relic に表示されません。スパン リンクを使用する重要なワークフローのサンプリング戦略を調整します。

6. <DNT>**Handle batch processing carefully**</DNT>: バッチ処理されたメッセージを処理する場合、追跡可能性を維持するために、メッセージごとに個別のスパン リンクを作成します。

### New Relicでスパンリンクを表示する [#viewing-span-links]

ダッシュボードにスパン リンクを実装したら、 New Relic UIでそれらを表示および操作できます。

1. [トレースのトレース詳細ページ](/docs/distributed-tracing/ui-data/trace-details/#span-links)に移動します。
2. フィルターバーのスパンリンクバッジを探します。これはリンクのあるスパンの数を示します。
3. リンクのあるスパンを選択すると、スパンの詳細ペインの<DNT>**Span links**</DNT>タブが表示されます。
4. リンクされたトレースをクリックすると、関連するトレース間を移動できます。

UI でのスパン リンクの使用の詳細については、 [「スパン リンクについて」を](/docs/distributed-tracing/ui-data/trace-details/#span-links)参照してください。