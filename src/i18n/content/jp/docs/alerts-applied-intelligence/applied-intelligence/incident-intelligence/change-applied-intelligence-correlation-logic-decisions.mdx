---
title: 適用されたインテリジェンス相関ロジックを意思決定で変更する
metaDescription: 'For New Relic''s applied intelligence, how to configure the correlation logic using decisions.'
translationType: machine
---

import nraiDecisionsIndex from 'images/NRAI_Decisions_Index.png'

import iiDecisionsStatistics from 'images/II---Decisions---Statistics.png'

import screenShot20200727At65041Am from 'images/Screen-Shot-2020-07-27-at-6.50.41-AM.png'

import topology4 from 'images/topology-4.png'

import topology1 from 'images/topology-1.png'

import topology2 from 'images/topology-2.png'

import topology3 from 'images/topology-3.png'

[インシデントインテリジェンス](/docs/new-relic-one/use-new-relic-one/new-relic-ai/get-started-incident-intelligence)は、ロジックを使用して[インシデント](/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence#issue-feed)を相互に関連付けます。これらの論理を「決定」と呼びます。組み込みの意思決定があり、インシデントインテリジェンスの**意思決定**UIページで独自の意思決定を作成およびカスタマイズできます。意思決定をより最適に構成すればするほど、インシデントイベントをより適切にグループ化して相互に関連付けることができるため、ノイズが減少し、オンコールチームのコンテキストが向上します。

<img
  title="NRAI_Decisions_Index.png"
  alt="Our AI correlates data related to incidents in the Decisions UI."
  src={nraiDecisionsIndex}
/>

**[one.newrelic.com](https://one.newrelic.com)> Applied intelligence > Incident intelligence > Decisions**：私たちのUIは、各決定がインシデントをどのように相関させるかを示します。

## 重要な概念

意思決定ロジックを理解するための重要な概念は次のとおりです。

* **「相関」とは何ですか？それはどのように機能しますか？**さまざまなアラートエンジンからインシデントインテリジェンスに送信される[インシデントイベント](/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence#issue-feed)については、最近作成されたアクティブなインシデントを相関させることができます。いずれかの決定の基準が満たされると、2つのイベント間で相関が発生します。相関に使用できるすべてのイベントは、考えられるすべてのペアの組み合わせで相互にテストされ、「貪欲なマージ」が実行されます。つまり、インシデントAがBと相関して[問題](/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence#issue-feed)になり、インシデントBがインシデントCと相関して別の問題になる場合、ABとBCもマージされ、A、B、Cを含む単一の問題が発生します。
* **決定にはどのような種類のロジックを使用できますか？**大まかに言えば、決定により、時間（イベント間の期間）、頻度（イベントの数）、コンテキスト（メタデータの構造と値）、および[トポロジー](#topology)（エンティティの関係）に基づいてロジックを定義できます。

## 積極的な決定を確認する [#decisions]

意思決定は、インシデントインテリジェンスがインシデントを相互に関連付ける方法を決定します。デフォルトでは、インシデントインテリジェンスの使用を開始すると、幅広いグローバル決定が有効になります。

既存の決定を確認するには：

1. **[one.newrelic.com](https://one.newrelic.com)**にアクセスし、\[**アラートとAI** ]をクリックします。左側のナビゲーションの\[**インシデントインテリジェンス**]で、\[**決定**]をクリックします。
2. アクティブな決定のリストを確認します。問題間の相関関係を作成するルールロジックを表示するには、決定をクリックします。
3. 決定が相関したインシデントの例を表示するには、\[**最近の相関**]タブをクリックします。
4. 他のオプションのいずれかを使用して、これらのグローバルな決定を有効または無効にします。

あなたの決定は、その有効性やその他のベストプラクティスについて定期的に分析され、レビューのために推奨事項が添付されます。

### 相関統計 [#correlation]

パターン認識アルゴリズムを使用して提供された提案された決定を使用する場合でも、独自の相関ロジックを追加する場合でも、相関率、ノイズリダクションの改善、および発生する相関問題の数に関する洞察を得ることができます。下に示された。

UIから、基に[なるNRQLクエリ](/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language)を表示し、このデータから独自のカスタムチャートとダッシュボードを作成できます。

<img
  title="Decisions Statistic Block"
  alt="Decisions Statistic Block"
  src={iiDecisionsStatistics}
/>

**[one.newrelic.com](https://one.newrelic.com) >アプライドインテリジェンス>インシデントインテリジェンス>意思決定**：意思決定UIからの統計の例。

統計のいくつかの定義：

* 相関率：時間相関が発生している時間と発生していない時間の割合。
* 相関する問題の総数：別の問題と相関する問題の数。
* ノイズリダクション：相関後の問題の総数を相関前の問題の総数で割ったもの。
* 相関の理由：どの決定が問題を最も相関させているかを示します。

### 提案された決定を使用する [#suggested-decisions]

提案された決定の種類に関する情報：

* **推奨される決定：**選択したソースからのデータは、ノイズを減らすのに役立つパターンについて継続的に検査されます。データでパターンが観察されたら、これらのイベントを将来相関させることができる決定が提案されます。
* **提案された決定の加速：**アラートをしばらく使用している場合、ソースにアラートポリシーを追加すると、その履歴データを使用してパターン認識ステップを加速し、決定を最大30％速く提案できます。

開始するには、\[**決定**]UIページの統計ブロックの下にある提案された決定をクリックします。提案された決定の背後にあるロジック、それが役立つと思われる理由、およびその決定の推定相関率に関する情報が表示されます。

<img
  title="Suggested Decision Block"
  alt="Suggested Decision Block"
  src={screenShot20200727At65041Am}
/>

**[one.newrelic.com](https://one.newrelic.com) >応用インテリジェンス>インシデントインテリジェンス>決定**：提案された決定ブロック

相関率を確認するのに十分なデータがない場合は、パーセンテージの見積もりのすぐ下にあるリンクから、より強力な結果を得るために追加できる他のソースに移動できます。**注：1か月あたりのインシデント数が5000未満の場合、おそらく決定を提案することはありません。**

提案された決定を追加するには、\[**決定をアクティブ化**]をクリックすると、他の決定とともに有効になっているように見えます。決定がニーズに関連しない場合は、\[**却下**]をクリックします。

## カスタム決定を作成する [#customize]

独自のカスタム決定を作成することにより、ノイズを減らし、相関を改善できます。決定の作成を開始するには、 **[one.newrelic.com](https://one.newrelic.com)**にアクセスし、\[ **Alerts＆AI** ]をクリックします。左側のナビゲーションの\[**インシデントインテリジェンス**]で、\[**決定**]をクリックし、\[決定の**追加**]をクリックします。そのUIを使用するためのヒントは、以下の表にあります。

決定を作成する場合、ステップ1、2、および3はそれ自体がオプションですが、決定を作成するには少なくとも1つを定義する必要があります。

<table id="decision-guidelines">
  <thead>
    <tr>
      <th style={{ width: "250px" }}>
        オプション
      </th>

      <th>
        説明
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        ステップ1：データをフィルタリングする
      </td>

      <td>
        このステップでは、フィルターを定義します。 2つのインシデント間で相関が発生することを忘れないでください。フィルタが定義されていない場合、すべての着信インシデントが決定によって考慮されます。

        インシデントの最初のセグメント（またはバケット）とインシデントの2番目のセグメントのフィルターを定義します。フィルタ演算子の種類は、サブストリングマッチングから[正規表現マッチング](#regex)までさまざまであり、必要なインシデントイベントをターゲットにして、不要なイベントを除外するのに役立ちます。

        セグメント1とセグメント2の間のイベントペアのすべての組み合わせは、決定の次のステップで使用されます。
      </td>
    </tr>

    <tr>
      <td>
        ステップ2：コンテキスト相関
      </td>

      <td>
        データをフィルタリングしたら、インシデントのコンテキストを比較するときに使用するロジックを定義します。次の方法に基づいてイベントを相互に関連付けることができます。

        * 標準演算子との属性値の比較
        * [類似性アルゴリズム](#algorithms)を使用した属性値の類似性
        * [キャプチャグループを使用した属性値の正規表現](#regex)
        * 類似性またはクラスタリングアルゴリズムを使用したインシデント全体の比較
      </td>
    </tr>

    <tr>
      <td>
        ステップ3：トポロジーの相関
      </td>

      <td>
        [トポロジ相関](#topology)は現在限定リリースです。この機能を有効にするには、アカウント担当者にお問い合わせください。有効にしたら、最初にNerdGraph `aiTopologyCollector`を介してトポロジデータを取り込む必要があります（ [NerdGraph GraphiQLエクスプローラー](https://api.newrelic.com/graphiql)でaiTopologyを検索します）。これにより、トポロジ関連の決定をトポロジデータと一致させることができます。[トポロジ相関の設定の詳細をご覧ください](#topology)。
      </td>
    </tr>

    <tr>
      <td>
        名前を付けます
      </td>

      <td>
        決定ロジックを構成したら、わかりやすい名前と説明を付けます。これは、通知やUIの他の領域で使用され、どの決定によって1組のインシデントが相互に関連付けられたかを示します。
      </td>
    </tr>

    <tr>
      <td>
        高度な設定
      </td>

      <td>
        オプション。詳細設定領域では、イベントを相互に関連付けるときに決定がどのように動作するかをさらにカスタマイズできます。各設定にはデフォルト値があるため、カスタマイズはオプションです。

        * **時間枠**：2つのインシデント間の最大時間を設定して、それらが相関の対象となる時間を作成します。
        * **問題の優先度**：インシデントが相関している場合、デフォルトの優先度設定（ `inherit priority` ）をオーバーライドして、より高いまたはより低い優先度を追加します。
        * **頻度**：トリガーする決定のためにルールロジックを満たす必要があるインシデントの最小数を変更します。
        * **類似性**：ルールロジックで`similar to`演算子を使用している場合は、アルゴリズムのリストから選択して、その感度を設定できます。これは、決定のすべての`similar to`オペレーターに適用されます。
      </td>
    </tr>
  </tbody>
</table>

### 類似性アルゴリズム [#algorithms]

使用する類似性アルゴリズムの技術的な詳細は次のとおりです。

<CollapserGroup>
  <Collapser
    id="levenshtein-distance"
    title="レーベンシュタイン距離"
  >
    このメジャーは、ホスト名のように、静的スキーマと固定長の短い文字列を比較する場合に役立ちます。レーベンシュタイン距離は、編集距離とも呼ばれます。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使い方
          </td>

          <td>
            2つの文字列間のレーベンシュタイン距離は、1つの文字列から別の文字列に移動するための1文字の編集の最小数です。許可される編集操作は、削除、挿入、および置換です。

            適用されるインテリジェンス決定のデフォルトの類似性しきい値は、編集距離3です。これは、決定ビルダーの**詳細モード**で変更できます。
          </td>
        </tr>

        <tr>
          <td>
            いつ使用するか
          </td>

          <td>
            この方法は、比較的短い文字列を静的スキーマおよび固定長と比較する場合に最も役立ちます。一般的なアプリケーションには、スペルチェッカー、計算生物学、音声認識などがあります。
          </td>
        </tr>

        <tr>
          <td>
            例
          </td>

          <td>
            `number/bumble: 3 (number → bumber → bumblr → bumble)`

            `trying/lying: 2 (trying → rying → lying)`

            `strong/through: 4 (strong → htrong → throng → throug → through)`
          </td>
        </tr>

        <tr>
          <td>
            潜在的な欠点
          </td>

          <td>
            レーベンシュタイン距離は、文字列の長さを考慮してデフォルトでは正規化されていません。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="fuzzy-score"
    title="ファジースコア"
  >
    このメトリックは、同じプレフィックスが相関の良い指標となる同じ長さの文字列を比較するのに役立ちます。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使い方
          </td>

          <td>
            ファジースコアアルゴリズムは、文字列間の文字一致に「ポイント」を割り当てることで機能します。

            * 一致する文字ごとに1ポイント

            * 後続の試合のための2つのボーナスポイント

              ファジースコアが高いほど、2つの文字列間の類似性が高くなります。
          </td>
        </tr>

        <tr>
          <td>
            いつ使用するか
          </td>

          <td>
            ファジースコアは、プレフィックスが同じで比較的短い（理想的には&lt;5文字）文字列に最も役立ちます。最小保証スコアは`(length(expected prefix) * 3) - 2`です。
          </td>
        </tr>

        <tr>
          <td>
            例
          </td>

          <td>
            例： `Decisions / dcsions`

            `d: 1`

            `c: 1`

            `i 1`

            `s: 2`

            `o: 1`

            `n: 1`

            `si: 2`

            `io: 2`

            `on: 2`

            `ns: 2`

            `= 15 points`
          </td>
        </tr>

        <tr>
          <td>
            潜在的な欠点
          </td>

          <td>
            最初の文字列の最初の文字が2番目の文字列で見つからない場合、ポイントは付与されません。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="fuzzy-wuzzy-ratio"
    title="ファジーワジー比"
  >
    このメトリックは、同じ長さの文字列を比較するのに役立ちます。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使い方
          </td>

          <td>
            **ファジーウージー**ファミリーの類似性測度は、複数のプラットフォーム間で異なるラベルを持つ同じイベントのチケットを見つけるのに役立つように[、SeatGeekによって開発されまし](https://chairnerd.seatgeek.com/fuzzywuzzy-fuzzy-string-matching-in-python/)た。 2つの文字列のファジーワジー比はパーセンテージで表され、数値が大きいほど文字列が類似していることを示します。これは、Pythonのdifflibの[SequenceMatcherアルゴリズム](https://docs.python.org/3/library/difflib.html)に基づいています。
          </td>
        </tr>

        <tr>
          <td>
            いつ使用するか
          </td>

          <td>
            ファジーワジー比率は、非常に短い（ホスト名など）または非常に長い（イベントの説明など）文字列、特に同じ長さの文字列を比較する場合に効果的です。
          </td>
        </tr>

        <tr>
          <td>
            潜在的な欠点
          </td>

          <td>
            このアルゴリズムは感度が高すぎるため、3〜10語の文字列に効果的に使用できません。 fuzzy wuzzy（以下を参照）に対する他の変更の1つがより良い選択かもしれません。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="fuzzzy-wuzzy-partial"
    title="ファジーワジー部分比率"
  >
    このメトリックは、異なる長さの文字列を比較する場合に役立ちます。ファジーwuzzyアルゴリズムに対するこの変更は、有効な長さの制限に対処するのに役立ちます。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使い方
          </td>

          <td>
            ファジーワジー部分比では、短い文字列が長い文字列内の同じ長さの各サブ文字列と比較されます。 「最適な」部分文字列のスコアは、ファジーワジー部分比率を決定するために使用されます。
          </td>
        </tr>

        <tr>
          <td>
            いつ使用するか
          </td>

          <td>
            ファジーwuzzy部分比率は、基本的なファジーwuzzyアルゴリズムが次の場合に失敗するタイプの比較に特に効果的です。3〜10語の文字列で、いくつかの重要な部分文字列が重複している可能性があります。
          </td>
        </tr>

        <tr>
          <td>
            例
          </td>

          <td>
            たとえば、次の文字列の間：

            `DevOps and SRE teams`

            `DevOps`

            …「DevOps」（短い文字列、長さ= 6）は、「DevOpsおよびSREチーム」内の長さ6の各サブ文字列と比較されます。これらのサブストリングの1つ（「DevOps」）は完全に一致するため、これら2つのストリングのファジーワジー部分比率は高くなります。
          </td>
        </tr>

        <tr>
          <td>
            潜在的な欠点
          </td>

          <td>
            ファジーwuzzyがあまりにも保守的である可能性がある場合、ファジーwuzzy部分一致は、相関で予想されるよりもリベラルである可能性があります。必要に応じて、意思決定ビルダーでしきい値を調整できます。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="fuzzy-wuzzy-token"
    title="ファジーワジートークンセット比率"
  >
    このメトリックは、情報が同じ順序ではなく、長さが異なる可能性がある文字列を比較する場合に役立ちます。メッセージや説明などの文章に最適です。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使い方
          </td>

          <td>
            トークンセット比率アルゴリズムは、文字列を比較するためにいくつかの手順に従います。

            1. 各文字列をトークン化します（例：「DevOpsおよびSREチーム」→「DevOps」「および」「SRE」「チーム」、「SREチームおよびDevOpsエンジニア」→「SRE」「チーム」「および」「DevOps」「エンジニア」）

            2. 交差するトークンを新しい文字列に結合し、残りのトークンを残します。 （例：交差：「DevOps」、「and」、「SRE」、remainder1：「teams」、remainder2：「team」、「engineers」）

            3. 各トークングループをアルファベット順に並べ替えます（例：「and、DevOps、SRE」、「teams」、engineers、team」）

            4. 次の文字列のペアを比較します。

               1. 交差点グループ
               2. 交差点グループ+残り1
               3. 交差点グループ+残り2

               これらのペア（「ベストマッチ」）からの比較は、ファジーワジートークンセットの比率です。
          </td>
        </tr>

        <tr>
          <td>
            いつ使用するか
          </td>

          <td>
            このメトリックは、類似した文字列の単語が重複しているが構造が異なる場合に役立ちます。たとえば、同じリソースでのさまざまな問題のイベントの説明などです。
          </td>
        </tr>

        <tr>
          <td>
            潜在的な欠点
          </td>

          <td>
            ファジーwuzzyがあまりにも保守的である可能性がある場合、ファジーwuzzyトークンセットの一致は、相関で予想されるよりも自由である可能性があります。必要に応じて、意思決定ビルダーでしきい値を調整できます。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="Jaro-winkler-distance"
    title="ジャロ・ウィンクラー距離"
  >
    このメトリックは、同一のプレフィックスが相関関係を強く示している短い文字列に役立ちます。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使い方
          </td>

          <td>
            このメトリックは、0-1のスケールを使用して、2つの文字列間の類似性を示します。ここで、0は類似性がなく（0は文字列間で一致する文字）、1は完全に一致します。ジャロ・ウィンクラー類似性は以下を考慮に入れます：

            * `matching`：文字列内で同じ位置にある2つの文字。
            * `transpositions`：文字列内で異なるシーケンス順序にある一致する文字。
            * `prefix scale`：文字列が最初から一致する場合、ジャロ・ウィンクラー距離は適切に調整されます（プレフィックスは最大4文字です）。
          </td>
        </tr>

        <tr>
          <td>
            いつ使用するか
          </td>

          <td>
            このメトリックは転置に対してかなり寛容ですが、文字列内でさらに離れた転置はあまり役に立ちません。

            中程度から長い文字列のジャロ・ウィンクラー類似性に使用する一般的に安全な数値は0.9です。より寛大な場合は'〜' 0.85を使用できます（他のより具体的なロジックが決定に含まれている場合）。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="cosine-distance"
    title="コサイン距離"
  >
    この測定値は、テキストの大きなブロック（インシデントの説明など）を比較するために最も一般的に使用され、類似性を簡単に視覚化できます。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使い方
          </td>

          <td>
            比較しているテキストブロックごとに、ブロック内の一意の単語ごとの数を表すベクトルが計算されます。結果として得られるベクトルのコサイン距離は、それらの内積をそれらの大きさの積で割ったものです。
          </td>
        </tr>

        <tr>
          <td>
            いつ使用するか
          </td>

          <td>
            この方法は、テキストの長いブロックを比較する場合に最も役立ちます。特に、比較がテキスト全体を考慮し、個々の単語の違いやスペルミスを考慮しない場合に役立ちます。
          </td>
        </tr>

        <tr>
          <td>
            例
          </td>

          <td>
            ```
            It is not length of life, but depth of life.
            Depth of life does not depend on length.
            ```

            これらの文の単語数は次のとおりです。

            `it 1 0`

            `is 0 1`

            `not 1 1`

            `length 1 1`

            `of 2 1`

            `life 2 1`

            `but 1 0`

            `depth 1 1`

            `does 0 1`

            `depend 0 1`

            `on 0 1`

            そして、ここにベクトルとして表されるそれらのカウントがあります：

            ```
            [1, 0, 1, 1, 2, 2, 1, 1, 0, 0, 0]
            [0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]
            ```

            これらのベクトルの余弦距離は約0.9です（1が最も高い類似性です）。
          </td>
        </tr>

        <tr>
          <td>
            潜在的な欠点
          </td>

          <td>
            コサイン距離は、単語の小さな文字の違いが重要でない状況ではあまり役に立ちません。また、余弦距離はテキストブロックの語順を無視します。
          </td>
        </tr>
      </tbody>
    </table>

    コサイン距離の実装の詳細については、この[詳細なウォークスルー](http://blog.christianperone.com/2013/09/machine-learning-cosine-similarity-for-vector-space-models-part-iii/)を参照してください。
  </Collapser>

  <Collapser
    id="hamming-distance"
    title="ハミング距離"
  >
    このメジャーは、静的スキーマを使用する短いテキストに役立ちますが、同じ長さの文字列に対してのみ機能します。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            いつ使用するか
          </td>

          <td>
            ハミング距離では、比較する文字列の長さが同じである必要があります。これは、2つの文字列の違いがタイプミスによる可能性がある場合、または既知の長さの2つの属性を比較する場合に役立つ類似度メトリックです。例：データセンターus01のアプリケーションmyappのディスク容量が少ない

            データセンターの変更に耐えたい場合は、ハミング距離を4に設定する必要があります。ハミング距離の平均的な使用例は約2〜3です。
          </td>
        </tr>

        <tr>
          <td>
            例
          </td>

          <td>
            レーベンシュタイン距離のような「距離の編集」メトリックのより単純なバージョンである、2つの文字列間のハミング距離は、（同じ位置で）一致しない文字列内の文字数です。たとえば、以下の文字列では、ハミング距離は2です。

            ```
            flowers / florets
            ```
          </td>
        </tr>

        <tr>
          <td>
            潜在的な欠点
          </td>

          <td>
            上記の例では、データセンターではなくアプリケーション名が変更された場合、相関関係も作成されます。距離が長くなるにつれて、ハミング距離の有用性は急落します。このため、1〜2文字の置換に耐えるよりもはるかに複雑な場合（または文字列の長さが一致しない場合）は、別の類似度測定を使用する必要があります。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>

  <Collapser
    id="Jaccard-distance"
    title="ジャッカード距離"
  >
    この測定値は、説明やインシデント全体など、テキストの大きなブロックを比較する場合に役立ちます。

    <table>
      <thead>
        <tr>
          <th style={{ width: "200px" }}>
            詳細
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            使い方
          </td>

          <td>
            パーセンテージで表される距離（0は完全に類似、1は完全に非類似）は、次の式で計算されます。

            ```
            1 - [(# of characters in both sets) / (# of characters in either set) * 100]
            ```

            つまり、Jaccard距離は、共有文字の数を文字の総数（共有および非共有）で割ったものです。 0.1のジャッカード距離は、2つのインシデント間の10％以下の文字が異なることを意味します。
          </td>
        </tr>

        <tr>
          <td>
            いつ使用するか
          </td>

          <td>
            ジャッカード距離は非常に簡単に解釈でき、データセットが大きい場合に特に役立ちます。たとえば、（1つの属性ではなく）2つのインシデント全体の類似性を比較する場合です。
          </td>
        </tr>

        <tr>
          <td>
            潜在的な欠点
          </td>

          <td>
            小さなデータセットやデータが欠落している状況では効果が低くなります。また、文字セットのさまざまな順列はJaccardの距離に影響を与えないため、誤検知を防ぐように注意する必要があります。
          </td>
        </tr>
      </tbody>
    </table>
  </Collapser>
</CollapserGroup>

## 正規表現演算子 [#regex]

[決定を下す際に利用できるオペレーターは次の](#customize)とおりです。

* `contains (regex)`：[ステップ1で使用：データをフィルタリングします](#customize)。
* `regular expression match`：[ステップ2で使用：コンテキスト相関。](#customize)

意思決定ビルダーは、[正規表現についてこれらのドキュメントで](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)概説されている標準に従います。

### ステップ1の正規表現 [#regex-step-1]

正規表現がtrueとしてテストされるためには、属性値全体（評価しているデータ）が、提供された正規表現と一致している必要があります。キャプチャされたグループは使用できますが、明示的に評価されません。

たとえば、属性値が`foobarbaz`の場合、これらの例は基準を満たし、trueとしてテストされます。

* `foo.*`
* `^.*baz`
* `\w+`

### ステップ2の正規表現 [#regex-step-2]

正規表現がtrueとしてテストされるためには、インシデント1とインシデント2の属性値全体が一致に含まれている必要があります。また、キャプチャされた各グループ（ `( )`の括弧内の式）は両方の値（インシデント1とインシデント2の属性）に存在し、同じ値を持っている必要があります。

* キャプチャされたグループの数は、両方のインシデント属性で等しくなければなりません。
* 各グループは、属性値間の対応するグループと等しくなければなりません。インシデント1属性値の最初にキャプチャされたグループの値は、インシデント2属性の最初にキャプチャされたグループの値と等しくなります。

たとえば、属性値1が`abc-123-xyz`で、属性値2が`abc-777-xyz`の場合、 `(\w+)-(?:\w+)-(\w+)`は次の基準を満たします。

* 値全体が式と一致します。
* 1番目と3番目のキャプチャされたグループは、それぞれ同じ値を持ちます。
* 2番目のグループは`?:`を使用してキャプチャされません。これにより、値全体を一致させることができますが、キャプチャグループの比較には使用されません。

### フラグについて [#flags]

デフォルトではフラグは有効になっていません。意思決定ビルダーの正規表現に含めるのに役立つフラグは次のとおりです。

* CASE_INSENSITIVE：（？i）
* マルチライン：（？m）
* ドット：（？s）

これらの各フラグの機能と実装に関する[詳細については、フィールドの詳細](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#field.detail)を参照してください。

## 相関アシスタント [#assistant]

相関アシスタントを使用すると、 [インシデント](/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence#issue-feed)をより迅速に分析し、決定ロジックを作成し、シミュレーションでロジックをテストできます。相関アシスタントを使用するには：

1. **one.newrelic.com**から、\[ **Alerts＆AI** ]、\[ **Issues＆Activity** ]、\[ **Incidents** ]タブの順にクリックします。
2. 関連付けたいインシデントのチェックボックスをオンにします。次に、インシデントリストの下部にある\[**インシデントの相関**]をクリックします。
3. インシデントを相関させるための最良の結果を得るには、頻度の割合が低い共通の属性を選択してください。[周波数の使用についての詳細をご覧ください](#frequency-tips)。
4. \[**シミュレーション]**をクリックして、データの最後の週に対する新しい決定の予想される影響を確認します。
5. 相関ペアの例をクリックして、それらの相関が望ましいかどうかを判断します。
6. シミュレートされたものが気に入った場合は、\[**次へ**]をクリックして、決定に名前を付けて説明します。
7. シミュレーション結果に潜在的なインシデントが多すぎる場合は、決定のために別の属性とインシデントのセットを選択して、別のシミュレーションを実行することをお勧めします。[シミュレーションの詳細をご覧ください](#simulations)。

### 属性分析 [#frequency-tips]

UIに表示される2種類の属性分析の説明は次のとおりです。

* **共通の属性**：この分析では、選択したすべてのインシデント間でまったく同じ属性と値を強調表示します。

* **類似属性**：類似分析では、距離3のレーベンシュタインアルゴリズムを使用して、3つ以下の文字変更が実行された場合に値が同じになる属性を見つけます。その他の情報：

  * 数値と1文字の値は、結果から除外されます。
  * 2つのインシデントを選択する必要があります。 3つ以上のインシデントが選択された場合、類似性分析は実行されません。

最良の決定を下すために、インシデントの頻度が低い共通の属性を選択することをお勧めします。低頻度または高頻度の属性の選択が決定にどのように影響するかを理解するためのヒントを次に示します。

* **低頻度：**例として、頻度列に0％が含まれる属性は、一意の識別子であるか、先月のデータで最近報告されたばかりの属性である可能性があります。低頻度の属性を選択すると、いくつかのイベントが相関する場合があります。
* **高頻度：**一方、100％の頻度の属性は、すべてのデータに存在する属性になります。これらの属性を選択すると、すべてのイベントが相互に関連付けられます。

デフォルトでは、属性は頻度でソートされ、最も頻度の低い属性が一番上に表示されます。属性の頻度のパーセンテージをクリックして、先月その属性について報告された値の分布に関する詳細情報を取得します。

### シミュレーションの使用に関するヒント [#simulations]

一連のインシデントを使用して、[相関アシスタント](#assistant)は、それらのインシデントに共通する属性と、同様の値を持つ属性を識別します。イベントが相互に関連している必要があることを示す良い指標であると思われる属性を選択してから、決定をシミュレートします。シミュレーションは、データの最後の週に対してロジックをテストし、検査する実際の例に加えて、発生した相関の数を示します。

シミュレーションが良さそうな場合は、実際の決定を作成し続けます。シミュレーションに有用な相関関係の例が表示されない場合は、別の属性セットを選択して、シミュレーションを再実行してください。

シミュレーションの作成時に表示される決定プレビュー情報の内訳は次のとおりです。

* **潜在的な相関率**：この決定が影響を与えたであろうテストされたインシデントのパーセンテージ。
* **作成されたインシデントの総数**：この決定によってテストされたインシデントの数。
* **相関するインシデント**の推定総数：この決定が相関するであろうインシデントの推定数。
* **インシデントの例**：この決定が相関していると思われるインシデントペアのリスト。これらをクリックすると、すべての属性と値を並べて比較し、相関が必要かどうかを判断するのに役立ちます。

希望する結果が表示されるまで、さまざまな属性を使用してシミュレーションを必要な回数だけ実行します。準備ができたら、UIプロンプトに従って決定を保存します。

## トポロジー相関 [#topology]

「トポロジー」とはどういう意味ですか？ New Relicの適用インテリジェンスの場合、トポロジはサービスマップの表現であり、インフラストラクチャ内のサービスとリソースが相互にどのように関連しているかを示します。

[カスタム決定を作成する](#build-decision)ときは、トポロジ相関を使用できます。これにより、インシデントソース間の関係が検出され、 [インシデント](/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence#issue-feed)を相関させる必要があるかどうかが判断されます。トポロジ相関は、相関の品質とそれらが検出される速度を向上させるように設計されています。

### 要件 [#topology-requirements]

**トポロジ相関は現在限定リリースです。**要件：

* NewRelicの担当者によるトポロジ機能へのアクセスを許可
* 環境ごとのNewRelic組織ごとの10,000頂点の制限

### トポロジー相関はどのように機能しますか？ [#topology-explained]

<img
  title="topology-4.png"
  alt="New Relic topology explained 4"
  src={topology4}
/>

<figcaption>
  このサービスマップでは、ホストとアプリが頂点であり、それらの関係を示す線がエッジです。
</figcaption>

トポロジの相関関係は、次の2つの主要な概念に依存しています。

* **頂点**：頂点は監視対象のエンティティを表します。頂点は、インシデントイベントの発生元、または問題のある症状を説明するソースです。頂点には、エンティティGUIDやその他のIDなどの属性（キーと値のペア）が構成されており、着信インシデントイベントに関連付けることができます。
* **エッジ**：エッジは、2つの頂点間の接続です。エッジは、頂点間の関係を表します。

トポロジを設定するには[、NerdGraphAPIを使用します](#create-topology-graph)。ただし、最初に、トポロジを使用してインシデントを関連付ける方法を理解すると役立つ場合があります。

1. まず、NewRelicは関連するすべてのインシデントを収集します。これには、[決定ロジックのステップ1と2](#build-decision)が真であり、詳細設定で定義された時間枠内にあるインシデントが含まれます。

<img
  title="topology-1.png"
  alt="New Relic topology explained 1"
  src={topology1}
/>

<figcaption>
  この例では、点線の選択のすべてのインシデントがこれらの要件を満たしています。[ステップ1と2で決定ロジックを](#build-decision)通過し、[決定ロジックのステップ2](#build-decision)で行われたすべてのコンテキスト比較が真です。
</figcaption>

2. 次に、頂点の定義属性とインシデントで使用可能な属性を使用して、[トポロジグラフ](#create-topology-graph)内の頂点に各インシデントを関連付けようとします。

<img
  title="topology-2.png"
  alt="New Relic topology explained 2"
  src={topology2}
/>

<figcaption>
  インシデントをトポロジグラフの情報に関連付ける手順の例を次に示します。
</figcaption>

3. 次に、インシデントに関連付けられた頂点のペアが、「トポロジカル依存」演算子を使用してテストされ、これらの頂点が相互に接続されているかどうかが判別されます。この演算子は、5ホップ以内に2つの頂点を接続するパスがグラフにあるかどうかを確認します。

<img
  title="topology-3.png"
  alt="New Relic topology explained 3"
  src={topology3}
/>

4. 次に、インシデントが相互に関連付けられ、問題がマージされます。

### インシデントイベントに属性を追加する [#add-attributes]

インシデントは、頂点の定義属性を使用して頂点に接続されます（[トポロジで説明さ](#topology-explained)れているトポロジの例では、各頂点に一意の値を持つ定義属性「CID」があります）。次に、適用されたインテリジェンスは、属性に一致する頂点を見つけます。

頂点で使用する定義属性がインシデントイベントにまだ含まれていない場合は、次の方法で追加できます。

1. **New Relicでエンティティに**[タグを付ける：エンティティ](/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data)にタグを付けることで、これらのタグはアラートによって生成されたインシデントイベントを強化します。たとえば、エンティティに`CID`とそれに対応する一意の値のタグを付けた場合、次のように頂点に属性を定義できます。 `'newrelic/tags/CID' : CID_VALUE`
2. **データのファセット：** 1つ以上の[ファセット](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions#syntax)を定義して[NRQLアラート条件](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions)を作成すると、属性ごとにデータがグループ化されます。また、発行されたインシデントイベントは、これらの属性と値で強化されます。インシデントの場合、ファセット属性は同じ形式に従います。 `newrelic/tags/ATTRIBUTE_NAME`

### トポロジを作成または表示する [#create-topology-graph]

トポロジを設定したり、既存のトポロジを表示したりするには、 [NerdGraphトポロジのチュートリアル](/docs/apis/nerdgraph/examples/topology-nerdgraph-tutorial)を参照してください。