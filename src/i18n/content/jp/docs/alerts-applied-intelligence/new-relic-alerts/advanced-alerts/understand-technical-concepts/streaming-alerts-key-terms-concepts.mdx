---
title: ストリーミング・アラート：重要な用語と概念
tags:
  - Alerts and applied intelligence
  - Alerts
  - Get started
translationType: machine
---

import accountsStreamingAlertsAggregationFlowchart from 'images/accounts_diagram_streaming-alerts-aggregation-flowchart.webp'

import accountsStreamingAlerts from 'images/accounts_diagram_streaming-alerts.webp'

ストリーミング アラート プラットフォームは、New Relic に着信するデータ ストリームまたは[シグナル](/docs/using-new-relic/welcome-new-relic/get-started/glossary#signal)に存在または欠落しているデータに基づいてインシデントをチェックします。

[NRQL条件](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/) を使用して、通知を受けたい信号のどの部分かを制御することができます。NRQL条件は、 [ストリーミングアルゴリズム](/docs/using-new-relic/welcome-new-relic/get-started/glossary#streaming-algorithm) によって処理されるデータをフィルタリングします。

NRQL 条件でフィルタリングされたデータを集約する方法は 3 つあります。

* イベントフロー（デフォルト）
* イベントタイマー
* ケイデンス

<Video
  type="wistia"
  id="n6nei987ln"
/>

<figcaption>
  このショートビデオでは、3つの集計方法について説明しています（5分31秒）。
</figcaption>

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="flowchart"
    title="集計方法の選択"
  >
    <img
      title="Choose your aggregation method."
      alt="A flowchart image that helps you decide what aggregation method you should use."
      src={accountsStreamingAlertsAggregationFlowchart}
    />

    <figcaption>
      データが一貫して予測可能に到着する場合は、 **イベントフロー** を使用します。データの到着が不規則で予測できない場合は、 **イベントタイマー** を使用してください。
    </figcaption>
  </Collapser>
</CollapserGroup>

## 重要な理由 [#why]

ストリーミングアラートの仕組みを理解することで、NRQLの条件を微調整して、重要なことを通知することができます。

<img
  title="A diagram that demonstrates how data is streamed into New Relic."
  alt="A diagram that demonstrates how data is streamed into New Relic."
  src={accountsStreamingAlerts}
/>

<figcaption>
  NRQL WHERE 句の条件に一致するデータのみがアラートされます。プロセスの各ステップの詳細については、[ストリーミング アラートのプロセスと説明](#streaming-table)を参照してください。
</figcaption>

データが New Relic にストリームされると、NRQL 条件によってフィルタリングされます。データが評価される前に、 [NRQL クエリの`WHERE`句](/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions#sel-where)で定義された基準を満たす必要があります。インシデントのデータをすぐに評価する代わりに、NRQL アラート条件は集計ウィンドウと呼ばれる期間にわたってデータを収集します。追加の遅延/タイマーにより、ウィンドウが集約される前に、より遅いデータ ポイントが到着することができます。

遅延/タイマー時間が経過すると、New Relic はデータを単一のデータ ポイントに集約します。Alerts は、データ ポイントを条件のしきい値基準と比較して、インシデントを開く必要があるかどうかを判断します。

データ ポイントがインシデントの基準を満たしている場合でも、インシデントが開かれない場合があります。インシデントは、データ ポイントが一定期間にわたって一貫してしきい値基準を満たしている場合にのみ開かれます。これはしきい値期間です。データ ポイントがしきい値期間全体にわたって違反している場合は、ポリシー設定に基づいて通知が送信されます。

これらの設定可能な遅延により、散発的なデータや欠落したデータに対する警告方法をより細かくコントロールすることができます。

## ストリーミングアラートのプロセスと説明 [#streaming-table]

<table class="alternate">
  <thead>
    <tr>
      <th style={{ width: "200px" }}>
        プロセス
      </th>

      <th>
        **説明**
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        ストリーミングデータ
      </td>

      <td>
        すべてのデータがNew Relicに入ってくる。
      </td>
    </tr>

    <tr>
      <td>
        WHERE句
      </td>

      <td>
        すべての受信ストリーミングデータをフィルタリングします。このフィルターを通過したデータについてのみ、アラートを監視します。
      </td>
    </tr>

    <tr>
      <td>
        アグリゲーション方法
      </td>

      <td>
        評価される前のデータの収集方法を制御する3つの方法のうちの1つ。

        彼らは

        * イベントフロー（デフォルト）
        * イベントタイマー
        * ケイデンス
      </td>
    </tr>

    <tr>
      <td>
        集計ウィンドウ
      </td>

      <td>
        この期間内のタイムスタンプを持つデータが集計され、評価されます。
      </td>
    </tr>

    <tr>
      <td>
        スライディングウィンドウ
      </td>

      <td>
        この機能を有効にすると、アグリゲーションウィンドウが重なり合い、より滑らかなチャートを作成することができます。

        スライディングウィンドウの期間を使って、アグリゲーションウィンドウが重なる時間を設定します。
      </td>
    </tr>

    <tr>
      <td>
        遅延/タイマー
      </td>

      <td>
        アグリゲーションが行われる前に、すべてのデータポイントがアグリゲーションウィンドウに到着していることを確認するための時間的な遅延です。
      </td>
    </tr>

    <tr>
      <td>
        集計されたデータ
      </td>

      <td>
        アグリゲートウィンドウのデータは、アラート評価のために1つのデータポイントに折りたたまれます。
      </td>
    </tr>

    <tr>
      <td>
        評価
      </td>

      <td>
        データポイントはNRQL条件によって評価されます。この条件は、入力される各集約されたデータポイントによってトリガされます。
      </td>
    </tr>

    <tr>
      <td>
        しきい値の継続時間
      </td>

      <td>
        インシデントが作成されるかどうかを決定する特定の期間。指定した NRQL 条件がしきい値期間にわたってしきい値基準を満たす場合、インシデントが発生します。

        データポイントにデータがない場合、カスタム値を挿入してギャップを埋めます。
      </td>
    </tr>
  </tbody>
</table>

## 集計方法の選択 [#aggregation-methods]

お客様のニーズに合わせて、3種類の集計方法を選択することができます。

[イベントフロー](#event-flow) （デフォルト）は、頻繁に入ってくるデータ、ほとんどが順番に入ってくるデータに最適です。

[イベントタイマー](#event-timer) は、クラウド統合データや頻度の低いエラーログなど、一括して届く頻度の低いデータに最適です。

[Cadence](#cadence) は、私たちのオリジナルで劣った集計方法です。データのタイムスタンプに関係なく、New Relic の内部ウォールクロックで検出された特定の時間間隔のデータを集約します。

集計方法を説明した短い動画（5分35秒）をご紹介します。

<Video
  id="jJ51qq3JGUI"
  type="youtube"
/>

## イベントの流れ [#event-flow]

イベントフローは、後続のウィンドウに最初のデータポイントが到着したときに、データのウィンドウを集約します。カスタムディレイは、現在のウィンドウのアグリゲーションをトリガーするために、どの後続ウィンドウにデータが入り始めるかを定義します。カスタムディレイは、データが到着するまでの時間を延長します。これらの時間はデータのタイムスタンプに基づいており、New Relic のウォールクロックの時間ではありません。

例えば、CPU使用率をウィンドウの持続時間が1分、遅延時間が3分の場合に監視しているとします。

CPU使用率のデータポイントが12:00から12:01の間のタイムスタンプで入ってくると、イベントフローは12:04pmから12:05pmの間のタイムスタンプを持つデータポイントが現れるまで、そのウィンドウを集約しません。イベントフローは、タイムスタンプが12:04pm以降の最初のデータポイントを受信すると、12:00から12:01のデータを送信して集計します。

<Callout variant="caution">
  データポイントが65分以上の間隔で到着することが予想される場合は、後述のイベントタイマー方式をご利用ください。
</Callout>

## イベントタイマー [#event-timer]

イベントタイマーは、イベントフローと同様に、指定したウィンドウにデータが到着したときのみ、そのウィンドウのデータを集約します。アグリゲーションウィンドウにデータポイントが到着すると、そのウィンドウ専用のタイマーがカウントダウンを開始します。タイマーがカウントダウンする前にデータが到着しなければ、そのウィンドウのデータが集約されます。タイマーのカウントダウンが完了する前にさらにデータポイントが到着した場合、タイマーはリセットされます。

例えば、かなりの頻度で到着するCloudWatchデータを監視しているとします。ウィンドウの時間は1分、タイマーは3分を使用しています。

CloudWatchのデータポイントが12:00～12:01の間のタイムスタンプで入ってくると、タイマーがカウントダウンを開始します。その12:00～12:01のウィンドウにそれ以上のデータポイントが現れなければ、そのウィンドウは3分後に集約されます。

12:00から12:01の間のタイムスタンプを持つ新しいデータポイントが到着すると、タイマーはリセットされます。さらにそのウィンドウのデータポイントが到着するたびにリセットされ続けます。タイマーが0になるまで、ウィンドウはアグリゲーションのために送信されません。

後のデータポイントのタイマーが先のデータポイントよりも先に経過した場合、イベントタイマー法は先のタイマーが経過するのを待ってから後のデータポイントを集計します。

最良の結果を得るためには、タイマーがウィンドウの継続時間と同じかそれ以上であることを確認してください。タイマーがウィンドウ期間より短く、データフローに一貫性がない場合、すべてのデータポイントが到着する前にデータが評価される可能性があります。これにより、誤った通知が行われる可能性があります。

## ケイデンス [#cadence]

他の2つの方法のいずれかを使用することをお勧めします。

Cadence は私たちの古いストリーミング集計方法です。この方法では、New Relic のウォールクロックの時間を使用して、データがいつ集約され評価されるかを決定します。この方法では、データポイントが到着したときのタイムスタンプは考慮されません。

## ストリーミングアラートツール [#tools]

ストリーミングアラートは、評価される前のデータの集計方法をコントロールし、誤った通知を減らすための一連のツールを提供します。それらは

* ウインドウ期間
* 遅延/タイマー
* 信号検知の消失
* ギャップ埋め

<Callout variant="tip">
  この記事では、これらのツールを概念的なレベルで説明しています。これらのツールの使い方については、 [Create NRQL alert conditions](/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions) で直接説明しています。
</Callout>

### ウインドウ期間 [#window-duration]

信号損失の検出をより効果的にし、不要な通知を減らすために、集約ウィンドウを必要な期間にカスタマイズすることができます。

[アグリゲーションウィンドウ](/docs/using-new-relic/welcome-new-relic/get-started/glossary#aggregation-window) は、特定の時間のブロックです。データを評価する前に、データポイントをアグリゲーションウィンドウに集めます。アグリゲーション・ウィンドウが長いと、データを滑らかにすることができます。異常値のデータポイントは、一緒にアグリゲートされるデータポイントが増えるため、評価のために送信されるアグリゲートされたデータポイントへの影響が少なくなるからです。データポイントが到着すると、そのタイムスタンプが使用され、適切な集計ウィンドウに入れられます。

アグリゲーションウィンドウは、 **30秒** から **15分** の間で設定できます。デフォルトは **1分** です。

### 遅延/タイマー [#delay-timer]

遅延／タイマーの設定は、アグリゲーションウィンドウにデータを集約する前に条件が待機する時間を制御します。

イベントフローとケイデンスメソッドは、ディレイを使用します。イベントタイマーはタイマーを使用します。

遅延のデフォルトは **2分** です。タイマーのデフォルトは **1分** で、最小値は **5秒** です。

### 信号検知の消失 [#signal-loss]

特定の期間にわたって NRQL 条件に一致するデータがない場合、信号の損失が発生します。信号の損失は、さまざまな原因によって引き起こされます。NRQL クエリの`WHERE`句は、インシデントの評価前にデータを除外できます。また、サービスまたはエンティティがオフラインであるか、定期的なジョブの実行に失敗し、データが New Relic に送信されていないことを意味する場合もあります。

不要な通知を避けるために、信号損失インシデントの通知を受け取るまでの待機時間を選択できます。信号損失検出を使用してインシデントを開き、信号が失われたときに通知を受け取ることができます。または、信号の損失を使用して、一時的なサービスまたは散発的なデータ (エラー カウントなど) のインシデントをクローズすることもできます。

### ギャップ埋め [#gap-filling]

ギャップ充填により、信号にデータがない場合に使用する値をカスタマイズできます。データ ストリームのギャップを最後に受信した値、静的な値で埋めるか、何もせずにギャップをそのままにしておくことができます。デフォルトは`None`です。

ストリーミングデータのギャップは、ネットワークやホストの問題によって引き起こされることがあります。また、信号がまばらであったり、エラーカウントなどの一部の信号では、何か問題が発生したときにしかデータが得られないことがあります。ギャップを既知の値で埋めることで、アラート評価プロセスはそれらのギャップを処理し、信号の損失評価にどのような影響を与えるべきかを判断することができます。

<Callout variant="tip">
  アラートシステムは、アクティブに報告された信号のギャップを埋めます。この信号の履歴は、2時間操作が行われないと失われます。ギャップを埋めるために、この非アクティブ期間の後に受信されたデータポイントは新しい信号として扱われます。

  信号損失とギャップ フィリングの詳細については[、このサポート フォーラムの投稿](https://discuss.newrelic.com/t/relic-solution-how-can-i-figure-out-when-to-use-gap-filling-and-loss-of-signal/120401)を参照してください。
</Callout>