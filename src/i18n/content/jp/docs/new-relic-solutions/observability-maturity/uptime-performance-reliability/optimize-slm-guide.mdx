---
title: 'サービスレベル管理: 信頼性の決定に影響を与える'
tags:
  - Observability maturity
  - 'Uptime, performance, and reliability'
  - Service level management
  - Implementation guide
metaDescription: 'New Relic observability maturity series: our service level management guide shows you how to easily measure and communicate the overall health, performance, and quality of your digital products and services to all stakeholders.'
freshnessValidatedDate: never
translationType: machine
---

import omSlTheWholeIsGreater from 'images/om-sl_diagram_theWholeIsGreater.webp'

import apmOverviewScreen from 'images/apm_screenshot-full_overview-screen.webp'

import apmServiceBoundary from 'images/apm_screenshot-crop_service-boundary.webp'

import apmLatencyBaseline from 'images/apm_screenshot-full_latency-baseline.webp'

import apmSLStartFromApm from 'images/apm_screenshot-full_sl-start-from-apm.webp'

import apmAddInputServiceLevel from 'images/apm_screenshot-crop_add-input-service-level.webp'

import apmSyntheticsSetup from 'images/apm_screenshot-crop_synthetics-setup.webp'

import queriesnrqlTransactionListNrql from 'images/queries-nrql_screenshot-full_transaction-list-nrql.webp'

import apmCapabilityFilterClause from 'images/apm_screenshot-crop_capability-filter-clause.webp'

このガイドでは、サービスレベル管理の品質を改善および最適化する方法について説明します。これは[、可観測性の成熟度に関するシリーズ](/docs/new-relic-solutions/observability-maturity/introduction)の一部です。

## 概要 [#overview]

サービスレベル管理は、すべての利害関係者に簡単に伝達できるユニバーサル言語にデータを標準化する方法です。 ITは通常ビジネスを話しませんし、ビジネスは通常ITを話しません。したがって、信頼性を向上させるには、最初に可観測性の言語の壁を解決する必要があります。

信頼性を明確にするための普遍的な言語のこの必要性は、サービスレベル管理を再普及させたものです。サービスレベルの管理は、**稼働時間、パフォーマンス、および信頼性**の実践で最もよく知られています。ただし、サービスレベルの管理は、**カスタマーエクスペリエンス**、**イノベーションと成長**、および**運用効率**の他のプラクティスにも適用されます（[これらのプラクティスの詳細をご覧ください](/docs/new-relic-solutions/observability-maturity/introduction)）。

この実装ガイドでは、**稼働時間、パフォーマンス、および信頼性**の実践のコンテキストでのサービスレベル管理の実践について説明します。

## 期待される成果 [#desired-outcomes]

### 事業成果 [#business-outcomes]

信頼性を実践する上で求められるビジネス上の成果は、ビジネスに影響を与えるインシデントの発生件数、発生期間、それに関わる人数を減らすことです。

1. 業務に支障をきたすインシデントの発生を抑制する
2. 解決までの平均時間 (MTTR) を短縮
3. 重大事故1件当たりの平均従事者数（FTE）を削減する

### 運用成果 [#operational-outcomes]

信頼性の実践におけるサービスレベル管理の必要な運用上の成果は、デジタル製品の健全性をうまく伝達することです。運用の成功は、重要な製品アプリケーションの何パーセントが標準のサービスレベルでカバーされているか、および主要な利害関係者による採用のパーセンテージによって測定されます。これは、利害関係者にとって重要なことに焦点を合わせ、標準化、シンプルさの確保、コンサルティングの散在、およびサービスレベル管理の有効性の証明によって達成されます。

## 用語解説 [#terminology]

このガイドを使用する前に理解しておくと役立つ用語を次に示します。

<CollapserGroup>
  <Collapser
    id="slm-terminology-service-level"
    title="サービスレベル"
  >
    [サービスレベル](https://en.wikipedia.org/wiki/Service_level) 技術に限定せず、システムのパフォーマンスを測定する。サービスレベルは指標によって測定され、期待される性能と結果について設定された目標と比較される。
  </Collapser>

  <Collapser
    id="slm-terminology-service-level-management"
    title="サービスレベル管理"
  >
    サービスレベル管理は、サービスレベルのコンプライアンスと達成を管理および報告する方法です。
  </Collapser>

  <Collapser
    id="slm-terminology-sli"
    title="サービスレベルインジケーター"
  >
    サービスレベルインジケータ（SLI）は、サービスレベルの指標です。 SLIは、測定対象の1つまたは複数を識別します。 SLIは、1つのデータポイントまたはデータポイントの複合にすることができます。テクノロジーでは、SLIは最も一般的に、成功したトランザクションまたはイベントのパーセンテージ（％）として表されます。数学的表現は、1時間、1日、1週間など、指定された期間にわたって計算された有効なイベントの合計に対する良好なイベントの合計です。

    **例SLI。**

    * 500ミリ秒以内に完了したログインAPIトランザクションの割合。
    * ログインAPIトランザクションのうち、内部サーバーエラーなしで完了したトランザクションの割合。
    * 500ミリ秒以内に完了し、内部サーバーエラーが発生しなかったログインAPIトランザクションのパーセンテージ。
    * Login APIに対する合成チェックPingのうち、成功した割合。
    * ブラウザログイン後、3秒以内にランディングページに遷移する割合。
    * インジェストされたメトリクスのうち、3秒以内にクエリーが可能なメトリクスの割合。
    * 上記の一部または全部を1つのSLIに集約した。
  </Collapser>

  <Collapser
    id="slm-terminology-slo"
    title="サービスレベル目標"
  >
    サービスレベル目標（SLO）は、システム、ジョブ、および/または機能の期待されるサービスレベルを説明するステートメントです。 SLOは通常、特定の期間内に1つ以上のSLIが成功するために必要なパーセンテージを表します。

    **SLOの例。**

    * ログインAPIは500ミリ秒以内に応答し、毎週99.99％の時間エラーが発生しません。
    * モバイルログイン機能は、毎週99.99％の時間で3秒以内にランディングページに移行します。
    * メトリクスのデータインジェストは、毎日99.99%の確率でAPIから消費後3秒以内にクエリーを利用できるようになります。
  </Collapser>

  <Collapser
    id="slm-terminology-service-boundary"
    title="サービス境界"
  >
    サービス境界は、消費者クライアントがリクエストを行うために接続するシステム内のポイントです。これは、最も一般的には外部APIまたはエンドポイントと呼ばれる。

    サービス境界は、2つの異なるシステム間の内部にも存在し、アプリケーションの集合が別のアプリケーションの集合のリクエストに応える場合もある。例えば、ID管理システムは、クライアントからのログイン要求と、異なる機能に対する許可認可の両方に対する依存関係になることができる。

    境界の種類：

    * **Internal service boundary**: これらは通常、顧客向けGraphQL APIの背後にあるミドルウェアの依存関係である。GraphQL層に応答する各依存APIは、それ自身の内部サービス境界とみなされるでしょう。内部サービス境界は、全体的な出力パフォーマンスの健全性を1:1の比率で表すものではありません。例えば、GraphQL APIへの顧客のリクエストは、7つの内部依存関係にヒットする可能性があります。1つの遅い依存関係は、元のリクエストの総和レスポンスタイムにはならないでしょう。
    * **Customer-facing service boundary**: 顧客向けのGraphQL API。この境界では、各依存性を測定する必要がなく、パフォーマンスの健全性を測定するために必要なレスポンスタイムとサクセスメトリクスの合計を得ることができます。
  </Collapser>

  <Collapser
    id="slm-terminology-error-budget"
    title="エラーバジェット"
  >
    エラーバジェットは、サービスレベル目標のコンプライアンスを測定し、伝達するための高度な方法です。New Relic では現在、以下の参考文献に記載されているような、エラーバジェットのさまざまな方法を検討しています。最新の情報については、 [サービスレベル管理製品ドキュメント](/docs/service-level-management/intro-slm) を参照してください。

    エラーバジェットとは、"コンプライアンス違反とみなされる前に、どの程度の失敗が許されるかを示すものです。" エラーバジェットを定義し、測定する方法は複数存在します。" "エラーバジェット" の"エラーという言葉は、"500 Internal Server Error" のようなHTTPリクエストエラーやアプリケーションエラーを意味するのではなく、単に"サービスレベル目標で定義されたあらゆる悪いリクエストやイベント" を意味します。

    **注**：エラーバジェットを実装する前に、まずサービスレベルのコンプライアンスを定義、計算、および伝達する能力を構築することをお勧めします。上記の[運用結果](#operational-outcomes)を参照してください。本当に重要なのは、SLIの目標（目的）を設定し、SLIがその目標をどの程度満たしているかを測定することです。たとえば、ログイン要求の24時間ごとに99.99％で、500ミリ秒以内にエラーが発生していませんか？ 24時間のSLIコンプライアンスの結果が99.99％の場合、目標を達成しています。

    **参考文献**

    Googleはエラーバジェットを次のように定義しています。

    "一言で言えば、エラーバジェットとは、ユーザーが不満を持ち始める前に、サービスが一定期間内に蓄積できるエラーの量です。サービスレベルの目標（SLO）に対して、それぞれの目標（SLI）を定義すると、エラーバジェットは、100までの残りになります。" -- [Google Cloud - メンテナンスウィンドウがエラーバジェットに与える影響-SREのヒント](https://cloud.google.com/blog/products/management-tools/sre-error-budgets-and-maintenance-windows)

    アトラシアンはエラーバジェットを次のように定義しています。

    「エラーバジェットとは、技術システムが契約上の影響なしに失敗する可能性がある最大時間です。たとえば、サービスレベル契約（SLA）で、ビジネスが顧客に補償する前にシステムが99.99％の時間機能することが指定されている場合、停止、つまり、エラーバジェット（またはシステムが結果なしにダウンする可能性がある時間）は、年間52分35秒です。」 [--Atlassian-エラーバジェットとは何ですか？なぜそれが重要なのですか？](https://www.atlassian.com/incident-management/kpis/error-budget)
  </Collapser>
</CollapserGroup>

## 主要業績評価指標 [#key-performance-indicators]

### サービスヘルスとは？

正常性は、クライアントでの最終応答、接続性、およびレンダリング可能性によって測定されるすべてのサービスのパフォーマンスの合計です。現実には、あなたのサービスは「デジタル製品」であり、その製品はユーザーにどれだけ受け入れられているかによってのみ優れています。あなたのテクノロジーは、可能な限り複雑ですが、外部APIを除いて、インターネットではほとんど見られないクローズドシステムです。

最も重要なヘルスKPIは、次の質問に答えることによって収集されます。

1. ユーザーにどのくらいの速さで正常に応答を配信できますか？
2. ユーザーは私たちのサービスに接続できますか？
3. クライアントアプリはコンテンツを高速かつ正常にレンダリングできますか？
4. 重要なデータを迅速かつ正常に処理できますか？

### サービスヘルスとは何**ですか**？

従来、ITは、CPU、RAM、ディスク、ネットワークなどのハードウェアデータからヘルスを関連付けることができました。しかし、今日のインフラストラクチャテクノロジーは、特に負荷分散やKubernetesのような組織化されたインフラストラクチャを補います。現在、これらの「メトリック」は診断データと見なされており、アプリケーションのパフォーマンスの問題が検出されたときに確認する障害点の一部にすぎません。

サービスの健全性は、インフラストラクチャデータだけではなく、エンドユーザークライアントのパフォーマンスデータだけでもありません。興味深いことに、多くの人は最初に実際のユーザー監視（RUM）またはエンドツーエンドのトランザクションデータ（分散トレース）を調べて正常性を識別しますが、さらに多くの質問が残されています。

### プロアクト（積極的）の前にリアクト（反応的）を学ぶ

初期の健康データを確立する際には、事後対応型および事前対応型の慣行について議論するのが一般的です。たとえば、インフラストラクチャのハードウェアパフォーマンスがわかっている場合は、障害を予測できます。モノリスアーキテクチャが支配的だったとき、前のステートメントが真実だった時がありました。分散システムには、ハードウェアパフォーマンスとそのハードウェア上にあるアプリケーションの出力パフォーマンスとの間に線形関係（1：1）がないため、これは今日では完全には当てはまりません。

本当にプロアクティブになるためには、まず本当のインプットとアウトプットのデータポイントを確立する必要があります。反応する前に、まず何を測定すべきかを知らなければなりません。プロアクティブになるには、まず対応の仕方を学ばなければなりません。シンプルに、段階的にスキルを身につけましょう。このガイドでは、プロアクティブな行動への最短ルートを紹介します。

現実には、顧客に最も近く、クライアントデバイスの前にあるアプリケーション層から始めることが、顧客の視点から健康データを観察する最短の道なのです。

### プライマリー・ヘルス・データポイントとそのKPI

このガイドでは、以下に定義するように、出力パフォーマンスと入力パフォーマンスのサービスレベル目標を確立して測定する方法を学習します。

クライアントのパフォーマンスについては[、カスタマーエクスペリエンスに関する実装ガイド：品質の基盤で説明さ](/docs/new-relic-solutions/observability-maturity/customer-experience/quality-foundation-implementation-guide)れています。

データ品質については、各ユースケースがデータの入力、出力、および望ましい結果によって大きく異なるため、このガイドでは取り上げない。

**クライアントのパフォーマンス**手順に進む前に、まず**出力パフォーマンス**と**入力パフォーマンス**の手順を実行することを強くお勧めします。出力と入力のSLOは非常に簡単に作成でき、最初に出力と入力のヘルスデータを取得することで投資の見返りが大幅に向上します。確立が容易であることに加えて、入力および出力データポイントは、信頼性の旅のはるかに早い段階で修復パスを提供します。

<CollapserGroup>
  <Collapser
    id="slm-health-output"
    title="出力性能"
  >
    <img
      title="The whole is greater than the sum of its parts. - Aristotle"
      alt="The whole is greater than the sum of its parts. - Aristotle"
      src={omSlTheWholeIsGreater}
    />

    出力パフォーマンスとは、特にバックエンド テクノロジーがリクエストにどれだけうまく応答できるかを指します。

    New Relic のコア機能の 1 つは、膨大な量のデータを非常に迅速に消費してクエリする機能です。これには、驚異的なレベルの並列非同期分散トランザクションを備えた並外れたアーキテクチャが必要であることが想像できます。New Relic は、ほとんどのクライアント向け機能を測定するのと同じように、クエリ出力の健全性を測定します。つまり、HTTP クエリ要求が応答を受信する速度とエラーのない標準によって測定します。NRQL クエリごとに、バックエンドへの 1 つのリクエストとクライアントへの 1 つのレスポンスがあります。アプリケーションとデジタル製品の大多数にとって、これは単純な事実です。

    アウトプット・パフォーマンスは、次のような方法で測定されます。

    * 応答時間（別名、待ち時間）
    * エラーのないパーセンテージ（別名、品質、または可用性）
  </Collapser>

  <Collapser
    id="slm-health-input"
    title="入力パフォーマンス"
  >
    入力パフォーマンスは、アプリケーションに接続する能力によって簡単に測定されます。これは伝統的に「稼働時間」として知られています。上記と同じ例を使用します: NRQL クエリ。

    出力性能は、接続が行われた後の応答を測定します。もし、クライアントとバックエンドの接続に失敗したらどうなるのでしょうか？出力を測定する前に接続が必要なため、その接続障害は出力性能に反映されません。

    New Relicは、 [合成モニタリング](/docs/synthetics/synthetic-monitoring/getting-started/get-started-synthetic-monitoring/)を使用して、世界中からの接続をシミュレートします。 New Relicには、NRQLクエリAPIに対して確立された合成チェックがあります。ソースポイントと出力の間に中断がある場合、これらのチェックは失敗し、サービスレベル目標スコアに反映されます。もちろん、非常に重要なアラートがトリガーされます。

    入力パフォーマンスは次のように測定されます。

    * 外部からのエンドポイントに対するテストが成功した割合です。
  </Collapser>

  <Collapser
    id="slm-health-client"
    title="クライアントのパフォーマンス"
  >
    クライアントパフォーマンスとは、クライアントがある場合、コンテンツを素早く、エラーなくレンダリングする能力のことです。これは、コンバージョン率、継続ユーザー数、保持率、放棄率、製品の全体的な顧客満足度を測定し改善する一般的なカスタマーエクスペリエンスと混同しないようにしましょう。

    クライアントのパフォーマンスの詳細については、 [カスタマーエクスペリエンスに関する実装ガイド：品質の基盤](/docs/new-relic-solutions/observability-maturity/customer-experience/quality-foundation-implementation-guide)を参照してください。
  </Collapser>

  <Collapser
    id="slm-health-data"
    title="データ品質"
  >
    データ品質は、期待されるデータをタイムリーに提供するプロセスの能力を測定します。New Relicは、クエリを実行する前に、まずデータを取り込む必要があります。そのプロセスはほぼリアルタイムで完了することが期待されています。New Relic は、お客様のデータが取り込まれた時間とサンプルを測定し、そのデータがいつクエリで利用可能になるかを判断します。

    データの品質は、入力データを知り、出力データを知り、望ましい結果が得られているかどうかを測定する。これには、結果を監査して正確さを判断することも含まれる。
  </Collapser>
</CollapserGroup>

## 前提条件 [#prerequisites]

### テクニカルイネーブルメント

* プライマリアプリケーションの[APMインストルメンテーション](/docs/apm/new-relic-apm/getting-started/introduction-apm)
* [お客様のアプリケーションの合成テスト](/docs/synthetics/synthetic-monitoring/getting-started/get-started-synthetic-monitoring)

### ラーニングイネーブルメント

* **強くお勧めし**ます： [このサービスレベルガイドに関する無料のインタラクティブオンラインコース](https://learn.newrelic.com/self-paced-service-level-management-in-new-relic/1233749/scorm/3p40vqhz6d4f8)
* [ダッシュボードとNRQL](https://learn.newrelic.com/webinar-getting-started-with-dashboards-nrql)で基本的なスキルを習得する
* [サービスレベル管理UIを](/docs/service-level-management/intro-slm)確認する

## 出力性能のSLIを確立する [#establishing-output-sli]

出力パフォーマンスSLIを確立するための手順の概要は次のとおりです。

1. サービスの特定
2. サービスバウンダリーの特定
3. ベースラインを設定する
4. サービスレベルの作成

次に、これらの手順について詳しく説明します。

### 1.サービスを特定します

を想定しています。

* お客様の主要なアプリケーションは、 [New Relic APM エージェント](/docs/apm/new-relic-apm/getting-started/introduction-apm) でインストルメントされています。
* アプリケーション名は、 [サービス特性ガイド](/docs/new-relic-solutions/observability-maturity/operational-efficiency/sc-implementation-guide/#improvement-process)で概説されているように、おなじみの命名規則に従います。
* アプリケーションは [エンティティ エクスプローラー](/docs/new-relic-solutions/new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts#find)で見つけることができます。

エンティティ エクスプローラーで、アプリケーション (エンティティ タイプ `Services - APM`) を見つけて選択します。以下の概要画面が表示されます。**まだ `Service levels` をクリックしないでください。**

<img
  alt="APM Overview screenshot"
  src={apmOverviewScreen}
/>

### 2.サービス境界の特定 [#identifying-service-boundary]

上記の[用語セクション](#terminology)の[サービス境界](#slm-terminology-service-boundary)の定義を必ずお読みください。

ここでの目標は、最初にサービスの出力を測定していることを確認することです。そのアプリケーションの依存関係はそれぞれ応答時間と成功率に影響しますが、最終および合計の応答時間と成功は、要求が受信されて応答された時点で簡単に測定されます。

[サービスマップ](/docs/new-relic-one/ui-data/service-maps/how-use-service-maps/)と[自動](/docs/new-relic-one/ui-data/automaps)マップを使用して、表示しているアプリケーションがアプリケーションまたはエンドポイントAPIを実行するアプリケーションの依存関係であるかどうかを判断します。

**例**

以下のスクリーンショットでは、あなたは受注処理をサポートするすべてのアプリケーションの責任者です。あなたは、#2 (Order-Composer) を選択して起動し、 **サービスマップ** をクリックしました。そして、Order-Composer は実際には依存関係であることがわかりました。したがって、真の健康サービスレベルを確立するために #1 (Order-Processing) を選択する必要があり ます。

あなたのチームは、依存関係であるOrder-Composerに対してのみ責任を負う場合があります。その場合、Order-Composerの独自のサービスレベルは、パフォーマンスの自己監視に完全に受け入れられます。ヘルスレポートでより適切にフィルタリングできるように、顧客以外のサービスレベルに`customer-facing:false`のタグを付けてください。また、真の出力パフォーマンス、入力接続サービスレベル、およびクライアントサービスレベルを確立するために、可観測性の過程で顧客向けエンドポイント（＃1 Order-Processing）とのコラボレーションを検討してください。

<img
  alt="Service map example"
  src={apmServiceBoundary}
/>

### 3.ベースラインを確立する

ベースラインを確立することは、サービスレベルの導入と実装を加速させるための重要なステップである。設計仕様がどうなっているか、あるいは **がどうあるべきだったかを判断することは、サービスにとってより困難なことです。** 。ベースラインを確立することで、サービスの現在のパフォーマンスを測定することができ、その後、サービスレベルのレポートを通じて、そのベースラインに達しているのか、劣化しているのかを知ることができるようになります。

事実上すべてのデータセットのベースラインを作成できます。ただし、ユースケースごとに異なる式と推奨事項があります。たとえば、一部のデータセットには平均、他のデータセットにはパーセンタイル、その他には最大を使用する必要があります。

サービスレベルを開始するときは、アプリケーションの[出力パフォーマンス](#key-performance-indicators)から開始する必要があります。このために、応答時間（待機時間）と非エラーの割合（成功）を使用します。

**どのくらいの歴史を考慮する必要がありますか？**実際、それほど多くはありません。信頼性の健全性メトリックを確立しています。季節性とピーク使用量は、良好なパフォーマンスのハンディキャップではありません。また、測定に含める履歴が多いほど、リリースとは異なるコードベースが含まれている可能性が高くなります。以前の展開では、どんなに小さくても、結果が歪む可能性がありました。

推奨される履歴は、公正なベースラインを確立するための1〜2週間のパフォーマンスデータです。

#### ベースライン例

レイテンシの7日間のサービスレベル目標の推奨ターゲットを表すNRQLクエリの例を次に示します。

```
FROM Transaction SELECT percentile(duration, 95) AS 'Latency Baseline SLI' WHERE appName='Order-Processing' SINCE 1 WEEK AGO
```

<img
  alt="Latency Baseline"
  src={apmLatencyBaseline}
/>

ベースラインを成功（エラーなし）にするには、次のクエリを試してください。必ず、独自のアプリケーション名を`Order-Processing`に置き換えてください。

```
FROM Transaction SELECT percentage(count(*), WHERE error is false) AS 'Success Baseline SLI' SINCE 1 WEEK AGO WHERE appName='Order-Processing'
```

### 4.サービスレベルを作成します

New Relic プラットフォームは推奨値を自動的に計算します。 <InlinePopover type="apm"/>そして<InlinePopover type="browser"/>あなたのためのベースライン。

**注：** \[**サービスレベルの追加**]ボタンが表示されない場合は、権限についてNewRelic管理者に確認してください。

上記の「[サービスの識別](#1-identifying-your-service)」セクションは、アプリケーションのAPMデータを見つける方法を示しています。同じセクションのスクリーンショットに「サービスレベル」と呼ばれる＃2が表示されます。アプリケーションのAPMデータを見つけて、\[**サービスレベル**]をクリックします。以下のビューが表示されます。

<img
  alt="Service levels start from APM"
  src={apmSLStartFromApm}
/>

**Add baseline service level objectives** をクリックすると、ほとんど即座にLatency SLIとSuccess SLIの両方とそれぞれの目標が作成されます。

各 SLO スコアカードの右上にある 3 つの点のアイコンをクリックすると、すべての設定を表示および変更できます。

**注：**データがSLOスコアに入力されるまで約10分かかります。これは、データの寿命とクエリのパフォーマンスのために[events-to-metricsサービス](/docs/data-apis/convert-to-metrics/create-metrics-other-data-types/)を使用しているためです。変換が行われ、データの入力が開始されるまで少し時間がかかります。

## 入力性能のSLIを確立する [#establishing-input-sli]

入力パフォーマンスSLIを確立するプロセスの概要：

1. 合成チェックを作成します。
2. サービスレベルインジケーターを作成する。

以下は、これらの手順の詳細です。

### 1.合成チェックを作成します

最も一般的な入力パフォーマンス サービス レベルは、「接続性」または「アップタイム」と呼ばれることがよくあります。これは、Health API エンドポイントに対する単純なチェック、または単に URL をロードすることです。これらは両方とも、合成監視サービスを使用して簡単に実行できます。データのレポートを開始する方法については、[単純なブラウザー モニター](/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors#simple)の[追加およびスクリプト API テスト](/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors#complex)の追加を参照してください。

### 2.サービスレベルインジケーターを作成します

その最初のステップを完了すると、データが得られるはずです。

次に、サービスレベル管理サービスを使用して、入力インジケーターと目的を作成します。

[エンティティ エクスプローラー](/docs/new-relic-solutions/new-relic-one/core-concepts/new-relic-explorer-view-performance-across-apps-services-hosts#find)で、右側の **Service levels** \[サービス レベル] を選択し、 **+ Add a service level indicator** \[+ サービス レベル インジケーターの追加] をクリックします。

**注：** \[**サービスレベルの追加**]ボタンが表示されない場合は、権限についてNewRelic管理者に確認してください。

次に、エンティティタイプを`Synthetic monitors`にフィルタリングします。以下のスクリーンショットを参照してください。

<img
  alt="Filter entity types in service levels"
  src={apmAddInputServiceLevel}
/>

次のステップ

1. そのリストで合成モニターを見つけてクリックします。これにより、左側のパネルの\[**続行**]ボタンが有効になります。 \[**続行]**をクリックします。
2. **成功**サービスレベルの推奨設定のボタンが表示されます（以下を参照）。クリックして。
3. 必要に応じて、タグ、タイトル、説明に適切な変更を加えます。
4. クリック **保存**.

<img
  alt="Synthetics input service level guided flow"
  src={apmSyntheticsSetup}
/>

## ケイパビリティSLIの確立 [#capability-SLI]

ここが、サービスレベルの採用を本当に加速させることになるのです

この作業を行うには、アプリケーションやサービスに関する深い知識は必要ありません。単に消費者向けのAPI（サービス境界）がどこにあるかを知っていればよく、以下のステップに従ってください。

これは、可観測性の成熟の旅における主要なステップです。ログインや支払いの承認などの重要なビジネス機能にサービスレベルを設定すると、ITとビジネスの間の言語の壁が急速に閉じられます。機能のサービスレベルスコアは、サービスレベルが低下し始めたときに、より正確な修復パスも提供します。たとえば、ログインサービスレベルが低下し始めた場合は、ID管理の依存関係と、コンシューマー向けAPIから始まるワークフローを確認する必要があります。

**注:**このタスクでは、「[出力 SLI の確立](#establishing-output-sli)」セクションで学んだスキルを基に構築します。

このプロセスの概要は次のとおりです。

1. アプリケーションの能力を評価する。
2. 能力のベースラインを設定する。
3. ケイパビリティ・サービス・レベルを作成する。

これらの手順については、以下で詳しく説明します。

上記[の「出力 SLI の確立](#establishing-output-sli)」セクションで説明したように、サービス境界アプリケーションを識別します。

次のNRQLクエリを実行して、最も頻繁に使用されるトランザクションのベースラインを特定します。 `Order-Processing`は必ず特定したアプリケーション名に置き換えてください。

```
FROM Transaction SELECT count(*), percentile(duration, 95) WHERE appName='Order-Processing' FACET name SINCE 1 WEEK AGO
```

下のスクリーンショットのようなものが表示されるはずです。

<img
  alt="transaction list query"
  src={queriesnrqlTransactionListNrql}
/>

最初のトランザクションには、「購入」と関係があることが示されています。「購入」機能のサービス レベルを作成できるようになりました。

**注：**このトランザクションが購入機能を表しているかどうかわからない場合でも、この演習は、アプリケーションチームとリーダーシップに機能サービスレベルの価値を示す良い例になります。ここでの目標は、可能な限りの芸術を示すことによって、利害関係者との会話を開始することであることを忘れないでください。

クエリの最後に`WHERE name='Controller/Sinatra//purchase'`を追加し、 `Controller/Sinatra//purchase`をトランザクション名に置き換えます。クエリを実行して、機能することを確認します。これで、結果に1つのトランザクションのみが表示されるはずです。このクエリと`DURATION (95%)`の結果をメモ帳にコピーします。すぐに両方が必要になります。

プラットフォームで新しいサービスレベルを作成します。新しいサービス・レベルの開始については、 [入力パフォーマンス SLI の確立](#establishing-input-sli) で説明しています。

この場合、リストでアプリケーション（APM `Entity`タイプ）を検索して、エンティティGUIDを介してメタデータ（タグ）を保持できるようにします。上記のセクションの「合成モニター」の代わりに、エンティティフィルターのドロップダウンで「APM」を選択します。

"Latency" ガイド付きワークフローを選択すると、有効なクエリーが自動入力されます。

メモ帳を使用して、 `name='your/transaction/name/here'`だけをコピーします。

以下のスクリーンショットで下線が引かれているように、この条件をサービスレベルの両方のクエリに追加**`AND `**ます。

<img
  alt="capability query clause"
  src={apmCapabilityFilterClause}
/>

2番目のクエリの`duration < 1.78`部分を調整して、メモ帳にコピーされた元のベースラインの`DURATION (95%)`結果と一致させるだけです。

このサービス・レベルに名前を付け、説明を更新し、サービス・レベルを保存します。

このようなケイパビリティ・サービス・レベルをいくつか設定し、アプリケーション・チームとリーダーシップに提示してフィードバックを得ることをお勧めします。

## 改善プロセス [#improvement-process]

### アラート品質管理

[アラート品質管理](/docs/new-relic-solutions/observability-maturity/uptime-performance-reliability/aqm-implementation-guide)は、サービスレベル管理と非常によく調和するもう1つの可観測性成熟度プラクティスです。アラート品質データとサービスレベルデータの両方の価値は、アラートポリシーが実際の影響と一致しているか、単にノイズを発生させているかを確認できることです。良いアラート、欠落しているアラート、およびノイズの多いアラートを検証できます。

これは、SLIコンプライアンスクエリーとアラート品質クエリーを並べたカスタムダッシュボードを作成することで実現できます。

まだ読んでいない場合は、 [アラート品質管理ガイド](/docs/new-relic-solutions/observability-maturity/uptime-performance-reliability/aqm-implementation-guide)を確認してください。

### 採用・継続的改善

サービスレベルや信頼性の向上には、そのサービスに関わる全ての関係者がその実践を採用することが必要です。これには、エンジニアリングマネジメント、プロダクトマネジメント、エグゼクティブマネジメントが含まれますが、これらに限定されるものではありません。第一の目標は、サービスレベルの威力と価値を利害関係者に素早く示し、それらの利害関係者にとって何が本当に重要なのかについて有意義な議論を始めることである。このガイドのステップでは、そのような有意義な議論を非常に迅速に行うことができます。

高い採用率を誇る実証済みの方法として、まず1つのデジタル製品とその重要な機能について、出力性能と入力性能のサービスレベルを設定する方法があります。これには通常、各エンドポイントアプリケーション（通常は1つか2つ）に対して1つの全体的な出力と入力のサービスレベルを設定し、次にエンドポイントトランザクションで測定した想定される重要な能力に対しておよそ4～7の出力パフォーマンスサービスレベルを設定します。

この方法には、測定すべきものと測定すべきでないものについて各利害関係者を調査し**ない**ことが含まれます。調査は通常、長い待ち時間、多くの質問、欲求不満、実証された価値の欠如、および次善の回答をもたらします。ベースラインと主要なトランザクションを「機能」として開始することを忘れないでください。

上に示したように、これらのエンドポイントが何であるか、およびどのエンドポイントトランザクションがどの機能を構成するかを自由に想定します。最初は精度が鍵ではありません。キックオフを成功させる秘訣は、健康状態を簡単に測定して伝達する能力を実証することです。その最初のデモンストレーションは、プライマリサービスレベルで測定されるものと測定されないものを改善するためにより多くの時間を投資することの価値を示します。

待たなくていい。そのデモを早く提供し、そのデモがより完全であればあるほど、より早く幅広い採用を達成し、すべての関係者と協力して信頼性向上プロセスを開始することができるのです!

### オートメーション

ステークホルダーにとって何が有効か（そして何が有効でないか）を確立したら、次に自動化によってスケールアップしたSLMを設計し始めることができます。サービスレベル管理の自動化については、 [New Relic Terraform library](https://registry.terraform.io/providers/newrelic/newrelic/latest/docs/resources/service_level) で勉強を始めることができます。

## 事業価値

上記の「[望ましい結果](#desired-outcomes)」のセクションで述べたように、口頭での最終的な結果は、ビジネスに影響を与えるインシデントのコストを削減することです。

ただし、サービス レベルは、インシデント時の推定収益損失と、サブスクリプション ベースのビジネスのリスクにさらされる推定収益の両方を定量化するのにも役立ちます。

**収益の損失**は、オンライン小売などのトランザクションによって生成された収益と、ペナルティが組み込まれたサービスレベル契約契約を結んでいる場合に支払われるペナルティについて簡単に見積もることができます。

**リスクのある収益**は、各顧客が月次または年次のサブスクリプション値を持つサブスクリプションベース（SaaS）のビジネスモデルの場合です。影響を受ける顧客の数と期間ごとのサブスクリプション収益を簡単に見積もり、「リスクのある収益」を計算できます。注：サブスクリプションビジネスは、サービスレベルアグリーメント契約内にペナルティを課すこともできます。これは、以下に示すように含める必要があります。

### サービスレベル契約違反による直接コストの定量化

以前の侵害のコストを決定します。たとえば、オンライン小売企業は、サービス損失 (ダウンタイム) 中の 1 分あたりの推定収益損失を知っています。法務担当者は、サービス レベル アグリーメント (SLA) 契約違反による違約金を教えてくれます。どちらの損失も、サービス レベル違反に関する New Relic データを使用してリアルタイムで簡単に _推定_ できます。

### サービスレベル違反による収益機会コストの定量化

以下の3つの変数を決定します。

* (A) 罰則または収益損失を引き起こした違反の数
* (B) 侵害の平均期間
* （C）1分/時間あたりの平均ペナルティまたは収益損失

これらの3つの変数（A _B_ C）を乗算して、回復する総収益機会を計算します。

### 収益漏れの定量化

以下の2つの変数を決定します。

* （A）総収入（期間あたり）
* （B）顧客に支払われたペナルティの合計（Aと同じ期間あたり）

B / Aを除算して、収益リーク率を計算します。

## サービス レベル目標の追跡 [#tracking-slo]

サービス レベルは、テスト、アラート、ゲームデー、およびその他の定期的なプラクティスと同様に、プラクティスです。それらは、システムの「健全性」を測定するのに役立つ科学的手段と考えることができます。しかし、すべてのツールと同様に、サービス レベルにはキャリブレーションが必要です。

チームのプロセスにサービス レベルの実践を含めます。以下の推奨事項は、New Relic のチーム内でサービス レベルを使用した経験から抽出されたものであり、特定のチーム要件に合わせて調整する必要があります。

* サービス レベルを定期的に見直し、次の点に細心の注意を払います。

  * SLI はインシデントとページを反映していますか?

  * 1 週間のエラー バジェットはいくらですか?

    * 値が低すぎる場合は、「分析」機能を使用してドロップの原因を調査し、原因となった悪いイベントを見つけます。
    * 100% の場合は、インジケーターが正しく、SLO が十分に積極的であることを確認してください。100% であることは、SLO が安全すぎることを示します。
    * さまざまな期間 (1 日/7 日/28 日) で観察される傾向は何ですか。

* 試合中は SLI に注意してください。SLI は、アラートと同様に影響を反映する必要があります。

* 本番環境でエラー バジェットが低下した場合は、ステージングで発生しなかった理由を評価します。

## 次のステップ [#next-steps]

可観測性成熟度プラクティスの次のステップは、クライアントブラウザまたはモバイルデバイスで測定されたカスタマーエクスペリエンスサービスレベルを追加することです。繰り返しになりますが、上記の改善プロセスで説明したように、最初に価値を証明することが重要です。覚えておいてください：可観測性は旅であり、成熟には時間、練習、そして忍耐が必要です。

旅を続けるには、以下を参照してください。

* [カスタマー エクスペリエンスに関するガイド: 品質基盤](/docs/new-relic-solutions/observability-maturity/customer-experience/quality-foundation-implementation-guide).
* まだ読んでいない場合は、 [アラート品質管理](/docs/new-relic-solutions/observability-maturity/uptime-performance-reliability/aqm-implementation-guide)に関するガイドを参照してください。