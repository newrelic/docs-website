---
title: 'NerdGraph チュートリアル: RAG インテグレーションのセットアップ'
metaDescription: Enhance New Relic AI with RAG (Retrieval Augmented Generation)
freshnessValidatedDate: never
translationType: machine
---

<Callout title="プレビュー">
  この機能はまだ開発中ですが、ぜひお試しください。

  この機能は現在、弊社の[プレリリース ポリシー](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy)に従ってプレビュー プログラムの一部として提供されています。
</Callout>

New Relicを使用すると、ドキュメント、Runbook、インシデント レトロ、さらにはソース コードをサービスに関連付けることにより、検索拡張生成 (RAG) を使用してNew Relic AIエージェントを強化できます。 このプロセスにより、 New Relic AIシステムの問題に対するインサイトを改善します。 このチュートリアルでは、組織 ID を取得し、RAG ツールを作成し、Blob API を使用してプラットフォームにドキュメントを追加する方法について説明します。

ドキュメントを追加したら、それらを RAG ツールに関連付ける関係を作成します。その後、RAG ドキュメントと RAG ツール間の関係を照会して設定を確認できます。 最後のステップは、RAG ツール自体にクエリを実行して、関連するインデックス付き情報を取得することです。

ナレッジ コネクタの詳細については、 [「New Relic AI ナレッジ コネクタ」](/docs/agentic-ai/knowledge-integration/overview)を参照してください。

<Callout variant="important">
  次の手順を実行する前に、「組織製品管理者」権限があることを確認してください。
</Callout>

コンテンツのインデックス作成を開始し、New Relic AI のナレッジ コネクタのメリットを活用するには、次の手順に従ってください。

## タスク1: RAGツールを作成する [#create-your-rag-tool]

<CollapserGroup>
  <Collapser id="get-started" title="組織IDを取得する">
    組織 ID はアカウントを一意に識別し、作成した RAG ツール、アップロードしたドキュメント、確立した関係がNew Relic内の組織に関連付けられることを保証します。

    RAG ツールとドキュメントを設定および管理するときに、NerdGraph でミューテーションとクエリを実行するには組織 ID が必要です。次のクエリを実行し、組織 ID を後の手順で使えるように保管しておきます。

    ### サンプルクエリ

    ```graphql
    {
      actor {
        organization {
          id
        }
      }
    }
    ```
  </Collapser>

  <Collapser id="create-rag-tool" title="RAGツールを作成する">
    RAG ツールは、New Relic 内の関連ドキュメントとリソースを整理するための専用のコンテナーとして機能します。RAG ツールの明確な名前と正確な説明は、LLM が各プロンプトに対して適切なツールを選択するのに役立ち、関連性のあるコンテキスト認識型の応答を保証します。

    New Relic アカウントに新しい RAG ツールを作成するには、次の`entityManagementCreateRagTool`ミューテーションを実行します。

    1. `${ORGANIZATION_ID}` 、前の手順で取得した実際の組織 ID に置き換えてください。
    2. 成功した場合、RAG ツールに対して`id`受け取ります。

    ### 入力

    <table>
      <thead>
        <tr>
          <th>
            問題の名前
          </th>

          <th>
            データタイプ
          </th>

          <th>
            必須ですか?
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `ragToolEntity`
          </td>

          <td>
            オブジェクト
          </td>

          <td>
            はい
          </td>

          <td>
            新しい RAG ツールの設定を含む入力オブジェクト。
          </td>
        </tr>

        <tr>
          <td>
            `description`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            RAG ツールの目的を明確かつ正確に説明します。
          </td>
        </tr>

        <tr>
          <td>
            `name`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            RAG ツールの一意の名前。
          </td>
        </tr>

        <tr>
          <td>
            `scope`
          </td>

          <td>
            オブジェクト
          </td>

          <td>
            はい
          </td>

          <td>
            ツールが作成されるコンテキストを定義するオブジェクト。
          </td>
        </tr>

        <tr>
          <td>
            `scope.id`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            組織の一意の ID ( 

            `${ORGANIZATION_ID}`

             )。
          </td>
        </tr>

        <tr>
          <td>
            `scope.type`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            スコープのタイプ。 

            `ORGANIZATION`

            である必要があります。
          </td>
        </tr>
      </tbody>
    </table>

    ### サンプル変異

    ```graphql
    mutation {
      entityManagementCreateRagTool(
        ragToolEntity: {
          description: "Runbooks for resolving incidents with APIs",
          name: "API Runbooks",
          scope: {id: `${ORGANIZATION_ID}`, type: ORGANIZATION}
        }
      ) {
        entity {
          id
        }
      }
    }
    ```

    返された`id`は、後の手順でドキュメントをツールにリンクしたり、関係を検証したり、 New Relicで関連情報をツールに照会したりするときに必要になるため、保存する必要があります。
  </Collapser>
</CollapserGroup>

## タスク2: ドキュメントのインデックスを作成する [#index-your-documents]

<CollapserGroup>
  <Collapser id="upload-document" title="Blob API経由でドキュメントをアップロードする">
    <Callout variant="important">
      インデックスが作成されたすべてのドキュメントは、組織内のすべてのユーザーに表示されます。インデックスを作成するドキュメントが社内ポリシーに準拠していることを確認し、機密データや個人情報をアップロードしないでください。
    </Callout>

    ### Blob APIとその目的

    Blob API は、ドキュメントやランブックなどのファイルをアカウントにアップロードするために設計された New Relic サービスです。NerdGraph は構造化データのクエリと変更に最適化されており、効率的なファイル転送には最適化されていないため、ドキュメントのアップロードには Blob API が必要です。

    ### 認証要件

    ドキュメントをアップロードする権限を持つ有効なNew Relic APIキーが必要です。 Blob APIを使用してNew RelicにドキュメントをアップロードするためのAPIキーを取得するには:

    1. [New Relic](https://one.newrelic.com/)アカウントにログインします。
    2. [APIキーUIページ](https://one.newrelic.com/administration/api-keys)からAPIキーを作成および管理します。
    3. **Create a key**\[キーの作成]をクリックし、必要な詳細を入力します (または必要な権限を持つ既存のキーを使用します)。
    4. **Create a key**\[キーの作成]をクリックし、生成されたキー (NRAK-XXXXXXXXXX のようになります) をコピーします。

    `curl` `bash`コマンドを使用してドキュメントをアップロードする方法の例を次に示します。

    ### 入力

    <table>
      <thead>
        <tr>
          <th>
            問題の名前
          </th>

          <th>
            データタイプ
          </th>

          <th>
            必須ですか?
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `Api-Key`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            認証用のNew Relic APIキー。
          </td>
        </tr>

        <tr>
          <td>
            `NewRelic-Entity`
          </td>

          <td>
            JSONオブジェクト
          </td>

          <td>
            はい
          </td>

          <td>
            ドキュメントの名前など、ドキュメントに関するメタデータ。
          </td>
        </tr>

        <tr>
          <td>
            `Content-Type`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            アップロードされるファイルの形式 (例: 

            `application/json`

             )。
          </td>
        </tr>

        <tr>
          <td>
            `payload`

             ( 

            `@incidents.json`

             )
          </td>

          <td>
            ファイル
          </td>

          <td>
            はい
          </td>

          <td>
            アップロードするドキュメント ファイル (ファイル パスで指定)。
          </td>
        </tr>
      </tbody>
    </table>

    ### サンプルクエリ

    ```shell
    curl -X POST https://blob-api.one-service.newrelic.com/v1/e/organizations/$ORGANIZATION_ID/RagDocuments \
         -H 'Api-Key: NRAK-XXXXXXXXXX' \
         -H 'NewRelic-Entity: {"name": "Runbooks for API service" }' \
         -H 'Content-Type: application/json' \
         -d @incidents.json
    ```

    ### サンプル回答

    <table>
      <thead>
        <tr>
          <th>
            レスポンス
          </th>

          <th>
            データタイプ
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `entityGuid`
          </td>

          <td>
            弦
          </td>

          <td>
            アップロードされた RAG ドキュメントの一意の識別子。
          </td>
        </tr>

        <tr>
          <td>
            `blobVersionEntity`
          </td>

          <td>
            オブジェクト
          </td>

          <td>
            アップロードされた BLOB のバージョンを表します。
          </td>
        </tr>
      </tbody>
    </table>

    ```json
    {
      "entityGuid": "MTIyODU0NTN8TkdFUHxSQUdfRE9DVU1FTlR8MDE5NGUyOTgtYmQzMS03NzA4LWI3NzItYzQ4MTZlYjNhYThk",
      "blobVersionEntity": null
    }
    ```

    ### 次のステップ

    ドキュメントをアップロードすると、インデックスが作成され、New Relic AI で検索および取得できるようになります。RAG ツールとの関係を作成したり、NerdGraph でドキュメントをクエリしたりするには、応答から`entityGuid`保存する必要があります。
  </Collapser>

  <Collapser id="view-the-rag-document-entity-represented-in-nerdgraph" title="NerdGraphで表現されたRAGドキュメントエンティティを表示する">
    ドキュメントが Blob API 経由でアップロードされた後、このクエリを実行すると、アップロードが成功したこと、およびドキュメントが独自の一意の識別子とプロパティを持つ RAG ドキュメント エンティティとして適切に登録されたことが確認されます。

    #### 入力

    <table>
      <thead>
        <tr>
          <th>
            問題の名前
          </th>

          <th>
            データタイプ
          </th>

          <th>
            必須ですか?
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `id`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            取得する RAG ドキュメントの一意の GUID。
          </td>
        </tr>
      </tbody>
    </table>

    ### サンプルクエリ

    以下のクエリで、 `${RAG_DOCUMENT_GUID}`プレースホルダーを前の手順で受け取った`entityGuid`に置き換えます。

    ```graphql
    {
      actor {
        entityManagement {
          entity(
            id: `${RAG_DOCUMENT_GUID}`
          ) {
            ... on EntityManagementRagDocumentEntity {
              id
              name
              blob {
                url
              }
              type
            }
          }
        }
      }
    }
    ```

    このクエリは、RAG ドキュメントに関する次の詳細を返します。

    * `id`: RAG ドキュメントの固有 ID。
    * `name`: RAG ドキュメントの名前。
    * `blob { url }`: アップロードされたドキュメントにアクセスするための URL。
    * `type`: エンティティのタイプ。この場合は`EntityManagementRagDocumentEntity`です。
  </Collapser>

  <Collapser id="create-a-relationship-between-the-rag-document-and-the-rag-tool" title="RAGツールとRAGドキュメントの関係を作成する">
    RAG ツールを作成し、ドキュメントをアップロードし、アップロードが成功したことを確認したので、次のステップでは、RAG ツールと RAG ドキュメントを関連付けて、ドキュメントを New Relic AI で検索および使用できるようにします。これを行うには、 `entityManagementCreateRelationship`ミューテーションを実行します。

    1. `${RAG_DOCUMENT_GUID}` 、Blob API 経由のドキュメントアップロードの応答からの`entityGuid`に置き換えます。
    2. `${RAG_TOOL_GUID}` 、RAG ツール作成ミューテーションの応答からの`id`に置き換えます。

    ### 入力

    <table>
      <thead>
        <tr>
          <th>
            問題の名前
          </th>

          <th>
            データタイプ
          </th>

          <th>
            必須ですか?
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `relationship`
          </td>

          <td>
            オブジェクト
          </td>

          <td>
            はい
          </td>

          <td>
            関係の詳細を含む入力オブジェクト。
          </td>
        </tr>

        <tr>
          <td>
            `source`
          </td>

          <td>
            オブジェクト
          </td>

          <td>
            はい
          </td>

          <td>
            リレーションシップのソース エンティティ (RAG ドキュメント)。
          </td>
        </tr>

        <tr>
          <td>
            `source.scope`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            ソース エンティティのスコープ。 

            `ORGANIZATION`

            である必要があります。
          </td>
        </tr>

        <tr>
          <td>
            `source.id`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            RAG ドキュメントの一意の GUID ( 

            `${RAG_DOCUMENT_GUID}`

             )。
          </td>
        </tr>

        <tr>
          <td>
            `target`
          </td>

          <td>
            オブジェクト
          </td>

          <td>
            はい
          </td>

          <td>
            リレーションシップのターゲット エンティティ (RAG ツール)。
          </td>
        </tr>

        <tr>
          <td>
            `target.scope`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            ターゲット エンティティのスコープ。 

            `ORGANIZATION`

            である必要があります。
          </td>
        </tr>

        <tr>
          <td>
            `target.id`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            RAG ツールの一意の GUID ( 

            `${RAG_TOOL_GUID}`

             )。
          </td>
        </tr>

        <tr>
          <td>
            `type`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            関係のタイプ。 

            `"INDEXED_FOR"`

            である必要があります。
          </td>
        </tr>
      </tbody>
    </table>

    ### サンプル変異

    ```graphql
    mutation {
      entityManagementCreateRelationship(
        relationship: {
          source: {
            scope: ORGANIZATION,
            id: `${RAG_DOCUMENT_GUID}`
          },
          target: {
            scope: ORGANIZATION,
            id: `${RAG_TOOL_GUID}`
          },
          type: "INDEXED_FOR"
        }
      ) {
        relationship {
          type
          target {
            id
            type
          }
          source {
            id
            type
          }
        }
      }
    }
    ```
  </Collapser>
</CollapserGroup>

## タスク3: 関連情報を取得する [#retrieve-relevant-information]

<CollapserGroup>
  <Collapser id="query-to-see-relationships-between-rag-documents-and-rag-tools" title="RAG ドキュメントと RAG ツールの関係を確認するためのクエリ">
    RAG ドキュメントと RAG ツール間の関係を作成した後、NerdGraph で関係を照会して関連付けを検証できます。これにより、ドキュメントが適切にリンクされ、New Relic AI で使用できるようになります。

    * `${RAG_DOCUMENT_ID}`アップロードしたドキュメントの`entityGuid`に置き換えます。

    ### 入力

    <table>
      <thead>
        <tr>
          <th>
            問題の名前
          </th>

          <th>
            データタイプ
          </th>

          <th>
            必須ですか?
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `relationships`
          </td>

          <td>
            クエリ
          </td>

          <td>
            はい
          </td>

          <td>
            エンティティ間の関係を取得するためのクエリ。
          </td>
        </tr>

        <tr>
          <td>
            `filter`
          </td>

          <td>
            オブジェクト
          </td>

          <td>
            いいえ
          </td>

          <td>
            属性に基づいて関係をフィルタリングするために使用されるオブジェクト。
          </td>
        </tr>

        <tr>
          <td>
            `filter.sourceId`
          </td>

          <td>
            オブジェクト
          </td>

          <td>
            いいえ
          </td>

          <td>
            ソース エンティティの一意の識別子でフィルターするオブジェクト。
          </td>
        </tr>

        <tr>
          <td>
            `filter.sourceId.eq`
          </td>

          <td>
            弦
          </td>

          <td>
            いいえ
          </td>

          <td>
            一致する RAG ドキュメントの一意の GUID。
          </td>
        </tr>
      </tbody>
    </table>

    ### サンプルクエリ

    ```graphql
    {
      actor {
        entityManagement {
          relationships(
            filter: {sourceId: {eq: `${RAG_DOCUMENT_ID}`}}
          ) {
            items {
              type
              target {
                id
                type
              }
            }
          }
        }
      }
    }
    ```
  </Collapser>

  <Collapser id="query-the-rag-tool" title="RAGツールをクエリする">
    RAG ツールとインデックス付きドキュメントを設定したら、RAG ツールにクエリを実行して、プロンプトに基づいて関連情報を取得できます。これにより、New Relic AI は組織のドキュメントを使用してコンテキストに応じた回答を表示できるようになります。

    ### 入力

    <table>
      <thead>
        <tr>
          <th>
            問題の名前
          </th>

          <th>
            データタイプ
          </th>

          <th>
            必須ですか?
          </th>

          <th>
            説明
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `prompt`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            RAG ツールで処理する自然言語クエリ。
          </td>
        </tr>

        <tr>
          <td>
            `toolId`
          </td>

          <td>
            弦
          </td>

          <td>
            はい
          </td>

          <td>
            書き込まれる RAG ツールの一意の GUID。
          </td>
        </tr>
      </tbody>
    </table>

    ### サンプルクエリ

    ```graphql
    {
      actor {
        machineLearning {
          ragQueryData(
            prompt: "tell me about the incident", 
            toolId: `${RAG_TOOL_GUID}`
          ) {
            blobId
            chunk
            documentId
            score
            toolId
          }
        }
      }
    }
    ```

    レスポンスには、インデックス付けされたドキュメントからのチャンク化された一致が含まれます。これは直接使用することも、New Relic AI で要約することもできます。
  </Collapser>
</CollapserGroup>