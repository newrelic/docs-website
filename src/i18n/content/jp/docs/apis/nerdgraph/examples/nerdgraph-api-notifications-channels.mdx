---
title: 'NerdGraph チュートリアル: アラート チャネル'
tags:
  - Notifications
  - Notifications and Nerdgraph
  - Channels
  - Notification Channels
metaDescription: 'For New Relic alerts: how you can list, create, update, and delete channels with our NerdGraph API.'
freshnessValidatedDate: never
translationType: machine
---

[UIで集計通知チャネル](/docs/alerts-applied-intelligence/notifications/intro-notifications)を管理するだけでなく、NerdGraph APIを使用することもできます。

<Callout variant="important">
  このドキュメントでは、宛先と通知メッセージを使用した新しい通知プラットフォームでのNerdgraphAPIの使用について説明します。通知メッセージはチャネルとも呼ばれ、従来の通知チャネルとは異なります。
</Callout>

<Callout variant="tip">
  NerdGraphの使用を開始するためのヘルプについては、NerdGraphの[概要を](/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph)参照してください。
</Callout>

## チャネルの一覧表示とフィルタリング [#list-and-filter]

`channels`クエリを使用すると、アカウントごとにすべてのチャネルをページ分割できます。また、いくつかのフィルタリング機能を許可します。

<CollapserGroup>
  <Collapser id="list-all-channels" title="アカウントのすべてのチャンネルを一覧表示する">
    次の例を見てみましょう。

    ```graphql
    {
      actor {
        account(id: YOUR_ACCOUNT_ID) {
          aiNotifications {
            channels {
              entities {
                id
                name
              }
              error {
                details
              }
            }
          }
        }
      }
    }
    ```
  </Collapser>

  <Collapser id="paginate" title="カーソルページ付けを使用したチャネルのページ付け">
    チャネルをページ分割するには、最初のクエリで`nextCursor`フィールドをリクエストする必要があります。

    カーソルページネーションを使用すると、応答から返される`nextCursor`が空に戻るまで、結果セットを介して要求を続けます。これは、結果の最後に到達したことを意味します。

    次の例を見てみましょう。

    ```graphql
    {
      actor {
        account(id: YOUR_ACCOUNT_ID) {
          aiNotifications {
            channels(cursor: "") {
              nextCursor
              entities {
                id
                name
              }
              totalCount
            }
          }
        }
      }
    }
    ```

    上のコードは、次のような結果のセットを返します。

    ```json
    {
      "data": {
        "actor": {
          "account": {
            "aiNotifications": {
              "channels": {
                "nextCursor": "/8o0y2qiR54m6thkdgHgwg==:jZTXDFKbTkhKwvMx+CtsPVM=",
                "entities": [
                  {
                    "id": "01c0cbe7-3d70-47c1-99e0-adf906eed6c2",
                    "name": "Channel Name"
                  },
                  {
                    "id": "05db0207-c137-4985-8cb5-f21e7e57b8cc",
                    "name": "Another Channel Name"
                  }
                  // ... more channels here in reality
                ],
                "totalCount": 807
              }
            }
          }
        }
      }
    }
    ```

    そのため、その後のリクエストでは、カーソルが空になるまで、このようにカーソルを提供します。

    ```graphql
    {
      actor {
        account(id: YOUR_ACCOUNT_ID) {
          aiNotifications {
            channels(cursor: "/8o0y2qiR54m6thkdgHgwg==:jZTXDFKbTkhKwvMx+CtsPVM=") {
              nextCursor
              entities {
                id
                name
              }
              totalCount
            }
          }
        }
      }
    }
    ```
  </Collapser>

  <Collapser id="find-channels-by-name" title="名前ですべてのチャンネルを検索">
    APIは、名前によるチャネルクエリを許可します。`name`フィルターは、完全一致と部分一致を返します。大文字と小文字は区別されません。これにより、指定された名前に一致するチャネルの情報のみが返されます。

    この例では、名前に`"DevOps"`が含まれるチャンネルを検索します。

    ```graphql
    {
      actor {
        account(id: YOUR_ACCOUNT_ID) {
          aiNotifications {
            channels(filters: {
              name: "DevOps"
            }) {
              entities {
                id
                name
              }
            }
          }
        }
      }
    }
    ```
  </Collapser>

  <Collapser id="find-by-id" title="IDでチャンネルを検索">
    APIを使用すると、チャネルIDでクエリを実行できます。

    ```graphql
    {
      actor {
        account(id: YOUR_ACCOUNT_ID) {
          aiNotifications {
            channels(filters: {id: YOUR_CHANNEL_ID}) {
              entities {
                id
                name
              }
            }
          }
        }
      }
    }
    ```
  </Collapser>

  <Collapser id="find-by-destination-id" title="宛先IDですべてのチャネルを検索">
    APIを使用すると、宛先IDでチャネルをクエリできます。

    ```graphql
    {
      actor {
        account(id: YOUR_ACCOUNT_ID) {
          aiNotifications {
            channels(filters: {destinationId: YOUR_DESTINATION_ID}) {
              entities {
                id
                name
              }
            }
          }
        }
      }
    }
    ```
  </Collapser>

  <Collapser id="find-by-type" title="タイプ別にすべてのチャネルを検索">
    APIを使用すると、チャネルタイプでクエリを実行できます。次のクエリは、選択したアカウントのすべての電子メールチャネルを返します。

    ```graphql
    {
      actor {
        account(id: YOUR_ACCOUNT_ID) {
          aiNotifications {
            channels(filters: {type: EMAIL}) {
              entities {
                id
                name
              }
            }
          }
        }
      }
    }
    ```
  </Collapser>
</CollapserGroup>

## チャネルを作成する [#create-channel]

チャネルを作成するには、チャネルタイプごとに異なる入力を指定する必要があります。各チャネルは宛先に接続されています。宛先については、宛先[に関するNerdGraphチュートリアルを](/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-destinations)参照してください。

ベストプラクティスは、 `channelSchema`エンドポイントを使用して、次のように`properties`で送信する必要のあるフィールドを確認することです。

```graphql
{
  actor {
    account(id: YOUR_ACCOUNT_ID) {
      aiNotifications {
        channelSchema(
          channelType: CHANNEL_TYPE,
          destinationId: YOUR_DESTINATION_ID,
          product:  YOUR_PRODUCT,
          constraints: []
        ) {
          schema {
            fields {
              mandatory
              label
              key
              component
            }
          }
          result
        }
      }
    }
  }
}
```

<CollapserGroup>
  <Collapser className="freq-link" id="jira" title="アトラシアン Jira">
    Jiraは構成可能なチケットシステムであるため、このチャネルを静的に作成する方法はありません。

    静的フィールドには、 `project`と`issuetype`の2つがあります。

    次に示すように、 `project`の提案を取得し、値の1つを`issuetype`の制約として使用します。

    ```graphql
    {
      actor {
        account(id: YOUR_ACCOUNT_ID) {
          aiNotifications {
            channelSuggestions(
              channelType: JIRA_CLASSIC,
              destinationId: YOUR_DESTINATION_ID,
              key: FIELD_NAME
              constraints: [
                {
                  key: "project",
                  value: YOUR_PROJECT_VALUE
                }
              ]
            ) {
              entities {
                value
              }
              error
            }
          }
        }
      }
    }
    ```

    選択した値は、スキーマをフェッチするための制約として使用されます。

    ```graphql
    {
      actor {
        account(id: YOUR_ACCOUNT_ID) {
          aiNotifications {
            channelSchema(
              channelType: JIRA_CLASSIC,
              destinationId: YOUR_DESTINATION_ID,
              product:  YOUR_PRODUCT,
              constraints: [
                {
                  key: "project",
                  value: YOUR_PROJECT_VALUE
                },
                {
                  key: "issuetype",
                  value: YOUR_ISSUE_TYPE_VALUE
                }
              ]
            ) {
              schema {
                fields {
                  mandatory
                  label
                  key
                  component
                }
              }
              result
            }
          }
        }
      }
    }
    ```

    各フィールドを取得し、提案から、またはフリーテキストとして値を選択した後、チャネルを作成できます。

    ```graphql
    mutation {
      aiNotificationsCreateChannel(accountId: YOUR_ACCOUNT_ID, channel: {
        type: JIRA,
        name: "Channel Name",
        destinationId: YOUR_DESTINATION_ID,
        product: YOUR_PRODUCT,
        properties: [
          {
            key: YOUR_FIELD_NAME,
            value: YOUR_FIELD_NAME,
          },
          // ... And so forth with the rest of the fields
        ]
      }) {
        channel {
          id
          name
        }
      }
    }
    ```
  </Collapser>

  <Collapser className="freq-link" id="servicenow" title="ServiceNow（インシデント・マネジメント）">
    ServiceNowは構成可能なチケットシステムであるため、このチャネルを静的に作成する方法はありません。

    上記のようにスキーマをフェッチしてから、各フィールドにフリーテキストを入力するか、提案を使用する必要があります。

    ```graphql
    {
      actor {
        account(id: YOUR_ACCOUNT_ID) {
          aiNotifications {
            channelSchema(
              channelType: SERVICE_NOW,
              destinationId: YOUR_DESTINATION_ID,
              product:  YOUR_PRODUCT,
              constraints: []
            ) {
              schema {
                fields {
                  mandatory
                  label
                  key
                  component
                }
              }
              result
            }
          }
        }
      }
    }
    ```

    各フィールドを取得し、提案から、またはフリーテキストとして値を選択した後、チャネルを作成できます。

    ```graphql
    mutation {
      aiNotificationsCreateChannel(accountId: YOUR_ACCOUNT_ID, channel: {
        type: SERVICE_NOW,
        name: "Channel Name",
        destinationId: YOUR_DESTINATION_ID,
        product: YOUR_PRODUCT,
        properties: [
          {
            key: YOUR_FIELD_NAME,
            value: YOUR_FIELD_NAME,
          },
          // ... And so forth with the rest of the fields
        ]
      }) {
        channel {
          id
          name
        }
      }
    }
    ```
  </Collapser>

  <Collapser className="freq-link" id="slack" title="スラック">
    ```graphql
    mutation {
      aiNotificationsCreateChannel(accountId: YOUR_ACCOUNT_ID, channel: {
        type: SLACK,
        name: "Channel Name",
        destinationId: YOUR_DESTINATION_ID,
        product: YOUR_PRODUCT,
        properties: [
          {
            key: "channelId",
            value: YOUR_SLACK_CHANNEL_ID
          }
        ]
      }) {
        channel {
          id
          name
        }
      }
    }
    ```
  </Collapser>

  <Collapser className="freq-link" id="microsoft-teams" title="マイクロソフトチーム">
    <Callout title="注記">
      Microsoft Teams 統合は、米国と EU の両方の地域で利用できるようになりました。
    </Callout>

    ### 前提条件

    Microsoft Teams に通知を送信するように New Relic を構成する前に、次の操作を行う必要があります。

    * 通知を受信する既存の Microsoft Teams チャネルを用意します。
    * New Relic で[Microsoft Teams の宛先](/docs/apis/nerdgraph/examples/nerdgraph-api-notifications-destinations/#microsoft-teams)を作成し、 `destinationId`を取得します。

    ### ステップ1: 利用可能なチームIDを取得する

    <Callout variant="tip">
      チーム ID とチャネル ID をすでに知っている場合は、手順 1 と 2 をスキップして、[手順 3](#step-3-configure-the-new-relic-notification-channel)に直接進み、通知チャネルを構成できます。
    </Callout>

    このクエリは、宛先からアクセスできる Microsoft Teams を検出します。`destinationId`を提供し、チーム ID が必要であることを指定すると（ `key: "teamId"`経由）、API は利用可能なチームのリストをその名前と ID とともに返します。

    ```graphql
    {
      actor {
        account(id: YOUR_ACCOUNT_ID) {
          aiNotifications {
            suggestions(
              destinationId: YOUR_DESTINATION_ID,
              key: "teamId",
              channelType: MICROSOFT_TEAMS,
              constraints: []
            ) {
              entities {
                displayValue
                value
              }
              errors {
                description
                details
                type
              }
            }
          }
        }
      }
    }
    ```

    応答には、表示名と一意のチーム ID を含むチームのリストが含まれます。

    ```json
    {
      "data": {
        "actor": {
          "account": {
            "aiNotifications": {
              "suggestions": {
                "entities": [
                  {
                    "displayValue": "Engineering Team",
                    "value": "389e7f6c-xxxx-47f0-aa77-xxxxxxxxxxxx"
                  },
                  {
                    "displayValue": "DevOps Team",
                    "value": "834dc358-xxxx-4445-9938-xxxxxxxxxxxx"
                  }
                ],
                "errors": []
              }
            }
          }
        }
      }
    }
    ```

    <Callout variant="tip">
      探しているチームが結果に見つからない場合は、 `filter`引数を使用して名前で検索できます。

      ```graphql
      {
        actor {
          account(id: YOUR_ACCOUNT_ID) {
            aiNotifications {
              suggestions(
                destinationId: YOUR_DESTINATION_ID,
                key: "teamId",
                channelType: MICROSOFT_TEAMS,
                constraints: [],
                filter: {
                  type: CONTAINS,
                  value: "Engineering"
                }
              ) {
                entities {
                  displayValue
                  value
                }
              }
            }
          }
        }
      }
      ```
    </Callout>

    ### ステップ2: チームで利用可能なチャンネルIDを取得する

    手順 1 でチーム ID を取得したら、このクエリによって特定のチーム内に存在するチャネルが検出されます。`destinationId`と`teamId`を（制約として）指定すると、API は利用可能なチャネルとその名前および ID のリストを返します。

    ```graphql
    {
      actor {
        account(id: YOUR_ACCOUNT_ID) {
          aiNotifications {
            suggestions(
              destinationId: YOUR_DESTINATION_ID,
              key: "channelId",
              channelType: MICROSOFT_TEAMS,
              constraints: [
                {
                  key: "teamId",
                  value: "YOUR_TEAM_ID"
                }
              ]
            ) {
              entities {
                displayValue
                value
              }
              errors {
                description
                details
                type
              }
            }
          }
        }
      }
    }
    ```

    応答には、指定されたチーム内のチャネルのリストが含まれます。

    ```json
    {
      "data": {
        "actor": {
          "account": {
            "aiNotifications": {
              "suggestions": {
                "entities": [
                  {
                    "displayValue": "General",
                    "value": "19:xxxxxxxxxxxxxxxxxxxxxxxx@thread.tacv2"
                  },
                  {
                    "displayValue": "Alerts",
                    "value": "19:yyyyyyyyyyyyyyyyyyyyyyyy@thread.tacv2"
                  }
                ],
                "errors": []
              }
            }
          }
        }
      }
    }
    ```

    <Callout variant="tip">
      チーム ID と同様に、 `filter`引数を使用して名前でチャネルをフィルタリングし、指定したチーム内を検索できます。
    </Callout>

    ### ステップ 3: New Relic通知チャネルを設定する

    チーム ID とチャネル ID の両方を取得したら、New Relic 通知チャネルを構成して、Microsoft Teams チャネルにアラートを送信します。

    <Callout variant="important">
      このミューテーションは、**既存の**Microsoft Teams チャネルに接続する New Relic 通知チャネル オブジェクトを作成します。Teams チャネルは、Microsoft Teams ワークスペースにすでに存在している必要があります。この API は、Microsoft Teams 自体に新しいチームやチャネルを作成するのではなく、既存の Teams チャネルに通知を送信するように New Relic を構成するだけです。
    </Callout>

    ```graphql
    mutation {
      aiNotificationsCreateChannel(accountId: YOUR_ACCOUNT_ID, channel: {
        type: MICROSOFT_TEAMS,
        name: "Channel Name",
        destinationId: YOUR_DESTINATION_ID,
        product: YOUR_PRODUCT,
        properties: [
          {
            key: "teamId",
            value: YOUR_TEAM_ID
          },
          {
            key: "channelId",
            value: YOUR_CHANNEL_ID
          }
        ]
      }) {
        channel {
          id
          name
        }
      }
    }
    ```

    `product`問題は、通知を生成するNew Relic製品を指定します。 有効な値は次のとおりです:

    * `IINT` - 勇気インテリジェンス (インシデント インテリジェンス)
    * `ALERTS`
    * `ERROR_TRACKING`
    * `APM` - アプリケーションパフォーマンス監視
    * `CHANGE_TRACKING`
    * `SECURITY`
    * `PD` - プロアクティブ検出
    * その他の値: `CSSP` 、 `DISCUSSIONS` 、 `NTFC` 、 `SHARING`
  </Collapser>

  <Collapser className="freq-link" id="webhook" title="Webhook">
    `payload`プロパティは、通知で送信されるペイロードです。ハンドルバー構文を使用して、リクエストから情報を動的に挿入します。

    ```graphql
    mutation {
      aiNotificationsCreateChannel(accountId: YOUR_ACCOUNT_ID, channel: {
        type: WEBHOOK,
        name: "Channel Name",
        destinationId: YOUR_DESTINATION_ID,
        product: YOUR_PRODUCT,
        properties: [
          {
          key:"payload",
          value: "{\"key\":\"value\"}"}
        ]
      }) {
        channel {
          id
          name
        }
      }
    }
    ```
  </Collapser>

  <Collapser className="freq-link" id="email" title="メール">
    ```graphql
    mutation {
      aiNotificationsCreateChannel(accountId: YOUR_ACCOUNT_ID, channel: {
        type: EMAIL,
        name: "Channel Name",
        destinationId: YOUR_DESTINATION_ID,
        product: YOUR_PRODUCT,
        properties: []
      }) {
        channel {
          id
          name
        }
      }
    }
    ```
  </Collapser>

  <Collapser className="freq-link" id="eventBridge" title="AWS EventBridge">
    `eventSource`は、既存のイベントソースの完全なURLである必要があります。`eventContent`は、次に示すように、通知の本文で送信されるペイロードです。

    ```graphql
    mutation {
      aiNotificationsCreateChannel(accountId: YOUR_ACCOUNT_ID, channel: {
        type: EVENT_BRIDGE,
        name: "Channel Name",
        destinationId: YOUR_DESTINATION_ID,
        product: YOUR_PRODUCT,
        properties: [
          {
            key: "eventSource",
            value:  YOUR_AWS_EVENT_SOURCE
          },
          {
            key: "eventContent",
            value:  YOUR_EVENT_CONTENT/var>
          }
        ]
      }) {
        channel {
          id
          name
        }
      }
    }
    ```
  </Collapser>

  <Collapser className="freq-link" id="pagerduty" title="PagerDuty">
    PagerDutyには、サービスレベルとアカウントレベルの2種類の統合があります。詳細については、 [PagerDuty統合ドキュメント](/docs/alerts-applied-intelligence/notifications/notification-integrations#pagerduty)を参照してください。

    サービスレベル：

    ```graphql
    mutation {
      aiNotificationsCreateChannel(accountId: YOUR_ACCOUNT_ID, channel: {
        type: PAGERDUTY_SERVICE_INTEGRATION,
        name: "Channel Name",
        destinationId: YOUR_DESTINATION_ID,
        product: YOUR_PRODUCT,
        properties: [
          {
            key: "summary",
            value: YOUR_PAGE_SUMMARY
          }
        ]
      }) {
        channel {
          id
          name
        }
      }
    }
    ```

    アカウントレベル：

    ```graphql
    mutation {
      aiNotificationsCreateChannel(accountId: YOUR_ACCOUNT_ID, channel: {
        type: PAGERDUTY_ACCOUNT_INTEGRATION,
        name: "Channel Name",
        destinationId: YOUR_DESTINATION_ID,
        product: YOUR_PRODUCT,
        properties: [
          {
            key: "summary",
            value: YOUR_PAGE_SUMMARY
          },
          {
            key: "email",
            value: EMAIL_OF_PD_USER
          },
          {
            key: "service",
            value: YOUR_PD_SERVICE_ID
          }
        ]
      }) {
        channel {
          id
          name
        }
      }
    }
    ```
  </Collapser>
</CollapserGroup>

## チャネルを更新する [#update-channel]

チャネルを更新するときは、チャネルのすべての属性を指定する必要はないことに注意してください。たとえば、名前のみを更新する場合は、次に示すように、それが更新する必要がある唯一の属性です。

```graphql
mutation {
  aiNotificationsUpdateChannel(accountId: YOUR_ACCOUNT_ID, channelId: YOUR_CHANNEL_ID, channel: {
    name: "Updated channel Name"
  }) {
    channel {
      id
      name
    }
  }
}
```

## チャネルのテスト [#test-channel]

NerdGraphAPIを介してチャネルをテストできます。これは、チャネルの作成前または作成後に実行できます。

```graphql
mutation {
  aiNotificationsTestChannel(accountId: YOUR_ACCOUNT_ID, channel: {
    type: PAGERDUTY_SERVICE_INTEGRATION,
    name: "Channel Name",
    properties: [
      {
        key: "summary",
        value: YOUR_PAGE_SUMMARY
      }
    ]
  }) {
    error {
      details
    }
    details
    result
  }
}

```

```graphql
mutation {
  aiNotificationsTestChannelById(accountId: YOUR_ACCOUNT_ID, channelId: YOUR_CHANNEL_ID) {
    error {
      details
    }
    details
    result
  }
}
```

## チャンネルの削除 [#delete-channel]

NerdGraphAPIを介してチャネルを削除できます。

```graphql
mutation {
  aiNotificationsDeleteChannel(accountId: YOUR_ACCOUNT_ID, channelId: YOUR_CHANNEL_ID) {
    ids
    error {
      details
    }
  }
}
```