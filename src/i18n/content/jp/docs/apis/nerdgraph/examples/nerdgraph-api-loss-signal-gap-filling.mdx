---
title: NerdGraphチュートリアル。信号の消失とギャップフィリング
tags:
  - Alerts and applied intelligence
  - Alerts
  - Alerts and Nerdgraph
metaDescription: Customize how New Relic detects loss of signal and what values it should use for filling gaps in the data.
translationType: machine
---

[NerdGraph API](/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph)を使用して、NewRelicアラートの信号損失検出とギャップフィリングをカスタマイズできます。たとえば、失われた信号を考慮するまでの待機時間を構成したり、時系列のギャップを埋めるために使用する値を構成したりできます。

信号の損失は、New Relicがデータの受信をしばらく停止すると発生します。技術的には、データが時系列で最後に受信されてからかなりの時間が経過した後に、信号の損失を検出します。信号の損失は、違反をトリガーまたは解決するために使用でき、これを使用してアラートを設定できます。

ギャップフィリングは、データポイントが失われたことによる問題を解決するのに役立ちます。有効なデータポイントの間にギャップが検出されると、最後に確認された値や静的な値などの代替値で自動的にギャップを埋めます。ギャップフィリングを行うことで、必要のないアラートの発生や解決を防ぐことができます。

<Callout variant="tip">
  アラートシステムは、アクティブに報告された信号のギャップを埋めます。この信号の履歴は、2時間操作が行われないと失われます。ギャップを埋めるために、この非アクティブ期間の後に受信されたデータポイントは新しい信号として扱われます。

  信号損失、ギャップの充填、アクセスをリクエストする方法の詳細については、[このExplorers Hubの記事](https://discuss.newrelic.com/t/announcing-new-relic-one-streaming-alerts-for-nrql-conditions/115361)を参照してください。
</Callout>

このガイドでは、以下のことを説明しています。

* [カスタマイズによる信号検知の消失](#loss-of-signal)
* [隙間を埋めるカスタマイズ](#customize)

## 電波障害検出のカスタマイズ [#loss-of-signal]

信号損失の検出は、一定の時間が経過してもデータが受信されない場合に、違反を開いたり閉じたりします。例えば、有効期限の期間を60秒に設定し、ある統合が1分以上データを送信しないようであれば、シグナル喪失の違反がトリガーされます。

NerdGraphのこの3つのフィールドを使って、信号損失の持続時間や違反を開くか閉じるかを設定できます。

* `expiration.expirationDuration`：最後のデータポイントがプラットフォームによって受信されてから、信号が失われたと見なされるまでの待機時間（秒単位）。これは、データのタイムスタンプではなく、データがプラットフォームに到着する時間に基づいています。デフォルトではこれをnullのままにするため、信号損失検出は有効になりません。
* `expiration.openViolationOnExpiration`： `true`の場合、シグナルが失われたときに新しい違反が開かれます。デフォルトは`false`です。このフィールドを使用するには、期間を指定する必要があります。
* `expiration.closeViolationsOnExpiration`： `true`の場合、シグナルに関連する未解決の違反は、有効期限が切れるとクローズされます。デフォルトは`false`です。このフィールドを使用するには、期間を指定する必要があります。

### 既存の状態の信号損失設定を見る

既存のNRQL条件では、信号損失設定がすでに構成されている場合があります。既存の条件設定を表示するには、 `nrqlCondition` > `expiration`の下のフィールドを選択します：

```
{
  actor {
    account(id: <var>YOUR_ACCOUNT_ID</var>) {
      alerts {
        nrqlCondition(id: <var>NRQL_CONDITION_ID</var>) {
          ... on AlertsNrqlStaticCondition {
            id
            name
            nrql {
              query
            }
            expiration {
              <mark>closeViolationsOnExpiration</mark>
              <mark>expirationDuration</mark>
              <mark>openViolationOnExpiration</mark>
            }
          }
        }
      }
    }
  }
}
```

このような結果が表示されるはずです。

```
{
  "data": {
    "actor": {
      "account": {
        "alerts": {
          "nrqlCondition": {
            "expiration": {
              "<mark>closeViolationsOnExpiration</mark>": false,
              "<mark>expirationDuration</mark>": 300,
              "<mark>openViolationOnExpiration</mark>": true
            },
            "id": "<var>YOUR_ACCOUNT_ID</var>",
            "name": "Any less than - Extrapolation",
            "nrql": {
              "query": "SELECT average(value) FROM AlertsSmokeTestSignals WHERE wave_type IN ('min-max', 'single-gap') FACET wave_type"
            }
          }
        }
      }
    }
  }, ...
```

### 信号の消失を設定して新たな状態を作る

2分間データが受信されなかった後、信号損失違反をトリガーする新しい[NRQL静的条件を作成する](/docs/alerts/alerts-nerdgraph/nerdgraph-examples/nerdgraph-api-nrql-condition-alerts#static-condition)とします。次の例のように、 `expirationDuration`を120秒に設定し、 `openViolationOnExpiration`を`true`に設定します。

```
mutation {
  alertsNrqlConditionStaticCreate(
    accountId: <var>YOUR_ACCOUNT_ID</var>
    policyId: <var>YOUR_POLICY_ID</var>
    condition: {
      name: "Low Host Count - Catastrophic"
      enabled: true
      nrql: {
        query: "SELECT uniqueCount(host) from Transaction where appName='my-app-name'"
      }
      signal {
        aggregationWindow: 60
        aggregationMethod: EVENT_FLOW
        aggregationDelay: 120
      }
      terms: [{
        threshold: 2
        thresholdOccurrences: AT_LEAST_ONCE
        thresholdDuration: 600
        operator: BELOW
        priority: CRITICAL
      }]
      valueFunction: SINGLE_VALUE
      violationTimeLimitSeconds: 86400
      <mark>expiration</mark>: {
        <mark>expirationDuration</mark>: 120
        <mark>openViolationOnExpiration</mark>: <var>true</var>
      }
    }
  ) {
    id
    name
  }
}
```

### 条件の信号消失設定の更新

アラート状態の信号損失パラメータを更新したい場合はどうなりますか？次の[変更により、NRQL静的条件](/docs/alerts/alerts-nerdgraph/nerdgraph-examples/nerdgraph-api-nrql-condition-alerts#static-condition)を新しい`expiration`値で更新できます。

```
mutation {
  alertsNrqlConditionStaticUpdate(
    accountId: <var>YOUR_ACCOUNT_ID</var>
    id: <var>YOUR_STATIC_CONDITION_ID</var>
    condition: {
      expiration: {
        <mark>closeViolationsOnExpiration</mark>: <var>BOOLEAN</var>
        <mark>expirationDuration</mark>: <var>DURATION_IN_SECONDS</var>
        <mark>openViolationOnExpiration</mark>: <var>BOOLEAN</var>
      }
    }
  ) {
    id
    expiration {
      closeViolationsOnExpiration
      expirationDuration
      openViolationOnExpiration
    }
  }
}
```

## 隙間を埋めるカスタマイズ [#customize]

ギャップフィリングでは、時系列のギャップ値を、最後に見つかった値か、任意の静的な値で置き換えます。ギャップフィリングを行うのは、信号のギャップの後に別のデータポイントが受信されてから（データ受信が回復してから）です。

タイプがスタティックに設定されている場合、フィリングのタイプと値の両方を設定できます。

* `signal.fillOption`：失われたデータポイントの置換値のタイプ。値は次のとおりです。

  * `NONE`：ギャップフィリングは無効になっています。
  * `LAST_VALUE`：時系列で見られる最後の値。
  * `STATIC`： `fillValue`で定義された任意の値。

* `signal.fillValue`： `fillOption`が`STATIC`に設定されている場合に失われたデータポイントを置き換えるために使用する値。

<Callout variant="important">
  ギャップフィリングも`expiration.expirationDuration`の影響を受けます。ギャップが有効期限よりも長い場合、信号は期限切れと見なされ、ギャップは埋められなくなります。
</Callout>

例えば、ギャップフィリングを設定した静的なNRQL条件を作成する方法は以下の通りです。

```
mutation {
  alertsNrqlConditionStaticCreate(
    accountId: <var>YOUR_ACCOUNT_ID</var>
    policyId: <var>YOUR_POLICY_ID</var>
    condition: {
      enabled: true
      name: "Example Gap Filling Condition"
      nrql: { query: "select count(*) from Transaction" }
      terms: {
        operator: ABOVE
        priority: CRITICAL
        threshold: 1000
        thresholdDuration: 300
        thresholdOccurrences: ALL
      }
      valueFunction: SINGLE_VALUE
      violationTimeLimitSeconds: 28800
      signal: {
        aggregationWindow: 60,
        aggregationMethod: EVENT_FLOW,
        aggregationDelay: 120,
        <mark>fillOption: STATIC,</mark>
        <mark>fillValue: 1</mark>
      }
    }
  ) {
    id
  }
}
```