---
title: ワークフロー定義スキーマ
tags:
  - workflow automation
  - workflow schemas
  - workflow automation API
metaDescription: Workflow definitions are written in YAML. Keys use a camelCase naming convention.
freshnessValidatedDate: never
translationType: machine
---

<Callout title="プレビュー">
  この機能はまだ開発中ですが、ぜひお試しください。

  この機能は現在、弊社の[プレリリース ポリシー](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy)に従ってプレビュー プログラムの一部として提供されています。
</Callout>

## 概要

ワークフロー定義は、実行される自動化されたプロセスを記述します。ワークフロー定義は、 `camelCase`命名規則を使用して YAML で記述されます。各ワークフローは次の要素で構成されます。

* **スキーマプロパティ**: 基本情報 (名前、説明、入力)
* **ステップ**: 実行するアクションの順序
* **式**: jq 構文を使用した動的な値
* **シークレット**: 安全な資格情報参照

## 基礎概念

ワークフローを構築する前に、ワークフローの定義全体で使用されるこれらの中心的な概念を理解してください。

### 式文字列 [#expression-strings]

いくつかのプロパティは、ワークフロー実行中に評価される埋め込み式を含む文字列値を受け入れ、ワークフロー定義で動的な値を有効にします。

式文字列には、それぞれ二重中括弧で囲まれた 1 つ以上の式を含めることができます。中括弧内の内容は[jq](https://jqlang.org/manual/)を使用して評価され、値にアクセスして操作するための強力な機能が提供されます。

**例**:

ワークフロー入力文字列の長さを取得します。

`${{ .workflowInputs.myString | length }}`

式を検証およびテストするには、 [JQ Playground](https://play.jqlang.org/)を使用します。

### 式のプロパティ [#expression-properties]

式を使用して、多数のプロパティにアクセスできます。これらのプロパティは`scope`オブジェクト内に存在するため、スコープ オブジェクトのこれらのプロパティにアクセスするには、式をピリオド`(.)`で始める必要があります。

利用可能なプロパティは次のとおりです。

* `workflowInputs` - 開始時にワークフローに渡される入力を含むオブジェクト。

**例**:

`${{ .workflowInputs.myInput }}`

* `steps` - ワークフローの各ステップのプロパティを含むオブジェクト
* `steps.<stepName>` - 特定のステップのプロパティを含むオブジェクト
* `steps.<stepName>.outputs` - ステップまたはアクションに固有の結果プロパティを含むオブジェクト。

**例**: `${{ .steps.myStep.outputs.myResult }}`

### 表現評価結果 [#expression-evaluation-results]

単一の jq 式は任意の JSON 型に評価できます。ただし、式文字列の最終結果は、文字列に式のみが含まれているか、追加のコンテンツが含まれているかによって異なります。

**単一の式（JSON 型を保持）** :

式文字列が周囲のコンテンツのない 1 つの式のみで構成されている場合は、元の JSON 型を維持しながら jq 式の結果に評価されます。たとえば、 `${{ .workflowInputs.myArray }}`配列として評価されます。これは、ワークフロー内で複雑なデータ構造を渡すのに役立ちます。

**複数の式または混合コンテンツ（文字列に変換されます）** :

式文字列に単一の式以外のコンテンツが含まれている場合、文字列の結果に評価されます。これは、式の前後にコンテンツがある場合、または文字列内に複数の式がある場合に発生します。文字列内の各式は評価され、文字列表現に変換されます。

<Callout variant="important">
  jq 式が null と評価されると、null ノードが返されます。たとえば、式`${{ .workflowInputs.missingInput }}`は、ワークフロー入力として`missingInput`が指定されていない場合は null を返します。
</Callout>

**例**:

`myArray`の値が`[1, 2, 3]`であると仮定します。

<table>
  <thead>
    <tr>
      <th>
        式文字列
      </th>

      <th>
        結果データ
      </th>

      <th>
        結果タイプ
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `${{ .workflowInputs.myArray }}`
      </td>

      <td>
        `[1, 2, 3]`
      </td>

      <td>
        数字の配列
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        3
      </td>

      <td>
        数
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        トゥルー
      </td>

      <td>
        ブール値
      </td>
    </tr>

    <tr>
      <td>
        `Input is not empty: ${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        `"Input is not empty: true"`
      </td>

      <td>
        弦
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray }} has length ${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        `"has length 3"`
      </td>

      <td>
        弦
      </td>
    </tr>
  </tbody>
</table>

### 表現安全なパターン [#expression-safe-pattern]

式で使用できるプロパティは、次の条件に準拠する必要があります。 `^[A-Za-z_][A-Za-z0-9_]*$`

### 秘密の参照 [#secret-references]

シークレット値は、シークレット サービスで検索するシークレットの名前を指定する参照文字列を介してアクションで使用できます。ワークフロー定義でシークレットを参照するには、次の構文を使用します。

* `${{ :secrets:<SECRET_NAME> }}` 秘密は `namespace`
* `${{ :secrets:<NAMESPACE>:<SECRET_NAME> }}` 秘密のために `namespace`
* `${{ :secrets:<SCOPE>:<NAMESPACE>:<SECRET_NAME> }}` スコープとネームスペースのシークレットについては。 現時点では、スコープは`ACCOUNT`または`ORGANIZATION`のみを受け入れます。

式文字列には、シークレット参照と JQ 式の組み合わせ`and/or`複数のシークレット参照) を含めることができます。

**例**:

```yaml
  steps:
  - name: mySecretStep
    type: action
    action: newrelic.instrumentation.log
    inputs:
      message: My message
      licenseKey: ${{ :secrets:<SECRET_NAME> }}
```

```yaml
  steps:
    - name: bearer_auth
      type: action
      action: utils.http.post
      inputs:
        headers:
          Authorization: Bearer ${{ :secrets:<SECRET_NAME> }}
```

## スキーマ構造

### スキーマプロパティ

<table>
  <thead>
    <tr>
      <th>
        プロパティ
      </th>

      <th>
        必須またはオプション
      </th>

      <th>
        タイプ
      </th>

      <th>
        形式
      </th>

      <th>
        制約
      </th>

      <th>
        説明
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`name`**
      </td>

      <td>
        必須
      </td>

      <td>
        弦
      </td>

      <td>
        正規表現に準拠する必要があります 

        `^[A-Za-z_][A-Za-z0-9_-]*$`
      </td>

      <td>
        **最大長**

        : 100
      </td>

      <td>
        **`name`**

        値は大文字と小文字を区別しません。たとえば、 

        `ExampleWorkflow`

         、 

        `exampleworkflow`

         、 

        `EXAMPLEWORKFLOW`

        はすべて同じワークフロー定義を表すものと見なされます。
      </td>
    </tr>

    <tr>
      <td>
        **`description`**
      </td>

      <td>
        オプション
      </td>

      <td>
        弦
      </td>

      <td>
        正規表現に準拠する必要があります 

        `^[A-Za-z0-9 _-]*$`
      </td>

      <td>
        **最大長**

        : 200
      </td>

      <td>
        ワークフローの目的を説明するワークフローの

        `description`

         。
      </td>
    </tr>

    <tr>
      <td>
        **`workflowInputs`**
      </td>

      <td>
        オプション
      </td>

      <td />

      <td>
        地図の地図
      </td>

      <td>
        **最大サイズ**

        : 100
      </td>

      <td>
        ワークフローが受け入れるワークフロー入力のマップ。詳細なプロパティについては以下を参照してください。
      </td>
    </tr>
  </tbody>
</table>

### ワークフロー入力

**例**:

```yaml
    workflowInputs:
  myInput1:
    type: String
  myInput2:
    type: Number
    defaultValue: 42
```

* **`workflowInputs.<inputName>`** (必須)

  * **タイプ**: 文字列 ([式安全なパターン](#expression-safe-pattern)に準拠)
  * **最小の長さ**: 1
  * **最大長**: 50
  * **説明**: ワークフロー入力の名前。

* **`workflowInputs.<inputName>.type`** (必須)

  * **タイプ**: 列挙型 (`Boolean, List, Map, String, Int, Float`)
  * **説明**: ワークフロー入力のデータ型。

* **`workflowInputs.<inputName>.defaultValue`** (オプション)

  * **タイプ**: 任意; `type`に準拠する必要があります。
  * **説明**: ワークフロー入力のデフォルト値。

* **`workflowInputs.<inputName>.required`** (オプション)

  * **タイプ**: ブール値 (`True` 、 `False`)。
  * **説明**: このフィールドのデフォルト値は「True」です。

* **`workflowInputs.<inputName>.enumValues`** (オプション)

  * **タイプ**: リスト (`String`)。
  * **説明**: このフィールドのデフォルト値は空のリスト`{}`です。workflowInput タイプが Enum の場合、これは必須です。

* **`workflowInputs.<inputName>.validations`** (オプション)

  * **タイプ**: マップの配列。
  * **説明**: ユーザーが提供するワークフロー入力に対して実行される検証。これはオプションのフィールドです。ここで説明するプロパティは、すべての検証タイプに存在します。特定の検証タイプは、[検証タイプの](#validation-types)セクションで説明されているように、追加のプロパティをサポートします。

* **`validations[*].type`** (必須)

  * **タイプ**: 文字列
  * **説明**: このフィールドでどのような検証が行われるかを示す検証のタイプ。各検証[タイプの詳細については、「検証タイプ](#validation-types)」を参照してください。

* **`validations[*].errorMessage`** (必須)

  * **タイプ**: 文字列
  * **説明**: 特定の検証が失敗したときにユーザーが表示するエラーメッセージ。

#### 検証用のサンプルYAML

```yaml
  name: calendar_demo

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'
      validations:
        - type: regex
          errorMessage: "The provided timezone is not correct"
          pattern: "^[A-Za-z]+\/[A-Za-z_]+(?:\/[A-Za-z_]+)?$"

        - type: maxLength
          errorMessage: "Timezone length should be less than 100"
          length: 100

    accountId:
      type: Int
      validations:
        - type: minIntValue
          errorMessage: "Account id should be greater than 100000"
          minValue: 100000
        - type: maxIntValue
          errorMessage: "Account id should be less than 9999999"
          maxValue: 9999999

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'
        selectors:
          - name: timezone
            expression: '.responseBody | fromjson.abbreviation'
          - name: datetime
            expression: '.responseBody | fromjson.datetime'
```

### 検証の種類 [#validation-types]

<table>
  <thead>
    <tr>
      <th>
        検証タイプ
      </th>

      <th>
        プロパティ
      </th>

      <th>
        必須またはオプション
      </th>

      <th>
        タイプ
      </th>

      <th>
        説明
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`regex`**
      </td>

      <td>
        `validations[*].pattern`
      </td>

      <td>
        必須
      </td>

      <td>
        弦
      </td>

      <td>
        指定された正規表現パターンに対してワークフロー入力値を検証します。
      </td>
    </tr>

    <tr>
      <td>
        **`maxIntValue`**
      </td>

      <td>
        `validations[*].maxValue`
      </td>

      <td>
        必須
      </td>

      <td>
        整数
      </td>

      <td>
        ワークフローの入力値が指定された maxValue より小さいことを検証します。
      </td>
    </tr>

    <tr>
      <td>
        **`minIntValue`**
      </td>

      <td>
        `validations[*].minValue`
      </td>

      <td>
        必須
      </td>

      <td>
        整数
      </td>

      <td>
        ワークフローの入力値が指定された minValue よりも大きいことを検証します。
      </td>
    </tr>

    <tr>
      <td>
        **`maxLength`**
      </td>

      <td>
        `validations[*].length`
      </td>

      <td>
        必須
      </td>

      <td>
        整数
      </td>

      <td>
        ワークフロー入力文字列とコレクションの最大長を検証します (

        `Array, Set, Map, etc.`

        )。
      </td>
    </tr>
  </tbody>
</table>

## 手順 [#steps]

<table>
  <thead>
    <tr>
      <th>
        プロパティ
      </th>

      <th>
        必須またはオプション
      </th>

      <th>
        タイプ
      </th>

      <th>
        制約
      </th>

      <th>
        説明
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`steps`**
      </td>

      <td>
        必須
      </td>

      <td>
        地図の配列
      </td>

      <td />

      <td>
        ワークフロー定義の実行時に実行される手順。少なくとも 1 つのステップが必要です。ここで説明するプロパティは、すべてのステップ タイプに存在します。特定のステップ タイプでは、 

        [「ステップ タイプ」](#step-types)

        セクションで説明されている追加のプロパティがサポートされます。
      </td>
    </tr>
  </tbody>
</table>

<Callout variant="important">
  ステップは、 `steps`配列で定義された順序で実行されます。異なる順序付けが必要な場合は、 `steps[*].next`プロパティをジャンプするステップの名前に設定して`jump`を実行できます。
</Callout>

### 共通ステッププロパティ

<table>
  <thead>
    <tr>
      <th>
        プロパティ
      </th>

      <th>
        必須またはオプション
      </th>

      <th>
        タイプ
      </th>

      <th>
        形式
      </th>

      <th>
        制約
      </th>

      <th>
        説明
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        **`steps[*].name`**
      </td>

      <td>
        必須
      </td>

      <td>
        弦
      </td>

      <td>
        [式セーフパターン](#expression-safe-pattern)

        に準拠する必要があり、 

        `end`

        にすることはできません。
      </td>

      <td>
        **最大長:**

         100
      </td>

      <td>
        `steps[*].next`

        によって参照されるステップの名前。特殊キーワード

        `end`

         、 

        `continue`

         、または

        `break`

        は使用できません。これらは、終了ステップ、ループの継続、またはループからの脱出を示すために使用されます。
      </td>
    </tr>

    <tr>
      <td>
        **`steps[*].type`**
      </td>

      <td>
        必須
      </td>

      <td>
        弦
      </td>

      <td />

      <td />

      <td>
        ステップのタイプ。実行時にステップが何を行うかを示します。利用可能なオプションについては、以下の

        [ステップ タイプ](#step-types)

        を参照してください。
      </td>
    </tr>

    <tr>
      <td>
        **`steps[*].next`**
      </td>

      <td>
        オプション
      </td>

      <td>
        弦
      </td>

      <td>
        表現の安全パターンに準拠する必要があります
      </td>

      <td />

      <td>
        このステップが正常に完了したときに実行される次のステップの名前。特別なキーワード end を使用すると、このステップが最後に実行されることを示すことができます。

        `next`

        が省略されている場合、定義

        `steps`

        配列内の次のエントリが暗黙的な次のステップとして使用されます。次のエントリがない場合、ワークフローは完了します。
      </td>
    </tr>

    <tr>
      <td>
        **`steps[*].ignoreErrors`**
      </td>

      <td>
        オプション
      </td>

      <td>
        ブール値
      </td>

      <td />

      <td />

      <td>
        `ignoreErrors`

        は、ワークフローのステップ内の設定オプションです。 デフォルトは false です。

        `ignoreErrors`

        を

        `true`

        に設定すると、ワークフローでは、このステップの実行中にエラーが発生してもワークフロー全体が失敗しないことが保証されます。代わりに、ワークフローは後続のステップの実行を継続します。
      </td>
    </tr>
  </tbody>
</table>

## ステップの種類 [#step-types]

### アクション [#action]

特定のアクションを実行するステップ。利用可能なオプションについては、[アクション カタログ](/docs/workflow-automation/setup-and-configuration/actions-catalog/actions-catalog)を参照してください。

* **`steps[*].action`** (必須)

  * **タイプ**: 文字列
  * **説明**: 実行するアクション関数の完全修飾名。次の規則に従う必要があります。 `<company domain>.<category of work>.<action name in camelCase>`

**例**:

* New Relic サービスを使用したアクション (例: NerdGraph 経由): `newrelic.dashboards.getDashboard`

* Slackを使ったアクション: `slack.chat.postMessage`

* **`steps[*].version`** (必須)

  * **タイプ**: 文字列
  * **説明**: 実行するアクション関数のバージョン。

* **`steps[*].inputs`** (オプション)

  * **タイプ**: 値のマップ（式を含む）

  * **説明**：

    * アクション関数に渡す入力。受け入れられる特定の入力は、各アクションによって定義されます。
    * 入力には式を使用できます。詳細については、「式文字列」セクションを参照してください。

  <Callout variant="important">
    機密データ ( APIキーやシークレット、PII、PHI、または個人を特定できるデータ) を引数として渡さないでください。
  </Callout>

* **`steps[*].inputs.selectors`** (オプション)

  * **タイプ**: `name`と`expression`の形式のマップのリスト。

  * **説明**：

    * `selectors`入力を使用すると、指定された要素のみを返すように出力を再定義できます。
    * 表現が使えます。詳細については、「[式文字列」](#expression-strings)セクションを参照してください。

**例**:

* この例では、http.get アクションの応答として`timezone`と`datetime`を取得しています。

```yaml
  name: calendar_demo

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'
    accountId:
      type: Int

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'
        selectors:
          - name: timezone
            expression: '.responseBody | fromjson.abbreviation'
          - name: datetime
            expression: '.responseBody | fromjson.datetime'
```

### ループ [#loop]

ループはコレクション (リスト、マップ、配列) を反復処理し、反復ごとに`index`および`element`変数を自動的に作成します。これらのループ変数は、 `${{ .steps.<loopStepName>.loop.element }}`または `${{ .steps.<loopStepName>.loop.index }}`

**プロパティ:**

* **`steps[*].for`** (必須)

  * **タイプ**: 定数
  * **説明**: ループの開始を知らせます

* **`steps[*].in`** (必須)

  * **タイプ**: 文字列 (式)
  * **説明**: 要素のコレクションを評価する式

* **`steps[*].steps`** (必須)

  * **説明**: 各反復で実行される手順。ネストされたループを含む任意のステップ タイプを含めることができます。

<Callout variant="important">
  * **対象:** (必須)。これは、 for ループの開始を示す最上位要素です。
  * **in:** (必須)。反復処理する入力コレクションは、Java 配列にキャスト可能である必要があります。
  * **手順:** (必須)。各反復ごとにステップが実行されます。
  * **要素**と**インデックス**はループの一部として自動的に割り当てられます。
  * `index` ゼロベースですが、複合要素のコレクションがある場合は、 `element`複合型になることがあります。
  * ループ内で作成された変数（ループ変数とステップ出力）は、ループ内でのみアクセス可能です。
  * これらの変数はループが終了するとクリアされ、ループ外からアクセスするとnullになります。
  * ループはループ外で定義された変数にアクセスできる
</Callout>

**例: 基本的なループ**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element : ${{ .steps.loopStep.loop.element }} , Index : ${{ .steps.loopStep.loop.index }}' # not exist outside of this loop
```

**例: 整数のループ**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: ${{ [range(1; 6)] }}
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }} , Index : ${{ .steps.loopStep.loop.index }}'  # Element : [1, 2, 3, 4, 5] , Index : [0, 1, 2, 3, 4]
```

**例: マップ上のループ**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element : ${{ .steps.loopStep.loop.element }} , Index : ${{ .steps.loopStep.loop.index }}'  # Element: [{ "key1": "val1" }, { "key2": "val2"}] , Index : [0, 1]
```

**例: ループ内でのジャンプ**

同じループ内のステップ間のジャンプは許可されます。ループ内/ループ外、異なるループ間、または親/子ループへのジャンプは許可されません。

```yaml
  name: myWorkflow
  steps:
    - name: firstStep
      type: action
      action: example.messaging.sayHello
      version: '1.0.0'
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: step3                                 # Okay within the loop
          - name: step2
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.step1.outputs.greeting }}'
          - name: step3
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            next: firstStep                            # Not okay, first step is not in the loop context
```

**例: 中断して続行**

ループフローを制御するには、 `next: break`または`next: continue`を使用します。これらはループ内の予約キーワードです。ループ外では、ワークフローの終了にジャンプします。注意: `end`ループ内では`break`のように動作します。

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [range(1; 6)] }}'
        steps:
          - name: insideLoopStep1
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: continue
          - name: insideLoopStep2
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
    - name: loopStepAgain
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: switchStep
            type: switch
            switch:
              - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                next: break
          - name: insideLoopStepAgain
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
            inputs:
              name: '${{ .steps.loopStepAgain.loop.element }}'
```

**簡単な例:**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: "${{ [range(1; 5)] }}"
        steps:
          - name: step1
            type: action
            action: newrelic.ingest.sendLogs
            version: 1
            inputs:
              logs:
                - message: "Loop: ${{ .steps.loopStep.loop.element }}"
```

### スイッチ [#switch]

* さまざまな条件をチェックし、true と評価される最初の分岐を実行するステップ。

* スイッチには、リスト内に任意の数の`condition`要素を含めることができます。条件を順番にチェックし、最初に true と評価される条件を処理します。いずれも true と評価されない場合は、 `steps[*].next`で定義されている`next`ステップが実行されます。

  * **`steps[*].switch`** (必須)

    * **タイプ**: 配列
    * **説明**: 評価する条件の順序付きリストを指定する、スイッチ ケースの配列。

  * **`steps[*].switch[*].condition`** (必須)

    * **タイプ**: 文字列 ([式](#expression-strings))
    * **説明**: スイッチケースの状態。true と評価された場合、ケース`next`ステップが実行されます。
    * 詳細については、「[式文字列」](#expression-strings)セクションを参照してください。

  * **`steps[*].switch[*].next`** (必須)

    * **タイプ**: 文字列 ([式安全なパターン](#expression-safe-pattern)に準拠)
    * **説明**: ケースの条件が true と評価された場合に実行するステップの名前。特別なキーワード`end`を使用すると、このステップが最後に実行されることを示すことができます。

  ```yaml
    - name: hasCompleted
      type: switch
      switch:
        - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Failed" }}
          next: displayError
        - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Success" }}
          next: displaySuccess
      next: displayUnexpected
  ```

### 待って [#wait]

ワークフローの実行を指定された秒数だけ一時停止してから続行するステップ。

待機ステップでは、1 つ以上のシグナルをリッスンすることもできます。各信号には、対応する次のステップがリスト内に定義されている必要があります。待機期間中に信号が受信された場合、最初に受信した信号が処理され、ワークフローは定義された次のステップを実行します。信号が受信されない場合、待機期間の終了後にワークフローは通常どおり続行されます。

信号から受信した値は待機ステップの出力に保存され、後続のステップでロジックまたは処理に使用できます。

**例**:

```yaml
  name: waitSignalExample
  workflowInputs:
  steps:
    - name: waitStep
      type: wait
      seconds: 300
      signals: [{name: 'mySignalName', next: 'firstStep'}]
    - name: endStep
      type: action
      action: newrelic.instrumentation.log
      version: 1
      inputs:
        message: "didn't get signal"
      next: end
    - name: firstStep
      type: action
      action: newrelic.instrumentation.log
      version: 1
      inputs:
        message: ${{ .steps.waitStep.outputs.signalInputs.myString }}
```

* **`steps[*].seconds`** (必須)

  * **タイプ**: 数値
  * **説明**: ワークフローの実行を続行する前に待機する秒数。

* **`steps[*].signals`**

  * **タイプ**: 配列
  * **説明**: 受信されるとプログラムフローを転換する信号。

* **`steps[*].signals[*].name`**

  * **タイプ**: 文字列
  * **説明**: リッスンする信号の名前。

* **`steps[*].signals[*].next`**

  * **タイプ**: 文字列
  * **説明**: 指定されたシグナルを受信した場合に実行するステップ。

### 割り当てる [#assign]

ワークフロー全体で使用する変数を定義するステップ。このステップでは、後続のステップで参照できる変数に値を割り当てます。このステップ タイプでは、すべての変数を 1 か所で定義することで、ワークフローがより読みやすく最適化されます。

**サンプルワークフロー**:

```yaml
  name: sampleWorkflowWithAssign
  description: WorkflowAssignDemo

  workflowInputs:
    initialValue:
      type: String
    anotherValue:
      type: Int

  steps:
    - name: runAction
      type: action
      action: internal.http.post
      version: 1
      inputs:
        url: 'http://localhost:8505/tasks/gc' # temporal-activity-worker-java service port
        selectors:
          - name: statusCode
            expression: '.statusCode'
          - name: responseBody
            expression: '.responseBody'
    - name: variableInitialization
      type: assign
      inputs:
        stringVar: "${{ .workflowInputs.initialValue }}"
        intVar: "${{ .workflowInputs.anotherValue }}"
        concatenationVar: "${{ .workflowInputs.initialValue }} - concatenated"
        booleanVar: true
        mapVar:
          key1: "value1"
          key2: "${{ .workflowInputs.initialValue }}"
        listVar:
          - "listItem1"
          - "${{ .workflowInputs.initialValue }}"
          - "${{ .workflowInputs.anotherValue }}"
        statusCode: ${{ .steps.runAction.outputs.statusCode }}

    - name: wait
      type: wait
      seconds: 2

    - name: logVariables
      type: action
      action: newrelic.ingest.sendLogs
      version: 1
      inputs:
        logs:
          - message: "stringVar: ${{ .steps.variableInitialization.outputs.stringVar }}"
          - message: "intVar: ${{ .steps.variableInitialization.outputs.intVar }}"
          - message: "concatenationVar: ${{ .steps.variableInitialization.outputs.concatenationVar }}"
          - message: "booleanVar: ${{ .steps.variableInitialization.outputs.booleanVar }}"
          - message: "mapVar: ${{ .steps.variableInitialization.outputs.mapVar | tojson }}"
          - message: "listVar: ${{ .steps.variableInitialization.outputs.listVar | tojson }}"
          - message: "statusCode: ${{ .steps.variableInitialization.outputs.statusCode }}"
```

* **`steps[*].inputs`** (必須)

  * **タイプ**: 値のマップ（[式](#expression-strings)を含む）
  * **説明**：
    * 入力は変数名とそれに割り当てられた値のマップです。秘密参照が変数に割り当てられると、秘密参照のままとなり、実際の値に変換されません。ただし、他の式 (ワークフロー入力など) は評価され、実際の値に変換されます。
  * 許可される入力タイプ: `Integer` 、 `Double` 、 `Boolean` 、 `String` 、 `Array` 、 `Map`

## 完全な例 [#examples]

### カレンダーのデモ

ワークフロー入力、HTTP アクション、セレクター、待機ステップ、NRQL クエリ、スイッチ ステートメント、Slack 通知などの複数のワークフロー機能を示す完全なワークフロー例。

```yaml
  name: calendar_demo

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'
    accountId:
      type: Int

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'
        selectors:
          - name: timezone
            expression: '.responseBody | fromjson.abbreviation'
          - name: datetime
            expression: '.responseBody | fromjson.datetime'

    - name: logTime
      type: action
      action: newrelic.instrumentation.log
      version: 1
      inputs:
        message: 'DEMO: In the ${{ .steps.getCurrentTime.outputs.timezone }} timezone, the current time is ${{ .steps.getCurrentTime.outputs.datetime }}'
        licenseKey: ${{ :secrets:STAGING_NEW_RELIC_LICENSE_KEY }}

    - name: wait
      type: wait
      seconds: 1

    - name: queryForLog
      type: action
      action: newrelic.nrql.query
      version: 1
      inputs:
        accountIds: ['${{ .workflowInputs.accountId }}']
        query: FROM Log SELECT * WHERE message LIKE 'DEMO:%${{ .steps.getCurrentTime.outputs.datetime }}'

    - name: checkQuery
      type: switch
      switch:
        - condition: ${{ .steps.queryForLog.outputs.results | length > 0 }}
          next: postResultsMessage

    - name: postWaitingMessage
      type: action
      action: slack.chat.postMessage
      version: 1
      inputs:
        channel: test-channel-workflow
        text: Waiting for log message...
        token: ${{ :secrets:dn_staging_slack_token }}
      next: wait

    - name: postResultsMessage
      type: action
      action: slack.chat.postMessage
      version: 1
      inputs:
        channel: test-channel-workflow
        text: 'Found log message! ${{ .steps.queryForLog.outputs.results[0].message }}'
        token: ${{ :secrets:dn_staging_slack_token }}
```