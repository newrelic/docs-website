---
title: ワークフロー定義スキーマ
tags:
  - workflow automation
  - workflow schems
  - workflow automation API
metaDescription: Workflow definitions are written in YAML. Keys use a camelCase naming convention.
freshnessValidatedDate: never
translationType: machine
---

<Callout title="プレビュー">
  この機能はまだ開発中ですが、ぜひお試しください。

  この機能は現在、弊社の[プレリリース ポリシー](/docs/licenses/license-information/referenced-policies/new-relic-pre-release-policy)に従ってプレビュー プログラムの一部として提供されています。
</Callout>

## スキーマ

ワークフロー定義は YAML で記述されます。キーは`camelCase`命名規則を使用します。

### **名前**（必須）

* **タイプ**: 文字列
* **フォーマット**: 正規表現`^[A-Za-z_][A-Za-z0-9_-]*$`に準拠する必要があります。
* **最大長**: 100
* **説明**: `name`値は大文字と小文字を区別しません。たとえば、 `ExampleWorkflow` 、 `exampleworkflow` 、 `EXAMPLEWORKFLOW`はすべて同じワークフロー定義を表すものと見なされます。

### **説明**（オプション）

* **タイプ**: 文字列
* **フォーマット**: 正規表現`^[A-Za-z0-9 _-]*$`に準拠する必要があります。
* **最大長**: 200
* **説明**: ワークフローの目的を説明する`description` 。

### **workflowInputs**（オプション）

* **タイプ**: 地図の地図
* **最大サイズ**: 100
* **説明**: ワークフローが受け入れるワークフロー入力のマップ。
* **例**:

```java
  workflowInputs:
    myInput1:
      type: String
    myInput2:
      type: Number
      defaultValue: 42
```

* **`workflowInputs.<inputName>`** (必須)

  * **タイプ**: 文字列 ([式安全なパターン]()に準拠)
  * **最小の長さ**: 1
  * **最大長**: 50
  * **説明**: ワークフロー入力の名前。

* **`workflowInputs.<inputName>.type`** (必須)

  * **タイプ**: 列挙型 (ブール、リスト、マップ、文字列、整数、フロート)
  * **説明**: ワークフロー入力のデータ型。

* **`workflowInputs.<inputName>.defaultValue`** (オプション)

  * **タイプ**: 任意; `type`に準拠する必要があります。
  * **説明**: ワークフロー入力のデフォルト値。

* **手順**（必須）

  * **タイプ**: マップの配列
  * **説明**: ワークフロー定義の実行時に実行される手順。少なくとも 1 つのステップが必要です。

  <Callout variant="important">
    ステップは、 `steps`配列で定義された順序で実行されます。

    異なる順序が必要な場合は、 `steps[*].next`プロパティをジャンプ先のステップの名前に設定することで「ジャンプ」を実行できます。
  </Callout>

  * **`steps[*].name`** (必須)

    * **タイプ**: 文字列 ([式セーフパターン]()に準拠; `end`は不可)
    * **最大長**: 100
    * **説明**: `steps[*].next`によって参照されるステップの名前。終了ステップ、ループの継続、またはループからの脱出を示すために使用される特殊キーワード`end` 、 `continue` 、または`break`は使用できません。

  * **`steps[*].type`** (必須)

    * **タイプ**: 文字列
    * **説明**: ステップのタイプ。実行時にステップが何を行うかを示します。利用可能なオプションについては、[ステップ タイプ]()を参照してください。

  * [**`steps[*].next`**](#steps-next) (オプション)

    * **タイプ**: 文字列 ([式安全なパターン]()に準拠)

    * **説明**：

      * このステップが正常に完了したときに実行される次のステップの名前。特別なキーワード`end`を使用すると、このステップが最後に実行されることを示すことができます。
      * `next`が省略されている場合、定義の`steps`配列内の次のエントリが暗黙的な次のステップとして使用されます。次のエントリがない場合、ワークフローは完了します。

## ステップの種類

### **アクション**

特定のアクションを実行するステップ。利用可能なオプションについては、[アクション カタログ](/docs/workflow-automation/setup-and-configuration/actions-catalog/actions-catalog)を参照してください。

* **`steps[*].action`** (必須)

  * **タイプ**: 文字列

  * **説明**: 実行するアクション関数の完全修飾名。次の規則に従う必要があります。

    `<company domain>.<category of work>.<action name in camelCase>`

  * **例**:

    * New Relic サービスを使用したアクション (例: NerdGraph 経由): `newrelic.dashboards.getDashboard`
    * Slackを使ったアクション: `slack.chat.postMessage`

* **`steps[*].version`** (必須)

  * **タイプ**: 文字列
  * **説明**: 実行するアクション関数のバージョン。

* **`steps[*].inputs`** (オプション)

  * **タイプ**: 値のマップ（[式]()を含む）

  * **説明**：

    * アクション関数に渡す入力。受け入れられる特定の入力は、各アクションによって定義されます。
    * 入力には式を使用できます。詳細については、[式文字列の]()セクションを参照してください。

  <Callout variant="important">
    機密データ ( APIキーやシークレット、PII、PHI、または個人を特定できるデータ) を引数として渡さないでください。
  </Callout>

* **`steps[*].inputs.selectors`** (オプション)

  * **タイプ**: `name`と`expression`の形式のマップのリスト。

  * **説明**：

    * `selectors`入力を使用すると、指定された要素のみを返すように出力を再定義できます。
    * 表現が使えます。詳細については、[式文字列の]()セクションを参照してください。

  * **例**

    * この例では、http.get アクションの応答として`pageUrl`と`statusDescription`を取得しています。

    ```yaml
        name: status
        description: A workflow for checking the status of New Relic components

        steps:
          - name: query1
            type: action
            action: http.get
            version: 1
            inputs:
              url: "https://status.newrelic.com/api/v2/status.json"
              selectors:
                - name: statusCode
                  expression: '.statusCode'
                - name: pageUrl
                  expression: '.responseBody | fromjson | .page.url'
                - name: statusDescription
                  expression: '.responseBody | fromjson | .status.description'

          - name: logOutput1
            type: action
            action: newrelic.ingest.sendLogs
            version: 1
            inputs:
              logs:
                - message: "status is '${{ .steps.query1.outputs.statusDescription }}' details at ${{ .steps.query1.outputs.pageUrl }}"
    ```

### **ループ**

ループは、 `in`で定義された特定のコレクションを反復処理し、反復ごとにループ変数`index`と`element`を作成します。これらのループ変数は、式`${{ .steps.<loopStepName>.loop.element }}`または `${{ .steps.<loopStepName>.loop.index }`

詳細については以下を参照してください。

<CollapserGroup>
  <Collapser id="moreforloop" title="リスト、マップ、コレクションを反復処理するループ">
    ループを使用して、リスト、マップ、またはコレクションを反復処理できます。

    * `for` （必須）

      * **タイプ**: 定数
      * **説明**: ループの開始を知らせます。

    * `in` （必須）

      * **タイプ**: 文字列 (式)
      * **説明**: 要素のコレクションに評価する必要がある式。

    * `steps` （必須）

      * **説明**: ループの各反復で実行される手順。ステップは、別のループを含む任意のタイプのステップにすることができます。

      * **例**: 以下は、ループ workflowInputs を実行する方法を示しています。結果はコレクションの型である必要があることに注意してください。

        ```yaml
            name: myWorkflow
            steps:
              - name: loopStep
                type: loop
                for:
                  in: '${{ .workflowInputs.count }}'
                  steps:
                    - name: step1
                      type: action
                      action: example.messaging.sayHello
                      version: '1.0.0'
                      inputs:
                        name: '${{ .steps.loopStep.loop.element }}' # not exist outside of this loop
                        index: '${{ .steps.loopStep.loop.index }}' # not exist outside of this loop
        ```

    <Callout variant="important">
      * `element` `index`はループの一部として自動的に割り当てられます。
      * `Index` ゼロベースです。
      * 複合要素のコレクションがある場合、 `element`複合型になることがあります。
      * ループ内のすべてのループ変数とループ内のステップからの出力には、ループ レベルのスコープがあります。これらの変数はループを終了した後にクリアされ、ループの外部からアクセスすると null 値になります。ループは、以前に定義されている場合、ループ外の変数にアクセスできます。
    </Callout>

    **整数に対する単純な for ループ**

    ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: ${{ [range(1; 6)] }}
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'  # [1, 2, 3, 4, 5]
                    index: '${{ .steps.loopStep.loop.index }}' # [0, 1, 2, 3, 4]
    ```

    **マップのシンプルなループ**

    ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'  # [{ "key1": "val1" }, { "key2": "val2"}]
                    index: '${{ .steps.loopStep.loop.index }}' # [0, 1]
    ```

    **ループ内でジャンプする**

    同じ for ループに属する名前付きステップ間のジャンプのみが許可されます。for ループ内またはループ外、内部/外部ループ、または 2 つの異なる for ループ間でのジャンプは許可されません。

    ```yaml
        name: myWorkflow
        steps:
          - name: firstStep
            type: action
            action: example.messaging.sayHello
            version: '1.0.0'
          - name: loopStep
            type: loop
            for:
              in: '${{ .workflowInputs.count }}'
              steps:
                - name: step1
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.loopStep.loop.element }}'
                  next: step3                                 # Okay within the loop
                - name: step2
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  inputs:
                    name: '${{ .steps.step1.outputs.greeting }}'
                - name: step3
                  type: action
                  action: example.messaging.sayHello
                  version: '1.0.0'
                  next: firstStep                            # Not okay, first step is not in the loop context
    ```

    **ループ内でbreak/continueを使用する**

    for ループのフローを変更するには、 `next: break`または`next: continue`を使用できます。`break`と`continue`ループ内で暗黙的に定義された予約済みのジャンプ ターゲットであることに注意してください。ループの外で`next: break`または`next: continue`を使用すると、ワークフロー ステップの最後にジャンプします。

    * `end`はループ内で使用される場合、 `break`と同じように機能します。
    * Next は、スイッチ ステップまたは任意のタイプのステップの両方で使用できます。

    ```yaml
      name: myWorkflow
      steps:
        - name: loopStep
          type: loop
          for:
            in: '${{ [range(1; 6)] }}'
            steps:
              - name: insideLoopStep1
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
                next: continue
              - name: insideLoopStep2
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStep.loop.element }}'
        - name: loopStepAgain
          type: loop
          for:
            in: '${{ .workflowInputs.count }}'
            steps:
              - name: switchStep
                type: switch
                switch:
                  - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                    next: break
              - name: insideLoopStepAgain
                type: action
                action: example.messaging.sayHello
                version: '1.0.0'
                inputs:
                  name: '${{ .steps.loopStepAgain.loop.element }}'
    ```
  </Collapser>
</CollapserGroup>

* **`steps[*].for`** (必須)

  * **タイプ**: 定数
  * **説明**: ループの開始を知らせる信号

* **`steps[*].in`** (必須)

  * **タイプ**: 文字列 (式)

  * **説明**: 要素のコレクションとして評価する必要がある式。

  * **`steps[*].steps`** (オプション)

    * **説明**: ループの各反復で実行される手順。上記の手順については定義を参照してください。

    * **例**:

      ```yaml
        name: myWorkflow
        steps:
          - name: loopStep
            type: loop
            for:
              in: "${{ [range(1; 5)] }}""
              steps:
                - name: step1
                  type: action
                  action: newrelic.ingest.sendLogs
                  version: 1
                  inputs:
                    logs:
                      - message: "Loop: ${{ .steps.loopStep.loop.element }}"
      ```

### **スイッチ**

* さまざまな条件をチェックし、true と評価される最初の分岐を実行するステップ。

* スイッチには、リスト内に任意の数の条件要素を含めることができます。条件を順番にチェックし、最初に true と評価される条件を処理します。どれもtrueと評価されない場合は、steps\[\*].nextで定義されている次のステップを実行します。

* **`steps[*].switch`** (必須)

  * **タイプ**: 配列
  * **説明**: 評価する条件の順序付きリストを指定する、スイッチ ケースの配列。

* **`steps[*].switch[*].condition`** (必須)

  * **タイプ**: 文字列 (式)
  * **説明**: スイッチケースの状態。true と評価された場合、ケースの次のステップが実行されます。

* **`steps[*].switch[*].next`** (必須)

  * **タイプ**: 文字列 ([式安全なパターン]()に準拠)
  * **説明**: ケースの条件が true と評価された場合に実行するステップの名前。特別なキーワード end を使用すると、このステップが最後に実行されることを示すことができます。

  ```yaml
  - name: hasCompleted
    type: switch
    switch:
      - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Failed" }}
        next: displayError
      - condition: ${{ .steps.waitForCompletion.outputs.automationExecutionStatus == "Success" }}
        next: displaySuccess
    next: displayUnexpected
  ```

### 待つ

ワークフローの実行を続行する前に一定の秒数待機させるステップ。1 つ以上の信号をリッスンすることもできます。待機中に信号が受信されない場合は、通常どおり続行されます。信号はリストで定義されます。各信号には対応する次のステップを定義する必要があります。最初に受信された信号が処理されます。信号として受信された値は、待機ステップのステップ出力に保存され、後のステップでのロジック処理に使用できます。

* 例：

  ```yaml
    name: waitSignalExample
    workflowInputs:
    steps:
      - name: waitStep
        type: wait
        seconds: 300
        signals: [{name: 'mySignalName', next: 'firstStep'}]
      - name: endStep
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: "didn't get signal"
        next: end
      - name: firstStep
        type: action
        action: newrelic.ingest.sendLogs
        version: 1
        inputs:
          logs:
            - message: ${{ .steps.waitStep.outputs.signalInputs.myString }}
  ```

* **`steps[*].seconds`** (必須)

  * **タイプ**: 数値
  * **説明**: ワークフローの実行を続行する前に待機する秒数。

* **`steps[*].signals`**

  * **タイプ**: 配列
  * **説明**: 受信されるとプログラムフローを転換する信号。

* **`steps[*].signals[*].name`**

  * **タイプ**: 文字列
  * **説明**: リッスンする信号の名前。

* **`steps[*].signals[*].next`**

  * **タイプ**: 文字列
  * **説明**: 指定されたシグナルを受信した場合に実行するステップ。

## 共有型

### 式文字列

いくつかのプロパティは、ワークフロー実行中に評価される埋め込み式を含む文字列値を受け入れ、ワークフロー定義内で動的な値を使用できるようにします。式文字列には 1 つまたは複数の式を含めることができ、各式は二重中括弧で囲まれます。中括弧内の内容は jq を使用して評価されます。

jq は、さまざまな方法で値にアクセスし、値を操作する機能を提供します。たとえば、ワークフロー入力文字列の長さは次のようにして実現できます。 `${{ .workflowInputs.myString | length }}`

[JQ 式を構築およびテストする](https://play.jqlang.org/)には、このツールを使用できます。

### 式のプロパティ

式を使用して、多数のプロパティにアクセスできます。これらのプロパティは「scope」オブジェクト内に存在するため、scope オブジェクトのこれらのプロパティにアクセスするには、式をピリオド (.) で始める必要があります。

利用可能なプロパティは次のとおりです。

* `workflowInputs` - 開始時にワークフローに渡される入力を含むオブジェクト。
  * 例： `${{ .workflowInputs.myInput }}`
* `steps` - ワークフローの各ステップのプロパティを含むオブジェクト
  * `steps.<stepName>` - 特定のステップのプロパティを含むオブジェクト
    * `steps.<stepName>.outputs` - ステップ/アクションに固有の結果プロパティを含むオブジェクト。
      * 例： `${{ .steps.myStep.outputs.myResult }}`

### 表現評価結果

単一の jq 式は任意の JSON 型に評価できますが、式文字列全体の最終結果は式を囲む文字列の内容 (存在する場合) に依存することに注意することが重要です。

式文字列全体が単一の式で構成されている場合は、結果の JSON 型を維持しながら、jq 式の結果に評価されます。たとえば、ワークフローに入力として配列が渡された場合、文字列`${{ .workflowInputs.myArray }}`は配列として評価されます。これは、ワークフロー内で複雑なデータを渡す場合に役立ちます。

式文字列に単一の式以外のコンテンツが含まれている場合は、文字列の結果に評価されます。たとえば、式の前後にコンテンツがある場合や、文字列内に複数の式がある場合に、この現象が発生します。文字列内の各式は評価され、文字列表現に変換されます。

例：

次の例では、myArray の値が \[1, 2, 3] であると仮定します。

<table>
  <thead>
    <tr>
      <th>
        式文字列
      </th>

      <th>
        結果データ
      </th>

      <th>
        結果タイプ
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `${{ .workflowInputs.myArray }}`
      </td>

      <td>
        \[1, 2, 3]
      </td>

      <td>
        数字の配列
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        3
      </td>

      <td>
        ナンバー
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        true
      </td>

      <td>
        ブール値
      </td>
    </tr>

    <tr>
      <td>
        `Input is not empty: ${{ .workflowInputs.myArray | length > 0 }}`
      </td>

      <td>
        「入力が空ではありません: true」
      </td>

      <td>
        ストリング
      </td>
    </tr>

    <tr>
      <td>
        `${{ .workflowInputs.myArray }} has length ${{ .workflowInputs.myArray | length }}`
      </td>

      <td>
        「長さは3です」
      </td>

      <td>
        ストリング
      </td>
    </tr>
  </tbody>
</table>

### 式セーフパターン [#expression-safe-pattern]

式で使用できるプロパティは、次の正規表現に準拠する必要があります。 `^[A-Za-z_][A-Za-z0-9_]*$`

### 秘密の参照

シークレット値は、シークレット サービスで検索するシークレットの名前を指定する参照文字列を介してアクションで使用できます。ワークフロー定義でシークレットを参照するには、次の構文を使用します。

* `${{ :secrets:<SECRET_NAME> }}` 秘密は `namespace`
* `${{ :secrets:<NAMESPACE>:<SECRET_NAME> }}` 秘密のために `namespace`

式文字列には、シークレット参照と JQ 式の組み合わせ、または複数のシークレット参照を含めることができます。

例：

```yaml
  steps:
  - name: bearer_auth
    type: action
    action: http.post
    inputs:
      headers:
        Authorization: Bearer ${{ :secrets:<SECRET_NAME> }}
```

## 例

* こんにちは世界

```yaml
name: helloWorld
description: 'A hello world workflow'

workflowInputs:
  name:
    type: String
    defaultValue: World
    required: false
    validations:
      - type: maxLength
        errorMessage: "name must be at most 100 characters"
        length: 100
  slackTokenSecret:
    type: String
    defaultValue: "${{ :secrets:SLACK_TOKEN }}"
  slackChannel:
    type: String
    defaultValue: my-channel
    validations:
      - type: regex
        errorMessage: "A slack channel name must be lowercase and can only contain letters, numbers, and hyphens"
        pattern: "^[a-z0-9\\-]+$"
    required: true

steps:
  - name: init1
    type: assign
    inputs:
      greeting: Hello ${{ .workflowInputs.name }}

  - name: logName
    type: action
    action: newrelic.ingest.sendLogs
    version: 1
    inputs:
      logs:
        - message: ${{ .steps.init1.outputs.greeting }}

  - name: waiting1
    type: wait
    seconds: 1

  - name: queryForLog
    type: action
    action: newrelic.nrdb.query
    version: 1
    inputs:
      query: >-
        FROM Log SELECT * WHERE message LIKE '${{ .steps.init1.outputs.greeting
        }}'

  - name: checkResult
    type: switch
    switch:
      - condition: ${{ .steps.queryForLog.outputs.results | length > 0 }}
        next: FoundMessage

  - name: waitingMessage
    type: action
    action: slack.chat.postMessage
    version: 1
    inputs:
      channel: ${{ .workflowInputs.slackChannel }}
      text: Waiting for log message...
      token: ${{ .workflowInputs.slackTokenSecret }}
    next: waiting1

  - name: FoundMessage
    type: action
    action: slack.chat.postMessage
    version: 1
    inputs:
      channel: ${{ .workflowInputs.slackChannel }}
      text: Found message! ${{ .steps.queryForLog.outputs.results[0].message }}
      token: ${{ .workflowInputs.slackTokenSecret }}
```