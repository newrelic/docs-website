---
title: ワークフローの例
tags:
  - workflow automation
  - workflow
  - automation
  - examples
metaDescription: 'Common workflow automation scenarios and examples for incident response, infrastructure management, and integrations.'
freshnessValidatedDate: never
translationType: machine
---

このページでは、ワークフロー自動化を使用して構築できる一般的な自動化シナリオを示します。これらの例を独自のワークフローの開始点として使用するか、すぐにデプロイできるソリューションの[テンプレート ライブラリ](/docs/workflow-automation/create-a-workflow-automation/use-a-template)を探索してください。

## APIゲートウェイのロールバック

API ゲートウェイの構成を以前の状態に戻して、エラーや誤った構成を修正できるようにします。

**このワークフローの機能:**

* New Relic Change Tracking (変更追跡機能) を使用して、問題に関連する最近のデプロイメントを検出します
* 承認ボタン付きのSlack通知を送信します `(:+1: or :-1:)`
* 承認後、ロールバックを自動化するための AWS Systems Manager ドキュメントを作成します。
* API Gateway 統合を以前のLambdaバージョンにロールバックします
* ロールバックを適用するための新しいデプロイメントを作成します
* Slackに成功または失敗の通知を送信します
* 完了後にSSMドキュメントをクリーンアップします

**要件：**

* API Gateway および Systems Manager の権限を持つ AWS 認証情報
* 通知と承認を受け取るための設定済みSlackアプリ
* 変更追跡によるNew Relicエンティティ監視 (変更追跡機能)

**キーアクション**: `newrelic.nerdgraph.execute` 、 `slack.chat.postMessage` 、 `slack.chat.getReactions` 、 `aws.systemsManager.writeDocument` 、 `aws.systemsManager.startAutomation` 、 `aws.systemsManager.waitForAutomationStatus` 、 `aws.systemsManager.deleteDocument`

## EC2インスタンス管理

EC2 インスタンスのプロビジョニング、スケーリング、終了を自動化して、最適なパフォーマンスとコストを実現します。

**このワークフローの機能:**

* New Relic から CPU 使用率が高いというアラートを受信します。
* 詳細をまとめて取得し、影響を受ける EC2 インスタンスを特定します。
* インスタンスの詳細を含む Slack 通知を送信し、サイズ変更の承認requests 。
* 承認後、インスタンスのサイズ変更を自動化するための SSM ドキュメントを作成します。
* インスタンスを停止し、インスタンスタイプを変更して再起動します。
* サイズ変更プロセス中に、進行状況の更新を Slack に送信します。
* 完了を待機し、成功または失敗のステータスを送信します。
* SSM ドキュメントをクリーンアップし、最終確認を送信します。

**要件：**

* EC2 および Systems Manager の権限を持つ AWS 認証情報
* EC2 メトリクスのアクティブな New Relic アラート条件
* 通知と承認を受け取るための設定済みSlackアプリ

**キーアクション**: `newrelic.nerdgraph.execute` 、 `newrelic.nrdb.query` 、 `slack.chat.postMessage` 、 `slack.chat.getReactions` 、 `aws.systemsManager.writeDocument` 、 `aws.systemsManager.startAutomation` 、 `aws.systemsManager.waitForAutomationStatus` 、 `aws.systemsManager.deleteDocument` 、 `utils.datetime.fromEpoch` 、 `utils.uuid.generate`

## デプロイメントのロールバック

エンティティが異常になった場合はデプロイメントをロールバックし、AWS SQS または HTTP のいずれかで通知します。

**このワークフローの機能:**

* エンティティの重大度を指定された期間 (デフォルトは 30 分) 監視します。
* エンティティの健全性を1分ごとにチェックします
* エンティティがCRITICALまたはWARNINGになった場合、不健全な状態をログに記録します。
* エンティティの詳細を含むロールバック通知を AWS SQS (設定されている場合) 経由で送信します。
* HTTP Webhook 経由でロールバック通知を送信します (設定されている場合)
* エンティティが全期間健全なままであれば、成功をログに記録します
* エンティティが見つからない場合は監視を停止します

**要件：**

* New Relicエンティティの重大度監視
* (オプション) ロールバック通知を受信するための AWS SQS キューとロール
* (オプション) ロールバック通知を受信する HTTP エンドポイント

**キーアクション**: `newrelic.nerdgraph.execute` 、 `newrelic.ingest.sendLogs` 、 `aws.execute.api` 、 `(sqs.send_message)` 、 `http.post`

## AWS SQS メッセージング

ダウンストリーム処理または通知システムのために、AWS SQS キューにメッセージを送信します。

**このワークフローの機能:**

* 指定されたSQSキューにメッセージを送信します
* 安全なアクセスのためにAWS IAMロール認証を使用する
* 検証のメッセージIDと成功ステータスを返します

**要件：**

* `sqs:SendMessage`権限を持つ AWS 認証情報
* SQSキューURL
* ワークフロー自動化用に設定された IAM ロール（ [AWS 認証情報の設定を](/docs/workflow-automation/setup-and-configuration/set-up-aws-credentials)参照）

**キーアクション**: `aws.execute.api` 、 `(sqs.send_message)`

```yaml
  name: aws_execute_api_sqs_example

  workflowInputs:
    awsRoleArn:
      type: String
    awsRegion:
      type: String
      defaultValue: us-west-2
    awsQueueUrl:
      type: String

  steps:
    - name: sendSqsMessage
      type: action
      action: aws.execute.api
      version: 1
      inputs:
        awsRoleArn: ${{ .workflowInputs.awsRoleArn }}
        region: ${{ .workflowInputs.awsRegion }}
        service: sqs
        api: send_message
        parameters:
          QueueUrl: "${{ .workflowInputs.awsQueueUrl }}"
          MessageBody: |
            {
              "message": "deployment is bad",
              "status": "not good"
            }
        selectors:
          - name: success
            expression: '.success'
          - name: messageId
            expression: '.response.MessageId'
```

## 複雑なNRQLアラート

時間枠間でデータを比較したり、通知をトリガーする前にカスタム ロジックを適用したりするなど、標準アラートではサポートできない複雑な NRQL クエリを処理します。

**このワークフローの機能:**

* 異なる時間枠（10 分前から 5 分前までと最後の 5 分）を比較する 2 つの NRQL クエリを実行します。
* クエリ結果を比較してカウントが増加したかどうかを検出します
* スイッチステップを使用して、新しいイベントが検出された場合にのみ条件付きで通知を送信します。
* クエリ結果とCSV添付ファイルを含む電子メール通知を送信します
* 継続的な監視のために10分ごとに実行するようにスケジュールできます

**要件：**

* クエリするデータを持つ New Relic アカウント
* New Relic で設定されたメールの送信先（[ワークフローから通知を送信するを](/docs/workflow-automation/setup-and-configuration/create-destinations)参照）
* [CreateSchedule API](/docs/workflow-automation/workflow-automation-apis/create-schedule)を使用してスケジュールされたワークフロー

**キーアクション**: `newrelic.nrdb.query` 、 `newrelic.notification.sendEmail`

**使用例**: このパターンは、次のような標準の New Relic アラートでは要件を処理できない場合に役立ちます。

* 複数の時間枠にわたるメトリクスの比較
* クエリ結果にカスタム数学演算を適用する
* 特定の閾値またはパターンが検出された場合にのみトリガーする
* 条件付きロジックを使用して複数のクエリからのデータを結合する

```yaml
  name: Complex_Alert_Workflow
  description: 'Compares NRQL results across time windows and sends alerts when new events are detected'

  workflowInputs:
    destinationId:
      type: String
    query:
      type: String
      defaultValue: 'FROM Span SELECT count(*)'

  steps:
    - name: query1
      type: action
      action: newrelic.nrdb.query
      version: 1
      inputs:
        query: "${{ .workflowInputs.query }} SINCE 10 minutes ago UNTIL 5 minutes ago"
        accountIds:
          - 7401815
        selectors:
          - name: length
            expression: '[ .results[] | length ]'
          - name: count
            expression: '[ .results[0].count ]'

    - name: query2
      type: action
      action: newrelic.nrdb.query
      version: 1
      inputs:
        query: "${{ .workflowInputs.query }} SINCE 5 minutes ago"
        accountIds:
          - 7401815
        selectors:
          - name: length
            expression: '[ .results[] | length ]'
          - name: count
            expression: '[ .results[0].count ]'

    - name: CheckForNewEvents
      type: switch
      switch:
        - condition: >-
            ${{ (.steps.query2.outputs.count - .steps.query1.outputs.count) > 0 }}
          next: sendEmail
      next: end

    - name: sendEmail
      type: action
      action: newrelic.notification.sendEmail
      version: 1
      inputs:
        destinationId: ${{ .workflowInputs.destinationId }}
        subject: Hello there!
        message: >-
          More spans incoming!!!
          There are --- ${{ (.steps.query2.outputs.count - .steps.query1.outputs.count) }} ---
          new Spans that were ingested in the last 5 minutes
        attachments:
          - type: QUERY
            query: ${{ .workflowInputs.query }} SINCE 5 minutes ago
            format: CSV
            filename: span_count.csv
      next: end
```

**このワークフローをスケジュールするには**、 `*/10 * * * *` (10 分ごと) のような cron 式で[CreateSchedule API](/docs/workflow-automation/create-a-workflow-automation/start-schedule#scheduled)を使用します。最小スケジュール間隔は 10 分であることに注意してください。詳細については、[ワークフローの制限を](/docs/workflow-automation/limitations-and-faq/workflow-limits)参照してください。

## Slackにレポートを送信する

NRQL クエリ出力を CSV ファイルとして Slack に送信します。

**このワークフローの機能:**

* 指定されたNew Relicアカウントに対してNRQLを実行します
* クエリ結果からCSVファイルを生成します
* CSVファイルを指定されたSlackチャンネルにメッセージとともに投稿する

**要件：**

* New Relic 認証情報と機能的な NRQL クエリ
* トークンとターゲットチャンネルが設定されたSlackアプリ

**キーアクション**: `newrelic.nrdb.query` 、 `utils.transform.toCSV` 、 `slack.chat.postMessage`

## JSON解析

New Relic パブリック ステータス API JSON (HTTP) を解析し、オプションで運用コンポーネントと非運用コンポーネントをログに記録します。

**このワークフローの機能:**

* New RelicステータスAPIからJSONデータを取得します
* コンポーネントを動作状態別に抽出し分類します
* 条件付きで運用コンポーネントをログに記録する（有効な場合）
* 条件付きで非動作コンポーネントをログに記録する（有効な場合）
* HTTPエラーを処理し、エラーメッセージをログに記録します

**要件：**

* New Relic ステータス API へのアクセス (`summary.json`)
* newrelic.ingest.sendLogs 経由でログを送信する権限

**キーアクション**: `http.get` 、 `newrelic.ingest.sendLogs`

## REST APIポーリングとログ記録

REST APIエンドポイントをポーリングし、結果をループし、データをNew Relicにログ記録します。

<Callout variant="important">
  完全なペイロードが必要な場合は、セレクターを使用する必要はありません。ほとんどのワークフロー ツールでは、完全な応答オブジェクトを直接参照できます。
</Callout>

### シンプルなGETとログ

API をポーリングして完全な応答をログに記録する基本的な使用例:

**このワークフローの機能:**

* トリガー: スケジュール（例：5分ごと）または手動で実行

* HTTP リクエストステップ:

  * メソッド: GET
  * URL: [https://pokeapi.co/api/v2/pokemon](https://pokeapi.co/api/v2/pokemon)
  * 完全なレスポンス本文を変数に保存します（例: `{{.http_response}}` ）。

* イベントのログ/作成手順:

  * `{{.http_response.body}}`全体をペイロードとして送信します
  * セレクターは必要ありません。生のJSONをそのまま渡すだけです。

### ループとセレクターを使用したREST API

この例では、API からのすべての結果を収集し、それらをループし、個別の HTTP 呼び出しを行い、抽出されたデータをログに記録します。

**このワークフローの機能:**

* REST APIエンドポイントからすべての結果を取得します
* レスポンス内の各結果をループする
* ループからのデータを使用して、各アイテムごとに個別のAPI呼び出しを作成します。
* セレクタを使用して各レスポンスから特定のフィールドを抽出します
* カスタムアトリビュートを使用して、抽出したデータをNew Relicにログ記録します

**要件：**

* REST APIエンドポイントへのアクセス
* ログを送信する権限 `newrelic.ingest.sendLogs`

**キーアクション**: `http.get` 、 `newrelic.ingest.sendLogs`

```yaml
  name: pokemon_workflow
  description: ''
  steps:
    - name: get_all_pokemons
      type: action
      action: http.get
      version: '1'
      inputs:
        url: https://pokeapi.co/api/v2/pokemon
        selectors:
          - name: pokemons
            expression: .responseBody | fromjson.results
    - name: pokemon_loop
      type: loop
      for:
        in: ${{ .steps.get_all_pokemons.outputs.pokemons }}
        steps:
          - name: get_individual_pokemon
            type: action
            action: http.get
            version: '1'
            inputs:
              url: ${{ .steps.pokemon_loop.loop.element.url }}
              selectors:
                - name: pokemon_name
                  expression: .responseBody | fromjson.name
                - name: pokemon_id
                  expression: .responseBody | fromjson.id
                - name: pokemon_stats
                  expression: .responseBody | fromjson.stats
          - name: log_pokemon_info
            type: action
            action: newrelic.ingest.sendLogs
            version: '1'
            inputs:
              logs:
                - message: >-
                    Pokemon name is: ${{
                    .steps.get_individual_pokemon.outputs.pokemon_name}}, Id: ${{
                    .steps.get_individual_pokemon.outputs.pokemon_id}}
                  attributes:
                    pokemon_stats: ${{ .steps.get_individual_pokemon.outputs.pokemon_stats}}
            next: continue
      next: end
```

### REST APIからCSVへの変換

この例では、セレクターなしで完全なレスポンスを使用し、API データを CSV に変換して、Slack 経由で共有する方法を示します。

**このワークフローの機能:**

* タイムゾーン入力に基づいて、World Time API から現在の時刻データを取得します。
* 完全なJSONレスポンスをCSV形式に変換します
* CSV データをNew Relicにログ記録します
* CSVファイルをSlackチャンネルに投稿する

**要件：**

* REST APIエンドポイントへのアクセス
* newrelic.ingest.sendLogs 経由でログを送信する権限
* トークンとターゲットチャンネルが設定されたSlackアプリ

**キーアクション**: `http.get` 、 `utils.transform.toCSV` 、 `newrelic.ingest.sendLogs` 、 `slack.chat.postMessage`

```yaml
  name: jsontocsv

  workflowInputs:
    timezone:
      type: String
      defaultValue: 'America/Los_Angeles'

  steps:
    - name: getCurrentTime
      type: action
      action: http.get
      version: 1
      inputs:
        url: 'https://worldtimeapi.org/api/timezone/${{ .workflowInputs.timezone }}'

    - name: csv1
      type: action
      action: utils.transform.toCSV
      version: 1
      inputs:
        json: ${{ .steps.getCurrentTime.outputs.responseBody }}

    - name: logOutput
      type: action
      action: newrelic.ingest.sendLogs
      version: 1
      inputs:
        logs:
          - message: 'CSV: ${{ .steps.csv1.outputs.csv }}'

    - name: postCsv
      type: action
      action: slack.chat.postMessage
      version: 1
      inputs:
        channel: test-channel-workflow
        text: "Current Date details"
        attachment:
          filename: 'file.csv'
          content: ${{ .steps.csv1.outputs.csv }}
        token: ${{ :secrets:dn_staging_slack_token }}
```

## 利用可能なテンプレートワークフロー

上記のテンプレートはNew Relicワークフロー Automation UIで直接利用できます。 アクセスするには:

1. **All Capabilities &gt; Workflow Automation**へ移動
2. **Create workflow** \[ワークフローの作成を]クリック
3. **Use a template** \[テンプレートを使用するを]選択
4. テンプレートライブラリを参照して、ユースケースに合ったワークフローを選択します

各テンプレートには以下が含まれます。

* 事前設定されたワークフローステップとロジック
* 入力例
* 必要な認証情報と統合
* 期待される成果の文書化

テンプレートをそのまま使用することも、特定の要件に合わせてカスタマイズすることもできます。

## ステップ間でのデータの受け渡し

すべてのワークフローは、テンプレート構文を使用して前のステップからの出力を参照できます。これにより、アクションを連結し、複雑な自動化ロジックを構築できます。

### ワークフロー入力の使用

実行時に動的な値を渡すには、構文`${{ .workflowInputs.variableName }}`を使用できます。この構文はエンドポイント URL やその他の入力フィールドで機能します。

**例：**

```json
  {
    "inputs": [
      {
        "key": "urlParams",
        "value": "{\"filter\": \"active\"}"
      },
      {
        "key": "headers",
        "value": "{\"Api-Key\": \"your-api-key\"}"
      }
    ]
  }
```

### 基本的なデータの受け渡し

この例では、 New Relicからまとめて発行し、アクティブな各発行について Slack に通知を送信します。

```yaml
  name: alertSlack
  description: "query Alert Issues and send notifications to Slack"

  workflowInputs:
    accountId:
      type: Int

  steps:
    - name: getAlert
      type: action
      action: newrelic.nerdgraph.execute
      version: 1
      inputs:
        graphql: |
          query GetAlertIssues($accountId: Int!) {
            actor {
              account(id: $accountId) {
                aiIssues {
                  issues(filter: {states: ACTIVATED}) {
                    issues {
                      issueId
                      priority
                      state
                      title
                    }
                  }
                }
              }
            }
          }
        variables:
          accountId: ${{ .workflowInputs.accountId }}

    - name: loopStep
      type: loop
      for:
        in: ${{ .steps.getAlert.outputs.data.actor.account.aiIssues.issues.issues }}
        steps:
          - name: sendToSlack
            type: action
            action: slack.chat.postMessage
            version: 1
            inputs:
              token: ${{ :secrets:your_slack_token }}
              channel: incident-channel
              text: >
                issueId: ${{ .steps.loopStep.loop.element.issueId }}
                priority: ${{ .steps.loopStep.loop.element.priority }}
                state: ${{ .steps.loopStep.loop.element.state }}
                title: ${{ .steps.loopStep.loop.element.title | tostring }}
```

### ループ構造

ループを使用して、リスト、マップ、またはコレクションを反復処理できます。

ループは、 `in`で定義された特定のコレクションを反復処理します。反復ごとにループ変数`index`と`element`が自動的に作成されます。これらのループ変数は、 [JQ 式](https://play.jqlang.org/)`${{ .steps.<loopStepName>.loop.element }}`または`${{ .steps.<loopStepName>.loop.index }}`を使用してループ内でアクセスできます。

**パラメーター：**

* **`for`** (必須): ループの開始を知らせる
* **`in`** (必須、文字列式): 要素のコレクションに評価する必要がある式
* **`steps`** (必須): ループの各反復で実行されるステップ。ステップは、別のループを含む任意のタイプのステップにすることができます。

**ワークフロー入力によるループ:**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
```

**重要な注意事項:**

* `for`： 必須。これはforループの開始を示す最上位要素です
* `in`： 必須。反復処理する入力コレクションは、 Java配列にキャスト可能である必要があります。
* `steps`： 必須。各反復でステップが実行される
* `element` `index`はループの一部として自動的に割り当てられます
* `index` ゼロベース
* 複合要素のコレクションがある場合、 `element`は複合型になることがあります。
* ループ内で作成された変数（ループ変数とステップ出力）は、ループ内でのみアクセス可能です。
* これらの変数はループが終了するとクリアされ、ループ外からアクセスするとnullになります。
* ループはループ外で定義された変数にアクセスできる

**整数の単純なループ:**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: ${{ [range(1; 6)] }}
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
```

**マップの単純なループ:**

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [ { "key1": "val1" }, { "key2": "val2"} ] }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: 'Element: ${{ .steps.loopStep.loop.element }}, Index: ${{ .steps.loopStep.loop.index }}'
```

**ループ内でジャンプ:**

同じ for ループに属する名前付きステップ間のジャンプのみが許可されます。for ループ内またはループ外、内部/外部ループ、または 2 つの異なる for ループ間でのジャンプは許可されません。

```yaml
  name: myWorkflow
  steps:
    - name: firstStep
      type: action
      action: internal.example.sayHello
      version: '1'
    - name: loopStep
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: step1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: step3  # Okay within the loop
          - name: step2
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.step1.outputs.greeting }}'
          - name: step3
            type: action
            action: internal.example.sayHello
            version: '1'
            next: firstStep  # Not okay, first step is not in the loop context
```

**ループ内で break/continue を使用します。**

for ループのフローを変更するには、 `next: break`または`next: continue`使用できます。`break`と`continue`は、ループ内で暗黙的に定義された予約済みのジャンプ ターゲットであることに注意してください。ループの外側で`next: break`または`next: continue`を使用すると、ワークフロー ステップの最後にジャンプします。

`end`は、ループ内で使用される場合、 `break`と同じように機能します。Next は、スイッチ ステップまたは任意のタイプのステップの両方で使用できます。

```yaml
  name: myWorkflow
  steps:
    - name: loopStep
      type: loop
      for:
        in: '${{ [range(1; 6)] }}'
        steps:
          - name: insideLoopStep1
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
            next: continue
          - name: insideLoopStep2
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStep.loop.element }}'
    - name: loopStepAgain
      type: loop
      for:
        in: '${{ .workflowInputs.count }}'
        steps:
          - name: switchStep
            type: switch
            switch:
              - condition: '${{ .steps.loopStepAgain.loop.index >= 0 }}'
                next: break
          - name: insideLoopStepAgain
            type: action
            action: internal.example.sayHello
            version: '1'
            inputs:
              name: '${{ .steps.loopStepAgain.loop.element }}'
```

### データを使った条件付きロジック

```yaml
  steps:
    - name: checkCPU
      type: action
      action: newrelic.nerdgraph.execute
      version: 1
      # ... query configuration

    - name: decideAction
      type: switch
      switch:
        - condition: "${{ .steps.checkCPU.outputs.data.actor.account.nrql.results[0].average > 90 }}"
          next: resizeInstance
        - condition: "${{ .steps.checkCPU.outputs.data.actor.account.nrql.results[0].average > 70 }}"
          next: sendWarning
      next: normalOperation

    - name: resizeInstance
      type: action
      action: aws.ec2.modifyInstanceAttribute
      version: 1
      # ... resize configuration

    - name: sendWarning
      type: action
      action: slack.chat.postMessage
      version: 1
      # ... warning message

    - name: normalOperation
      type: action
      action: newrelic.ingest.sendLogs
      version: 1
      # ... log normal status
```

## 次のステップ

* **[トラブルシューティング](/docs/workflow-automation/troubleshooting)**: 資格情報エラー、統合の問題、ワークフローの失敗を修正します。
* **[ベストプラクティス](/docs/workflow-automation/limitations-and-faq/workflow-best-practices)**: エラー処理、パフォーマンスの最適化、テスト戦略。
* **[ワークフローの制限](/docs/workflow-automation/limitations-and-faq/workflow-limits)**: タイムアウト、レート制限、制約を理解します。