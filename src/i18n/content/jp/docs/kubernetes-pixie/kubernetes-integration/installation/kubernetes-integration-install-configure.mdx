---
title: Kubernetesインテグレーションのインストール
tags:
  - Integrations
  - Kubernetes integration
  - Installation
metaDescription: 'New Relic''s Kubernetes integration: How to install and activate the integration, and what data is reported.'
signupBanner: null
text: Monitor and improve your entire stack. 100GB free. Forever.
freshnessValidatedDate: never
translationType: human
---

import kubernetesAks from 'images/kubernetes_logo_aks.webp'

import kubernetesOpenshift from 'images/kubernetes_logo_openshift.webp'

import kubernetesCke from 'images/kubernetes_logo_cke.webp'

import kubernetesEks from 'images/kubernetes_logo_eks.webp'

import pixieLiveDebugging from 'images/pixie_screenshot-full_live-debugging.webp'

import pixieServiceOtelMap from 'images/pixie_screenshot-full_service-otel-map.webp'

import kubernetesFargateOverview from 'images/kubernetes_diagram_fargate-overview.svg'

import kubernetesFargateWorkflow from 'images/kubernetes_diagram_fargate-workflow.svg'

import kubernetesFargateUi from 'images/kubernetes_screenshot-crop_fargate-ui.webp'

New Relic Kubernetesインテグレーションにより、New Relic Infrastructureエージェントを活用して、環境の健全性とパフォーマンスのフルオブザーバビリティを実現します。このエージェントは、[Kubernetesイベントインテグレーション](/docs/integrations/kubernetes-integration/kubernetes-events/install-kubernetes-events-integration)、[Prometheusエージェント](/docs/infrastructure/prometheus-integrations/install-configure-prometheus-agent/install-prometheus-agent/)、[New RelicログKubernetesプラグイン](/docs/logs)など、いくつかのNew Relicインテグレーションを使用してクラスタからテレメトリーデータを収集します。

## インストールオプション

Kubernetesインテグレーションをインストールするには、こちらのガイド付きインストールの手順に従うことをお勧めします。サーバー、VM、[特権のない](/docs/infrastructure/install-infrastructure-agent/linux-installation/linux-agent-running-modes)環境には、このインタラクティブなインストールツールをお勧めします。

<Tabs>
  <TabsBar>
    <TabsBarItem id="guided-install">
      ガイド付きインストール（推奨）
    </TabsBarItem>

    <TabsBarItem id="windows-install">
      Windowsの場合
    </TabsBarItem>

    <TabsBarItem id="eks-fargate">
      EKS Fargateの場合
    </TabsBarItem>

    <TabsBarItem id="man-helm">
      手動によるHelm
    </TabsBarItem>

    <TabsBarItem id="gke-autopilot">
      GKE Autopilotで
    </TabsBarItem>
  </TabsBar>

  <TabsPages>
    <TabsPageItem id="guided-install">
      ガイド付きインストールエクスペリエンスでは、New Relic Kubernetesインテグレーションのインストールプロセスが簡素化され、有効にする機能や収集対象データの制御を行えるようになります。また、Kubernetesインテグレーションと並行して、事前に構築されたオプションのリソース（ダッシュボードやアラートなど）を含むクイックスタートオプションも用意しており、Kubernetesクラスタを即座に可視化できます。

      次の3つのオプションから1つを選択できます。

      1. New Relic CLI
      2. 必要な値が事前に入力されたHelmコマンド
      3. プレーンなマニフェスト

      ## Kubernetesインテグレーションガイド付きインストールのナビゲーション [#kubernetes-install-navigation]

      ガイド付きインストールを開始したら、以下の情報を使用して設定に関する意思決定を行います。

      <Callout variant="tip">
        以降の手順では、クイックスタートの準備手順をスキップします。クイックスタートによるガイド付きインストールを選択した場合は、<DoNotTranslate>**Confirm your Kubernetes quickstart installation**</DoNotTranslate>ページと<DoNotTranslate>**Installation plan**</DoNotTranslate>ページをクリックするだけで、以下に説明するメインのガイド付きインストールページにアクセスできます。
      </Callout>

      <Steps>
        <Step>
          ## インストールの準備

          ガイド付きインストール用にKubernetesシステムを準備します。

          * カスタムマニフェストがHelmの代わりに使用されている場合、まず`kubectl delete -f previous-manifest-file.yml`を使用して古いインストレーションを削除してから、ガイド付きインストーラを再度実行する必要があります。これにより、`kubectl apply -f manifest-file.yml`を使用してデプロイできる一連のマニフェストが更新されます。

          * 対応のKubernetesバージョンを使用していること、当社の[互換性と要件のページ](/docs/kubernetes-pixie/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements)に記載されたマネージドサービスまたはプラットフォームに関する事前の注意事項を必ず確認してください。

          * New Relic <InlinePopover type="licenseKey"/>を持っていることを確認してください。無料のアカウントを設定できます。クレジットカードは不要です。

          * newrelic dockerhub（`https://hub.docker.com/u/newrelic`）とGoogleのレジストリ（`registry.k8s.io`）ドメインが許可リストに追加されていることを確認してください。ここは、インストール時にコンテナイメージをプルする場所です。通常、`registry.k8s.io`はリージョンに応じてローカルレジストリドメイン（`asia-northeast1-docker.pkg.dev`など）にリダイレクトされるため、ホワイトリストに追加されるさらなるGoogleレジストリドメインを特定するには、[コマンド](https://kubernetes.io/blog/2023/03/10/image-registry-redirect/#how-can-i-check-if-i-am-impacted)に従う必要があります。

            マネージドクラウドにインテグレーションをインストールする場合は、先に進む前に、これらの[予備ノート](#cloud-platforms)を参照してください。

            <CollapserGroup>
              <Collapser
                className="freq-link"
                id="install-amazon-eks"
                title={<><img src={kubernetesEks} alt="EKS" style={{ verticalAlign: 'middle' }}/>Amazon EKS / EKS Anywhere / ベアメタル上のEKS Anywhere</>}
              >
                AmazonはKubernetesプラットフォームから離れたマスターノードの管理を抽象化するため、KubernetesインテグレーションではAmazon EKSへのワーカーノードのみを監視します。

                Amazon EKSでKubernetesインテグレーションをデプロイするためにガイド付きインストールを使用する前に、Amazon EKSでKubernetesクラスタを管理する[コマンドラインツール](https://docs.aws.amazon.com/eks/latest/userguide/eksctl.html)である`eksctl`をインストールしておいてください。
              </Collapser>

              <Collapser
                className="freq-link"
                id="install-google-kubernetes-engine"
                title={<><img src={kubernetesCke} alt="CKE" style={{ verticalAlign: 'middle' }}/>Google Kubernetes Engine（GKE Standard）</>}
              >
                GoogleはKubernetesプラットフォームから離れたマスターノードの管理を抽象化するため、KubernetesインテグレーションではGKEのワーカーノードのみを監視します。

                ガイド付きインストールを起動し、GKEにKubernetesインテグレーションをデプロイする前に、十分な権限があることを確認してください。

                1. [console.cloud.google.com/iam-admin/iam](https://console.cloud.google.com/iam-admin/iam)に移動し、ユーザー名を見つけます。

                2. <DoNotTranslate>**edit**</DoNotTranslate>

                   をクリックします。

                3. `Roles`および`ClusterRoles`を作成する権限があることを確認します。不確かな場合は、

                   <DoNotTranslate>**Kubernetes Engine Cluster Admin**</DoNotTranslate>

                   ロールを追加します。ユーザーロールを編集できない場合は、必要なパーミッションを付与してもらうようGCPプロジェクトのオーナーに依頼してください。
              </Collapser>

              <Collapser
                className="freq-link"
                id="install-openshift-container-platform"
                title={<><img src={kubernetesOpenshift} alt="OpenShift" style={{ verticalAlign: 'middle' }}/>OpenShiftコンテナプラットフォーム</>}
              >
                [OpenShift](https://learn.openshift.com)でKubernetesインテグレーションをデプロイするには、

                1. インテグレーションで使用されるサービスアカウントを、以下の特権がある[セキュリティコンテキスト制約](https://docs.openshift.com/enterprise/3.0/admin_guide/manage_scc.html)に追加します。

                   ```
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-newrelic-infrastructure
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-nrk8s-controlplane
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-kube-state-metrics
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-newrelic-logging
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-nri-kube-events
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-nri-metadata-injection-admission
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:<release_name>-nrk8s-controlplane
                   oc adm policy add-scc-to-user privileged system:serviceaccount:<namespace>:default
                   ```

                   <Callout variant="tip">
                     インストーラは`newrelic-bundle`（デフォルトの`release_name`として）、および`newrelic`（デフォルトの`namespace`として）を提供します。
                   </Callout>

                2. [ガイド付きインストール](https://one.newrelic.com/nr1-core?state=51fbbd48-c8ca-ead9-bb90-af96e18d82a7)の手順を完了します。

                3. 署名入りの証明書を使用している場合、マニフェスト内の`DaemonSet`部分で以下の変数を使用して、証明書が適切に設定されていることを確認します。`.pem`ファイルを設定します。

                   ```yaml
                   env:
                     - name: NRIA_CA_BUNDLE_DIR
                       value: YOUR_CA_BUNDLE_DIR
                     - name: NRIA_CA_BUNDLE_FILE
                       value: YOUR_CA_BUNDLE_NAME
                   ```

                4. YAMLキーパスを`spec.template.spec.containers.name.env`に設定します。

                5. 変更内容を保存します。
              </Collapser>

              <Collapser
                className="freq-link"
                id="install-azure-aks"
                title={<><img src={kubernetesAks} alt="AKS" style={{ verticalAlign: 'middle' }}/>Azure Kubernetes Service (AKS)</>}
              >
                AzureはKubernetesプラットフォームから離れたマスターノードの管理を抽象化するため、KubernetesインテグレーションではAzure Kubernetes Serviceのワーカーノードのみを監視します。
              </Collapser>
            </CollapserGroup>
        </Step>

        <Step>
          ## ガイド付きインストールの開始

          以下のオプションのいずれかをクリックして、ガイド付きインストールを開始します。

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  ガイド付きインストールオプション
                </th>

                <th>
                  説明
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  [ガイド付きインストール](https://onenr.io/0oR861DvMQG)
                </td>

                <td>
                  [EU](/docs/using-new-relic/welcome-new-relic/get-started/our-eu-us-region-data-centers)データセンターを使用して**いない**New Relic組織で、クイックスタートのボーナスダッシュボードやアラートを必要としない場合に使用します。
                </td>
              </tr>

              <tr>
                <td>
                  [ガイド付きインストール（EU）](https://onenr.io/0VwgOqNAZwJ)
                </td>

                <td>
                  [EU](/docs/using-new-relic/welcome-new-relic/get-started/our-eu-us-region-data-centers)データセンターを使用しているNew Relic組織で、クイックスタートのボーナスダッシュボードやアラートを必要としない場合に使用します。
                </td>
              </tr>

              <tr>
                <td>
                  [クイックスタートによるガイド付きインストール](https://one.newrelic.com/launcher/catalog-pack-details.launcher/?pane=eyJuZXJkbGV0SWQiOiJjYXRhbG9nLXBhY2stZGV0YWlscy5jYXRhbG9nLXBhY2stY29udGVudHMiLCJxdWlja3N0YXJ0SWQiOiI4OGE3OWY1Mi04MWMxLTRmYTItOTlmOC0zY2I1YjAxMmYxNjAifQ==)
                </td>

                <td>
                  [EU](/docs/using-new-relic/welcome-new-relic/get-started/our-eu-us-region-data-centers)データセンターを使用して**いない**New Relic組織で、クイックスタートのボーナスダッシュボードやアラートのインストールが必要な場合は、このオプションを使用します。
                </td>
              </tr>
            </tbody>
          </table>
        </Step>

        <Step>
          ## インストールの設定

          <DoNotTranslate>**Configure the Kubernetes Integration**</DoNotTranslate>ページで、次のフィールドに入力します。

          <table>
            <thead>
              <tr>
                <th style={{ width: "200px" }}>
                  フィールド
                </th>

                <th>
                  説明
                </th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>
                  お客様のデータをこのアカウントに送信します
                </td>

                <td>
                  Kubernetesデータを書き込むNew Relicアカウントを選択します。
                </td>
              </tr>

              <tr>
                <td>
                  クラスタ名
                </td>

                <td>
                  クラスタ名は、Kubernetesデータのタグ付けに使用する名前です。これにより、このインテグレーションをインストールするクラスタに固有のデータをフィルタリングできます。これは、複数のクラスタをNew Relicアカウントに接続する場合に重要なので、わかりやすい名前を選択してください。
                </td>
              </tr>

              <tr>
                <td>
                  インテグレーションのネームスペース
                </td>

                <td>
                  インテグレーションのネームスペースは、クラスタ内にKubernetesインテグレーションを格納するために使用するネームスペースです。`newrelic`のデフォルトのネームスペースを使用することをお勧めします。
                </td>
              </tr>
            </tbody>
          </table>
        </Step>

        <Step>
          ## 追加データの選択

          <DoNotTranslate>**Select the additional data you want to gather**</DoNotTranslate>ページで、適切なオプションを選択します。

          ### Prometheusエンドポイントをスクレイピング [#scrape-endpoints]

          このオプションを選択すると、Prometheusをエージェントモードでインストールし、クラスタで公開されているPrometheusエンドポイントからメトリクスを収集します。各オプションの詳細を表示するには、コラプサーを展開します。

          <CollapserGroup>
            <Collapser
              className="freq-link"
              id="scrape-all-except-ksm"
              title="コアのKubernetesシステムメトリクスを除くすべてのPrometheusエンドポイントをスクレイピング（推奨）"
            >
              [`kube-state-metrics`、`newrelic-infrastructure`、`nri-prometheus`](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle#bundled-charts)などのKubernetesインテグレーションの他のさまざまなコンポーネントがこれらのメトリクスをすでに収集しており、これらのメトリクスを除外するようにPrometheusを設定すると、メトリクスの冗長性が削除されてデータ取り込みコストを節約できるため、この設定を推奨します。

              この設定では、[`kube_`、`container_`、`machine_`、`cadvisor_`](https://github.com/newrelic/newrelic-prometheus-configurator/blob/64af9453f4b20d4aab88a4d1afda55cf9a6e63c4/charts/newrelic-prometheus-agent/static/lowdatamodedefaults.yaml)という接頭辞が付いたメトリクスが除外されます。

              `newrelic-prometheus-configurator/charts/newrelic-prometheus-agent/static/lowdatamodedefaults.yaml`の例を以下に示します。

              ```yaml
              low_data_mode:
              - action: drop
                source_labels: [__name__]
                regex: "kube_.+|container_.+|machine_.+|cadvisor_.+"
              ```
            </Collapser>

            <Collapser
              className="freq-link"
              id="scrape-all-endpoints"
              title="すべてのPrometheusエンドポイントをスクレイピング"
            >
              メトリクスの冗長性に関係なく、すべてのPrometheusメトリクスにわたってPrometheusのメトリクス命名規則を保存する場合は、<DoNotTranslate>**Scrape all Prometheus endpoints**</DoNotTranslate>を選択します。
            </Collapser>

            <Collapser
              className="freq-link"
              id="scrape-with-quickstarts"
              title="クイックスタートによるPrometheusエンドポイントのみをスクレイピング"
            >
              New Relicは、さまざまなサービスの予め作成されたダッシュボード、アラート、エンティティである[クイックスタート](https://newrelic.com/instant-observability/?category=prometheus&search=)を提供します。このオプションを選択すると、Prometheusで、[予め作成されたクイックスタート](https://github.com/newrelic/newrelic-prometheus-configurator/blob/main/charts/newrelic-prometheus-agent/values.yaml#L214-L228)があり、即時のオブザーバビリティを実行する準備ができているサービスのみをスクレイピングできます。

              以下は、Prometheusクイックスタートオプションでスクレイピングされるサービスを`app_values`フィールドに表示する`newrelic-prometheus-configurator/charts/newrelic-prometheus-agent/values.yaml`の例です。

              ```yaml
              kubernetes:
                  # NewRelic provides a list of Dashboards, alerts and entities for several Services. The integrations_filter configuration
                  # allows to scrape only the targets having this experience out of the box.
                  # If integrations_filter is enabled, then the jobs scrape merely the targets having one of the specified labels matching
                  # one of the values of app_values.
                  # Under the hood, a relabel_configs with 'action=keep' are generated, consider it in case any custom extra_relabel_config is needed.
                  integrations_filter:
                    # -- enabling the integration filters, merely the targets having one of the specified labels matching
                    #    one of the values of app_values are scraped. Each job configuration can override this default.
                    enabled: true
                    # -- source_labels used to fetch label values in the relabel config added by the integration filters configuration
                    source_labels: ["app.kubernetes.io/name", "app.newrelic.io/name", "k8s-app"]
                    # -- app_values used to create the regex used in the relabel config added by the integration filters configuration.
                    # Note that a single regex will be created from this list, example: '.*(?i)(app1|app2|app3).*'
                    app_values: ["redis", "traefik", "calico", "nginx", "coredns", "kube-dns", "etcd", "cockroachdb", "velero", "harbor", "argocd"]
              ```
            </Collapser>

            <Collapser
              className="freq-link"
              id="custom-app-labels"
              title="特定のラベルのみをスクレイピング"
            >
              このオプションは、Prometheusメトリクスを確認するサービスをよく理解している上級ユーザーにとって便利です。Prometheusでスクレイピングするサービスのコンマ区切りリストを入力すると、Prometheusはサービス名でワイルドカード一致を実行して、目的のエンドポイントからメトリクスを検索します。

              このオプションは、送信されたリストに一致するサービスのメトリクス_のみ_を提供するので、エントリが正しいかどうか検証するように注意してください。カスタムアプリラベルの詳細については、[Prometheusエージェントの詳細設定](/docs/infrastructure/prometheus-integrations/install-configure-prometheus-agent/advanced-configuration/#enable-disable-integrations)を参照してください。

              送信されたリストに追加するサービスは、以下の`app_values`のデータを上書きし、Prometheusはこれらのサービスから<DoNotTranslate>**only**</DoNotTranslate>メトリクスをスクレイピングします。

              `newrelic-prometheus-configurator/charts/newrelic-prometheus-agent/values.yaml`の例を以下に示します。

              ```yaml
              kubernetes:
                  # NewRelic provides a list of Dashboards, alerts and entities for several Services. The integrations_filter configuration
                  # allows to scrape only the targets having this experience out of the box.
                  # If integrations_filter is enabled, then the jobs scrape merely the targets having one of the specified labels matching
                  # one of the values of app_values.
                  # Under the hood, a relabel_configs with 'action=keep' are generated, consider it in case any custom extra_relabel_config is needed.
                  integrations_filter:
                    # -- enabling the integration filters, merely the targets having one of the specified labels matching
                    #    one of the values of app_values are scraped. Each job configuration can override this default.
                    enabled: true
                    # -- source_labels used to fetch label values in the relabel config added by the integration filters configuration
                    source_labels: ["app.kubernetes.io/name", "app.newrelic.io/name", "k8s-app"]
                    # -- app_values used to create the regex used in the relabel config added by the integration filters configuration.
                    # Note that a single regex will be created from this list, example: '.*(?i)(app1|app2|app3).*'
                    app_values: ["redis", "traefik", "calico", "nginx", "coredns", "kube-dns", "etcd", "cockroachdb", "velero", "harbor", "argocd"]
              ```
            </Collapser>
          </CollapserGroup>

          ### ログデータの収集 [#gather-logs]

          インストールUI内でログデータの詳細をカスタマイズできます。

          <CollapserGroup>
            <Collapser
              className="freq-link"
              id="full-enrichment"
              title="すべてのログをフルエンリッチメントで転送"
            >
              より堅牢なデータが必要な場合は、このオプションを選択すると、ラベルと注釈データを追加してログを完全に強化できます。

              以下は、完全なデータエンリッチメントを含むログの例です。

              ```json
              [
                {
                  "cluster_name": "api-test",
                  "kubernetes": {
                    "annotations": {
                      "kubernetes.io/psp": "eks.privileged"
                    },
                    "container_hash": "fryckbos/test@sha256:5b098eaf3c7d5b3585eb10cebee63665b6208bea31ef31a3f0856c5ffdda644b",
                    "container_image": "fryckbos/test:latest",
                    "container_name": "newrelic-logging",
                    "docker_id": "134e1daf63761baa15e035b08b7aea04518a0f0e50af4215131a50c6a379a072",
                    "host": "ip-192-168-17-123.ec2.internal",
                    "labels": {
                      "app": "newrelic-logging",
                      "app.kubernetes.io/name": "newrelic-logging",
                      "controller-revision-hash": "84db95db86",
                      "pod-template-generation": "1",
                      "release": "nri-bundle"
                    },
                    "namespace_name": "nrlogs",
                    "pod_id": "54556e3e-719c-46b5-af69-020b75d69bf1",
                    "pod_name": "nri-bundle-newrelic-logging-jxnbj"
                  },
                  "message": "[2021/09/14 12:30:49] [ info] [engine] started (pid=1)\n",
                  "plugin": {
                    "source": "kubernetes",
                    "type": "fluent-bit",
                    "version": "1.8.1"
                  },
                  "stream": "stderr",
                  "time": "2021-09-14T12:30:49.138824971Z",
                  "timestamp": 1631622649138
                }
              ]
              ```
            </Collapser>

            <Collapser
              className="freq-link"
              id="min-enrichment"
              title="エンリッチメントの最小化によるすべてのログの転送（低データモード）"
            >
              データ取り込みコストを優先したい場合は、エンリッチメントの最小化（低データモードとも呼ばれる）によるログデータの収集を選択できます。このオプションでは、ログからラベルと注釈が削除され、メッセージやタイムスタンプとともに、クラスタ、コンテナ、ネームスペース、ポッドの名前などの標準的なKubernetesログデータのみを共有します。

              エンリッチメントの最小化モードを選択すると、`cluster_name`、`container_name`、`namespace_name`、`pod_name`、`stream`、`message`および`log`のログ属性のみが保持されます。

              以下は、エンリッチメントの最小化データによるログの例です。

              ```json
              [
                {
                  "cluster_name": "api-test",
                  "container_name": "newrelic-logging",
                  "namespace_name": "nrlogs",
                  "pod_name": "nri-bundle-newrelic-logging-jxnbj",
                  "message": "[2021/09/14 12:30:49] [ info] [engine] started (pid=1)\n",
                  "stream": "stderr",
                  "timestamp": 1631622649138
                }
              ]
              ```
            </Collapser>
          </CollapserGroup>

          ### Pixieを通じてサービスレベルの洞察、フルボディのリクエスト、アプリケーションプロファイルを実現 [#enable-pixie]

          [Pixie](https://docs.px.dev/about-pixie/what-is-pixie/)は、eBPFを使用してテレメトリーデータを自動的に収集する、Kubernetesアプリケーション用のオープンソースオブザーバビリティツールです。クラスタにはPixieがインストールされていないものの、[New Relicプラットフォーム](/docs/kubernetes-pixie/auto-telemetry-pixie/get-started-auto-telemetry-pixie/)でPixieの強力なテレメトリーデータ収集と可視化を活用したい場合は、<DoNotTranslate>**Enable service-level insights, full-body requests, and application profiles through Pixie**</DoNotTranslate>をチェックしてください。

          すでにCommunity Cloudを使用している場合は、<DoNotTranslate>**Community Cloud hosted Pixie is already running on this cluster**</DoNotTranslate>を選択します。[Pixieでのさまざまなホスティング](https://docs.px.dev/installing-pixie/install-guides/#title)方法については、以下の点に留意してください。New Relicは、Pixieホスティングオプションごとに異なるレベルのインテグレーションをサポートします。

          <CollapserGroup>
            <Collapser
              className="freq-link"
              id="community-cloud-pixie"
              title="Community Cloud Pixie"
            >
              すでにPixieのCommunity Cloudを利用している場合は、PixieをNew Relicに接続するためのAPIキーを指定できます。このアプローチでは、PixieのライブUIをNew Relicアカウントに組み込み、（Pixieのライブデバッグツールから）簡単にアクセスできます。また、New Relic OpenTelemetryエンドポイントを通じてPixieデータをNew Relicに書き込みます。

              <img
                title="service graph in live debugger"
                alt="service-graph"
                src={pixieLiveDebugging}
              />
            </Collapser>

            <Collapser
              className="freq-link"
              id="self-hosted-pixie"
              title="自己ホスト型Pixie"
            >
              自己ホスト型Pixie CloudでPixieを使用している場合は、PixieをNew Relicに接続することもできます。このアプローチにより、OpenTelemetryエンドポイント経由でPixieテレメトリーデータをNew Relicにエクスポートし、長期的なデータ保持期間と可視化を実現します。残念ながら、Pixie Cloudを自己ホスティングしている場合、New RelicではPixieのライブUIの埋め込みをサポートしていません。

              Pixie Cloudを自己ホスティングしていて、New RelicへのPixieテレメトリーデータのエクスポートを有効にする場合は、<DoNotTranslate>**Community Cloud hosted Pixie option**</DoNotTranslate>をチェックせずに、KubernetesインテグレーションでPixieを有効にするだけです。Kubernetesインテグレーションは、Pixieがクラスタ内で実行されていることを検出し、データのエクスポートを有効にして、データを即座に可視化し、洞察を得ることができます。

              <img
                title="The OpenTelemetry <DoNotTranslate>**Service map**</DoNotTranslate> view shows helps visualize your application's dependencies."
                alt="The OpenTelemetry <DoNotTranslate>**Service map**</DoNotTranslate> view shows helps visualize your application's dependencies."
                src={pixieServiceOtelMap}
              />
            </Collapser>
          </CollapserGroup>
        </Step>

        <Step>
          ## インストールの完了

          ガイド付きインストールの最終手順で、次のインストール方法のいずれかを選択して、Kubernetesのインストール設定を確定します。

          * <DoNotTranslate>**Guided Install (recommended)**</DoNotTranslate>：このオプションは、[`newrelic-cli`](https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/) CLIを自動的にダウンロードして使用し、Kubernetesインテグレーションをインストールして設定します。

          * <DoNotTranslate>**Helm 3**</DoNotTranslate>：[Helm](https://helm.sh/)を使用してKubernetesインテグレーションをインストールして設定する場合は、このオプションを使用します。このオプションは[`nri-bundle`Helmチャート](/docs/kubernetes-pixie/kubernetes-integration/installation/install-kubernetes-integration-using-helm/#install-k8-helm)をインストールします。[ここで](/docs/kubernetes-pixie/kubernetes-integration/installation/install-kubernetes-integration-using-helm/#configure)説明するオプションを使用すると、さらに設定できます。

          * <DoNotTranslate>**Manifest**</DoNotTranslate>：Kubernetes マニフェストをYAML形式で生成し、[`kubectl`](https://kubernetes.io/docs/reference/kubectl/)を使用して手動でインストールする場合は、このオプションを選択します。

            <Callout variant="tip">
              データが表示されませんか？上記の手順を完了してもデータが表示されない場合は、[このトラブルシューティングページ](/docs/kubernetes-pixie/kubernetes-integration/troubleshooting/kubernetes-integration-troubleshooting-not-seeing-data/)を確認してください。
            </Callout>
        </Step>
      </Steps>
    </TabsPageItem>

    <TabsPageItem id="windows-install">
      WindowsベースのKubernetesシステムを使用している場合は、このオプションを使用してください。Windowsインテグレーションには[さまざまな制限](/docs/kubernetes-pixie/kubernetes-integration/installation/install-version2-kubernetes-integration-windows/#k8-windows-limitations)があります。

      <Callout title="プレビュー">
        この機能は現在プレビュー段階です。
      </Callout>

      ## 互換性および要件 [#k8-windows-req]

      [Kubernetesインテグレーション](/docs/integrations/kubernetes-integration/get-started/introduction-kubernetes-integration)をインストールする前に、[互換性と要件](/docs/integrations/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements)を確認してください。

      <Callout variant="important">
        Windowsでコンテナを使用する場合、コンテナホストのバージョンとコンテナイメージのバージョンが同じである必要があります。Kubernetesインテグレーションは、WindowsバージョンLTSC 2019（1809）、20H2、LTSC 2022で実行できます。
      </Callout>

      Windowsのバージョンを確認するには：

      1. コマンドウィンドウを開きます。
      2. 次のコマンドを実行します。

      ```shell
      Reg Query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v
      ReleaseIdcmd.exe
      ```

      ### 例：BusyBoxコンテナからWindows用Kubernetesを取得する [#example-k8s-windows-busybox]

      以下のコマンドを実行します。

      ```shell
      kubectl exec -it busybox1-766bb4d6cc-rmsnj -- Reg Query
      "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v ReleaseId
      ```

      次のように表示されます。

      ```shell
      HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion
      ReleaseId	REG_SZ	1809
      ```

      リリースIDとOSバージョン間の有用なマッピングについては、[こちら](https://hub.docker.com/_/microsoft-windows-servercore)を参照してください。

      ## インストール [#k8-windows-install]

      Helmを使用して、Windows用のKubernetesインテグレーションをインストールできます。Windowsの異なるビルドバージョン（1809と2004）を持つノードを含むクラスタに、インテグレーションをインストールする方法の例を参照してください。

      1. New Relic Helmチャートリポジトリを追加します。

         ```shell
         helm repo add newrelic https://helm-charts.newrelic.com
         ```

      2. newrelicの名前空間の作成：

         ```shell
         kubectl create namespace newrelic
         ```

      3. kube-state-metricsをインストールします。

         ```shell
         helm repo add ksm https://kubernetes.github.io/kube-state-metrics
         helm install ksm ksm/kube-state-metrics --version 2.13.2
         ```

         <Callout variant="important">
           このコマンドは、インテグレーションの必須の依存関係であるkube-state-metricsを、Linuxノードにインストールするためのものです。Linux以外のノードにインストールすることはサポートされていないため、Linux以外のノードにインストールすると、デプロイメントが失敗するおそれがあります。`nodeSelector`を使用して、Linuxノードを選択することをお勧めします。kube-state-metricsデプロイメントを編集することで、これを実行できます。
         </Callout>

      4. Helmで使用する次のデータを含む`values-newrelic.yaml`ファイルを作成します。

         ```yaml
         global:
           licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
           cluster: _K8S_CLUSTER_NAME_

         enableLinux: true        # Set to true if your cluster also has linux nodes
         enableWindows: true
         windowsOsList:
           - version: 2019            # Human-readable version identifier
             imageTag: 2-windows-1809-alpha  # Tag to be used for nodes running the windows version above
             buildNumber: 10.0.17763         # Build number for your nodes running the version above. Used as a selector.
           - version: 20h2
             imageTag: 2-windows-20H2-alpha
             buildNumber: 10.0.19042
           - version: 2022
             imageTag: 2-windows-ltsc2022-alpha
             buildNumber: 10.0.20348
         nodeSelector:
           kubernetes.io/os: linux         # Selector for Linux installation.
         windowsNodeSelector:
           kubernetes.io/os: windows       # Selector for Windows installation.
         ```

      5. 以下を使用してインテグレーションをインストールします。

         ```shell
         helm upgrade --install newrelic newrelic/newrelic-infrastructure \
         --namespace newrelic --create-namespace \
         --version 2.7.2 \
         -f values-newrelic.yaml
         ```

      6. ポッドがデプロイされ、安定した状態になっていることを確認します。

         ```shell
         kubectl -n newrelic get pods -w
         ```

      Helmチャートは、リストにあるWindowsの各バージョンに1つのDaemonSetを作成し、NodeSelectorを使用して各ノードに対応するポッドをデプロイします。

      ## 制限 [#k8-windows-limitations]

      Windows用Kubernetesインテグレーションには次の制限が適用されます。

      * Windowsエージェントは[Kubernetesサンプル](/docs/integrations/kubernetes-integration/understand-use-data/understand-use-data#event-types)（`K8sNodeSample` 、 `K8sPodSample`など）のみを送信します。

        * `SystemSample`、`StorageSample`、`NetworkSample`、および`ProcessSample`は生成されません。
        * Windows kubeletには[Kubernetesメトリクス](/docs/integrations/kubernetes-integration/understand-use-data/understand-use-data#metrics)がないため、一部のKubernetesメトリクスが欠落しています。

      * ノード：

        * `fsInodes`： 送信されません
        * `fsInodesFree`： 送信されません
        * `fsInodesUsed`： 送信されません
        * `memoryMajorPageFaultsPerSecond`: 値として常にゼロを返します
        * `memoryPageFaults`: 値として常にゼロを返します
        * `memoryRssBytes`: 値として常にゼロを返します
        * `runtimeInodes`： 送信されません
        * `runtimeInodesFree`： 送信されません
        * `runtimeInodesUsed`： 送信されません

      * ポッド：

        * `net.errorsPerSecond`： 送信されません
        * `net.rxBytesPerSecond`： 送信されません
        * `net.txBytesPerSecond`： 送信されません

      * コンテナ：

        * `containerID`： 送信されません
        * `containerImageID`： 送信されません
        * `memoryUsedBytes`：UIでは、これはポッドをクリックすると表示されるポッドカードに表示され、データは表示されません。代わりに`memoryWorkingSetBytes`を使用するようにチャートを更新することで、この問題はまもなく修正される予定です。

      * ボリューム：

        * `fsUsedBytes`: ゼロ、よって`fsUsedPercent`はゼロです

      ## Windows Kubeletでの既知の問題 [#k8-windows-limitations]

      KubeletのWindowsバージョンには、インテグレーションによるデータの取得を妨げる可能性がある問題がいくつかあります。

      * [問題 90554：](https://github.com/kubernetes/kubernetes/pull/90554)この問題により、インテグレーションが`/stats/summary`エンドポイントにリクエストを行うと、Kubeletが500エラーを返します。この問題はKubernetes 1.19リリースに含まれる予定で、リリース1.16.11、1.17.7、1.18.4にバックポートされています。この問題に対するインテグレーション側の解決策はありません。できるだけ早くいずれかのパッチバージョンに更新することをお勧めします。[詳細ログを有効にし](/docs/integrations/kubernetes-integration/troubleshooting/get-logs-version#verbose)、次のタイプのメッセージを検索すると、この問題の影響を受けているかどうかを確認できます。

      ```shell
      error querying Kubelet. Get "https://<KUBELET_IP>/stats/summary": error calling kubelet endpoint. Got status code: 500
      ```

      * [問題 87730：](https://github.com/kubernetes/kubernetes/pull/87730)この問題により、最小限の負荷で実行すると、Kubeletメトリクスが非常に遅くなります。タイムアウトエラーが発生して、インテグレーションが失敗します。この問題に対するパッチがKubernetes 1.18に追加され、1.15.12、1.16.9、1.17.5にバックポートされました。できるだけ早くいずれかのパッチバージョンに更新することをお勧めします。この問題を軽減するには、[`TIMEOUT`設定オプション](/docs/integrations/kubernetes-integration/installation/kubernetes-integration-install-configure#kube-state-metrics-timeout-change)を使用して、インテグレーションタイムアウトを増やすことができます。[詳細ログを有効にし](/docs/integrations/kubernetes-integration/troubleshooting/get-logs-version#verbose)、次のタイプのメッセージを検索すると、この問題の影響を受けているかどうかを確認できます。

      ```shell
      error querying Kubelet. Get "https://<KUBELET_IP>/stats/summary": context deadline exceeded (Client.Timeout exceeded while awaiting headers)
      ```
    </TabsPageItem>

    <TabsPageItem id="eks-fargate">
      EKS FargateでKubernetesワークロードをモニタリングする場合は、このオプションを使用します。このインテグレーションでは、モニタリングが必要な各ポッドにInfrastructureエージェントとnri-kubernetesインテグレーションを含むサイドカーが自動的に挿入されます。

      <Callout title="プレビュー">
        この機能は現在プレビュー段階です。
      </Callout>

      New Relicは、モニタリングが必要な各ポッドにインフラストラクチャエージェントと、`nri-kubernetes`インテグレーションを含むサイドカーを自動挿入することで、EKS FargateでのKubernetesワークロードのモニタリングをサポートします。

      同じKubernetesクラスタにEC2ノードも含まれている場合、ソリューションがすべてのノードに`DaemonSet`としてデプロイされます。EC2ノードでスケジュールされたポッドにサイドカーが挿入されることはなく、 `DaemonSet`がFargateノードにデプロイされることもありません。以下に、FargateノードとEC2ノードの両方を含むハイブリッドインスタンスの例を示します。

      <img
        title="Diagram showing an EKS cluster with Fargate and EC2 nodes"
        alt="Diagram showing an EKS cluster with Fargate and EC2 nodes"
        src={kubernetesFargateOverview}
      />

      <figcaption>
        混合環境のインテグレーションでは、Fargateノードのサイドカーのみが使用されます。
      </figcaption>

      スケジュールされている場所やFargateノード、EC2ノードかに関係なく、New RelicはすべてのKubernetesオブジェクトでサポートされているすべてのメトリクスを収集します。Fargateによって課された制限により、New RelicインテグレーションはFargateノード上の[非特権](/docs/integrations/kubernetes-integration/installation/kubernetes-integration-install-configure/#unprivileged)モードでの実行に限定されます。つまり、実行中のプロセスなど、通常はホストから直接取得されるメトリクスがFargateノードでは利用できません。

      どちらのシナリオでも、エージェントはKube State Metrics（KSM）、Kubelet、cAdvisorからデータを収集し、データを同じ形式で送信します。

      <Callout variant="important">
        他のKubernetesクラスタと同様に、このソリューションでもKube State Metrics（KSM）インスタンスをデプロイして監視する必要があります。Helmチャートやインストーラーはデフォルトで自動的にこれを行いますが、クラスタにKSMの動作インスタンスがすでにある場合は、この動作を無効にすることができます。このKSMインスタンスは、他のワークロードと同様に監視されます。Fargateノードでスケジュールされた場合はサイドカーを挿入し、EC2ノードでスケジュールされた場合は`DaemonSet`のローカルインスタンスを挿入します。
      </Callout>

      Kubernetes用New Relicソリューションの他のコンポーネント（`nri-prometheus`、`nri-metadata-injection` 、 `nri-kube-events`など）には特別な特徴はなく、Fargate以外の環境と同様に、Helmチャートによって通常どおりデプロイされます。

      ## インストレーション [#installation]

      EKS FargateクラスタにNew Relicの完全なオブザーバビリティをインストールするには、次の2つの選択肢から選択できます。

      * [自動インジェクション（推奨）](#automatic)
      * [手動インジェクション](#manual)

      どちらのアプローチを選択しても、インストール後のエクスペリエンスはまったく同じです。唯一の違いは、コンテナの注入方法です。New Relicのインフラストラクチャモニタリングオペレーターを使用して、自動インジェクションを設定することをお勧めします。これにより、監視する各デプロイメントを手動で編集する必要がなくなります。

      ### 自動インジェクション（推奨） [#automatic]

      デフォルトでは、Fargateサポートが有効になっている場合、New Relicはオペレーターをクラスタ（`newrelic-infra-operator`）にデプロイします。デプロイが完了すると、このオペレーターはFargateノードにスケジュールされているポッドにモニタリングサイドカーを自動挿入し、同時に`Secrets`、`ClusterRoleBindings`、およびその他の関連リソースの作成と更新も管理します。

      このオペレーターは、ポッドと名前空間の両方のラベルセレクターを使用して、インジェクションの範囲を狭めたり広げたりできる、多数の高度な設定オプションを受け入れます。

      #### オペレーターが行うこと [#what-operator-does]

      オペレーターはバックグラウンドで`MutatingWebhookConfiguration`を設定し、クラスタ内に作成されるポッドオブジェクトを変更できるようにします。このイベントで、作成中のポッドがユーザーの設定と一致する場合、オペレーターは次のことを行います。

      1. New Relic Kubernetesインテグレーションを含むポッドにサイドカーコンテナを追加します。

      2. シークレットが存在しない場合は、サイドカーがデータを報告するために必要なNew Relic

         <InlinePopover type="licenseKey"/>

         を含む、ポッドと同じ名前空間にシークレットを作成します。

      3. ポッドのサービスアカウントを、オペレーターチャートが以前作成した`ClusterRoleBinding`に追加します。これにより、このサイドカーにKubernetesメトリクスエンドポイントにアクセスするために必要な権限が付与されます。

      `ClusterRoleBinding`は、挿入されるポッドに次の権限を付与します。

      ```yml

      rules:
      - apiGroups: [""]
        resources:
        - "nodes"
        - "nodes/metrics"
        - "nodes/stats"
        - "nodes/proxy"
        - "pods"
        - "services"
        - "namespaces"
        verbs: ["get", "list"]
      - nonResourceURLs: ["/metrics"]
        verbs: ["get"]

      ```

      <Callout variant="tip">
        サイドカーを挿入し、オペレーターがインストールされる前にデプロイされたポッドからメトリクスを取得するには、影響を受けるデプロイメントのロールアウト（再起動）を手動で実行する必要があります。こうすることで、ポッドの作成時に、オペレーターはモニタリングサイドカーを注入できるようになります。New Relicは、予期しないサービスの中断やリソース使用量の急増を防ぐために、これを自動的に行いません。
      </Callout>

      <Callout variant="important">
        `newrelic`名前空間（またはインストール用に選択した名前空間）を宣言するセレクターを使用して、Fargateプロファイルを作成してください。
      </Callout>

      以下に、インジェクションワークフローを示します。

      <img
        title="Diagram showing the workflow of sidecar injection"
        alt="Diagram showing the workflow of sidecar injection"
        src={kubernetesFargateWorkflow}
      />

      #### 自動インジェクションインストール [#auto-injection-install]

      <Callout variant="tip">
        次の手順はデフォルト設定の場合です。これらを完了する前に、以下の[設定](#config-auto)セクションを参照して、自動インジェクションの側面を変更するかどうかを確認してください。
      </Callout>

      まず、New Relic Helmリポジトリをまだ追加していない場合は追加します。

      ```shell
      helm repo add newrelic https://helm-charts.newrelic.com
      ```

      次に、インフラストラクチャサイドカーの注入を担当するオペレーターをインストールするために、設定の定義に使用する`values.yaml`という名前のファイルを作成してください。

      ```yaml
      ## Global values
      global:
        # -- The cluster name for the Kubernetes cluster.
        cluster: "_YOUR_K8S_CLUSTER_NAME_"

        # -- The license key for your New Relic Account. This will be preferred configuration option if both `licenseKey` and `customSecret` are specified.
        licenseKey: "_YOUR_NEW_RELIC_LICENSE_KEY_"

        # -- (bool) In each integration it has different behavior. Enables operating system metric collection on each EC2 K8s node. Not applicable to Fargate nodes.
        # @default -- false
        privileged: true

        # -- (bool) Must be set to `true` when deploying in an EKS Fargate environment
        # @default -- false
        fargate: true

      ## Enable nri-bundle sub-charts

      newrelic-infra-operator:
        # Deploys the infrastructure operator, which injects the monitoring sidecar into Fargate pods
        enabled: true
        tolerations: 
        - key: "eks.amazonaws.com/compute-type"
          operator: "Equal"
          value: "fargate"
          effect: "NoSchedule"
        config:
          ignoreMutationErrors: true
          infraAgentInjection:
            # Injection policies can be defined here.  See [values file](https://github.com/newrelic/newrelic-infra-operator/blob/main/charts/newrelic-infra-operator/values.yaml#L114-L125) for more detail.
            policies:
            - namespaceName: namespace-a
            - namespaceName: namespace-b

      newrelic-infrastructure:
        # Deploys the Infrastructure Daemonset to EC2 nodes.  Disable for Fargate-only clusters.
        enabled: true

      nri-metadata-injection:
        # Deploy our mutating admission webhook to link APM and Kubernetes entities
        enabled: true

      kube-state-metrics:
        # Deploys Kube State Metrics.  Disable if you are already running KSM in your cluster.
        enabled: true

      nri-kube-events:
        # Deploy the Kubernetes events integration.
        enabled: true

      newrelic-logging:
        # Deploys the New Relic's Fluent Bit daemonset to EC2 nodes.  Disable for Fargate-only clusters.
        enabled: true

      newrelic-prometheus-agent:
        # Deploys the Prometheus agent for scraping Prometheus endpoints.
        enabled: true
        config:
          kubernetes:
            integrations_filter:
              enabled: true
              source_labels: ["app.kubernetes.io/name", "app.newrelic.io/name", "k8s-app"]
              app_values: ["redis", "traefik", "calico", "nginx", "coredns", "kube-dns", "etcd", "cockroachdb", "velero", "harbor", "argocd", "istio"]
      ```

      最後に、ファイルを作成して調整した後、次のHelmコマンドを使用してソリューションをデプロイできます。

      ```shell
      helm upgrade --install newrelic-bundle newrelic/nri-bundle -n newrelic --create-namespace -f values.yaml
      ```

      <Callout variant="important">
        ハイブリッドクラスタ（EC2ノードとFargateノードの両方を含む）にソリューションをデプロイする場合は、ソリューションがFargateプロファイルにより選択されていないことを確認してください。選択されていると、`DaemonSet`インスタンスは保留状態のままになります。Fargateのみの環境の場合、`DaemonSet`インスタンスは作成されないため問題ありません。
      </Callout>

      #### 設定 [#config-auto]

      自動インジェクションのさまざまな側面を設定できます。デフォルトでは、オペレーターは`Job`、または`BatchJob`の一部ではないFargateノードにデプロイされたすべてのポッドにモニタリングサイドカーを注入します。

      この動作は設定オプションから変更できます。たとえば、セレクターを定義して、注入されるポッドの選択を狭めたり広げたり、オペレーターにリソースを割り当てたり、サイドカーを調整したりできます。また、他の属性、ラベル、環境変数を追加することもできます。チャートの[README.md](https://github.com/newrelic/helm-charts/blob/master/charts/newrelic-infra-operator/README.md)および[values.yaml](https://github.com/newrelic/helm-charts/blob/master/charts/newrelic-infra-operator/values.yaml)を参照してください。

      <Callout variant="important">
        独自のカスタムインジェクションルールを指定すると、Fargateでスケジュールされていないポッドへのサイドカーインジェクションを防止するデフォルトのルールセットが破棄されます。カスタムルールでも同じように機能することを確認してください。`DaemonSet`もデプロイされているハイブリッドクラスタ上で、EC2でスケジュールされたポッドが2回監視されることになり、データが不正確だったり重複したりします。
      </Callout>

      #### 最新バージョンまたは新しい設定への更新 [#update-auto-install-version]

      EKS Fargateインテグレーションの最新バージョンに更新するには、`helm repo update newrelic`を使用してHelmリポジトリをアップグレードし、上記のコマンドを再度実行するだけでバンドルを再インストールします。

      挿入されたインフラストラクチャエージェントまたはオペレーター自体の設定を更新するには、`values-newrelic.yaml`を変更し、新しい設定でHelmリリースをアップグレードします。オペレーターはすぐに更新され、次回の再起動時にワークロードに新しいバージョンが組み込まれます。直ちにアップグレードしたい場合は、以下を実行してワークロードを強制的に再起動できます。

      ```shell
      kubectl rollout restart deployment YOUR_APP
      ```

      #### Fargateインテグレーションのアンインストール [#uninstall-auto-injection]

      自動インジェクションを実行しているサイドカーをアンインストールし、残りのNew Relicソリューションを保持するには、Helmを使用して、`values.yaml`ファイル、またはコマンドラインで`infra-operator.enabled`を`false`に設定して、インフラオペレーターを無効にします。（`--set`）を指定し、上記のインストールコマンドを再実行します。

      `--set global.fargate=true`フラグを保持することを強く推奨します。これを行うと、自動インジェクションは有効になりませんが、他のインストールコンポーネントがFargateを認識し、不要な動作が防止されます。

      ソリューション全体をアンインストールするには：

      1. Helmリリースを完全にアンインストールします。
      2. サイドカーを削除するには、ポッドをロールアウトします。

      ```shell
      kubectl rollout restart deployment YOUR_APP
      ```

      3. ガベージコレクションのシークレット：

      ```shell
      kubectl delete secrets -n YOUR_NAMESPACE -l newrelic/infra-operator-created=true
      ```

      #### 既知の制限：自動インジェクション [#known-limitations]

      自動インジェクションを使用する際に注意すべき問題がいくつかあります。

      1. 現在、クラスタ全体を監視して、不要になったシークレットがガベージコレクションの対象になっていることを確認するコントローラーはありません。ただし、すべてのオブジェクトは、必要に応じてすべてのリソースの削除に使用できる同じラベルを共有します。ラベル`newrelic/infra-operator-created: true`を挿入します。これを使用すると、1 つのコマンドでリソースを削除できます。
      2. 現時点では、注入されたサイドカーを使用してポッド内で実行されているサービスを監視することはできません。サイドカーはKubernetes自体のみを監視します。ただし、上級ユーザーは、これらのポッドを自動インジェクションから除外し、サイドカーを設定し適切な場所にその設定をマウントすることで、オンホストインテグレーションが有効になっている、カスタマイズバージョンのサイドカーを手動で注入することもできます。ヘルプについては、この[チュートリアル](/docs/integrations/kubernetes-integration/link-apps-services/tutorial-monitor-redis-running-kubernetes/)を参照してください。

      ### 手動インジェクション [#manual]

      自動インジェクションについて懸念がある場合は、Fargateノード上でスケジュールされるワークロードのマニフェストを変更すると、サイドカーを手動で直接注入できます。EC2ノードにスケジュールされたデプロイメントにサイドカーを追加すると、特に`DaemonSet`でそれらのノードがすでに監視されている場合、データが不正確だったり重複したりすることがあります。

      サイドカーがデータを正常に報告するには、次のオブジェクトが必要です。

      * `ClusterRole`は、 `nri-kubernetes`インテグレーションに必要な権限を提供します。
      * `ClusterRole`とポッドのサービスアカウントをリンクする`ClusterRoleBinding`
      * Fargateの各名前空間に New Relic `licenseKey`を保存するシークレット
      * 監視対象のワークロードの仕様テンプレート内のサイドカーコンテナ

      #### 手動インジェクションインストール [#manual-injection-install]

      <Callout variant="tip">
        これらの手動設定手順は、一般的なインストール用です。これらを完了する前に、以下の[設定](#config-manual)セクションを参照して、自動インジェクションの側面を変更するかどうかを確認してください。
      </Callout>

      手動インジェクションの場合は、次の手順を実行します。

      1. `ClusterRole`が存在しない場合は、を作成し、メトリックエンドポイントに到達するために必要な権限を付与します。 同じクラスター内の複数のアプリケーションを監視する場合でも、これは1回だけ実行する必要があります。

      <CollapserGroup>
        <Collapser
          id="cluster-role"
          title="ClusterRole"
        >
          以下に示すように、このスニペットは何も変更せずに使用できます。

          ```yml
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRole
          metadata:
            labels:
              app: newrelic-infrastructure
            name: newrelic-newrelic-infrastructure-infra-agent
          rules:
          - apiGroups:
            - ""
            resources:
            - nodes
            - nodes/metrics
            - nodes/stats
            - nodes/proxy
            - pods
            - services
            verbs:
            - get
            - list
          - nonResourceURLs:
            - /metrics
            verbs:
            - get
          ```
        </Collapser>
      </CollapserGroup>

      2. 監視するワークロードごとに、`newrelic/infrastructure-k8s`イメージのサイドカーコンテナを追加します。以下は、注入されたサイドカーの例です。

      <CollapserGroup>
        <Collapser
          id="container-to-inject"
          title="ContainerToInject"
        >
          次のスニペットのコンテナを取得し、それを監視するワークロードに挿入し、 `customAttributes`変数に`FargateProfile`の名前を指定します。ボリュームは`emptyDir: {}`として定義できることに注意してください。

          <Callout variant="tip">
            KSMデプロイの特殊なケースでは、`DISABLE_KUBE_STATE_METRICS`環境変数を削除し、リソースのリクエストと制限を増やす必要もあります。
          </Callout>

          ```yml
          apiVersion: apps/v1
          kind: Deployment
          spec:
          template:
          spec:
          containers:
          - name: newrelic-infrastructure
            env:
            - name: NRIA_LICENSE_KEY
              valueFrom:
                secretKeyRef:
                  key: license
                  name: newrelic-newrelic-infrastructure-config
            - name: NRIA_VERBOSE
              value: "1"
            - name: DISABLE_KUBE_STATE_METRICS
              value: "true"
            - name: CLUSTER_NAME
              value: testing-injection
            - name: COMPUTE_TYPE
              value: serverless
            - name: NRK8S_NODE_NAME
              valueFrom:
                fieldRef:
                  apiVersion: v1
                  fieldPath: spec.nodeName
            - name: NRIA_DISPLAY_NAME
              valueFrom:
                fieldRef:
                  apiVersion: v1
                  fieldPath: spec.nodeName
            - name: NRIA_CUSTOM_ATTRIBUTES
              value: '{"clusterName":"$(CLUSTER_NAME)", "computeType":"$(COMPUTE_TYPE)", "fargateProfile":"[YOUR FARGATE PROFILE]"}'
            - name: NRIA_PASSTHROUGH_ENVIRONMENT
              value: KUBERNETES_SERVICE_HOST,KUBERNETES_SERVICE_PORT,CLUSTER_NAME,CADVISOR_PORT,NRK8S_NODE_NAME,KUBE_STATE_METRICS_URL,KUBE_STATE_METRICS_POD_LABEL,TIMEOUT,ETCD_TLS_SECRET_NAME,ETCD_TLS_SECRET_NAMESPACE,API_SERVER_SECURE_PORT,KUBE_STATE_METRICS_SCHEME,KUBE_STATE_METRICS_PORT,SCHEDULER_ENDPOINT_URL,ETCD_ENDPOINT_URL,CONTROLLER_MANAGER_ENDPOINT_URL,API_SERVER_ENDPOINT_URL,DISABLE_KUBE_STATE_METRICS,DISCOVERY_CACHE_TTL
            image: newrelic/infrastructure-k8s:2.4.0-unprivileged
            imagePullPolicy: IfNotPresent
            resources:
              limits:
                memory: 100M
                cpu: 200m
              requests:
                cpu: 100m
                memory: 50M
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              runAsUser: 1000
            terminationMessagePath: /dev/termination-log
            terminationMessagePolicy: File
            volumeMounts:
            - mountPath: /var/db/newrelic-infra/data
              name: tmpfs-data
            - mountPath: /var/db/newrelic-infra/user_data
              name: tmpfs-user-data
            - mountPath: /tmp
              name: tmpfs-tmp
            - mountPath: /var/cache/nr-kubernetes
              name: tmpfs-cache
          [...]
          ```
        </Collapser>
      </CollapserGroup>

      3. `ClusterRoleBinding`を作成するか、以前に作成したものに監視対象アプリケーションの`ServiceAccount`を追加します。すべてのワークロードは同じ`ClusterRoleBinding`を共有できますが、各ワークロードの`ServiceAccount`をそれに追加する必要があります。

      <CollapserGroup>
        <Collapser
          id="cluster-role-binding"
          title="ClusterRoleBinding"
        >
          監視するポッドのサービスアカウントをサブジェクトとして持つ、次の`ClusterRoleBinding`を作成します。

          <Callout variant="tip">
            同じサービスアカウントを2回繰り返す必要はありません。まだ含まれていないサービスアカウントでポッドを監視する場合は、その都度サービスアカウントをリストに追加するだけです。
          </Callout>

          ```yml
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: newrelic-newrelic-infrastructure-infra-agent
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: newrelic-newrelic-infrastructure-infra-agent
          subjects:
          - kind: ServiceAccount
            name: [INSERT_SERVICE_ACCOUNT_NAME_OF_WORKLOAD]
            namespace: [INSERT_SERVICE_ACCOUNT_NAMESPACE_OF_WORKLOAD]
          ```
        </Collapser>
      </CollapserGroup>

      4. New Relic

         <InlinePopover type="licenseKey"/>

         を含むシークレットを作成します。各名前空間には独自のシークレットが必要です。

      <CollapserGroup>
        <Collapser
          id="secret"
          title="シークレット"
        >
          <InlinePopover type="licenseKey"/>のBase64エンコード値を含むライセンスを持つ次の`Secret`を作成します。監視するポッドが実行されている名前空間ごとに1つのシークレットが必要です。

          ```yml
          apiVersion: v1
          data:
            license: INSERT_YOUR_NEW_RELIC_LICENSE_ENCODED_IN_BASE64
            kind: Secret
          metadata:
            name: newrelic-newrelic-infrastructure-config
            namespace: [INSERT_NAMESPACE_OF_WORKLOAD]
            type: Opaque
          ```
        </Collapser>
      </CollapserGroup>

      #### 設定 [#config-manual]

      サイドカーエージェントのマニフェストを手動で追加する場合、任意のエージェント設定オプションを使用すると、エージェントの動作を設定できます。ヘルプについては、[インフラストラクチャエージェントの構成設定](/docs/infrastructure/install-infrastructure-agent/configuration/infrastructure-agent-configuration-settings/)を参照してください。

      #### 最新バージョンにアップデート [#manual-update-version]

      いずれかのコンポーネントを更新するには、デプロイされたyamlを変更するだけです。

      注入されたコンテナのいずれかのフィールドを更新すると、ポッドが再作成されます。

      <Callout variant="important">
        エージェントはNew Relic <InlinePopover type="licenseKey"/>をホットロードできません。シークレットを更新した後、デプロイメントを再度ロールアウトする必要があります。
      </Callout>

      #### Fargateインテグレーションのアンインストール [#manual-uninstall]

      挿入されたコンテナと関連リソースを削除するには、以下を削除するだけです。

      * 監視が不要なワークロードのサイドカー。
      * newrelicライセンスを含むすべてのシークレット。
      * `ClusterRole` `ClusterRoleBinding`個のオブジェクト。

      サイドカーコンテナを削除すると、ポッドが再作成されることに注意してください。

      ## ロギング [#fargate-logging]

      New Relicのログ記録は、AWSによって課されたセキュリティ制約のため、Fargateノードでは利用できませんが、以下にいくつかのログ記録オプションを示します。

      * ログ記録にFluentbitを使用している場合は、[ログ転送用のKubernetesプラグイン](/docs/logs/forward-logs/kubernetes-plugin-log-forwarding/)を参照してください。
      * ログデータがすでにAWS FireLensによって監視されている場合は、[ログ転送用のAWS FireLensプラグイン](/docs/logs/forward-logs/aws-firelens-plugin-log-forwarding/)を参照してください。
      * ログデータがすでにAmazon CloudWatch Logsによって監視されている場合は、[Kinesis Data Firehoseを使用したログのストリーミング](/docs/logs/forward-logs/stream-logs-using-kinesis-data-firehose/)を参照してください。
      * [CloudWatchログ送信用のAWS Lambda](/docs/logs/forward-logs/aws-lambda-sending-cloudwatch-logs/)を参照してください。
      * [Amazon ECSからNew Relicにログを転送する3つの方法](https://newrelic.com/blog/how-to-relic/forward-logs-from-amazon-ecs-to-new-relic)を参照してください。

      ## トラブルシューティング [#troubleshooting]

      ### DaemonSetレプリカがFargateノードにデプロイされている

      インフラ`DaemonSet`レプリカがFargateノードでスケジュールされている場合は、`nodeAffinity`ルールが適切に設定されていないことが原因である可能性があります。

      コマンドライン（`--set global.fargate=true`）または`values.yaml`ファイルのいずれかで、ソリューションが`true`に`global.fargate`オプションを指定してインストールされていることを再確認します。インストール方法がHelmではなかった場合は、Fargateノードを除外する`nodeAffinity`ルールを手動で追加する必要があります。

      ### 許容できない感染によるイベント`FailedScheduling`

      ポッドの作成中に次のイベントが発生した場合は、[自動インジェクションのインストール](#auto-injection-install)で説明されている`tolerations`を、`values.yaml`ファイルに必ず追加してください。

      ```
      LAST SEEN | TYPE | REASON | OBJECT | MESSAGE
      :--|:--|:--|:--|:--
      3m9s (x2 over 8m10s) | Warning | FailedScheduling | Pod/no-fargate-deploy-cbddd6ccf-8f9x4 | 0/2 nodes are available: 2 node(s) had untolerated taint {eks.amazonaws.com/compute-type: fargate}. preemption: 0/2 nodes are available: 2 Preemption is not helpful for scheduling..
      ```

      ### ポッドが多すぎることによるイベント`FailedScheduling`

      ポッドの作成中に次のイベントが発生した場合は、インストールが行われる名前空間を指定するセレクターを含む、Fargateプロファイルがあるかどうかを確認してください。

      ```
      LAST SEEN | TYPE | REASON | OBJECT | MESSAGE
      :--|:--|:--|:--|:--
      61s | Warning | FailedScheduling | Pod/newrelic-bundle-newrelic-infra-operator-admission-create-d8ggt | 0/2 nodes are available: 2 Too many pods. preemption: 0/2 nodes are available: 2 No preemption victims found for incoming pod..
      ```

      ## EKSデータの表示 [#view-data]

      以下に、New Relic UIでのFargateノードの外観の例を示します。

      <img
        title="Screenshot showing the Kubernetes explorer with a Fargate node"
        alt="Screenshot showing the Kubernetes explorer with a Fargate node"
        src={kubernetesFargateUi}
      />

      AWSデータを表示するには：

      1. <DoNotTranslate>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Infrastructure > Kubernetes**</DoNotTranslate>

         に移動し、次のうち1つを行います。

      * インテグレーション名を選択してデータを表示します。
      * \[データを探索]アイコンを選択して、AWSデータを表示します。

      2. 2つのFargateタグを使用してデータをフィルタリングします。

      * `computeType=serverless`
      * `fargateProfile=[name of the Fargate profile to which the workload belongs]`
    </TabsPageItem>

    <TabsPageItem id="man-helm">
      Helmを使用してインテグレーションをインストールする場合は、2つのオプションがあります。

      1. ガイド付きインストールエクスペリエンス。これは、必要なフィールドが事前に入力されたHelmコマンドを提供します。このオプションでは、Helmリリースではなく、プレーンマニフェストとしてインテグレーションをインストールすることもできます。
      2. `values.yaml`ファイルによる手動設定。このタブでは、その方法について説明します。

      [Helm](https://helm.sh/)は、Kubernetes上のパッケージマネージャーです。これにより、インストール、アップグレード、リビジョン追跡が容易になり、Kubernetesにインストールするサービスの依存関係が管理されます。まだ作成されていない場合は、無料のNew Relicアカウントを以下で作成し、今すぐデータの監視を開始してください。

      <ButtonLink
        role="button"
        to="https://onenr.io/0Y8wpoYJJQO"
        variant="primary"
      >
        インストーラの起動
      </ButtonLink>

      ## 互換性および要件 [#compatibility]

      [Helm](https://github.com/helm/helm#install)がマシンにインストールされていることを確認してください。Kubernetesインテグレーションのバージョン3には、Helmバージョン3が必要です。

      Helmを使用してKubernetesインテグレーションをインストールするには、New Relic <InlinePopover type="licenseKey"/>とKubernetesクラスタの名前が必要です。

      1. <InlinePopover type="licenseKey"/>を見つけてコピーします。

      2. クラスタの表示名を選択します。たとえば、次の出力を使用できます。

         ```shell
         kubectl config current-context
         ```

      <Callout variant="important">
        これらの値は、後でインストールプロセス中に必要になるため、安全な場所に保管してください。
      </Callout>

      ## Helmを使用したKubernetesインテグレーションのインストール [#install-k8-helm]

      New Relicでは、プラットフォームにさまざまな機能を提供する、さまざまなコンポーネント用のHelmチャートをいくつか用意しています。

      * [`newrelic-infrastructure`](https://github.com/newrelic/nri-kubernetes/tree/main/charts/newrelic-infrastructure)：メインの Kubernetesインテグレーションとインフラストラクチャエージェントが含まれます。これはNew Relic Kubernetesエクスペリエンスのコアコンポーネントで、Kubernetesダッシュボードと、Kubernetesクラスタエクスプローラーに表示されるほとんどのデータをレポートする役割を果たします。
      * [`newrelic-logging`](https://github.com/newrelic/helm-charts/tree/master/charts/newrelic-logging)：New Relicの[Fluent Bit](https://fluentbit.io/)出力[プラグイン](https://github.com/newrelic/newrelic-fluent-bit-output)を備えたDaemonSetを提供し、ログを[New Relic](/docs/logs/new-relic-logs/get-started/introduction-new-relic-logs)に簡単に転送します。
      * [`nri-kube-events`](https://github.com/newrelic/nri-kube-events/tree/main/charts/nri-kube-events)：クラスタイベント（`kubectl get events`など）を収集して、New Relicに報告します。
      * [`newrelic-prometheus-agent`](https://github.com/newrelic/newrelic-prometheus-configurator/tree/main/charts/newrelic-prometheus-agent)：New RelicのPrometheus Configuratorは、[エージェントモードでPrometheus](/docs/infrastructure/prometheus-integrations/install-configure-prometheus-agent/install-prometheus-agent)を設定し、リモート書き込みエンドポイントを使用して[メトリクスをNew Relic に報告します](/docs/infrastructure/prometheus-integrations/get-started/send-prometheus-metric-data-new-relic/#remote-write)。
      * [`nri-metadata-injection`](https://github.com/newrelic/k8s-metadata-injection/tree/main/charts/nri-metadata-injection)：コンテナにいくつかの環境変数を挿入する、最小限の`MutatingAdmissionWebhook`を設定します。これらにはクラスタとNew Relicのインストールに関するメタデータが含まれており、後でAPMを使用してインストゥルメントされたアプリケーションにより取得され、[APMとインフラストラクチャデータを関連付ける](/docs/integrations/kubernetes-integration/link-your-applications/link-your-applications-kubernetes/)ことができます。
      * [`nri-statsd`](https://github.com/newrelic/helm-charts/tree/master/charts/nri-statsd)：New Relic StatsDインテグレーション。

      これらのコンポーネントは個別にインストールできますが、[`nri-bundle`](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle)チャートを使用することを強くお勧めします。New Relicでは、上記の個別チャートのラッパーやメタパッケージとして機能するこのチャートを用意してします。このチャートを使用すると、次のような利点が得られます。

      * インストールされるコンポーネントを完全に制御できます。各コンポーネントは、個別の[Helm依存関係](https://helm.sh/docs/chart_template_guide/subcharts_and_globals/#overriding-values-from-a-parent-chart)としてインストールされます。[ここで](#configure)説明するパラメーターを使用して、それらを個別に設定できます。
      * インストールされているバージョンが相互に互換性があることが保証されます。
      * インストールされているチャート間で設定値に矛盾がないことが保証されます。

      `nri-bundle`チャートは、[Kubernetesガイド付きインストール](/docs/kubernetes-pixie/kubernetes-integration/installation/kubernetes-integration-install-configure#guided-install)でインストールおよび設定されるチャートです。

      ### Helmを使用した`nri-bundle`のインストールと設定

      1. Helmと`kubectl`を実行するマシンで適切なコンテキストを使用していることを確認してください。

         利用可能なコンテキストは次のようにして確認できます。

         ```shell
         kubectl config get-contexts
         ```

         次を使用して、目的のコンテキストに切り替えます。

         ```shell
         kubectl config use-context _CONTEXT_NAME_
         ```

      2. New Relic Helmチャートリポジトリを追加します。

         ```shell
         helm repo add newrelic https://helm-charts.newrelic.com
         ```

      3. `values-newrelic.yaml`という名前のファイルを作成します。これは設定の定義に使用します。

         ```yaml
         global:
           licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
           cluster: _K8S_CLUSTER_NAME_

         newrelic-prometheus-agent:
           # Automatically scrape prometheus metrics for annotated services in the cluster
           # Collecting prometheus metrics for large clusters might impact data usage significantly
           enabled: true
         nri-metadata-injection:
           # Deploy our webhook to link APM and Kubernetes entities
           enabled: true
         nri-kube-events:
           # Report Kubernetes events
           enabled: true
         newrelic-logging:
           # Report logs for containers running in the cluster
           enabled: true
         kube-state-metrics:
           # Deploy kube-state-metrics in the cluster.
           # Set this to true unless it is already deployed.
           enabled: true
         ```

      4. 次のコマンドを実行して、チャート内のすべてが正しく設定されていることを確認します。`--dry-run`と`--debug`を指定しているため、この手順では何もインストールされません。

         ```shell
         helm upgrade --install newrelic-bundle newrelic/nri-bundle \
         --namespace newrelic --create-namespace \
         -f values-newrelic.yaml \
         --dry-run \
         --debug
         ```

         次のフラグに注意して調整してください。

         * `global.licenseKey=YOUR_NEW_RELIC_LICENSE_KEY`：アカウントに対して有効な

           <InlinePopover type="licenseKey"/>

           に設定する必要があります。

         * `global.cluster=K8S_CLUSTER_NAME`：New Relic UIでクラスタの識別に使用するため、New Relicアカウントで設定されている、他のKubernetesクラスタでは使用されていないわかりやすい値にする必要があります。

         * `kube-state-metrics.enabled=true`: これを`true`に設定すると、インテグレーションの実行に必要なKube State Metrics（KSM）が自動的にインストールされます。KSMがクラスタ内にすでに存在する場合は、別の名前空間にある場合でも、これをfalseに設定できます。

         * `newrelic-prometheus-agent.enabled=true`: クラスタ内に存在するPrometheusエンドポイントからデータを自動収集する、Prometheusエージェントをデプロイします。

         * `nri-metadata-injection.enabled=true`: 最小限のWebhookをインストールします。これにより環境変数が追加され、[New Relic APMでインストゥルメントされたアプリケーションを、Kubernetesにリンク](/docs/kubernetes-pixie/kubernetes-integration/link-your-applications/link-your-applications-kubernetes)できるようになります。

         Kubernetesチャートには、特定のニーズに合わせて編集できるフラグと調整パラメーターの包括的なセットが含まれています。変更できる内容については、以下の[インテグレーションの設定](#configure)セクションを確認してください。

      5. `--debug`と`--dry-run`を指定せずにコマンドを実行して、Kubernetesインテグレーションをインストールします。

         ```shell
         helm upgrade --install newrelic-bundle newrelic/nri-bundle \
         --namespace newrelic --create-namespace \
         -f values-newrelic.yaml
         ```

         <Callout variant="important">
           Kubernetesバージョン1.27.xまたは[それ以前の対応バージョン](/docs/kubernetes-pixie/kubernetes-integration/get-started/kubernetes-integration-compatibility-requirements)を使用していることを確認してください。
         </Callout>

      6. ポッドがデプロイされ、安定した状態になっていることを確認します。

         ```shell
         kubectl -n newrelic get pods -w
         ```

      以下が表示されます。

      * `newrelic-nrk8s-ksm` ポッド。
      * `newrelic-nrk8s-kubelet` クラスタ内の各ノードのポッド。
      * `newrelic-nrk8s-control-plane` クラスタ内の各マスターノードのポッド（存在する場合）。
      * `newrelic-kube-state-metrics` ポッド（インストールにKSMを含めた場合）。
      * `newrelic-nri-kube-events` ポッド（Kubernetesイベントレポートを有効にしている場合）。
      * `prometheus-agent` ポッド（[Prometheusエージェント](/docs/infrastructure/prometheus-integrations/install-configure-prometheus-agent/install-prometheus-agent)インテグレーションを有効にしている場合）。
      * `newrelic-newrelic-logging` クラスタ内の各ノードのポッド（ロギングインテグレーションを有効にしている場合）。

      <InstallFeedback/>

      ## インテグレーションの設定 [#configure]

      `nri-bundle`チャート。そのインストール手順は上記に記載されており、ソリューションのコンポーネントを含む、他のいくつかのチャートのラッパーやメタパッケージとして機能します。このようなラッパーを提供することで、コンポーネントのチャートを比較的単純に保ちながら、相互に互換性があるバージョンを使用して、制御されたコンポーネントのセットを提供できます。

      [`nri-bundle`](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle)チャートは、[複数の個別チャート](#install-k8-helm)をラップし、さまざまなテレメトリーデータを収集して、New Relicに送信します。このバンドルを使用すると、ニーズに応じて必要な子チャートを選択的に有効にすることができます。個別のコンポーネントを設定するには、[Helmの依存関係システム](https://helm.sh/docs/chart_template_guide/subcharts_and_globals/#overriding-values-from-a-parent-chart)を使用する必要があります。つまり、各子チャートの設定を、[values-newrelic.ymlファイル](https://helm.sh/docs/chart_template_guide/values_files/)内の別個のセクション（各子チャートにちなんだ名前）に配置する必要があります。たとえば、`newrelic-infrastructure`チャートを設定するには、次のコードを`values-newrelic.yaml`に追加します。

      ```yaml
      # General settings that apply to all the child charts
      global:
        licenseKey: _YOUR_NEW_RELIC_LICENSE_KEY_
        cluster: _K8S_CLUSTER_NAME_

      # ... Other settings as shown above

      # Specific configuration for the newrelic-infrastructure child chart
      newrelic-infrastructure:
        verboseLog: true  # Enable debug logs
        privileged: false  # Install with minimal privileges
        # Other options from https://github.com/newrelic/helm-charts/tree/master/charts/newrelic-infrastructure-v3

      # Specific configuration for the newrelic-logging child chart
      newrelic-logging:
        fluentBit:
        retryLimit: 10
      ```

      子チャートのオプションに子チャート名をプレフィックスとして付け、ネストをドットで置き換えることで、コマンドラインから子チャートオプションを渡すこともできます。

      ```
      helm upgrade --install newrelic-bundle newrelic/nri-bundle \
      --namespace=newrelic \
      --set global.licenseKey=_YOUR_NEW_RELIC_LICENSE_KEY_ \
      --set global.cluster=_K8S_CLUSTER_NAME_ \
      --set newrelic-infrastructure.privileged=false \
      --set newrelic-infrastructure.verboseLog=true \
      --set newrelic-logging.fluentBit.retryLimit=10
      ```

      各子チャートで調整できるフラグ（[scrape-interval](/docs/new-relic-solutions/observability-maturity/operational-efficiency/data-governance-optimize-ingest-guide#k8s-integration)など）の完全なリストは、それぞれのリポジトリにあります。

      * [`newrelic-infrastructure`](https://github.com/newrelic/nri-kubernetes/tree/main/charts/newrelic-infrastructure)
      * デバッグログ、特権モード、コントロールプレーンモニタリングなどを設定します。
      * [`nri-kube-events`](https://github.com/newrelic/nri-kube-events/tree/main/charts/nri-kube-events)
      * [`nri-metadata-injection`](https://github.com/newrelic/k8s-metadata-injection/tree/main/charts/nri-metadata-injection)
      * APMリンク用のWebhookのデプロイ方法を設定します。
      * スクレイピングするPrometheusエンドポイントを設定します。
      * [`newrelic-logging`](https://github.com/newrelic/helm-charts/tree/master/charts/newrelic-logging)
      * New Relicに送信するログまたはログ属性を設定します。

      <Callout variant="tip">
        子チャートの設定オプションを指定する場合は、それらを`values-newrelic.yaml`内のチャート名にちなんで名付けられたセクションの下に配置する必要があります。
      </Callout>

      <Callout variant="tip">
        コマンドラインから子チャートのオプションを渡すには、子チャートの名前をプレフィックスとして付け、ネストをドットで置き換える必要があります。
      </Callout>
    </TabsPageItem>

    <TabsPageItem id="gke-autopilot">
      GKE AutopilotクラスタにKubernetesインテグレーションをインストールするには3つの方法があります。

      * ガイド付きインストールにあるNew Relic CLI
      * 必要な値が事前に入力されたHelmコマンド
      * 必要な値が事前に入力されたプレーンなマニフェスト

      <CollapserGroup>
        <Collapser
          id="guided-gke"
          title="ガイド付きインストール（推奨）"
        >
          [ガイド付きインストール](/docs/kubernetes-pixie/kubernetes-integration/installation/kubernetes-integration-install-configure/#guided-install)タブと同じインストールフローを使用して、GKEオートパイロットでインストールできます。
        </Collapser>

        <Collapser
          id="helm-gke"
          title="手動によるHelm"
        >
          完全なHelmコマンドは次のようになります。

          ```shell
          KSM_IMAGE_VERSION="v2.10.0" && \
          helm repo add newrelic https://helm-charts.newrelic.com && helm repo update && \
          kubectl create namespace newrelic ; helm upgrade --install newrelic-bundle newrelic/nri-bundle \
          --set global.licenseKey=<Your License Key> \
          --set global.cluster=<Your Cluster Name> \
          --namespace=newrelic \
          --set newrelic-infrastructure.privileged=false \
          --set newrelic-infrastructure.controlPlane.enabled=false \
          --set newrelic-infrastructure.kubelet.config.scheme=http \
          --set newrelic-infrastructure.kubelet.config.port=10255 \
          --set global.lowDataMode=true \
          --set kube-state-metrics.image.tag=${KSM_IMAGE_VERSION} \
          --set kube-state-metrics.enabled=true \
          --set kubeEvents.enabled=true \
          --set newrelic-prometheus-agent.enabled=true \
          --set newrelic-prometheus-agent.lowDataMode=true \
          --set newrelic-prometheus-agent.config.kubernetes.integrations_filter.enabled=false \
          --set newrelic-pixie.enabled=false
          --set logging.enabled=true 
          --set newrelic-logging.lowDataMode=true 
          --set newrelic-logging.fluentBit.linuxMountPath=/var/log  
          --set newrelic-logging.fluentBit.persistence.mode=persistentVolume 
          --set newrelic-logging.fluentBit.persistence.persistentVolume.storageClass=standard-rwx
          ```

          [Fluent Bit](https://fluentbit.io/)は、FileStoreボリュームを使用して、Fluent Bitポッドの再起動または再デプロイ中のデータ損失やログの重複を防ぐことができます。FileStoreを使用すると、Googleが請求する追加料金が発生します。詳細については、Google Cloud管理者に相談するか、[FileStoreのドキュメント](https://cloud.google.com/filestore/pricing)をご覧になることをお勧めします。Google FileStore APIはGKEプロジェクトで有効にする必要があります。APIの有効化について詳しくは、この[ドキュメント](https://support.google.com/googleapi/answer/6158841)を参照してください。

          FileStoreを使用したくない場合は、以下を追加します。

          * `"newrelic-logging.fluentBit.persistence.mode"`を次のように設定します `"none"`
          * 削除 `"newrelic-logging.fluentBit.persistence.persistentVolume.storageClass"`

          詳細については、[Helmチャートのドキュメント](https://github.com/newrelic/helm-charts/tree/master/charts/nri-bundle)を確認してください。
        </Collapser>

        <Collapser
          id="manifest-gke"
          title="マニフェスト"
        >
          次のフラグを使用してマニフェストコマンドを更新します。

          * `"newrelic-infrastructure.privileged"`、`"newrelic-infrastructure.controlPlane.enabled"`を`false`に設定します。
          * 追加 `"newrelic-infrastructure.kubelet.config.scheme":"http"`
          * 追加 `"newrelic-infrastructure.kubelet.config.port":"10255"`
          * 追加 `"logging.enabled":"true"`
          * 追加 `"newrelic-logging.lowDataMode":"true"`
          * 追加 `"newrelic-logging.fluentBit.linuxMountPath":"/var/log"`
          * 追加 `"newrelic-logging.fluentBit.persistence.mode":"persistentVolume"`
          * 追加 `"newrelic-logging.fluentBit.persistence.persistentVolume.storageClass":"standard-rwx"`
          * Pixieは現在GKE Autopilotでサポートされていないため、コマンドからPixieペイロードを削除します。

          [Fluent Bit](https://fluentbit.io/)は、FileStoreボリュームを使用して、Fluent Bitポッドの再起動または再デプロイ中のデータ損失やログの重複を防ぐことができます。FileStoreを使用すると、Googleが請求する追加料金が発生します。詳細については、Google Cloud管理者に相談するか、[FileStoreのドキュメント](https://cloud.google.com/filestore/pricing)をご覧になることをお勧めします。Google FileStore APIはGKEプロジェクトで有効にする必要があります。APIの有効化について詳しくは、この[ドキュメント](https://support.google.com/googleapi/answer/6158841)を参照してください。

          FileStoreを使用したくない場合は、以下を追加します。

          * `"newrelic-logging.fluentBit.persistence.mode"`を次のように設定します `"none"`
          * 削除 `"newrelic-logging.fluentBit.persistence.persistentVolume.storageClass"`

          マニフェストファイルを作成してクラスタに適用するコマンドは次のとおりです。

          ```shell
          KSM_IMAGE_VERSION="v2.10.0" && \
          curl -X POST https://k8s-config-generator.service.newrelic.com/generate -H 'Content-Type: application/json' -d '{"global.cluster":"<Your Cluster Name>","global.namespace":"newrelic","newrelic-infrastructure.privileged":"false","newrelic-infrastructure.controlPlane.enabled":"false","newrelic-infrastructure.kubelet.config.scheme":"http","newrelic-infrastructure.kubelet.config.port":"10255","global.lowDataMode":"true","kube-state-metrics.image.tag":"'${KSM_IMAGE_VERSION}'","kube-state-metrics.enabled":"true","kubeEvents.enabled":"true","newrelic-prometheus-agent.enabled":"true","newrelic-prometheus-agent.lowDataMode":"true","newrelic-prometheus-agent.config.kubernetes.integrations_filter.enabled":"false","logging.enabled":"true", "newrelic-logging.lowDataMode":"true", "newrelic-logging.fluentBit.linuxMountPath":"/var/log", "newrelic-logging.fluentBit.persistence.mode":"persistentVolume", "newrelic-logging.fluentBit.persistence.persistentVolume.storageClass":"standard-rwx","global.licenseKey":"<Your License Key"}'  > newrelic.yaml && (kubectl create namespace newrelic ; kubectl apply -f newrelic.yaml)
          ```
        </Collapser>
      </CollapserGroup>
    </TabsPageItem>
  </TabsPages>
</Tabs>

## Kubernetesデータの使用

詳細：

* [非特権モードと特権モード](/docs/infrastructure/install-infrastructure-agent/linux-installation/linux-agent-running-modes)
* [UIでKubernetesデータを探索](/docs/kubernetes-pixie/kubernetes-integration/understand-use-data/kubernetes-cluster-explorer)
* [Kubernetesデータ](/docs/kubernetes-pixie/kubernetes-integration/understand-use-data/find-use-your-kubernetes-data)をクエリ、チャート、アラートなどで使用

<InstallFeedback/>