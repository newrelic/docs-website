---
title: NRQLの構文、句、関数
contentType: page
template: basicDoc
topics:
  - Query your data
  - 'NRQL: New Relic Query Language'
  - Get started
japaneseVersion: >-
  https://docs.newrelic.co.jp/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions
---

NRQLは、New Relicデータベースのクエリに使用可能なクエリ言語です。このドキュメントではNRQLの構文、句、構成要素、関数について説明します。

## 構文 [#syntax]

このドキュメントは、NRQLクエリにおいて使用される関数と句の参考資料です。NRQLを理解するためのその他のリソース：

* [NRQLの紹介](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql)：どのようなNRQLが使用されるのか、それによってどのようなデータをクエリできるのか、そして基本的なNRQL構文について説明しています。
* [New Relicチャートの作成に使用するNRQLクエリを検証する](/docs/using-new-relic/user-interface-functions/view-your-data/standard-new-relic-ui-page-functions#view-query)
* [SQL JOIN関数をシミュレーション](/docs/insights/new-relic-insights/using-new-relic-query-language/simulate-sql-join-functions-insights)
* [ファネルを使用して一連の関連データを評価する](/docs/insights/new-relic-insights/features/funnels)
* [Event APIでクエリを行うためのNRQLをフォーマットする](/docs/insights/insights-api/get-data/query-insights-event-data-api)

## クエリの構成要素 [#clauses]

すべてのNRQLクエリは`SELECT`文または `FROM`句で始まります。その他すべての句は任意です。以下の句の定義には、NRQLクエリの例も含まれます。

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="state-select"
    title={<>必須：<InlineCode>SELECT</InlineCode>文</>}
  >
    ```
    SELECT属性...
    ```

    ```
    SELECT関数（属性）...
    ```

    `SELECT`は、[属性](/docs/insights/new-relic-insights/decorating-events/insights-attributes)または[関数](#functions)を指定することによってどの部分のデータタイプをクエリしたいかを指定します。その後、カンマ区切りの1つ以上の引数が続きます。各引数では、以下を実行できます。

    * ワイルドカードとして`*`を使用することにより、利用可能なすべての属性の値を取得できます。例えば：`SELECT * from Transaction`。
    * 指定した属性、または [カンマ区切りのリスト](#commas)で指定した複数の属性に関連する値を取得できます。
    * [集約関数](#functions)を選択することで、指定した属性から集約値を取得できます。
    * [`AS`句](#sel-as)を使って、各引数で返された結果にラベルを付けます。

    基本的な数学関数とともに[`SELECT`を使用することもできます](/docs/query-data/nrql-new-relic-query-language/getting-started/nrql-math-using-select)。

    <CollapserGroup>
      <Collapser
        id="avg-resp-time-query"
        title="直近1週間の平均レスポンスタイム"
      >
        このクエリは、直近1週間の平均応答時間を返します。

        ```
        SELECT average(duration) FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-from"
    title={<>必須：<InlineCode>FROM</InlineCode>句</>}
  >
    ```
    SELECT ...
      FROM data type
      ...
    ```

    `FROM`句を使用して、クエリしたい[データタイプ](/docs/query-data/nrql-new-relic-query-language/getting-started/introduction-nrql#what-you-can-query)を指定します。クエリは`FROM`または[`SELECT`](#state-select)から開始することができます。[カンマ区切りのリスト](#commas)を使って、複数のデータタイプにまたがる同じ属性の値をマージすることができます。

    <CollapserGroup>
      <Collapser
        id="one-event"
        title="ひとつのデータタイプのクエリ"
      >
        このクエリは、直近3日間の [APMトランザクション](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) の全件数を返します。

        ```
        SELECT count(*) FROM Transaction SINCE 3 days ago
        ```
      </Collapser>

      <Collapser
        id="multiple-events"
        title="複数のデータタイプのクエリ"
      >
        このクエリは、直近3日間の [APM トランザクション](/docs/insights/new-relic-insights/decorating-events/insights-attributes#transaction-defaults) と [Browserイベント](/docs/insights/new-relic-insights/decorating-events/browser-default-attributes-insights#browser-attributes-table) の全カウント数を返します。

        ```
        SELECT count(*) FROM Transaction, PageView SINCE 3 days ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="show-event-types"
    title={<><InlineCode>SHOW EVENT TYPES</InlineCode>句</>}
  >
    ```
    SHOW EVENT TYPES...
    ```

    `SHOW EVENT TYPES`は、特定の時間範囲内にアカウントに存在するすべてのデータタイプのリストを返します。これは、`SELECT`の代わりにクエリの最初の句として使用されます。

    <Callout variant="important">
      この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータタイプを指します。
    </Callout>

    <CollapserGroup>
      <Collapser
        id="avg-resp-time-query"
        title="直近1日間のデータタイプ"
      >
        このクエリは、直近1日のすべてのデータタイプを返します。

        ```
        SHOW EVENT TYPES SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-where"
    title={<><InlineCode>WHERE</InlineCode>句</>}
  >
    `WHERE`句を使用して、結果をフィルタリングします。NRQLは、句で指定した条件を満たす結果を返します。

    ```
    SELECT function(attribute) ...
      WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ]
      [AND|OR ...]
      ...
    ```

    * 複数の条件を指定する場合は、条件を演算子`AND`または`OR`で区切ります。
    * [SQLのjoinをシミュレート](/docs/insights/nrql-new-relic-query-language/using-nrql/simulate-sql-join-functions-insights)したい場合は、`WHERE`または`FACET`句でカスタム属性を使用します。

    <Table id="where-operators">
      <thead>
        <tr>
          <th width={150}>
            **`WHERE`句が受け付ける演算子**
          </th>

          <th>
            **説明**
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `=`, `!=`, `<`, `<=`, `>`, `>=`
          </td>

          <td>
            NRQLは標準的な比較演算子を受け付けます。

            例: `state = 'WA'`
          </td>
        </tr>

        <tr>
          <td>
            `AND`
          </td>

          <td>
            2つの条件の論理積を定義するために使用します。
          </td>
        </tr>

        <tr>
          <td>
            `OR`
          </td>

          <td>
            2つの条件の論理和を定義するために使用します。
          </td>
        </tr>

        <tr>
          <td>
            `IS NULL`
          </td>

          <td>
            属性がnull値を持つかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `IS NOT NULL`
          </td>

          <td>
            属性がnull値を持たないかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `IN`
          </td>

          <td>
            属性の文字列値が指定したセットに存在するかどうかを判断します。この方法を使うと、複数の`WHERE`句を組み合わせた場合よりもパフォーマンスが向上します。

            例: `animalType IN （'cat', 'dog', 'fish'）`
          </td>
        </tr>

        <tr>
          <td>
            `NOT IN`
          </td>

          <td>
            属性の文字列値が指定したセットに存在しないかどうかを判断します。この方法を使うと、複数の`WHERE`句を組み合わせた場合よりもパフォーマンスが向上します。

            値は括弧で囲み、カンマで区切る必要があります。例えば：

            ```
            SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA')
            ```
          </td>
        </tr>

        <tr>
          <td>
            `LIKE`
          </td>

          <td>
            属性に指定の部分文字列が含まれるかどうかを判断します。

            `LIKE`演算子の文字列引数は、文字列内の任意の位置にワイルドカードとしてパーセント記号（%）を受け付けます。部分文字列が一致対象の文字列で開始（先頭に一致）または終了（末尾に一致）しない場合、ワールドカードを文字列の先頭または末尾に指定する必要があります。

            **例：**

            `userAgentName LIKE 'IE%'`

            * IE
            * IE Mobile

            `userAgentName LIKE 'o%a%'`

            * Opera
            * Opera Mini

            `userAgentName LIKE 'o%a'`

            * Opera

            `userAgentName LIKE '%o%a%'`

            * Opera
            * Opera Mini
            * Mozilla Gecko
          </td>
        </tr>

        <tr>
          <td>
            `NOT LIKE`
          </td>

          <td>
            属性に指定の部分文字列が含まれないかどうかを判定します。
          </td>
        </tr>

        <tr>
          <td>
            `RLIKE`
          </td>

          <td>
            属性に特定のRegex 部分文字列が含まれるかどうかを判断します。[RE2 構文](https://github.com/google/re2/wiki/Syntax)を使用します。

            **例：**

            `appName RLIKE 'z.*|q.*''`

            * `z-app`
            * `q-app`

            `hostname RLIKE 'ip-10-351-[0-2]?[0-9]-.*'`

            * `ip-10-351-19-237`
            * `ip-10-351-2-41`
            * `ip-10-351-24-238`
            * `ip-10-351-14-15`

            <Callout variant="important">
              注:

              * Regexパターンではスラッシュをエスケープする必要があります。たとえば、`\d`は`\\d`とする必要があります。
              * Regexではデフォルトで文字列全体マッチとなっているため、`^`と`$`は暗黙となり、追加する必要はありません。
              * Regexパターンにキャプチャグループが含まれる場合、そのグループは無視されます。つまり、クエリで後で使用するためにグループはキャプチャされません。
            </Callout>
          </td>
        </tr>

        <tr>
          <td>
            `NOT RLIKE`
          </td>

          <td>
            属性に指定のRegex部分文字列が含まれないかどうかを判定します。[RE2 構文](https://github.com/google/re2/wiki/Syntax)を使用します。
          </td>
        </tr>
      </tbody>
    </Table>

    <CollapserGroup>
      <Collapser
        id="query-3-conditions"
        title="3つの条件を使ったクエリの例"
      >
        このクエリは、過去24時間、米国およびカナダ国内のSafariユーザーについて、URLに`checkout`が含まれるページのブラウザレスポンスタイムを返します。

        ```
        SELECT histogram(duration, 50, 20) FROM PageView
        WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%'
        SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-as"
    title={<><InlineCode>AS</InlineCode>句</>}
  >
    ```
    SELECT ...
      AS 'label'
      ...
    ```

    `AS`句を使用して、シングルクォート区切りの文字列で属性、集計、ファネル内のステップ、または数学関数の結果にラベルを付けます。このラベルは結果のチャートで使用されます。

    <CollapserGroup>
      <Collapser
        id="math-as"
        title={<>数学関数と<InlineCode>AS</InlineCode>を使用したクエリ</>}
      >
        このクエリはセッションごとのページ数を返します。

        ```
        SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session'
          FROM PageView
        ```
      </Collapser>

      <Collapser
        id="funnel-as"
        title={<>ファネルと<InlineCode>AS</InlineCode>を使用したクエリ</>}
      >
        このクエリは、過去1週間でサイトのメインページと採用情報ページの両方を訪れた人の数を返します。

        ```
        SELECT funnel(SESSION,
            WHERE name='Controller/about/main' AS 'Step 1',
            WHERE name = 'Controller/about/careers' AS 'Step 2')
            FROM PageView SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet"
    title={<><InlineCode>FACET</InlineCode>句</>}
  >
    ```
    SELECT ...
      FACET attribute
      ...
    ```

    `FACET`を使用すると、結果を属性値で分割してグループ化できます。例えば、`PageView`データで`deviceType`別に`FACET`を行い、トラフィックの何割が携帯電話、タブレット、およびデスクトップデバイスから発生しているかを把握することができます。

    `LIMIT`句を使用して、表示するファセットの数を指定します（デフォルトは10）。複雑なグループ化には、[`FACET CASES`](#sel-facet-cases)を使用してください。`FACET`句は、カンマで区切られた最大5つの属性をサポートします。

    ファセットは、`SELECT`句で指定した最初のフィールドによって降順でソートされます。1,000件以上のユニーク値を持つ属性をファセットに指定した場合、ファセット値のサブセットを選択し、それらをクエリタイプに従って並べ替えます。

    `min()`、`max()`、または`count()`を選択すると、`FACET`はこれらの関数を使用してファセットの選択方法とソート方法を決定します。その他の[関数](#functions)を選択すると、`FACET`はファセット対象の属性の発生頻度に基づいて、ファセットの選択方法とソート方法を決定します。

    実際の例を使った複数の属性に対するファセットについては、こちらの [New Relicのブログ記事](https://blog.newrelic.com/2017/12/08/facets-nrql-queries-insights/)をご覧ください。

    <CollapserGroup>
      <Collapser
        id="faceted-query"
        title={<><InlineCode>count()</InlineCode>を使用したファセットクエリ</>}
      >
        このクエリは、ページビュー数が最も多い都市を表示します。このクエリは、都市ごとのページビューの合計数を使用してファセットの選択方法と並べ替え方法を決定します。

        ```
        SELECT count(*) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="uniquecount"
        title={<><InlineCode>uniqueCount()</InlineCode>を使用したファセットクエリ</>}
      >
        このクエリは、最も多数のユニークURLにアクセスしている都市を表示します。このクエリは、特定の都市が結果に表れる合計回数を使用して、ファセットの選択方法と並べ替え方法を決定します。

        ```
        SELECT uniqueCount(pageUrl) FROM PageView FACET city
        ```
      </Collapser>

      <Collapser
        id="cohort-analysis"
        title="時間範囲で結果をグループ化"
      >
        [高度なセグメンテーション](/docs/insights/new-relic-insights/features/advanced-segmentation)や[コホート分析](/docs/insights/new-relic-insights/features/cohort-analysis-grouping-results-across-time)では、バケット機能でファセットすることでデータをより効率的に分割することができます。

        コホート分析は、タイムスタンプに基づいて結果をグループ化する方法です。指定範囲日時に対応するバケットに結果を分割することができます。
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    title={<><InlineCode>FACET ... AS</InlineCode>句</>}
  >
    `FACET ... AS` 句では、クエリで `AS` キーワードを使用してファセットに名前を付けます。この句は、結果のファセットに明確な名前または簡略化された名前を追加するのに役立ちます。[ネスト構造の集計](http://docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nested-aggregation-make-ordered-computations-single-query)クエリで、ファセットの名前を変更するためにも使用できます。

    `FACET ... AS` クエリでは、結果のファセット名が変更されますが（たとえば、テーブルのヘッダーとして表示される場合）、実際のファセット名自体は変更されません。

    ```
    FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type'
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-cases"
    title={<><InlineCode>FACET CASES</InlineCode>句</>}
  >
    ```
    SELECT ...
      FACET CASES (
        WHERE attribute operator value, WHERE attribute operator value, ...
        )
      ...
    ```

    `FACET CASES`を使用して、[`FACET`](#sel-facet)で可能な範囲を超えた複雑な条件別にデータを取り出します。複数の条件はカンマ`,`で区切ります。たとえば、PageViewデータをクエリして、1秒未満、1秒から10秒、10秒を上回るといったカテゴリに`FACET CASES`を行うことができます。ケース内の複数の属性を組み合わせたり、[`AS`](#sel-as)セレクタを使ってケースにラベルを付けることができます。データ点は、最大で1つのファセットケースに追加されます。つまり、一致する最初のファセットになります。

    属性とともに[時間関数](/docs/query-data/nrql-new-relic-query-language/nrql-query-examples/group-results-across-time)も使用できます。

    <CollapserGroup>
      <Collapser
        id="facet-cases-basic"
        title={<><InlineCode>WHERE</InlineCode>の基本的な使い方</>}
      >
        ```
        SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10)
        ```
      </Collapser>

      <Collapser
        id="facet-cases-mixnmatch"
        title="複数の属性に基づくグループ化"
      >
        この例は、トランザクション名に`login`が含まれる1つのバケットと、URLに`login`が含まれ、かつカスタム属性がユーザーが有料ユーザーであったことを示すもう1つのバケットに結果をグループ化します：

        ```
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid')
        ```
      </Collapser>

      <Collapser
        id="facet-cases-as-label"
        title={<><InlineCode>AS</InlineCode>を使用したグループのラベル付け</>}
      >
        この例は、結果に目視可能な名前をつけるために[`AS`](#sel-as)セレクタを使います：

        ```
        SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users')
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-facet-order"
    title={<><InlineCode>FACET ... ORDER BY</InlineCode> 句</>}
  >
    NRQL では、デフォルトは `SELECT` 句の最初の集計で、クエリ内のファセットの選択をガイドします。`FACET ... ORDER BY` 句では、ORDER BY 修飾子を使用して集計関数を追加し、ファセットの選択方法を指定することで、このデフォルトの動作をオーバーライドできます。具体的には、`LIMIT`句によって制限される前に、最終結果に含めるファセットの優先度をオーバーライドします。この句はクエリで使用できますが、アラートやストリーミングには使用できません。

    この例では、`FACET ... ORDER BY` を使用してアプリ トランザクションの平均期間を見つける方法を示し、応答サイズが最大のアプリによる上位10（デフォルトの制限）の最大期間を示しています。この場合、`FACET ... ORDER BY` が使用されていない場合、クエリ結果には、アプリの選択とは関係のない応答サイズで、期間が最も長い上位10件が代わりに表示されます。

    ```
    FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize)
    ```

    <Callout variant="tip">
      `LIMIT` 句が適用される前に操作が実行されるため、`FACET ... ORDER BY`は、最終的なクエリ結果の種類に影響を与えません。これは、非時系列クエリの結果で特に顕著になります。
    </Callout>

    <Callout variant="important">
      この場合の `ORDER BY` 修飾子は、`ORDER BY` 句とは機能が異なります。`FACET attribute1 ORDER BY attribute2` の形式に従うクエリを解析する場合、NewRelic はこれらのクエリを `FACET ... ORDER BY` クエリとして読み取りますが、`ORDER BY` が `FACET` の直後に表示される場合に限定されます。それ以外の場合、`ORDER BY` は New Relic によって句として解釈されます。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-limit"
    title={<><InlineCode>LIMIT</InlineCode>句</>}
  >
    ```
    SELECT ...
      LIMIT count
      ...
    ```

    `LIMIT`句を使用して、`FACET`クエリで返されるファセット値の最大数あるいは`SELECT *`クエリで返される項目の最大数を管理します。この句は、単一の整数値を引数に取ります。`LIMIT`句が指定されないか、値が提供されなかった場合、リミットのデフォルト設定は`FACET`クエリの場合は10に、`SELECT *`クエリの場合は100となります。

    `LIMIT`句で許容される最大値は2,000です。

    <CollapserGroup>
      <Collapser title={<><InlineCode>LIMIT</InlineCode>を使用したクエリ</>}>
        このクエリはセッション数上位20カ国を表示し、各国のWindowsユーザー限定でレスポンスタイムの95 パーセンタイルを提供します。

        ```
        SELECT uniqueCount(session), percentile(duration, 95)
          FROM PageView WHERE userAgentOS = 'Windows'
          FACET countryCode LIMIT 20 SINCE YESTERDAY
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-offset"
    title={<><InlineCode>OFFSET</InlineCode> 句</>}
  >
    ```
    SELECT ...
      LIMIT count OFFSET count
      ...
    ```

    `OFFSET`句と`LIMIT`句を使用して、`SELECT *`または`SELECTの列`クエリによって返される行の一部を制御します。 `LIMIT` 句と同様に、 `OFFSET` は引数として単一の整数値を取ります。 `OFFSET` は、クエリで選択された行が返される前に、スキップされる行数を設定します。これは `LIMIT` によって制約されます。

    `OFFSET` 行はスキップされ、直近のレコードから開始されます。

    たとえば、`SELECT InterestingValue FROM Minute_Report LIMIT 5 OFFSET 1` のクエリは、 `Minute_Report` から、直近の値を除いて最後の5つの値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-order-by"
    title={<><InlineCode>ORDER BY</InlineCode> 句</>}
  >
    `ORDER BY` 句を使用すると、行でイベント属性を選択するクエリで結果を並べ替える方法を指定できます。

    このクエリは、期間順にトランザクションを並べ替えます。

    ```
    FROM Transaction SELECT appName, duration ORDER BY duration
    ```

    デフォルトの並べ替え順序は昇順ですが、 `ASC` または `DESC` の修飾子を追加することで変更できます。
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-since"
    title={<><InlineCode>SINCE</InlineCode>句</>}
  >
    ```
    SELECT ...
      SINCE [numerical units AGO | phrase]
      ...
    ```

    **デフォルト** 値は **1 時間前**です。

    `SINCE`句を使用して、返されたデータに対する時間範囲の開始時点を定義します。NRQLを使用する場合、[UTCタイムスタンプ](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets#utc-range)または[相対時間範囲](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets#relative-range)を設定できます。タイムゾーンは結果ではなく、クエリに対して指定できます。NRQLの結果はシステム時間に基づきます。

    詳細な情報と例については、[ダッシュボードとチャートで時間範囲を設定する](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets)をご覧ください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-until"
    title={<><InlineCode>UNTIL</InlineCode>句</>}
  >
    ```
    SELECT ...
      UNTIL integer units AGO
      ...
    ```

    **デフォルト** 値は **NOW**です。`UNTIL`は、デフォルト以外の終了点を指定するためのみに使用してください。

    `UNTIL`句はデータを返す時間範囲の終了時点を定義します。時間範囲を指定するとデータが保存されるようになり、時間範囲が終了した後に確認することができます。時間は [UTC タイムスタンプ](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets#utc-range) または[相対時間範囲](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets#relative-range)を指定できます。タイムゾーンは結果ではなく、クエリに対して指定できます。返される結果はシステム時間に基づきます。

    詳細な情報と例については、[ダッシュボードとチャートで時間範囲を設定する](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets)をご覧ください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timezone"
    title={<><InlineCode>WITH TIMEZONE</InlineCode>句</>}
  >
    ```
    SELECT ... WITH TIMEZONE (selected zone)
      ...
    ```

    デフォルトで、クエリ結果は、現在使用中のブラウザのタイムゾーンで表示されます。

    `WITH TIMEZONE`句を使用して、タイムゾーンが未指定のクエリで日付や時刻のタイムゾーンを選択します。

    たとえば、`SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York'`というクエリ句は、東部標準時の月曜日午前12時から東部標準時の火曜日午前12時までに記録されたデータを返します。

    <Table style={{ width: "auto" }}>
      <thead>
        <tr>
          <th colSpan={4}>
            利用可能なタイムゾーンの選択
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            アフリカ/アビジャン
          </td>

          <td>
            アフリカ/アディスアベバ
          </td>

          <td>
            アフリカ/アルジェ
          </td>

          <td>
            アフリカ/ブランタイヤ
          </td>
        </tr>

        <tr>
          <td>
            アフリカ/カイロ
          </td>

          <td>
            アフリカ/ウィントフック
          </td>

          <td>
            米州/アダック
          </td>

          <td>
            米州/アンカレッジ
          </td>
        </tr>

        <tr>
          <td>
            米州/アラグアイナ
          </td>

          <td>
            米州/アルゼンチン/ブエノスアイレス
          </td>

          <td>
            米州/ベリーズ
          </td>

          <td>
            米州/ボゴタ
          </td>
        </tr>

        <tr>
          <td>
            米州/カンポグランデ
          </td>

          <td>
            米州/カンクン
          </td>

          <td>
            米州/カラカス
          </td>

          <td>
            米州/シカゴ
          </td>
        </tr>

        <tr>
          <td>
            米州/チワワ
          </td>

          <td>
            米州/ドーソンクリーク
          </td>

          <td>
            米州/デンバー
          </td>

          <td>
            米州/エンセナーダ
          </td>
        </tr>

        <tr>
          <td>
            米州/グリーンベイ
          </td>

          <td>
            米州/ゴットホープ
          </td>

          <td>
            米州/グースベイ
          </td>

          <td>
            米州/ハバナ
          </td>
        </tr>

        <tr>
          <td>
            米州/ラパス
          </td>

          <td>
            米州/ロサンゼルス
          </td>

          <td>
            米州/ミクロン
          </td>

          <td>
            米州/モンテビデオ
          </td>
        </tr>

        <tr>
          <td>
            米州/ニューヨーク
          </td>

          <td>
            米州/モローニャ
          </td>

          <td>
            米州/サンティアゴ
          </td>

          <td>
            米州/サンパウロ
          </td>
        </tr>

        <tr>
          <td>
            米州/セントジョンズ
          </td>

          <td>
            アジア/アナディル
          </td>

          <td>
            アジア/バンコク
          </td>

          <td>
            アジア/ベイルート
          </td>
        </tr>

        <tr>
          <td>
            アジア/ダマスカス
          </td>

          <td>
            アジア/ダッカ
          </td>

          <td>
            アジア/ドバイ
          </td>

          <td>
            アジア/ガザ
          </td>
        </tr>

        <tr>
          <td>
            アジア/香港
          </td>

          <td>
            アジア/イルクーツク
          </td>

          <td>
            アジア/エルサレム
          </td>

          <td>
            アジア/カブール
          </td>
        </tr>

        <tr>
          <td>
            アジア/カトマンズ
          </td>

          <td>
            アジア/コルカタ
          </td>

          <td>
            アジア/クラスノヤルスク
          </td>

          <td>
            アジア/マガダン
          </td>
        </tr>

        <tr>
          <td>
            アジア/ノボシビルスク
          </td>

          <td>
            アジア/ヤンゴン
          </td>

          <td>
            アジア/ソウル
          </td>

          <td>
            アジア/タシケント
          </td>
        </tr>

        <tr>
          <td>
            アジア/テヘラン
          </td>

          <td>
            アジア/東京
          </td>

          <td>
            アジア/ウラジオストク
          </td>

          <td>
            アジア/ヤクーツク
          </td>
        </tr>

        <tr>
          <td>
            アジア/エカテリンブルク
          </td>

          <td>
            アジア/エレバン
          </td>

          <td>
            大西洋/アゾレス
          </td>

          <td>
            大西洋/カーポベルデ
          </td>
        </tr>

        <tr>
          <td>
            大西洋/スタンリー
          </td>

          <td>
            オーストラリア/アデレード
          </td>

          <td>
            オーストラリア/ブリスベン
          </td>

          <td>
            オーストラリア/ダーウィン
          </td>
        </tr>

        <tr>
          <td>
            オーストラリア/ユークラ
          </td>

          <td>
            オーストラリア/ホバート
          </td>

          <td>
            オーストラリア/ロードハウ
          </td>

          <td>
            オーストラリア/パース
          </td>
        </tr>

        <tr>
          <td>
            チリ/イースター島
          </td>

          <td>
            その他/GMT+10
          </td>

          <td>
            その他/GMT+8
          </td>

          <td>
            その他/GMT-11
          </td>
        </tr>

        <tr>
          <td>
            その他/GMT-12
          </td>

          <td>
            ヨーロッパ/アムステルダム
          </td>

          <td>
            ヨーロッパ/ベルファスト
          </td>

          <td>
            ヨーロッパ/ベオグラード
          </td>
        </tr>

        <tr>
          <td>
            ヨーロッパ/ブリュッセル
          </td>

          <td>
            ヨーロッパ/ダブリン
          </td>

          <td>
            ヨーロッパ/リスボン
          </td>

          <td>
            ヨーロッパ/ロンドン
          </td>
        </tr>

        <tr>
          <td>
            ヨーロッパ/ミンスク
          </td>

          <td>
            ヨーロッパ/モスクワ
          </td>

          <td>
            太平洋/オークランド
          </td>

          <td>
            太平洋/チャタム
          </td>
        </tr>

        <tr>
          <td>
            太平洋/ガンビエ
          </td>

          <td>
            太平洋/キリバス
          </td>

          <td>
            太平洋/マルケサス
          </td>

          <td>
            太平洋/ミッドウェイ
          </td>
        </tr>

        <tr>
          <td>
            太平洋/ノーフォーク
          </td>

          <td>
            太平洋/トンガタプ
          </td>

          <td>
            UTC
          </td>

          <td/>
        </tr>
      </tbody>
    </Table>

    詳細な情報と例については、[ダッシュボードとチャートで時間範囲を設定する](/docs/insights/new-relic-insights/managing-dashboards-data/set-time-range-insights-dashboards-widgets)をご覧ください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="with-metric-format"
    title={<><InlineCode>WITH METRIC_FORMAT</InlineCode> 句</>}
  >
    メトリックデータのクエリに関する情報については、[メトリックスのクエリを行う](#query-metrics)をご覧ください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-compare"
    title={<><InlineCode>COMPARE WITH</InlineCode>句</>}
  >
    ```
    SELECT ... (SINCE or UNTIL) (integer units) AGO
      COMPARE WITH (integer units) AGO
      ...
    ```

    `COMPARE WITH`句を使用して、2つの異なる時間範囲の値を比較します。

    `COMPARE WITH`では、`SINCE`または`UNTIL`文が必要になります。`COMPARE WITH`で指定された時間は、`SINCE`または`UNTIL`で指定した時間に相対します。たとえば、`SINCE 1 day ago COMPARE WITH 1 day ago`は、昨日とその前日を比較します。

    `COMPARE WITH`値の時間範囲は、常に`SINCE`または`UNTIL`で指定されたものと同じになります。たとえば、`SINCE 2 hours ago COMPARE WITH 4 hours ago`は、午後3時から午後5時の範囲と午後1時から午後3時の範囲を比較します。

    `COMPARE WITH`は、折れ線グラフまたはビルボードのいずれかの形式にすることができます：

    * `TIMESERIES`を使うと、`COMPARE WITH`は時系列でマッピングされた比較で折れ線グラフを作成します。
    * `TIMESERIES`がない場合、`COMPARE WITH`は現在値と`COMPARE WITH`値からの増減率でビルボードを生成します。

    **例:** このクエリは、過去1時間の95パーセンタイルを1週間前の同じ時間範囲と比較した折れ線グラフでデータを返します。一つ目は単一の値、その次は折れ線グラフです。

    ```
    SELECT percentile(duration) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO

    SELECT percentile(duration) FROM PageView
      SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="sel-timeseries"
    title={<><InlineCode>TIMESERIES</InlineCode>句</>}
  >
    ```
    SELECT ...
      TIMESERIES integer units
      ...
    ```

    `TIMESERIES`句を使用して、指定期間単位の時系列としてデータを返します。`TIMESERIES`は特定のチャートをトリガするために使用されることから、デフォルト値はありません。

    時間範囲を指定するには、`integer units`を使用します。例えば：

    * `TIMESERIES 1 minute`
    * `TIMESERIES 30 minutes`
    * `TIMESERIES 1 hour`
    * `TIMESERIES 30 seconds`

    <CollapserGroup>
      <Collapser
        id="set-interval"
        title="設定した間隔を使用する"
      >
        指定された値は、グラフを分割する単位を示します。たとえば、以下のようにして1日のグラフを30分刻みで表示します。

        ```
        SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes
        ```
      </Collapser>

      <Collapser
        id="timeseries-auto"
        title="自動設定した間隔を使用する"
      >
        `TIMESERIES`は`AUTO`に設定することもでき、これによってグラフが適切な数の区分に分割されます。たとえば、1日のチャートは30分間隔で分割され、1週間のチャートは6時間間隔で分割されます。

        このクエリは、6時間間隔のデータ点で、1週間のクライアントサイドのトランザクションタイムの50パーセントタイルと90パーセンタイルを示す折れ線グラフを返します。

        ```
        SELECT average(duration), percentile(duration, 50, 90)
          FROM PageView SINCE 1 week AGO TIMESERIES AUTO
        ```
      </Collapser>

      <Collapser
        id="timeseries-max"
        title="最大インターバルを使用する"
      >
        `TIMESERIES`を`MAX`に設定することで時間枠が自動的に調整され、指定された期間で許可された間隔数を最大にすることができます。これによって、`TIMESERIES`バケットを手動で更新することなく時間枠を更新でき、認められた最大インターバル数に時間枠を分割できます。返される`TIMESERIES`バケットの最大数は366です。

        例えば、以下のクエリでは4分間の間隔を作成していますが、これは1日のチャートの上限となります。

        ```
        SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX
        ```
      </Collapser>
    </CollapserGroup>

    <Callout variant="important">
      `average（ ）`または`percentile（ ）`などの関数では、間隔を大きく設定することで、外れ値に対して大幅なスムージング効果が得られます。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="extrapolate"
    title={<><InlineCode>EXTRAPOLATE</InlineCode>句</>}
  >
    この句は以下のデータタイプで使用可能です：

    * `Transaction`
    * `TransactionError`
    * APMエージェントのAPIを通じて報告されたカスタムイベント

    `EXTRAPOLATE`の目的は、クエリ結果がシステム内のアクティビティ全体をより厳密に表現できるよう、[イベントデータのAPMエージェントサンプリング](/docs/agents/manage-apm-agents/agent-data/new-relic-events-limits-sampling)の影響を数学的に補うことです。

    この節は、New Relic APMエージェントが余りにも多くの[イベント](/docs/using-new-relic/metrics/analyze-your-metrics/data-collection-metric-timeslice-event-data#event-data)を報告することで、[収穫サイクル](/docs/using-new-relic/welcome-new-relic/getting-started/glossary#harvest-cycle)の報告上限を超過しがちになる際に便利です。その場合、エージェントはイベントのサンプリングを開始します。

    `EXTRAPOLATE`に対応したNRQLクエリでこれを使用した場合、**報告されたイベント**と**合計イベント**の比率を基に、合計未サンプルデータの近似を推定します。この句に未対応であるか、サンプルデータを使用していないNRQLでこれを使用した場合、結果に影響を与えません。

    <Callout variant="important">
      `EXTRAPOLATE`は、（スループットやエラー率など）同種データについて最も有用なことに注意してください。（`uniqueCount()` や `uniques()`など）特徴的なことの数を外挿しようとする際には有効ではありません。
    </Callout>

    この句は、以下のいずれかの[集約関数](/docs/insights/nrql-new-relic-query-language/nrql-reference/nrql-syntax-components-functions#functions)を利用したNRQLクエリでのみ機能します：

    * apdex
    * average
    * count
    * histogram
    * sum
    * percentage （引数として取る関数が`EXTRAPOLATE`に対応している場合）
    * rate （引数として取る関数が`EXTRAPOLATE`に対応している場合）
    * stddev

    <CollapserGroup>
      <Collapser
        id="extrapolate-example-1"
        title="スループットの推定の例"
      >
        `interestingApplication`という名前のサービスの推定スループットを示すクエリ。

        ```
        SELECT count(*) FROM Transaction WHERE appName='interestingApplication' 
        SINCE 60 minutes ago EXTRAPOLATE
        ```
      </Collapser>

      <Collapser
        id="extrapolate-example-2"
        title="時系列としてのスループットの推定の例"
      >
        トランザクション名ごとに、時系列として表示する`interestingApplication`という名前のサービスの推定スループットを示すクエリ。

        ```
        SELECT count(*) FROM Transaction WHERE appName='interestingApplication' 
        SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>
</CollapserGroup>

## メトリックデータのクエリを行う [#query-metrics]

NRQLを使用してメトリックデータのクエリを行うには、次のいくつかの方法があります：

* [メトリックタイムスライスデータをクエリ](/docs/query-data/nrql-new-relic-query-language/nrql-query-tutorials/query-metric-timeslice-data-nrql)（New Relic APM、Browser、Mobileによりレポートされます）
* [`Metric`データタイプをクエリ](/docs/data-ingest-apis/get-data-new-relic/metric-api/view-query-you-metric-data)（一部のインテグレーションおよびテレメトリーSDKによりレポートされます）

New Relicでのメトリックスの理解の詳細については、[メトリックデータのタイプ](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics)をご覧ください。

## 集計関数 [#functions]

集約関数を使用して、NRQLクエリのデータを絞り込み、集約できます。以下に、集約関数の利用に関する便利な情報を提供します：

* New Relic Universityの[Filter Queries](http://newrelic.wistia.com/medias/8k4xbxlfwj)、[Apdex Queries](http://newrelic.wistia.com/medias/46dvx1mkm0)、および[Percentile Queries](http://newrelic.wistia.com/medias/j3htrz66l0)のチュートリアル。または、完全な[Writing NRQL クエリ](https://learn.newrelic.com/writing-nrql-queries)のオンラインコースにアクセスしてください。
* データタイプ「型強制」には対応していません。[利用可能なデータ型変換関数](#type-conversion)の詳細を参照してください。
* New Relic Insights の [**コホート分析** ページ](/docs/insights/new-relic-insights/features/cohort-analysis)では、コホート分析の関数が表示されます。コホート関数は、時間別にトランザクションを集計します。

以下は、利用可能な集約関数になります。以下の定義には、NRQLクエリの例が含まれます。

例：

```
SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
```

<CollapserGroup>
  <Collapser
    className="freq-link"
    id="func-apdex"
    title={<InlineCode>apdex(attribute, t: )</InlineCode>}
  >
    `apdex`関数を使用して、単一のトランザクションまたはすべてのトランザクションに対して[Apdexスコア](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#score)を返します。[属性](/docs/insights/new-relic-insights/decorating-events/insights-attributes)は、[`duration`](/docs/insights/insights-data-sources/default-events-attributes/apm-default-event-attributes#txn-duration)や[`backendDuration`](/docs/insights/insights-data-sources/default-events-attributes/browser-default-events-attributes-insights#backend-duration)などのレスポンスタイムに基づいて、任意の属性に指定できます。`t:` 引数は [Apdex T](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction) の閾値を秒単位で定義します。

    `apdex（ ）`関数が返すApdexスコアは、実行時間のみに基づくものです。APMエラーは考慮していません。エラーが含まれているにもかかわらず、トランザクションが[Apdex T](/docs/apm/new-relic-apm/getting-started/glossary#apdex_t)以下で完了する場合、そのトランザクションは`apdex （ ）`関数によって[満足](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#bullet-satisfied)と評価されます。

    <CollapserGroup>
      <Collapser
        id="apdex-cust-attributes"
        title="特定の顧客の Apdexを取得する"
      >
        もし [定義済みのカスタム属性](/docs/insights/new-relic-insights/decorating-events/insights-custom-attributes) がある場合は、それらの属性に基づいて絞り込むことができます。たとえば、特に重要な顧客のApdexを監視することができます。

        ```
        SELECT apdex(duration, t: 0.4) FROM Transaction
          WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago
        ```
      </Collapser>

      <Collapser
        id="apdex-transaction"
        title="特定のトランザクションのApdexを取得する"
      >
        `name`属性を使用して特定のトランザクションのスコアを返す、または`name`を省略して総合的なApdexを返します。このクエリは、直近1時間の **Controller/notes/index** トランザクションのApdexスコアを返します。

        ```
        SELECT apdex(duration, t: 0.5) from Transaction
          WHERE name='Controller/notes/index' SINCE 1 hour ago
        ```

        ![crop-apdex-function](./images/screen-apdex-function.png "crop-apdex-function")

        `apdex`関数は、サイトに対するユーザーの満足度を測定する[Apdexスコア](/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction)を返します。引数は、秒単位のレスポンスタイムの属性とApdex Tの閾値です。
      </Collapser>

      <Collapser title="アプリ全体のApdexを取得する">
        このクエリの例では、直近3週間のアプリケーション全体のApdexを返します。

        ```
        SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-average"
    title={<InlineCode>average(attribute)</InlineCode>}
  >
    `average( )`関数を使用して、属性の平均値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数字の値が返されない場合、nullの値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-buckets"
    title={<InlineCode>buckets(attribute, ceiling \[,number of buckets])</InlineCode>}
  >
    `buckets()`関数を使用して、`FACET`句ごとに分割されたデータを、範囲に基づきバケットに集約します。New Relicデータベースの数値として保存される属性ごとにバケットにまとめることができます。

    この関数は 3 つの引数を取ります。

    * 属性名
    * サンプル範囲の最大値。外れ値は最終バケットに表示されます。
    * バケットの合計数

    詳細と例については、[データをバケットに分割](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/segment-your-insights-data-buckets)をご覧ください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-bucket-percentile"
    title={<InlineCode>bucketPercentile(attribute)</InlineCode>}
  >
    `bucketPercentile( )`関数は、Prometheusの[`histogram_quantile`](https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile)関数のNRQL版です。ディメンションメトリックデータとともに使用します。分位数の代わりにNew Relicパーセンタイルを返します。これは分位数\*100です。

    `bucketPercentile( )`関数を使用して、Prometheus形式のヒストグラムデータから分位数を計算します。

    バケット名を引数として取得し、バケットの境界とともにパーセンタイルをレポートします：

    ```
    SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago
    ```

    オプションで、引数としてパーセンタイル指定を追加できます：

    ```
    SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago
    ```

    複数のメトリックスを使用してPrometheusヒストグラムデータを構成しているため、関連する`<basename>`に関して特定のPrometheusメトリックスのクエリを行う必要があります。

    たとえば、PrometheusヒストグラムからNRQLを使用して`<basename>` `prometheus_http_request_duration_seconds`によりパーセンタイルの計算を行うには、`bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50)`を使用します。\_bucketがサフィックスとして`<basename>`の最後に追加されていることに注意してください。

    詳しくは、[Prometheus.ioドキュメント](https://prometheus.io/docs/concepts/metric_types/#histogram)を参照してください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-cardinality"
    title={<InlineCode>cardinality(attribute)</InlineCode>}
  >
    `cardinality( )`関数を使用して、[メトリック](/docs/using-new-relic/data/understand-data/new-relic-data-types#metrics)上のすべてのディメンション（属性）の組み合わせの数を取得します。

    次の3つの引数を取りますが、すべてオプションです：

    * Metric name: ある場合、`cardinality( )`は指定したメトリックのみを計算します。
    * Include: ある場合、Includeリストは、濃度計算をこの属性に制限します。
    * Exclude: ある場合、Excludeリストにより、この属性は濃度計算で使用されなくなります。

    ```
    SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list})
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-count"
    title={<InlineCode>count(\*)</InlineCode>}
  >
    `count（ ）`関数を使用して、利用可能なレコード数を返します。これは単一の引数を受け入れます (`*`、属性、または一定値のいずれか)。現在、一般的なSQL動作に従って、その引数に対する値を持つすべてのレコードを計上します。

    `count（*）`は特定の属性を示すものではないため、結果はデフォルトの「[humanize](/docs/insights/new-relic-insights/managing-dashboards-data/data-formatter-setting-default-formats-numeric-values#format)」形式でフォーマットされます。
  </Collapser>

  <Collapser
    className="freq-link"
    id="derivative"
    title={<InlineCode>derivative(attribute \[,time interval])</InlineCode>}
  >
    `derivative()`は、所定のデータセットの変化率を検索します。最小2乗回帰を使用して変化率を計算し、微分係数を近似します。

    `時間間隔`は、変化率を計算する期間です。たとえば、`derivative(attributeName, 1 minute)`は、1分あたりの変化率を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-dimensions"
    title={<InlineCode>{'dimensions(include: {attributes}, exclude: {attributes})'}</InlineCode>}
  >
    `dimensions( )`関数を使用して、データタイプのすべてのディメンション値を返します。

    オプションの引数を使用して、特定の属性を明示的に含めたり除外したりすることができます：

    * Include: ある場合、includeリストは、`dimensions( )`をそれらの属性に限定します。
    * Exclude: ある場合、`dimensions( )`の計算ではそれらの属性を使用しません。

    ```
    FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions()
    ```

    `FACET`句とともに使用する場合、`dimensions( )`は、未集計クエリでのPrometheusの動作と同様に、イベントタイプで使用できるすべてのファセットについて一意の時系列を生成します。
  </Collapser>

  <Collapser
    className="freq-link"
    title={<InlineCode>earliest(attribute)</InlineCode>}
  >
    `latest（ ）`関数を使用して、指定された時間範囲における属性の最も古い値を返します。

    単一の引数を取ります。最初の引数以外は無視されます。

    `FACET`と併用する場合、この関数は得られた各ファセットの属性の最新値を返します。

    <CollapserGroup>
      <Collapser title="PageView からユーザーエージェントごとに最も古い国を取得">
        このクエリは、PageView イベントからユーザーエージェントごとに最も古い国コードを返します。

        ```
        SELECT earliest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    title={<InlineCode>eventType()</InlineCode>}
  >
    ```
    ...WHERE eventType() = 'EventNameHere'...
    ...FACET eventType()...
    ```

    `eventType()`関数は、選択したデータタイプ別に結果を取り出すために[FACET](#sel-facet)句で使用、または特定のデータタイプに結果をフィルタリングするために[WHERE](#sel-where)句で使用します。これは [filter()](#func-filter) や [percentage()](#func-percentage) 関数で特定のデータタイプを対象とする際に特に便利です。

    <Callout variant="important">
      この文脈において、「イベントタイプ」はNRQLクエリでアクセス可能なデータタイプを指します。
    </Callout>

    <CollapserGroup>
      <Collapser
        id="filter-eventtype"
        title={<><InlineCode>filter()</InlineCode>関数で<InlineCode>eventType()</InlineCode>を使用する</>}
      >
        このクエリは、合計`Transaction`の結果あたりの合計`TransactionError`の結果の割合を返します。`eventType()`関数を使用して、filter()関数で特定のデータタイプをターゲットにすることができます。

        ```
        SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago
        ```
      </Collapser>

      <Collapser
        id="facet-eventtype"
        title={<><InlineCode>FACET</InlineCode>で<InlineCode>eventType()</InlineCode>を使用する</>}
      >
        このクエリは、各データタイプ（`Transaction`および`TransactionError`）が返すレコードの数を表示します。

        ```
        SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-filter"
    title={<InlineCode>filter(function(attribute), WHERE condition)</InlineCode>}
  >
    `filter（ ）`関数を使用して、SELECT文内の集計関数の1つに結果を制限できます。`filter()`は、`FACET`または`TIMESERIES`と併用することができます。

    <CollapserGroup>
      <Collapser title="オファーコードを使用した購入を分析する">
        `filter()`は、一連のトランザクションで購入された商品の中で、オファーコードを使用して購入された商品と、オファーコードを使用せずに購入された商品を比較するために使用できます：

        ![Insightsフィルタのスクリーンショット](./images/screenshot_insights_filter_0_0.png "Insightsフィルタのスクリーンショット")

        `filter（ ）`関数を使用して、SELECT文内の集計関数の1つに結果を制限できます。
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-funnel"
    title={<InlineCode>funnel(attribute, steps)</InlineCode>}
  >
    `funnel()`関数を使用して、ファネルチャートを生成します。属性を最初に引数に取ります。その後、カンマで区切られた複数の[`WHERE`](#sel-where)句（オプションでラベル付け用に[`AS`](#sel-as)句を含める）をステップとして指定します。

    詳細な情報と例については、 [ファネルのドキュメント](/docs/insights/nrql-new-relic-query-language/nrql-query-examples/funnels-evaluate-data-series-events)をご覧ください。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-get-field"
    title={<InlineCode>getField(attribute, field)</InlineCode>}
  >
    `getField()`関数を使用して、[複雑なメトリックス](/docs/using-new-relic/data/understand-data/new-relic-data-types)からフィールドを抽出します。

    次の引数を取ります：

    <Table style={{ width: "500px" }}>
      <thead>
        <tr>
          <th>
            メトリックのタイプ
          </th>

          <th>
            サポートされたフィールド
          </th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>
            `summary`
          </td>

          <td>
            count、total、max、min
          </td>
        </tr>

        <tr>
          <td>
            `gauge`
          </td>

          <td>
            count、total、max、min、latest
          </td>
        </tr>

        <tr>
          <td>
            `distribution`
          </td>

          <td>
            count、total、max、min
          </td>
        </tr>

        <tr>
          <td>
            `counter`
          </td>

          <td>
            count
          </td>
        </tr>
      </tbody>
    </Table>
  </Collapser>

  <dd>
    例：

    ```
    SELECT max(getField(mySummary, count)) from Metric
    ```

    ```
    SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10
    ```
  </dd>

  <Collapser
    className="freq-link"
    id="func-histogram"
    title={<InlineCode>histogram(attribute, ceiling \[,number of buckets])</InlineCode>}
  >
    `histogram（ ）`関数を使用して、ヒストグラムを生成します。この関数は 3 つの引数を取ります。

    * 属性名
    * サンプル範囲の最大値
    * バケットの合計数

    <CollapserGroup>
      <Collapser
        id="histogram-response-times"
        title="PageViewイベントからのレスポンスタイムのヒストグラム"
      >
        このクエリは 20 バケットにわたって 10 秒以内のレスポンスタイムのヒストグラムを生成します。

        ```
        SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago
        ```
      </Collapser>

      <Collapser
        id="histogram-prometheus"
        title="Prometheusヒストグラムバケット"
      >
        `histogram( )`では、Prometheusヒストグラムバケットを受け取ります:

        ```
        SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago
        ```
      </Collapser>

      <Collapser
        id="distribution-metric"
        title="New Relicディストリビューションメトリック"
      >
        `histogram( )`では[ディストリビューションメトリックを](/docs/data-ingest-apis/get-data-new-relic/metric-api/events-metrics-service-create-metrics#limits-rules)入力として受け取ります:

        ```
        SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="keyset"
    title={<InlineCode>keyset()</InlineCode>}
  >
    `keyset()`を使用すると、所定の時間範囲における所定のデータタイプに対するすべての属性を表示できます。この関数は引数を取りません。文字列型キー、数値型キー、ブーリアン型キー、およびすべてのキーをグループ化した JSON 構造体を返します。

    <CollapserGroup>
      <Collapser title="データタイプのすべての属性を表示">
        このクエリは、最後の日からの`PageView`イベントで見つかった属性を返します：

        ```
        SELECT keyset() FROM PageView SINCE 1 day ago
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    title={<InlineCode>latest(attribute)</InlineCode>}
  >
    `latest（ ）`関数を使用して、指定された時間範囲における属性の最新値を返します。

    単一の引数を取ります。最初の引数以外は無視されます。

    `FACET`と併用する場合、この関数は得られた各ファセットの属性の最新値を返します。

    <CollapserGroup>
      <Collapser title="PageView からユーザーエージェントごとに最新の国を取得">
        このクエリは、PageView イベントからユーザーエージェントごとに最新の国コードを返します。

        ```
        SELECT latest(countryCode) FROM PageView FACET userAgentName
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-max"
    title={<InlineCode>max(attribute)</InlineCode>}
  >
    `max（ ）`関数を使用して、指定された時間範囲内に記録された数値属性の最大値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数字の値が返されない場合、nullの値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-median"
    title={<InlineCode>median(attribute)</InlineCode>}
  >
    `median( )`関数を利用して、属性の中央値あるいは50パーセンタイルを返します。パーセンタイルクエリの詳細に関しては、[percentile()](#func-percentile)を参照してください。

    <Callout variant="tip">
      `median( )`クエリは、[クエリビルダー](/docs/chart-builder/use-chart-builder/get-started/introduction-chart-builder)を利用する場合にのみ利用できます。
    </Callout>

    <CollapserGroup>
      <Collapser title="中央値クエリ">
        このクエリは、中央値に関する折れ線グラフを生成します。

        ```
        SELECT median(duration) FROM PageView TIMESERIES AUTO
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-min"
    title={<InlineCode>min(attribute)</InlineCode>}
  >
    `min（ ）`関数を使用して、指定された時間範囲内に記録された数値属性の最小値を返します。引数として単一の属性名を取得します。属性の値が数字でない場合、集計の際に無視されます。クエリの条件に合うデータが見つからない場合、またはクエリにより数字の値が返されない場合、nullの値を返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentage"
    title={<InlineCode>percentage(function(attribute), WHERE condition)</InlineCode>}
  >
    `percentage（ ）`関数を使用して、いくつかの条件に一致する目的のデータセットの割合を返します。

    最初の引数には、目的の属性に対する[集計関数](#functions)が必要です。必ず2つの引数を使用してください（最初の 2 つ以外の引数は無視されます）。属性が数値でない場合、この関数は 100% を値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-percentile"
    title={<InlineCode>percentile(attribute \[, percentile \[, ...]])</InlineCode>}
  >
    `percentile（ ）`関数を使用して、所定の指定パーセンタイルでの属性の概算値を返します。この関数は属性が必須であり、パーセンタイル点を表す引数はいくつでも指定できます。`percentile()` 関数は、小数点以下3桁までの表示を可能にすることで、より厳密な内容を提供できます。パーセンタイルの閾値は小数点値として指定される場合があるものの、大半のデータセットにおいて、互いに0.1よりも近いパーセンタイルは解決されない点に注意してください。

    ![percentile.png](./images/percentile_0.png "percentile.png")

    パーセンタイルの表示例

    `TIMESERIES`を使用して、時系列でマッピングされたパーセンタイルで折れ線グラフを生成します。

    * `TIMESERIES`を省略して、パーセンタイルの集計値を示すビルボードと属性シートを生成します。

    パーセンタイルが指定されていない場合、デフォルトで 95 パーセンタイルとなります。50パーセンタイル値、つまり中央値のみを返すには、[median()](#func-median)を使用することもできます。

    <CollapserGroup>
      <Collapser title="基本的なパーセンタイルのクエリ">
        このクエリは 5、50、95 パーセンタイルの折れ線を表示する折れ線グラフを生成します。

        ```
        SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="predictLinear"
    title={<InlineCode>predictLinear(attribute, \[,time interval])</InlineCode>}
  >
    `predictLinear()`は、`derivative()`関数の拡張です。同様の方法の最小2乗線形回帰を使用して、データセットの将来値を予測します。

    * `時間間隔`は、クエリでどの程度将来まで扱うかを表します。たとえば、`predictLinear(attributeName, 1 hour)`は、1時間の線形予想をクエリの時間枠の将来に当てはめます。
    * 一般に、`predictLinear()`は、ディスクスペースのような増加が続く値や大きなトレンドの予想などで有用です。
    * `predictLinear()`は線形回帰のため、クエリを行っているデータセットに習熟していると、正確な長期的な予想を行えます。
    * 指数的または対数的、その他の非線形的に増加するデータセットでは、非常に短期的な予想でのみ有効な可能性が高いと言えます。
    * New Relicでは、`TIMESERIES`クエリで`predictLinear`を使用することを推奨していません。これは、各バケットがクエリ内の相対的な期間に基づき個別に予想を行う、つまり、そうしたクエリは時系列終了以後の予想は示さないためです。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-rate"
    title={<InlineCode>rate(function(attribute) \[,time interval])</InlineCode>}
  >
    `rate ()`関数を使用して、時間間隔ごとに所定のクエリの頻度またはレートを視覚化します。たとえば、1 時間の 1 分あたりのページビュー数や 1 日間の 1 時間あたりのサイトのユニークセッション数を把握したい場合があるかもしれません。

    * [`TIMESERIES`](#sel-timeseries)を使用して、時系列でマッピングされたレートで折れ線グラフを生成します。
    * [`TIMESERIES`](#sel-timeseries)を省略して、時系列で平均化された単一のレート値を示すビルボードを生成します。

    <CollapserGroup>
      <Collapser title="基本的な評価クエリ">
        このクエリは、過去 6 時間の 10 分あたりの APM トランザクションのスループット評価を示す折れ線グラフを生成します。

        ```
        SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago 
        TIMESERIES
        ```
      </Collapser>
    </CollapserGroup>
  </Collapser>

  <Collapser
    className="freq-link"
    id="round"
    title={<InlineCode>round(attribute)</InlineCode>}
  >
    `round( )`関数を使用して、属性の丸め値を返します。

    オプションで、`round( )`は2番目の引数`to_nearest`を取り、最初の引数を2番目の引数の最も近い倍数に切り上げます。`to_nearest`は分数でも使用できます。

    ```
    SELECT round(n [, to_nearest])
    ```
  </Collapser>

  <Collapser
    className="freq-link"
    id="stddev"
    title={<InlineCode>stddev(attribute)</InlineCode>}
  >
    `stddev()`関数を使用して、指定された時間範囲内に記録された数値属性の[標準偏差値](https://en.wikipedia.org/wiki/Standard_deviation)を返します。単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="stdvar"
    title={<InlineCode>stdvar(attribute)</InlineCode>}
  >
    `stdvar()`関数を使用して、指定された時間範囲内に記録された数値属性の[標準分散](https://en.wikipedia.org/wiki/Variance)を返します。

    単一の引数を取ります。属性が数値でない場合は、ゼロを値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-sum"
    title={<InlineCode>sum(attribute)</InlineCode>}
  >
    `sum（ ）`関数を使用して、指定された時間範囲内に記録された数値属性の合計値を返します。

    単一の引数を取ります。最初の引数以外は無視されます。属性が数値でない場合は、ゼロを値として返します。
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniqueCount"
    title={<InlineCode>uniqueCount(attribute)</InlineCode>}
  >
    `uniqueCount（ ）`関数を使用して、指定された時間範囲内に記録された属性のユニーク値の数を返します。

    <Callout variant="tip">
      クエリのパフォーマンスを最適化するため、この関数は256を超えるユニーク値を検査するクエリのおおよその結果を返します。
    </Callout>
  </Collapser>

  <Collapser
    className="freq-link"
    id="func-uniques"
    title={<><InlineCode>uniques(attribute \[,limit]</InlineCode><InlineCode>)</InlineCode></>}
  >
    `uniques（ ）`関数を使用して、指定された時間範囲内に記録された属性のユニーク値のリストを返します。`facet`句と共に使用すると、各ファセット値ごとに固有の属性値一覧が返されます。

    `limit`パラメータは任意です。これが提供されない場合、ファセットあたり1,000の固有の属性値がデフォルトリミットとして適用されます。最大10,000までの、別の`limit`を指定することもできます。`uniques( )`関数は、上限に達するまで、発見した固有の属性値の最初の一式を返します。このため、データセットに5,000の固有の属性値があり、上限が1,000に設定されている場合、演算子はその頻度に関わらず、発見した最初の1,000の固有の値を返します。

    クエリ結果で返すことのできる最大数は、`uniques( )`上限と`facet`上限を掛け合わせたものになります。以下のクエリでは、論理的に返すことの可能な最大値は500万になります（5,000 x 1,000）。

    ```
    From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000
    ```

    しかし、クエリしたデータセットのほか、クエリの複雑さ次第では、メモリ保護上限の影響で非常に大きなクエリの実行を阻止する可能性があります。
  </Collapser>
</CollapserGroup>

## データ型変換 [#type-conversion]

NRQLは「型強制」をサポートしていません。つまり、文字列として保存された浮動小数点は文字列として取り扱われ、浮動小数点数を要求する関数に渡しても操作できません。

次に示す関数を用いることで、数値を伴う文字列、または文字列を伴うブーリアン値をそれぞれ数またはブーリアン値に変換できます。

* `numeric()` 関数を用いて、文字列形式の数値を数値関数に変換します。この関数は、クエリ結果に数学関数を使用するクエリ、もしくは`average()`などのNRQL 集計関数に組み込むことができます。
* `boolean()`関数を用いることで、「true」もしくは「false」の文字列値を対応するブーリアン値に変換できます。

## その他のヘルプ [#more_help]

さらに支援が必要な場合は、これらのサポートと学習リソースを確認してください：

* [Explorers Hub](https://discuss.newrelic.com/)を参照して、コミュニティから支援を受け、ディスカッションに参加してください。
* [当社のサイトで回答を見つけ、サポートポータルの使用方法について学びます](/docs/using-new-relic/welcome-new-relic/get-started/find-help-use-support-portal)。
* Linux、Windows、およびmacOSのトラブルシューティングツールである[New Relic Diagnosticsを実行します](/docs/using-new-relic/cross-product-functions/troubleshooting/new-relic-diagnostics)。
* New Relicの[データセキュリティ](/docs/security)と[ライセンス](/docs/licenses)ドキュメントを見直してください。
