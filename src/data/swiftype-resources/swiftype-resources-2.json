{
  "/docs/agents/go-agent/instrumentation/instrument-go-transactions": [
    {
      "sections": [
        "Create custom events (Go)",
        "RecordCustomEvent parameters",
        "Example"
      ],
      "title": "Create custom events (Go)",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Instrumentation"
      ],
      "external_id": "51ae4a409139b08f5a2df59d9c379d425d21d97a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/features/create-custom-events-go/",
      "published_at": "2021-10-18T03:46:41Z",
      "updated_at": "2021-06-02T15:17:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Custom events are useful to explore data for a single event you are interested in, including data from external sources, at a particular moment in time. To track arbitrary event data for apps monitored by your New Relic Go agent, add RecordCustomEvent to the apps. You can then query and visualize the event data. RecordCustomEvent parameters To add RecordCustomEvent to your Go app, use this format: RecordCustomEvent(eventType string, params map[string]interface{}) Copy Parameter Description eventType string Required. The name of the event type to record. Must consist of alphanumeric characters, underscores _, or colons :. Must contain no more than 255 bytes. Must follow New Relic data equirements for names, limits, and restricted characters. params map number, string, or boolean Required. Specify key/value pairs of attributes to annotate the event. Each value in the params map must be a number, string, or boolean. Keys must be less than 255 bytes. The params map must not contain more than 64 attributes. Example Here is an example of a custom event for a Go app: func customEvent(w http.ResponseWriter, r *http.Request) { io.WriteString(w, \"recording a custom event\") app.RecordCustomEvent(\"my_event_type\", map[string]interface{}{ \"myString\": \"hello\", \"myFloat\": 0.603, \"myInt\": 123, \"myBool\": true, }) } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.71702,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create custom events (<em>Go</em>)",
        "sections": "Create custom events (<em>Go</em>)",
        "tags": "<em>Go</em> <em>agent</em>",
        "body": "Custom events are useful to explore data for a single event you are interested in, including data from external sources, at a particular moment in time. To track arbitrary event data for apps monitored by your New Relic <em>Go</em> <em>agent</em>, add RecordCustomEvent to the apps. You can then query and visualize"
      },
      "id": "6043d7e028ccbcd7dc2c60d3"
    },
    {
      "sections": [
        "Go agent attributes",
        "host.displayName",
        "httpResponseCode",
        "Important",
        "request.headers.accept",
        "request.headers.contentLength",
        "request.headers.contentType",
        "request.headers.host",
        "request.headers.referer",
        "request.headers.User-Agent",
        "request.headers.userAgent",
        "request.method",
        "response.headers.contentLength",
        "response.headers.contentType",
        "http.statusCode",
        "Span and segment attributes",
        "db.collection",
        "db.instance",
        "db.statement",
        "http.method",
        "http.url",
        "peer.address",
        "peer.hostname",
        "Change attribute destination",
        "Turn destinations on or off",
        "Turn attributes on or off",
        "Create custom attributes",
        "For more help"
      ],
      "title": "Go agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Instrumentation"
      ],
      "external_id": "f6e6d25a949481b15a5beb78c962303857d713a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/instrumentation/go-agent-attributes/",
      "published_at": "2021-10-18T02:17:35Z",
      "updated_at": "2021-03-16T13:46:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information for transaction events, error events, and traced errors. You can adjust the destinations of default attributes and create custom attributes for the attributes collected by New Relic's Go language agent, including: Error traces Transaction events Page views For an extra level of monitoring detail, create custom attributes. Go agent attributes The Go agent receives the following default attributes from your app. You can adjust these default settings and turn attributes on or off for certain destinations. host.displayName The name of the server host under which the current script is executing, called with newrelic.AttributeHostDisplayName. Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeHostDisplayName) Copy httpResponseCode The response status code for a web request, called with newrelic.AttributeResponseCodeDeprecated Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeResponseCodeDeprecated) Copy Important As of Go agent v3.0.0, this attribute has been marked deprecated and been renamed to http.statusCode. The v3.x agent will continue to produce this attribute, but it will be removed in v4.0.0. request.headers.accept The type as read from the HTTP request's Accept header, called with newrelic.AttributeRequestAccept Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeRequestAccept) Copy request.headers.contentLength The incoming request size in bytes as read from the Content-Length request header, called with newrelic.AttributeRequestContentLength. Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeRequestContentLength) Copy request.headers.contentType The incoming request content type as read from the Content-Type request header, called with newrelic.AttributeRequestContentType. Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeRequestContentType) Copy request.headers.host The name from the HTTP host request header, called with newrelic.AttributeRequestHost. Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeRequestHost) Copy request.headers.referer The incoming request referer as read from the Referer request header, called with newrelic.AttributeRequestReferer. Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeRequestReferer) Copy request.headers.User-Agent The contents of the User-Agent HTTP header, called with newrelic.AttributeRequestUserAgentDeprecated Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeRequestUserAgentDeprecated) Copy Important As of Go agent v3.0.0, this attribute has been marked deprecated and been renamed to request.headers.userAgent. The v3.x agent will continue to produce this attribute, but it will be removed in v4.0.0. request.headers.userAgent The contents of the User-Agent HTTP header, called with newrelic.AttributeRequestUserAgent Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Disabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeRequestUserAgent) Copy Important This attribute was added in v3.0.0 of the agent and the original request.headers.User-Agent will eventually be removed. Therefore the v3.x agents will produce two attributes representing the the contents of the User-Agent HTTP header. To completely exclude the attribute when using the v3.x agent, you must include both the old and new attributes. For example: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeRequestUserAgent, newrelic.AttributeRequestUserAgentDeprecated, ) Copy request.method The HTTP method of the incoming request, called with newrelic.AttributeRequestMethod Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeRequestMethod) Copy response.headers.contentLength The outgoing response size in bytes as read from the Content-Length response header, called with newrelic.AttributeResponseContentLength. Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeResponseContentLength) Copy response.headers.contentType The outgoing response content-type as read from the Content-Type response header, called with newrelic.AttributeResponseContentType. Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeResponseContentType) Copy http.statusCode The response status code for a web request, called with newrelic.AttributeResponseCode Default settings: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeResponseCode) Copy Important This attribute was added in v3.0.0 of the agent and the original httpResponseCode will eventually be removed. Therefore the v3.x agents will produce two attributes representing the response status code for a web request. To completely exclude the attribute when using the v3.x agent, you must include both the old and new attributes. For example: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeResponseCode, newrelic.AttributeResponseCodeDeprecated, ) Copy Span and segment attributes If you have Go agent v2.6.0 or higher, you can configure attributes on spans and segments. The Go agent receives the following default attributes from your app. These attributes are only found on span events and transaction trace segments. You can adjust these default settings and turn attributes on or off for certain destinations. db.collection For datastore segments, this is the collection used and represents the table or group, called with newrelic.SpanAttributeDBCollection. Default settings: Transaction trace segments: Enabled Span events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.SpanAttributeDBCollection) Copy db.instance For datastore segments this is the database name and represents the name of the database where the query is being executed, called with newrelic.SpanAttributeDBInstance. Default settings: Transaction trace segments: Enabled Span events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.SpanAttributeDBInstance) Copy db.statement For datastore segments this is the parameterized query being executed and represents the query being performed, called with newrelic.SpanAttributeDBStatement. Default settings: Transaction trace segments: Enabled Span events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.SpanAttributeDBStatement) Copy http.method For external segments this is the http method of the outgoing request, called with newrelic.SpanAttributeHTTPMethod. Default settings: Transaction trace segments: Enabled Span events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.SpanAttributeHTTPMethod) Copy http.url For external segments this is the url of the outgoing request, called with newrelic.SpanAttributeHTTPURL. Default settings: Transaction trace segments: Enabled Span events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.SpanAttributeHTTPURL) Copy peer.address For datastore segments this is the hostname plus port of the database being queried, called with newrelic.SpanAttributePeerAddress. Default settings: Transaction trace segments: Enabled Span events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.SpanAttributePeerAddress) Copy peer.hostname For datastore segments this is the hostname of the database being queried, called with newrelic.SpanAttributePeerHostname. Default settings: Transaction trace segments: Enabled Span events: Enabled Example of excluding this attribute: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.SpanAttributePeerHostname) Copy Change attribute destination Use these options to change attribute destinations: Turn destinations on or off To open or close an entire destination to attributes, set the .Enabled flag to true or false. For example, to turn off APM error collection: After the config, add: config.ErrorCollector.Attributes.Enabled = false Copy Turn attributes on or off To turn specific attributes on or off, use the .Include or .Exclude methods. For example, to disable AttributeResponseCode: After the config, add: config.Attributes.Exclude = append(config.Attributes.Exclude, newrelic.AttributeResponseCode) Copy Create custom attributes Add custom attributes by using this method in a transaction: txn.AddAttribute(\"key\", \"value\") Copy The txn variable is the one instrumented for the Go transaction. For example: txn.AddAttribute(\"product\", \"widget\") txn.AddAttribute(\"price\", 19.99) txn.AddAttribute(\"importantCustomer\", true) Copy Default settings for custom attribute destinations: Error collector (traced errors): Enabled Transaction events: Enabled For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.898285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Go</em> <em>agent</em> attributes",
        "sections": "<em>Go</em> <em>agent</em> attributes",
        "tags": "<em>Go</em> <em>agent</em>",
        "body": "Attributes are key-value pairs containing information for transaction events, error events, and traced errors. You can adjust the destinations of default attributes and create custom attributes for the attributes collected by New Relic&#x27;s <em>Go</em> language <em>agent</em>, including: Error traces Transaction events"
      },
      "id": "603e9f8028ccbcaa6ceba76d"
    },
    {
      "sections": [
        "Create custom metrics in Go",
        "Create a custom metric",
        "Name a custom metric",
        "For more help"
      ],
      "title": "Create custom metrics in Go",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Instrumentation"
      ],
      "external_id": "9336bef71f0cac25636bfe0b4392864f3605c6a8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/instrumentation/create-custom-metrics-go/",
      "published_at": "2021-10-18T02:18:32Z",
      "updated_at": "2021-03-11T08:14:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Custom metrics allow you to report any metric that passes through your code. For example, with New Relic's Go monitoring, you can create custom metrics to time a component of your app that may not captured by default. Once you capture a custom metric, you can: Unify your monitoring inside New Relic through the data explorer. Use our REST API to programmatically retrieve and use custom metric data outside of the UI. Create custom metric alert conditions to notify you or your team when your custom metric exceeds specific values. Create a custom metric Instantiate your application by running the following: cfg := newrelic.NewConfig(\"Your App Name\", mustGetEnv(\"NEW_RELIC_LICENSE_KEY\")) cfg.Logger = newrelic.NewDebugLogger(os.Stdout) var err error app, err = newrelic.NewApplication(cfg) Copy After instantiating your app, create a custom metric with the following code: app.RecordCustomMetric( \"CustomMetricName\", //name of your metric 132, //time in ms ); Copy RecordCustomMetric's first parameter is a string that names your custom metric. The RecordCustomMetric method will automatically prepend the string Custom/ to your metric name. This means the above code will generate a metric named Custom/CustomMetricName. RecordCustomMetric's second parameter is the time, in milliseconds, that you want to record for your custom transaction. This means the above code will produce a metric of .132 seconds in New Relic's systems. To use a custom metric as a counter, it can be incremented by making the call as described above, and the count value for that metric will be incremented by 1. The value you use for the second parameter (time in ms) is irrelevant if you are only using the metric as a counter, and thus you can use a static number, such as 0 or 1. To increment a counter by a number greater than 1, call app.RecordCustomMetric multiple times - each call will only increment the metric by 1 no matter what the value of the second parameter is. Name a custom metric Carefully consider how you name your custom metrics. If your program creates too many uniquely-named metrics, you may end up with a metric grouping issue (MGI). MGIs occur when the granularity of metric names is too fine, resulting in hundreds or thousands of different metric names. One common cause of MGIs is relying on the full URL name for metric naming in web transactions. A few major code paths may generate many different full URL paths to unique documents, articles, page, etc. If the unique element of the URL path is included in the metric name, each of these common paths will have its own unique metric name. If metric grouping issues occur, follow the troubleshooting procedures. For more help Additional documentation resources include: New Relic for Go segment documentation on GitHub (more details about instrumenting segments on New Relic GitHub) Instrument Go transactions (how to create New Relic transactions in your Go app)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.77753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create custom metrics in <em>Go</em>",
        "sections": "Create custom metrics in <em>Go</em>",
        "tags": "<em>Go</em> <em>agent</em>",
        "body": " Additional documentation resources include: New Relic for <em>Go</em> segment documentation on GitHub (more details about instrumenting segments on New Relic GitHub) <em>Instrument</em> <em>Go</em> transactions (how to create New Relic transactions in your <em>Go</em> app)"
      },
      "id": "6043b8f628ccbc48692c609c"
    }
  ],
  "/docs/agents/go-agent/troubleshooting/no-data-appears-go": [
    {
      "sections": [
        "Go agent logging",
        "Write log files",
        "Logrus integration example",
        "For more help"
      ],
      "title": "Go agent logging",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Configuration"
      ],
      "external_id": "3eca4ea8f4b58b64841e4c465cbacde5c897de10",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/configuration/go-agent-logging/",
      "published_at": "2021-10-18T05:33:31Z",
      "updated_at": "2021-03-11T12:43:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Go logging uses the standard Go log package and a New Relic Logger package. Logging is useful for troubleshooting your New Relic integration; for example, with installation or configuration problems. Write log files To use the Go agent methods for writing log and audit files, see log.go on the agent GitHub repo. Logrus integration example New Relic offers an integration for the Logrus logging system. Here is an example of using the New Relic Logrus integration in an application: Import both github.com/sirupsen/logrus and github.com/newrelic/go-agent/v3/integrations/nrlogrus. Set the log level and assign the Logger output to Logrus. For example: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { logrus.SetLevel(logrus.DebugLevel) config.Logger = nrlogrus.StandardLogger() }, ) Copy For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.239395,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Go</em> <em>agent</em> logging",
        "sections": "<em>Go</em> <em>agent</em> logging",
        "tags": "<em>Go</em> <em>agent</em>",
        "body": "New Relic for <em>Go</em> logging uses the standard <em>Go</em> log package and a New Relic Logger package. Logging is useful for <em>troubleshooting</em> your New Relic integration; for example, with installation or configuration problems. Write log files To use the <em>Go</em> <em>agent</em> methods for writing log and audit files, see"
      },
      "id": "6043f284196a67c735960f7f"
    },
    {
      "sections": [
        "Install New Relic for Go",
        "Compatibility and requirements",
        "Install the Go agent",
        "View your app's data in New Relic",
        "Keep your agent up to date"
      ],
      "title": "Install New Relic for Go ",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Installation"
      ],
      "external_id": "1fe1294fee3ba819e696f667f6a4eebaba8f9221",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/installation/install-new-relic-go/",
      "published_at": "2021-10-18T02:15:38Z",
      "updated_at": "2021-08-02T04:17:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Go agent auto-instruments your code so you can start monitoring your Go language apps and microservices. You can use our launcher, or follow the instructions in this document to complete a basic Go agent installation. If you don't have one already, create a New Relic account. It's free, forever. Add Go data Compatibility and requirements The Go agent requires Golang 1.7 or higher on Linux, macOS, or Windows. For more information, see Go agent compatibility and requirements. Install the Go agent In order to install the Go agent, you need a New Relic license key. Then, to install the agent: From github.com/newrelic/go-agent, use your preferred process; for example: go get github.com/newrelic/go-agent/v3/newrelic Copy Import the github.com/newrelic/go-agent/v3/newrelic package in your application. Initialize the Go agent by adding the following in the main function or in an init block: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), ) Copy Instrument web transactions by wrapping standard HTTP requests in your app code. For example: http.HandleFunc(newrelic.WrapHandleFunc(app, \"/users\", usersHandler)) Copy Instrument other transactions you want to monitor. Optional: Instrument segments for an extra level of timing detail. Compile and deploy your application. View your app's data in New Relic Wait a few minutes for your application to send data to New Relic. Then, check your app's performance in the APM UI. If no data appears within a few minutes, follow the troubleshooting tips. Keep your agent up to date To take full advantage of New Relic's latest features, enhancements, and important security patches, keep your app's Go agent up to date.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.77232,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install New Relic for <em>Go</em> ",
        "sections": "Install the <em>Go</em> <em>agent</em>",
        "tags": "<em>Go</em> <em>agent</em>",
        "body": "&#x27;s performance in the APM UI. If no data appears within a few minutes, follow the <em>troubleshooting</em> tips. Keep your <em>agent</em> up to date To take full advantage of New Relic&#x27;s latest features, enhancements, and important security patches, keep your app&#x27;s <em>Go</em> <em>agent</em> up to date."
      },
      "id": "6043cf6428ccbc98632c60c6"
    },
    {
      "sections": [
        "Go runtime page: Troubleshoot performance problems",
        "View and filter Go runtime data",
        "Go runtime charts"
      ],
      "title": "Go runtime page: Troubleshoot performance problems",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Features"
      ],
      "external_id": "de13cce9b7e936dd86b266c3bae1b031a2343aa2",
      "image": "https://docs.newrelic.com/static/1eae071363cd2ce3e57467c3d1cce83f/c1b63/go-runtime.png",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/features/go-runtime-page-troubleshoot-performance-problems/",
      "published_at": "2021-10-18T03:05:22Z",
      "updated_at": "2021-03-16T13:45:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The APM user interface provides a variety of data about your app, including special features for the Go agent for APM. In addition, the Go runtime page provides important runtime data useful for troubleshooting performance issues. View and filter Go runtime data To view the Go runtime page, go to one.newrelic.com > APM > (select an app) > Go runtime. Go runtime charts This table describes the Go runtime page chart data. Chart name Description Goroutines A count of the average number of goroutines running during a given time slice. GC pause time Milliseconds spent in stop-the-world garbage collection. GC pause frequency Calls per minute of stop-the-world garbage collection. GC pauses The percentage of wall-clock time spent in stop-the-world garbage collection. CPU utilization CPU utilization as a percentage of available CPU. Memory Average memory used, in mebibytes, during a given time slice.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.23567,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Go</em> runtime page: <em>Troubleshoot</em> performance problems",
        "sections": "<em>Go</em> runtime page: <em>Troubleshoot</em> performance problems",
        "tags": "<em>Go</em> <em>agent</em>",
        "body": "The APM user interface provides a variety of data about your app, including special features for the <em>Go</em> <em>agent</em> for APM. In addition, the <em>Go</em> runtime page provides important runtime data useful for <em>troubleshooting</em> performance issues. View and filter <em>Go</em> runtime data To view the <em>Go</em> runtime page, <em>go</em>"
      },
      "id": "603ecf06e7b9d25d8a2a07c9"
    }
  ],
  "/docs/agents/index": [
    {
      "sections": [
        "Enable configurable security policies",
        "Important",
        "Compatibility and requirements",
        "Caution",
        "Example configuration",
        "Java agent: YAML example",
        ".NET agent: XML example",
        "Ruby agent: YAML example",
        "Available policy options",
        "For more help"
      ],
      "title": "Enable configurable security policies",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "1f645201e6e79a35f84334b11415e8a2a0edf665",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/enable-configurable-security-policies/",
      "published_at": "2021-10-18T02:27:11Z",
      "updated_at": "2021-09-14T14:49:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important APM's configurable security policies is available in limited release for approved New Relic accounts. APM's configurable security policies gives you granular control over configuration options related to your account's data security. This document explains how to enable account-wide security policies and the options available. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Compatibility and requirements APM agent versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security policies Caution Security policies apply account-wide. Once enabled, they can only be edited or disabled with the help of New Relic support. If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your APM agent's high security mode, which is set in the configuration file. High security mode and configurable security policies do not apply to Lambda monitoring or use of the New Relic Event API. For the limited release, there is no UI component. If you are participating in the limited release, follow this procedure to set up your accounts: Choose the accounts on which to enable configurable security policies. Choose the configurable security policies options that you want for those accounts. Inform your New Relic sales rep of the options that you have chosen. Ensure your agent versions support this feature. Update agents if necessary. When you receive the security token based on the security policies options that you chose, insert the security token into the agent configuration file(s). See examples. Delete the high security mode enabled flag from your config file(s). High security mode (HSM) at the agent level is different than high security mode at the account level. Be sure to disable HSM in the agent's config file, as explained in this procedure. Having both the security token and the HSM flag will result in the agent disconnecting. Example configuration Here are some example configuration examples for enabling the configurable security policies: Java agent: YAML example The Java agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy .NET agent: XML example The .NET agent uses a XML file for configuration. Here is an example snippet enabling security policies: ... <configuration agentenabled=\"true\" xmlns=\"urn:newrelic-config\"> <service licensekey=\"YOUR_LICENSE_KEY\"> <application> <name>YOUR_APPLICATION_NAME</name> </application> <securityPoliciesToken>YOUR_TOKEN</securityPoliciesToken> <log level=\"info\"> </log></service></configuration> ... Copy If you prefer to use an environment variable, it would look like this: NEW_RELIC_SECURITY_POLICIES_TOKEN=YOUR_TOKEN Copy Ruby agent: YAML example The Ruby agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy Available policy options Here are the settings you can choose when creating your policies. Some of these options will not be available for some agents. Setting Effect Database query collection Options: Enabled: Collects obfuscated database query data. Obfuscated queries generally appear along with slow query details in the APM or New Relic One UI. Disabled: Prevents the collection of obfuscated database query data. Raw query data is not collected once configurable security policies is enabled. attributes.include list Go, Java, .NET, Node.js, Ruby only Options: Enabled: attributes.include list functions normally; attribute keys found in the attributes.include list are recorded. Disabled: Ignores the list of allowed attributes listed in the attributes.include property in agent configuration; no intrinsic request parameter attributes will be collected. Whitelisting attributes at the account level is not supported. Raw exception messages Options: Enabled: Allows recording of all raw exception messages. Disabled: Prevents recording of all raw exception messages. The messages may be either obfuscated or completely removed, depending on the agent. Custom events Options: Enabled: Allows the recording of custom events that are created and sent up via an agent API. Disabled: Prevents recording of any custom events collect by an agent API. Custom attributes Options: Enabled: Allows for the collection of custom attributes passed in by the New Relic agent. Disabled: Prevents collection of custom attributes that are collected by the New Relic agent. Custom instrumentation editor Java only Options: Enabled: Allows custom instrumentation of the agent, using the custom instrumentation editor. Disabled: Prevents custom instrumentation of the agent using the custom instrumentation editor. Instrumentation previously done via the editor is also disabled. Access to the custom instrumentation editor is only available to New Relic account Owners and Admins. Message parameters Java and Ruby only Options: Enabled: Allows the collection of message parameters (message.parameters.*). Disabled: Prevents collection of message parameters. Job arguments Ruby only Options: Enabled: Allows the collection of job arguments (job.(type).args.*). Disabled: Prevents the collection of job arguments. For more help For more information about configuration file settings, refer to your specific agent's documentation. If you are a New Relic customer and interested in the limited release of configurable security policies, contact your New Relic sales rep.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 329.34473,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Java <em>agent</em>: YAML example",
        "tags": "Manage <em>APM</em> <em>agents</em>",
        "body": " security policies and the options available. For more information about New Relic&#x27;s security measures, see our security and privacy documentation, or visit the New Relic security website. Compatibility and requirements <em>APM</em> <em>agent</em> versions that support this feature include: C SDK: not available Go: 2.1"
      },
      "id": "6043d4a8196a6773a1960f68"
    },
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-10-18T03:55:42Z",
      "updated_at": "2021-09-14T10:34:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 329.0783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> configuration",
        "sections": "Server-side <em>agent</em> configuration",
        "tags": "Manage <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-10-18T02:26:15Z",
      "updated_at": "2021-09-14T10:33:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.62726,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "Manage <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work with each"
      },
      "id": "603ebde1196a677dbaa83dec"
    }
  ],
  "/docs/agents/java-agent/additional-installation/aws-elastic-beanstalk-installation-java": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.63525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " Security and WebSphere, you must grant the <em>Java</em> <em>agent</em> <em>additional</em> permissions before it can execute properly. Browser monitoring To use browser monitoring when running the <em>Java</em> <em>agent</em> on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the <em>Java</em> <em>agent</em>"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "Tip",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-10-18T20:20:21Z",
      "updated_at": "2021-08-27T14:01:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendors documentation. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI From one.newrelic.com, click Add more data and then search for \"Java\". Select the Java app monitoring option and complete the process. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Javas built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agents jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, heres how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report data to your New Relic account. To copy your license key: Go to the API keys UI and get a license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Heres a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Heres a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you dont specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Lets say you want the same Docker image for every installation. However, you dont want to run the New Relic agent every time an engineer spins up a test app because you dont want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.24691,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " property. In the main body of newrelic.yml, disable the <em>Java</em> <em>agent</em> by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific <em>agents</em> by specifying the environment at runtime. <em>Additional</em> Tomcat Dockerfile examples Tomcat with environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "950370b0bcc14b07fe7609be457f3ace862af0c8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-07-27T10:41:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>3.47.1</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.85253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "sections": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "6043b9c764441f130a378f20"
    }
  ],
  "/docs/agents/java-agent/additional-installation/ibm-websphere-application-server": [
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "Tip",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-10-18T20:20:21Z",
      "updated_at": "2021-08-27T14:01:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendors documentation. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI From one.newrelic.com, click Add more data and then search for \"Java\". Select the Java app monitoring option and complete the process. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Javas built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agents jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, heres how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report data to your New Relic account. To copy your license key: Go to the API keys UI and get a license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Heres a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Heres a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you dont specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Lets say you want the same Docker image for every installation. However, you dont want to run the New Relic agent every time an engineer spins up a test app because you dont want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.24691,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " property. In the main body of newrelic.yml, disable the <em>Java</em> <em>agent</em> by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific <em>agents</em> by specifying the environment at runtime. <em>Additional</em> Tomcat Dockerfile examples Tomcat with environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "950370b0bcc14b07fe7609be457f3ace862af0c8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-07-27T10:41:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>3.47.1</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.85253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "sections": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "6043b9c764441f130a378f20"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-10-18T06:19:00Z",
      "updated_at": "2021-07-15T18:10:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic\" Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.43539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-java-agent-using-gradle": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.63522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " Security and WebSphere, you must grant the <em>Java</em> <em>agent</em> <em>additional</em> permissions before it can execute properly. Browser monitoring To use browser monitoring when running the <em>Java</em> <em>agent</em> on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the <em>Java</em> <em>agent</em>"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "Tip",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-10-18T20:20:21Z",
      "updated_at": "2021-08-27T14:01:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendors documentation. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI From one.newrelic.com, click Add more data and then search for \"Java\". Select the Java app monitoring option and complete the process. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Javas built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agents jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, heres how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report data to your New Relic account. To copy your license key: Go to the API keys UI and get a license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Heres a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Heres a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you dont specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Lets say you want the same Docker image for every installation. However, you dont want to run the New Relic agent every time an engineer spins up a test app because you dont want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.2469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " property. In the main body of newrelic.yml, disable the <em>Java</em> <em>agent</em> by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific <em>agents</em> by specifying the environment at runtime. <em>Additional</em> Tomcat Dockerfile examples Tomcat with environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "950370b0bcc14b07fe7609be457f3ace862af0c8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-07-27T10:41:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>3.47.1</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.85253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "sections": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "6043b9c764441f130a378f20"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-java-agent-using-maven": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.63522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " Security and WebSphere, you must grant the <em>Java</em> <em>agent</em> <em>additional</em> permissions before it can execute properly. Browser monitoring To use browser monitoring when running the <em>Java</em> <em>agent</em> on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the <em>Java</em> <em>agent</em>"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "Tip",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-10-18T20:20:21Z",
      "updated_at": "2021-08-27T14:01:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendors documentation. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI From one.newrelic.com, click Add more data and then search for \"Java\". Select the Java app monitoring option and complete the process. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Javas built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agents jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, heres how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report data to your New Relic account. To copy your license key: Go to the API keys UI and get a license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Heres a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Heres a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you dont specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Lets say you want the same Docker image for every installation. However, you dont want to run the New Relic agent every time an engineer spins up a test app because you dont want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.2469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " property. In the main body of newrelic.yml, disable the <em>Java</em> <em>agent</em> by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific <em>agents</em> by specifying the environment at runtime. <em>Additional</em> Tomcat Dockerfile examples Tomcat with environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-10-18T06:19:00Z",
      "updated_at": "2021-07-15T18:10:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic\" Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.43539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-ansible": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.63518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " Security and WebSphere, you must grant the <em>Java</em> <em>agent</em> <em>additional</em> permissions before it can execute properly. Browser monitoring To use browser monitoring when running the <em>Java</em> <em>agent</em> on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the <em>Java</em> <em>agent</em>"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "Tip",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-10-18T20:20:21Z",
      "updated_at": "2021-08-27T14:01:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendors documentation. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI From one.newrelic.com, click Add more data and then search for \"Java\". Select the Java app monitoring option and complete the process. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Javas built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agents jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, heres how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report data to your New Relic account. To copy your license key: Go to the API keys UI and get a license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Heres a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Heres a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you dont specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Lets say you want the same Docker image for every installation. However, you dont want to run the New Relic agent every time an engineer spins up a test app because you dont want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.2469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " property. In the main body of newrelic.yml, disable the <em>Java</em> <em>agent</em> by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific <em>agents</em> by specifying the environment at runtime. <em>Additional</em> Tomcat Dockerfile examples Tomcat with environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "950370b0bcc14b07fe7609be457f3ace862af0c8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-07-27T10:41:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>3.47.1</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.85253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "sections": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "6043b9c764441f130a378f20"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.63518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " Security and WebSphere, you must grant the <em>Java</em> <em>agent</em> <em>additional</em> permissions before it can execute properly. Browser monitoring To use browser monitoring when running the <em>Java</em> <em>agent</em> on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the <em>Java</em> <em>agent</em>"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "950370b0bcc14b07fe7609be457f3ace862af0c8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-07-27T10:41:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>3.47.1</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.85253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "sections": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "6043b9c764441f130a378f20"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-10-18T06:19:00Z",
      "updated_at": "2021-07-15T18:10:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic\" Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.43539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-gae-flexible-environment": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.63515,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " Security and WebSphere, you must grant the <em>Java</em> <em>agent</em> <em>additional</em> permissions before it can execute properly. Browser monitoring To use browser monitoring when running the <em>Java</em> <em>agent</em> on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the <em>Java</em> <em>agent</em>"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "Tip",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-10-18T20:20:21Z",
      "updated_at": "2021-08-27T14:01:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendors documentation. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI From one.newrelic.com, click Add more data and then search for \"Java\". Select the Java app monitoring option and complete the process. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Javas built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agents jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, heres how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report data to your New Relic account. To copy your license key: Go to the API keys UI and get a license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Heres a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Heres a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you dont specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Lets say you want the same Docker image for every installation. However, you dont want to run the New Relic agent every time an engineer spins up a test app because you dont want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.2469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " property. In the main body of newrelic.yml, disable the <em>Java</em> <em>agent</em> by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific <em>agents</em> by specifying the environment at runtime. <em>Additional</em> Tomcat Dockerfile examples Tomcat with environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "950370b0bcc14b07fe7609be457f3ace862af0c8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-07-27T10:41:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>3.47.1</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.85253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "sections": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "6043b9c764441f130a378f20"
    }
  ],
  "/docs/agents/java-agent/additional-installation/wildfly-installation-java": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.63515,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " Security and WebSphere, you must grant the <em>Java</em> <em>agent</em> <em>additional</em> permissions before it can execute properly. Browser monitoring To use browser monitoring when running the <em>Java</em> <em>agent</em> on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the <em>Java</em> <em>agent</em>"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "Tip",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-10-18T20:20:21Z",
      "updated_at": "2021-08-27T14:01:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendors documentation. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI From one.newrelic.com, click Add more data and then search for \"Java\". Select the Java app monitoring option and complete the process. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Javas built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agents jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, heres how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report data to your New Relic account. To copy your license key: Go to the API keys UI and get a license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Heres a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Heres a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you dont specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Lets say you want the same Docker image for every installation. However, you dont want to run the New Relic agent every time an engineer spins up a test app because you dont want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.2469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " property. In the main body of newrelic.yml, disable the <em>Java</em> <em>agent</em> by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific <em>agents</em> by specifying the environment at runtime. <em>Additional</em> Tomcat Dockerfile examples Tomcat with environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "950370b0bcc14b07fe7609be457f3ace862af0c8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-07-27T10:41:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>3.47.1</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.85253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "sections": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "6043b9c764441f130a378f20"
    }
  ],
  "/docs/agents/java-agent/api-guides/guide-using-java-agent-api": [
    {
      "sections": [
        "Java agent API: Instrument using annotation",
        "Important",
        "Configure your agent for annotations",
        "@Trace",
        "Create a new transaction",
        "Add detail to your transactions",
        "Convert a transaction to a web request",
        "Define your own @Trace annotation class",
        "Properties for @Trace",
        "dispatcher",
        "async",
        "metricName",
        "excludeFromTransactionTrace",
        "leaf",
        "@TraceLambda",
        "Properties for @TraceLambda",
        "pattern",
        "includeNonstatic",
        "@TraceByReturnType",
        "Properties for @TraceByReturnType",
        "traceReturnTypes",
        "Performance considerations",
        "Caution",
        "More API functions"
      ],
      "title": "Java agent API: Instrument using annotation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "4a373504c0682b36745d2283fdd902ead43510ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation/",
      "published_at": "2021-10-18T03:44:06Z",
      "updated_at": "2021-07-15T18:31:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent provides several options for custom instrumentation. One of those options is adding the Java agent API's @Trace, @TraceLambda or @TraceByReturnType annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can't or don't want to modify your source code, see Custom instrumentation for other instrumentation options. Configure your agent for annotations By default, the configuration setting enable_custom_tracing is set to true in the Java agent, which is the setting required for @Trace annotations to function. This setting is not included in the newrelic.yml by default. The only time you need to incorporate this setting into your configuration file is if you want to disable @Trace annotations altogether. To do this, set enable_custom_tracing: false (prefaced with two spaces) in the common stanza of your newrelic.yml. Make sure that newrelic-api.jar appears in your classpath as it contains all these annotations. @Trace Annotating a method with @Trace tells the Java agent that measurements should be taken for that method. To add a method call as a custom trace add @Trace annotations to your method. import com.newrelic.api.agent.Trace; ... @Trace public void run() { // background task } Copy Create a new transaction If transactions do not appear and you want to start a new transaction, include dispatcher=true with the @Trace annotation: @Trace (dispatcher=true) public void run() { // background task } Copy Add detail to your transactions If your transaction traces show large blocks of uninstrumented time and you want to include some more methods within the trace, you can use the @Trace annotation without parameters: @Trace protected void methodWithinTransaction() { // work } Copy Convert a transaction to a web request To make a background task report as a web browser transaction with a Java agent API call: In the method annotated with @Trace(dispatcher=true), call: NewRelic.setRequestAndResponse(Request request, Response response) Copy The arguments are implementations of the Request and Response interfaces in newrelic-api.jar. Important Even if your Request and Response objects already are present, you still need to add this API call. Define your own @Trace annotation class If you define your own @Trace annotation class, there is no dependency on the newrelic-api.jar. To define the class: package com.test; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Trace { public static final String NULL = \"\"; String metricName() default NULL; boolean dispatcher() default false; String tracerFactoryName() default NULL; } Copy Then, configure the agent to use this annotation in the common section of the newrelic.yml: class_transformer: trace_annotation_class_name: com.test.Trace Copy Properties for @Trace The @Trace annotation supports the following properties. dispatcher Type: Boolean Default: false If true, the agent will start a transaction when it reaches a method with this @Trace annotation if a transaction is not already in progress. If a transaction is already in progress, the method with this annotation will be included in the ongoing transaction, rather than starting a new one. If false (default), no metrics will be recorded if the agent has not started a transaction before the @Trace annotation is reached. For example: @Trace(dispatcher=true) Copy async Type: Boolean Default: false If true, this method is marked as asynchronous and the agent will trace this method if it linked to an existing transaction. For example: @Trace(async=true) Copy If false (default), the method is not marked as asynchronous. If other @Trace annotations are present and the method is not executing asynchronously, it will still be traced. metricName Type: String Default: (none) This property affects transaction traces and error reporting. By default, the metric name will include the class name followed by the method name. If you do not want class followed by method, then you can use this property to change the metric name. If you set the metricName, as in @Trace(metricName=\"YourMessageHere\"), then the time spent in this method will appear as YourMessageHere in any transaction trace. If you set the metricName in addition to the dispatcher, as in @Trace(metricName=\"YourMessageHere\", dispatcher=true), then the transaction name will appear as YourMessageHere in the APM Transactions page but the time spent in this method will not appear as YourMessageHere in any transaction trace. Here is an example: @Trace(metricName=\"YourMetricName\") Copy Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. excludeFromTransactionTrace Type: Boolean Default: false If true, the method will be excluded from the transaction trace. The agent will still collect metrics for the method. Here is an example: @Trace(excludeFromTransactionTrace=true) Copy leaf Type: Boolean Default: false A leaf tracer has no child tracers. This is useful when you want all time attributed to the tracer, even if other trace points are encountered the tracer's execution. Database tracers often act as a leaf so that all time is attributed to database activity, even if instrumented external calls are made. Here is an example: @Trace(leaf=true) Copy If a leaf tracer does not participate in transaction traces, the agent can create a tracer with lower overhead. Here is an example: @Trace(excludeFromTransactionTrace=true, leaf=true) Copy @TraceLambda If your transaction traces show large blocks of uninstrumented time and you want to include lambda expressions within the trace, you can use the @TraceLambda annotation without parameters: import com.newrelic.api.agent.TraceLambda; @TraceLambda class ClassContainingLambdaExpressions() { // work } Copy Lambda expressions become static methods of the containing class after compilation. By default, static methods within classes marked with the @TraceLambda annotation matching the annotations pattern will be marked with the @Trace annotation. Properties for @TraceLambda The @TraceLambda annotation supports the following properties. pattern Type: String Default: ^\\$?(lambda\\|anonfun)\\$(?\\<name\\>.*) If you set the pattern, as in @TraceLambda(pattern=\"YourPattern\"), then the marked classes method names will be matched against the regex pattern YourPattern. If matched the related method will be marked with the @Trace annotation. Here is an example: @TraceLambda(pattern=\"YourPattern\") Copy includeNonstatic Type: Boolean Default: false If true, the marked classes nonstatic methods will be eligible for assessment against the pattern for instrumentation. Here is an example: @TraceLambda(includeNonstatic=\"true\") Copy @TraceByReturnType To include methods with a particular return type within the trace, you can use the @TraceByReturnType annotation to mark a class passing the return types as a property. Methods in annotated classes that match one of the specified return types will be marked with the @Trace annotation. @TraceByReturnType(traceReturnTypes={Integer.class, String.class}) class ClassContainingMethods() { // ... } Copy Properties for @TraceByReturnType The @TraceByReturnType annotation supports the following properties. traceReturnTypes Type: List < Class> Default: empty list If you set the traceReturnTypes, as in @TraceByReturnType(traceReturnTypes={String.class}), then the marked classes method return types will be matched against the String.class. All matched methods will be marked with the @Trace annotation. Here is an example: @TraceByReturnType(traceReturnTypes={Integer.class, String.class}) class ClassContainingMethods() { public String doSomething() { // matches // ... } public Long somethingElse() { // does not match // ... } } Copy Performance considerations When the Java agent is present in the JVM, it will inject code on the annotated methods. The performance hit is negligible in heavyweight operations, such as database or webservice calls, but is noticeable in methods that are called frequently, such as an accessor called thousands of times a second. Caution Do not instrument all of your methods, as this can lead to decreased performance and to a metric grouping issue. More API functions For more about the Java agent API and its functionality, see the Java agent API introduction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.47117,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> provides several options for custom instrumentation. One of those options is adding the <em>Java</em> <em>agent</em> <em>API</em>&#x27;s @Trace, @TraceLambda or @TraceByReturnType annotations to your application code. This document describes how to use annotations. Important To use annotations, you must"
      },
      "id": "603eb64a28ccbc9ca2eba79f"
    },
    {
      "sections": [
        "Java agent API: Custom instrumentation with annotation of an example app",
        "Important",
        "Complete example app using API",
        "Tip",
        "Complete API call example",
        "How the example uses the API",
        "Import the needed packages",
        "Set @Trace for transaction traces",
        "Create custom names for web transactions",
        "Bypass Apdex when collecting non-public data",
        "Record the user ID",
        "Collect promotion data",
        "Send instructions to the handler",
        "Include page load timing code in the HTTP response",
        "Complete the HTTP response"
      ],
      "title": "Java agent API: Custom instrumentation with annotation of an example app",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "a6a2aadf63f8282b7d599579f67010fbd600d183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-custom-instrumentation-annotation-example-app/",
      "published_at": "2021-10-18T02:46:00Z",
      "updated_at": "2021-07-09T06:24:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you set up custom instrumentation for your Java application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the API, ensure you have the latest Java agent release. Complete example app using API Below is an example of an imaginary store app's servlet using the Java agent API. Tip If you copy and paste example code, be sure to use appropriate spacing on your command lines. Complete API call example package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } } String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } } protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy How the example uses the API Here is the same example app divided into sections that describe how the API is used: Import the needed packages This part of the example shows the imports needed for the example application and Java agent API. package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; Copy Set @Trace for transaction traces This part of the API call provides instructions to instrument this call using New Relic's trace annotation @Trace. Any requests that hit processRequest will now show a segment in APM's Transaction trace call chart. public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } Copy Create custom names for web transactions This part of the API call instructs web transactions containing a storeId value to appear in APM's Transactions page with the custom transaction name you set. A request to any one store will appear under the same, aggregate name. private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); } } Copy Bypass Apdex when collecting non-public data This part of the API call excludes the non-public beta storeID from affecting the Apdex score. if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } Copy Record the user ID This part of the API call inserts additional metadata into the page load timing request so that browser traces can be tied with the userId. It also records the userId as a custom parameter on the transaction so that it appears in the parameter details of a transaction trace. (Page load timing sometimes is referred to as real user monitoring or RUM.) String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } Copy Collect promotion data This part of the API call records the number of times a promotion was viewed so that the metrics can appear on a custom dashboard. Important For metrics you want to graph in custom dashboards, be sure to prepend Custom/ to the metric name; for example, Custom/Promotion. String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } Copy Send instructions to the handler This part of the API call sends a set of instructions to the handler for processing requests and handling exceptions. protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { Copy Include page load timing code in the HTTP response This part of the API call defines what to include in the HttpServletResponse. For manual instrumentation of browser monitoring to monitor page load timing (sometimes referred to as real user monitoring or RUM): Set the header after the < head> tag. Set the footer at the end of < body> tag. resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } Copy Complete the HTTP response This part of the API call defines the remaining information to include in the HttpServletResponse response. protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.90597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you set up custom instrumentation for your <em>Java</em> application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the <em>API</em>, ensure you have the latest <em>Java</em> <em>agent</em> release"
      },
      "id": "603eb76a64441f48424e886b"
    },
    {
      "sections": [
        "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
        "External API",
        "External parameters builders",
        "Important",
        "Cross application tracing API",
        "Client wrappers",
        "OutbounderHeaders implementation",
        "InboundHeaders implementation",
        "Server wrappers",
        "Extend ExtendedRequest class",
        "Response interface implementation",
        "CAT implementation using wrappers",
        "Cross application tracing: Client-side",
        "Cross application tracing: Server-side",
        "Messaging API",
        "Messaging API implementation",
        "Message with CAT headers implementation",
        "Datastore API",
        "Datastore API implementation",
        "Datastore API: Slow query",
        "Datastore with slow query implementation",
        "WebFrameworks API",
        "Tip",
        "WebFrameworks API implementation",
        "For more help"
      ],
      "title": "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "714d226d7cc81508ecd006cb53c26c7525abfd4e",
      "image": "https://docs.newrelic.com/static/00e2b7a703330efa62b14e15dda69907/1ff84/CAT_diagram.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-external-calls-messaging-datastore-web-frameworks/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-03-11T03:37:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent collects and reports information on web transactions and non-web transactions, such as background tasks. The agent should instrument supported frameworks automatically, without any need to modify your application code. However, in addition to custom code and frameworks or technology not listed in the Compatibility and requirements for the Java agent documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the Java agent API to instrument external calls, messaging frameworks, cross application tracing (CAT), datastores, and web frameworks. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. External API The External API enables applications to report external service calls to New Relic. This information appears on the External services page in APM. To report HTTP external activity, simply create an instance of ExternalParameters using the HttpParameters builder, and call reportAsExternal(ExternalParameters parameters) on the traced method you want to report. External API String library = \"HttpClient\"; // a user-recognizable name for the library that is being used URI uri = request.getURI(); // the URI that is being requested String procedure = \"execute\"; // these are typically named after the method in the library that's being instrumented // construct external parameters ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // report the current method as doing external activity NewRelic.getAgent().getTracedMethod().reportAsExternal(params); Copy External parameters builders There are several builders to create ExternalParameters: DatastoreParameters HttpParameters GenericParameters MessageConsumeParameters MessageProduceParameters These builders create the input parameter object for TracedMethod's reportAsExternal API call. These parameter objects are used for things like linking HTTP external calls via cross application tracing, tracing external calls to a datastore, tracing external calls to a datastore with additional slow query processing, as well as tracing calls between message producers and consumers. Important All of the methods of this class have the potential to expose sensitive private information. Use caution when creating the arguments, paying particular attention to URIs and string values. Cross application tracing API The cross application tracing (CAT) API allows the New Relic Java agent to link transactions across applications monitored by New Relic. The API uses client and server wrappers that allow the agent to read headers from requests, and add headers to responses. Client wrappers For the agent to write outbound request headers in the client initiating the request, use the OutboundHeaders interface. For example: OutbounderHeaders implementation class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; // OutboundHeaders is implemented by delegating to the library's request object public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } // This allows the agent to add the correct headers to the HTTP request @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy For the agent to read inbound response headers in the client receiving the response, implement the InboundHeaders. For example: InboundHeaders implementation class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; // OutboundHeaders is implemented by delegating to the library's response object public InboundWrapper(CloseableHttpResponse responseHeaders) { this.responseHeaders = responseHeaders; } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } // this allows the agent to read the correct headers from the HTTP response @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } Copy Server wrappers For the agent to get web request headers, you must extend the ExtendedRequest class: Extend ExtendedRequest class // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } Copy For the agent to set the web response headers, implement the Response interface: Response interface implementation // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy CAT implementation using wrappers Using the wrapper objects described in the previous sections, you can enable the Java agent to do cross application tracing (CAT) on the client and server side. For example: Cross application tracing: Client-side @Trace public int makeExternalCall(URI uri) throws IOException { String library = \"HTTPClient\"; String procedure = \"Execute\"; HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } Copy In this sample code, the agent is configured to report an external call using CAT on the client that is initiating the request. These steps can be summarized as follows: Implement OutboundHeaders and InboundHeaders using framework classes on the client. Use addOutboundRequestHeaders(OutboundHeaders outboundHeaders) to have the agent add appropriate headers to the outbound request. Create ExternalParameters object using HttpParameters builder and provide inbound response headers. Report as an external request using reportAsExternal(ExternalParameters params). Cross application tracing: Server-side @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } Copy In this sample code, the agent is configured to report an external call using CAT on the server that is responding to the request. These steps can be summarized as follows: Implement Response and extend the ExtendedRequest class using framework classes on the server. Use setWebRequest(ExtendedRequest request) and setWebResponse(Response response) to convert the transaction into a web transaction and together provide the agent with the inbound request headers and a place to record the outbound headers. It's important to use both setWebRequest(ExtendedRequest request) and setWebResponse(Response response) together, because the transaction name depends on the request object, and the response code depends on the response object. Use addOutboundResponseHeaders() to have the agent add appropriate headers to the outbound response. Mark the end of the response with a call to markResponseSent(). Messaging API The messaging API allows applications to report interactions with message queue brokers. It builds on top of the External API by providing the MessageConsumerParametersMessage and MessageConsumerParameters. This API generates the necessary metrics to identify message broker interactions. The UI will use these metrics to display messaging data including segments in transactions with the appropriate action and count (message put, or message take), a dedicated messages tab in transaction traces, and more. Providing inbound and outbound headers to the API also allows the agent to add CAT headers, and record CAT metrics, which enables the UI to draw service maps that show connections between applications. Important The messaging API relies on two-way communication between producers and consumers. If your producer does not receive an acknowledgment from a consumer, like in a fire-and-forget pattern, the messaging API will not accurately reflect the interactions with message queue brokers. The following example demonstrates how to instrument a fictional JMS library. Messaging API implementation public class MessageProducer { // instrument the method that puts messages on a queue @Trace public void sendMessageToQueue(Message message) { ExternalParameters messageProduceParameters = MessageProduceParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .outboundHeaders(new OutboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageProduceParameters); } } Copy To simplify things, the agent assumes that sendMessageToQueue always puts a message in a named queue. In reality, a message can be sent to different destination types, including named queues, temporary queues, topics, and temporary topics. The API provides an enum to report messages to different destination types: NAMED_QUEUE, TEMP_QUEUE, NAMED_TOPIC, TEMP_TOPIC. It's important to specify the appropriate destination type because the UI will display the names of named queues and named topics and will omit the names of temporary queues and temporary topics. If the library is capable of transmitting CAT headers, an OutboundHeaders object will be provided to the API so that the agent can add CAT headers. Message with CAT headers implementation public class MessageConsumer { @Trace public Message messageReceive() { ExternalParameters messageConsumeParameters = MessageConsumeParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .inboundHeaders(new InboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageConsumeParameters); return message; } } Copy Datastore API When a traced method is reported as an external datastore call, the call is shown in the APM Databases page. Because datastores are external to the running application, the method is reported as datastore activity using the reportAsExternal(ExternalParameters params) method. The only difference is that a different builder, DatastoreParameters, is used to create the appropriate ExternalParameters object. Datastore API implementation TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .build()); Copy Datastore API: Slow query This API call provides the same behavior as the Datastore API call and extends it to allow slow query information to be tracked. The same reportAsExternal(ExternalParameters params) method and builder are used, but with an additional builder method. Datastore with slow query implementation Creating the appropriate ExternalParameters object is illustrated below: //Reporting a method as doing datastore activity TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .slowQuery(rawQuery,QUERY_CONVERTER) .build()); private static QueryConverter<String> QUERY_CONVERTER = new QueryConverter<String>() { @Override public String toRawQueryString(String statement) { // Do work to transform raw query object to string return statement; } @Override public String toObfuscatedQueryString(String statement) { // Do work to remove any sensitive information here return obfuscateQuery(statement); } }; Copy WebFrameworks API The WebFrameworks API allows the agent to report additional identifying information about the application. // Set the dispatcher name and version which is reported to APM. // The dispatcherName is intended to represent the type of server that this // application is running on such as: Tomcat, Jetty, Netty, etc. NewRelic.setServerInfo(String dispatcherName, String version) // Set the app server port which is reported to APM. NewRelic.setAppServerPort(int port) // Set the instance name in the environment. // A single host:port may support multiple JVM instances. // The instance name is intended to help identify a specific JVM instance. NewRelic.setInstanceName(String instanceName) Copy Tip These values can be set only once. Subsequent calls will have no effect. WebFrameworks API implementation public NewRelicApiClient() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version. NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client:8080\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8080/ \\n\"); } Copy For more help Additional documentation resources include: New Relic Java agent API Javadoc (detailed API documentation on GitHub) Java agent API example (example application using custom instrumentation for cross application tracing and external datastore calls) Java agent API guide (goal-driven guide to using the Java agent API) Java instrumentation by annotation (how to use annotations to instrument your application code)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.1857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "tags": "<em>API</em> <em>guides</em>",
        "body": " or technology not listed in the Compatibility and requirements for the <em>Java</em> <em>agent</em> documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the <em>Java</em> <em>agent</em> <em>API</em> to instrument external calls, messaging frameworks, cross application"
      },
      "id": "6043c7f828ccbcef982c6077"
    }
  ],
  "/docs/agents/java-agent/api-guides/java-agent-api-custom-instrumentation-annotation-example-app": [
    {
      "sections": [
        "Java agent API: Instrument using annotation",
        "Important",
        "Configure your agent for annotations",
        "@Trace",
        "Create a new transaction",
        "Add detail to your transactions",
        "Convert a transaction to a web request",
        "Define your own @Trace annotation class",
        "Properties for @Trace",
        "dispatcher",
        "async",
        "metricName",
        "excludeFromTransactionTrace",
        "leaf",
        "@TraceLambda",
        "Properties for @TraceLambda",
        "pattern",
        "includeNonstatic",
        "@TraceByReturnType",
        "Properties for @TraceByReturnType",
        "traceReturnTypes",
        "Performance considerations",
        "Caution",
        "More API functions"
      ],
      "title": "Java agent API: Instrument using annotation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "4a373504c0682b36745d2283fdd902ead43510ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation/",
      "published_at": "2021-10-18T03:44:06Z",
      "updated_at": "2021-07-15T18:31:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent provides several options for custom instrumentation. One of those options is adding the Java agent API's @Trace, @TraceLambda or @TraceByReturnType annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can't or don't want to modify your source code, see Custom instrumentation for other instrumentation options. Configure your agent for annotations By default, the configuration setting enable_custom_tracing is set to true in the Java agent, which is the setting required for @Trace annotations to function. This setting is not included in the newrelic.yml by default. The only time you need to incorporate this setting into your configuration file is if you want to disable @Trace annotations altogether. To do this, set enable_custom_tracing: false (prefaced with two spaces) in the common stanza of your newrelic.yml. Make sure that newrelic-api.jar appears in your classpath as it contains all these annotations. @Trace Annotating a method with @Trace tells the Java agent that measurements should be taken for that method. To add a method call as a custom trace add @Trace annotations to your method. import com.newrelic.api.agent.Trace; ... @Trace public void run() { // background task } Copy Create a new transaction If transactions do not appear and you want to start a new transaction, include dispatcher=true with the @Trace annotation: @Trace (dispatcher=true) public void run() { // background task } Copy Add detail to your transactions If your transaction traces show large blocks of uninstrumented time and you want to include some more methods within the trace, you can use the @Trace annotation without parameters: @Trace protected void methodWithinTransaction() { // work } Copy Convert a transaction to a web request To make a background task report as a web browser transaction with a Java agent API call: In the method annotated with @Trace(dispatcher=true), call: NewRelic.setRequestAndResponse(Request request, Response response) Copy The arguments are implementations of the Request and Response interfaces in newrelic-api.jar. Important Even if your Request and Response objects already are present, you still need to add this API call. Define your own @Trace annotation class If you define your own @Trace annotation class, there is no dependency on the newrelic-api.jar. To define the class: package com.test; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Trace { public static final String NULL = \"\"; String metricName() default NULL; boolean dispatcher() default false; String tracerFactoryName() default NULL; } Copy Then, configure the agent to use this annotation in the common section of the newrelic.yml: class_transformer: trace_annotation_class_name: com.test.Trace Copy Properties for @Trace The @Trace annotation supports the following properties. dispatcher Type: Boolean Default: false If true, the agent will start a transaction when it reaches a method with this @Trace annotation if a transaction is not already in progress. If a transaction is already in progress, the method with this annotation will be included in the ongoing transaction, rather than starting a new one. If false (default), no metrics will be recorded if the agent has not started a transaction before the @Trace annotation is reached. For example: @Trace(dispatcher=true) Copy async Type: Boolean Default: false If true, this method is marked as asynchronous and the agent will trace this method if it linked to an existing transaction. For example: @Trace(async=true) Copy If false (default), the method is not marked as asynchronous. If other @Trace annotations are present and the method is not executing asynchronously, it will still be traced. metricName Type: String Default: (none) This property affects transaction traces and error reporting. By default, the metric name will include the class name followed by the method name. If you do not want class followed by method, then you can use this property to change the metric name. If you set the metricName, as in @Trace(metricName=\"YourMessageHere\"), then the time spent in this method will appear as YourMessageHere in any transaction trace. If you set the metricName in addition to the dispatcher, as in @Trace(metricName=\"YourMessageHere\", dispatcher=true), then the transaction name will appear as YourMessageHere in the APM Transactions page but the time spent in this method will not appear as YourMessageHere in any transaction trace. Here is an example: @Trace(metricName=\"YourMetricName\") Copy Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. excludeFromTransactionTrace Type: Boolean Default: false If true, the method will be excluded from the transaction trace. The agent will still collect metrics for the method. Here is an example: @Trace(excludeFromTransactionTrace=true) Copy leaf Type: Boolean Default: false A leaf tracer has no child tracers. This is useful when you want all time attributed to the tracer, even if other trace points are encountered the tracer's execution. Database tracers often act as a leaf so that all time is attributed to database activity, even if instrumented external calls are made. Here is an example: @Trace(leaf=true) Copy If a leaf tracer does not participate in transaction traces, the agent can create a tracer with lower overhead. Here is an example: @Trace(excludeFromTransactionTrace=true, leaf=true) Copy @TraceLambda If your transaction traces show large blocks of uninstrumented time and you want to include lambda expressions within the trace, you can use the @TraceLambda annotation without parameters: import com.newrelic.api.agent.TraceLambda; @TraceLambda class ClassContainingLambdaExpressions() { // work } Copy Lambda expressions become static methods of the containing class after compilation. By default, static methods within classes marked with the @TraceLambda annotation matching the annotations pattern will be marked with the @Trace annotation. Properties for @TraceLambda The @TraceLambda annotation supports the following properties. pattern Type: String Default: ^\\$?(lambda\\|anonfun)\\$(?\\<name\\>.*) If you set the pattern, as in @TraceLambda(pattern=\"YourPattern\"), then the marked classes method names will be matched against the regex pattern YourPattern. If matched the related method will be marked with the @Trace annotation. Here is an example: @TraceLambda(pattern=\"YourPattern\") Copy includeNonstatic Type: Boolean Default: false If true, the marked classes nonstatic methods will be eligible for assessment against the pattern for instrumentation. Here is an example: @TraceLambda(includeNonstatic=\"true\") Copy @TraceByReturnType To include methods with a particular return type within the trace, you can use the @TraceByReturnType annotation to mark a class passing the return types as a property. Methods in annotated classes that match one of the specified return types will be marked with the @Trace annotation. @TraceByReturnType(traceReturnTypes={Integer.class, String.class}) class ClassContainingMethods() { // ... } Copy Properties for @TraceByReturnType The @TraceByReturnType annotation supports the following properties. traceReturnTypes Type: List < Class> Default: empty list If you set the traceReturnTypes, as in @TraceByReturnType(traceReturnTypes={String.class}), then the marked classes method return types will be matched against the String.class. All matched methods will be marked with the @Trace annotation. Here is an example: @TraceByReturnType(traceReturnTypes={Integer.class, String.class}) class ClassContainingMethods() { public String doSomething() { // matches // ... } public Long somethingElse() { // does not match // ... } } Copy Performance considerations When the Java agent is present in the JVM, it will inject code on the annotated methods. The performance hit is negligible in heavyweight operations, such as database or webservice calls, but is noticeable in methods that are called frequently, such as an accessor called thousands of times a second. Caution Do not instrument all of your methods, as this can lead to decreased performance and to a metric grouping issue. More API functions For more about the Java agent API and its functionality, see the Java agent API introduction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.47117,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> provides several options for custom instrumentation. One of those options is adding the <em>Java</em> <em>agent</em> <em>API</em>&#x27;s @Trace, @TraceLambda or @TraceByReturnType annotations to your application code. This document describes how to use annotations. Important To use annotations, you must"
      },
      "id": "603eb64a28ccbc9ca2eba79f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-10-18T02:14:44Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.65321,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em> ",
        "sections": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This <em>API</em> consists of: Static methods on the com.newrelic.<em>api.agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of <em>API</em> objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
        "External API",
        "External parameters builders",
        "Important",
        "Cross application tracing API",
        "Client wrappers",
        "OutbounderHeaders implementation",
        "InboundHeaders implementation",
        "Server wrappers",
        "Extend ExtendedRequest class",
        "Response interface implementation",
        "CAT implementation using wrappers",
        "Cross application tracing: Client-side",
        "Cross application tracing: Server-side",
        "Messaging API",
        "Messaging API implementation",
        "Message with CAT headers implementation",
        "Datastore API",
        "Datastore API implementation",
        "Datastore API: Slow query",
        "Datastore with slow query implementation",
        "WebFrameworks API",
        "Tip",
        "WebFrameworks API implementation",
        "For more help"
      ],
      "title": "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "714d226d7cc81508ecd006cb53c26c7525abfd4e",
      "image": "https://docs.newrelic.com/static/00e2b7a703330efa62b14e15dda69907/1ff84/CAT_diagram.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-external-calls-messaging-datastore-web-frameworks/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-03-11T03:37:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent collects and reports information on web transactions and non-web transactions, such as background tasks. The agent should instrument supported frameworks automatically, without any need to modify your application code. However, in addition to custom code and frameworks or technology not listed in the Compatibility and requirements for the Java agent documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the Java agent API to instrument external calls, messaging frameworks, cross application tracing (CAT), datastores, and web frameworks. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. External API The External API enables applications to report external service calls to New Relic. This information appears on the External services page in APM. To report HTTP external activity, simply create an instance of ExternalParameters using the HttpParameters builder, and call reportAsExternal(ExternalParameters parameters) on the traced method you want to report. External API String library = \"HttpClient\"; // a user-recognizable name for the library that is being used URI uri = request.getURI(); // the URI that is being requested String procedure = \"execute\"; // these are typically named after the method in the library that's being instrumented // construct external parameters ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // report the current method as doing external activity NewRelic.getAgent().getTracedMethod().reportAsExternal(params); Copy External parameters builders There are several builders to create ExternalParameters: DatastoreParameters HttpParameters GenericParameters MessageConsumeParameters MessageProduceParameters These builders create the input parameter object for TracedMethod's reportAsExternal API call. These parameter objects are used for things like linking HTTP external calls via cross application tracing, tracing external calls to a datastore, tracing external calls to a datastore with additional slow query processing, as well as tracing calls between message producers and consumers. Important All of the methods of this class have the potential to expose sensitive private information. Use caution when creating the arguments, paying particular attention to URIs and string values. Cross application tracing API The cross application tracing (CAT) API allows the New Relic Java agent to link transactions across applications monitored by New Relic. The API uses client and server wrappers that allow the agent to read headers from requests, and add headers to responses. Client wrappers For the agent to write outbound request headers in the client initiating the request, use the OutboundHeaders interface. For example: OutbounderHeaders implementation class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; // OutboundHeaders is implemented by delegating to the library's request object public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } // This allows the agent to add the correct headers to the HTTP request @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy For the agent to read inbound response headers in the client receiving the response, implement the InboundHeaders. For example: InboundHeaders implementation class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; // OutboundHeaders is implemented by delegating to the library's response object public InboundWrapper(CloseableHttpResponse responseHeaders) { this.responseHeaders = responseHeaders; } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } // this allows the agent to read the correct headers from the HTTP response @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } Copy Server wrappers For the agent to get web request headers, you must extend the ExtendedRequest class: Extend ExtendedRequest class // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } Copy For the agent to set the web response headers, implement the Response interface: Response interface implementation // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy CAT implementation using wrappers Using the wrapper objects described in the previous sections, you can enable the Java agent to do cross application tracing (CAT) on the client and server side. For example: Cross application tracing: Client-side @Trace public int makeExternalCall(URI uri) throws IOException { String library = \"HTTPClient\"; String procedure = \"Execute\"; HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } Copy In this sample code, the agent is configured to report an external call using CAT on the client that is initiating the request. These steps can be summarized as follows: Implement OutboundHeaders and InboundHeaders using framework classes on the client. Use addOutboundRequestHeaders(OutboundHeaders outboundHeaders) to have the agent add appropriate headers to the outbound request. Create ExternalParameters object using HttpParameters builder and provide inbound response headers. Report as an external request using reportAsExternal(ExternalParameters params). Cross application tracing: Server-side @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } Copy In this sample code, the agent is configured to report an external call using CAT on the server that is responding to the request. These steps can be summarized as follows: Implement Response and extend the ExtendedRequest class using framework classes on the server. Use setWebRequest(ExtendedRequest request) and setWebResponse(Response response) to convert the transaction into a web transaction and together provide the agent with the inbound request headers and a place to record the outbound headers. It's important to use both setWebRequest(ExtendedRequest request) and setWebResponse(Response response) together, because the transaction name depends on the request object, and the response code depends on the response object. Use addOutboundResponseHeaders() to have the agent add appropriate headers to the outbound response. Mark the end of the response with a call to markResponseSent(). Messaging API The messaging API allows applications to report interactions with message queue brokers. It builds on top of the External API by providing the MessageConsumerParametersMessage and MessageConsumerParameters. This API generates the necessary metrics to identify message broker interactions. The UI will use these metrics to display messaging data including segments in transactions with the appropriate action and count (message put, or message take), a dedicated messages tab in transaction traces, and more. Providing inbound and outbound headers to the API also allows the agent to add CAT headers, and record CAT metrics, which enables the UI to draw service maps that show connections between applications. Important The messaging API relies on two-way communication between producers and consumers. If your producer does not receive an acknowledgment from a consumer, like in a fire-and-forget pattern, the messaging API will not accurately reflect the interactions with message queue brokers. The following example demonstrates how to instrument a fictional JMS library. Messaging API implementation public class MessageProducer { // instrument the method that puts messages on a queue @Trace public void sendMessageToQueue(Message message) { ExternalParameters messageProduceParameters = MessageProduceParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .outboundHeaders(new OutboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageProduceParameters); } } Copy To simplify things, the agent assumes that sendMessageToQueue always puts a message in a named queue. In reality, a message can be sent to different destination types, including named queues, temporary queues, topics, and temporary topics. The API provides an enum to report messages to different destination types: NAMED_QUEUE, TEMP_QUEUE, NAMED_TOPIC, TEMP_TOPIC. It's important to specify the appropriate destination type because the UI will display the names of named queues and named topics and will omit the names of temporary queues and temporary topics. If the library is capable of transmitting CAT headers, an OutboundHeaders object will be provided to the API so that the agent can add CAT headers. Message with CAT headers implementation public class MessageConsumer { @Trace public Message messageReceive() { ExternalParameters messageConsumeParameters = MessageConsumeParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .inboundHeaders(new InboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageConsumeParameters); return message; } } Copy Datastore API When a traced method is reported as an external datastore call, the call is shown in the APM Databases page. Because datastores are external to the running application, the method is reported as datastore activity using the reportAsExternal(ExternalParameters params) method. The only difference is that a different builder, DatastoreParameters, is used to create the appropriate ExternalParameters object. Datastore API implementation TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .build()); Copy Datastore API: Slow query This API call provides the same behavior as the Datastore API call and extends it to allow slow query information to be tracked. The same reportAsExternal(ExternalParameters params) method and builder are used, but with an additional builder method. Datastore with slow query implementation Creating the appropriate ExternalParameters object is illustrated below: //Reporting a method as doing datastore activity TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .slowQuery(rawQuery,QUERY_CONVERTER) .build()); private static QueryConverter<String> QUERY_CONVERTER = new QueryConverter<String>() { @Override public String toRawQueryString(String statement) { // Do work to transform raw query object to string return statement; } @Override public String toObfuscatedQueryString(String statement) { // Do work to remove any sensitive information here return obfuscateQuery(statement); } }; Copy WebFrameworks API The WebFrameworks API allows the agent to report additional identifying information about the application. // Set the dispatcher name and version which is reported to APM. // The dispatcherName is intended to represent the type of server that this // application is running on such as: Tomcat, Jetty, Netty, etc. NewRelic.setServerInfo(String dispatcherName, String version) // Set the app server port which is reported to APM. NewRelic.setAppServerPort(int port) // Set the instance name in the environment. // A single host:port may support multiple JVM instances. // The instance name is intended to help identify a specific JVM instance. NewRelic.setInstanceName(String instanceName) Copy Tip These values can be set only once. Subsequent calls will have no effect. WebFrameworks API implementation public NewRelicApiClient() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version. NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client:8080\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8080/ \\n\"); } Copy For more help Additional documentation resources include: New Relic Java agent API Javadoc (detailed API documentation on GitHub) Java agent API example (example application using custom instrumentation for cross application tracing and external datastore calls) Java agent API guide (goal-driven guide to using the Java agent API) Java instrumentation by annotation (how to use annotations to instrument your application code)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.1857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "tags": "<em>API</em> <em>guides</em>",
        "body": " or technology not listed in the Compatibility and requirements for the <em>Java</em> <em>agent</em> documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the <em>Java</em> <em>agent</em> <em>API</em> to instrument external calls, messaging frameworks, cross application"
      },
      "id": "6043c7f828ccbcef982c6077"
    }
  ],
  "/docs/agents/java-agent/api-guides/java-agent-api-instrument-external-calls-messaging-datastore-web-frameworks": [
    {
      "sections": [
        "Java agent API: Instrument using annotation",
        "Important",
        "Configure your agent for annotations",
        "@Trace",
        "Create a new transaction",
        "Add detail to your transactions",
        "Convert a transaction to a web request",
        "Define your own @Trace annotation class",
        "Properties for @Trace",
        "dispatcher",
        "async",
        "metricName",
        "excludeFromTransactionTrace",
        "leaf",
        "@TraceLambda",
        "Properties for @TraceLambda",
        "pattern",
        "includeNonstatic",
        "@TraceByReturnType",
        "Properties for @TraceByReturnType",
        "traceReturnTypes",
        "Performance considerations",
        "Caution",
        "More API functions"
      ],
      "title": "Java agent API: Instrument using annotation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "4a373504c0682b36745d2283fdd902ead43510ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation/",
      "published_at": "2021-10-18T03:44:06Z",
      "updated_at": "2021-07-15T18:31:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent provides several options for custom instrumentation. One of those options is adding the Java agent API's @Trace, @TraceLambda or @TraceByReturnType annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can't or don't want to modify your source code, see Custom instrumentation for other instrumentation options. Configure your agent for annotations By default, the configuration setting enable_custom_tracing is set to true in the Java agent, which is the setting required for @Trace annotations to function. This setting is not included in the newrelic.yml by default. The only time you need to incorporate this setting into your configuration file is if you want to disable @Trace annotations altogether. To do this, set enable_custom_tracing: false (prefaced with two spaces) in the common stanza of your newrelic.yml. Make sure that newrelic-api.jar appears in your classpath as it contains all these annotations. @Trace Annotating a method with @Trace tells the Java agent that measurements should be taken for that method. To add a method call as a custom trace add @Trace annotations to your method. import com.newrelic.api.agent.Trace; ... @Trace public void run() { // background task } Copy Create a new transaction If transactions do not appear and you want to start a new transaction, include dispatcher=true with the @Trace annotation: @Trace (dispatcher=true) public void run() { // background task } Copy Add detail to your transactions If your transaction traces show large blocks of uninstrumented time and you want to include some more methods within the trace, you can use the @Trace annotation without parameters: @Trace protected void methodWithinTransaction() { // work } Copy Convert a transaction to a web request To make a background task report as a web browser transaction with a Java agent API call: In the method annotated with @Trace(dispatcher=true), call: NewRelic.setRequestAndResponse(Request request, Response response) Copy The arguments are implementations of the Request and Response interfaces in newrelic-api.jar. Important Even if your Request and Response objects already are present, you still need to add this API call. Define your own @Trace annotation class If you define your own @Trace annotation class, there is no dependency on the newrelic-api.jar. To define the class: package com.test; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Trace { public static final String NULL = \"\"; String metricName() default NULL; boolean dispatcher() default false; String tracerFactoryName() default NULL; } Copy Then, configure the agent to use this annotation in the common section of the newrelic.yml: class_transformer: trace_annotation_class_name: com.test.Trace Copy Properties for @Trace The @Trace annotation supports the following properties. dispatcher Type: Boolean Default: false If true, the agent will start a transaction when it reaches a method with this @Trace annotation if a transaction is not already in progress. If a transaction is already in progress, the method with this annotation will be included in the ongoing transaction, rather than starting a new one. If false (default), no metrics will be recorded if the agent has not started a transaction before the @Trace annotation is reached. For example: @Trace(dispatcher=true) Copy async Type: Boolean Default: false If true, this method is marked as asynchronous and the agent will trace this method if it linked to an existing transaction. For example: @Trace(async=true) Copy If false (default), the method is not marked as asynchronous. If other @Trace annotations are present and the method is not executing asynchronously, it will still be traced. metricName Type: String Default: (none) This property affects transaction traces and error reporting. By default, the metric name will include the class name followed by the method name. If you do not want class followed by method, then you can use this property to change the metric name. If you set the metricName, as in @Trace(metricName=\"YourMessageHere\"), then the time spent in this method will appear as YourMessageHere in any transaction trace. If you set the metricName in addition to the dispatcher, as in @Trace(metricName=\"YourMessageHere\", dispatcher=true), then the transaction name will appear as YourMessageHere in the APM Transactions page but the time spent in this method will not appear as YourMessageHere in any transaction trace. Here is an example: @Trace(metricName=\"YourMetricName\") Copy Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. excludeFromTransactionTrace Type: Boolean Default: false If true, the method will be excluded from the transaction trace. The agent will still collect metrics for the method. Here is an example: @Trace(excludeFromTransactionTrace=true) Copy leaf Type: Boolean Default: false A leaf tracer has no child tracers. This is useful when you want all time attributed to the tracer, even if other trace points are encountered the tracer's execution. Database tracers often act as a leaf so that all time is attributed to database activity, even if instrumented external calls are made. Here is an example: @Trace(leaf=true) Copy If a leaf tracer does not participate in transaction traces, the agent can create a tracer with lower overhead. Here is an example: @Trace(excludeFromTransactionTrace=true, leaf=true) Copy @TraceLambda If your transaction traces show large blocks of uninstrumented time and you want to include lambda expressions within the trace, you can use the @TraceLambda annotation without parameters: import com.newrelic.api.agent.TraceLambda; @TraceLambda class ClassContainingLambdaExpressions() { // work } Copy Lambda expressions become static methods of the containing class after compilation. By default, static methods within classes marked with the @TraceLambda annotation matching the annotations pattern will be marked with the @Trace annotation. Properties for @TraceLambda The @TraceLambda annotation supports the following properties. pattern Type: String Default: ^\\$?(lambda\\|anonfun)\\$(?\\<name\\>.*) If you set the pattern, as in @TraceLambda(pattern=\"YourPattern\"), then the marked classes method names will be matched against the regex pattern YourPattern. If matched the related method will be marked with the @Trace annotation. Here is an example: @TraceLambda(pattern=\"YourPattern\") Copy includeNonstatic Type: Boolean Default: false If true, the marked classes nonstatic methods will be eligible for assessment against the pattern for instrumentation. Here is an example: @TraceLambda(includeNonstatic=\"true\") Copy @TraceByReturnType To include methods with a particular return type within the trace, you can use the @TraceByReturnType annotation to mark a class passing the return types as a property. Methods in annotated classes that match one of the specified return types will be marked with the @Trace annotation. @TraceByReturnType(traceReturnTypes={Integer.class, String.class}) class ClassContainingMethods() { // ... } Copy Properties for @TraceByReturnType The @TraceByReturnType annotation supports the following properties. traceReturnTypes Type: List < Class> Default: empty list If you set the traceReturnTypes, as in @TraceByReturnType(traceReturnTypes={String.class}), then the marked classes method return types will be matched against the String.class. All matched methods will be marked with the @Trace annotation. Here is an example: @TraceByReturnType(traceReturnTypes={Integer.class, String.class}) class ClassContainingMethods() { public String doSomething() { // matches // ... } public Long somethingElse() { // does not match // ... } } Copy Performance considerations When the Java agent is present in the JVM, it will inject code on the annotated methods. The performance hit is negligible in heavyweight operations, such as database or webservice calls, but is noticeable in methods that are called frequently, such as an accessor called thousands of times a second. Caution Do not instrument all of your methods, as this can lead to decreased performance and to a metric grouping issue. More API functions For more about the Java agent API and its functionality, see the Java agent API introduction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.47117,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> provides several options for custom instrumentation. One of those options is adding the <em>Java</em> <em>agent</em> <em>API</em>&#x27;s @Trace, @TraceLambda or @TraceByReturnType annotations to your application code. This document describes how to use annotations. Important To use annotations, you must"
      },
      "id": "603eb64a28ccbc9ca2eba79f"
    },
    {
      "sections": [
        "Java agent API: Custom instrumentation with annotation of an example app",
        "Important",
        "Complete example app using API",
        "Tip",
        "Complete API call example",
        "How the example uses the API",
        "Import the needed packages",
        "Set @Trace for transaction traces",
        "Create custom names for web transactions",
        "Bypass Apdex when collecting non-public data",
        "Record the user ID",
        "Collect promotion data",
        "Send instructions to the handler",
        "Include page load timing code in the HTTP response",
        "Complete the HTTP response"
      ],
      "title": "Java agent API: Custom instrumentation with annotation of an example app",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "a6a2aadf63f8282b7d599579f67010fbd600d183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-custom-instrumentation-annotation-example-app/",
      "published_at": "2021-10-18T02:46:00Z",
      "updated_at": "2021-07-09T06:24:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you set up custom instrumentation for your Java application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the API, ensure you have the latest Java agent release. Complete example app using API Below is an example of an imaginary store app's servlet using the Java agent API. Tip If you copy and paste example code, be sure to use appropriate spacing on your command lines. Complete API call example package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } } String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } } protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy How the example uses the API Here is the same example app divided into sections that describe how the API is used: Import the needed packages This part of the example shows the imports needed for the example application and Java agent API. package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; Copy Set @Trace for transaction traces This part of the API call provides instructions to instrument this call using New Relic's trace annotation @Trace. Any requests that hit processRequest will now show a segment in APM's Transaction trace call chart. public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } Copy Create custom names for web transactions This part of the API call instructs web transactions containing a storeId value to appear in APM's Transactions page with the custom transaction name you set. A request to any one store will appear under the same, aggregate name. private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); } } Copy Bypass Apdex when collecting non-public data This part of the API call excludes the non-public beta storeID from affecting the Apdex score. if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } Copy Record the user ID This part of the API call inserts additional metadata into the page load timing request so that browser traces can be tied with the userId. It also records the userId as a custom parameter on the transaction so that it appears in the parameter details of a transaction trace. (Page load timing sometimes is referred to as real user monitoring or RUM.) String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } Copy Collect promotion data This part of the API call records the number of times a promotion was viewed so that the metrics can appear on a custom dashboard. Important For metrics you want to graph in custom dashboards, be sure to prepend Custom/ to the metric name; for example, Custom/Promotion. String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } Copy Send instructions to the handler This part of the API call sends a set of instructions to the handler for processing requests and handling exceptions. protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { Copy Include page load timing code in the HTTP response This part of the API call defines what to include in the HttpServletResponse. For manual instrumentation of browser monitoring to monitor page load timing (sometimes referred to as real user monitoring or RUM): Set the header after the < head> tag. Set the footer at the end of < body> tag. resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } Copy Complete the HTTP response This part of the API call defines the remaining information to include in the HttpServletResponse response. protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.90597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you set up custom instrumentation for your <em>Java</em> application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the <em>API</em>, ensure you have the latest <em>Java</em> <em>agent</em> release"
      },
      "id": "603eb76a64441f48424e886b"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-10-18T02:14:44Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.65321,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em> ",
        "sections": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This <em>API</em> consists of: Static methods on the com.newrelic.<em>api.agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of <em>API</em> objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation": [
    {
      "sections": [
        "Java agent API: Custom instrumentation with annotation of an example app",
        "Important",
        "Complete example app using API",
        "Tip",
        "Complete API call example",
        "How the example uses the API",
        "Import the needed packages",
        "Set @Trace for transaction traces",
        "Create custom names for web transactions",
        "Bypass Apdex when collecting non-public data",
        "Record the user ID",
        "Collect promotion data",
        "Send instructions to the handler",
        "Include page load timing code in the HTTP response",
        "Complete the HTTP response"
      ],
      "title": "Java agent API: Custom instrumentation with annotation of an example app",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "a6a2aadf63f8282b7d599579f67010fbd600d183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-custom-instrumentation-annotation-example-app/",
      "published_at": "2021-10-18T02:46:00Z",
      "updated_at": "2021-07-09T06:24:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you set up custom instrumentation for your Java application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the API, ensure you have the latest Java agent release. Complete example app using API Below is an example of an imaginary store app's servlet using the Java agent API. Tip If you copy and paste example code, be sure to use appropriate spacing on your command lines. Complete API call example package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } } String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } } protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy How the example uses the API Here is the same example app divided into sections that describe how the API is used: Import the needed packages This part of the example shows the imports needed for the example application and Java agent API. package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; Copy Set @Trace for transaction traces This part of the API call provides instructions to instrument this call using New Relic's trace annotation @Trace. Any requests that hit processRequest will now show a segment in APM's Transaction trace call chart. public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } Copy Create custom names for web transactions This part of the API call instructs web transactions containing a storeId value to appear in APM's Transactions page with the custom transaction name you set. A request to any one store will appear under the same, aggregate name. private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); } } Copy Bypass Apdex when collecting non-public data This part of the API call excludes the non-public beta storeID from affecting the Apdex score. if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } Copy Record the user ID This part of the API call inserts additional metadata into the page load timing request so that browser traces can be tied with the userId. It also records the userId as a custom parameter on the transaction so that it appears in the parameter details of a transaction trace. (Page load timing sometimes is referred to as real user monitoring or RUM.) String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } Copy Collect promotion data This part of the API call records the number of times a promotion was viewed so that the metrics can appear on a custom dashboard. Important For metrics you want to graph in custom dashboards, be sure to prepend Custom/ to the metric name; for example, Custom/Promotion. String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } Copy Send instructions to the handler This part of the API call sends a set of instructions to the handler for processing requests and handling exceptions. protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { Copy Include page load timing code in the HTTP response This part of the API call defines what to include in the HttpServletResponse. For manual instrumentation of browser monitoring to monitor page load timing (sometimes referred to as real user monitoring or RUM): Set the header after the < head> tag. Set the footer at the end of < body> tag. resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } Copy Complete the HTTP response This part of the API call defines the remaining information to include in the HttpServletResponse response. protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.90597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you set up custom instrumentation for your <em>Java</em> application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the <em>API</em>, ensure you have the latest <em>Java</em> <em>agent</em> release"
      },
      "id": "603eb76a64441f48424e886b"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-10-18T02:14:44Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.65321,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em> ",
        "sections": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This <em>API</em> consists of: Static methods on the com.newrelic.<em>api.agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of <em>API</em> objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
        "External API",
        "External parameters builders",
        "Important",
        "Cross application tracing API",
        "Client wrappers",
        "OutbounderHeaders implementation",
        "InboundHeaders implementation",
        "Server wrappers",
        "Extend ExtendedRequest class",
        "Response interface implementation",
        "CAT implementation using wrappers",
        "Cross application tracing: Client-side",
        "Cross application tracing: Server-side",
        "Messaging API",
        "Messaging API implementation",
        "Message with CAT headers implementation",
        "Datastore API",
        "Datastore API implementation",
        "Datastore API: Slow query",
        "Datastore with slow query implementation",
        "WebFrameworks API",
        "Tip",
        "WebFrameworks API implementation",
        "For more help"
      ],
      "title": "Java agent API: Instrument external calls, messaging, datastore, web frameworks",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "714d226d7cc81508ecd006cb53c26c7525abfd4e",
      "image": "https://docs.newrelic.com/static/00e2b7a703330efa62b14e15dda69907/1ff84/CAT_diagram.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-external-calls-messaging-datastore-web-frameworks/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-03-11T03:37:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent collects and reports information on web transactions and non-web transactions, such as background tasks. The agent should instrument supported frameworks automatically, without any need to modify your application code. However, in addition to custom code and frameworks or technology not listed in the Compatibility and requirements for the Java agent documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the Java agent API to instrument external calls, messaging frameworks, cross application tracing (CAT), datastores, and web frameworks. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. External API The External API enables applications to report external service calls to New Relic. This information appears on the External services page in APM. To report HTTP external activity, simply create an instance of ExternalParameters using the HttpParameters builder, and call reportAsExternal(ExternalParameters parameters) on the traced method you want to report. External API String library = \"HttpClient\"; // a user-recognizable name for the library that is being used URI uri = request.getURI(); // the URI that is being requested String procedure = \"execute\"; // these are typically named after the method in the library that's being instrumented // construct external parameters ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // report the current method as doing external activity NewRelic.getAgent().getTracedMethod().reportAsExternal(params); Copy External parameters builders There are several builders to create ExternalParameters: DatastoreParameters HttpParameters GenericParameters MessageConsumeParameters MessageProduceParameters These builders create the input parameter object for TracedMethod's reportAsExternal API call. These parameter objects are used for things like linking HTTP external calls via cross application tracing, tracing external calls to a datastore, tracing external calls to a datastore with additional slow query processing, as well as tracing calls between message producers and consumers. Important All of the methods of this class have the potential to expose sensitive private information. Use caution when creating the arguments, paying particular attention to URIs and string values. Cross application tracing API The cross application tracing (CAT) API allows the New Relic Java agent to link transactions across applications monitored by New Relic. The API uses client and server wrappers that allow the agent to read headers from requests, and add headers to responses. Client wrappers For the agent to write outbound request headers in the client initiating the request, use the OutboundHeaders interface. For example: OutbounderHeaders implementation class OutboundWrapper implements OutboundHeaders { private final HttpUriRequest delegate; // OutboundHeaders is implemented by delegating to the library's request object public OutboundWrapper(HttpUriRequest request) { this.delegate = request; } // This allows the agent to add the correct headers to the HTTP request @Override public void setHeader(String name, String value) { delegate.addHeader(name, value); } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy For the agent to read inbound response headers in the client receiving the response, implement the InboundHeaders. For example: InboundHeaders implementation class InboundWrapper implements InboundHeaders { private final CloseableHttpResponse responseHeaders; // OutboundHeaders is implemented by delegating to the library's response object public InboundWrapper(CloseableHttpResponse responseHeaders) { this.responseHeaders = responseHeaders; } // New Relic CAT specifies different header names for HTTP and MESSAGE @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } // this allows the agent to read the correct headers from the HTTP response @Override public String getHeader(String name) { return responseHeaders.getFirstHeader(name).getValue(); } } Copy Server wrappers For the agent to get web request headers, you must extend the ExtendedRequest class: Extend ExtendedRequest class // Extend ExtendedRequest class to create a wrapper for the Request object class RequestWrapper extends ExtendedRequest { private IHTTPSession session; public RequestWrapper(IHTTPSession session) { super(); this.session = session; } @Override public String getRequestURI() { return session.getUri(); } @Override public String getHeader(String name) { return session.getHeaders().get(name); } @Override public String getRemoteUser() { return null; } @SuppressWarnings(\"rawtypes\") @Override public Enumeration getParameterNames() { return Collections.enumeration(session.getParms().keySet()); } @Override public String[] getParameterValues(String name) { return new String[]{session.getParms().get(name)}; } @Override public Object getAttribute(String name) { return null; } @Override public String getCookieValue(String name) { return null; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } @Override public String getMethod() { return session.getMethod().toString(); } } Copy For the agent to set the web response headers, implement the Response interface: Response interface implementation // Implement Response interface to create a wrapper for the outgoing Response object public class ResponseWrapper implements com.newrelic.api.agent.Response { private final Response httpResponse; public ResponseWrapper(Response httpResponse) { this.httpResponse = httpResponse; } @Override public int getStatus() throws Exception { return 200; } @Override public String getStatusMessage() throws Exception { return null; } @Override public void setHeader(String name, String value) { httpResponse.addHeader(name, value); } @Override public String getContentType() { return \"\"; } @Override public HeaderType getHeaderType() { return HeaderType.HTTP; } } Copy CAT implementation using wrappers Using the wrapper objects described in the previous sections, you can enable the Java agent to do cross application tracing (CAT) on the client and server side. For example: Cross application tracing: Client-side @Trace public int makeExternalCall(URI uri) throws IOException { String library = \"HTTPClient\"; String procedure = \"Execute\"; HttpUriRequest request = RequestBuilder.get().setUri(uri).build(); // Wrap the outbound Request object OutboundWrapper outboundHeaders = new OutboundWrapper(request); // Obtain a reference to the method currently being traced TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); // Add headers for outbound external request tracedMethod.addOutboundRequestHeaders(outboundHeaders); CloseableHttpClient connection = HttpClientBuilder.create().build(); CloseableHttpResponse response = connection.execute(request); // Wrap the incoming Response object InboundWrapper inboundHeaders = new InboundWrapper(response); // Create an input parameter object for a call to an external HTTP service ExternalParameters params = HttpParameters .library(library) .uri(uri) .procedure(procedure) .inboundHeaders(inboundHeaders) .build(); // Report a call to an external HTTP service tracedMethod.reportAsExternal(params); return response.getStatusLine().getStatusCode(); } Copy In this sample code, the agent is configured to report an external call using CAT on the client that is initiating the request. These steps can be summarized as follows: Implement OutboundHeaders and InboundHeaders using framework classes on the client. Use addOutboundRequestHeaders(OutboundHeaders outboundHeaders) to have the agent add appropriate headers to the outbound request. Create ExternalParameters object using HttpParameters builder and provide inbound response headers. Report as an external request using reportAsExternal(ExternalParameters params). Cross application tracing: Server-side @Trace(dispatcher = true) @Override public Response serve(IHTTPSession session) { // Obtain a reference to the current Transaction Transaction tx = NewRelic.getAgent().getTransaction(); // Set the name of the current transaction NewRelic.setTransactionName(\"Custom\", \"ExternalHTTPServer\"); // Wrap the Request object ExtendedRequest req = new RequestWrapper(session); // Set the request for the current transaction and convert it into a web transaction tx.setWebRequest(req); queryDB(); Response res = newFixedLengthResponse(\"<html><body><h1>SuccessfulResponse</h1>\\n</body></html>\\n\"); // Set the response for the current transaction and convert it into a web transaction tx.setWebResponse(new ResponseWrapper(res)); // Instruct the transaction to write the outbound response headers tx.addOutboundResponseHeaders(); // Mark the time when the response left the server tx.markResponseSent(); return res; } Copy In this sample code, the agent is configured to report an external call using CAT on the server that is responding to the request. These steps can be summarized as follows: Implement Response and extend the ExtendedRequest class using framework classes on the server. Use setWebRequest(ExtendedRequest request) and setWebResponse(Response response) to convert the transaction into a web transaction and together provide the agent with the inbound request headers and a place to record the outbound headers. It's important to use both setWebRequest(ExtendedRequest request) and setWebResponse(Response response) together, because the transaction name depends on the request object, and the response code depends on the response object. Use addOutboundResponseHeaders() to have the agent add appropriate headers to the outbound response. Mark the end of the response with a call to markResponseSent(). Messaging API The messaging API allows applications to report interactions with message queue brokers. It builds on top of the External API by providing the MessageConsumerParametersMessage and MessageConsumerParameters. This API generates the necessary metrics to identify message broker interactions. The UI will use these metrics to display messaging data including segments in transactions with the appropriate action and count (message put, or message take), a dedicated messages tab in transaction traces, and more. Providing inbound and outbound headers to the API also allows the agent to add CAT headers, and record CAT metrics, which enables the UI to draw service maps that show connections between applications. Important The messaging API relies on two-way communication between producers and consumers. If your producer does not receive an acknowledgment from a consumer, like in a fire-and-forget pattern, the messaging API will not accurately reflect the interactions with message queue brokers. The following example demonstrates how to instrument a fictional JMS library. Messaging API implementation public class MessageProducer { // instrument the method that puts messages on a queue @Trace public void sendMessageToQueue(Message message) { ExternalParameters messageProduceParameters = MessageProduceParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .outboundHeaders(new OutboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageProduceParameters); } } Copy To simplify things, the agent assumes that sendMessageToQueue always puts a message in a named queue. In reality, a message can be sent to different destination types, including named queues, temporary queues, topics, and temporary topics. The API provides an enum to report messages to different destination types: NAMED_QUEUE, TEMP_QUEUE, NAMED_TOPIC, TEMP_TOPIC. It's important to specify the appropriate destination type because the UI will display the names of named queues and named topics and will omit the names of temporary queues and temporary topics. If the library is capable of transmitting CAT headers, an OutboundHeaders object will be provided to the API so that the agent can add CAT headers. Message with CAT headers implementation public class MessageConsumer { @Trace public Message messageReceive() { ExternalParameters messageConsumeParameters = MessageConsumeParameters.library(\"JMS\") .destinationType(DestinationType.NAMED_QUEUE) .destinationName(message.getJMSDestination()) .inboundHeaders(new InboundWrapper(message)) .build(); NewRelic.getAgent().getTracedMethod().reportAsExternal(messageConsumeParameters); return message; } } Copy Datastore API When a traced method is reported as an external datastore call, the call is shown in the APM Databases page. Because datastores are external to the running application, the method is reported as datastore activity using the reportAsExternal(ExternalParameters params) method. The only difference is that a different builder, DatastoreParameters, is used to create the appropriate ExternalParameters object. Datastore API implementation TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .build()); Copy Datastore API: Slow query This API call provides the same behavior as the Datastore API call and extends it to allow slow query information to be tracked. The same reportAsExternal(ExternalParameters params) method and builder are used, but with an additional builder method. Datastore with slow query implementation Creating the appropriate ExternalParameters object is illustrated below: //Reporting a method as doing datastore activity TracedMethod tracedMethod = NewRelic.getAgent().getTracedMethod(); tracedMethod.reportAsExternal( DatastoreParameters .product(\"sqlite\") // the datastore vendor .collection(\"test.db\") // the name of the collection (or table for SQL databases) .operation(\"select\") // the operation being performed, e.g. \"SELECT\" or \"UPDATE\" for SQL databases .instance(\"localhost\", 8080) // the datastore instance information - generally can be found as part of the connection .databaseName(\"test.db\") // may be null, indicating no keyspace for the command .slowQuery(rawQuery,QUERY_CONVERTER) .build()); private static QueryConverter<String> QUERY_CONVERTER = new QueryConverter<String>() { @Override public String toRawQueryString(String statement) { // Do work to transform raw query object to string return statement; } @Override public String toObfuscatedQueryString(String statement) { // Do work to remove any sensitive information here return obfuscateQuery(statement); } }; Copy WebFrameworks API The WebFrameworks API allows the agent to report additional identifying information about the application. // Set the dispatcher name and version which is reported to APM. // The dispatcherName is intended to represent the type of server that this // application is running on such as: Tomcat, Jetty, Netty, etc. NewRelic.setServerInfo(String dispatcherName, String version) // Set the app server port which is reported to APM. NewRelic.setAppServerPort(int port) // Set the instance name in the environment. // A single host:port may support multiple JVM instances. // The instance name is intended to help identify a specific JVM instance. NewRelic.setInstanceName(String instanceName) Copy Tip These values can be set only once. Subsequent calls will have no effect. WebFrameworks API implementation public NewRelicApiClient() throws IOException, URISyntaxException { super(8080); // Set Dispatcher name and version. NewRelic.setServerInfo(\"NanoHttp\", \"2.3.1\"); // Set Appserver port for jvm identification NewRelic.setAppServerPort(8080); // Set JVM instance name NewRelic.setInstanceName(\"Client:8080\"); start(NanoHTTPD.SOCKET_READ_TIMEOUT, false); System.out.println(\"\\nRunning on http://localhost:8080/ \\n\"); } Copy For more help Additional documentation resources include: New Relic Java agent API Javadoc (detailed API documentation on GitHub) Java agent API example (example application using custom instrumentation for cross application tracing and external datastore calls) Java agent API guide (goal-driven guide to using the Java agent API) Java instrumentation by annotation (how to use annotations to instrument your application code)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.1857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument external calls, messaging, datastore, web frameworks",
        "tags": "<em>API</em> <em>guides</em>",
        "body": " or technology not listed in the Compatibility and requirements for the <em>Java</em> <em>agent</em> documentation, some implementations of supported frameworks may require custom instrumentation. This document describes how to use the <em>Java</em> <em>agent</em> <em>API</em> to instrument external calls, messaging frameworks, cross application"
      },
      "id": "6043c7f828ccbcef982c6077"
    }
  ],
  "/docs/agents/java-agent/api-guides/java-agent-api-instrumenting-example-app-external-datastore-calls-cat": [
    {
      "sections": [
        "Java agent API: Instrument using annotation",
        "Important",
        "Configure your agent for annotations",
        "@Trace",
        "Create a new transaction",
        "Add detail to your transactions",
        "Convert a transaction to a web request",
        "Define your own @Trace annotation class",
        "Properties for @Trace",
        "dispatcher",
        "async",
        "metricName",
        "excludeFromTransactionTrace",
        "leaf",
        "@TraceLambda",
        "Properties for @TraceLambda",
        "pattern",
        "includeNonstatic",
        "@TraceByReturnType",
        "Properties for @TraceByReturnType",
        "traceReturnTypes",
        "Performance considerations",
        "Caution",
        "More API functions"
      ],
      "title": "Java agent API: Instrument using annotation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "4a373504c0682b36745d2283fdd902ead43510ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation/",
      "published_at": "2021-10-18T03:44:06Z",
      "updated_at": "2021-07-15T18:31:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent provides several options for custom instrumentation. One of those options is adding the Java agent API's @Trace, @TraceLambda or @TraceByReturnType annotations to your application code. This document describes how to use annotations. Important To use annotations, you must modify the source code. If you can't or don't want to modify your source code, see Custom instrumentation for other instrumentation options. Configure your agent for annotations By default, the configuration setting enable_custom_tracing is set to true in the Java agent, which is the setting required for @Trace annotations to function. This setting is not included in the newrelic.yml by default. The only time you need to incorporate this setting into your configuration file is if you want to disable @Trace annotations altogether. To do this, set enable_custom_tracing: false (prefaced with two spaces) in the common stanza of your newrelic.yml. Make sure that newrelic-api.jar appears in your classpath as it contains all these annotations. @Trace Annotating a method with @Trace tells the Java agent that measurements should be taken for that method. To add a method call as a custom trace add @Trace annotations to your method. import com.newrelic.api.agent.Trace; ... @Trace public void run() { // background task } Copy Create a new transaction If transactions do not appear and you want to start a new transaction, include dispatcher=true with the @Trace annotation: @Trace (dispatcher=true) public void run() { // background task } Copy Add detail to your transactions If your transaction traces show large blocks of uninstrumented time and you want to include some more methods within the trace, you can use the @Trace annotation without parameters: @Trace protected void methodWithinTransaction() { // work } Copy Convert a transaction to a web request To make a background task report as a web browser transaction with a Java agent API call: In the method annotated with @Trace(dispatcher=true), call: NewRelic.setRequestAndResponse(Request request, Response response) Copy The arguments are implementations of the Request and Response interfaces in newrelic-api.jar. Important Even if your Request and Response objects already are present, you still need to add this API call. Define your own @Trace annotation class If you define your own @Trace annotation class, there is no dependency on the newrelic-api.jar. To define the class: package com.test; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Trace { public static final String NULL = \"\"; String metricName() default NULL; boolean dispatcher() default false; String tracerFactoryName() default NULL; } Copy Then, configure the agent to use this annotation in the common section of the newrelic.yml: class_transformer: trace_annotation_class_name: com.test.Trace Copy Properties for @Trace The @Trace annotation supports the following properties. dispatcher Type: Boolean Default: false If true, the agent will start a transaction when it reaches a method with this @Trace annotation if a transaction is not already in progress. If a transaction is already in progress, the method with this annotation will be included in the ongoing transaction, rather than starting a new one. If false (default), no metrics will be recorded if the agent has not started a transaction before the @Trace annotation is reached. For example: @Trace(dispatcher=true) Copy async Type: Boolean Default: false If true, this method is marked as asynchronous and the agent will trace this method if it linked to an existing transaction. For example: @Trace(async=true) Copy If false (default), the method is not marked as asynchronous. If other @Trace annotations are present and the method is not executing asynchronously, it will still be traced. metricName Type: String Default: (none) This property affects transaction traces and error reporting. By default, the metric name will include the class name followed by the method name. If you do not want class followed by method, then you can use this property to change the metric name. If you set the metricName, as in @Trace(metricName=\"YourMessageHere\"), then the time spent in this method will appear as YourMessageHere in any transaction trace. If you set the metricName in addition to the dispatcher, as in @Trace(metricName=\"YourMessageHere\", dispatcher=true), then the transaction name will appear as YourMessageHere in the APM Transactions page but the time spent in this method will not appear as YourMessageHere in any transaction trace. Here is an example: @Trace(metricName=\"YourMetricName\") Copy Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. excludeFromTransactionTrace Type: Boolean Default: false If true, the method will be excluded from the transaction trace. The agent will still collect metrics for the method. Here is an example: @Trace(excludeFromTransactionTrace=true) Copy leaf Type: Boolean Default: false A leaf tracer has no child tracers. This is useful when you want all time attributed to the tracer, even if other trace points are encountered the tracer's execution. Database tracers often act as a leaf so that all time is attributed to database activity, even if instrumented external calls are made. Here is an example: @Trace(leaf=true) Copy If a leaf tracer does not participate in transaction traces, the agent can create a tracer with lower overhead. Here is an example: @Trace(excludeFromTransactionTrace=true, leaf=true) Copy @TraceLambda If your transaction traces show large blocks of uninstrumented time and you want to include lambda expressions within the trace, you can use the @TraceLambda annotation without parameters: import com.newrelic.api.agent.TraceLambda; @TraceLambda class ClassContainingLambdaExpressions() { // work } Copy Lambda expressions become static methods of the containing class after compilation. By default, static methods within classes marked with the @TraceLambda annotation matching the annotations pattern will be marked with the @Trace annotation. Properties for @TraceLambda The @TraceLambda annotation supports the following properties. pattern Type: String Default: ^\\$?(lambda\\|anonfun)\\$(?\\<name\\>.*) If you set the pattern, as in @TraceLambda(pattern=\"YourPattern\"), then the marked classes method names will be matched against the regex pattern YourPattern. If matched the related method will be marked with the @Trace annotation. Here is an example: @TraceLambda(pattern=\"YourPattern\") Copy includeNonstatic Type: Boolean Default: false If true, the marked classes nonstatic methods will be eligible for assessment against the pattern for instrumentation. Here is an example: @TraceLambda(includeNonstatic=\"true\") Copy @TraceByReturnType To include methods with a particular return type within the trace, you can use the @TraceByReturnType annotation to mark a class passing the return types as a property. Methods in annotated classes that match one of the specified return types will be marked with the @Trace annotation. @TraceByReturnType(traceReturnTypes={Integer.class, String.class}) class ClassContainingMethods() { // ... } Copy Properties for @TraceByReturnType The @TraceByReturnType annotation supports the following properties. traceReturnTypes Type: List < Class> Default: empty list If you set the traceReturnTypes, as in @TraceByReturnType(traceReturnTypes={String.class}), then the marked classes method return types will be matched against the String.class. All matched methods will be marked with the @Trace annotation. Here is an example: @TraceByReturnType(traceReturnTypes={Integer.class, String.class}) class ClassContainingMethods() { public String doSomething() { // matches // ... } public Long somethingElse() { // does not match // ... } } Copy Performance considerations When the Java agent is present in the JVM, it will inject code on the annotated methods. The performance hit is negligible in heavyweight operations, such as database or webservice calls, but is noticeable in methods that are called frequently, such as an accessor called thousands of times a second. Caution Do not instrument all of your methods, as this can lead to decreased performance and to a metric grouping issue. More API functions For more about the Java agent API and its functionality, see the Java agent API introduction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.47116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Instrument using annotation",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> provides several options for custom instrumentation. One of those options is adding the <em>Java</em> <em>agent</em> <em>API</em>&#x27;s @Trace, @TraceLambda or @TraceByReturnType annotations to your application code. This document describes how to use annotations. Important To use annotations, you must"
      },
      "id": "603eb64a28ccbc9ca2eba79f"
    },
    {
      "sections": [
        "Java agent API: Custom instrumentation with annotation of an example app",
        "Important",
        "Complete example app using API",
        "Tip",
        "Complete API call example",
        "How the example uses the API",
        "Import the needed packages",
        "Set @Trace for transaction traces",
        "Create custom names for web transactions",
        "Bypass Apdex when collecting non-public data",
        "Record the user ID",
        "Collect promotion data",
        "Send instructions to the handler",
        "Include page load timing code in the HTTP response",
        "Complete the HTTP response"
      ],
      "title": "Java agent API: Custom instrumentation with annotation of an example app",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "a6a2aadf63f8282b7d599579f67010fbd600d183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-custom-instrumentation-annotation-example-app/",
      "published_at": "2021-10-18T02:46:00Z",
      "updated_at": "2021-07-09T06:24:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you set up custom instrumentation for your Java application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the API, ensure you have the latest Java agent release. Complete example app using API Below is an example of an imaginary store app's servlet using the Java agent API. Tip If you copy and paste example code, be sure to use appropriate spacing on your command lines. Complete API call example package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } } String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } } protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy How the example uses the API Here is the same example app divided into sections that describe how the API is used: Import the needed packages This part of the example shows the imports needed for the example application and Java agent API. package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; Copy Set @Trace for transaction traces This part of the API call provides instructions to instrument this call using New Relic's trace annotation @Trace. Any requests that hit processRequest will now show a segment in APM's Transaction trace call chart. public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } Copy Create custom names for web transactions This part of the API call instructs web transactions containing a storeId value to appear in APM's Transactions page with the custom transaction name you set. A request to any one store will appear under the same, aggregate name. private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); } } Copy Bypass Apdex when collecting non-public data This part of the API call excludes the non-public beta storeID from affecting the Apdex score. if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } Copy Record the user ID This part of the API call inserts additional metadata into the page load timing request so that browser traces can be tied with the userId. It also records the userId as a custom parameter on the transaction so that it appears in the parameter details of a transaction trace. (Page load timing sometimes is referred to as real user monitoring or RUM.) String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } Copy Collect promotion data This part of the API call records the number of times a promotion was viewed so that the metrics can appear on a custom dashboard. Important For metrics you want to graph in custom dashboards, be sure to prepend Custom/ to the metric name; for example, Custom/Promotion. String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } Copy Send instructions to the handler This part of the API call sends a set of instructions to the handler for processing requests and handling exceptions. protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { Copy Include page load timing code in the HTTP response This part of the API call defines what to include in the HttpServletResponse. For manual instrumentation of browser monitoring to monitor page load timing (sometimes referred to as real user monitoring or RUM): Set the header after the < head> tag. Set the footer at the end of < body> tag. resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } Copy Complete the HTTP response This part of the API call defines the remaining information to include in the HttpServletResponse response. protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.90597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you set up custom instrumentation for your <em>Java</em> application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the <em>API</em>, ensure you have the latest <em>Java</em> <em>agent</em> release"
      },
      "id": "603eb76a64441f48424e886b"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-10-18T02:14:44Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.65321,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em> ",
        "sections": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This <em>API</em> consists of: Static methods on the com.newrelic.<em>api.agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of <em>API</em> objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/async-instrumentation/disable-scala-netty-akka-play-2-instrumentation": [
    {
      "sections": [
        "Troubleshoot Java asynchronous instrumentation",
        "Verify your instrumentation",
        "Use logs to troubleshoot",
        "Problem: Transaction times are too long",
        "Problem: No transaction trace data",
        "Problem: Too few async calls",
        "Ensure that each activity you monitor is appropriately linked",
        "Check if you are missing required annotations"
      ],
      "title": "Troubleshoot Java asynchronous instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "0f21da73ba02edc45ec0cbbbaa7e0fc45678404b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/troubleshoot-java-asynchronous-instrumentation/",
      "published_at": "2021-10-18T02:21:09Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are having problems using the Java agent API for async tokens and segments, use these techniques to help you find answers and solve problems. Verify your instrumentation The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use these techniques to verify that your applications instrumentation is correct: After instrumenting your code, verify that the logs show that an equal number of tokens have been created and expired. For more information on which log messages to look for, see Use logs to troubleshoot. Check the garbage collection statistics under APM's JVMs page to determine whether or not your changes have significantly altered garbage collection patterns. Check if any segments or tokens are timing out by reviewing your transaction traces for a timed_out attribute. If so, you can change the limit with token_timeout and segment_timeout. Use logs to troubleshoot To customize your Java agent logging, see Generating logs. Then, you can examine your logs for these common messages: To view created tokens, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: created active token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view expired tokens and the time that they expired, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: expired token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view created segments, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@486b7f04: startSegment(): com.newrelic.agent.Segment@2b7fdad3 created and started with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy To view ended segments and the time that they ended, check logs at FINEST for: com.newrelic.agent.Transaction@486b7f04--finish segment(): com.newrelic.agent.Segment@2b7fdad3 async finish with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy Problem: Transaction times are too long Make sure to expire tokens and end or ignore segments; otherwise transactions may take longer to report to New Relic. The Java agent has a timeout mechanism for tokens and segments that are not ended correctly. For more information, see token_timeout and segment_timeout. Problem: No transaction trace data Inspect transaction traces to make sure expected asynchronous work is reported. If you do not see any transaction traces, make sure your transaction duration exceeds the transaction trace threshold set in transaction_threshold. Problem: Too few async calls If too few calls are being reported: Ensure that each activity you monitor is appropriately linked In the faulty example below, a parallel stream is being used, which means that the work done inside the lambda in the call to map() can be scheduled on a different thread than the thread handling the request. Without creating a token to link all this work together, you will not see any of the work that gets scheduled on a different thread inside of your transaction. @RequestMapping(\"parallel_stream_bad\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad(@RequestParam(\"ids\") List<long> ids) { List<item> results = ids .parallelStream() .map(i -> requestItem(i)) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad\", results); } Copy Check if you are missing required annotations The example below will report only a subset of the calls to requestItem() because it is impossible to put @Trace(async = true) around blocks of anonymous work inside the call to map(). Instead, you should pass the token into requestItem() and link it, and then add @Trace(async=true) around it. Or use a helper function like requestItemAsync() to do this without changing your existing methods. @RequestMapping(\"parallel_stream_bad2\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad2(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> { token.link(); return requestItem(id); }) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad2\", results); } Copy Compare this to the correct example below, in which the lambda expression is wrapped by the wrapper class InstrumentedCallable. This class accepts a token and a lambda, then wraps asynchronous work in @Trace(async = true) and uses a token to link the work to the request thread. @RequestMapping(\"parallel_stream_wrap\") @Trace(dispatcher = true) public ResponseEntity parallelStreamWrap(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> InstrumentedCallable.instrumentCallable(token, () -> requestItem(id))) .map(c -> c.call()) .filter(item -> item != null) .collect(Collectors.toList()); token.expire(); return formattedResponse(\"parallel_stream_wrap\", results); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.99493,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "sections": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "If you are having problems using the <em>Java</em> <em>agent</em> API for <em>async</em> tokens and segments, use these techniques to help you find answers and solve problems. Verify your <em>instrumentation</em> The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use"
      },
      "id": "603eb55a196a67260aa83dac"
    },
    {
      "sections": [
        "Java agent API for asynchronous applications",
        "Async tracking tools: Tokens and segments",
        "Tokens: Connect async threads",
        "1. Start a transaction, then create and expire a token",
        "2. Mark a transaction as async and link to request thread",
        "3. View your async trace in the New Relic UI",
        "Tip",
        "Segments: Time arbitrary async activity",
        "1. Create a transaction and call an external service",
        "2. Start a segment, report externals, and end the segment"
      ],
      "title": "Java agent API for asynchronous applications",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7b5f035809040487d96279fb318203b479a61b02",
      "image": "https://docs.newrelic.com/static/06c87505ee5c0d97e598d04258587f52/c1b63/Screen-Shot-2017-03-14-at-4.50.31-PM.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/java-agent-api-asynchronous-applications/",
      "published_at": "2021-10-18T03:48:35Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java (agent version 3.37 or higher) includes an API to instrument asynchronous activity. For supported frameworks, the agent usually instruments async work automatically. However, the async API can still be useful to add detail. This document provides examples of using tokens and segments to instrument your app. For more information about how New Relic instruments and displays async work in the APM UI, see Monitoring considerations for asynchronous applications. For details on the actual classes and methods, see the Javadoc. For general information on the Java agent API, see the Java agent API guide. For troubleshooting common problems, see Troubleshooting Java asynchronous applications. Async tracking tools: Tokens and segments The Java agent API provides two ways to trace asynchronous activity: Tokens: Tokens are passed between threads to link asynchronous units of work to a specific transaction. They do not perform any timing directly. Segments: Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. Segments are typically used to track external calls that are completed by a callback mechanism. Tokens: Connect async threads Use tokens to link arbitrary units of work that are on separate threads. This section describes how to use the token-related calls together to instrument async work. For detailed information on classes and methods, see the Javadoc. To use tokens, you first need to create the token, then link another call to the originating transaction. You should link the token as soon as possible within the other call. If you do not link the token immediately, you risk losing any methods that contain an @Trace below the call you are trying to link. You can also expire the token in the original call. The Java agent will then link the work in the New Relic UI. These examples illustrate how to use the token-related calls together: 1. Start a transaction, then create and expire a token Consider the method parallelStream() in the code snippet below. Because some of the calls to requestItemAsync() will occur on a separate thread, a token is created and passed to link that asynchronous work back to the requesting thread. /** * Example showing multi-threaded implementation of requesting data using a parallel {@link Stream}. */ @RequestMapping(\"parallel_stream\") @Trace(dispatcher = true) // starts a transaction public ResponseEntity<String> parallelStream(@RequestParam(\"ids\") List<Long> ids) { final Token token = NewRelic.getAgent().getTransaction(). getToken() ; List<item> results = ids .parallelStream() .map(id -> requestItemAsync\\(id, token)) // note we're calling a different method than parallelStreamBad .filter(item -> item != null) .collect(Collectors.toList()); token.expire() ; return formattedResponse(\"parallel_stream\", results); } Copy The agent API calls in this sample are: @Trace(dispatcher = true): Tells the agent to start a transaction. For more on this method, see the Javadoc. getToken(): Creates the token which will link the work together. For more on this method, see the Javadoc. token.expire(): Expires the token. This allows the transaction to end. For more on this method, see the Javadoc. 2. Mark a transaction as async and link to request thread The following code example shows requestItemAsync, which might execute on a separate thread from the requesting thread. For this reason, the token that was created in the previous code example is linked to the Transaction in requestItemAsync. Note that requestItemAsync() has the @Trace(async=true) annotation, which tells the agent to trace this method if it's linked to an existing transaction. After parallelStream() collects all results, the token is expired. This is important because it makes sure the transaction doesn't stay open after parallelStream() completes. @Trace(async = true) private Item requestItemAsync(long id, Token token) { token.link() ; return requestItem(id); } Copy The agent API calls in this sample are: @Trace(async = true): Starts a transaction. For more on this method, see the Javadoc. token.link(): Links the work being done in requestItemAsync() (which is executing on a different thread) to the requesting thread. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI Here's an example of a transaction trace in the APM UI for this endpoint: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: All asynchronous method calls linked with a token are indicated with an Async icon. All asynchronous method calls linked with a token are indicated with an Async icon in the Drilldown column. It's not necessary to link methods that are on the same thread, but doing so will have no negative effect. It's often the case that a single token can be shared, like in the parallelStream() example. Tip By default, a transaction can create a maximum of 3000 tokens and each token has a default timeout of 180s. You can change the former limit with the token_limit config option and the latter with the token_timeout config option. Traces for transactions that exceed the token_limit will contain a token_clamp attribute. Increasing either config option may increase agent memory usage. Segments: Time arbitrary async activity Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. This is most commonly used to time connections to external services. Use segments if you want to: Time code that completes via a callback Time an asynchronous call that spans many methods Measure the time between when work is created and when it executed (for example, in a thread pool) 1. Create a transaction and call an external service The method below makes a call to an external service (in this case a database) using the method storeItem(): /** * Example showing single threaded implementation of inserting data into a datasource. */ @RequestMapping(\"insert\") @Trace(dispatcher = true) //starts a transaction public ResponseEntity insert(@RequestParam(\"id\") Long id) { if (id != null) { storeItem(id); return new ResponseEntity<>(\"insert\", HttpStatus.OK); } else { return new ResponseEntity<>(\"insert\", HttpStatus.BAD_REQUEST); } } Copy The goal in this case it to find out how long the Callable in the Lambda statement is waiting in the thread pool before executing, rather than determining how long storeItem() runs. For this reason, a segment is used instead of a token, and @Trace(async = true) is not necessary like it was for a token. The agent API call in this sample is: @Trace(dispatcher = true): Starts a transaction. For more on this method, see the Javadoc. 2. Start a segment, report externals, and end the segment The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI When the method completes, APM displays a transaction trace with one external call: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: A single asynchronous segment is called out in the Drilldown column. Tip By default, the agent can track a maximum of 1000 segments during a given transaction. You can change this limit with the segment_timeout config option. Traces of transactions that exceed this limit will contain a segment_clamp attribute. Increasing this limit may increase agent memory usage.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.99489,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "sections": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> (<em>agent</em> version 3.37 or higher) includes an API to <em>instrument</em> asynchronous activity. For supported frameworks, the <em>agent</em> usually instruments <em>async</em> work automatically. However, the <em>async</em> API can still be useful to add detail. This document provides examples of using tokens"
      },
      "id": "603eb4c9196a67dde5a83db7"
    },
    {
      "sections": [
        "Introduction to Java async instrumentation",
        "Asynchronous operations",
        "Async and thread-switching",
        "Async and response time",
        "Custom instrumentation with the async API"
      ],
      "title": "Introduction to Java async instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "3b0a9e1f2f6b69a8ad101ec59c592ac4a574ae63",
      "image": "https://docs.newrelic.com/static/a38112969f7c8a3001651b65853a803b/39c09/sZ6-I4x5BDSDspRS_G7Hefg.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/introduction-java-async-instrumentation/",
      "published_at": "2021-10-18T05:34:29Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java includes a set of API methods for custom instrumentation of asynchronous activity. This is most useful to instrument asynchronous activity in unsupported frameworks, but you can also use the API to add additional instrumentation to supported frameworks. This document explains how asynchronous activity occurs, and how New Relic monitors async work. Asynchronous operations With a synchronous programming model, programming tasks are usually executed in a specific order. One task must complete before the next task begins, and each task blocks the next task from completing. Asynchronous programming uses a non-blocking model, so that tasks can be run in parallel. Tasks executed asynchronously are completely independent of each other in their execution and initialization. Because asynchronous code doesn't execute in a specific order, the server's full processing power can be used more efficiently, and the app's throughput increases. Async and thread-switching For applications that use asynchronous processing, thread-switching is when a program or task switches from one thread to another. Understanding these asynchronous interleavings can help you decide which methods should be instrumented. Here is an example method with a controller that makes external requests in parallel. These requests execute asynchronously, so each request executes independently of each other and getScoreAsync() returns immediately after being called. This allows the requesting thread to continue making requests while getScoreAsync() makes an external call and sends a reply. @ResponseBody @RequestMapping(\"getScores\", method = RequestMethod.Get produces = text/plain) public String getCreditScores(@RequestParam(name = \"uids\") uids) { return Arrays.stream(uids.split(\",\")) .parallel() .map(Integer::valueOf) .map(uid -> getScoreAsync(uid)) .collect(Collectors.toList());} Copy Some of these requests will finish before others. Some might even finish after the requesting thread has moved on to other tasks: With New Relic's asynchronous instrumentation, the APM UI flags the work as Async. For example, if the above method were instrumented by New Relic (either automatically or via custom instrumentation), this is what the APM UI would show on the Trace details page: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: When asynchronous activity in a Java application is detected by APM, it is indicated with the Async flag in the Drilldown column. Async and response time Response time is defined as the duration of a transaction from the perspective of the requester. For asynchronous applications, the response time is often less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Because tasks can be deferred, the application can take advantage of its limited resources and process things more quickly. The chart's response time line gives you more insight into the perceived behavior and speed of your application than does the total web transaction time: one.newrelic.com > APM > (select an app) > Summary: On the APM Summary page, asynchronous activity in a Java app can result in the response time (the blue line) being less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Custom instrumentation with the async API To implement custom instrumentation of async work, see the Java agent async API guide. For general information on how to use the Java agent API, see Java agent API guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.99489,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "sections": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " transaction time. This is because the methods don&#x27;t have to wait for all preceding methods to complete before returning. Custom <em>instrumentation</em> with the <em>async</em> API To implement custom <em>instrumentation</em> of <em>async</em> work, see the <em>Java</em> <em>agent</em> <em>async</em> API guide. For general information on how to use the <em>Java</em> <em>agent</em> API, see <em>Java</em> <em>agent</em> API guide."
      },
      "id": "603eb491e7b9d282bd2a07ca"
    }
  ],
  "/docs/agents/java-agent/async-instrumentation/introduction-java-async-instrumentation": [
    {
      "sections": [
        "Troubleshoot Java asynchronous instrumentation",
        "Verify your instrumentation",
        "Use logs to troubleshoot",
        "Problem: Transaction times are too long",
        "Problem: No transaction trace data",
        "Problem: Too few async calls",
        "Ensure that each activity you monitor is appropriately linked",
        "Check if you are missing required annotations"
      ],
      "title": "Troubleshoot Java asynchronous instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "0f21da73ba02edc45ec0cbbbaa7e0fc45678404b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/troubleshoot-java-asynchronous-instrumentation/",
      "published_at": "2021-10-18T02:21:09Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are having problems using the Java agent API for async tokens and segments, use these techniques to help you find answers and solve problems. Verify your instrumentation The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use these techniques to verify that your applications instrumentation is correct: After instrumenting your code, verify that the logs show that an equal number of tokens have been created and expired. For more information on which log messages to look for, see Use logs to troubleshoot. Check the garbage collection statistics under APM's JVMs page to determine whether or not your changes have significantly altered garbage collection patterns. Check if any segments or tokens are timing out by reviewing your transaction traces for a timed_out attribute. If so, you can change the limit with token_timeout and segment_timeout. Use logs to troubleshoot To customize your Java agent logging, see Generating logs. Then, you can examine your logs for these common messages: To view created tokens, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: created active token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view expired tokens and the time that they expired, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: expired token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view created segments, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@486b7f04: startSegment(): com.newrelic.agent.Segment@2b7fdad3 created and started with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy To view ended segments and the time that they ended, check logs at FINEST for: com.newrelic.agent.Transaction@486b7f04--finish segment(): com.newrelic.agent.Segment@2b7fdad3 async finish with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy Problem: Transaction times are too long Make sure to expire tokens and end or ignore segments; otherwise transactions may take longer to report to New Relic. The Java agent has a timeout mechanism for tokens and segments that are not ended correctly. For more information, see token_timeout and segment_timeout. Problem: No transaction trace data Inspect transaction traces to make sure expected asynchronous work is reported. If you do not see any transaction traces, make sure your transaction duration exceeds the transaction trace threshold set in transaction_threshold. Problem: Too few async calls If too few calls are being reported: Ensure that each activity you monitor is appropriately linked In the faulty example below, a parallel stream is being used, which means that the work done inside the lambda in the call to map() can be scheduled on a different thread than the thread handling the request. Without creating a token to link all this work together, you will not see any of the work that gets scheduled on a different thread inside of your transaction. @RequestMapping(\"parallel_stream_bad\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad(@RequestParam(\"ids\") List<long> ids) { List<item> results = ids .parallelStream() .map(i -> requestItem(i)) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad\", results); } Copy Check if you are missing required annotations The example below will report only a subset of the calls to requestItem() because it is impossible to put @Trace(async = true) around blocks of anonymous work inside the call to map(). Instead, you should pass the token into requestItem() and link it, and then add @Trace(async=true) around it. Or use a helper function like requestItemAsync() to do this without changing your existing methods. @RequestMapping(\"parallel_stream_bad2\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad2(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> { token.link(); return requestItem(id); }) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad2\", results); } Copy Compare this to the correct example below, in which the lambda expression is wrapped by the wrapper class InstrumentedCallable. This class accepts a token and a lambda, then wraps asynchronous work in @Trace(async = true) and uses a token to link the work to the request thread. @RequestMapping(\"parallel_stream_wrap\") @Trace(dispatcher = true) public ResponseEntity parallelStreamWrap(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> InstrumentedCallable.instrumentCallable(token, () -> requestItem(id))) .map(c -> c.call()) .filter(item -> item != null) .collect(Collectors.toList()); token.expire(); return formattedResponse(\"parallel_stream_wrap\", results); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.99493,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "sections": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "If you are having problems using the <em>Java</em> <em>agent</em> API for <em>async</em> tokens and segments, use these techniques to help you find answers and solve problems. Verify your <em>instrumentation</em> The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use"
      },
      "id": "603eb55a196a67260aa83dac"
    },
    {
      "sections": [
        "Java agent API for asynchronous applications",
        "Async tracking tools: Tokens and segments",
        "Tokens: Connect async threads",
        "1. Start a transaction, then create and expire a token",
        "2. Mark a transaction as async and link to request thread",
        "3. View your async trace in the New Relic UI",
        "Tip",
        "Segments: Time arbitrary async activity",
        "1. Create a transaction and call an external service",
        "2. Start a segment, report externals, and end the segment"
      ],
      "title": "Java agent API for asynchronous applications",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7b5f035809040487d96279fb318203b479a61b02",
      "image": "https://docs.newrelic.com/static/06c87505ee5c0d97e598d04258587f52/c1b63/Screen-Shot-2017-03-14-at-4.50.31-PM.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/java-agent-api-asynchronous-applications/",
      "published_at": "2021-10-18T03:48:35Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java (agent version 3.37 or higher) includes an API to instrument asynchronous activity. For supported frameworks, the agent usually instruments async work automatically. However, the async API can still be useful to add detail. This document provides examples of using tokens and segments to instrument your app. For more information about how New Relic instruments and displays async work in the APM UI, see Monitoring considerations for asynchronous applications. For details on the actual classes and methods, see the Javadoc. For general information on the Java agent API, see the Java agent API guide. For troubleshooting common problems, see Troubleshooting Java asynchronous applications. Async tracking tools: Tokens and segments The Java agent API provides two ways to trace asynchronous activity: Tokens: Tokens are passed between threads to link asynchronous units of work to a specific transaction. They do not perform any timing directly. Segments: Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. Segments are typically used to track external calls that are completed by a callback mechanism. Tokens: Connect async threads Use tokens to link arbitrary units of work that are on separate threads. This section describes how to use the token-related calls together to instrument async work. For detailed information on classes and methods, see the Javadoc. To use tokens, you first need to create the token, then link another call to the originating transaction. You should link the token as soon as possible within the other call. If you do not link the token immediately, you risk losing any methods that contain an @Trace below the call you are trying to link. You can also expire the token in the original call. The Java agent will then link the work in the New Relic UI. These examples illustrate how to use the token-related calls together: 1. Start a transaction, then create and expire a token Consider the method parallelStream() in the code snippet below. Because some of the calls to requestItemAsync() will occur on a separate thread, a token is created and passed to link that asynchronous work back to the requesting thread. /** * Example showing multi-threaded implementation of requesting data using a parallel {@link Stream}. */ @RequestMapping(\"parallel_stream\") @Trace(dispatcher = true) // starts a transaction public ResponseEntity<String> parallelStream(@RequestParam(\"ids\") List<Long> ids) { final Token token = NewRelic.getAgent().getTransaction(). getToken() ; List<item> results = ids .parallelStream() .map(id -> requestItemAsync\\(id, token)) // note we're calling a different method than parallelStreamBad .filter(item -> item != null) .collect(Collectors.toList()); token.expire() ; return formattedResponse(\"parallel_stream\", results); } Copy The agent API calls in this sample are: @Trace(dispatcher = true): Tells the agent to start a transaction. For more on this method, see the Javadoc. getToken(): Creates the token which will link the work together. For more on this method, see the Javadoc. token.expire(): Expires the token. This allows the transaction to end. For more on this method, see the Javadoc. 2. Mark a transaction as async and link to request thread The following code example shows requestItemAsync, which might execute on a separate thread from the requesting thread. For this reason, the token that was created in the previous code example is linked to the Transaction in requestItemAsync. Note that requestItemAsync() has the @Trace(async=true) annotation, which tells the agent to trace this method if it's linked to an existing transaction. After parallelStream() collects all results, the token is expired. This is important because it makes sure the transaction doesn't stay open after parallelStream() completes. @Trace(async = true) private Item requestItemAsync(long id, Token token) { token.link() ; return requestItem(id); } Copy The agent API calls in this sample are: @Trace(async = true): Starts a transaction. For more on this method, see the Javadoc. token.link(): Links the work being done in requestItemAsync() (which is executing on a different thread) to the requesting thread. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI Here's an example of a transaction trace in the APM UI for this endpoint: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: All asynchronous method calls linked with a token are indicated with an Async icon. All asynchronous method calls linked with a token are indicated with an Async icon in the Drilldown column. It's not necessary to link methods that are on the same thread, but doing so will have no negative effect. It's often the case that a single token can be shared, like in the parallelStream() example. Tip By default, a transaction can create a maximum of 3000 tokens and each token has a default timeout of 180s. You can change the former limit with the token_limit config option and the latter with the token_timeout config option. Traces for transactions that exceed the token_limit will contain a token_clamp attribute. Increasing either config option may increase agent memory usage. Segments: Time arbitrary async activity Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. This is most commonly used to time connections to external services. Use segments if you want to: Time code that completes via a callback Time an asynchronous call that spans many methods Measure the time between when work is created and when it executed (for example, in a thread pool) 1. Create a transaction and call an external service The method below makes a call to an external service (in this case a database) using the method storeItem(): /** * Example showing single threaded implementation of inserting data into a datasource. */ @RequestMapping(\"insert\") @Trace(dispatcher = true) //starts a transaction public ResponseEntity insert(@RequestParam(\"id\") Long id) { if (id != null) { storeItem(id); return new ResponseEntity<>(\"insert\", HttpStatus.OK); } else { return new ResponseEntity<>(\"insert\", HttpStatus.BAD_REQUEST); } } Copy The goal in this case it to find out how long the Callable in the Lambda statement is waiting in the thread pool before executing, rather than determining how long storeItem() runs. For this reason, a segment is used instead of a token, and @Trace(async = true) is not necessary like it was for a token. The agent API call in this sample is: @Trace(dispatcher = true): Starts a transaction. For more on this method, see the Javadoc. 2. Start a segment, report externals, and end the segment The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI When the method completes, APM displays a transaction trace with one external call: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: A single asynchronous segment is called out in the Drilldown column. Tip By default, the agent can track a maximum of 1000 segments during a given transaction. You can change this limit with the segment_timeout config option. Traces of transactions that exceed this limit will contain a segment_clamp attribute. Increasing this limit may increase agent memory usage.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.99489,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "sections": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> (<em>agent</em> version 3.37 or higher) includes an API to <em>instrument</em> asynchronous activity. For supported frameworks, the <em>agent</em> usually instruments <em>async</em> work automatically. However, the <em>async</em> API can still be useful to add detail. This document provides examples of using tokens"
      },
      "id": "603eb4c9196a67dde5a83db7"
    },
    {
      "sections": [
        "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
        "Contents",
        "Java agent versions 3.21 or lower",
        "Java agent versions 3.22 or higher",
        "Check for deprecated configuration settings"
      ],
      "title": "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7a6fa946f9f903c240099279d125807b89665668",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/disable-scala-netty-akka-play-2-instrumentation/",
      "published_at": "2021-10-18T06:20:05Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to disable Java agent instrumentation on these popular async frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this instrumentation if you find that the metrics reported aren't valuable to you, or if the instrumentation incurs more overhead than you would like. If you selectively disable some of the instrumentation, some segments of activity will not be reported and your total time will be understated. Contents Java agent versions 3.21 or lower If you are using Java agent version 3.22 or lower, add the following to the class_transformer section of your newrelic.yml settings: # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings class_transformer: akka_instrumentation: enabled: false netty_instrumenation: enabled: false play2_instrumentation: enabled: false scala_instrumentation: enabled: false Copy Java agent versions 3.22 or higher The older Scala, Netty, Akka, and Play 2 Framework instrumentation configuration names have been deprecated as of Java Agent version 3.22. For those using Java Agent 3.22 or higher, add the following to the class_transformer section of your newrelic.yml settings: common: &default_settings class_transformer: # Disable all Akka instrumentations com.newrelic.instrumentation.akka-2.0: enabled: false com.newrelic.instrumentation.akka-2.1: enabled: false # Disabling 2.2 also disables higher versions com.newrelic.instrumentation.akka-2.2: enabled: false # Disable all Netty instrumentations com.newrelic.instrumentation.netty-3.4: enabled: false com.newrelic.instrumentation.netty-3.8: enabled: false com.newrelic.instrumentation.netty-4.0.0: enabled: false com.newrelic.instrumentation.netty-4.0.8: enabled: false # Disable all Play 2 instrumentations com.newrelic.instrumentation.play-2.1: enabled: false com.newrelic.instrumentation.play-2.2: enabled: false com.newrelic.instrumentation.play-2.3: enabled: false # New in Release 3.22, the Play 2.4 instrumentation does not respect # the older play2_instrumentation configuration setting com.newrelic.instrumentation.play-2.4: enabled: false # Disable all Scala-language instrumentations com.newrelic.instrumentation.scala-2.9.3: enabled: false Copy The pre-3.22 instrumentation names will be respected for a time, but they will be removed in future releases. If disabled by either the old or new instrumentation configuration, the instrumentation will be disabled. Check for deprecated configuration settings Any use of the pre-3.22 instrumentation names will be logged with messages similar to: INFO: Using deprecated configuration setting akka_instrumentation for instrumentation com.newrelic.instrumentation.akka-2.2 Copy OR INFO: The configuration setting akka_instrumentation is deprecated, please update the class_transformer config to use com.newrelic.instrumentation.akka-2.2 instead Copy Using the deprecated settings does not indicate the deprecated instrumentation has been loaded or is being used. These messages are hints to the user that it is time to update your configuration settings. Play 2.4 does not respect the older play2_instrumentation configuration settings, as it is a new instrumentation. In all cases, if you are using Java agent version 3.22 or higher, you should use the new instrumentation names for the Scala, Netty, Akka, and Play 2 framework in their newrelic.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.90912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable Scala, Netty, Akka, and Play 2 <em>Instrumentation</em>",
        "sections": "<em>Java</em> <em>agent</em> versions 3.21 or lower",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document describes how to disable <em>Java</em> <em>agent</em> <em>instrumentation</em> on these popular <em>async</em> frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this <em>instrumentation</em> if you find that the metrics reported aren&#x27;t valuable to you, or if the <em>instrumentation</em> incurs more overhead"
      },
      "id": "6043f28428ccbc13812c6062"
    }
  ],
  "/docs/agents/java-agent/async-instrumentation/java-agent-api-asynchronous-applications": [
    {
      "sections": [
        "Troubleshoot Java asynchronous instrumentation",
        "Verify your instrumentation",
        "Use logs to troubleshoot",
        "Problem: Transaction times are too long",
        "Problem: No transaction trace data",
        "Problem: Too few async calls",
        "Ensure that each activity you monitor is appropriately linked",
        "Check if you are missing required annotations"
      ],
      "title": "Troubleshoot Java asynchronous instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "0f21da73ba02edc45ec0cbbbaa7e0fc45678404b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/troubleshoot-java-asynchronous-instrumentation/",
      "published_at": "2021-10-18T02:21:09Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are having problems using the Java agent API for async tokens and segments, use these techniques to help you find answers and solve problems. Verify your instrumentation The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use these techniques to verify that your applications instrumentation is correct: After instrumenting your code, verify that the logs show that an equal number of tokens have been created and expired. For more information on which log messages to look for, see Use logs to troubleshoot. Check the garbage collection statistics under APM's JVMs page to determine whether or not your changes have significantly altered garbage collection patterns. Check if any segments or tokens are timing out by reviewing your transaction traces for a timed_out attribute. If so, you can change the limit with token_timeout and segment_timeout. Use logs to troubleshoot To customize your Java agent logging, see Generating logs. Then, you can examine your logs for these common messages: To view created tokens, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: created active token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view expired tokens and the time that they expired, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: expired token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view created segments, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@486b7f04: startSegment(): com.newrelic.agent.Segment@2b7fdad3 created and started with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy To view ended segments and the time that they ended, check logs at FINEST for: com.newrelic.agent.Transaction@486b7f04--finish segment(): com.newrelic.agent.Segment@2b7fdad3 async finish with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy Problem: Transaction times are too long Make sure to expire tokens and end or ignore segments; otherwise transactions may take longer to report to New Relic. The Java agent has a timeout mechanism for tokens and segments that are not ended correctly. For more information, see token_timeout and segment_timeout. Problem: No transaction trace data Inspect transaction traces to make sure expected asynchronous work is reported. If you do not see any transaction traces, make sure your transaction duration exceeds the transaction trace threshold set in transaction_threshold. Problem: Too few async calls If too few calls are being reported: Ensure that each activity you monitor is appropriately linked In the faulty example below, a parallel stream is being used, which means that the work done inside the lambda in the call to map() can be scheduled on a different thread than the thread handling the request. Without creating a token to link all this work together, you will not see any of the work that gets scheduled on a different thread inside of your transaction. @RequestMapping(\"parallel_stream_bad\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad(@RequestParam(\"ids\") List<long> ids) { List<item> results = ids .parallelStream() .map(i -> requestItem(i)) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad\", results); } Copy Check if you are missing required annotations The example below will report only a subset of the calls to requestItem() because it is impossible to put @Trace(async = true) around blocks of anonymous work inside the call to map(). Instead, you should pass the token into requestItem() and link it, and then add @Trace(async=true) around it. Or use a helper function like requestItemAsync() to do this without changing your existing methods. @RequestMapping(\"parallel_stream_bad2\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad2(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> { token.link(); return requestItem(id); }) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad2\", results); } Copy Compare this to the correct example below, in which the lambda expression is wrapped by the wrapper class InstrumentedCallable. This class accepts a token and a lambda, then wraps asynchronous work in @Trace(async = true) and uses a token to link the work to the request thread. @RequestMapping(\"parallel_stream_wrap\") @Trace(dispatcher = true) public ResponseEntity parallelStreamWrap(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> InstrumentedCallable.instrumentCallable(token, () -> requestItem(id))) .map(c -> c.call()) .filter(item -> item != null) .collect(Collectors.toList()); token.expire(); return formattedResponse(\"parallel_stream_wrap\", results); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.99493,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "sections": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "If you are having problems using the <em>Java</em> <em>agent</em> API for <em>async</em> tokens and segments, use these techniques to help you find answers and solve problems. Verify your <em>instrumentation</em> The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use"
      },
      "id": "603eb55a196a67260aa83dac"
    },
    {
      "sections": [
        "Introduction to Java async instrumentation",
        "Asynchronous operations",
        "Async and thread-switching",
        "Async and response time",
        "Custom instrumentation with the async API"
      ],
      "title": "Introduction to Java async instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "3b0a9e1f2f6b69a8ad101ec59c592ac4a574ae63",
      "image": "https://docs.newrelic.com/static/a38112969f7c8a3001651b65853a803b/39c09/sZ6-I4x5BDSDspRS_G7Hefg.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/introduction-java-async-instrumentation/",
      "published_at": "2021-10-18T05:34:29Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java includes a set of API methods for custom instrumentation of asynchronous activity. This is most useful to instrument asynchronous activity in unsupported frameworks, but you can also use the API to add additional instrumentation to supported frameworks. This document explains how asynchronous activity occurs, and how New Relic monitors async work. Asynchronous operations With a synchronous programming model, programming tasks are usually executed in a specific order. One task must complete before the next task begins, and each task blocks the next task from completing. Asynchronous programming uses a non-blocking model, so that tasks can be run in parallel. Tasks executed asynchronously are completely independent of each other in their execution and initialization. Because asynchronous code doesn't execute in a specific order, the server's full processing power can be used more efficiently, and the app's throughput increases. Async and thread-switching For applications that use asynchronous processing, thread-switching is when a program or task switches from one thread to another. Understanding these asynchronous interleavings can help you decide which methods should be instrumented. Here is an example method with a controller that makes external requests in parallel. These requests execute asynchronously, so each request executes independently of each other and getScoreAsync() returns immediately after being called. This allows the requesting thread to continue making requests while getScoreAsync() makes an external call and sends a reply. @ResponseBody @RequestMapping(\"getScores\", method = RequestMethod.Get produces = text/plain) public String getCreditScores(@RequestParam(name = \"uids\") uids) { return Arrays.stream(uids.split(\",\")) .parallel() .map(Integer::valueOf) .map(uid -> getScoreAsync(uid)) .collect(Collectors.toList());} Copy Some of these requests will finish before others. Some might even finish after the requesting thread has moved on to other tasks: With New Relic's asynchronous instrumentation, the APM UI flags the work as Async. For example, if the above method were instrumented by New Relic (either automatically or via custom instrumentation), this is what the APM UI would show on the Trace details page: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: When asynchronous activity in a Java application is detected by APM, it is indicated with the Async flag in the Drilldown column. Async and response time Response time is defined as the duration of a transaction from the perspective of the requester. For asynchronous applications, the response time is often less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Because tasks can be deferred, the application can take advantage of its limited resources and process things more quickly. The chart's response time line gives you more insight into the perceived behavior and speed of your application than does the total web transaction time: one.newrelic.com > APM > (select an app) > Summary: On the APM Summary page, asynchronous activity in a Java app can result in the response time (the blue line) being less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Custom instrumentation with the async API To implement custom instrumentation of async work, see the Java agent async API guide. For general information on how to use the Java agent API, see Java agent API guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.99489,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "sections": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " transaction time. This is because the methods don&#x27;t have to wait for all preceding methods to complete before returning. Custom <em>instrumentation</em> with the <em>async</em> API To implement custom <em>instrumentation</em> of <em>async</em> work, see the <em>Java</em> <em>agent</em> <em>async</em> API guide. For general information on how to use the <em>Java</em> <em>agent</em> API, see <em>Java</em> <em>agent</em> API guide."
      },
      "id": "603eb491e7b9d282bd2a07ca"
    },
    {
      "sections": [
        "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
        "Contents",
        "Java agent versions 3.21 or lower",
        "Java agent versions 3.22 or higher",
        "Check for deprecated configuration settings"
      ],
      "title": "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7a6fa946f9f903c240099279d125807b89665668",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/disable-scala-netty-akka-play-2-instrumentation/",
      "published_at": "2021-10-18T06:20:05Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to disable Java agent instrumentation on these popular async frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this instrumentation if you find that the metrics reported aren't valuable to you, or if the instrumentation incurs more overhead than you would like. If you selectively disable some of the instrumentation, some segments of activity will not be reported and your total time will be understated. Contents Java agent versions 3.21 or lower If you are using Java agent version 3.22 or lower, add the following to the class_transformer section of your newrelic.yml settings: # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings class_transformer: akka_instrumentation: enabled: false netty_instrumenation: enabled: false play2_instrumentation: enabled: false scala_instrumentation: enabled: false Copy Java agent versions 3.22 or higher The older Scala, Netty, Akka, and Play 2 Framework instrumentation configuration names have been deprecated as of Java Agent version 3.22. For those using Java Agent 3.22 or higher, add the following to the class_transformer section of your newrelic.yml settings: common: &default_settings class_transformer: # Disable all Akka instrumentations com.newrelic.instrumentation.akka-2.0: enabled: false com.newrelic.instrumentation.akka-2.1: enabled: false # Disabling 2.2 also disables higher versions com.newrelic.instrumentation.akka-2.2: enabled: false # Disable all Netty instrumentations com.newrelic.instrumentation.netty-3.4: enabled: false com.newrelic.instrumentation.netty-3.8: enabled: false com.newrelic.instrumentation.netty-4.0.0: enabled: false com.newrelic.instrumentation.netty-4.0.8: enabled: false # Disable all Play 2 instrumentations com.newrelic.instrumentation.play-2.1: enabled: false com.newrelic.instrumentation.play-2.2: enabled: false com.newrelic.instrumentation.play-2.3: enabled: false # New in Release 3.22, the Play 2.4 instrumentation does not respect # the older play2_instrumentation configuration setting com.newrelic.instrumentation.play-2.4: enabled: false # Disable all Scala-language instrumentations com.newrelic.instrumentation.scala-2.9.3: enabled: false Copy The pre-3.22 instrumentation names will be respected for a time, but they will be removed in future releases. If disabled by either the old or new instrumentation configuration, the instrumentation will be disabled. Check for deprecated configuration settings Any use of the pre-3.22 instrumentation names will be logged with messages similar to: INFO: Using deprecated configuration setting akka_instrumentation for instrumentation com.newrelic.instrumentation.akka-2.2 Copy OR INFO: The configuration setting akka_instrumentation is deprecated, please update the class_transformer config to use com.newrelic.instrumentation.akka-2.2 instead Copy Using the deprecated settings does not indicate the deprecated instrumentation has been loaded or is being used. These messages are hints to the user that it is time to update your configuration settings. Play 2.4 does not respect the older play2_instrumentation configuration settings, as it is a new instrumentation. In all cases, if you are using Java agent version 3.22 or higher, you should use the new instrumentation names for the Scala, Netty, Akka, and Play 2 framework in their newrelic.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.90912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable Scala, Netty, Akka, and Play 2 <em>Instrumentation</em>",
        "sections": "<em>Java</em> <em>agent</em> versions 3.21 or lower",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document describes how to disable <em>Java</em> <em>agent</em> <em>instrumentation</em> on these popular <em>async</em> frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this <em>instrumentation</em> if you find that the metrics reported aren&#x27;t valuable to you, or if the <em>instrumentation</em> incurs more overhead"
      },
      "id": "6043f28428ccbc13812c6062"
    }
  ],
  "/docs/agents/java-agent/async-instrumentation/troubleshoot-java-asynchronous-instrumentation": [
    {
      "sections": [
        "Java agent API for asynchronous applications",
        "Async tracking tools: Tokens and segments",
        "Tokens: Connect async threads",
        "1. Start a transaction, then create and expire a token",
        "2. Mark a transaction as async and link to request thread",
        "3. View your async trace in the New Relic UI",
        "Tip",
        "Segments: Time arbitrary async activity",
        "1. Create a transaction and call an external service",
        "2. Start a segment, report externals, and end the segment"
      ],
      "title": "Java agent API for asynchronous applications",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7b5f035809040487d96279fb318203b479a61b02",
      "image": "https://docs.newrelic.com/static/06c87505ee5c0d97e598d04258587f52/c1b63/Screen-Shot-2017-03-14-at-4.50.31-PM.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/java-agent-api-asynchronous-applications/",
      "published_at": "2021-10-18T03:48:35Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java (agent version 3.37 or higher) includes an API to instrument asynchronous activity. For supported frameworks, the agent usually instruments async work automatically. However, the async API can still be useful to add detail. This document provides examples of using tokens and segments to instrument your app. For more information about how New Relic instruments and displays async work in the APM UI, see Monitoring considerations for asynchronous applications. For details on the actual classes and methods, see the Javadoc. For general information on the Java agent API, see the Java agent API guide. For troubleshooting common problems, see Troubleshooting Java asynchronous applications. Async tracking tools: Tokens and segments The Java agent API provides two ways to trace asynchronous activity: Tokens: Tokens are passed between threads to link asynchronous units of work to a specific transaction. They do not perform any timing directly. Segments: Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. Segments are typically used to track external calls that are completed by a callback mechanism. Tokens: Connect async threads Use tokens to link arbitrary units of work that are on separate threads. This section describes how to use the token-related calls together to instrument async work. For detailed information on classes and methods, see the Javadoc. To use tokens, you first need to create the token, then link another call to the originating transaction. You should link the token as soon as possible within the other call. If you do not link the token immediately, you risk losing any methods that contain an @Trace below the call you are trying to link. You can also expire the token in the original call. The Java agent will then link the work in the New Relic UI. These examples illustrate how to use the token-related calls together: 1. Start a transaction, then create and expire a token Consider the method parallelStream() in the code snippet below. Because some of the calls to requestItemAsync() will occur on a separate thread, a token is created and passed to link that asynchronous work back to the requesting thread. /** * Example showing multi-threaded implementation of requesting data using a parallel {@link Stream}. */ @RequestMapping(\"parallel_stream\") @Trace(dispatcher = true) // starts a transaction public ResponseEntity<String> parallelStream(@RequestParam(\"ids\") List<Long> ids) { final Token token = NewRelic.getAgent().getTransaction(). getToken() ; List<item> results = ids .parallelStream() .map(id -> requestItemAsync\\(id, token)) // note we're calling a different method than parallelStreamBad .filter(item -> item != null) .collect(Collectors.toList()); token.expire() ; return formattedResponse(\"parallel_stream\", results); } Copy The agent API calls in this sample are: @Trace(dispatcher = true): Tells the agent to start a transaction. For more on this method, see the Javadoc. getToken(): Creates the token which will link the work together. For more on this method, see the Javadoc. token.expire(): Expires the token. This allows the transaction to end. For more on this method, see the Javadoc. 2. Mark a transaction as async and link to request thread The following code example shows requestItemAsync, which might execute on a separate thread from the requesting thread. For this reason, the token that was created in the previous code example is linked to the Transaction in requestItemAsync. Note that requestItemAsync() has the @Trace(async=true) annotation, which tells the agent to trace this method if it's linked to an existing transaction. After parallelStream() collects all results, the token is expired. This is important because it makes sure the transaction doesn't stay open after parallelStream() completes. @Trace(async = true) private Item requestItemAsync(long id, Token token) { token.link() ; return requestItem(id); } Copy The agent API calls in this sample are: @Trace(async = true): Starts a transaction. For more on this method, see the Javadoc. token.link(): Links the work being done in requestItemAsync() (which is executing on a different thread) to the requesting thread. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI Here's an example of a transaction trace in the APM UI for this endpoint: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: All asynchronous method calls linked with a token are indicated with an Async icon. All asynchronous method calls linked with a token are indicated with an Async icon in the Drilldown column. It's not necessary to link methods that are on the same thread, but doing so will have no negative effect. It's often the case that a single token can be shared, like in the parallelStream() example. Tip By default, a transaction can create a maximum of 3000 tokens and each token has a default timeout of 180s. You can change the former limit with the token_limit config option and the latter with the token_timeout config option. Traces for transactions that exceed the token_limit will contain a token_clamp attribute. Increasing either config option may increase agent memory usage. Segments: Time arbitrary async activity Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. This is most commonly used to time connections to external services. Use segments if you want to: Time code that completes via a callback Time an asynchronous call that spans many methods Measure the time between when work is created and when it executed (for example, in a thread pool) 1. Create a transaction and call an external service The method below makes a call to an external service (in this case a database) using the method storeItem(): /** * Example showing single threaded implementation of inserting data into a datasource. */ @RequestMapping(\"insert\") @Trace(dispatcher = true) //starts a transaction public ResponseEntity insert(@RequestParam(\"id\") Long id) { if (id != null) { storeItem(id); return new ResponseEntity<>(\"insert\", HttpStatus.OK); } else { return new ResponseEntity<>(\"insert\", HttpStatus.BAD_REQUEST); } } Copy The goal in this case it to find out how long the Callable in the Lambda statement is waiting in the thread pool before executing, rather than determining how long storeItem() runs. For this reason, a segment is used instead of a token, and @Trace(async = true) is not necessary like it was for a token. The agent API call in this sample is: @Trace(dispatcher = true): Starts a transaction. For more on this method, see the Javadoc. 2. Start a segment, report externals, and end the segment The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI When the method completes, APM displays a transaction trace with one external call: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: A single asynchronous segment is called out in the Drilldown column. Tip By default, the agent can track a maximum of 1000 segments during a given transaction. You can change this limit with the segment_timeout config option. Traces of transactions that exceed this limit will contain a segment_clamp attribute. Increasing this limit may increase agent memory usage.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.99489,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "sections": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> (<em>agent</em> version 3.37 or higher) includes an API to <em>instrument</em> asynchronous activity. For supported frameworks, the <em>agent</em> usually instruments <em>async</em> work automatically. However, the <em>async</em> API can still be useful to add detail. This document provides examples of using tokens"
      },
      "id": "603eb4c9196a67dde5a83db7"
    },
    {
      "sections": [
        "Introduction to Java async instrumentation",
        "Asynchronous operations",
        "Async and thread-switching",
        "Async and response time",
        "Custom instrumentation with the async API"
      ],
      "title": "Introduction to Java async instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "3b0a9e1f2f6b69a8ad101ec59c592ac4a574ae63",
      "image": "https://docs.newrelic.com/static/a38112969f7c8a3001651b65853a803b/39c09/sZ6-I4x5BDSDspRS_G7Hefg.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/introduction-java-async-instrumentation/",
      "published_at": "2021-10-18T05:34:29Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java includes a set of API methods for custom instrumentation of asynchronous activity. This is most useful to instrument asynchronous activity in unsupported frameworks, but you can also use the API to add additional instrumentation to supported frameworks. This document explains how asynchronous activity occurs, and how New Relic monitors async work. Asynchronous operations With a synchronous programming model, programming tasks are usually executed in a specific order. One task must complete before the next task begins, and each task blocks the next task from completing. Asynchronous programming uses a non-blocking model, so that tasks can be run in parallel. Tasks executed asynchronously are completely independent of each other in their execution and initialization. Because asynchronous code doesn't execute in a specific order, the server's full processing power can be used more efficiently, and the app's throughput increases. Async and thread-switching For applications that use asynchronous processing, thread-switching is when a program or task switches from one thread to another. Understanding these asynchronous interleavings can help you decide which methods should be instrumented. Here is an example method with a controller that makes external requests in parallel. These requests execute asynchronously, so each request executes independently of each other and getScoreAsync() returns immediately after being called. This allows the requesting thread to continue making requests while getScoreAsync() makes an external call and sends a reply. @ResponseBody @RequestMapping(\"getScores\", method = RequestMethod.Get produces = text/plain) public String getCreditScores(@RequestParam(name = \"uids\") uids) { return Arrays.stream(uids.split(\",\")) .parallel() .map(Integer::valueOf) .map(uid -> getScoreAsync(uid)) .collect(Collectors.toList());} Copy Some of these requests will finish before others. Some might even finish after the requesting thread has moved on to other tasks: With New Relic's asynchronous instrumentation, the APM UI flags the work as Async. For example, if the above method were instrumented by New Relic (either automatically or via custom instrumentation), this is what the APM UI would show on the Trace details page: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: When asynchronous activity in a Java application is detected by APM, it is indicated with the Async flag in the Drilldown column. Async and response time Response time is defined as the duration of a transaction from the perspective of the requester. For asynchronous applications, the response time is often less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Because tasks can be deferred, the application can take advantage of its limited resources and process things more quickly. The chart's response time line gives you more insight into the perceived behavior and speed of your application than does the total web transaction time: one.newrelic.com > APM > (select an app) > Summary: On the APM Summary page, asynchronous activity in a Java app can result in the response time (the blue line) being less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Custom instrumentation with the async API To implement custom instrumentation of async work, see the Java agent async API guide. For general information on how to use the Java agent API, see Java agent API guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.99489,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "sections": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " transaction time. This is because the methods don&#x27;t have to wait for all preceding methods to complete before returning. Custom <em>instrumentation</em> with the <em>async</em> API To implement custom <em>instrumentation</em> of <em>async</em> work, see the <em>Java</em> <em>agent</em> <em>async</em> API guide. For general information on how to use the <em>Java</em> <em>agent</em> API, see <em>Java</em> <em>agent</em> API guide."
      },
      "id": "603eb491e7b9d282bd2a07ca"
    },
    {
      "sections": [
        "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
        "Contents",
        "Java agent versions 3.21 or lower",
        "Java agent versions 3.22 or higher",
        "Check for deprecated configuration settings"
      ],
      "title": "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7a6fa946f9f903c240099279d125807b89665668",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/disable-scala-netty-akka-play-2-instrumentation/",
      "published_at": "2021-10-18T06:20:05Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to disable Java agent instrumentation on these popular async frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this instrumentation if you find that the metrics reported aren't valuable to you, or if the instrumentation incurs more overhead than you would like. If you selectively disable some of the instrumentation, some segments of activity will not be reported and your total time will be understated. Contents Java agent versions 3.21 or lower If you are using Java agent version 3.22 or lower, add the following to the class_transformer section of your newrelic.yml settings: # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings class_transformer: akka_instrumentation: enabled: false netty_instrumenation: enabled: false play2_instrumentation: enabled: false scala_instrumentation: enabled: false Copy Java agent versions 3.22 or higher The older Scala, Netty, Akka, and Play 2 Framework instrumentation configuration names have been deprecated as of Java Agent version 3.22. For those using Java Agent 3.22 or higher, add the following to the class_transformer section of your newrelic.yml settings: common: &default_settings class_transformer: # Disable all Akka instrumentations com.newrelic.instrumentation.akka-2.0: enabled: false com.newrelic.instrumentation.akka-2.1: enabled: false # Disabling 2.2 also disables higher versions com.newrelic.instrumentation.akka-2.2: enabled: false # Disable all Netty instrumentations com.newrelic.instrumentation.netty-3.4: enabled: false com.newrelic.instrumentation.netty-3.8: enabled: false com.newrelic.instrumentation.netty-4.0.0: enabled: false com.newrelic.instrumentation.netty-4.0.8: enabled: false # Disable all Play 2 instrumentations com.newrelic.instrumentation.play-2.1: enabled: false com.newrelic.instrumentation.play-2.2: enabled: false com.newrelic.instrumentation.play-2.3: enabled: false # New in Release 3.22, the Play 2.4 instrumentation does not respect # the older play2_instrumentation configuration setting com.newrelic.instrumentation.play-2.4: enabled: false # Disable all Scala-language instrumentations com.newrelic.instrumentation.scala-2.9.3: enabled: false Copy The pre-3.22 instrumentation names will be respected for a time, but they will be removed in future releases. If disabled by either the old or new instrumentation configuration, the instrumentation will be disabled. Check for deprecated configuration settings Any use of the pre-3.22 instrumentation names will be logged with messages similar to: INFO: Using deprecated configuration setting akka_instrumentation for instrumentation com.newrelic.instrumentation.akka-2.2 Copy OR INFO: The configuration setting akka_instrumentation is deprecated, please update the class_transformer config to use com.newrelic.instrumentation.akka-2.2 instead Copy Using the deprecated settings does not indicate the deprecated instrumentation has been loaded or is being used. These messages are hints to the user that it is time to update your configuration settings. Play 2.4 does not respect the older play2_instrumentation configuration settings, as it is a new instrumentation. In all cases, if you are using Java agent version 3.22 or higher, you should use the new instrumentation names for the Scala, Netty, Akka, and Play 2 framework in their newrelic.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.90912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable Scala, Netty, Akka, and Play 2 <em>Instrumentation</em>",
        "sections": "<em>Java</em> <em>agent</em> versions 3.21 or lower",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document describes how to disable <em>Java</em> <em>agent</em> <em>instrumentation</em> on these popular <em>async</em> frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this <em>instrumentation</em> if you find that the metrics reported aren&#x27;t valuable to you, or if the <em>instrumentation</em> incurs more overhead"
      },
      "id": "6043f28428ccbc13812c6062"
    }
  ],
  "/docs/agents/java-agent/attributes/java-agent-attributes": [
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "event_ingest_uri",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "metric_ingest_uri",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "JFR (Real-time profiling)",
        "audit_logging",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignoreErrorPriority",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-10-19T05:54:03Z",
      "updated_at": "2021-09-20T19:27:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. event_ingest_uri Type String Default https://insights-collector.newrelic.com/v1/accounts/events Event ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send events to other ingest endpoints (for example, EU production: https://insights-collector.eu01.nr-data.net/v1/accounts/events). extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is not currently used by the agent. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. metric_ingest_uri Type String Default https://metric-api.newrelic.com/metric/v1 Metric ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send metrics to other ingest endpoints (for example EU production: https://metric-api.eu.newrelic.com/metric/v1). proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default false Whether errors are reported for Reactor Netty. Default is false. If set to true, Reactor Netty errors will be reported. Important Only available in Java agent 6.3.0 and above. Notice, default was changed to false as of Java agent 6.5.0. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transactions total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data. Additionally the agent can expose linking metadata over JMX that can be used by other tracing systems. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata over remote JMX. Important This applies to Java agent version 6.1.0 or higher. JFR (Real-time profiling) The Java agent uses Java Flight Recorder (JFR) to collect high fidelity JVM data for Real-time profiling. Real-time profiling can be configured in the jfr stanza in the agent yaml, with system properties prefixed by newrelic.config.jfr., or with environment variables prefixed with NEW_RELIC_JFR_. enabled Type Boolean Default false Set to true to enable Real-time profiling with JFR. Important Real-time profiling with JFR is on by default in Java agent version 7.1.0. If you are on any other agent version 7.0.0 or higher, you can turn on JFR by changing the value to true. audit_logging Type Boolean Default false Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. Audit logging is extremely verbose and should only be used for troubleshooting purposes. Important This applies to Java agent version 7.0.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list exception class names you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy An environment variable can be used to list exception class names and messages you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list expected exception class names: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\" Copy An environment variable can be used to list expected exception class names and messages: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignoreErrorPriority Type Boolean Default true When multiple errors are noticed in a transaction, only the last error will be reported by default. Setting this property to false will instead report only the first error that is noticed. For more information, see the noticeError API. For example: error_collector: ignoreErrorPriority: false Copy ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messagesprefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings  OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.05526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> configuration: Config file",
        "sections": "<em>Java</em> <em>agent</em> configuration: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " to true to enable audit logging which will display all JFR metrics and events in each harvest batch. Audit logging is extremely verbose and should only be used for troubleshooting purposes. Important This applies to <em>Java</em> <em>agent</em> version 7.0.0 or higher. <em>Attributes</em> To set these options, use the <em>attributes</em>"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Ruby agent configuration",
        "Configuration methods and precedence",
        "View and edit config file options",
        "Update the config file",
        "Important",
        "General",
        "license_key",
        "agent_enabled",
        "app_name",
        "monitor_mode",
        "log_level",
        "high_security",
        "security_policies_token",
        "proxy_host",
        "proxy_port",
        "proxy_user",
        "proxy_pass",
        "capture_params",
        "Caution",
        "config_path",
        "apdex_t",
        "sync_startup",
        "send_data_on_exit",
        "timeout",
        "force_install_exit_handler",
        "log_file_name",
        "log_file_path",
        "prepend_active_record_instrumentation",
        "capture_memcache_keys",
        "message_tracer.segment_parameters.enabled",
        "marshaller",
        "backport_fast_active_record_connection_lookup",
        "labels",
        "ca_bundle_path",
        "datastore_tracer.instance_reporting.enabled",
        "datastore_tracer.database_name_reporting.enabled",
        "clear_transaction_state_after_fork",
        "exclude_newrelic_header",
        "infinite_tracing.trace_observer.host",
        "infinite_tracing.trace_observer.port",
        "Transaction Tracer",
        "transaction_tracer.enabled",
        "transaction_tracer.transaction_threshold",
        "transaction_tracer.record_sql",
        "transaction_tracer.record_redis_arguments",
        "transaction_tracer.capture_attributes",
        "transaction_tracer.explain_threshold",
        "transaction_tracer.explain_enabled",
        "transaction_tracer.stack_trace_threshold",
        "transaction_tracer.limit_segments",
        "Error Collector",
        "error_collector.enabled",
        "error_collector.capture_attributes",
        "error_collector.ignore_errors",
        "error_collector.ignore_classes",
        "error_collector.ignore_messages",
        "error_collector.ignore_status_codes",
        "error_collector.expected_classes",
        "error_collector.expected_messages",
        "error_collector.expected_status_codes",
        "error_collector.max_backtrace_frames",
        "error_collector.capture_events",
        "error_collector.max_event_samples_stored",
        "Browser Monitoring",
        "browser_monitoring.auto_instrument",
        "browser_monitoring.capture_attributes",
        "Analytics Events",
        "analytics_events.enabled",
        "analytics_events.max_samples_stored",
        "analytics_events.capture_attributes",
        "Attributes",
        "attributes.enabled",
        "transaction_tracer.attributes.enabled",
        "transaction_events.attributes.enabled",
        "error_collector.attributes.enabled",
        "browser_monitoring.attributes.enabled",
        "span_events.attributes.enabled",
        "transaction_segments.attributes.enabled",
        "attributes.exclude",
        "transaction_tracer.attributes.exclude",
        "transaction_events.attributes.exclude",
        "error_collector.attributes.exclude",
        "browser_monitoring.attributes.exclude",
        "span_events.attributes.exclude",
        "transaction_segments.attributes.exclude",
        "attributes.include",
        "transaction_tracer.attributes.include",
        "transaction_events.attributes.include",
        "error_collector.attributes.include",
        "browser_monitoring.attributes.include",
        "span_events.attributes.include",
        "transaction_segments.attributes.include",
        "Audit Log",
        "audit_log.enabled",
        "audit_log.path",
        "audit_log.endpoints",
        "Autostart",
        "autostart.denylisted_constants",
        "autostart.denylisted_executables",
        "autostart.denylisted_rake_tasks",
        "Cross Application Tracer",
        "cross_application_tracer.enabled",
        "Custom Attributes",
        "custom_attributes.enabled",
        "Custom Insights Events",
        "custom_insights_events.enabled",
        "custom_insights_events.max_samples_stored",
        "Disabling",
        "disable_rake",
        "disable_samplers",
        "disable_resque",
        "disable_sidekiq",
        "disable_dj",
        "disable_sinatra",
        "disable_sinatra_auto_middleware",
        "disable_view_instrumentation",
        "disable_activerecord_instrumentation",
        "disable_data_mapper",
        "disable_activejob",
        "disable_action_cable_instrumentation",
        "disable_active_storage",
        "disable_memcached",
        "disable_memcache_client",
        "disable_dalli",
        "disable_dalli_cas_client",
        "disable_memcache_instrumentation",
        "disable_gc_profiler",
        "disable_sequel_instrumentation",
        "disable_database_instrumentation",
        "disable_mongo",
        "disable_redis",
        "disable_vm_sampler",
        "disable_memory_sampler",
        "disable_cpu_sampler",
        "disable_delayed_job_sampler",
        "disable_active_record_notifications",
        "disable_bunny",
        "disable_curb",
        "disable_excon",
        "disable_httpclient",
        "disable_net_http",
        "disable_rack",
        "disable_rack_urlmap",
        "disable_puma_rack",
        "disable_puma_rack_urlmap",
        "disable_typhoeus",
        "disable_httprb",
        "disable_middleware_instrumentation",
        "disable_grape",
        "Distributed Tracing",
        "distributed_tracing.enabled",
        "Heroku",
        "heroku.use_dyno_names",
        "heroku.dyno_name_prefixes_to_shorten",
        "Instrumentation",
        "instrumentation.net_http",
        "instrumentation.typhoeus",
        "instrumentation.bunny",
        "instrumentation.httprb",
        "instrumentation.resque",
        "instrumentation.redis",
        "instrumentation.rake",
        "instrumentation.mongo",
        "instrumentation.delayed_job",
        "instrumentation.httpclient",
        "instrumentation.curb",
        "instrumentation.sinatra",
        "instrumentation.rack",
        "instrumentation.rack_urlmap",
        "instrumentation.puma_rack",
        "instrumentation.puma_rack_urlmap",
        "instrumentation.memcached",
        "instrumentation.memcache_client",
        "instrumentation.memcache",
        "instrumentation.logger",
        "instrumentation.excon",
        "instrumentation.grape",
        "Mongo",
        "mongo.capture_queries",
        "mongo.obfuscate_queries",
        "Process Host",
        "process_host.display_name",
        "Rake",
        "rake.tasks",
        "rake.connect_timeout",
        "Resque",
        "resque.capture_params",
        "Rules",
        "rules.ignore_url_regexes",
        "Sidekiq",
        "sidekiq.capture_params",
        "Slow SQL",
        "slow_sql.enabled",
        "slow_sql.explain_threshold",
        "slow_sql.explain_enabled",
        "slow_sql.record_sql",
        "slow_sql.use_longer_sql_id",
        "Span Events",
        "span_events.enabled",
        "span_events.queue_size",
        "span_events.max_samples_stored",
        "Strip Exception Messages",
        "strip_exception_messages.enabled",
        "strip_exception_messages.allowed_classes",
        "Thread Profiler",
        "thread_profiler.enabled",
        "Utilization",
        "utilization.detect_aws",
        "utilization.detect_azure",
        "utilization.detect_gcp",
        "utilization.detect_pcf",
        "utilization.detect_docker",
        "utilization.detect_kubernetes"
      ],
      "title": "Ruby agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Configuration"
      ],
      "external_id": "ee72f1c59d456c5e5a089cfa81bfbde6064d7cb0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/configuration/ruby-agent-configuration/",
      "published_at": "2021-10-19T03:52:40Z",
      "updated_at": "2021-10-19T03:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can configure the New Relic Ruby agent with settings in a configuration file, environment variables, or programmatically with server-side configuration. This document summarizes the configuration options available for the Ruby agent. If the default value for a configuration option is (Dynamic), this means the Ruby agent calculates the default at runtime. The value for the config setting defaults to the value of another setting as appropriate. Configuration methods and precedence The primary (default) method to configure the Ruby agent is via the configuration file (newrelic.yml) in the config subdirectory. To set configuration values using environment variables: Add the prefix NEW_RELIC_ to the setting's name. Replace any periods . with underscores _. You can also configure a few values in the UI via server-side configuration. The Ruby agent follows this order of precedence for configuration: Environment variables Server-side configuration Configuration file (newrelic.yml) Default configuration settings In other words, environment variables override all other configuration settings and info, server-side configuration overrides the configuration file and default config settings, and so on. View and edit config file options The Ruby agent's newrelic.yml is a standard YAML configuration file. It typically includes a Defaults section at the top, plus sections below for each application environment; for example, Development, Testing, and Production. The Ruby agent determines which section of the newrelic.yml config file to read from by looking at certain environment variables to derive the application's environment. This can be useful, for example, when you want to use info for the log_level config setting in your production environment, and you want more verbose log_level config settings (such as debug in your development environment. Here is an example newrelic.yml config file: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'My Application Name' production: <<: *default_settings log_level: info development: <<: *default_settings log_level: debug Copy For non-Rails apps, the Ruby agent looks for the following environment variables, in this order, to determine the application environment: NEW_RELIC_ENV RUBY_ENV RAILS_ENV APP_ENV RACK_ENV If the Ruby agent does not detect values for any of those environment variables, it will default the application environment to development and read from the development section of the newrelic.yml config file. When running the Ruby agent in a Rails app, the agent first looks for the NEW_RELIC_ENV environment variable to determine the application environment and which section of the newrelic.yml to use. If NEW_RELIC_ENV is not present, the agent uses the Rails environment (RAILS_ENV or RAILS.env, depending on the version of Rails) . When you edit the config file, be sure to: Indent only with two spaces. Indent only where relevant, in stanzas such as error_collector. If you do not indent correctly, the agent may throw an Unable to parse configuration file error on startup. To view the most current list of available Ruby agent configuration options, use the rake newrelic:config:docs command. This document describes the most common options. Update the config file This documentation applies to the Ruby agent's latest release. For details on earlier versions, refer to the comments in newrelic.yml itself. To update newrelic.yml file after a new release, use the template in the base directory of the agent gem. When you update to new gem versions, examine or diff config/newrelic.yml and newrelic.yml in the installation directory to take advantage of new configuration options. Important Updating the gem does not automatically update config/newrelic.yml. General These settings are available for agent configuration. Some settings depend on your New Relic subscription level. license_key Type String Default \"\" Environ variable NEW_RELIC_LICENSE_KEY Your New Relic license key. agent_enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_AGENT_ENABLED If true, allows the Ruby agent to run. app_name Type String Default (Dynamic) Environ variable NEW_RELIC_APP_NAME Specify the application name used to aggregate data in the New Relic UI. To report data to multiple apps at the same time, specify a list of names separated by a semicolon ;. For example, MyApp or MyStagingApp;Instance1. monitor_mode Type Boolean Default (Dynamic) Environ variable NEW_RELIC_MONITOR_MODE When true, the agent transmits data about your app to the New Relic collector. log_level Type String Default \"info\" Environ variable NEW_RELIC_LOG_LEVEL Sets the level of detail of log messages. Possible log levels, in increasing verbosity, are: error, warn, info or debug. high_security Type Boolean Default false Environ variable NEW_RELIC_HIGH_SECURITY If true, enables high security mode. Ensure you understand the implications of high security mode before enabling this setting. security_policies_token Type String Default \"\" Environ variable NEW_RELIC_SECURITY_POLICIES_TOKEN Applies Language Agent Security Policy settings. proxy_host Type String Default nil Environ variable NEW_RELIC_PROXY_HOST Defines a host for communicating with the New Relic collector via a proxy server. proxy_port Type Integer Default 8080 Environ variable NEW_RELIC_PROXY_PORT Defines a port for communicating with the New Relic collector via a proxy server. proxy_user Type String Default nil Environ variable NEW_RELIC_PROXY_USER Defines a user for communicating with the New Relic collector via a proxy server. proxy_pass Type String Default nil Environ variable NEW_RELIC_PROXY_PASS Defines a password for communicating with the New Relic collector via a proxy server. capture_params Type Boolean Default false Environ variable NEW_RELIC_CAPTURE_PARAMS When true, the agent captures HTTP request parameters and attaches them to transaction traces, traced errors, and TransactionError events. Caution When using the capture_params setting, the Ruby agent will not attempt to filter secret information. Recommendation: To filter secret information from request parameters, use the attributes.include setting instead. For more information, see the Ruby attribute examples. config_path Type String Default (Dynamic) Environ variable NEW_RELIC_CONFIG_PATH Path to newrelic.yml. If undefined, the agent checks the following directories (in order): config/newrelic.yml, newrelic.yml, $HOME/.newrelic/newrelic.yml and $HOME/newrelic.yml. apdex_t Type Float Default 0.5 Environ variable NEW_RELIC_APDEX_T DEPRECATED For agent versions 3.5.0 or higher, set your Apdex T via the New Relic UI. sync_startup Type Boolean Default false Environ variable NEW_RELIC_SYNC_STARTUP When set to true, forces a synchronous connection to the New Relic collector during application startup. For very short-lived processes, this helps ensure the New Relic agent has time to report. send_data_on_exit Type Boolean Default true Environ variable NEW_RELIC_SEND_DATA_ON_EXIT If true, enables the exit handler that sends data to the New Relic collector before shutting down. timeout Type Integer Default 120 Environ variable NEW_RELIC_TIMEOUT Defines the maximum number of seconds the agent should spend attempting to connect to the collector. force_install_exit_handler Type Boolean Default false Environ variable NEW_RELIC_FORCE_INSTALL_EXIT_HANDLER Forces the exit handler that sends all cached data to collector before shutting down to be installed regardless of detecting scenarios where it generally should not be. Known use-case for this option is where Sinatra is running as an embedded service within another framework and the agent is detecting the Sinatra app and skipping the at_exit handler as a result. Sinatra classically runs the entire application in an at_exit block and would otherwise misbehave if the Agent's at_exit handler was also installed in those circumstances. Note: send_data_on_exit should also be set to true in tandem with this setting. log_file_name Type String Default \"newrelic_agent.log\" Environ variable NEW_RELIC_LOG_FILE_NAME Defines a name for the log file. log_file_path Type String Default \"log/\" Environ variable NEW_RELIC_LOG_FILE_PATH Defines a path to the agent log file, excluding the filename. prepend_active_record_instrumentation Type Boolean Default false Environ variable NEW_RELIC_PREPEND_ACTIVE_RECORD_INSTRUMENTATION If true, uses Module#prepend rather than alias_method for ActiveRecord instrumentation. capture_memcache_keys Type Boolean Default false Environ variable NEW_RELIC_CAPTURE_MEMCACHE_KEYS Enable or disable the capture of memcache keys from transaction traces. message_tracer.segment_parameters.enabled Type Boolean Default true Environ variable NEW_RELIC_MESSAGE_TRACER_SEGMENT_PARAMETERS_ENABLED If true, the agent will collect metadata about messages and attach them as segment parameters. marshaller Type String Default \"json\" Environ variable NEW_RELIC_MARSHALLER Specifies a marshaller for transmitting data to the New Relic collector. Currently json is the only valid value for this setting. backport_fast_active_record_connection_lookup Type Boolean Default false Environ variable NEW_RELIC_BACKPORT_FAST_ACTIVE_RECORD_CONNECTION_LOOKUP Backports the faster ActiveRecord connection lookup introduced in Rails 6, which improves agent performance when instrumenting ActiveRecord. Note that this setting may not be compatible with other gems that patch ActiveRecord. labels Type String Default \"\" Environ variable NEW_RELIC_LABELS A dictionary of label names and values that will be applied to the data sent from this agent. May also be expressed as a semicolon-delimited ; string of colon-separated : pairs. For example, <var>Server</var>:<var>One</var>;<var>Data Center</var>:<var>Primary</var>. ca_bundle_path Type String Default nil Environ variable NEW_RELIC_CA_BUNDLE_PATH Manual override for the path to your local CA bundle. This CA bundle will be used to validate the SSL certificate presented by New Relic's data collection service. datastore_tracer.instance_reporting.enabled Type Boolean Default true Environ variable NEW_RELIC_DATASTORE_TRACER_INSTANCE_REPORTING_ENABLED If false, the agent will not report datastore instance metrics, nor add host or port_path_or_id parameters to transaction or slow SQL traces. datastore_tracer.database_name_reporting.enabled Type Boolean Default true Environ variable NEW_RELIC_DATASTORE_TRACER_DATABASE_NAME_REPORTING_ENABLED If false, the agent will not add database_name parameter to transaction or slow sql traces. clear_transaction_state_after_fork Type Boolean Default false Environ variable NEW_RELIC_CLEAR_TRANSACTION_STATE_AFTER_FORK If true, the agent will clear Tracer::State in Agent.drop_buffered_data. exclude_newrelic_header Type Boolean Default false Environ variable NEW_RELIC_EXCLUDE_NEWRELIC_HEADER Allows newrelic distributed tracing headers to be suppressed on outbound requests. infinite_tracing.trace_observer.host Type String Default \"\" Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST Configures the hostname for the Trace Observer Host. When configured, enables tail-based sampling by sending all recorded spans to a Trace Observer for further sampling decisions, irrespective of any usual agent sampling decision. infinite_tracing.trace_observer.port Type Integer Default 443 Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_PORT Configures the TCP/IP port for the Trace Observer Host Transaction Tracer The transaction traces feature collects detailed information from a selection of transactions, including a summary of the calling sequence, a breakdown of time spent, and a list of SQL queries and their query plans (on mysql and postgresql). Available features depend on your New Relic subscription level. transaction_tracer.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_ENABLED If true, enables collection of transaction traces. transaction_tracer.transaction_threshold Type Float Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_TRACER_TRANSACTION_THRESHOLD Specify a threshold in seconds. Transactions with a duration longer than this threshold are eligible for transaction traces. Specify a float value or the string apdex_f. transaction_tracer.record_sql Type String Default \"obfuscated\" Environ variable NEW_RELIC_TRANSACTION_TRACER_RECORD_SQL Obfuscation level for SQL queries reported in transaction trace nodes. By default, this is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to none. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. transaction_tracer.record_redis_arguments Type Boolean Default false Environ variable NEW_RELIC_TRANSACTION_TRACER_RECORD_REDIS_ARGUMENTS If true, the agent records Redis command arguments in transaction traces. transaction_tracer.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_CAPTURE_ATTRIBUTES DEPRECATED Use transaction_tracer.attributes.enabled instead. transaction_tracer.explain_threshold Type Float Default 0.5 Environ variable NEW_RELIC_TRANSACTION_TRACER_EXPLAIN_THRESHOLD Threshold (in seconds) above which the agent will collect explain plans. Relevant only when explain_enabled is true. transaction_tracer.explain_enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_EXPLAIN_ENABLED If true, enables the collection of explain plans in transaction traces. This setting will also apply to explain plans in slow SQL traces if slow_sql.explain_enabled is not set separately. transaction_tracer.stack_trace_threshold Type Float Default 0.5 Environ variable NEW_RELIC_TRANSACTION_TRACER_STACK_TRACE_THRESHOLD Specify a threshold in seconds. The agent includes stack traces in transaction trace nodes when the stack trace duration exceeds this threshold. transaction_tracer.limit_segments Type Integer Default 4000 Environ variable NEW_RELIC_TRANSACTION_TRACER_LIMIT_SEGMENTS Maximum number of transaction trace nodes to record in a single transaction trace. Error Collector The agent collects and reports all uncaught exceptions by default. These configuration options allow you to customize the error collection. For information on ignored and expected errors, see this page on Error Analytics in APM. To set expected errors via the NewRelic::Agent.notice_error Ruby method, consult the Ruby Agent API. error_collector.enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ENABLED If true, the agent captures traced errors and error count metrics. error_collector.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_CAPTURE_ATTRIBUTES DEPRECATED Use error_collector.attributes.enabled instead. error_collector.ignore_errors Type String Default \"ActionController::RoutingError,Sinatra::NotFound\" Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERRORS DEPRECATED Use error_collector.ignore_classes instead. Specify a comma-delimited list of error classes that the agent should ignore. Caution Server side configuration takes precedence for this setting over all environment configurations. This differs from all other configuration settings where environment variable take precedence over server side configuration. error_collector.ignore_classes Type Array Default [] Environ variable None A list of error classes that the agent should ignore. Caution This option can't be set via environment variable. error_collector.ignore_messages Type Hash Default {} Environ variable None A map of error classes to a list of messages. When an error of one of the classes specified here occurs, if its error message contains one of the strings corresponding to it here, that error will be ignored. Caution This option can't be set via environment variable. error_collector.ignore_status_codes Type String Default \"\" Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_STATUS_CODES A comma separated list of status codes, possibly including ranges. Errors associated with these status codes, where applicable, will be ignored. error_collector.expected_classes Type Array Default [] Environ variable None A list of error classes that the agent should treat as expected. Caution This option can't be set via environment variable. error_collector.expected_messages Type Hash Default {} Environ variable None A map of error classes to a list of messages. When an error of one of the classes specified here occurs, if its error message contains one of the strings corresponding to it here, that error will be treated as expected. Caution This option can't be set via environment variable. error_collector.expected_status_codes Type String Default \"\" Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_STATUS_CODES A comma separated list of status codes, possibly including ranges. Errors associated with these status codes, where applicable, will be treated as expected. error_collector.max_backtrace_frames Type Integer Default 50 Environ variable NEW_RELIC_ERROR_COLLECTOR_MAX_BACKTRACE_FRAMES Defines the maximum number of frames in an error backtrace. Backtraces over this amount are truncated at the beginning and end. error_collector.capture_events Type Boolean Default (Dynamic) Environ variable NEW_RELIC_ERROR_COLLECTOR_CAPTURE_EVENTS If true, the agent collects TransactionError events. error_collector.max_event_samples_stored Type Integer Default 100 Environ variable NEW_RELIC_ERROR_COLLECTOR_MAX_EVENT_SAMPLES_STORED Defines the maximum number of TransactionError events sent to Insights per harvest cycle. Browser Monitoring The browser monitoring page load timing feature (sometimes referred to as real user monitoring or RUM) gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. browser_monitoring.auto_instrument Type Boolean Default (Dynamic) Environ variable NEW_RELIC_BROWSER_MONITORING_AUTO_INSTRUMENT If true, enables auto-injection of the JavaScript header for page load timing (sometimes referred to as real user monitoring or RUM). browser_monitoring.capture_attributes Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITORING_CAPTURE_ATTRIBUTES DEPRECATED Use browser_monitoring.attributes.enabled instead. Analytics Events New Relic dashboards is a resource to gather and visualize data about your software and what it says about your business. With it you can quickly and easily create real-time dashboards to get immediate answers about end-user experiences, clickstreams, mobile activities, and server transactions. analytics_events.enabled Type Boolean Default true Environ variable NEW_RELIC_ANALYTICS_EVENTS_ENABLED If true, enables analytics event sampling. analytics_events.max_samples_stored Type Integer Default 1200 Environ variable NEW_RELIC_ANALYTICS_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of request events reported from a single harvest. analytics_events.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_ANALYTICS_EVENTS_CAPTURE_ATTRIBUTES DEPRECATED Use transaction_events.attributes.enabled instead. Attributes Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_ENABLED If true, enables capture of attributes for all destinations. transaction_tracer.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction traces. transaction_events.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction events. error_collector.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_ENABLED If true, the agent captures attributes from error collection. browser_monitoring.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_ENABLED If true, the agent captures attributes from browser monitoring. span_events.attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes on span events. transaction_segments.attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes on transaction segments. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from all destinations. Allows * as wildcard at end. transaction_tracer.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction traces. Allows * as wildcard at end. transaction_events.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction events. Allows * as wildcard at end. error_collector.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from error collection. Allows * as wildcard at end. browser_monitoring.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from browser monitoring. Allows * as wildcard at end. span_events.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from span events. Allows * as wildcard at end. transaction_segments.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction segments. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE Prefix of attributes to include in all destinations. Allows * as wildcard at end. transaction_tracer.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction traces. Allows * as wildcard at end. transaction_events.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction events. Allows * as wildcard at end. error_collector.attributes.include Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_INCLUDE Prefix of attributes to include in error collection. Allows * as wildcard at end. browser_monitoring.attributes.include Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_INCLUDE Prefix of attributes to include in browser monitoring. Allows * as wildcard at end. span_events.attributes.include Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include on span events. Allows * as wildcard at end. transaction_segments.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include on transaction segments. Allows * as wildcard at end. Audit Log audit_log.enabled Type Boolean Default false Environ variable NEW_RELIC_AUDIT_LOG_ENABLED If true, enables an audit log which logs communications with the New Relic collector. audit_log.path Type String Default (Dynamic) Environ variable NEW_RELIC_AUDIT_LOG_PATH Specifies a path to the audit log file (including the filename). audit_log.endpoints Type Array Default [\".*\"] Environ variable NEW_RELIC_AUDIT_LOG_ENDPOINTS List of allowed endpoints to include in audit log Autostart autostart.denylisted_constants Type String Default \"Rails::Console\" Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_CONSTANTS Specify a list of constants that should prevent the agent from starting automatically. Separate individual constants with a comma ,. For example, Rails::Console,UninstrumentedBackgroundJob. autostart.denylisted_executables Type String Default \"irb,rspec\" Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_EXECUTABLES Defines a comma-delimited list of executables that the agent should not instrument. For example, rake,my_ruby_script.rb. autostart.denylisted_rake_tasks Type String Default Copy Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_RAKE_TASKS Defines a comma-delimited list of Rake tasks that the agent should not instrument. For example, assets:precompile,db:migrate. Cross Application Tracer cross_application_tracer.enabled Type Boolean Default false Environ variable NEW_RELIC_CROSS_APPLICATION_TRACER_ENABLED DEPRECATED Please see: distributed_tracing-enabled. If true, enables cross-application tracing when distributed_tracing.enabled is set to false. Custom Attributes custom_attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_CUSTOM_ATTRIBUTES_ENABLED If false, custom attributes will not be sent on Insights events. Custom Insights Events custom_insights_events.enabled Type Boolean Default true Environ variable NEW_RELIC_CUSTOM_INSIGHTS_EVENTS_ENABLED If true, the agent captures New Relic Insights custom events. custom_insights_events.max_samples_stored Type Integer Default 1000 Environ variable NEW_RELIC_CUSTOM_INSIGHTS_EVENTS_MAX_SAMPLES_STORED Specify a maximum number of custom Insights events to buffer in memory at a time. Disabling Use these settings to toggle instrumentation types during agent startup. disable_rake Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RAKE DEPRECATED Please see: instrumentation.rake. If true, disables Rake instrumentation. disable_samplers Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SAMPLERS If true, disables the collection of sampler metrics. Sampler metrics are metrics that are not event-based (such as CPU time or memory usage). disable_resque Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RESQUE DEPRECATED Please see: instrumentation.resque. If true, disables Resque instrumentation. disable_sidekiq Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SIDEKIQ If true, disables Sidekiq instrumentation. disable_dj Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DJ DEPRECATED Please see: instrumentation.delayed_job. If true, disables Delayed::Job instrumentation. disable_sinatra Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SINATRA DEPRECATED Please see: instrumentation.sinatra. If true , disables Sinatra instrumentation. disable_sinatra_auto_middleware Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SINATRA_AUTO_MIDDLEWARE If true, disables agent middleware for Sinatra. This middleware is responsible for advanced feature support such as cross application tracing, page load timing, and error collection. Important Cross application tracing is deprecated in favor of distributed tracing. Distributed tracing is on by default for Ruby agent versions 8.0.0 and above. Middlewares are not required to support distributed tracing. To continue using cross application tracing, update the following options in your newrelic.yml configuration file: # newrelic.yml cross_application_tracer: enabled: true distributed_tracing: enabled: false Copy disable_view_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_VIEW_INSTRUMENTATION If true, disables view instrumentation. disable_activerecord_instrumentation Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_ACTIVERECORD_INSTRUMENTATION If true, disables active record instrumentation. disable_data_mapper Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DATA_MAPPER If true, disables DataMapper instrumentation. disable_activejob Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVEJOB If true, disables ActiveJob instrumentation. disable_action_cable_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTION_CABLE_INSTRUMENTATION If true, disables Action Cable instrumentation. disable_active_storage Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVE_STORAGE If true, disables ActiveStorage instrumentation. disable_memcached Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_MEMCACHED DEPRECATED Please see: instrumentation.memcached. If true, disables instrumentation for the memcached gem. disable_memcache_client Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_MEMCACHE_CLIENT DEPRECATED Please see: instrumentation.memcache-client. If true, disables instrumentation for the memcache-client gem. disable_dalli Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_DALLI DEPRECATED Please see: instrumentation.memcache. If true, disables instrumentation for the dalli gem. disable_dalli_cas_client Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_DALLI_CAS_CLIENT DEPRECATED Please see: instrumentation.memcache. If true, disables instrumentation for the dalli gem's additional CAS client support. disable_memcache_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MEMCACHE_INSTRUMENTATION DEPRECATED Please see: instrumentation.memcache. If true, disables memcache instrumentation. disable_gc_profiler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_GC_PROFILER If true, disables the use of GC::Profiler to measure time spent in garbage collection disable_sequel_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SEQUEL_INSTRUMENTATION If true, disables Sequel instrumentation. disable_database_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DATABASE_INSTRUMENTATION DEPRECATED Use disable_sequel_instrumentation instead. disable_mongo Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MONGO DEPRECATED Please see: instrumentation.mongo. If true, the agent won't install instrumentation for the Mongo gem. disable_redis Type Boolean Default false Environ variable NEW_RELIC_DISABLE_REDIS DEPRECATED Please see: instrumentation.redis. If true, the agent won't install instrumentation for Redis. disable_vm_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_VM_SAMPLER If true, the agent won't sample performance measurements from the Ruby VM. disable_memory_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MEMORY_SAMPLER If true, the agent won't sample the memory usage of the host process. disable_cpu_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_CPU_SAMPLER If true, the agent won't sample the CPU usage of the host process. disable_delayed_job_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DELAYED_JOB_SAMPLER If true, the agent won't measure the depth of Delayed Job queues. disable_active_record_notifications Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVE_RECORD_NOTIFICATIONS If true, disables instrumentation for ActiveRecord 4, 5, and 6. disable_bunny Type Boolean Default false Environ variable NEW_RELIC_DISABLE_BUNNY DEPRECATED Please see: instrumentation.bunny. If true, disables instrumentation for the bunny gem. disable_curb Type Boolean Default false Environ variable NEW_RELIC_DISABLE_CURB DEPRECATED Please see: instrumentation.curb. If true, disables instrumentation for the curb gem. disable_excon Type Boolean Default false Environ variable NEW_RELIC_DISABLE_EXCON DEPRECATED Please see: instrumentation.excon. If true, disables instrumentation for the excon gem. disable_httpclient Type Boolean Default false Environ variable NEW_RELIC_DISABLE_HTTPCLIENT DEPRECATED Please see: instrumentation.httpclient. If true, disables instrumentation for the httpclient gem. disable_net_http Type Boolean Default false Environ variable NEW_RELIC_DISABLE_NET_HTTP DEPRECATED Please see: instrumentation.net_http. If true, disables instrumentation for Net::HTTP. disable_rack Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RACK DEPRECATED Please see: instrumentation.rack. If true, prevents the agent from hooking into the to_app method in Rack::Builder to find gems to instrument during application startup. disable_rack_urlmap Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RACK_URLMAP DEPRECATED Please see: instrumentation.rack_urlmap. If true, prevents the agent from hooking into Rack::URLMap to install middleware tracing. disable_puma_rack Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_PUMA_RACK DEPRECATED Please see: instrumentation.puma_rack. If true, prevents the agent from hooking into the to_app method in Puma::Rack::Builder to find gems to instrument during application startup. disable_puma_rack_urlmap Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_PUMA_RACK_URLMAP DEPRECATED Please see: instrumentation.puma_rack_urlmap. If true, prevents the agent from hooking into Puma::Rack::URLMap to install middleware tracing. disable_typhoeus Type Boolean Default false Environ variable NEW_RELIC_DISABLE_TYPHOEUS DEPRECATED Please see: instrumentation.typhoeus. If true, the agent won't install instrumentation for the typhoeus gem. disable_httprb Type Boolean Default false Environ variable NEW_RELIC_DISABLE_HTTPRB DEPRECATED Please see: instrumentation.httprb. If true, the agent won't install instrumentation for the http.rb gem. disable_middleware_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MIDDLEWARE_INSTRUMENTATION If true, the agent won't wrap third-party middlewares in instrumentation (regardless of whether they are installed via Rack::Builder or Rails). disable_grape Type Boolean Default false Environ variable NEW_RELIC_DISABLE_GRAPE DEPRECATED Please see: instrumentation.grape. If true, the agent won't install Grape instrumentation. Distributed Tracing distributed_tracing.enabled Type Boolean Default true Environ variable NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Distributed tracing lets you see the path that a request takes through your distributed system. Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition guide before you enable this feature. Heroku heroku.use_dyno_names Type Boolean Default true Environ variable NEW_RELIC_HEROKU_USE_DYNO_NAMES If true, the agent uses Heroku dyno names as the hostname. heroku.dyno_name_prefixes_to_shorten Type Array Default [\"scheduler\", \"run\"] Environ variable NEW_RELIC_HEROKU_DYNO_NAME_PREFIXES_TO_SHORTEN Ordinarily the agent reports dyno names with a trailing dot and process ID (for example, worker.3). You can remove this trailing data by specifying the prefixes you want to report without trailing data (for example, worker). Instrumentation instrumentation.net_http Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_NET_HTTP Controls auto-instrumentation of Net::HTTP at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.typhoeus Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_TYPHOEUS Controls auto-instrumentation of Typhoeus at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.bunny Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_BUNNY Controls auto-instrumentation of bunny at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.httprb Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_HTTPRB Controls auto-instrumentation of http.rb gem at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.resque Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RESQUE Controls auto-instrumentation of resque at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.redis Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_REDIS Controls auto-instrumentation of Redis at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.rake Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RAKE Controls auto-instrumentation of rake at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.mongo Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MONGO Controls auto-instrumentation of Mongo at start up. May be one of [enabled|disabled] . instrumentation.delayed_job Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_DELAYED_JOB Controls auto-instrumentation of Delayed Job at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.httpclient Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_HTTPCLIENT Controls auto-instrumentation of HTTPClient at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.curb Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_CURB Controls auto-instrumentation of Curb at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.sinatra Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_SINATRA Controls auto-instrumentation of Sinatra at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.rack Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RACK Controls auto-instrumentation of Rack. When enabled, the agent hooks into the to_app method in Rack::Builder to find gems to instrument during application startup. May be one of [auto|prepend|chain|disabled] . instrumentation.rack_urlmap Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RACK_URLMAP Controls auto-instrumentation of Rack::URLMap at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.puma_rack Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_PUMA_RACK Controls auto-instrumentation of Puma::Rack. When enabled, the agent hooks into the to_app method in Puma::Rack::Builder to find gems to instrument during application startup. May be one of [auto|prepend|chain|disabled] . instrumentation.puma_rack_urlmap Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_PUMA_RACK_URLMAP Controls auto-instrumentation of Puma::Rack::URLMap at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcached Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHED Controls auto-instrumentation of memcached gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcache_client Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHE_CLIENT Controls auto-instrumentation of memcache-client gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcache Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHE Controls auto-instrumentation of dalli gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.logger Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_LOGGER Controls auto-instrumentation of Ruby standard library Logger at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.excon Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_EXCON Controls auto-instrumentation of Excon at start up. May be one of [enabled|disabled] . instrumentation.grape Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_GRAPE Controls auto-instrumentation of Grape at start up. May be one of [auto|prepend|chain|disabled] . Mongo mongo.capture_queries Type Boolean Default true Environ variable NEW_RELIC_MONGO_CAPTURE_QUERIES If true, the agent captures Mongo queries in transaction traces. mongo.obfuscate_queries Type Boolean Default true Environ variable NEW_RELIC_MONGO_OBFUSCATE_QUERIES If true, the agent obfuscates Mongo queries in transaction traces. Process Host process_host.display_name Type String Default (Dynamic) Environ variable NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Specify a custom host name for display in the New Relic UI. Rake rake.tasks Type Array Default [] Environ variable NEW_RELIC_RAKE_TASKS Specify an array of Rake tasks to automatically instrument. rake.connect_timeout Type Integer Default 10 Environ variable NEW_RELIC_RAKE_CONNECT_TIMEOUT Timeout for waiting on connect to complete before a rake task Resque resque.capture_params Type Boolean Default false Environ variable NEW_RELIC_RESQUE_CAPTURE_PARAMS DEPRECATED If true, enables the capture of job arguments for transaction traces and traced errors in Resque. Rules rules.ignore_url_regexes Type Array Default [] Environ variable NEW_RELIC_RULES_IGNORE_URL_REGEXES Define transactions you want the agent to ignore, by specifying a list of patterns matching the URI you want to ignore. Note: This will only ignore transaction events, not spans or traces from the same transation. See documentation on (ignoring specific transactions) [https://docs.newrelic.com/docs/agents/ruby-agent/api-guides/ignoring-specific-transactions/#config-ignoring] for more details. Sidekiq sidekiq.capture_params Type Boolean Default false Environ variable NEW_RELIC_SIDEKIQ_CAPTURE_PARAMS DEPRECATED If true, enables the capture of job arguments for transaction traces and traced errors in Sidekiq. Slow SQL slow_sql.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_ENABLED If true, the agent collects slow SQL queries. slow_sql.explain_threshold Type Float Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_EXPLAIN_THRESHOLD Specify a threshold in seconds. The agent collects slow SQL queries and explain plans that exceed this threshold. slow_sql.explain_enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_EXPLAIN_ENABLED If true, the agent collects explain plans in slow SQL queries. If this setting is omitted, the transaction_tracer.explain_enabled setting will be applied as the default setting for explain plans in slow SQL as well. slow_sql.record_sql Type String Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_RECORD_SQL Defines an obfuscation level for slow SQL queries. Valid options are obfuscated, raw, or none). slow_sql.use_longer_sql_id Type Boolean Default false Environ variable NEW_RELIC_SLOW_SQL_USE_LONGER_SQL_ID Generate a longer sql_id for slow SQL traces. sql_id is used for aggregation of similar queries. Span Events span_events.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ENABLED If true, enables span event sampling. span_events.queue_size Type Integer Default 10000 Environ variable NEW_RELIC_SPAN_EVENTS_QUEUE_SIZE Sets the maximum number of span events to buffer when streaming to the trace observer. span_events.max_samples_stored Type Integer Default 2000 Environ variable NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of span events reported from a single harvest. Strip Exception Messages strip_exception_messages.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_STRIP_EXCEPTION_MESSAGES_ENABLED If true, the agent strips messages from all exceptions except those in the allowlist. Enabled automatically in high security mode. strip_exception_messages.allowed_classes Type String Default \"\" Environ variable NEW_RELIC_STRIP_EXCEPTION_MESSAGES_ALLOWED_CLASSES Specify a list of exceptions you do not want the agent to strip when strip_exception_messages is true. Separate exceptions with a comma. For example, \"ImportantException,PreserveMessageException\". Thread Profiler thread_profiler.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_THREAD_PROFILER_ENABLED If true, enables use of the thread profiler. Utilization utilization.detect_aws Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_AWS If true, the agent automatically detects that it is running in an AWS environment. utilization.detect_azure Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_AZURE If true, the agent automatically detects that it is running in an Azure environment. utilization.detect_gcp Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_GCP If true, the agent automatically detects that it is running in an Google Cloud Platform environment. utilization.detect_pcf Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_PCF If true, the agent automatically detects that it is running in a Pivotal Cloud Foundry environment. utilization.detect_docker Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_DOCKER If true, the agent automatically detects that it is running in Docker. utilization.detect_kubernetes Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_KUBERNETES If true, the agent automatically detects that it is running in Kubernetes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.26233,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Ruby <em>agent</em> configuration",
        "sections": "<em>Attributes</em>",
        "tags": "<em>Agents</em>",
        "body": " the capture_params setting, the Ruby <em>agent</em> will not attempt to filter secret information. Recommendation: To filter secret information from request parameters, use the <em>attributes</em>.include setting instead. For more information, see the Ruby attribute examples. config_path Type String Default (Dynamic"
      },
      "id": "603eb6f4e7b9d22a5f2f7c73"
    },
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-10-18T05:35:40Z",
      "updated_at": "2021-09-27T15:21:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # Real-time profiling using Java Flight Recorder (JFR). # This feature reports dimensional metrics to the ingest endpoint configured by # metric_ingest_uri and events to the ingest endpoint configured by event_ingest_uri. # Both ingest endpoints default to US production but they will be automatically set to EU # production when using an EU license key. Other ingest endpoints can be configured manually. # Requires a JVM that provides the JFR library. jfr: # Set to true to enable Real-time profiling with JFR. # Default is false. enabled: false # Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. # Audit logging is extremely verbose and should only be used for troubleshooting purposes. # Default is false. audit_logging: false # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.83655,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;configuration&#x2F;<em>java</em>-<em>agent</em>-configuration-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    }
  ],
  "/docs/agents/java-agent/configuration/automatic-application-naming": [
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-10-18T05:35:40Z",
      "updated_at": "2021-09-27T15:21:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # Real-time profiling using Java Flight Recorder (JFR). # This feature reports dimensional metrics to the ingest endpoint configured by # metric_ingest_uri and events to the ingest endpoint configured by event_ingest_uri. # Both ingest endpoints default to US production but they will be automatically set to EU # production when using an EU license key. Other ingest endpoints can be configured manually. # Requires a JVM that provides the JFR library. jfr: # Set to true to enable Real-time profiling with JFR. # Default is false. enabled: false # Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. # Audit logging is extremely verbose and should only be used for troubleshooting purposes. # Default is false. audit_logging: false # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.62119,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>configuration</em>&#x2F;<em>java</em>-<em>agent</em>-<em>configuration</em>-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    },
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "event_ingest_uri",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "metric_ingest_uri",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "JFR (Real-time profiling)",
        "audit_logging",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignoreErrorPriority",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-10-19T05:54:03Z",
      "updated_at": "2021-09-20T19:27:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. event_ingest_uri Type String Default https://insights-collector.newrelic.com/v1/accounts/events Event ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send events to other ingest endpoints (for example, EU production: https://insights-collector.eu01.nr-data.net/v1/accounts/events). extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is not currently used by the agent. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. metric_ingest_uri Type String Default https://metric-api.newrelic.com/metric/v1 Metric ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send metrics to other ingest endpoints (for example EU production: https://metric-api.eu.newrelic.com/metric/v1). proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default false Whether errors are reported for Reactor Netty. Default is false. If set to true, Reactor Netty errors will be reported. Important Only available in Java agent 6.3.0 and above. Notice, default was changed to false as of Java agent 6.5.0. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transactions total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data. Additionally the agent can expose linking metadata over JMX that can be used by other tracing systems. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata over remote JMX. Important This applies to Java agent version 6.1.0 or higher. JFR (Real-time profiling) The Java agent uses Java Flight Recorder (JFR) to collect high fidelity JVM data for Real-time profiling. Real-time profiling can be configured in the jfr stanza in the agent yaml, with system properties prefixed by newrelic.config.jfr., or with environment variables prefixed with NEW_RELIC_JFR_. enabled Type Boolean Default false Set to true to enable Real-time profiling with JFR. Important Real-time profiling with JFR is on by default in Java agent version 7.1.0. If you are on any other agent version 7.0.0 or higher, you can turn on JFR by changing the value to true. audit_logging Type Boolean Default false Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. Audit logging is extremely verbose and should only be used for troubleshooting purposes. Important This applies to Java agent version 7.0.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list exception class names you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy An environment variable can be used to list exception class names and messages you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list expected exception class names: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\" Copy An environment variable can be used to list expected exception class names and messages: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignoreErrorPriority Type Boolean Default true When multiple errors are noticed in a transaction, only the last error will be reported by default. Setting this property to false will instead report only the first error that is noticed. For more information, see the noticeError API. For example: error_collector: ignoreErrorPriority: false Copy ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messagesprefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings  OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.35989,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "sections": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> reads its <em>configuration</em> from the newrelic.yml file. By default the <em>agent</em> looks for this file in the directory that contains newrelic.jar. You can override the config file&#x27;s location by setting the newrelic.config.file system property to a fully qualified file name"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Hostname logic in Java",
        "Display names",
        "Tip",
        "Instance names",
        "Hostname logic precedence",
        "Hosts and unique agent identifiers",
        "For more help"
      ],
      "title": "Hostname logic in Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "32a9b875cf20d27be147a4ca29b749f1612d94e2",
      "image": "https://docs.newrelic.com/static/026e7b6f7910842deb3f7c1960cad008/9e32a/upload.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/hostname-logic-java/",
      "published_at": "2021-10-18T05:35:39Z",
      "updated_at": "2021-09-14T09:17:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Java agent automatically assigns a host:port name to your JVMs. If the default name is not useful, you can set a display name to distinguish your JVMs in the New Relic UI. For supported frameworks, the Java agent uses the instance name instead of the display name. The Java agent uniquely identifies running agents by their host, port, and dispatcher, regardless of the environment used. Display names If the default host:port label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. Set the display name via configuration, either in an environment variable or in your newrelic.yml config file. The environment variable takes precedence over the config file value. After the JVM is restarted and the Java agent is reporting again , the display name will show in the JVM list as seen in the example below in addition to host:port. To set a display name: Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable. OR Set process_host.display_name in your newrelic.yml. Restart your JVM to see your changes in the New Relic UI. Tip You can also set the display name with a system property. Instance names For WebSphere and WebLogic users, the Java agent also reports the instance name for each active app server instance, which is visible in the APM Settings > Environment page. Generally, this name is provided by the app server. If an instance name is set, it will be used instead of the display name in the New Relic UI. Hostname logic precedence If there are multiple hostname settings (for example, you use WebSphere and also set the display_name property), the agent uses this precedence: display_name overrides the default name, and the WebSphere and WebLogic instance names. WebSphere and WebLogic instance names override the default name. The default (host:port) name has lowest precedence. Hosts and unique agent identifiers The Java agent uses hosts, ports, and dispatchers to uniquely identify multiple JVMs reporting to the same app name. Multiple agents running on the same server are therefore reported separately, as long as their ports or dispatcher names differ. The unique identifier is based on the following values: Host: An identifier for your app's parent server that is derived from the Operating System. This value is not configurable by the Java agent. Port: The port associated with the app server. If the agent can't determine the port number, or your app is not running in an app server, defaults to 0. This value is user-configurable. Dispatcher Name: The name of the app server. For example, Apache Tomcat, Glassfish, or WebLogic. If there is no active app server, defaults to Unknown. For more help Additional documentation resources include: Setting the hostname reported by the Java agent (manually overriding the hostname settings when the link between your APM app and Servers for Linux is broken) Add, rename, and remove hosts (add and remove hosts in APM)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.903656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Hostname logic in <em>Java</em>",
        "sections": "Hostname logic in <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " name. The default (host:port) name has lowest precedence. Hosts and unique <em>agent</em> identifiers The <em>Java</em> <em>agent</em> uses hosts, ports, and dispatchers to uniquely identify multiple JVMs reporting to the same app name. Multiple <em>agents</em> running on the same server are therefore reported separately, as long"
      },
      "id": "6043cfbb64441ff20b378f0b"
    }
  ],
  "/docs/agents/java-agent/configuration/configuring-your-ssl-certificates": [
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-10-18T05:35:40Z",
      "updated_at": "2021-09-27T15:21:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # Real-time profiling using Java Flight Recorder (JFR). # This feature reports dimensional metrics to the ingest endpoint configured by # metric_ingest_uri and events to the ingest endpoint configured by event_ingest_uri. # Both ingest endpoints default to US production but they will be automatically set to EU # production when using an EU license key. Other ingest endpoints can be configured manually. # Requires a JVM that provides the JFR library. jfr: # Set to true to enable Real-time profiling with JFR. # Default is false. enabled: false # Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. # Audit logging is extremely verbose and should only be used for troubleshooting purposes. # Default is false. audit_logging: false # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.621185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>configuration</em>&#x2F;<em>java</em>-<em>agent</em>-<em>configuration</em>-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    },
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "event_ingest_uri",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "metric_ingest_uri",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "JFR (Real-time profiling)",
        "audit_logging",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignoreErrorPriority",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-10-19T05:54:03Z",
      "updated_at": "2021-09-20T19:27:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. event_ingest_uri Type String Default https://insights-collector.newrelic.com/v1/accounts/events Event ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send events to other ingest endpoints (for example, EU production: https://insights-collector.eu01.nr-data.net/v1/accounts/events). extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is not currently used by the agent. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. metric_ingest_uri Type String Default https://metric-api.newrelic.com/metric/v1 Metric ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send metrics to other ingest endpoints (for example EU production: https://metric-api.eu.newrelic.com/metric/v1). proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default false Whether errors are reported for Reactor Netty. Default is false. If set to true, Reactor Netty errors will be reported. Important Only available in Java agent 6.3.0 and above. Notice, default was changed to false as of Java agent 6.5.0. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transactions total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data. Additionally the agent can expose linking metadata over JMX that can be used by other tracing systems. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata over remote JMX. Important This applies to Java agent version 6.1.0 or higher. JFR (Real-time profiling) The Java agent uses Java Flight Recorder (JFR) to collect high fidelity JVM data for Real-time profiling. Real-time profiling can be configured in the jfr stanza in the agent yaml, with system properties prefixed by newrelic.config.jfr., or with environment variables prefixed with NEW_RELIC_JFR_. enabled Type Boolean Default false Set to true to enable Real-time profiling with JFR. Important Real-time profiling with JFR is on by default in Java agent version 7.1.0. If you are on any other agent version 7.0.0 or higher, you can turn on JFR by changing the value to true. audit_logging Type Boolean Default false Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. Audit logging is extremely verbose and should only be used for troubleshooting purposes. Important This applies to Java agent version 7.0.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list exception class names you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy An environment variable can be used to list exception class names and messages you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list expected exception class names: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\" Copy An environment variable can be used to list expected exception class names and messages: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignoreErrorPriority Type Boolean Default true When multiple errors are noticed in a transaction, only the last error will be reported by default. Setting this property to false will instead report only the first error that is noticed. For more information, see the noticeError API. For example: error_collector: ignoreErrorPriority: false Copy ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messagesprefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings  OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.35989,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "sections": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> reads its <em>configuration</em> from the newrelic.yml file. By default the <em>agent</em> looks for this file in the directory that contains newrelic.jar. You can override the config file&#x27;s location by setting the newrelic.config.file system property to a fully qualified file name"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Hostname logic in Java",
        "Display names",
        "Tip",
        "Instance names",
        "Hostname logic precedence",
        "Hosts and unique agent identifiers",
        "For more help"
      ],
      "title": "Hostname logic in Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "32a9b875cf20d27be147a4ca29b749f1612d94e2",
      "image": "https://docs.newrelic.com/static/026e7b6f7910842deb3f7c1960cad008/9e32a/upload.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/hostname-logic-java/",
      "published_at": "2021-10-18T05:35:39Z",
      "updated_at": "2021-09-14T09:17:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Java agent automatically assigns a host:port name to your JVMs. If the default name is not useful, you can set a display name to distinguish your JVMs in the New Relic UI. For supported frameworks, the Java agent uses the instance name instead of the display name. The Java agent uniquely identifies running agents by their host, port, and dispatcher, regardless of the environment used. Display names If the default host:port label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. Set the display name via configuration, either in an environment variable or in your newrelic.yml config file. The environment variable takes precedence over the config file value. After the JVM is restarted and the Java agent is reporting again , the display name will show in the JVM list as seen in the example below in addition to host:port. To set a display name: Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable. OR Set process_host.display_name in your newrelic.yml. Restart your JVM to see your changes in the New Relic UI. Tip You can also set the display name with a system property. Instance names For WebSphere and WebLogic users, the Java agent also reports the instance name for each active app server instance, which is visible in the APM Settings > Environment page. Generally, this name is provided by the app server. If an instance name is set, it will be used instead of the display name in the New Relic UI. Hostname logic precedence If there are multiple hostname settings (for example, you use WebSphere and also set the display_name property), the agent uses this precedence: display_name overrides the default name, and the WebSphere and WebLogic instance names. WebSphere and WebLogic instance names override the default name. The default (host:port) name has lowest precedence. Hosts and unique agent identifiers The Java agent uses hosts, ports, and dispatchers to uniquely identify multiple JVMs reporting to the same app name. Multiple agents running on the same server are therefore reported separately, as long as their ports or dispatcher names differ. The unique identifier is based on the following values: Host: An identifier for your app's parent server that is derived from the Operating System. This value is not configurable by the Java agent. Port: The port associated with the app server. If the agent can't determine the port number, or your app is not running in an app server, defaults to 0. This value is user-configurable. Dispatcher Name: The name of the app server. For example, Apache Tomcat, Glassfish, or WebLogic. If there is no active app server, defaults to Unknown. For more help Additional documentation resources include: Setting the hostname reported by the Java agent (manually overriding the hostname settings when the link between your APM app and Servers for Linux is broken) Add, rename, and remove hosts (add and remove hosts in APM)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.90365,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Hostname logic in <em>Java</em>",
        "sections": "Hostname logic in <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " name. The default (host:port) name has lowest precedence. Hosts and unique <em>agent</em> identifiers The <em>Java</em> <em>agent</em> uses hosts, ports, and dispatchers to uniquely identify multiple JVMs reporting to the same app name. Multiple <em>agents</em> running on the same server are therefore reported separately, as long"
      },
      "id": "6043cfbb64441ff20b378f0b"
    }
  ],
  "/docs/agents/java-agent/configuration/hostname-logic-java": [
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-10-18T05:35:40Z",
      "updated_at": "2021-09-27T15:21:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # Real-time profiling using Java Flight Recorder (JFR). # This feature reports dimensional metrics to the ingest endpoint configured by # metric_ingest_uri and events to the ingest endpoint configured by event_ingest_uri. # Both ingest endpoints default to US production but they will be automatically set to EU # production when using an EU license key. Other ingest endpoints can be configured manually. # Requires a JVM that provides the JFR library. jfr: # Set to true to enable Real-time profiling with JFR. # Default is false. enabled: false # Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. # Audit logging is extremely verbose and should only be used for troubleshooting purposes. # Default is false. audit_logging: false # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.621185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>configuration</em>&#x2F;<em>java</em>-<em>agent</em>-<em>configuration</em>-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    },
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "event_ingest_uri",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "metric_ingest_uri",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "JFR (Real-time profiling)",
        "audit_logging",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignoreErrorPriority",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-10-19T05:54:03Z",
      "updated_at": "2021-09-20T19:27:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. event_ingest_uri Type String Default https://insights-collector.newrelic.com/v1/accounts/events Event ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send events to other ingest endpoints (for example, EU production: https://insights-collector.eu01.nr-data.net/v1/accounts/events). extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is not currently used by the agent. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. metric_ingest_uri Type String Default https://metric-api.newrelic.com/metric/v1 Metric ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send metrics to other ingest endpoints (for example EU production: https://metric-api.eu.newrelic.com/metric/v1). proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default false Whether errors are reported for Reactor Netty. Default is false. If set to true, Reactor Netty errors will be reported. Important Only available in Java agent 6.3.0 and above. Notice, default was changed to false as of Java agent 6.5.0. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transactions total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data. Additionally the agent can expose linking metadata over JMX that can be used by other tracing systems. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata over remote JMX. Important This applies to Java agent version 6.1.0 or higher. JFR (Real-time profiling) The Java agent uses Java Flight Recorder (JFR) to collect high fidelity JVM data for Real-time profiling. Real-time profiling can be configured in the jfr stanza in the agent yaml, with system properties prefixed by newrelic.config.jfr., or with environment variables prefixed with NEW_RELIC_JFR_. enabled Type Boolean Default false Set to true to enable Real-time profiling with JFR. Important Real-time profiling with JFR is on by default in Java agent version 7.1.0. If you are on any other agent version 7.0.0 or higher, you can turn on JFR by changing the value to true. audit_logging Type Boolean Default false Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. Audit logging is extremely verbose and should only be used for troubleshooting purposes. Important This applies to Java agent version 7.0.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list exception class names you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy An environment variable can be used to list exception class names and messages you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list expected exception class names: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\" Copy An environment variable can be used to list expected exception class names and messages: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignoreErrorPriority Type Boolean Default true When multiple errors are noticed in a transaction, only the last error will be reported by default. Setting this property to false will instead report only the first error that is noticed. For more information, see the noticeError API. For example: error_collector: ignoreErrorPriority: false Copy ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messagesprefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings  OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.35989,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "sections": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> reads its <em>configuration</em> from the newrelic.yml file. By default the <em>agent</em> looks for this file in the directory that contains newrelic.jar. You can override the config file&#x27;s location by setting the newrelic.config.file system property to a fully qualified file name"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Ruby agent configuration",
        "Configuration methods and precedence",
        "View and edit config file options",
        "Update the config file",
        "Important",
        "General",
        "license_key",
        "agent_enabled",
        "app_name",
        "monitor_mode",
        "log_level",
        "high_security",
        "security_policies_token",
        "proxy_host",
        "proxy_port",
        "proxy_user",
        "proxy_pass",
        "capture_params",
        "Caution",
        "config_path",
        "apdex_t",
        "sync_startup",
        "send_data_on_exit",
        "timeout",
        "force_install_exit_handler",
        "log_file_name",
        "log_file_path",
        "prepend_active_record_instrumentation",
        "capture_memcache_keys",
        "message_tracer.segment_parameters.enabled",
        "marshaller",
        "backport_fast_active_record_connection_lookup",
        "labels",
        "ca_bundle_path",
        "datastore_tracer.instance_reporting.enabled",
        "datastore_tracer.database_name_reporting.enabled",
        "clear_transaction_state_after_fork",
        "exclude_newrelic_header",
        "infinite_tracing.trace_observer.host",
        "infinite_tracing.trace_observer.port",
        "Transaction Tracer",
        "transaction_tracer.enabled",
        "transaction_tracer.transaction_threshold",
        "transaction_tracer.record_sql",
        "transaction_tracer.record_redis_arguments",
        "transaction_tracer.capture_attributes",
        "transaction_tracer.explain_threshold",
        "transaction_tracer.explain_enabled",
        "transaction_tracer.stack_trace_threshold",
        "transaction_tracer.limit_segments",
        "Error Collector",
        "error_collector.enabled",
        "error_collector.capture_attributes",
        "error_collector.ignore_errors",
        "error_collector.ignore_classes",
        "error_collector.ignore_messages",
        "error_collector.ignore_status_codes",
        "error_collector.expected_classes",
        "error_collector.expected_messages",
        "error_collector.expected_status_codes",
        "error_collector.max_backtrace_frames",
        "error_collector.capture_events",
        "error_collector.max_event_samples_stored",
        "Browser Monitoring",
        "browser_monitoring.auto_instrument",
        "browser_monitoring.capture_attributes",
        "Analytics Events",
        "analytics_events.enabled",
        "analytics_events.max_samples_stored",
        "analytics_events.capture_attributes",
        "Attributes",
        "attributes.enabled",
        "transaction_tracer.attributes.enabled",
        "transaction_events.attributes.enabled",
        "error_collector.attributes.enabled",
        "browser_monitoring.attributes.enabled",
        "span_events.attributes.enabled",
        "transaction_segments.attributes.enabled",
        "attributes.exclude",
        "transaction_tracer.attributes.exclude",
        "transaction_events.attributes.exclude",
        "error_collector.attributes.exclude",
        "browser_monitoring.attributes.exclude",
        "span_events.attributes.exclude",
        "transaction_segments.attributes.exclude",
        "attributes.include",
        "transaction_tracer.attributes.include",
        "transaction_events.attributes.include",
        "error_collector.attributes.include",
        "browser_monitoring.attributes.include",
        "span_events.attributes.include",
        "transaction_segments.attributes.include",
        "Audit Log",
        "audit_log.enabled",
        "audit_log.path",
        "audit_log.endpoints",
        "Autostart",
        "autostart.denylisted_constants",
        "autostart.denylisted_executables",
        "autostart.denylisted_rake_tasks",
        "Cross Application Tracer",
        "cross_application_tracer.enabled",
        "Custom Attributes",
        "custom_attributes.enabled",
        "Custom Insights Events",
        "custom_insights_events.enabled",
        "custom_insights_events.max_samples_stored",
        "Disabling",
        "disable_rake",
        "disable_samplers",
        "disable_resque",
        "disable_sidekiq",
        "disable_dj",
        "disable_sinatra",
        "disable_sinatra_auto_middleware",
        "disable_view_instrumentation",
        "disable_activerecord_instrumentation",
        "disable_data_mapper",
        "disable_activejob",
        "disable_action_cable_instrumentation",
        "disable_active_storage",
        "disable_memcached",
        "disable_memcache_client",
        "disable_dalli",
        "disable_dalli_cas_client",
        "disable_memcache_instrumentation",
        "disable_gc_profiler",
        "disable_sequel_instrumentation",
        "disable_database_instrumentation",
        "disable_mongo",
        "disable_redis",
        "disable_vm_sampler",
        "disable_memory_sampler",
        "disable_cpu_sampler",
        "disable_delayed_job_sampler",
        "disable_active_record_notifications",
        "disable_bunny",
        "disable_curb",
        "disable_excon",
        "disable_httpclient",
        "disable_net_http",
        "disable_rack",
        "disable_rack_urlmap",
        "disable_puma_rack",
        "disable_puma_rack_urlmap",
        "disable_typhoeus",
        "disable_httprb",
        "disable_middleware_instrumentation",
        "disable_grape",
        "Distributed Tracing",
        "distributed_tracing.enabled",
        "Heroku",
        "heroku.use_dyno_names",
        "heroku.dyno_name_prefixes_to_shorten",
        "Instrumentation",
        "instrumentation.net_http",
        "instrumentation.typhoeus",
        "instrumentation.bunny",
        "instrumentation.httprb",
        "instrumentation.resque",
        "instrumentation.redis",
        "instrumentation.rake",
        "instrumentation.mongo",
        "instrumentation.delayed_job",
        "instrumentation.httpclient",
        "instrumentation.curb",
        "instrumentation.sinatra",
        "instrumentation.rack",
        "instrumentation.rack_urlmap",
        "instrumentation.puma_rack",
        "instrumentation.puma_rack_urlmap",
        "instrumentation.memcached",
        "instrumentation.memcache_client",
        "instrumentation.memcache",
        "instrumentation.logger",
        "instrumentation.excon",
        "instrumentation.grape",
        "Mongo",
        "mongo.capture_queries",
        "mongo.obfuscate_queries",
        "Process Host",
        "process_host.display_name",
        "Rake",
        "rake.tasks",
        "rake.connect_timeout",
        "Resque",
        "resque.capture_params",
        "Rules",
        "rules.ignore_url_regexes",
        "Sidekiq",
        "sidekiq.capture_params",
        "Slow SQL",
        "slow_sql.enabled",
        "slow_sql.explain_threshold",
        "slow_sql.explain_enabled",
        "slow_sql.record_sql",
        "slow_sql.use_longer_sql_id",
        "Span Events",
        "span_events.enabled",
        "span_events.queue_size",
        "span_events.max_samples_stored",
        "Strip Exception Messages",
        "strip_exception_messages.enabled",
        "strip_exception_messages.allowed_classes",
        "Thread Profiler",
        "thread_profiler.enabled",
        "Utilization",
        "utilization.detect_aws",
        "utilization.detect_azure",
        "utilization.detect_gcp",
        "utilization.detect_pcf",
        "utilization.detect_docker",
        "utilization.detect_kubernetes"
      ],
      "title": "Ruby agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Configuration"
      ],
      "external_id": "ee72f1c59d456c5e5a089cfa81bfbde6064d7cb0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/configuration/ruby-agent-configuration/",
      "published_at": "2021-10-19T03:52:40Z",
      "updated_at": "2021-10-19T03:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can configure the New Relic Ruby agent with settings in a configuration file, environment variables, or programmatically with server-side configuration. This document summarizes the configuration options available for the Ruby agent. If the default value for a configuration option is (Dynamic), this means the Ruby agent calculates the default at runtime. The value for the config setting defaults to the value of another setting as appropriate. Configuration methods and precedence The primary (default) method to configure the Ruby agent is via the configuration file (newrelic.yml) in the config subdirectory. To set configuration values using environment variables: Add the prefix NEW_RELIC_ to the setting's name. Replace any periods . with underscores _. You can also configure a few values in the UI via server-side configuration. The Ruby agent follows this order of precedence for configuration: Environment variables Server-side configuration Configuration file (newrelic.yml) Default configuration settings In other words, environment variables override all other configuration settings and info, server-side configuration overrides the configuration file and default config settings, and so on. View and edit config file options The Ruby agent's newrelic.yml is a standard YAML configuration file. It typically includes a Defaults section at the top, plus sections below for each application environment; for example, Development, Testing, and Production. The Ruby agent determines which section of the newrelic.yml config file to read from by looking at certain environment variables to derive the application's environment. This can be useful, for example, when you want to use info for the log_level config setting in your production environment, and you want more verbose log_level config settings (such as debug in your development environment. Here is an example newrelic.yml config file: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'My Application Name' production: <<: *default_settings log_level: info development: <<: *default_settings log_level: debug Copy For non-Rails apps, the Ruby agent looks for the following environment variables, in this order, to determine the application environment: NEW_RELIC_ENV RUBY_ENV RAILS_ENV APP_ENV RACK_ENV If the Ruby agent does not detect values for any of those environment variables, it will default the application environment to development and read from the development section of the newrelic.yml config file. When running the Ruby agent in a Rails app, the agent first looks for the NEW_RELIC_ENV environment variable to determine the application environment and which section of the newrelic.yml to use. If NEW_RELIC_ENV is not present, the agent uses the Rails environment (RAILS_ENV or RAILS.env, depending on the version of Rails) . When you edit the config file, be sure to: Indent only with two spaces. Indent only where relevant, in stanzas such as error_collector. If you do not indent correctly, the agent may throw an Unable to parse configuration file error on startup. To view the most current list of available Ruby agent configuration options, use the rake newrelic:config:docs command. This document describes the most common options. Update the config file This documentation applies to the Ruby agent's latest release. For details on earlier versions, refer to the comments in newrelic.yml itself. To update newrelic.yml file after a new release, use the template in the base directory of the agent gem. When you update to new gem versions, examine or diff config/newrelic.yml and newrelic.yml in the installation directory to take advantage of new configuration options. Important Updating the gem does not automatically update config/newrelic.yml. General These settings are available for agent configuration. Some settings depend on your New Relic subscription level. license_key Type String Default \"\" Environ variable NEW_RELIC_LICENSE_KEY Your New Relic license key. agent_enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_AGENT_ENABLED If true, allows the Ruby agent to run. app_name Type String Default (Dynamic) Environ variable NEW_RELIC_APP_NAME Specify the application name used to aggregate data in the New Relic UI. To report data to multiple apps at the same time, specify a list of names separated by a semicolon ;. For example, MyApp or MyStagingApp;Instance1. monitor_mode Type Boolean Default (Dynamic) Environ variable NEW_RELIC_MONITOR_MODE When true, the agent transmits data about your app to the New Relic collector. log_level Type String Default \"info\" Environ variable NEW_RELIC_LOG_LEVEL Sets the level of detail of log messages. Possible log levels, in increasing verbosity, are: error, warn, info or debug. high_security Type Boolean Default false Environ variable NEW_RELIC_HIGH_SECURITY If true, enables high security mode. Ensure you understand the implications of high security mode before enabling this setting. security_policies_token Type String Default \"\" Environ variable NEW_RELIC_SECURITY_POLICIES_TOKEN Applies Language Agent Security Policy settings. proxy_host Type String Default nil Environ variable NEW_RELIC_PROXY_HOST Defines a host for communicating with the New Relic collector via a proxy server. proxy_port Type Integer Default 8080 Environ variable NEW_RELIC_PROXY_PORT Defines a port for communicating with the New Relic collector via a proxy server. proxy_user Type String Default nil Environ variable NEW_RELIC_PROXY_USER Defines a user for communicating with the New Relic collector via a proxy server. proxy_pass Type String Default nil Environ variable NEW_RELIC_PROXY_PASS Defines a password for communicating with the New Relic collector via a proxy server. capture_params Type Boolean Default false Environ variable NEW_RELIC_CAPTURE_PARAMS When true, the agent captures HTTP request parameters and attaches them to transaction traces, traced errors, and TransactionError events. Caution When using the capture_params setting, the Ruby agent will not attempt to filter secret information. Recommendation: To filter secret information from request parameters, use the attributes.include setting instead. For more information, see the Ruby attribute examples. config_path Type String Default (Dynamic) Environ variable NEW_RELIC_CONFIG_PATH Path to newrelic.yml. If undefined, the agent checks the following directories (in order): config/newrelic.yml, newrelic.yml, $HOME/.newrelic/newrelic.yml and $HOME/newrelic.yml. apdex_t Type Float Default 0.5 Environ variable NEW_RELIC_APDEX_T DEPRECATED For agent versions 3.5.0 or higher, set your Apdex T via the New Relic UI. sync_startup Type Boolean Default false Environ variable NEW_RELIC_SYNC_STARTUP When set to true, forces a synchronous connection to the New Relic collector during application startup. For very short-lived processes, this helps ensure the New Relic agent has time to report. send_data_on_exit Type Boolean Default true Environ variable NEW_RELIC_SEND_DATA_ON_EXIT If true, enables the exit handler that sends data to the New Relic collector before shutting down. timeout Type Integer Default 120 Environ variable NEW_RELIC_TIMEOUT Defines the maximum number of seconds the agent should spend attempting to connect to the collector. force_install_exit_handler Type Boolean Default false Environ variable NEW_RELIC_FORCE_INSTALL_EXIT_HANDLER Forces the exit handler that sends all cached data to collector before shutting down to be installed regardless of detecting scenarios where it generally should not be. Known use-case for this option is where Sinatra is running as an embedded service within another framework and the agent is detecting the Sinatra app and skipping the at_exit handler as a result. Sinatra classically runs the entire application in an at_exit block and would otherwise misbehave if the Agent's at_exit handler was also installed in those circumstances. Note: send_data_on_exit should also be set to true in tandem with this setting. log_file_name Type String Default \"newrelic_agent.log\" Environ variable NEW_RELIC_LOG_FILE_NAME Defines a name for the log file. log_file_path Type String Default \"log/\" Environ variable NEW_RELIC_LOG_FILE_PATH Defines a path to the agent log file, excluding the filename. prepend_active_record_instrumentation Type Boolean Default false Environ variable NEW_RELIC_PREPEND_ACTIVE_RECORD_INSTRUMENTATION If true, uses Module#prepend rather than alias_method for ActiveRecord instrumentation. capture_memcache_keys Type Boolean Default false Environ variable NEW_RELIC_CAPTURE_MEMCACHE_KEYS Enable or disable the capture of memcache keys from transaction traces. message_tracer.segment_parameters.enabled Type Boolean Default true Environ variable NEW_RELIC_MESSAGE_TRACER_SEGMENT_PARAMETERS_ENABLED If true, the agent will collect metadata about messages and attach them as segment parameters. marshaller Type String Default \"json\" Environ variable NEW_RELIC_MARSHALLER Specifies a marshaller for transmitting data to the New Relic collector. Currently json is the only valid value for this setting. backport_fast_active_record_connection_lookup Type Boolean Default false Environ variable NEW_RELIC_BACKPORT_FAST_ACTIVE_RECORD_CONNECTION_LOOKUP Backports the faster ActiveRecord connection lookup introduced in Rails 6, which improves agent performance when instrumenting ActiveRecord. Note that this setting may not be compatible with other gems that patch ActiveRecord. labels Type String Default \"\" Environ variable NEW_RELIC_LABELS A dictionary of label names and values that will be applied to the data sent from this agent. May also be expressed as a semicolon-delimited ; string of colon-separated : pairs. For example, <var>Server</var>:<var>One</var>;<var>Data Center</var>:<var>Primary</var>. ca_bundle_path Type String Default nil Environ variable NEW_RELIC_CA_BUNDLE_PATH Manual override for the path to your local CA bundle. This CA bundle will be used to validate the SSL certificate presented by New Relic's data collection service. datastore_tracer.instance_reporting.enabled Type Boolean Default true Environ variable NEW_RELIC_DATASTORE_TRACER_INSTANCE_REPORTING_ENABLED If false, the agent will not report datastore instance metrics, nor add host or port_path_or_id parameters to transaction or slow SQL traces. datastore_tracer.database_name_reporting.enabled Type Boolean Default true Environ variable NEW_RELIC_DATASTORE_TRACER_DATABASE_NAME_REPORTING_ENABLED If false, the agent will not add database_name parameter to transaction or slow sql traces. clear_transaction_state_after_fork Type Boolean Default false Environ variable NEW_RELIC_CLEAR_TRANSACTION_STATE_AFTER_FORK If true, the agent will clear Tracer::State in Agent.drop_buffered_data. exclude_newrelic_header Type Boolean Default false Environ variable NEW_RELIC_EXCLUDE_NEWRELIC_HEADER Allows newrelic distributed tracing headers to be suppressed on outbound requests. infinite_tracing.trace_observer.host Type String Default \"\" Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST Configures the hostname for the Trace Observer Host. When configured, enables tail-based sampling by sending all recorded spans to a Trace Observer for further sampling decisions, irrespective of any usual agent sampling decision. infinite_tracing.trace_observer.port Type Integer Default 443 Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_PORT Configures the TCP/IP port for the Trace Observer Host Transaction Tracer The transaction traces feature collects detailed information from a selection of transactions, including a summary of the calling sequence, a breakdown of time spent, and a list of SQL queries and their query plans (on mysql and postgresql). Available features depend on your New Relic subscription level. transaction_tracer.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_ENABLED If true, enables collection of transaction traces. transaction_tracer.transaction_threshold Type Float Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_TRACER_TRANSACTION_THRESHOLD Specify a threshold in seconds. Transactions with a duration longer than this threshold are eligible for transaction traces. Specify a float value or the string apdex_f. transaction_tracer.record_sql Type String Default \"obfuscated\" Environ variable NEW_RELIC_TRANSACTION_TRACER_RECORD_SQL Obfuscation level for SQL queries reported in transaction trace nodes. By default, this is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to none. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. transaction_tracer.record_redis_arguments Type Boolean Default false Environ variable NEW_RELIC_TRANSACTION_TRACER_RECORD_REDIS_ARGUMENTS If true, the agent records Redis command arguments in transaction traces. transaction_tracer.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_CAPTURE_ATTRIBUTES DEPRECATED Use transaction_tracer.attributes.enabled instead. transaction_tracer.explain_threshold Type Float Default 0.5 Environ variable NEW_RELIC_TRANSACTION_TRACER_EXPLAIN_THRESHOLD Threshold (in seconds) above which the agent will collect explain plans. Relevant only when explain_enabled is true. transaction_tracer.explain_enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_EXPLAIN_ENABLED If true, enables the collection of explain plans in transaction traces. This setting will also apply to explain plans in slow SQL traces if slow_sql.explain_enabled is not set separately. transaction_tracer.stack_trace_threshold Type Float Default 0.5 Environ variable NEW_RELIC_TRANSACTION_TRACER_STACK_TRACE_THRESHOLD Specify a threshold in seconds. The agent includes stack traces in transaction trace nodes when the stack trace duration exceeds this threshold. transaction_tracer.limit_segments Type Integer Default 4000 Environ variable NEW_RELIC_TRANSACTION_TRACER_LIMIT_SEGMENTS Maximum number of transaction trace nodes to record in a single transaction trace. Error Collector The agent collects and reports all uncaught exceptions by default. These configuration options allow you to customize the error collection. For information on ignored and expected errors, see this page on Error Analytics in APM. To set expected errors via the NewRelic::Agent.notice_error Ruby method, consult the Ruby Agent API. error_collector.enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ENABLED If true, the agent captures traced errors and error count metrics. error_collector.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_CAPTURE_ATTRIBUTES DEPRECATED Use error_collector.attributes.enabled instead. error_collector.ignore_errors Type String Default \"ActionController::RoutingError,Sinatra::NotFound\" Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERRORS DEPRECATED Use error_collector.ignore_classes instead. Specify a comma-delimited list of error classes that the agent should ignore. Caution Server side configuration takes precedence for this setting over all environment configurations. This differs from all other configuration settings where environment variable take precedence over server side configuration. error_collector.ignore_classes Type Array Default [] Environ variable None A list of error classes that the agent should ignore. Caution This option can't be set via environment variable. error_collector.ignore_messages Type Hash Default {} Environ variable None A map of error classes to a list of messages. When an error of one of the classes specified here occurs, if its error message contains one of the strings corresponding to it here, that error will be ignored. Caution This option can't be set via environment variable. error_collector.ignore_status_codes Type String Default \"\" Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_STATUS_CODES A comma separated list of status codes, possibly including ranges. Errors associated with these status codes, where applicable, will be ignored. error_collector.expected_classes Type Array Default [] Environ variable None A list of error classes that the agent should treat as expected. Caution This option can't be set via environment variable. error_collector.expected_messages Type Hash Default {} Environ variable None A map of error classes to a list of messages. When an error of one of the classes specified here occurs, if its error message contains one of the strings corresponding to it here, that error will be treated as expected. Caution This option can't be set via environment variable. error_collector.expected_status_codes Type String Default \"\" Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_STATUS_CODES A comma separated list of status codes, possibly including ranges. Errors associated with these status codes, where applicable, will be treated as expected. error_collector.max_backtrace_frames Type Integer Default 50 Environ variable NEW_RELIC_ERROR_COLLECTOR_MAX_BACKTRACE_FRAMES Defines the maximum number of frames in an error backtrace. Backtraces over this amount are truncated at the beginning and end. error_collector.capture_events Type Boolean Default (Dynamic) Environ variable NEW_RELIC_ERROR_COLLECTOR_CAPTURE_EVENTS If true, the agent collects TransactionError events. error_collector.max_event_samples_stored Type Integer Default 100 Environ variable NEW_RELIC_ERROR_COLLECTOR_MAX_EVENT_SAMPLES_STORED Defines the maximum number of TransactionError events sent to Insights per harvest cycle. Browser Monitoring The browser monitoring page load timing feature (sometimes referred to as real user monitoring or RUM) gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. browser_monitoring.auto_instrument Type Boolean Default (Dynamic) Environ variable NEW_RELIC_BROWSER_MONITORING_AUTO_INSTRUMENT If true, enables auto-injection of the JavaScript header for page load timing (sometimes referred to as real user monitoring or RUM). browser_monitoring.capture_attributes Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITORING_CAPTURE_ATTRIBUTES DEPRECATED Use browser_monitoring.attributes.enabled instead. Analytics Events New Relic dashboards is a resource to gather and visualize data about your software and what it says about your business. With it you can quickly and easily create real-time dashboards to get immediate answers about end-user experiences, clickstreams, mobile activities, and server transactions. analytics_events.enabled Type Boolean Default true Environ variable NEW_RELIC_ANALYTICS_EVENTS_ENABLED If true, enables analytics event sampling. analytics_events.max_samples_stored Type Integer Default 1200 Environ variable NEW_RELIC_ANALYTICS_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of request events reported from a single harvest. analytics_events.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_ANALYTICS_EVENTS_CAPTURE_ATTRIBUTES DEPRECATED Use transaction_events.attributes.enabled instead. Attributes Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_ENABLED If true, enables capture of attributes for all destinations. transaction_tracer.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction traces. transaction_events.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction events. error_collector.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_ENABLED If true, the agent captures attributes from error collection. browser_monitoring.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_ENABLED If true, the agent captures attributes from browser monitoring. span_events.attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes on span events. transaction_segments.attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes on transaction segments. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from all destinations. Allows * as wildcard at end. transaction_tracer.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction traces. Allows * as wildcard at end. transaction_events.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction events. Allows * as wildcard at end. error_collector.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from error collection. Allows * as wildcard at end. browser_monitoring.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from browser monitoring. Allows * as wildcard at end. span_events.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from span events. Allows * as wildcard at end. transaction_segments.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction segments. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE Prefix of attributes to include in all destinations. Allows * as wildcard at end. transaction_tracer.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction traces. Allows * as wildcard at end. transaction_events.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction events. Allows * as wildcard at end. error_collector.attributes.include Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_INCLUDE Prefix of attributes to include in error collection. Allows * as wildcard at end. browser_monitoring.attributes.include Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_INCLUDE Prefix of attributes to include in browser monitoring. Allows * as wildcard at end. span_events.attributes.include Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include on span events. Allows * as wildcard at end. transaction_segments.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include on transaction segments. Allows * as wildcard at end. Audit Log audit_log.enabled Type Boolean Default false Environ variable NEW_RELIC_AUDIT_LOG_ENABLED If true, enables an audit log which logs communications with the New Relic collector. audit_log.path Type String Default (Dynamic) Environ variable NEW_RELIC_AUDIT_LOG_PATH Specifies a path to the audit log file (including the filename). audit_log.endpoints Type Array Default [\".*\"] Environ variable NEW_RELIC_AUDIT_LOG_ENDPOINTS List of allowed endpoints to include in audit log Autostart autostart.denylisted_constants Type String Default \"Rails::Console\" Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_CONSTANTS Specify a list of constants that should prevent the agent from starting automatically. Separate individual constants with a comma ,. For example, Rails::Console,UninstrumentedBackgroundJob. autostart.denylisted_executables Type String Default \"irb,rspec\" Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_EXECUTABLES Defines a comma-delimited list of executables that the agent should not instrument. For example, rake,my_ruby_script.rb. autostart.denylisted_rake_tasks Type String Default Copy Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_RAKE_TASKS Defines a comma-delimited list of Rake tasks that the agent should not instrument. For example, assets:precompile,db:migrate. Cross Application Tracer cross_application_tracer.enabled Type Boolean Default false Environ variable NEW_RELIC_CROSS_APPLICATION_TRACER_ENABLED DEPRECATED Please see: distributed_tracing-enabled. If true, enables cross-application tracing when distributed_tracing.enabled is set to false. Custom Attributes custom_attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_CUSTOM_ATTRIBUTES_ENABLED If false, custom attributes will not be sent on Insights events. Custom Insights Events custom_insights_events.enabled Type Boolean Default true Environ variable NEW_RELIC_CUSTOM_INSIGHTS_EVENTS_ENABLED If true, the agent captures New Relic Insights custom events. custom_insights_events.max_samples_stored Type Integer Default 1000 Environ variable NEW_RELIC_CUSTOM_INSIGHTS_EVENTS_MAX_SAMPLES_STORED Specify a maximum number of custom Insights events to buffer in memory at a time. Disabling Use these settings to toggle instrumentation types during agent startup. disable_rake Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RAKE DEPRECATED Please see: instrumentation.rake. If true, disables Rake instrumentation. disable_samplers Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SAMPLERS If true, disables the collection of sampler metrics. Sampler metrics are metrics that are not event-based (such as CPU time or memory usage). disable_resque Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RESQUE DEPRECATED Please see: instrumentation.resque. If true, disables Resque instrumentation. disable_sidekiq Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SIDEKIQ If true, disables Sidekiq instrumentation. disable_dj Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DJ DEPRECATED Please see: instrumentation.delayed_job. If true, disables Delayed::Job instrumentation. disable_sinatra Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SINATRA DEPRECATED Please see: instrumentation.sinatra. If true , disables Sinatra instrumentation. disable_sinatra_auto_middleware Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SINATRA_AUTO_MIDDLEWARE If true, disables agent middleware for Sinatra. This middleware is responsible for advanced feature support such as cross application tracing, page load timing, and error collection. Important Cross application tracing is deprecated in favor of distributed tracing. Distributed tracing is on by default for Ruby agent versions 8.0.0 and above. Middlewares are not required to support distributed tracing. To continue using cross application tracing, update the following options in your newrelic.yml configuration file: # newrelic.yml cross_application_tracer: enabled: true distributed_tracing: enabled: false Copy disable_view_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_VIEW_INSTRUMENTATION If true, disables view instrumentation. disable_activerecord_instrumentation Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_ACTIVERECORD_INSTRUMENTATION If true, disables active record instrumentation. disable_data_mapper Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DATA_MAPPER If true, disables DataMapper instrumentation. disable_activejob Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVEJOB If true, disables ActiveJob instrumentation. disable_action_cable_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTION_CABLE_INSTRUMENTATION If true, disables Action Cable instrumentation. disable_active_storage Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVE_STORAGE If true, disables ActiveStorage instrumentation. disable_memcached Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_MEMCACHED DEPRECATED Please see: instrumentation.memcached. If true, disables instrumentation for the memcached gem. disable_memcache_client Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_MEMCACHE_CLIENT DEPRECATED Please see: instrumentation.memcache-client. If true, disables instrumentation for the memcache-client gem. disable_dalli Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_DALLI DEPRECATED Please see: instrumentation.memcache. If true, disables instrumentation for the dalli gem. disable_dalli_cas_client Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_DALLI_CAS_CLIENT DEPRECATED Please see: instrumentation.memcache. If true, disables instrumentation for the dalli gem's additional CAS client support. disable_memcache_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MEMCACHE_INSTRUMENTATION DEPRECATED Please see: instrumentation.memcache. If true, disables memcache instrumentation. disable_gc_profiler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_GC_PROFILER If true, disables the use of GC::Profiler to measure time spent in garbage collection disable_sequel_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SEQUEL_INSTRUMENTATION If true, disables Sequel instrumentation. disable_database_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DATABASE_INSTRUMENTATION DEPRECATED Use disable_sequel_instrumentation instead. disable_mongo Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MONGO DEPRECATED Please see: instrumentation.mongo. If true, the agent won't install instrumentation for the Mongo gem. disable_redis Type Boolean Default false Environ variable NEW_RELIC_DISABLE_REDIS DEPRECATED Please see: instrumentation.redis. If true, the agent won't install instrumentation for Redis. disable_vm_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_VM_SAMPLER If true, the agent won't sample performance measurements from the Ruby VM. disable_memory_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MEMORY_SAMPLER If true, the agent won't sample the memory usage of the host process. disable_cpu_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_CPU_SAMPLER If true, the agent won't sample the CPU usage of the host process. disable_delayed_job_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DELAYED_JOB_SAMPLER If true, the agent won't measure the depth of Delayed Job queues. disable_active_record_notifications Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVE_RECORD_NOTIFICATIONS If true, disables instrumentation for ActiveRecord 4, 5, and 6. disable_bunny Type Boolean Default false Environ variable NEW_RELIC_DISABLE_BUNNY DEPRECATED Please see: instrumentation.bunny. If true, disables instrumentation for the bunny gem. disable_curb Type Boolean Default false Environ variable NEW_RELIC_DISABLE_CURB DEPRECATED Please see: instrumentation.curb. If true, disables instrumentation for the curb gem. disable_excon Type Boolean Default false Environ variable NEW_RELIC_DISABLE_EXCON DEPRECATED Please see: instrumentation.excon. If true, disables instrumentation for the excon gem. disable_httpclient Type Boolean Default false Environ variable NEW_RELIC_DISABLE_HTTPCLIENT DEPRECATED Please see: instrumentation.httpclient. If true, disables instrumentation for the httpclient gem. disable_net_http Type Boolean Default false Environ variable NEW_RELIC_DISABLE_NET_HTTP DEPRECATED Please see: instrumentation.net_http. If true, disables instrumentation for Net::HTTP. disable_rack Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RACK DEPRECATED Please see: instrumentation.rack. If true, prevents the agent from hooking into the to_app method in Rack::Builder to find gems to instrument during application startup. disable_rack_urlmap Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RACK_URLMAP DEPRECATED Please see: instrumentation.rack_urlmap. If true, prevents the agent from hooking into Rack::URLMap to install middleware tracing. disable_puma_rack Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_PUMA_RACK DEPRECATED Please see: instrumentation.puma_rack. If true, prevents the agent from hooking into the to_app method in Puma::Rack::Builder to find gems to instrument during application startup. disable_puma_rack_urlmap Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_PUMA_RACK_URLMAP DEPRECATED Please see: instrumentation.puma_rack_urlmap. If true, prevents the agent from hooking into Puma::Rack::URLMap to install middleware tracing. disable_typhoeus Type Boolean Default false Environ variable NEW_RELIC_DISABLE_TYPHOEUS DEPRECATED Please see: instrumentation.typhoeus. If true, the agent won't install instrumentation for the typhoeus gem. disable_httprb Type Boolean Default false Environ variable NEW_RELIC_DISABLE_HTTPRB DEPRECATED Please see: instrumentation.httprb. If true, the agent won't install instrumentation for the http.rb gem. disable_middleware_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MIDDLEWARE_INSTRUMENTATION If true, the agent won't wrap third-party middlewares in instrumentation (regardless of whether they are installed via Rack::Builder or Rails). disable_grape Type Boolean Default false Environ variable NEW_RELIC_DISABLE_GRAPE DEPRECATED Please see: instrumentation.grape. If true, the agent won't install Grape instrumentation. Distributed Tracing distributed_tracing.enabled Type Boolean Default true Environ variable NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Distributed tracing lets you see the path that a request takes through your distributed system. Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition guide before you enable this feature. Heroku heroku.use_dyno_names Type Boolean Default true Environ variable NEW_RELIC_HEROKU_USE_DYNO_NAMES If true, the agent uses Heroku dyno names as the hostname. heroku.dyno_name_prefixes_to_shorten Type Array Default [\"scheduler\", \"run\"] Environ variable NEW_RELIC_HEROKU_DYNO_NAME_PREFIXES_TO_SHORTEN Ordinarily the agent reports dyno names with a trailing dot and process ID (for example, worker.3). You can remove this trailing data by specifying the prefixes you want to report without trailing data (for example, worker). Instrumentation instrumentation.net_http Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_NET_HTTP Controls auto-instrumentation of Net::HTTP at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.typhoeus Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_TYPHOEUS Controls auto-instrumentation of Typhoeus at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.bunny Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_BUNNY Controls auto-instrumentation of bunny at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.httprb Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_HTTPRB Controls auto-instrumentation of http.rb gem at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.resque Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RESQUE Controls auto-instrumentation of resque at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.redis Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_REDIS Controls auto-instrumentation of Redis at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.rake Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RAKE Controls auto-instrumentation of rake at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.mongo Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MONGO Controls auto-instrumentation of Mongo at start up. May be one of [enabled|disabled] . instrumentation.delayed_job Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_DELAYED_JOB Controls auto-instrumentation of Delayed Job at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.httpclient Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_HTTPCLIENT Controls auto-instrumentation of HTTPClient at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.curb Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_CURB Controls auto-instrumentation of Curb at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.sinatra Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_SINATRA Controls auto-instrumentation of Sinatra at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.rack Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RACK Controls auto-instrumentation of Rack. When enabled, the agent hooks into the to_app method in Rack::Builder to find gems to instrument during application startup. May be one of [auto|prepend|chain|disabled] . instrumentation.rack_urlmap Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RACK_URLMAP Controls auto-instrumentation of Rack::URLMap at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.puma_rack Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_PUMA_RACK Controls auto-instrumentation of Puma::Rack. When enabled, the agent hooks into the to_app method in Puma::Rack::Builder to find gems to instrument during application startup. May be one of [auto|prepend|chain|disabled] . instrumentation.puma_rack_urlmap Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_PUMA_RACK_URLMAP Controls auto-instrumentation of Puma::Rack::URLMap at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcached Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHED Controls auto-instrumentation of memcached gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcache_client Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHE_CLIENT Controls auto-instrumentation of memcache-client gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcache Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHE Controls auto-instrumentation of dalli gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.logger Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_LOGGER Controls auto-instrumentation of Ruby standard library Logger at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.excon Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_EXCON Controls auto-instrumentation of Excon at start up. May be one of [enabled|disabled] . instrumentation.grape Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_GRAPE Controls auto-instrumentation of Grape at start up. May be one of [auto|prepend|chain|disabled] . Mongo mongo.capture_queries Type Boolean Default true Environ variable NEW_RELIC_MONGO_CAPTURE_QUERIES If true, the agent captures Mongo queries in transaction traces. mongo.obfuscate_queries Type Boolean Default true Environ variable NEW_RELIC_MONGO_OBFUSCATE_QUERIES If true, the agent obfuscates Mongo queries in transaction traces. Process Host process_host.display_name Type String Default (Dynamic) Environ variable NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Specify a custom host name for display in the New Relic UI. Rake rake.tasks Type Array Default [] Environ variable NEW_RELIC_RAKE_TASKS Specify an array of Rake tasks to automatically instrument. rake.connect_timeout Type Integer Default 10 Environ variable NEW_RELIC_RAKE_CONNECT_TIMEOUT Timeout for waiting on connect to complete before a rake task Resque resque.capture_params Type Boolean Default false Environ variable NEW_RELIC_RESQUE_CAPTURE_PARAMS DEPRECATED If true, enables the capture of job arguments for transaction traces and traced errors in Resque. Rules rules.ignore_url_regexes Type Array Default [] Environ variable NEW_RELIC_RULES_IGNORE_URL_REGEXES Define transactions you want the agent to ignore, by specifying a list of patterns matching the URI you want to ignore. Note: This will only ignore transaction events, not spans or traces from the same transation. See documentation on (ignoring specific transactions) [https://docs.newrelic.com/docs/agents/ruby-agent/api-guides/ignoring-specific-transactions/#config-ignoring] for more details. Sidekiq sidekiq.capture_params Type Boolean Default false Environ variable NEW_RELIC_SIDEKIQ_CAPTURE_PARAMS DEPRECATED If true, enables the capture of job arguments for transaction traces and traced errors in Sidekiq. Slow SQL slow_sql.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_ENABLED If true, the agent collects slow SQL queries. slow_sql.explain_threshold Type Float Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_EXPLAIN_THRESHOLD Specify a threshold in seconds. The agent collects slow SQL queries and explain plans that exceed this threshold. slow_sql.explain_enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_EXPLAIN_ENABLED If true, the agent collects explain plans in slow SQL queries. If this setting is omitted, the transaction_tracer.explain_enabled setting will be applied as the default setting for explain plans in slow SQL as well. slow_sql.record_sql Type String Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_RECORD_SQL Defines an obfuscation level for slow SQL queries. Valid options are obfuscated, raw, or none). slow_sql.use_longer_sql_id Type Boolean Default false Environ variable NEW_RELIC_SLOW_SQL_USE_LONGER_SQL_ID Generate a longer sql_id for slow SQL traces. sql_id is used for aggregation of similar queries. Span Events span_events.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ENABLED If true, enables span event sampling. span_events.queue_size Type Integer Default 10000 Environ variable NEW_RELIC_SPAN_EVENTS_QUEUE_SIZE Sets the maximum number of span events to buffer when streaming to the trace observer. span_events.max_samples_stored Type Integer Default 2000 Environ variable NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of span events reported from a single harvest. Strip Exception Messages strip_exception_messages.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_STRIP_EXCEPTION_MESSAGES_ENABLED If true, the agent strips messages from all exceptions except those in the allowlist. Enabled automatically in high security mode. strip_exception_messages.allowed_classes Type String Default \"\" Environ variable NEW_RELIC_STRIP_EXCEPTION_MESSAGES_ALLOWED_CLASSES Specify a list of exceptions you do not want the agent to strip when strip_exception_messages is true. Separate exceptions with a comma. For example, \"ImportantException,PreserveMessageException\". Thread Profiler thread_profiler.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_THREAD_PROFILER_ENABLED If true, enables use of the thread profiler. Utilization utilization.detect_aws Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_AWS If true, the agent automatically detects that it is running in an AWS environment. utilization.detect_azure Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_AZURE If true, the agent automatically detects that it is running in an Azure environment. utilization.detect_gcp Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_GCP If true, the agent automatically detects that it is running in an Google Cloud Platform environment. utilization.detect_pcf Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_PCF If true, the agent automatically detects that it is running in a Pivotal Cloud Foundry environment. utilization.detect_docker Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_DOCKER If true, the agent automatically detects that it is running in Docker. utilization.detect_kubernetes Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_KUBERNETES If true, the agent automatically detects that it is running in Kubernetes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.410645,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Ruby <em>agent</em> <em>configuration</em>",
        "sections": "Ruby <em>agent</em> <em>configuration</em>",
        "tags": "<em>Agents</em>",
        "body": "You can configure the New Relic Ruby <em>agent</em> with settings in a <em>configuration</em> file, environment variables, or programmatically with server-side <em>configuration</em>. This document summarizes the <em>configuration</em> options available for the Ruby <em>agent</em>. If the default value for a <em>configuration</em> option is (Dynamic"
      },
      "id": "603eb6f4e7b9d22a5f2f7c73"
    }
  ],
  "/docs/agents/java-agent/configuration/java-agent-config-file-template": [
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "event_ingest_uri",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "metric_ingest_uri",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "JFR (Real-time profiling)",
        "audit_logging",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignoreErrorPriority",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-10-19T05:54:03Z",
      "updated_at": "2021-09-20T19:27:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. event_ingest_uri Type String Default https://insights-collector.newrelic.com/v1/accounts/events Event ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send events to other ingest endpoints (for example, EU production: https://insights-collector.eu01.nr-data.net/v1/accounts/events). extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is not currently used by the agent. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. metric_ingest_uri Type String Default https://metric-api.newrelic.com/metric/v1 Metric ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send metrics to other ingest endpoints (for example EU production: https://metric-api.eu.newrelic.com/metric/v1). proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default false Whether errors are reported for Reactor Netty. Default is false. If set to true, Reactor Netty errors will be reported. Important Only available in Java agent 6.3.0 and above. Notice, default was changed to false as of Java agent 6.5.0. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transactions total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data. Additionally the agent can expose linking metadata over JMX that can be used by other tracing systems. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata over remote JMX. Important This applies to Java agent version 6.1.0 or higher. JFR (Real-time profiling) The Java agent uses Java Flight Recorder (JFR) to collect high fidelity JVM data for Real-time profiling. Real-time profiling can be configured in the jfr stanza in the agent yaml, with system properties prefixed by newrelic.config.jfr., or with environment variables prefixed with NEW_RELIC_JFR_. enabled Type Boolean Default false Set to true to enable Real-time profiling with JFR. Important Real-time profiling with JFR is on by default in Java agent version 7.1.0. If you are on any other agent version 7.0.0 or higher, you can turn on JFR by changing the value to true. audit_logging Type Boolean Default false Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. Audit logging is extremely verbose and should only be used for troubleshooting purposes. Important This applies to Java agent version 7.0.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list exception class names you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy An environment variable can be used to list exception class names and messages you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list expected exception class names: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\" Copy An environment variable can be used to list expected exception class names and messages: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignoreErrorPriority Type Boolean Default true When multiple errors are noticed in a transaction, only the last error will be reported by default. Setting this property to false will instead report only the first error that is noticed. For more information, see the noticeError API. For example: error_collector: ignoreErrorPriority: false Copy ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messagesprefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings  OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.35988,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "sections": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> reads its <em>configuration</em> from the newrelic.yml file. By default the <em>agent</em> looks for this file in the directory that contains newrelic.jar. You can override the config file&#x27;s location by setting the newrelic.config.file system property to a fully qualified file name"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Hostname logic in Java",
        "Display names",
        "Tip",
        "Instance names",
        "Hostname logic precedence",
        "Hosts and unique agent identifiers",
        "For more help"
      ],
      "title": "Hostname logic in Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "32a9b875cf20d27be147a4ca29b749f1612d94e2",
      "image": "https://docs.newrelic.com/static/026e7b6f7910842deb3f7c1960cad008/9e32a/upload.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/hostname-logic-java/",
      "published_at": "2021-10-18T05:35:39Z",
      "updated_at": "2021-09-14T09:17:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Java agent automatically assigns a host:port name to your JVMs. If the default name is not useful, you can set a display name to distinguish your JVMs in the New Relic UI. For supported frameworks, the Java agent uses the instance name instead of the display name. The Java agent uniquely identifies running agents by their host, port, and dispatcher, regardless of the environment used. Display names If the default host:port label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. Set the display name via configuration, either in an environment variable or in your newrelic.yml config file. The environment variable takes precedence over the config file value. After the JVM is restarted and the Java agent is reporting again , the display name will show in the JVM list as seen in the example below in addition to host:port. To set a display name: Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable. OR Set process_host.display_name in your newrelic.yml. Restart your JVM to see your changes in the New Relic UI. Tip You can also set the display name with a system property. Instance names For WebSphere and WebLogic users, the Java agent also reports the instance name for each active app server instance, which is visible in the APM Settings > Environment page. Generally, this name is provided by the app server. If an instance name is set, it will be used instead of the display name in the New Relic UI. Hostname logic precedence If there are multiple hostname settings (for example, you use WebSphere and also set the display_name property), the agent uses this precedence: display_name overrides the default name, and the WebSphere and WebLogic instance names. WebSphere and WebLogic instance names override the default name. The default (host:port) name has lowest precedence. Hosts and unique agent identifiers The Java agent uses hosts, ports, and dispatchers to uniquely identify multiple JVMs reporting to the same app name. Multiple agents running on the same server are therefore reported separately, as long as their ports or dispatcher names differ. The unique identifier is based on the following values: Host: An identifier for your app's parent server that is derived from the Operating System. This value is not configurable by the Java agent. Port: The port associated with the app server. If the agent can't determine the port number, or your app is not running in an app server, defaults to 0. This value is user-configurable. Dispatcher Name: The name of the app server. For example, Apache Tomcat, Glassfish, or WebLogic. If there is no active app server, defaults to Unknown. For more help Additional documentation resources include: Setting the hostname reported by the Java agent (manually overriding the hostname settings when the link between your APM app and Servers for Linux is broken) Add, rename, and remove hosts (add and remove hosts in APM)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.90364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Hostname logic in <em>Java</em>",
        "sections": "Hostname logic in <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " name. The default (host:port) name has lowest precedence. Hosts and unique <em>agent</em> identifiers The <em>Java</em> <em>agent</em> uses hosts, ports, and dispatchers to uniquely identify multiple JVMs reporting to the same app name. Multiple <em>agents</em> running on the same server are therefore reported separately, as long"
      },
      "id": "6043cfbb64441ff20b378f0b"
    },
    {
      "sections": [
        "Ruby agent configuration",
        "Configuration methods and precedence",
        "View and edit config file options",
        "Update the config file",
        "Important",
        "General",
        "license_key",
        "agent_enabled",
        "app_name",
        "monitor_mode",
        "log_level",
        "high_security",
        "security_policies_token",
        "proxy_host",
        "proxy_port",
        "proxy_user",
        "proxy_pass",
        "capture_params",
        "Caution",
        "config_path",
        "apdex_t",
        "sync_startup",
        "send_data_on_exit",
        "timeout",
        "force_install_exit_handler",
        "log_file_name",
        "log_file_path",
        "prepend_active_record_instrumentation",
        "capture_memcache_keys",
        "message_tracer.segment_parameters.enabled",
        "marshaller",
        "backport_fast_active_record_connection_lookup",
        "labels",
        "ca_bundle_path",
        "datastore_tracer.instance_reporting.enabled",
        "datastore_tracer.database_name_reporting.enabled",
        "clear_transaction_state_after_fork",
        "exclude_newrelic_header",
        "infinite_tracing.trace_observer.host",
        "infinite_tracing.trace_observer.port",
        "Transaction Tracer",
        "transaction_tracer.enabled",
        "transaction_tracer.transaction_threshold",
        "transaction_tracer.record_sql",
        "transaction_tracer.record_redis_arguments",
        "transaction_tracer.capture_attributes",
        "transaction_tracer.explain_threshold",
        "transaction_tracer.explain_enabled",
        "transaction_tracer.stack_trace_threshold",
        "transaction_tracer.limit_segments",
        "Error Collector",
        "error_collector.enabled",
        "error_collector.capture_attributes",
        "error_collector.ignore_errors",
        "error_collector.ignore_classes",
        "error_collector.ignore_messages",
        "error_collector.ignore_status_codes",
        "error_collector.expected_classes",
        "error_collector.expected_messages",
        "error_collector.expected_status_codes",
        "error_collector.max_backtrace_frames",
        "error_collector.capture_events",
        "error_collector.max_event_samples_stored",
        "Browser Monitoring",
        "browser_monitoring.auto_instrument",
        "browser_monitoring.capture_attributes",
        "Analytics Events",
        "analytics_events.enabled",
        "analytics_events.max_samples_stored",
        "analytics_events.capture_attributes",
        "Attributes",
        "attributes.enabled",
        "transaction_tracer.attributes.enabled",
        "transaction_events.attributes.enabled",
        "error_collector.attributes.enabled",
        "browser_monitoring.attributes.enabled",
        "span_events.attributes.enabled",
        "transaction_segments.attributes.enabled",
        "attributes.exclude",
        "transaction_tracer.attributes.exclude",
        "transaction_events.attributes.exclude",
        "error_collector.attributes.exclude",
        "browser_monitoring.attributes.exclude",
        "span_events.attributes.exclude",
        "transaction_segments.attributes.exclude",
        "attributes.include",
        "transaction_tracer.attributes.include",
        "transaction_events.attributes.include",
        "error_collector.attributes.include",
        "browser_monitoring.attributes.include",
        "span_events.attributes.include",
        "transaction_segments.attributes.include",
        "Audit Log",
        "audit_log.enabled",
        "audit_log.path",
        "audit_log.endpoints",
        "Autostart",
        "autostart.denylisted_constants",
        "autostart.denylisted_executables",
        "autostart.denylisted_rake_tasks",
        "Cross Application Tracer",
        "cross_application_tracer.enabled",
        "Custom Attributes",
        "custom_attributes.enabled",
        "Custom Insights Events",
        "custom_insights_events.enabled",
        "custom_insights_events.max_samples_stored",
        "Disabling",
        "disable_rake",
        "disable_samplers",
        "disable_resque",
        "disable_sidekiq",
        "disable_dj",
        "disable_sinatra",
        "disable_sinatra_auto_middleware",
        "disable_view_instrumentation",
        "disable_activerecord_instrumentation",
        "disable_data_mapper",
        "disable_activejob",
        "disable_action_cable_instrumentation",
        "disable_active_storage",
        "disable_memcached",
        "disable_memcache_client",
        "disable_dalli",
        "disable_dalli_cas_client",
        "disable_memcache_instrumentation",
        "disable_gc_profiler",
        "disable_sequel_instrumentation",
        "disable_database_instrumentation",
        "disable_mongo",
        "disable_redis",
        "disable_vm_sampler",
        "disable_memory_sampler",
        "disable_cpu_sampler",
        "disable_delayed_job_sampler",
        "disable_active_record_notifications",
        "disable_bunny",
        "disable_curb",
        "disable_excon",
        "disable_httpclient",
        "disable_net_http",
        "disable_rack",
        "disable_rack_urlmap",
        "disable_puma_rack",
        "disable_puma_rack_urlmap",
        "disable_typhoeus",
        "disable_httprb",
        "disable_middleware_instrumentation",
        "disable_grape",
        "Distributed Tracing",
        "distributed_tracing.enabled",
        "Heroku",
        "heroku.use_dyno_names",
        "heroku.dyno_name_prefixes_to_shorten",
        "Instrumentation",
        "instrumentation.net_http",
        "instrumentation.typhoeus",
        "instrumentation.bunny",
        "instrumentation.httprb",
        "instrumentation.resque",
        "instrumentation.redis",
        "instrumentation.rake",
        "instrumentation.mongo",
        "instrumentation.delayed_job",
        "instrumentation.httpclient",
        "instrumentation.curb",
        "instrumentation.sinatra",
        "instrumentation.rack",
        "instrumentation.rack_urlmap",
        "instrumentation.puma_rack",
        "instrumentation.puma_rack_urlmap",
        "instrumentation.memcached",
        "instrumentation.memcache_client",
        "instrumentation.memcache",
        "instrumentation.logger",
        "instrumentation.excon",
        "instrumentation.grape",
        "Mongo",
        "mongo.capture_queries",
        "mongo.obfuscate_queries",
        "Process Host",
        "process_host.display_name",
        "Rake",
        "rake.tasks",
        "rake.connect_timeout",
        "Resque",
        "resque.capture_params",
        "Rules",
        "rules.ignore_url_regexes",
        "Sidekiq",
        "sidekiq.capture_params",
        "Slow SQL",
        "slow_sql.enabled",
        "slow_sql.explain_threshold",
        "slow_sql.explain_enabled",
        "slow_sql.record_sql",
        "slow_sql.use_longer_sql_id",
        "Span Events",
        "span_events.enabled",
        "span_events.queue_size",
        "span_events.max_samples_stored",
        "Strip Exception Messages",
        "strip_exception_messages.enabled",
        "strip_exception_messages.allowed_classes",
        "Thread Profiler",
        "thread_profiler.enabled",
        "Utilization",
        "utilization.detect_aws",
        "utilization.detect_azure",
        "utilization.detect_gcp",
        "utilization.detect_pcf",
        "utilization.detect_docker",
        "utilization.detect_kubernetes"
      ],
      "title": "Ruby agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Configuration"
      ],
      "external_id": "ee72f1c59d456c5e5a089cfa81bfbde6064d7cb0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/configuration/ruby-agent-configuration/",
      "published_at": "2021-10-19T03:52:40Z",
      "updated_at": "2021-10-19T03:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can configure the New Relic Ruby agent with settings in a configuration file, environment variables, or programmatically with server-side configuration. This document summarizes the configuration options available for the Ruby agent. If the default value for a configuration option is (Dynamic), this means the Ruby agent calculates the default at runtime. The value for the config setting defaults to the value of another setting as appropriate. Configuration methods and precedence The primary (default) method to configure the Ruby agent is via the configuration file (newrelic.yml) in the config subdirectory. To set configuration values using environment variables: Add the prefix NEW_RELIC_ to the setting's name. Replace any periods . with underscores _. You can also configure a few values in the UI via server-side configuration. The Ruby agent follows this order of precedence for configuration: Environment variables Server-side configuration Configuration file (newrelic.yml) Default configuration settings In other words, environment variables override all other configuration settings and info, server-side configuration overrides the configuration file and default config settings, and so on. View and edit config file options The Ruby agent's newrelic.yml is a standard YAML configuration file. It typically includes a Defaults section at the top, plus sections below for each application environment; for example, Development, Testing, and Production. The Ruby agent determines which section of the newrelic.yml config file to read from by looking at certain environment variables to derive the application's environment. This can be useful, for example, when you want to use info for the log_level config setting in your production environment, and you want more verbose log_level config settings (such as debug in your development environment. Here is an example newrelic.yml config file: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'My Application Name' production: <<: *default_settings log_level: info development: <<: *default_settings log_level: debug Copy For non-Rails apps, the Ruby agent looks for the following environment variables, in this order, to determine the application environment: NEW_RELIC_ENV RUBY_ENV RAILS_ENV APP_ENV RACK_ENV If the Ruby agent does not detect values for any of those environment variables, it will default the application environment to development and read from the development section of the newrelic.yml config file. When running the Ruby agent in a Rails app, the agent first looks for the NEW_RELIC_ENV environment variable to determine the application environment and which section of the newrelic.yml to use. If NEW_RELIC_ENV is not present, the agent uses the Rails environment (RAILS_ENV or RAILS.env, depending on the version of Rails) . When you edit the config file, be sure to: Indent only with two spaces. Indent only where relevant, in stanzas such as error_collector. If you do not indent correctly, the agent may throw an Unable to parse configuration file error on startup. To view the most current list of available Ruby agent configuration options, use the rake newrelic:config:docs command. This document describes the most common options. Update the config file This documentation applies to the Ruby agent's latest release. For details on earlier versions, refer to the comments in newrelic.yml itself. To update newrelic.yml file after a new release, use the template in the base directory of the agent gem. When you update to new gem versions, examine or diff config/newrelic.yml and newrelic.yml in the installation directory to take advantage of new configuration options. Important Updating the gem does not automatically update config/newrelic.yml. General These settings are available for agent configuration. Some settings depend on your New Relic subscription level. license_key Type String Default \"\" Environ variable NEW_RELIC_LICENSE_KEY Your New Relic license key. agent_enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_AGENT_ENABLED If true, allows the Ruby agent to run. app_name Type String Default (Dynamic) Environ variable NEW_RELIC_APP_NAME Specify the application name used to aggregate data in the New Relic UI. To report data to multiple apps at the same time, specify a list of names separated by a semicolon ;. For example, MyApp or MyStagingApp;Instance1. monitor_mode Type Boolean Default (Dynamic) Environ variable NEW_RELIC_MONITOR_MODE When true, the agent transmits data about your app to the New Relic collector. log_level Type String Default \"info\" Environ variable NEW_RELIC_LOG_LEVEL Sets the level of detail of log messages. Possible log levels, in increasing verbosity, are: error, warn, info or debug. high_security Type Boolean Default false Environ variable NEW_RELIC_HIGH_SECURITY If true, enables high security mode. Ensure you understand the implications of high security mode before enabling this setting. security_policies_token Type String Default \"\" Environ variable NEW_RELIC_SECURITY_POLICIES_TOKEN Applies Language Agent Security Policy settings. proxy_host Type String Default nil Environ variable NEW_RELIC_PROXY_HOST Defines a host for communicating with the New Relic collector via a proxy server. proxy_port Type Integer Default 8080 Environ variable NEW_RELIC_PROXY_PORT Defines a port for communicating with the New Relic collector via a proxy server. proxy_user Type String Default nil Environ variable NEW_RELIC_PROXY_USER Defines a user for communicating with the New Relic collector via a proxy server. proxy_pass Type String Default nil Environ variable NEW_RELIC_PROXY_PASS Defines a password for communicating with the New Relic collector via a proxy server. capture_params Type Boolean Default false Environ variable NEW_RELIC_CAPTURE_PARAMS When true, the agent captures HTTP request parameters and attaches them to transaction traces, traced errors, and TransactionError events. Caution When using the capture_params setting, the Ruby agent will not attempt to filter secret information. Recommendation: To filter secret information from request parameters, use the attributes.include setting instead. For more information, see the Ruby attribute examples. config_path Type String Default (Dynamic) Environ variable NEW_RELIC_CONFIG_PATH Path to newrelic.yml. If undefined, the agent checks the following directories (in order): config/newrelic.yml, newrelic.yml, $HOME/.newrelic/newrelic.yml and $HOME/newrelic.yml. apdex_t Type Float Default 0.5 Environ variable NEW_RELIC_APDEX_T DEPRECATED For agent versions 3.5.0 or higher, set your Apdex T via the New Relic UI. sync_startup Type Boolean Default false Environ variable NEW_RELIC_SYNC_STARTUP When set to true, forces a synchronous connection to the New Relic collector during application startup. For very short-lived processes, this helps ensure the New Relic agent has time to report. send_data_on_exit Type Boolean Default true Environ variable NEW_RELIC_SEND_DATA_ON_EXIT If true, enables the exit handler that sends data to the New Relic collector before shutting down. timeout Type Integer Default 120 Environ variable NEW_RELIC_TIMEOUT Defines the maximum number of seconds the agent should spend attempting to connect to the collector. force_install_exit_handler Type Boolean Default false Environ variable NEW_RELIC_FORCE_INSTALL_EXIT_HANDLER Forces the exit handler that sends all cached data to collector before shutting down to be installed regardless of detecting scenarios where it generally should not be. Known use-case for this option is where Sinatra is running as an embedded service within another framework and the agent is detecting the Sinatra app and skipping the at_exit handler as a result. Sinatra classically runs the entire application in an at_exit block and would otherwise misbehave if the Agent's at_exit handler was also installed in those circumstances. Note: send_data_on_exit should also be set to true in tandem with this setting. log_file_name Type String Default \"newrelic_agent.log\" Environ variable NEW_RELIC_LOG_FILE_NAME Defines a name for the log file. log_file_path Type String Default \"log/\" Environ variable NEW_RELIC_LOG_FILE_PATH Defines a path to the agent log file, excluding the filename. prepend_active_record_instrumentation Type Boolean Default false Environ variable NEW_RELIC_PREPEND_ACTIVE_RECORD_INSTRUMENTATION If true, uses Module#prepend rather than alias_method for ActiveRecord instrumentation. capture_memcache_keys Type Boolean Default false Environ variable NEW_RELIC_CAPTURE_MEMCACHE_KEYS Enable or disable the capture of memcache keys from transaction traces. message_tracer.segment_parameters.enabled Type Boolean Default true Environ variable NEW_RELIC_MESSAGE_TRACER_SEGMENT_PARAMETERS_ENABLED If true, the agent will collect metadata about messages and attach them as segment parameters. marshaller Type String Default \"json\" Environ variable NEW_RELIC_MARSHALLER Specifies a marshaller for transmitting data to the New Relic collector. Currently json is the only valid value for this setting. backport_fast_active_record_connection_lookup Type Boolean Default false Environ variable NEW_RELIC_BACKPORT_FAST_ACTIVE_RECORD_CONNECTION_LOOKUP Backports the faster ActiveRecord connection lookup introduced in Rails 6, which improves agent performance when instrumenting ActiveRecord. Note that this setting may not be compatible with other gems that patch ActiveRecord. labels Type String Default \"\" Environ variable NEW_RELIC_LABELS A dictionary of label names and values that will be applied to the data sent from this agent. May also be expressed as a semicolon-delimited ; string of colon-separated : pairs. For example, <var>Server</var>:<var>One</var>;<var>Data Center</var>:<var>Primary</var>. ca_bundle_path Type String Default nil Environ variable NEW_RELIC_CA_BUNDLE_PATH Manual override for the path to your local CA bundle. This CA bundle will be used to validate the SSL certificate presented by New Relic's data collection service. datastore_tracer.instance_reporting.enabled Type Boolean Default true Environ variable NEW_RELIC_DATASTORE_TRACER_INSTANCE_REPORTING_ENABLED If false, the agent will not report datastore instance metrics, nor add host or port_path_or_id parameters to transaction or slow SQL traces. datastore_tracer.database_name_reporting.enabled Type Boolean Default true Environ variable NEW_RELIC_DATASTORE_TRACER_DATABASE_NAME_REPORTING_ENABLED If false, the agent will not add database_name parameter to transaction or slow sql traces. clear_transaction_state_after_fork Type Boolean Default false Environ variable NEW_RELIC_CLEAR_TRANSACTION_STATE_AFTER_FORK If true, the agent will clear Tracer::State in Agent.drop_buffered_data. exclude_newrelic_header Type Boolean Default false Environ variable NEW_RELIC_EXCLUDE_NEWRELIC_HEADER Allows newrelic distributed tracing headers to be suppressed on outbound requests. infinite_tracing.trace_observer.host Type String Default \"\" Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST Configures the hostname for the Trace Observer Host. When configured, enables tail-based sampling by sending all recorded spans to a Trace Observer for further sampling decisions, irrespective of any usual agent sampling decision. infinite_tracing.trace_observer.port Type Integer Default 443 Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_PORT Configures the TCP/IP port for the Trace Observer Host Transaction Tracer The transaction traces feature collects detailed information from a selection of transactions, including a summary of the calling sequence, a breakdown of time spent, and a list of SQL queries and their query plans (on mysql and postgresql). Available features depend on your New Relic subscription level. transaction_tracer.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_ENABLED If true, enables collection of transaction traces. transaction_tracer.transaction_threshold Type Float Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_TRACER_TRANSACTION_THRESHOLD Specify a threshold in seconds. Transactions with a duration longer than this threshold are eligible for transaction traces. Specify a float value or the string apdex_f. transaction_tracer.record_sql Type String Default \"obfuscated\" Environ variable NEW_RELIC_TRANSACTION_TRACER_RECORD_SQL Obfuscation level for SQL queries reported in transaction trace nodes. By default, this is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to none. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. transaction_tracer.record_redis_arguments Type Boolean Default false Environ variable NEW_RELIC_TRANSACTION_TRACER_RECORD_REDIS_ARGUMENTS If true, the agent records Redis command arguments in transaction traces. transaction_tracer.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_CAPTURE_ATTRIBUTES DEPRECATED Use transaction_tracer.attributes.enabled instead. transaction_tracer.explain_threshold Type Float Default 0.5 Environ variable NEW_RELIC_TRANSACTION_TRACER_EXPLAIN_THRESHOLD Threshold (in seconds) above which the agent will collect explain plans. Relevant only when explain_enabled is true. transaction_tracer.explain_enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_EXPLAIN_ENABLED If true, enables the collection of explain plans in transaction traces. This setting will also apply to explain plans in slow SQL traces if slow_sql.explain_enabled is not set separately. transaction_tracer.stack_trace_threshold Type Float Default 0.5 Environ variable NEW_RELIC_TRANSACTION_TRACER_STACK_TRACE_THRESHOLD Specify a threshold in seconds. The agent includes stack traces in transaction trace nodes when the stack trace duration exceeds this threshold. transaction_tracer.limit_segments Type Integer Default 4000 Environ variable NEW_RELIC_TRANSACTION_TRACER_LIMIT_SEGMENTS Maximum number of transaction trace nodes to record in a single transaction trace. Error Collector The agent collects and reports all uncaught exceptions by default. These configuration options allow you to customize the error collection. For information on ignored and expected errors, see this page on Error Analytics in APM. To set expected errors via the NewRelic::Agent.notice_error Ruby method, consult the Ruby Agent API. error_collector.enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ENABLED If true, the agent captures traced errors and error count metrics. error_collector.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_CAPTURE_ATTRIBUTES DEPRECATED Use error_collector.attributes.enabled instead. error_collector.ignore_errors Type String Default \"ActionController::RoutingError,Sinatra::NotFound\" Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERRORS DEPRECATED Use error_collector.ignore_classes instead. Specify a comma-delimited list of error classes that the agent should ignore. Caution Server side configuration takes precedence for this setting over all environment configurations. This differs from all other configuration settings where environment variable take precedence over server side configuration. error_collector.ignore_classes Type Array Default [] Environ variable None A list of error classes that the agent should ignore. Caution This option can't be set via environment variable. error_collector.ignore_messages Type Hash Default {} Environ variable None A map of error classes to a list of messages. When an error of one of the classes specified here occurs, if its error message contains one of the strings corresponding to it here, that error will be ignored. Caution This option can't be set via environment variable. error_collector.ignore_status_codes Type String Default \"\" Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_STATUS_CODES A comma separated list of status codes, possibly including ranges. Errors associated with these status codes, where applicable, will be ignored. error_collector.expected_classes Type Array Default [] Environ variable None A list of error classes that the agent should treat as expected. Caution This option can't be set via environment variable. error_collector.expected_messages Type Hash Default {} Environ variable None A map of error classes to a list of messages. When an error of one of the classes specified here occurs, if its error message contains one of the strings corresponding to it here, that error will be treated as expected. Caution This option can't be set via environment variable. error_collector.expected_status_codes Type String Default \"\" Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_STATUS_CODES A comma separated list of status codes, possibly including ranges. Errors associated with these status codes, where applicable, will be treated as expected. error_collector.max_backtrace_frames Type Integer Default 50 Environ variable NEW_RELIC_ERROR_COLLECTOR_MAX_BACKTRACE_FRAMES Defines the maximum number of frames in an error backtrace. Backtraces over this amount are truncated at the beginning and end. error_collector.capture_events Type Boolean Default (Dynamic) Environ variable NEW_RELIC_ERROR_COLLECTOR_CAPTURE_EVENTS If true, the agent collects TransactionError events. error_collector.max_event_samples_stored Type Integer Default 100 Environ variable NEW_RELIC_ERROR_COLLECTOR_MAX_EVENT_SAMPLES_STORED Defines the maximum number of TransactionError events sent to Insights per harvest cycle. Browser Monitoring The browser monitoring page load timing feature (sometimes referred to as real user monitoring or RUM) gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. browser_monitoring.auto_instrument Type Boolean Default (Dynamic) Environ variable NEW_RELIC_BROWSER_MONITORING_AUTO_INSTRUMENT If true, enables auto-injection of the JavaScript header for page load timing (sometimes referred to as real user monitoring or RUM). browser_monitoring.capture_attributes Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITORING_CAPTURE_ATTRIBUTES DEPRECATED Use browser_monitoring.attributes.enabled instead. Analytics Events New Relic dashboards is a resource to gather and visualize data about your software and what it says about your business. With it you can quickly and easily create real-time dashboards to get immediate answers about end-user experiences, clickstreams, mobile activities, and server transactions. analytics_events.enabled Type Boolean Default true Environ variable NEW_RELIC_ANALYTICS_EVENTS_ENABLED If true, enables analytics event sampling. analytics_events.max_samples_stored Type Integer Default 1200 Environ variable NEW_RELIC_ANALYTICS_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of request events reported from a single harvest. analytics_events.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_ANALYTICS_EVENTS_CAPTURE_ATTRIBUTES DEPRECATED Use transaction_events.attributes.enabled instead. Attributes Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_ENABLED If true, enables capture of attributes for all destinations. transaction_tracer.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction traces. transaction_events.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction events. error_collector.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_ENABLED If true, the agent captures attributes from error collection. browser_monitoring.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_ENABLED If true, the agent captures attributes from browser monitoring. span_events.attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes on span events. transaction_segments.attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes on transaction segments. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from all destinations. Allows * as wildcard at end. transaction_tracer.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction traces. Allows * as wildcard at end. transaction_events.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction events. Allows * as wildcard at end. error_collector.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from error collection. Allows * as wildcard at end. browser_monitoring.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from browser monitoring. Allows * as wildcard at end. span_events.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from span events. Allows * as wildcard at end. transaction_segments.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction segments. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE Prefix of attributes to include in all destinations. Allows * as wildcard at end. transaction_tracer.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction traces. Allows * as wildcard at end. transaction_events.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction events. Allows * as wildcard at end. error_collector.attributes.include Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_INCLUDE Prefix of attributes to include in error collection. Allows * as wildcard at end. browser_monitoring.attributes.include Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_INCLUDE Prefix of attributes to include in browser monitoring. Allows * as wildcard at end. span_events.attributes.include Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include on span events. Allows * as wildcard at end. transaction_segments.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include on transaction segments. Allows * as wildcard at end. Audit Log audit_log.enabled Type Boolean Default false Environ variable NEW_RELIC_AUDIT_LOG_ENABLED If true, enables an audit log which logs communications with the New Relic collector. audit_log.path Type String Default (Dynamic) Environ variable NEW_RELIC_AUDIT_LOG_PATH Specifies a path to the audit log file (including the filename). audit_log.endpoints Type Array Default [\".*\"] Environ variable NEW_RELIC_AUDIT_LOG_ENDPOINTS List of allowed endpoints to include in audit log Autostart autostart.denylisted_constants Type String Default \"Rails::Console\" Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_CONSTANTS Specify a list of constants that should prevent the agent from starting automatically. Separate individual constants with a comma ,. For example, Rails::Console,UninstrumentedBackgroundJob. autostart.denylisted_executables Type String Default \"irb,rspec\" Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_EXECUTABLES Defines a comma-delimited list of executables that the agent should not instrument. For example, rake,my_ruby_script.rb. autostart.denylisted_rake_tasks Type String Default Copy Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_RAKE_TASKS Defines a comma-delimited list of Rake tasks that the agent should not instrument. For example, assets:precompile,db:migrate. Cross Application Tracer cross_application_tracer.enabled Type Boolean Default false Environ variable NEW_RELIC_CROSS_APPLICATION_TRACER_ENABLED DEPRECATED Please see: distributed_tracing-enabled. If true, enables cross-application tracing when distributed_tracing.enabled is set to false. Custom Attributes custom_attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_CUSTOM_ATTRIBUTES_ENABLED If false, custom attributes will not be sent on Insights events. Custom Insights Events custom_insights_events.enabled Type Boolean Default true Environ variable NEW_RELIC_CUSTOM_INSIGHTS_EVENTS_ENABLED If true, the agent captures New Relic Insights custom events. custom_insights_events.max_samples_stored Type Integer Default 1000 Environ variable NEW_RELIC_CUSTOM_INSIGHTS_EVENTS_MAX_SAMPLES_STORED Specify a maximum number of custom Insights events to buffer in memory at a time. Disabling Use these settings to toggle instrumentation types during agent startup. disable_rake Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RAKE DEPRECATED Please see: instrumentation.rake. If true, disables Rake instrumentation. disable_samplers Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SAMPLERS If true, disables the collection of sampler metrics. Sampler metrics are metrics that are not event-based (such as CPU time or memory usage). disable_resque Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RESQUE DEPRECATED Please see: instrumentation.resque. If true, disables Resque instrumentation. disable_sidekiq Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SIDEKIQ If true, disables Sidekiq instrumentation. disable_dj Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DJ DEPRECATED Please see: instrumentation.delayed_job. If true, disables Delayed::Job instrumentation. disable_sinatra Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SINATRA DEPRECATED Please see: instrumentation.sinatra. If true , disables Sinatra instrumentation. disable_sinatra_auto_middleware Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SINATRA_AUTO_MIDDLEWARE If true, disables agent middleware for Sinatra. This middleware is responsible for advanced feature support such as cross application tracing, page load timing, and error collection. Important Cross application tracing is deprecated in favor of distributed tracing. Distributed tracing is on by default for Ruby agent versions 8.0.0 and above. Middlewares are not required to support distributed tracing. To continue using cross application tracing, update the following options in your newrelic.yml configuration file: # newrelic.yml cross_application_tracer: enabled: true distributed_tracing: enabled: false Copy disable_view_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_VIEW_INSTRUMENTATION If true, disables view instrumentation. disable_activerecord_instrumentation Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_ACTIVERECORD_INSTRUMENTATION If true, disables active record instrumentation. disable_data_mapper Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DATA_MAPPER If true, disables DataMapper instrumentation. disable_activejob Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVEJOB If true, disables ActiveJob instrumentation. disable_action_cable_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTION_CABLE_INSTRUMENTATION If true, disables Action Cable instrumentation. disable_active_storage Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVE_STORAGE If true, disables ActiveStorage instrumentation. disable_memcached Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_MEMCACHED DEPRECATED Please see: instrumentation.memcached. If true, disables instrumentation for the memcached gem. disable_memcache_client Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_MEMCACHE_CLIENT DEPRECATED Please see: instrumentation.memcache-client. If true, disables instrumentation for the memcache-client gem. disable_dalli Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_DALLI DEPRECATED Please see: instrumentation.memcache. If true, disables instrumentation for the dalli gem. disable_dalli_cas_client Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_DALLI_CAS_CLIENT DEPRECATED Please see: instrumentation.memcache. If true, disables instrumentation for the dalli gem's additional CAS client support. disable_memcache_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MEMCACHE_INSTRUMENTATION DEPRECATED Please see: instrumentation.memcache. If true, disables memcache instrumentation. disable_gc_profiler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_GC_PROFILER If true, disables the use of GC::Profiler to measure time spent in garbage collection disable_sequel_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SEQUEL_INSTRUMENTATION If true, disables Sequel instrumentation. disable_database_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DATABASE_INSTRUMENTATION DEPRECATED Use disable_sequel_instrumentation instead. disable_mongo Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MONGO DEPRECATED Please see: instrumentation.mongo. If true, the agent won't install instrumentation for the Mongo gem. disable_redis Type Boolean Default false Environ variable NEW_RELIC_DISABLE_REDIS DEPRECATED Please see: instrumentation.redis. If true, the agent won't install instrumentation for Redis. disable_vm_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_VM_SAMPLER If true, the agent won't sample performance measurements from the Ruby VM. disable_memory_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MEMORY_SAMPLER If true, the agent won't sample the memory usage of the host process. disable_cpu_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_CPU_SAMPLER If true, the agent won't sample the CPU usage of the host process. disable_delayed_job_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DELAYED_JOB_SAMPLER If true, the agent won't measure the depth of Delayed Job queues. disable_active_record_notifications Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVE_RECORD_NOTIFICATIONS If true, disables instrumentation for ActiveRecord 4, 5, and 6. disable_bunny Type Boolean Default false Environ variable NEW_RELIC_DISABLE_BUNNY DEPRECATED Please see: instrumentation.bunny. If true, disables instrumentation for the bunny gem. disable_curb Type Boolean Default false Environ variable NEW_RELIC_DISABLE_CURB DEPRECATED Please see: instrumentation.curb. If true, disables instrumentation for the curb gem. disable_excon Type Boolean Default false Environ variable NEW_RELIC_DISABLE_EXCON DEPRECATED Please see: instrumentation.excon. If true, disables instrumentation for the excon gem. disable_httpclient Type Boolean Default false Environ variable NEW_RELIC_DISABLE_HTTPCLIENT DEPRECATED Please see: instrumentation.httpclient. If true, disables instrumentation for the httpclient gem. disable_net_http Type Boolean Default false Environ variable NEW_RELIC_DISABLE_NET_HTTP DEPRECATED Please see: instrumentation.net_http. If true, disables instrumentation for Net::HTTP. disable_rack Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RACK DEPRECATED Please see: instrumentation.rack. If true, prevents the agent from hooking into the to_app method in Rack::Builder to find gems to instrument during application startup. disable_rack_urlmap Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RACK_URLMAP DEPRECATED Please see: instrumentation.rack_urlmap. If true, prevents the agent from hooking into Rack::URLMap to install middleware tracing. disable_puma_rack Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_PUMA_RACK DEPRECATED Please see: instrumentation.puma_rack. If true, prevents the agent from hooking into the to_app method in Puma::Rack::Builder to find gems to instrument during application startup. disable_puma_rack_urlmap Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_PUMA_RACK_URLMAP DEPRECATED Please see: instrumentation.puma_rack_urlmap. If true, prevents the agent from hooking into Puma::Rack::URLMap to install middleware tracing. disable_typhoeus Type Boolean Default false Environ variable NEW_RELIC_DISABLE_TYPHOEUS DEPRECATED Please see: instrumentation.typhoeus. If true, the agent won't install instrumentation for the typhoeus gem. disable_httprb Type Boolean Default false Environ variable NEW_RELIC_DISABLE_HTTPRB DEPRECATED Please see: instrumentation.httprb. If true, the agent won't install instrumentation for the http.rb gem. disable_middleware_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MIDDLEWARE_INSTRUMENTATION If true, the agent won't wrap third-party middlewares in instrumentation (regardless of whether they are installed via Rack::Builder or Rails). disable_grape Type Boolean Default false Environ variable NEW_RELIC_DISABLE_GRAPE DEPRECATED Please see: instrumentation.grape. If true, the agent won't install Grape instrumentation. Distributed Tracing distributed_tracing.enabled Type Boolean Default true Environ variable NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Distributed tracing lets you see the path that a request takes through your distributed system. Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition guide before you enable this feature. Heroku heroku.use_dyno_names Type Boolean Default true Environ variable NEW_RELIC_HEROKU_USE_DYNO_NAMES If true, the agent uses Heroku dyno names as the hostname. heroku.dyno_name_prefixes_to_shorten Type Array Default [\"scheduler\", \"run\"] Environ variable NEW_RELIC_HEROKU_DYNO_NAME_PREFIXES_TO_SHORTEN Ordinarily the agent reports dyno names with a trailing dot and process ID (for example, worker.3). You can remove this trailing data by specifying the prefixes you want to report without trailing data (for example, worker). Instrumentation instrumentation.net_http Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_NET_HTTP Controls auto-instrumentation of Net::HTTP at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.typhoeus Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_TYPHOEUS Controls auto-instrumentation of Typhoeus at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.bunny Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_BUNNY Controls auto-instrumentation of bunny at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.httprb Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_HTTPRB Controls auto-instrumentation of http.rb gem at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.resque Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RESQUE Controls auto-instrumentation of resque at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.redis Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_REDIS Controls auto-instrumentation of Redis at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.rake Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RAKE Controls auto-instrumentation of rake at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.mongo Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MONGO Controls auto-instrumentation of Mongo at start up. May be one of [enabled|disabled] . instrumentation.delayed_job Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_DELAYED_JOB Controls auto-instrumentation of Delayed Job at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.httpclient Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_HTTPCLIENT Controls auto-instrumentation of HTTPClient at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.curb Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_CURB Controls auto-instrumentation of Curb at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.sinatra Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_SINATRA Controls auto-instrumentation of Sinatra at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.rack Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RACK Controls auto-instrumentation of Rack. When enabled, the agent hooks into the to_app method in Rack::Builder to find gems to instrument during application startup. May be one of [auto|prepend|chain|disabled] . instrumentation.rack_urlmap Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RACK_URLMAP Controls auto-instrumentation of Rack::URLMap at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.puma_rack Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_PUMA_RACK Controls auto-instrumentation of Puma::Rack. When enabled, the agent hooks into the to_app method in Puma::Rack::Builder to find gems to instrument during application startup. May be one of [auto|prepend|chain|disabled] . instrumentation.puma_rack_urlmap Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_PUMA_RACK_URLMAP Controls auto-instrumentation of Puma::Rack::URLMap at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcached Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHED Controls auto-instrumentation of memcached gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcache_client Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHE_CLIENT Controls auto-instrumentation of memcache-client gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcache Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHE Controls auto-instrumentation of dalli gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.logger Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_LOGGER Controls auto-instrumentation of Ruby standard library Logger at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.excon Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_EXCON Controls auto-instrumentation of Excon at start up. May be one of [enabled|disabled] . instrumentation.grape Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_GRAPE Controls auto-instrumentation of Grape at start up. May be one of [auto|prepend|chain|disabled] . Mongo mongo.capture_queries Type Boolean Default true Environ variable NEW_RELIC_MONGO_CAPTURE_QUERIES If true, the agent captures Mongo queries in transaction traces. mongo.obfuscate_queries Type Boolean Default true Environ variable NEW_RELIC_MONGO_OBFUSCATE_QUERIES If true, the agent obfuscates Mongo queries in transaction traces. Process Host process_host.display_name Type String Default (Dynamic) Environ variable NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Specify a custom host name for display in the New Relic UI. Rake rake.tasks Type Array Default [] Environ variable NEW_RELIC_RAKE_TASKS Specify an array of Rake tasks to automatically instrument. rake.connect_timeout Type Integer Default 10 Environ variable NEW_RELIC_RAKE_CONNECT_TIMEOUT Timeout for waiting on connect to complete before a rake task Resque resque.capture_params Type Boolean Default false Environ variable NEW_RELIC_RESQUE_CAPTURE_PARAMS DEPRECATED If true, enables the capture of job arguments for transaction traces and traced errors in Resque. Rules rules.ignore_url_regexes Type Array Default [] Environ variable NEW_RELIC_RULES_IGNORE_URL_REGEXES Define transactions you want the agent to ignore, by specifying a list of patterns matching the URI you want to ignore. Note: This will only ignore transaction events, not spans or traces from the same transation. See documentation on (ignoring specific transactions) [https://docs.newrelic.com/docs/agents/ruby-agent/api-guides/ignoring-specific-transactions/#config-ignoring] for more details. Sidekiq sidekiq.capture_params Type Boolean Default false Environ variable NEW_RELIC_SIDEKIQ_CAPTURE_PARAMS DEPRECATED If true, enables the capture of job arguments for transaction traces and traced errors in Sidekiq. Slow SQL slow_sql.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_ENABLED If true, the agent collects slow SQL queries. slow_sql.explain_threshold Type Float Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_EXPLAIN_THRESHOLD Specify a threshold in seconds. The agent collects slow SQL queries and explain plans that exceed this threshold. slow_sql.explain_enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_EXPLAIN_ENABLED If true, the agent collects explain plans in slow SQL queries. If this setting is omitted, the transaction_tracer.explain_enabled setting will be applied as the default setting for explain plans in slow SQL as well. slow_sql.record_sql Type String Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_RECORD_SQL Defines an obfuscation level for slow SQL queries. Valid options are obfuscated, raw, or none). slow_sql.use_longer_sql_id Type Boolean Default false Environ variable NEW_RELIC_SLOW_SQL_USE_LONGER_SQL_ID Generate a longer sql_id for slow SQL traces. sql_id is used for aggregation of similar queries. Span Events span_events.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ENABLED If true, enables span event sampling. span_events.queue_size Type Integer Default 10000 Environ variable NEW_RELIC_SPAN_EVENTS_QUEUE_SIZE Sets the maximum number of span events to buffer when streaming to the trace observer. span_events.max_samples_stored Type Integer Default 2000 Environ variable NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of span events reported from a single harvest. Strip Exception Messages strip_exception_messages.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_STRIP_EXCEPTION_MESSAGES_ENABLED If true, the agent strips messages from all exceptions except those in the allowlist. Enabled automatically in high security mode. strip_exception_messages.allowed_classes Type String Default \"\" Environ variable NEW_RELIC_STRIP_EXCEPTION_MESSAGES_ALLOWED_CLASSES Specify a list of exceptions you do not want the agent to strip when strip_exception_messages is true. Separate exceptions with a comma. For example, \"ImportantException,PreserveMessageException\". Thread Profiler thread_profiler.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_THREAD_PROFILER_ENABLED If true, enables use of the thread profiler. Utilization utilization.detect_aws Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_AWS If true, the agent automatically detects that it is running in an AWS environment. utilization.detect_azure Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_AZURE If true, the agent automatically detects that it is running in an Azure environment. utilization.detect_gcp Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_GCP If true, the agent automatically detects that it is running in an Google Cloud Platform environment. utilization.detect_pcf Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_PCF If true, the agent automatically detects that it is running in a Pivotal Cloud Foundry environment. utilization.detect_docker Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_DOCKER If true, the agent automatically detects that it is running in Docker. utilization.detect_kubernetes Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_KUBERNETES If true, the agent automatically detects that it is running in Kubernetes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.41057,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Ruby <em>agent</em> <em>configuration</em>",
        "sections": "Ruby <em>agent</em> <em>configuration</em>",
        "tags": "<em>Agents</em>",
        "body": "You can configure the New Relic Ruby <em>agent</em> with settings in a <em>configuration</em> file, environment variables, or programmatically with server-side <em>configuration</em>. This document summarizes the <em>configuration</em> options available for the Ruby <em>agent</em>. If the default value for a <em>configuration</em> option is (Dynamic"
      },
      "id": "603eb6f4e7b9d22a5f2f7c73"
    }
  ],
  "/docs/agents/java-agent/configuration/java-agent-configuration-config-file": [
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-10-18T05:35:40Z",
      "updated_at": "2021-09-27T15:21:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # Real-time profiling using Java Flight Recorder (JFR). # This feature reports dimensional metrics to the ingest endpoint configured by # metric_ingest_uri and events to the ingest endpoint configured by event_ingest_uri. # Both ingest endpoints default to US production but they will be automatically set to EU # production when using an EU license key. Other ingest endpoints can be configured manually. # Requires a JVM that provides the JFR library. jfr: # Set to true to enable Real-time profiling with JFR. # Default is false. enabled: false # Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. # Audit logging is extremely verbose and should only be used for troubleshooting purposes. # Default is false. audit_logging: false # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.62117,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>configuration</em>&#x2F;<em>java</em>-<em>agent</em>-<em>configuration</em>-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    },
    {
      "sections": [
        "Hostname logic in Java",
        "Display names",
        "Tip",
        "Instance names",
        "Hostname logic precedence",
        "Hosts and unique agent identifiers",
        "For more help"
      ],
      "title": "Hostname logic in Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "32a9b875cf20d27be147a4ca29b749f1612d94e2",
      "image": "https://docs.newrelic.com/static/026e7b6f7910842deb3f7c1960cad008/9e32a/upload.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/hostname-logic-java/",
      "published_at": "2021-10-18T05:35:39Z",
      "updated_at": "2021-09-14T09:17:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Java agent automatically assigns a host:port name to your JVMs. If the default name is not useful, you can set a display name to distinguish your JVMs in the New Relic UI. For supported frameworks, the Java agent uses the instance name instead of the display name. The Java agent uniquely identifies running agents by their host, port, and dispatcher, regardless of the environment used. Display names If the default host:port label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. Set the display name via configuration, either in an environment variable or in your newrelic.yml config file. The environment variable takes precedence over the config file value. After the JVM is restarted and the Java agent is reporting again , the display name will show in the JVM list as seen in the example below in addition to host:port. To set a display name: Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable. OR Set process_host.display_name in your newrelic.yml. Restart your JVM to see your changes in the New Relic UI. Tip You can also set the display name with a system property. Instance names For WebSphere and WebLogic users, the Java agent also reports the instance name for each active app server instance, which is visible in the APM Settings > Environment page. Generally, this name is provided by the app server. If an instance name is set, it will be used instead of the display name in the New Relic UI. Hostname logic precedence If there are multiple hostname settings (for example, you use WebSphere and also set the display_name property), the agent uses this precedence: display_name overrides the default name, and the WebSphere and WebLogic instance names. WebSphere and WebLogic instance names override the default name. The default (host:port) name has lowest precedence. Hosts and unique agent identifiers The Java agent uses hosts, ports, and dispatchers to uniquely identify multiple JVMs reporting to the same app name. Multiple agents running on the same server are therefore reported separately, as long as their ports or dispatcher names differ. The unique identifier is based on the following values: Host: An identifier for your app's parent server that is derived from the Operating System. This value is not configurable by the Java agent. Port: The port associated with the app server. If the agent can't determine the port number, or your app is not running in an app server, defaults to 0. This value is user-configurable. Dispatcher Name: The name of the app server. For example, Apache Tomcat, Glassfish, or WebLogic. If there is no active app server, defaults to Unknown. For more help Additional documentation resources include: Setting the hostname reported by the Java agent (manually overriding the hostname settings when the link between your APM app and Servers for Linux is broken) Add, rename, and remove hosts (add and remove hosts in APM)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.90364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Hostname logic in <em>Java</em>",
        "sections": "Hostname logic in <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " name. The default (host:port) name has lowest precedence. Hosts and unique <em>agent</em> identifiers The <em>Java</em> <em>agent</em> uses hosts, ports, and dispatchers to uniquely identify multiple JVMs reporting to the same app name. Multiple <em>agents</em> running on the same server are therefore reported separately, as long"
      },
      "id": "6043cfbb64441ff20b378f0b"
    },
    {
      "sections": [
        "Ruby agent configuration",
        "Configuration methods and precedence",
        "View and edit config file options",
        "Update the config file",
        "Important",
        "General",
        "license_key",
        "agent_enabled",
        "app_name",
        "monitor_mode",
        "log_level",
        "high_security",
        "security_policies_token",
        "proxy_host",
        "proxy_port",
        "proxy_user",
        "proxy_pass",
        "capture_params",
        "Caution",
        "config_path",
        "apdex_t",
        "sync_startup",
        "send_data_on_exit",
        "timeout",
        "force_install_exit_handler",
        "log_file_name",
        "log_file_path",
        "prepend_active_record_instrumentation",
        "capture_memcache_keys",
        "message_tracer.segment_parameters.enabled",
        "marshaller",
        "backport_fast_active_record_connection_lookup",
        "labels",
        "ca_bundle_path",
        "datastore_tracer.instance_reporting.enabled",
        "datastore_tracer.database_name_reporting.enabled",
        "clear_transaction_state_after_fork",
        "exclude_newrelic_header",
        "infinite_tracing.trace_observer.host",
        "infinite_tracing.trace_observer.port",
        "Transaction Tracer",
        "transaction_tracer.enabled",
        "transaction_tracer.transaction_threshold",
        "transaction_tracer.record_sql",
        "transaction_tracer.record_redis_arguments",
        "transaction_tracer.capture_attributes",
        "transaction_tracer.explain_threshold",
        "transaction_tracer.explain_enabled",
        "transaction_tracer.stack_trace_threshold",
        "transaction_tracer.limit_segments",
        "Error Collector",
        "error_collector.enabled",
        "error_collector.capture_attributes",
        "error_collector.ignore_errors",
        "error_collector.ignore_classes",
        "error_collector.ignore_messages",
        "error_collector.ignore_status_codes",
        "error_collector.expected_classes",
        "error_collector.expected_messages",
        "error_collector.expected_status_codes",
        "error_collector.max_backtrace_frames",
        "error_collector.capture_events",
        "error_collector.max_event_samples_stored",
        "Browser Monitoring",
        "browser_monitoring.auto_instrument",
        "browser_monitoring.capture_attributes",
        "Analytics Events",
        "analytics_events.enabled",
        "analytics_events.max_samples_stored",
        "analytics_events.capture_attributes",
        "Attributes",
        "attributes.enabled",
        "transaction_tracer.attributes.enabled",
        "transaction_events.attributes.enabled",
        "error_collector.attributes.enabled",
        "browser_monitoring.attributes.enabled",
        "span_events.attributes.enabled",
        "transaction_segments.attributes.enabled",
        "attributes.exclude",
        "transaction_tracer.attributes.exclude",
        "transaction_events.attributes.exclude",
        "error_collector.attributes.exclude",
        "browser_monitoring.attributes.exclude",
        "span_events.attributes.exclude",
        "transaction_segments.attributes.exclude",
        "attributes.include",
        "transaction_tracer.attributes.include",
        "transaction_events.attributes.include",
        "error_collector.attributes.include",
        "browser_monitoring.attributes.include",
        "span_events.attributes.include",
        "transaction_segments.attributes.include",
        "Audit Log",
        "audit_log.enabled",
        "audit_log.path",
        "audit_log.endpoints",
        "Autostart",
        "autostart.denylisted_constants",
        "autostart.denylisted_executables",
        "autostart.denylisted_rake_tasks",
        "Cross Application Tracer",
        "cross_application_tracer.enabled",
        "Custom Attributes",
        "custom_attributes.enabled",
        "Custom Insights Events",
        "custom_insights_events.enabled",
        "custom_insights_events.max_samples_stored",
        "Disabling",
        "disable_rake",
        "disable_samplers",
        "disable_resque",
        "disable_sidekiq",
        "disable_dj",
        "disable_sinatra",
        "disable_sinatra_auto_middleware",
        "disable_view_instrumentation",
        "disable_activerecord_instrumentation",
        "disable_data_mapper",
        "disable_activejob",
        "disable_action_cable_instrumentation",
        "disable_active_storage",
        "disable_memcached",
        "disable_memcache_client",
        "disable_dalli",
        "disable_dalli_cas_client",
        "disable_memcache_instrumentation",
        "disable_gc_profiler",
        "disable_sequel_instrumentation",
        "disable_database_instrumentation",
        "disable_mongo",
        "disable_redis",
        "disable_vm_sampler",
        "disable_memory_sampler",
        "disable_cpu_sampler",
        "disable_delayed_job_sampler",
        "disable_active_record_notifications",
        "disable_bunny",
        "disable_curb",
        "disable_excon",
        "disable_httpclient",
        "disable_net_http",
        "disable_rack",
        "disable_rack_urlmap",
        "disable_puma_rack",
        "disable_puma_rack_urlmap",
        "disable_typhoeus",
        "disable_httprb",
        "disable_middleware_instrumentation",
        "disable_grape",
        "Distributed Tracing",
        "distributed_tracing.enabled",
        "Heroku",
        "heroku.use_dyno_names",
        "heroku.dyno_name_prefixes_to_shorten",
        "Instrumentation",
        "instrumentation.net_http",
        "instrumentation.typhoeus",
        "instrumentation.bunny",
        "instrumentation.httprb",
        "instrumentation.resque",
        "instrumentation.redis",
        "instrumentation.rake",
        "instrumentation.mongo",
        "instrumentation.delayed_job",
        "instrumentation.httpclient",
        "instrumentation.curb",
        "instrumentation.sinatra",
        "instrumentation.rack",
        "instrumentation.rack_urlmap",
        "instrumentation.puma_rack",
        "instrumentation.puma_rack_urlmap",
        "instrumentation.memcached",
        "instrumentation.memcache_client",
        "instrumentation.memcache",
        "instrumentation.logger",
        "instrumentation.excon",
        "instrumentation.grape",
        "Mongo",
        "mongo.capture_queries",
        "mongo.obfuscate_queries",
        "Process Host",
        "process_host.display_name",
        "Rake",
        "rake.tasks",
        "rake.connect_timeout",
        "Resque",
        "resque.capture_params",
        "Rules",
        "rules.ignore_url_regexes",
        "Sidekiq",
        "sidekiq.capture_params",
        "Slow SQL",
        "slow_sql.enabled",
        "slow_sql.explain_threshold",
        "slow_sql.explain_enabled",
        "slow_sql.record_sql",
        "slow_sql.use_longer_sql_id",
        "Span Events",
        "span_events.enabled",
        "span_events.queue_size",
        "span_events.max_samples_stored",
        "Strip Exception Messages",
        "strip_exception_messages.enabled",
        "strip_exception_messages.allowed_classes",
        "Thread Profiler",
        "thread_profiler.enabled",
        "Utilization",
        "utilization.detect_aws",
        "utilization.detect_azure",
        "utilization.detect_gcp",
        "utilization.detect_pcf",
        "utilization.detect_docker",
        "utilization.detect_kubernetes"
      ],
      "title": "Ruby agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Configuration"
      ],
      "external_id": "ee72f1c59d456c5e5a089cfa81bfbde6064d7cb0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/configuration/ruby-agent-configuration/",
      "published_at": "2021-10-19T03:52:40Z",
      "updated_at": "2021-10-19T03:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can configure the New Relic Ruby agent with settings in a configuration file, environment variables, or programmatically with server-side configuration. This document summarizes the configuration options available for the Ruby agent. If the default value for a configuration option is (Dynamic), this means the Ruby agent calculates the default at runtime. The value for the config setting defaults to the value of another setting as appropriate. Configuration methods and precedence The primary (default) method to configure the Ruby agent is via the configuration file (newrelic.yml) in the config subdirectory. To set configuration values using environment variables: Add the prefix NEW_RELIC_ to the setting's name. Replace any periods . with underscores _. You can also configure a few values in the UI via server-side configuration. The Ruby agent follows this order of precedence for configuration: Environment variables Server-side configuration Configuration file (newrelic.yml) Default configuration settings In other words, environment variables override all other configuration settings and info, server-side configuration overrides the configuration file and default config settings, and so on. View and edit config file options The Ruby agent's newrelic.yml is a standard YAML configuration file. It typically includes a Defaults section at the top, plus sections below for each application environment; for example, Development, Testing, and Production. The Ruby agent determines which section of the newrelic.yml config file to read from by looking at certain environment variables to derive the application's environment. This can be useful, for example, when you want to use info for the log_level config setting in your production environment, and you want more verbose log_level config settings (such as debug in your development environment. Here is an example newrelic.yml config file: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'My Application Name' production: <<: *default_settings log_level: info development: <<: *default_settings log_level: debug Copy For non-Rails apps, the Ruby agent looks for the following environment variables, in this order, to determine the application environment: NEW_RELIC_ENV RUBY_ENV RAILS_ENV APP_ENV RACK_ENV If the Ruby agent does not detect values for any of those environment variables, it will default the application environment to development and read from the development section of the newrelic.yml config file. When running the Ruby agent in a Rails app, the agent first looks for the NEW_RELIC_ENV environment variable to determine the application environment and which section of the newrelic.yml to use. If NEW_RELIC_ENV is not present, the agent uses the Rails environment (RAILS_ENV or RAILS.env, depending on the version of Rails) . When you edit the config file, be sure to: Indent only with two spaces. Indent only where relevant, in stanzas such as error_collector. If you do not indent correctly, the agent may throw an Unable to parse configuration file error on startup. To view the most current list of available Ruby agent configuration options, use the rake newrelic:config:docs command. This document describes the most common options. Update the config file This documentation applies to the Ruby agent's latest release. For details on earlier versions, refer to the comments in newrelic.yml itself. To update newrelic.yml file after a new release, use the template in the base directory of the agent gem. When you update to new gem versions, examine or diff config/newrelic.yml and newrelic.yml in the installation directory to take advantage of new configuration options. Important Updating the gem does not automatically update config/newrelic.yml. General These settings are available for agent configuration. Some settings depend on your New Relic subscription level. license_key Type String Default \"\" Environ variable NEW_RELIC_LICENSE_KEY Your New Relic license key. agent_enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_AGENT_ENABLED If true, allows the Ruby agent to run. app_name Type String Default (Dynamic) Environ variable NEW_RELIC_APP_NAME Specify the application name used to aggregate data in the New Relic UI. To report data to multiple apps at the same time, specify a list of names separated by a semicolon ;. For example, MyApp or MyStagingApp;Instance1. monitor_mode Type Boolean Default (Dynamic) Environ variable NEW_RELIC_MONITOR_MODE When true, the agent transmits data about your app to the New Relic collector. log_level Type String Default \"info\" Environ variable NEW_RELIC_LOG_LEVEL Sets the level of detail of log messages. Possible log levels, in increasing verbosity, are: error, warn, info or debug. high_security Type Boolean Default false Environ variable NEW_RELIC_HIGH_SECURITY If true, enables high security mode. Ensure you understand the implications of high security mode before enabling this setting. security_policies_token Type String Default \"\" Environ variable NEW_RELIC_SECURITY_POLICIES_TOKEN Applies Language Agent Security Policy settings. proxy_host Type String Default nil Environ variable NEW_RELIC_PROXY_HOST Defines a host for communicating with the New Relic collector via a proxy server. proxy_port Type Integer Default 8080 Environ variable NEW_RELIC_PROXY_PORT Defines a port for communicating with the New Relic collector via a proxy server. proxy_user Type String Default nil Environ variable NEW_RELIC_PROXY_USER Defines a user for communicating with the New Relic collector via a proxy server. proxy_pass Type String Default nil Environ variable NEW_RELIC_PROXY_PASS Defines a password for communicating with the New Relic collector via a proxy server. capture_params Type Boolean Default false Environ variable NEW_RELIC_CAPTURE_PARAMS When true, the agent captures HTTP request parameters and attaches them to transaction traces, traced errors, and TransactionError events. Caution When using the capture_params setting, the Ruby agent will not attempt to filter secret information. Recommendation: To filter secret information from request parameters, use the attributes.include setting instead. For more information, see the Ruby attribute examples. config_path Type String Default (Dynamic) Environ variable NEW_RELIC_CONFIG_PATH Path to newrelic.yml. If undefined, the agent checks the following directories (in order): config/newrelic.yml, newrelic.yml, $HOME/.newrelic/newrelic.yml and $HOME/newrelic.yml. apdex_t Type Float Default 0.5 Environ variable NEW_RELIC_APDEX_T DEPRECATED For agent versions 3.5.0 or higher, set your Apdex T via the New Relic UI. sync_startup Type Boolean Default false Environ variable NEW_RELIC_SYNC_STARTUP When set to true, forces a synchronous connection to the New Relic collector during application startup. For very short-lived processes, this helps ensure the New Relic agent has time to report. send_data_on_exit Type Boolean Default true Environ variable NEW_RELIC_SEND_DATA_ON_EXIT If true, enables the exit handler that sends data to the New Relic collector before shutting down. timeout Type Integer Default 120 Environ variable NEW_RELIC_TIMEOUT Defines the maximum number of seconds the agent should spend attempting to connect to the collector. force_install_exit_handler Type Boolean Default false Environ variable NEW_RELIC_FORCE_INSTALL_EXIT_HANDLER Forces the exit handler that sends all cached data to collector before shutting down to be installed regardless of detecting scenarios where it generally should not be. Known use-case for this option is where Sinatra is running as an embedded service within another framework and the agent is detecting the Sinatra app and skipping the at_exit handler as a result. Sinatra classically runs the entire application in an at_exit block and would otherwise misbehave if the Agent's at_exit handler was also installed in those circumstances. Note: send_data_on_exit should also be set to true in tandem with this setting. log_file_name Type String Default \"newrelic_agent.log\" Environ variable NEW_RELIC_LOG_FILE_NAME Defines a name for the log file. log_file_path Type String Default \"log/\" Environ variable NEW_RELIC_LOG_FILE_PATH Defines a path to the agent log file, excluding the filename. prepend_active_record_instrumentation Type Boolean Default false Environ variable NEW_RELIC_PREPEND_ACTIVE_RECORD_INSTRUMENTATION If true, uses Module#prepend rather than alias_method for ActiveRecord instrumentation. capture_memcache_keys Type Boolean Default false Environ variable NEW_RELIC_CAPTURE_MEMCACHE_KEYS Enable or disable the capture of memcache keys from transaction traces. message_tracer.segment_parameters.enabled Type Boolean Default true Environ variable NEW_RELIC_MESSAGE_TRACER_SEGMENT_PARAMETERS_ENABLED If true, the agent will collect metadata about messages and attach them as segment parameters. marshaller Type String Default \"json\" Environ variable NEW_RELIC_MARSHALLER Specifies a marshaller for transmitting data to the New Relic collector. Currently json is the only valid value for this setting. backport_fast_active_record_connection_lookup Type Boolean Default false Environ variable NEW_RELIC_BACKPORT_FAST_ACTIVE_RECORD_CONNECTION_LOOKUP Backports the faster ActiveRecord connection lookup introduced in Rails 6, which improves agent performance when instrumenting ActiveRecord. Note that this setting may not be compatible with other gems that patch ActiveRecord. labels Type String Default \"\" Environ variable NEW_RELIC_LABELS A dictionary of label names and values that will be applied to the data sent from this agent. May also be expressed as a semicolon-delimited ; string of colon-separated : pairs. For example, <var>Server</var>:<var>One</var>;<var>Data Center</var>:<var>Primary</var>. ca_bundle_path Type String Default nil Environ variable NEW_RELIC_CA_BUNDLE_PATH Manual override for the path to your local CA bundle. This CA bundle will be used to validate the SSL certificate presented by New Relic's data collection service. datastore_tracer.instance_reporting.enabled Type Boolean Default true Environ variable NEW_RELIC_DATASTORE_TRACER_INSTANCE_REPORTING_ENABLED If false, the agent will not report datastore instance metrics, nor add host or port_path_or_id parameters to transaction or slow SQL traces. datastore_tracer.database_name_reporting.enabled Type Boolean Default true Environ variable NEW_RELIC_DATASTORE_TRACER_DATABASE_NAME_REPORTING_ENABLED If false, the agent will not add database_name parameter to transaction or slow sql traces. clear_transaction_state_after_fork Type Boolean Default false Environ variable NEW_RELIC_CLEAR_TRANSACTION_STATE_AFTER_FORK If true, the agent will clear Tracer::State in Agent.drop_buffered_data. exclude_newrelic_header Type Boolean Default false Environ variable NEW_RELIC_EXCLUDE_NEWRELIC_HEADER Allows newrelic distributed tracing headers to be suppressed on outbound requests. infinite_tracing.trace_observer.host Type String Default \"\" Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST Configures the hostname for the Trace Observer Host. When configured, enables tail-based sampling by sending all recorded spans to a Trace Observer for further sampling decisions, irrespective of any usual agent sampling decision. infinite_tracing.trace_observer.port Type Integer Default 443 Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_PORT Configures the TCP/IP port for the Trace Observer Host Transaction Tracer The transaction traces feature collects detailed information from a selection of transactions, including a summary of the calling sequence, a breakdown of time spent, and a list of SQL queries and their query plans (on mysql and postgresql). Available features depend on your New Relic subscription level. transaction_tracer.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_ENABLED If true, enables collection of transaction traces. transaction_tracer.transaction_threshold Type Float Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_TRACER_TRANSACTION_THRESHOLD Specify a threshold in seconds. Transactions with a duration longer than this threshold are eligible for transaction traces. Specify a float value or the string apdex_f. transaction_tracer.record_sql Type String Default \"obfuscated\" Environ variable NEW_RELIC_TRANSACTION_TRACER_RECORD_SQL Obfuscation level for SQL queries reported in transaction trace nodes. By default, this is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to none. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. transaction_tracer.record_redis_arguments Type Boolean Default false Environ variable NEW_RELIC_TRANSACTION_TRACER_RECORD_REDIS_ARGUMENTS If true, the agent records Redis command arguments in transaction traces. transaction_tracer.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_CAPTURE_ATTRIBUTES DEPRECATED Use transaction_tracer.attributes.enabled instead. transaction_tracer.explain_threshold Type Float Default 0.5 Environ variable NEW_RELIC_TRANSACTION_TRACER_EXPLAIN_THRESHOLD Threshold (in seconds) above which the agent will collect explain plans. Relevant only when explain_enabled is true. transaction_tracer.explain_enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_EXPLAIN_ENABLED If true, enables the collection of explain plans in transaction traces. This setting will also apply to explain plans in slow SQL traces if slow_sql.explain_enabled is not set separately. transaction_tracer.stack_trace_threshold Type Float Default 0.5 Environ variable NEW_RELIC_TRANSACTION_TRACER_STACK_TRACE_THRESHOLD Specify a threshold in seconds. The agent includes stack traces in transaction trace nodes when the stack trace duration exceeds this threshold. transaction_tracer.limit_segments Type Integer Default 4000 Environ variable NEW_RELIC_TRANSACTION_TRACER_LIMIT_SEGMENTS Maximum number of transaction trace nodes to record in a single transaction trace. Error Collector The agent collects and reports all uncaught exceptions by default. These configuration options allow you to customize the error collection. For information on ignored and expected errors, see this page on Error Analytics in APM. To set expected errors via the NewRelic::Agent.notice_error Ruby method, consult the Ruby Agent API. error_collector.enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ENABLED If true, the agent captures traced errors and error count metrics. error_collector.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_CAPTURE_ATTRIBUTES DEPRECATED Use error_collector.attributes.enabled instead. error_collector.ignore_errors Type String Default \"ActionController::RoutingError,Sinatra::NotFound\" Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERRORS DEPRECATED Use error_collector.ignore_classes instead. Specify a comma-delimited list of error classes that the agent should ignore. Caution Server side configuration takes precedence for this setting over all environment configurations. This differs from all other configuration settings where environment variable take precedence over server side configuration. error_collector.ignore_classes Type Array Default [] Environ variable None A list of error classes that the agent should ignore. Caution This option can't be set via environment variable. error_collector.ignore_messages Type Hash Default {} Environ variable None A map of error classes to a list of messages. When an error of one of the classes specified here occurs, if its error message contains one of the strings corresponding to it here, that error will be ignored. Caution This option can't be set via environment variable. error_collector.ignore_status_codes Type String Default \"\" Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_STATUS_CODES A comma separated list of status codes, possibly including ranges. Errors associated with these status codes, where applicable, will be ignored. error_collector.expected_classes Type Array Default [] Environ variable None A list of error classes that the agent should treat as expected. Caution This option can't be set via environment variable. error_collector.expected_messages Type Hash Default {} Environ variable None A map of error classes to a list of messages. When an error of one of the classes specified here occurs, if its error message contains one of the strings corresponding to it here, that error will be treated as expected. Caution This option can't be set via environment variable. error_collector.expected_status_codes Type String Default \"\" Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_STATUS_CODES A comma separated list of status codes, possibly including ranges. Errors associated with these status codes, where applicable, will be treated as expected. error_collector.max_backtrace_frames Type Integer Default 50 Environ variable NEW_RELIC_ERROR_COLLECTOR_MAX_BACKTRACE_FRAMES Defines the maximum number of frames in an error backtrace. Backtraces over this amount are truncated at the beginning and end. error_collector.capture_events Type Boolean Default (Dynamic) Environ variable NEW_RELIC_ERROR_COLLECTOR_CAPTURE_EVENTS If true, the agent collects TransactionError events. error_collector.max_event_samples_stored Type Integer Default 100 Environ variable NEW_RELIC_ERROR_COLLECTOR_MAX_EVENT_SAMPLES_STORED Defines the maximum number of TransactionError events sent to Insights per harvest cycle. Browser Monitoring The browser monitoring page load timing feature (sometimes referred to as real user monitoring or RUM) gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. browser_monitoring.auto_instrument Type Boolean Default (Dynamic) Environ variable NEW_RELIC_BROWSER_MONITORING_AUTO_INSTRUMENT If true, enables auto-injection of the JavaScript header for page load timing (sometimes referred to as real user monitoring or RUM). browser_monitoring.capture_attributes Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITORING_CAPTURE_ATTRIBUTES DEPRECATED Use browser_monitoring.attributes.enabled instead. Analytics Events New Relic dashboards is a resource to gather and visualize data about your software and what it says about your business. With it you can quickly and easily create real-time dashboards to get immediate answers about end-user experiences, clickstreams, mobile activities, and server transactions. analytics_events.enabled Type Boolean Default true Environ variable NEW_RELIC_ANALYTICS_EVENTS_ENABLED If true, enables analytics event sampling. analytics_events.max_samples_stored Type Integer Default 1200 Environ variable NEW_RELIC_ANALYTICS_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of request events reported from a single harvest. analytics_events.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_ANALYTICS_EVENTS_CAPTURE_ATTRIBUTES DEPRECATED Use transaction_events.attributes.enabled instead. Attributes Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_ENABLED If true, enables capture of attributes for all destinations. transaction_tracer.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction traces. transaction_events.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction events. error_collector.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_ENABLED If true, the agent captures attributes from error collection. browser_monitoring.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_ENABLED If true, the agent captures attributes from browser monitoring. span_events.attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes on span events. transaction_segments.attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes on transaction segments. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from all destinations. Allows * as wildcard at end. transaction_tracer.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction traces. Allows * as wildcard at end. transaction_events.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction events. Allows * as wildcard at end. error_collector.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from error collection. Allows * as wildcard at end. browser_monitoring.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from browser monitoring. Allows * as wildcard at end. span_events.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from span events. Allows * as wildcard at end. transaction_segments.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction segments. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE Prefix of attributes to include in all destinations. Allows * as wildcard at end. transaction_tracer.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction traces. Allows * as wildcard at end. transaction_events.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction events. Allows * as wildcard at end. error_collector.attributes.include Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_INCLUDE Prefix of attributes to include in error collection. Allows * as wildcard at end. browser_monitoring.attributes.include Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_INCLUDE Prefix of attributes to include in browser monitoring. Allows * as wildcard at end. span_events.attributes.include Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include on span events. Allows * as wildcard at end. transaction_segments.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include on transaction segments. Allows * as wildcard at end. Audit Log audit_log.enabled Type Boolean Default false Environ variable NEW_RELIC_AUDIT_LOG_ENABLED If true, enables an audit log which logs communications with the New Relic collector. audit_log.path Type String Default (Dynamic) Environ variable NEW_RELIC_AUDIT_LOG_PATH Specifies a path to the audit log file (including the filename). audit_log.endpoints Type Array Default [\".*\"] Environ variable NEW_RELIC_AUDIT_LOG_ENDPOINTS List of allowed endpoints to include in audit log Autostart autostart.denylisted_constants Type String Default \"Rails::Console\" Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_CONSTANTS Specify a list of constants that should prevent the agent from starting automatically. Separate individual constants with a comma ,. For example, Rails::Console,UninstrumentedBackgroundJob. autostart.denylisted_executables Type String Default \"irb,rspec\" Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_EXECUTABLES Defines a comma-delimited list of executables that the agent should not instrument. For example, rake,my_ruby_script.rb. autostart.denylisted_rake_tasks Type String Default Copy Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_RAKE_TASKS Defines a comma-delimited list of Rake tasks that the agent should not instrument. For example, assets:precompile,db:migrate. Cross Application Tracer cross_application_tracer.enabled Type Boolean Default false Environ variable NEW_RELIC_CROSS_APPLICATION_TRACER_ENABLED DEPRECATED Please see: distributed_tracing-enabled. If true, enables cross-application tracing when distributed_tracing.enabled is set to false. Custom Attributes custom_attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_CUSTOM_ATTRIBUTES_ENABLED If false, custom attributes will not be sent on Insights events. Custom Insights Events custom_insights_events.enabled Type Boolean Default true Environ variable NEW_RELIC_CUSTOM_INSIGHTS_EVENTS_ENABLED If true, the agent captures New Relic Insights custom events. custom_insights_events.max_samples_stored Type Integer Default 1000 Environ variable NEW_RELIC_CUSTOM_INSIGHTS_EVENTS_MAX_SAMPLES_STORED Specify a maximum number of custom Insights events to buffer in memory at a time. Disabling Use these settings to toggle instrumentation types during agent startup. disable_rake Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RAKE DEPRECATED Please see: instrumentation.rake. If true, disables Rake instrumentation. disable_samplers Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SAMPLERS If true, disables the collection of sampler metrics. Sampler metrics are metrics that are not event-based (such as CPU time or memory usage). disable_resque Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RESQUE DEPRECATED Please see: instrumentation.resque. If true, disables Resque instrumentation. disable_sidekiq Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SIDEKIQ If true, disables Sidekiq instrumentation. disable_dj Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DJ DEPRECATED Please see: instrumentation.delayed_job. If true, disables Delayed::Job instrumentation. disable_sinatra Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SINATRA DEPRECATED Please see: instrumentation.sinatra. If true , disables Sinatra instrumentation. disable_sinatra_auto_middleware Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SINATRA_AUTO_MIDDLEWARE If true, disables agent middleware for Sinatra. This middleware is responsible for advanced feature support such as cross application tracing, page load timing, and error collection. Important Cross application tracing is deprecated in favor of distributed tracing. Distributed tracing is on by default for Ruby agent versions 8.0.0 and above. Middlewares are not required to support distributed tracing. To continue using cross application tracing, update the following options in your newrelic.yml configuration file: # newrelic.yml cross_application_tracer: enabled: true distributed_tracing: enabled: false Copy disable_view_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_VIEW_INSTRUMENTATION If true, disables view instrumentation. disable_activerecord_instrumentation Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_ACTIVERECORD_INSTRUMENTATION If true, disables active record instrumentation. disable_data_mapper Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DATA_MAPPER If true, disables DataMapper instrumentation. disable_activejob Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVEJOB If true, disables ActiveJob instrumentation. disable_action_cable_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTION_CABLE_INSTRUMENTATION If true, disables Action Cable instrumentation. disable_active_storage Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVE_STORAGE If true, disables ActiveStorage instrumentation. disable_memcached Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_MEMCACHED DEPRECATED Please see: instrumentation.memcached. If true, disables instrumentation for the memcached gem. disable_memcache_client Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_MEMCACHE_CLIENT DEPRECATED Please see: instrumentation.memcache-client. If true, disables instrumentation for the memcache-client gem. disable_dalli Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_DALLI DEPRECATED Please see: instrumentation.memcache. If true, disables instrumentation for the dalli gem. disable_dalli_cas_client Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_DALLI_CAS_CLIENT DEPRECATED Please see: instrumentation.memcache. If true, disables instrumentation for the dalli gem's additional CAS client support. disable_memcache_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MEMCACHE_INSTRUMENTATION DEPRECATED Please see: instrumentation.memcache. If true, disables memcache instrumentation. disable_gc_profiler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_GC_PROFILER If true, disables the use of GC::Profiler to measure time spent in garbage collection disable_sequel_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SEQUEL_INSTRUMENTATION If true, disables Sequel instrumentation. disable_database_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DATABASE_INSTRUMENTATION DEPRECATED Use disable_sequel_instrumentation instead. disable_mongo Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MONGO DEPRECATED Please see: instrumentation.mongo. If true, the agent won't install instrumentation for the Mongo gem. disable_redis Type Boolean Default false Environ variable NEW_RELIC_DISABLE_REDIS DEPRECATED Please see: instrumentation.redis. If true, the agent won't install instrumentation for Redis. disable_vm_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_VM_SAMPLER If true, the agent won't sample performance measurements from the Ruby VM. disable_memory_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MEMORY_SAMPLER If true, the agent won't sample the memory usage of the host process. disable_cpu_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_CPU_SAMPLER If true, the agent won't sample the CPU usage of the host process. disable_delayed_job_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DELAYED_JOB_SAMPLER If true, the agent won't measure the depth of Delayed Job queues. disable_active_record_notifications Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVE_RECORD_NOTIFICATIONS If true, disables instrumentation for ActiveRecord 4, 5, and 6. disable_bunny Type Boolean Default false Environ variable NEW_RELIC_DISABLE_BUNNY DEPRECATED Please see: instrumentation.bunny. If true, disables instrumentation for the bunny gem. disable_curb Type Boolean Default false Environ variable NEW_RELIC_DISABLE_CURB DEPRECATED Please see: instrumentation.curb. If true, disables instrumentation for the curb gem. disable_excon Type Boolean Default false Environ variable NEW_RELIC_DISABLE_EXCON DEPRECATED Please see: instrumentation.excon. If true, disables instrumentation for the excon gem. disable_httpclient Type Boolean Default false Environ variable NEW_RELIC_DISABLE_HTTPCLIENT DEPRECATED Please see: instrumentation.httpclient. If true, disables instrumentation for the httpclient gem. disable_net_http Type Boolean Default false Environ variable NEW_RELIC_DISABLE_NET_HTTP DEPRECATED Please see: instrumentation.net_http. If true, disables instrumentation for Net::HTTP. disable_rack Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RACK DEPRECATED Please see: instrumentation.rack. If true, prevents the agent from hooking into the to_app method in Rack::Builder to find gems to instrument during application startup. disable_rack_urlmap Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RACK_URLMAP DEPRECATED Please see: instrumentation.rack_urlmap. If true, prevents the agent from hooking into Rack::URLMap to install middleware tracing. disable_puma_rack Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_PUMA_RACK DEPRECATED Please see: instrumentation.puma_rack. If true, prevents the agent from hooking into the to_app method in Puma::Rack::Builder to find gems to instrument during application startup. disable_puma_rack_urlmap Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_PUMA_RACK_URLMAP DEPRECATED Please see: instrumentation.puma_rack_urlmap. If true, prevents the agent from hooking into Puma::Rack::URLMap to install middleware tracing. disable_typhoeus Type Boolean Default false Environ variable NEW_RELIC_DISABLE_TYPHOEUS DEPRECATED Please see: instrumentation.typhoeus. If true, the agent won't install instrumentation for the typhoeus gem. disable_httprb Type Boolean Default false Environ variable NEW_RELIC_DISABLE_HTTPRB DEPRECATED Please see: instrumentation.httprb. If true, the agent won't install instrumentation for the http.rb gem. disable_middleware_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MIDDLEWARE_INSTRUMENTATION If true, the agent won't wrap third-party middlewares in instrumentation (regardless of whether they are installed via Rack::Builder or Rails). disable_grape Type Boolean Default false Environ variable NEW_RELIC_DISABLE_GRAPE DEPRECATED Please see: instrumentation.grape. If true, the agent won't install Grape instrumentation. Distributed Tracing distributed_tracing.enabled Type Boolean Default true Environ variable NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Distributed tracing lets you see the path that a request takes through your distributed system. Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition guide before you enable this feature. Heroku heroku.use_dyno_names Type Boolean Default true Environ variable NEW_RELIC_HEROKU_USE_DYNO_NAMES If true, the agent uses Heroku dyno names as the hostname. heroku.dyno_name_prefixes_to_shorten Type Array Default [\"scheduler\", \"run\"] Environ variable NEW_RELIC_HEROKU_DYNO_NAME_PREFIXES_TO_SHORTEN Ordinarily the agent reports dyno names with a trailing dot and process ID (for example, worker.3). You can remove this trailing data by specifying the prefixes you want to report without trailing data (for example, worker). Instrumentation instrumentation.net_http Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_NET_HTTP Controls auto-instrumentation of Net::HTTP at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.typhoeus Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_TYPHOEUS Controls auto-instrumentation of Typhoeus at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.bunny Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_BUNNY Controls auto-instrumentation of bunny at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.httprb Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_HTTPRB Controls auto-instrumentation of http.rb gem at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.resque Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RESQUE Controls auto-instrumentation of resque at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.redis Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_REDIS Controls auto-instrumentation of Redis at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.rake Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RAKE Controls auto-instrumentation of rake at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.mongo Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MONGO Controls auto-instrumentation of Mongo at start up. May be one of [enabled|disabled] . instrumentation.delayed_job Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_DELAYED_JOB Controls auto-instrumentation of Delayed Job at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.httpclient Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_HTTPCLIENT Controls auto-instrumentation of HTTPClient at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.curb Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_CURB Controls auto-instrumentation of Curb at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.sinatra Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_SINATRA Controls auto-instrumentation of Sinatra at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.rack Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RACK Controls auto-instrumentation of Rack. When enabled, the agent hooks into the to_app method in Rack::Builder to find gems to instrument during application startup. May be one of [auto|prepend|chain|disabled] . instrumentation.rack_urlmap Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_RACK_URLMAP Controls auto-instrumentation of Rack::URLMap at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.puma_rack Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_PUMA_RACK Controls auto-instrumentation of Puma::Rack. When enabled, the agent hooks into the to_app method in Puma::Rack::Builder to find gems to instrument during application startup. May be one of [auto|prepend|chain|disabled] . instrumentation.puma_rack_urlmap Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_PUMA_RACK_URLMAP Controls auto-instrumentation of Puma::Rack::URLMap at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcached Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHED Controls auto-instrumentation of memcached gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcache_client Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHE_CLIENT Controls auto-instrumentation of memcache-client gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcache Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHE Controls auto-instrumentation of dalli gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.logger Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_LOGGER Controls auto-instrumentation of Ruby standard library Logger at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.excon Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_EXCON Controls auto-instrumentation of Excon at start up. May be one of [enabled|disabled] . instrumentation.grape Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_GRAPE Controls auto-instrumentation of Grape at start up. May be one of [auto|prepend|chain|disabled] . Mongo mongo.capture_queries Type Boolean Default true Environ variable NEW_RELIC_MONGO_CAPTURE_QUERIES If true, the agent captures Mongo queries in transaction traces. mongo.obfuscate_queries Type Boolean Default true Environ variable NEW_RELIC_MONGO_OBFUSCATE_QUERIES If true, the agent obfuscates Mongo queries in transaction traces. Process Host process_host.display_name Type String Default (Dynamic) Environ variable NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Specify a custom host name for display in the New Relic UI. Rake rake.tasks Type Array Default [] Environ variable NEW_RELIC_RAKE_TASKS Specify an array of Rake tasks to automatically instrument. rake.connect_timeout Type Integer Default 10 Environ variable NEW_RELIC_RAKE_CONNECT_TIMEOUT Timeout for waiting on connect to complete before a rake task Resque resque.capture_params Type Boolean Default false Environ variable NEW_RELIC_RESQUE_CAPTURE_PARAMS DEPRECATED If true, enables the capture of job arguments for transaction traces and traced errors in Resque. Rules rules.ignore_url_regexes Type Array Default [] Environ variable NEW_RELIC_RULES_IGNORE_URL_REGEXES Define transactions you want the agent to ignore, by specifying a list of patterns matching the URI you want to ignore. Note: This will only ignore transaction events, not spans or traces from the same transation. See documentation on (ignoring specific transactions) [https://docs.newrelic.com/docs/agents/ruby-agent/api-guides/ignoring-specific-transactions/#config-ignoring] for more details. Sidekiq sidekiq.capture_params Type Boolean Default false Environ variable NEW_RELIC_SIDEKIQ_CAPTURE_PARAMS DEPRECATED If true, enables the capture of job arguments for transaction traces and traced errors in Sidekiq. Slow SQL slow_sql.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_ENABLED If true, the agent collects slow SQL queries. slow_sql.explain_threshold Type Float Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_EXPLAIN_THRESHOLD Specify a threshold in seconds. The agent collects slow SQL queries and explain plans that exceed this threshold. slow_sql.explain_enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_EXPLAIN_ENABLED If true, the agent collects explain plans in slow SQL queries. If this setting is omitted, the transaction_tracer.explain_enabled setting will be applied as the default setting for explain plans in slow SQL as well. slow_sql.record_sql Type String Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_RECORD_SQL Defines an obfuscation level for slow SQL queries. Valid options are obfuscated, raw, or none). slow_sql.use_longer_sql_id Type Boolean Default false Environ variable NEW_RELIC_SLOW_SQL_USE_LONGER_SQL_ID Generate a longer sql_id for slow SQL traces. sql_id is used for aggregation of similar queries. Span Events span_events.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ENABLED If true, enables span event sampling. span_events.queue_size Type Integer Default 10000 Environ variable NEW_RELIC_SPAN_EVENTS_QUEUE_SIZE Sets the maximum number of span events to buffer when streaming to the trace observer. span_events.max_samples_stored Type Integer Default 2000 Environ variable NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of span events reported from a single harvest. Strip Exception Messages strip_exception_messages.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_STRIP_EXCEPTION_MESSAGES_ENABLED If true, the agent strips messages from all exceptions except those in the allowlist. Enabled automatically in high security mode. strip_exception_messages.allowed_classes Type String Default \"\" Environ variable NEW_RELIC_STRIP_EXCEPTION_MESSAGES_ALLOWED_CLASSES Specify a list of exceptions you do not want the agent to strip when strip_exception_messages is true. Separate exceptions with a comma. For example, \"ImportantException,PreserveMessageException\". Thread Profiler thread_profiler.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_THREAD_PROFILER_ENABLED If true, enables use of the thread profiler. Utilization utilization.detect_aws Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_AWS If true, the agent automatically detects that it is running in an AWS environment. utilization.detect_azure Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_AZURE If true, the agent automatically detects that it is running in an Azure environment. utilization.detect_gcp Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_GCP If true, the agent automatically detects that it is running in an Google Cloud Platform environment. utilization.detect_pcf Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_PCF If true, the agent automatically detects that it is running in a Pivotal Cloud Foundry environment. utilization.detect_docker Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_DOCKER If true, the agent automatically detects that it is running in Docker. utilization.detect_kubernetes Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_KUBERNETES If true, the agent automatically detects that it is running in Kubernetes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.41057,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Ruby <em>agent</em> <em>configuration</em>",
        "sections": "Ruby <em>agent</em> <em>configuration</em>",
        "tags": "<em>Agents</em>",
        "body": "You can configure the New Relic Ruby <em>agent</em> with settings in a <em>configuration</em> file, environment variables, or programmatically with server-side <em>configuration</em>. This document summarizes the <em>configuration</em> options available for the Ruby <em>agent</em>. If the default value for a <em>configuration</em> option is (Dynamic"
      },
      "id": "603eb6f4e7b9d22a5f2f7c73"
    }
  ],
  "/docs/agents/java-agent/configuration/java-agent-error-configuration": [
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-10-18T05:35:40Z",
      "updated_at": "2021-09-27T15:21:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # Real-time profiling using Java Flight Recorder (JFR). # This feature reports dimensional metrics to the ingest endpoint configured by # metric_ingest_uri and events to the ingest endpoint configured by event_ingest_uri. # Both ingest endpoints default to US production but they will be automatically set to EU # production when using an EU license key. Other ingest endpoints can be configured manually. # Requires a JVM that provides the JFR library. jfr: # Set to true to enable Real-time profiling with JFR. # Default is false. enabled: false # Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. # Audit logging is extremely verbose and should only be used for troubleshooting purposes. # Default is false. audit_logging: false # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.62116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>configuration</em>&#x2F;<em>java</em>-<em>agent</em>-<em>configuration</em>-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    },
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "event_ingest_uri",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "metric_ingest_uri",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "JFR (Real-time profiling)",
        "audit_logging",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignoreErrorPriority",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-10-19T05:54:03Z",
      "updated_at": "2021-09-20T19:27:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. event_ingest_uri Type String Default https://insights-collector.newrelic.com/v1/accounts/events Event ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send events to other ingest endpoints (for example, EU production: https://insights-collector.eu01.nr-data.net/v1/accounts/events). extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is not currently used by the agent. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. metric_ingest_uri Type String Default https://metric-api.newrelic.com/metric/v1 Metric ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send metrics to other ingest endpoints (for example EU production: https://metric-api.eu.newrelic.com/metric/v1). proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default false Whether errors are reported for Reactor Netty. Default is false. If set to true, Reactor Netty errors will be reported. Important Only available in Java agent 6.3.0 and above. Notice, default was changed to false as of Java agent 6.5.0. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transactions total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data. Additionally the agent can expose linking metadata over JMX that can be used by other tracing systems. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata over remote JMX. Important This applies to Java agent version 6.1.0 or higher. JFR (Real-time profiling) The Java agent uses Java Flight Recorder (JFR) to collect high fidelity JVM data for Real-time profiling. Real-time profiling can be configured in the jfr stanza in the agent yaml, with system properties prefixed by newrelic.config.jfr., or with environment variables prefixed with NEW_RELIC_JFR_. enabled Type Boolean Default false Set to true to enable Real-time profiling with JFR. Important Real-time profiling with JFR is on by default in Java agent version 7.1.0. If you are on any other agent version 7.0.0 or higher, you can turn on JFR by changing the value to true. audit_logging Type Boolean Default false Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. Audit logging is extremely verbose and should only be used for troubleshooting purposes. Important This applies to Java agent version 7.0.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list exception class names you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy An environment variable can be used to list exception class names and messages you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list expected exception class names: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\" Copy An environment variable can be used to list expected exception class names and messages: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignoreErrorPriority Type Boolean Default true When multiple errors are noticed in a transaction, only the last error will be reported by default. Setting this property to false will instead report only the first error that is noticed. For more information, see the noticeError API. For example: error_collector: ignoreErrorPriority: false Copy ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messagesprefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings  OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.35988,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "sections": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> reads its <em>configuration</em> from the newrelic.yml file. By default the <em>agent</em> looks for this file in the directory that contains newrelic.jar. You can override the config file&#x27;s location by setting the newrelic.config.file system property to a fully qualified file name"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Hostname logic in Java",
        "Display names",
        "Tip",
        "Instance names",
        "Hostname logic precedence",
        "Hosts and unique agent identifiers",
        "For more help"
      ],
      "title": "Hostname logic in Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "32a9b875cf20d27be147a4ca29b749f1612d94e2",
      "image": "https://docs.newrelic.com/static/026e7b6f7910842deb3f7c1960cad008/9e32a/upload.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/hostname-logic-java/",
      "published_at": "2021-10-18T05:35:39Z",
      "updated_at": "2021-09-14T09:17:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Java agent automatically assigns a host:port name to your JVMs. If the default name is not useful, you can set a display name to distinguish your JVMs in the New Relic UI. For supported frameworks, the Java agent uses the instance name instead of the display name. The Java agent uniquely identifies running agents by their host, port, and dispatcher, regardless of the environment used. Display names If the default host:port label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. Set the display name via configuration, either in an environment variable or in your newrelic.yml config file. The environment variable takes precedence over the config file value. After the JVM is restarted and the Java agent is reporting again , the display name will show in the JVM list as seen in the example below in addition to host:port. To set a display name: Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable. OR Set process_host.display_name in your newrelic.yml. Restart your JVM to see your changes in the New Relic UI. Tip You can also set the display name with a system property. Instance names For WebSphere and WebLogic users, the Java agent also reports the instance name for each active app server instance, which is visible in the APM Settings > Environment page. Generally, this name is provided by the app server. If an instance name is set, it will be used instead of the display name in the New Relic UI. Hostname logic precedence If there are multiple hostname settings (for example, you use WebSphere and also set the display_name property), the agent uses this precedence: display_name overrides the default name, and the WebSphere and WebLogic instance names. WebSphere and WebLogic instance names override the default name. The default (host:port) name has lowest precedence. Hosts and unique agent identifiers The Java agent uses hosts, ports, and dispatchers to uniquely identify multiple JVMs reporting to the same app name. Multiple agents running on the same server are therefore reported separately, as long as their ports or dispatcher names differ. The unique identifier is based on the following values: Host: An identifier for your app's parent server that is derived from the Operating System. This value is not configurable by the Java agent. Port: The port associated with the app server. If the agent can't determine the port number, or your app is not running in an app server, defaults to 0. This value is user-configurable. Dispatcher Name: The name of the app server. For example, Apache Tomcat, Glassfish, or WebLogic. If there is no active app server, defaults to Unknown. For more help Additional documentation resources include: Setting the hostname reported by the Java agent (manually overriding the hostname settings when the link between your APM app and Servers for Linux is broken) Add, rename, and remove hosts (add and remove hosts in APM)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.90364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Hostname logic in <em>Java</em>",
        "sections": "Hostname logic in <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " name. The default (host:port) name has lowest precedence. Hosts and unique <em>agent</em> identifiers The <em>Java</em> <em>agent</em> uses hosts, ports, and dispatchers to uniquely identify multiple JVMs reporting to the same app name. Multiple <em>agents</em> running on the same server are therefore reported separately, as long"
      },
      "id": "6043cfbb64441ff20b378f0b"
    }
  ],
  "/docs/agents/java-agent/configuration/name-your-java-application": [
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-10-18T05:35:40Z",
      "updated_at": "2021-09-27T15:21:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # Real-time profiling using Java Flight Recorder (JFR). # This feature reports dimensional metrics to the ingest endpoint configured by # metric_ingest_uri and events to the ingest endpoint configured by event_ingest_uri. # Both ingest endpoints default to US production but they will be automatically set to EU # production when using an EU license key. Other ingest endpoints can be configured manually. # Requires a JVM that provides the JFR library. jfr: # Set to true to enable Real-time profiling with JFR. # Default is false. enabled: false # Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. # Audit logging is extremely verbose and should only be used for troubleshooting purposes. # Default is false. audit_logging: false # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.621155,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>configuration</em>&#x2F;<em>java</em>-<em>agent</em>-<em>configuration</em>-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    },
    {
      "sections": [
        "Java agent configuration: Config file",
        "Configuration file structure",
        "Tip",
        "Configuration settings precedence",
        "Configuring the Java extensions directory",
        "Create an extensions directory",
        "Specify an existing extensions directory",
        "General configuration settings",
        "license_key (REQUIRED)",
        "app_name (REQUIRED)",
        "agent_enabled",
        "apdex_t (DEPRECATED)",
        "appserver_port",
        "Important",
        "audit_mode",
        "ca_bundle_path",
        "use_private_ssl",
        "enable_auto_app_naming",
        "enable_auto_transaction_naming",
        "Caution",
        "enable_custom_tracing",
        "event_ingest_uri",
        "extensions.dir",
        "high_security",
        "insert_api_key",
        "labels",
        "max_stack_trace_lines",
        "metric_ingest_uri",
        "proxy_host",
        "proxy_password",
        "proxy_port",
        "proxy_user",
        "proxy_scheme",
        "reactor-netty.errors.enabled",
        "send_data_on_exit",
        "send_data_on_exit_threshold",
        "send_environment_info",
        "send_jvm_props",
        "ssl (DEPRECATED)",
        "sync_startup",
        "scala_futures_as_segments",
        "Logging configuration",
        "log_daily",
        "log_file_count",
        "log_file_name",
        "log_file_path",
        "log_level",
        "log_limit_in_kbytes",
        "JMX",
        "enabled",
        "linkingMetadataMBean",
        "JFR (Real-time profiling)",
        "audit_logging",
        "Attributes",
        "include",
        "exclude",
        "Transaction tracer",
        "explain_enabled",
        "explain_threshold",
        "insert_sql_max_length",
        "log_sql",
        "record_sql",
        "stack_based_naming (Play 2.x+ only)",
        "stack_trace_threshold",
        "top_n",
        "transaction_threshold",
        "slow_query_whitelist (DEPRECATED)",
        "collect_slow_queries_from",
        "attributes.enabled",
        "attributes.include",
        "attributes.exclude",
        "token_limit",
        "segment_limit",
        "Transaction segments",
        "Browser monitoring",
        "auto_instrument",
        "disabled_auto_pages",
        "External tracer",
        "exclude_request_uri",
        "Cross application tracer",
        "Error collector",
        "ignore_classes",
        "ignore_messages",
        "ignore_status_codes",
        "expected_classes",
        "expected_messages",
        "expected_status_codes",
        "ignoreErrorPriority",
        "ignore_errors (DEPRECATED)",
        "Strip exceptions",
        "whitelist (DEPRECATED)",
        "allowed_classes",
        "Thread profiler",
        "Transaction events",
        "max_samples_stored",
        "custom_request_headers",
        "Custom events",
        "Hostname configuration",
        "display_name",
        "ipv_preference",
        "Custom instrumentation",
        "trace_annotation_class_name",
        "com.newrelic.instrumentation.servlet-user",
        "System properties",
        "newrelic.config.process_host.display_name",
        "newrelic.config.file",
        "newrelic.debug",
        "newrelic.environment",
        "newrelic.home",
        "newrelic.logfile",
        "Environment variables",
        "NEW_RELIC_APP_NAME (REQUIRED)",
        "NEW_RELIC_DISTRIBUTED_TRACING_ENABLED",
        "NEW_RELIC_PROCESS_HOST_DISPLAY_NAME",
        "NEW_RELIC_LICENSE_KEY (REQUIRED)",
        "NEW_RELIC_LOG",
        "Cloud platform utilization",
        "detect_aws",
        "detect_docker",
        "Async instrumentation",
        "token_timeout",
        "segment_timeout",
        "Circuit breaker",
        "memory_threshold",
        "gc_cpu_threshold",
        "Message tracer",
        "segment_parameters.enabled",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Infinite Tracing",
        "trace_observer.host",
        "Span events",
        "Jar collector",
        "skip_temp_jars",
        "jars_per_second"
      ],
      "title": "Java agent configuration: Config file",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "1d61f848fa192438225eae269421b8d384915c8b",
      "image": "https://docs.newrelic.com/static/60ca967eab99ca225186310913ae2de6/8c557/java-config-cascade.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file/",
      "published_at": "2021-10-19T05:54:03Z",
      "updated_at": "2021-09-20T19:27:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent reads its configuration from the newrelic.yml file. By default the agent looks for this file in the directory that contains newrelic.jar. You can override the config file's location by setting the newrelic.config.file system property to a fully qualified file name. Configuration file structure The newrelic.yml file is split into stanzas corresponding to different environments: Test Development Staging Production (default) New Relic applies settings in the common stanza to each of these environments. You can select other environments as the default by setting the newrelic.environment system property to the environment name. Tip A newrelic.yml template is available. If you edit newrelic.yml, be careful to conform to the YAML format. Use a YAML validator to ensure the syntax is accurate before using the file with New Relic's Java agent, and follow these rules: Java agent newrelic.yml Requirements Format YML files are case sensitive. Indentations All indentations must be in increments of two characters. Other indentations will result in an Unable to parse configuration file error upon agent startup. Use the same level of indentation for data in the same stanza of the file. Indent any sub-stanzas by an additional two spaces. Changes to file You must restart your JVM host process for changes to take effect. Exception: Property changes to log_level and audit_mode do not require a restart. Property changes under circuit breaker don't require a restart. Configuration settings precedence To override any setting in the config file, use a system property override. In certain environments, environment variables can also be used to override both the config file and the system properties. The environment variables primarily exist to support Heroku. When used, server-side configuration overrides all other configuration settings. With the Java agent, server-side configuration overrides all other settings. Environment variables override Java system properties. Java properties override user configuration settings in your newrelic.yml file. User settings override the newrelic.yml default settings. Configuring the Java extensions directory The Java agent reads the configuration files on process startup. To identify the directory where the files are located, either create a new or specify an existing extensions directory: Create an extensions directory To create the extensions directory: Navigate to the directory where newrelic.jar and newrelic.yml are located. Create a directory named extensions. In newrelic.yml, check that the property extensions.dir is not set. Specify an existing extensions directory To use an existing Java extensions directory: In your newrelic.yml file, locate the common section. Use the property extensions.dir to specify the location of the file. General configuration settings Set these options in the common stanza. To override any of these options, use a newrelic.config prefixed system property. license_key (REQUIRED) Type String Default (none) This setting is required. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. app_name (REQUIRED) Type String Default (none) This setting is required. Defines the application name used to report data to New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon. For example, to report data to My Application and My Application 2 use this: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. agent_enabled Type Boolean Default true Flag to enable the agent. Use this setting to force the agent to run or not run. apdex_t (DEPRECATED) Type Float Default 1.0 The apdex_t threshold in seconds for the application's Apdex score. For Java agent versions 1.2.008 or higher, the apdex_t value is set in the UI and the value in newrelic.yml is ignored. appserver_port Type Integer Default (none) Number to differentiate JVMs for the same app on the same machine. New Relic uses host/port for uniqueness, so you can distinguish the JVMs by putting a switch like this into the startup arguments for each JVM: -Dnewrelic.config.appserver_port=8081 Copy Once you have used appserver_port to name the JVMs and restart them, you should be able to see them individually in the dropdown and in the profiling interface. Important This is only a change for New Relic; it doesn't actually affect the port on which the host communicates in any way. audit_mode Type Boolean Default false Enables plain text logging of all data sent to New Relic to the agent logfile. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. ca_bundle_path Type String Value Format /path/to/ca/cert/bundle.pem Specifies a path to a custom SSL certificate bundle that will be used by the agent to establish a secure connection to New Relic. If your custom SSL certificate bundle doesn't include certificates that are sufficient to connect to New Relic then you'll need to merge the required certs into your custom certificate bundle. use_private_ssl Type Boolean Default false The following SSL certificates are bundled into the agent jar: META-INF/certs/eu-newrelic-com.pem META-INF/certs/eu01-nr-data-net.pem META-INF/certs/newrelic-com.pem Copy By default (use_private_ssl: false) the agent will use the SSL certificates bundled into the JDK to establish a secure connection to New Relic or the custom SSL certificates bundle specified by ca_bundle_path. If you want to use the SSL certificates bundled with the agent, set use_private_ssl: true. Note: use_private_ssl will be ignored if ca_bundle_path is set. enable_auto_app_naming Type Boolean Default false Enables the reporting of data separately for each web app. Set to true to enable support for auto app naming. The name of each web app is detected automatically and the agent reports data separately for each one. This provides a finer-grained performance breakdown for web apps in New Relic. For more information, see Automatic application naming. For more methods of naming your application, see Name your Java application. enable_auto_transaction_naming Type Boolean Default true Enables component-based transaction naming. Set to true to enable component-based transaction naming. Set to false to use the URI of a web request as the name of the transaction. For more information, see Naming web transactions. Caution Unless you implement API calls to name your transactions, disabling auto-transaction naming is very likely to cause Metric grouping issues. enable_custom_tracing Type Boolean Default true Enables all instrumentation using an @Trace annotation. Disabling this causes @Trace annotations to be ignored. event_ingest_uri Type String Default https://insights-collector.newrelic.com/v1/accounts/events Event ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send events to other ingest endpoints (for example, EU production: https://insights-collector.eu01.nr-data.net/v1/accounts/events). extensions.dir Type String Default (none) Defines the location of the optional extensions directory. If this property is not set, the agent will look for a subdirectory named extensions in the same directory as newrelic.jar and newrelic.yml. high_security Type Boolean Default false In order for high security to be enabled, this property must be set to true and the high security property in the New Relic user interface must be enabled. Enabling high security means SSL is turned on, request and message queue parameters are not collected, and queries cannot be sent to New Relic in their raw form. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. insert_api_key Type String Default (none) A valid Insert API Key for your account. This is not currently used by the agent. labels Type String Default \"\" Attach tags to this app. Note that this option now enables tags, which replaced the label feature. You can still query your historical labels. max_stack_trace_lines Type Integer Default 30 Limits the number of lines the agent collects from each stack trace. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. metric_ingest_uri Type String Default https://metric-api.newrelic.com/metric/v1 Metric ingest URI used by some agent features. Defaults to the US production ingest endpoint. Can be manually configured to send metrics to other ingest endpoints (for example EU production: https://metric-api.eu.newrelic.com/metric/v1). proxy_host Type String Default (none) The proxy host through which to connect to the New Relic collector. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_password Type String Default (none) The password for proxy authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. Important The Java agent supports Basic (clear text) authentication. proxy_port Type String Default 8080 The proxy host port number. If a proxy is used, the host setting is required. Other proxy settings are optional. proxy_user Type String Default (none) The username for proxy authentication, such as Basic (clear text) authentication. If a proxy is used, the host setting is required. Other proxy settings are optional. The username and password settings will be used to authenticate to Basic Auth challenges from a proxy server. proxy_scheme Type String Default (none) The proxy scheme used. Setting proxy_scheme: \"https\" will allow the agent to connect through proxies using the HTTPS scheme. reactor-netty.errors.enabled Type Boolean Default false Whether errors are reported for Reactor Netty. Default is false. If set to true, Reactor Netty errors will be reported. Important Only available in Java agent 6.3.0 and above. Notice, default was changed to false as of Java agent 6.5.0. send_data_on_exit Type Boolean Default false Enable delayed JVM shutdown to give the agent a chance to send latest metric data to New Relic before JVM shutdown. send_data_on_exit_threshold Type Integer Default 60 The number of seconds after which the agent will use the send_data_on_exit setting. send_environment_info Type Boolean Default true Enable reporting of JVM settings to New Relic. send_jvm_props Type Boolean Default true When set to true, JVM properties will be sent to New Relic. ssl (DEPRECATED) Type Boolean Default true Requires connections to the New Relic collector to go over SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. This work is done asynchronously to the threads that process your application code, so response times will not be directly affected by this change. Important As of Java agent 3.48.0, SSL is enabled by default and the config option to disable it has been deprecated. As of Java agent 4.0.0, the ability to disable SSL has been removed. sync_startup Type Boolean Default false Enable the agent to connect the New Relic collector immediately upon app startup. scala_futures_as_segments Important This applies to Java agent version 3.44.0 or higher. Type Boolean Default false For more concise transaction trace details, the agent does not report Scala Futures as transaction segments, and those Futures do not contribute to the transactions total time. Enabling scala_futures_as_segments increases your overhead. If you want Scala Futures to report as transaction segments so you can view them in a transaction trace, you can enable it: scala_futures_as_segments: enabled: true Copy Logging configuration These are part of the general configuration variables. They are broken out here because they are frequently tweaked for debugging. Some of the logging configuration variables are dynamic and do not need a host restart for them to take effect. For instance, if log files are growing too quickly, log_level can be set to a less verbose setting to reduce the reporting rate. Here is the order of precedence for configuration variables affecting log rotation. If log_daily is true, other log rotation settings are ignored. If log_file_count is 1 or 0, the size limit is ignored. Finally, the agent applies log_limit_in_kbytes. Depending on the growth rate, it is possible for the log file size to exceed the configured value by a small amount. log_daily Type Boolean Default false Set to true to roll the logs daily. Overrides the other configuration variables that affect log rotation. log_file_count Type Integer Default 1 The maximum number of log files to keep when using log rotation. log_file_name Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. log_file_path Type String Default logs subdirectory where newrelic.jar is located The log file path. Tip If log_file_path is specified, the directory must already exist. If the default value is used, the agent will attempt to create the directory. log_level Type String Default info The log verbosity level. The agent uses its own log file to keep its logging separate from that of your application. Valid options, in order of verboseness, are: off severe warning info fine finer finest This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. log_limit_in_kbytes Type Integer Default 0 The log file size in kilobytes at which log files are rotated. Set to 0 for no limit. JMX To set these options, use the jmx stanza. To override them, use a newrelic.config.jmx prefixed system property. The Java agent uses JMX to collect JVM data. Additionally the agent can expose linking metadata over JMX that can be used by other tracing systems. enabled Type Boolean Default true This setting can be used to turn on or off all JMX functionality. linkingMetadataMBean Type Boolean Default false This setting can be enabled to allow the Java agent to expose linking metadata over remote JMX. Important This applies to Java agent version 6.1.0 or higher. JFR (Real-time profiling) The Java agent uses Java Flight Recorder (JFR) to collect high fidelity JVM data for Real-time profiling. Real-time profiling can be configured in the jfr stanza in the agent yaml, with system properties prefixed by newrelic.config.jfr., or with environment variables prefixed with NEW_RELIC_JFR_. enabled Type Boolean Default false Set to true to enable Real-time profiling with JFR. Important Real-time profiling with JFR is on by default in Java agent version 7.1.0. If you are on any other agent version 7.0.0 or higher, you can turn on JFR by changing the value to true. audit_logging Type Boolean Default false Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. Audit logging is extremely verbose and should only be used for troubleshooting purposes. Important This applies to Java agent version 7.0.0 or higher. Attributes To set these options, use the attributes stanza. To override them, use a newrelic.config.attributes prefixed system property. Attributes are key-value pairs that provide information for transaction traces, traced errors, browser monitoring, and transaction events. There is also an attribute stanza under each destination. For more information, see Java agent attributes, Enabling and disabling attributes and Attribute examples. enabled Type Boolean Default true This setting can be used to turn on or off all attributes. Important For security reasons, capturing custom attributes using the Custom Instrumentation Editor is set to false by default. include Type List of Strings Default (none) If attributes are enabled, attribute keys found in this list will be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic. Separate the keys in the list with a comma; for example: key1, key2, key3 Copy Also refer to the agent attribute rules. Transaction tracer These options are set in the transaction_tracer stanza and can be overridden by using a newrelic.config.transaction_tracer prefixed system property. Transaction tracing captures deep information about slow transactions and sends this to the New Relic service. The transaction includes the exact call sequence of the transactions, including any query statements issued. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true The transaction tracer is enabled by default. Set this to false to turn it off. explain_enabled Type Boolean Default true Determines whether the agent will capture the EXPLAIN plan for slow queries. Only supported for MySQL and PostgreSQL. explain_threshold Type Float Default 0.5 Threshold in seconds for query execution time below which the slow query and the EXPLAIN plan (if supported) will not be captured. Relevant to slow queries only when record_sql is set to raw or obfuscated. Relevant to EXPLAIN plans only when explain_enabled is set to true. insert_sql_max_length Type Integer Default 2000 The character limit for the SQL query string. If you have many slow SQL queries with large chunks of information, this could negatively affect performance or how quickly you see your data in New Relic. Increase the value gradually until you find the right balance of information and performance. log_sql Type Boolean Default false Set to true to enable logging of queries to the agent log file instead of uploading to New Relic. Queries are logged using the record_sql mode. record_sql Type String Default obfuscated When the transaction tracer is on, query statements can optionally be recorded. The recorder has three modes: off: Send no queries. raw: Send the query statement in its original form. obfuscated: Strips out numeric and string literals. stack_based_naming (Play 2.x+ only) Type Boolean Default False Defaulted to true until Java agent version 3.12.1, when it was changed to false. This option is for Play 2.x+ only. Play/Scala instrumentation can use Thread.getStackTrace() to improve tracer naming, but at the cost of increased overhead. stack_trace_threshold Type Integer Default 0.5 Defines a threshold (in seconds) for collecting stack traces from an SQL call. When SQL statements exceed this threshold, the agent will capture the current stack trace. This is useful for pinpointing where long SQL calls originate from. top_n Type Integer Default 20 Use this setting to control the variety of your transaction traces. top_n is an integer that represents the number of unique, slow transactions that traces will be created for. If you want transaction traces to more accurately reflect the actual slowest transactions in your app, make this value lower. If you want to sample a more diverse array of transactions, make the value higher. A value of 0 would mean that only the slowest transaction is always traced. This is considered not to be optimal, though, because you may have one or two transactions that are always the slowest, and repeatedly seeing those same transaction traces will probably not give you much value. If the same transaction is often the slowest, the top_n setting allows the Java agent (over time) to sample the slowest n transactions. This gives you greater variety and more insight into your application. transaction_threshold Type String (float) Default apdex_f The time threshold used to determine when a transaction is eligible to be traced. When the transaction's response time exceeds this threshold, a transaction trace will be recorded and sent to New Relic. The default is apdex_f (default), which sets the threshold to be the \"Frustrated\" Apdex level (four times the apdex_t value). You can also set a specific time threshold by entering a float value that represents a number of seconds. slow_query_whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use collect_slow_queries_from. By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: slow_query_whitelist: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy collect_slow_queries_from Type String Default (none) By default, high security mode does not allow the agent to collect slow queries. Enable this option to collect Cassandra queries from the DataStax driver, even with high security enabled. If you don't use high security, the agent collects slow queries automatically. For DataStax driver 2.1.2, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-2.1.2' Copy For DataStax driver 3.0.0, add this rule to your allow list: transaction_tracer: collect_slow_queries_from: 'com.newrelic.instrumentation.cassandra-datastax-3.0.0' Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction traces. If attributes.enabled at the root level is false, no attributes will be sent to transaction traces regardless on how this property (transaction_tracer.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction traces, all attribute keys found in this list will be sent to New Relic in transaction traces. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction traces. For more information, see the agent attribute rules. token_limit Type Integer Default 3000 Limits the number of Tokens that can be created per Transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. segment_limit Type Integer Default 3000 Limits the number of segments that can be created per transaction. Increasing this value may impact performance, because it increases the amount of memory the agent uses and the amount of data sent to New Relic. Transaction segments These options are set in the transaction_segments stanza and can be overridden by using a newrelic.config.transaction_segments prefixed system property. Transaction segments represent discrete pieces of work (generally method calls) and are displayed within transaction traces. Important Transaction segment attribute filtering requires Java agent version 4.10.0 or higher. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction segments. If attributes.enabled at the root level is false, no attributes will be sent to transaction segments regardless on how this property (transaction_segments.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for transaction segments, all attribute keys found in this list will be sent to New Relic in transaction segments. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction segments. For more information, see the agent attribute rules. Browser monitoring These options are set in the browser_monitoring stanza and can be overridden by using a newrelic.config.browser_monitoring prefixed system property. Browser monitoring gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. auto_instrument Type Boolean Default true By default the agent automatically inserts API calls in compiled JSPs to inject the monitoring JavaScript into web pages. Set this attribute to false to turn off this behavior. disabled_auto_pages Type Comma-separated list of strings Default (none) When auto_instrument is true, by default all pages are instrumented. List all pages that you want the auto instrumentation to skip here. You can still use manual instrumentation on these pages. For example: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy attributes.enabled Type Boolean Default false This setting can be used to turn on or off all attributes for browser monitoring. This is the data you can query. If attributes.enabled is false at the root level, no attributes will be sent up in browser monitoring regardless on how this property under browser_monitoring is set. attributes.include Type List of Strings Default (none) If attributes are enabled for browser_monitoring, all attribute keys found in this list will be sent to New Relic in page views. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in page views. For more information, see the agent attribute rules. External tracer The external tracing options are set in the external_tracer stanza and can be overridden by using a newrelic.config.external_tracer prefixed system property. exclude_request_uri Type Boolean Default false This setting can be used to control the collection of outgoing request URIs for errors and transaction traces. Set this to true to disable collecting this information. Cross application tracer The cross application tracing options are set in the cross_application_tracer stanza and can be overridden by using a newrelic.config.cross_application_tracer prefixed system property. Cross application tracing adds request and response headers to external calls using the Apache HttpClient libraries. This provides better performance data when calling applications monitored by other New Relic Agents. enabled Type Boolean Default true Cross application tracing is enabled by default. Set this to false to turn it off. Error collector These options are set in the error_collector stanza and unless noted otherwise can be overridden by using a newrelic.config.error_collector prefixed system property. The error collector captures information about uncaught exceptions and sends them to New Relic for viewing. Tip For how to configure errors for the Java agent, including how to configure errors via the UI, see Java agent error configuration. enabled Type Boolean Default true Enable error collection. ignore_classes Type Stanza containing a list of fully qualified class_name strings Default (none) Specified exception class names will be ignored and will not affect error rate or Apdex score, or be reported to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list exception class names you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy ignore_messages Type Stanza containing a fully qualified class_name and a list of messages per error class Default (none) Specify exception class names the agent should ignore. Ignored messages will not affect error rate or Apdex score, or be reported to APM. Contains yaml pairs consisting of: A fully qualified exception class name that should not be reported to APM AND A list of exception messages to match against (at least one is required) If the exception class name matches an error but the message does not, then that error will not be ignored. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_messages: com.example.MyException: - \"Some error message to ignore\" - \"Some other error message to ignore\" com.example.DifferentException: - \"Some different error message to ignore\" Copy An environment variable can be used to list exception class names and messages you want to be ignored: NEW_RELIC_ERROR_COLLECTOR_IGNORE_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy ignore_status_codes Type Comma-separated list of strings and ranges Default 404 A comma-separated list comprised of individual and dashed ranges of HTTP status codes that should not be treated as errors. If this property is commented out in the newrelic.yml configuration file, then the 404 status code will automatically be ignored. When using server-side configuration, the status code 404 must be specified in order for it to be ignored. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: ignore_status_codes: 404,507-511 Copy expected_classes Type Stanza containing a List of fully qualified class_name strings Default (none) Prevents specified exception classes from affecting error rate or Apdex score while still reporting the errors to APM. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_classes: - \"com.example.MyException\" - \"com.example.DifferentException\" Copy An environment variable can be used to list expected exception class names: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_CLASSES=\"[\\\"com.example.MyException\\\", \\\"com.example.DifferentException\\\"]\" Copy expected_messages Type Stanza containing a fully qualified class_name and a List of messages per error class Default (none) Contains yaml pairs consisting of a fully qualified exception class name that should be marked as expected and thus prevented from affecting error rate or Apdex score and a List of exception messages to match against, the latter of which at least one is required. If the exception class name matches an error but the message does not, then that error will not be marked as expected and therefore will affect error rate and Apdex score. Message strings use contains for matching. A message cannot be provided on its own and must always be paired with a fully qualified class name. Cannot be specified by system property. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_messages: com.example.MyException: - \"Some expected error message\" - \"Some other expected error message\" com.example.DifferentException: - \"Some different expected error message\" Copy An environment variable can be used to list expected exception class names and messages: NEW_RELIC_ERROR_COLLECTOR_EXPECTED_MESSAGES=\"{\\\"com.example.MyException\\\": [\\\"Some error message to ignore\\\", \\\"Some other error message to ignore\\\"], \\\"com.example.DifferentException\\\": [\\\"Some different error message to ignore\\\"]}\" Copy expected_status_codes Type Comma-separated list of strings and ranges Default (none) A comma-separated list comprised of individual and dashed ranges of HTTP status codes to be marked as expected and thus prevented from affecting error rate or Apdex score. This setting is dynamic, so running agents will notice changes to newrelic.yml without a JVM restart. For example: error_collector: expected_status_codes: 415,500-506 Copy attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for traced errors. If attributes.enabled is false at the root level, then no attributes will be sent to traced errors regardless of how this property is set under error_collector. attributes.include Type List of strings Default (none) If attributes are enabled for traced errors, all attribute keys found in this list will be sent to New Relic in traced errors. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) Attribute keys found in this list will not be sent to New Relic in traced errors. For more information, see the agent attribute rules. ignoreErrorPriority Type Boolean Default true When multiple errors are noticed in a transaction, only the last error will be reported by default. Setting this property to false will instead report only the first error that is noticed. For more information, see the noticeError API. For example: error_collector: ignoreErrorPriority: false Copy ignore_errors (DEPRECATED) Type Comma-separated list of Strings Default (none) All specified exception class names specified will not be treated as errors. Deprecated as of Java agent 3.40.0 and replaced by ignore_classes. For example: error_collector: ignore_errors: some.other.MyException Copy Strip exceptions These options are set in the strip_exception_messages stanza and unless noted otherwise can be overridden by using a newrelic.config.strip_exception_messagesprefixed system property. This configuration can be enabled to control whether Java exception messages are reported to New Relic. enabled Type Boolean Default false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you set this to true, the agent strips the messages from exceptions in order to prevent it from inadvertently capturing sensitive information. If you enable high security mode, this is automatically set to true. If you set enabled to true but you want the agent to capture messages from specific exceptions, add the exceptions to your allow list. whitelist (DEPRECATED) Type String Default (none) Important This config has been deprecated as of agent version 5.10.0 and will be removed in a future agent version. Instead use allowed_classes. If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to the whitelist, separated by a comma. allowed_classes Type String Default (none) If you set enabled to true but you want the agent to capture messages for specific exceptions, add each exception to allowed_classes, separated by a comma. Thread profiler These options are set in the thread_profiler stanza and can be overridden by using a newrelic.config.thread_profiler prefixed system property. Thread profiler measures wall clock time, CPU time, and method call counts in your application's threads as they run. enabled Type Boolean Default true Enable the thread profiler. Transaction events These options are set in the transaction_events stanza and can be overridden by using a newrelic.config.transaction_events prefixed system property. Transaction events provide the data for displaying histograms and percentiles in the UI. Important Previously this stanza was called analytics_events. If your configuration file still uses analytics_events, update your agent to use transaction_events. enabled Type Boolean Default true Enable the transaction events service. max_samples_stored Type Integer Default 2000 Max 10000 The maximum number of sampled transaction events reported every 60 seconds. custom_request_headers Type List of maps Default None Important Unlike other settings, custom_request_headers have to be paired together and must be set in the newrelic.yml file. They can't be overwritten by Java virtual machine arguments (system property) or environment variables. A list of maps with the paired keys header_name and the optional header_alias. Choose one or more custom HTTP request headers to add as transaction attributes. You can list multiple header configurations: transaction_events: custom_request_headers: - header_name: \"X-Custom-Header-1\" - header_name: \"X-Custom-Header-2\" header_alias: \"CustomHeader2alias\" Copy In the first map set, X-Custom-Header-1 is captured and reported by the agent as the header name for a corresponding value from the request object. The header_name will also be the name of the attribute sent to New Relic. In the second map set, the request header is X-Custom-Header-2, but the CustomHeader2alias is the name sent to New Relic. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for transaction events. If attributes.enabled is false at the root level, then no attributes will be sent to transaction events regardless of how this property is set under transaction_events. attributes.include Type List of Strings Default (none) If attributes are enabled for transaction events, all attribute keys found in this list will be sent to New Relic in transaction events. For more information, see the agent attribute rules. attributes.exclude Type List of Strings Default (none) All attribute keys found in this list will not be sent to New Relic in transaction events. For more information, see the agent attribute rules. Custom events Custom events are set in the custom_insights_events stanza and can be overridden by using a newrelic.config.custom_insights_events prefixed system property. APM lets you record custom event data via the New Relic language agent APIs, which you can then query. Important For Java agent versions prior to 4.1.0, the following YAML configuration is recognized: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy For agent versions 4.1.0 and above, the YAML configuration uses the nested stanza formatting: custom_insights_events: enabled: false max_samples_stored: 5000 Copy enabled Type Boolean Default true This enables the custom event service. max_samples_stored Type Integer Default/Max 10000 The maximum number of sampled custom events reported every 60 seconds. Hostname configuration These options are set in the process_host stanza and can be overridden by using a newrelic.config.process_host prefixed system property. These properties are used for configuring the hostname displayed in the UI: display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. ipv_preference Type String Default 4 If the hostname cannot be determined, then the IP address of the host will be used. This property determines whether the IPv4 or IPv6 address should be used. The default is IPv4. Custom instrumentation These options set in the class_transformer stanza and can be overridden by using a newrelic.config.class_transformer prefixed system property. trace_annotation_class_name Type String Default (none) String containing the full class name of the annotation class the agent uses to determine which user-specified methods to instrument. For more information about custom annotations, see Java custom metric collection. com.newrelic.instrumentation.servlet-user Type Boolean Default false Enable this option to capture the userPrincipal name. This name is included as a transaction trace attribute, and can be queried. System properties You can override any setting in the newrelic.yml file by setting a system property. The system property corresponding to a given setting in the config file is the setting name prefixed by newrelic.config. For example, the system property for the log_level setting is newrelic.config.log_level. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the system property for the enabled setting in the transaction_tracer stanza is newrelic.config.transaction_tracer.enabled. In addition to overriding configuration settings, the following system properties are recognized by the agent: newrelic.config.process_host.display_name Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. Requires Java agent 3.17 or higher. newrelic.config.file Type String Default (none) String containing a fully qualified path to the newrelic configuration file. If empty, the agent assumes newrelic.yml is in the same directory as newrelic.jar. newrelic.debug Type Boolean Default (none) Enable debug logging. newrelic.environment Type String Default (none) String containing the environment configuration for the agent to use. newrelic.home Type String Default (none) String containing the home directory of agent. This defaults to the same directory as the agent jarfile. newrelic.logfile Type String Default newrelic_agent.log String containing the name of the agent log file. Environment variables Environment variables take the highest precedence and override the system properties and yml config settings. To set environment variables, use the export VARNAME=value command. To permanently set environment variables, add the export line to a file such as ~/.bashrc or ~/.bash_profile. You can override any setting from a system property or in the newrelic.yml by setting an environment variable. The environment variable corresponding to a given setting in the config file is the setting name prefixed by NEW_RELIC with all dots (.) and dashes (-) replaced by underscores (_). For example, the environment variable for the log_level setting is NEW_RELIC_LOG_LEVEL. For settings nested in stanzas, prepend the stanza name to the setting name. For example, the environment variable for the enabled setting in the transaction_tracer stanza is NEW_RELIC_TRANSACTION_TRACER_ENABLED. Important Agent configuration via environment variables requires Java agent version 4.10.0 or higher. For agent versions older than 4.10.0 the following environment variables are available: NEW_RELIC_APP_NAME (REQUIRED) Type String Default (none) This setting is required. Contains the application name under which to report data to New Relic. Set the name of your application as you want it to appear in New Relic. If enable_auto_app_naming is false, the agent reports all data to this application. Otherwise, the agent reports only background tasks (transactions for non-web applications) to this application. To report data to more than one application, separate the application names with a semicolon ;. For example, to report data to My Application and My Application 2: app_name: My Application;My Application 2 Copy For more methods of naming your application, see Name your Java application. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Type String Default false Enables distributed tracing. Case sensitive: use true or false. For more information, see the distributed tracing section. NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Type String Default (none) Set a display name to decorate the \"host:port\" label in the New Relic UI. NEW_RELIC_LICENSE_KEY (REQUIRED) Type String Default (none) This setting is required. Contains your New Relic account license. You must specify the license key associated with your New Relic account. This key binds your agent's data to your account in the New Relic service. NEW_RELIC_LOG Type String Default newrelic_agent.log The unqualified log file name or the string STDOUT which will log to standard out. Cloud platform utilization These options are set in the utilization stanza and can be overridden by using a newrelic.config.utilization prefixed system property. The agent collects utilization information and sends it to the New Relic service. The agent can collect information from Amazon Web Services (AWS) EC2 instances and Docker containers. detect_aws Type Boolean Default true Determines whether the agent polls AWS metadata API. detect_docker Type Boolean Default true Determines whether the agent reads Docker information from the file system. Async instrumentation These options are set directly in the common stanza and can be overridden by using a prefixed system property. token_timeout Type Integer Default (seconds) 180 The number of seconds after which the agent will automatically expire an async token that has not been explicitly expired with token.expire(). For usage instructions, see Tokens: Connect async threads. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to unexpired tokens. segment_timeout Type Integer Default (seconds) 600 The number of seconds after which the agent will automatically end a segment that has not been explicitly ended with segment.end() or segment.ignore(). For usage instructions, see Segments: Time arbitrary async activity. Important Increasing this value may impact performance, because it increases the amount of memory the agent uses and prevents transactions from being reported due to un-ended segments. Circuit breaker These settings customize the behavior of the Java circuit breaker. These settings are not included in newrelic.yml by default. You do not need to restart your JVM after changing them. If you want to customize the circuit breaker, add the stanza under the common stanza: common: &default_settings  OTHER_CONFIG_SETTINGS circuitbreaker: enabled: true memory_threshold: 20 gc_cpu_threshold: 10 Copy enabled Type Boolean Default true If your application is behaving as expected, you may want to disable the circuit breaker. memory_threshold Type Integer (0 to 100) Default 20 Customize the precentage of free heap memory below which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. gc_cpu_threshold Type Integer (0 to 100) Default 10 Customize the precentage of garbage collection CPU time above which the circuit breaker should trip. When the percentage of free heap memory is less than memory_threshold, and the CPU time spent doing garbage collection is greater than gc_cpu_threshold, the circuit breaker trips. In order to make the circuit breaker less likely to trip, decrease memory_threshold and/or increase gc_cpu_threshold. Adjust these values as needed, based on your application's operating performance and behavior. Message tracer These options are set in the message_tracer stanza and can be overridden by using a newrelic.config.message_tracer prefixed system property. segment_parameters.enabled Type Boolean Default true Adds message properties to tracer attributes. Set this to false to turn it off. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the transition guide. Requires Java agent version 4.3.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. In the config file, it can be set in the distributed_tracing stanza. It can be overridden using a newrelic.config.distributed_tracing prefixed system property. enabled Type Boolean Default false Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: enabled: true Copy To enable this using a system property, you would use: -Dnewrelic.config.distributed_tracing.enabled=true Copy exclude_newrelic_header Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. For example, to exclude newrelic headers in the config file, you would use: distributed_tracing: exclude_newrelic_header: true Copy To exclude newrelic headers using a system property, you would use: -Dnewrelic.config.distributed_tracing.exclude_newrelic_header=true Copy Infinite Tracing Important Requirements: Java Agent 5.12.1 or higher. Infinite Tracing does not work if enable_auto_app_naming is enabled. To turn on Infinite Tracing, enable distributed tracing and add the additional setting below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default None For help getting a valid Infinite Tracing trace observer host entry, see find or create a Trace Observer. You can configure this via YAML: infinite_tracing: trace_observer: host: YOUR_TRACE_OBSERVER_HOST Copy You can also use the system property newrelic.config.infinite_tracing.trace_observer.host or the environment variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST. Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza and can be overridden by using a newrelic.config.span_events prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable span event reporting. attributes.enabled Type Boolean Default true This setting can be used to turn on or off all attributes for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this property (span_events.attributes.enabled) is set. attributes.include Type List of strings Default (none) If attributes are enabled for span events, all attribute keys found in this list will be sent to New Relic in span_events. For more information, see the agent attribute rules. attributes.exclude Type List of strings Default (none) All attribute keys found in this list will not be sent to New Relic in span events. For more information, see the agent attribute rules. Important Span event attribute filtering requires Java agent version 4.10.0 or higher. Jar collector The Java agent collects and information about jars and their versions on the application classpath. Jar collection configuration is set in the jar_collector stanza and can be overridden by using a newrelic.config.jar_collector prefixed system property. Options include: enabled Type Boolean Default true Used to enable/disable jar collection and reporting. skip_temp_jars Type Boolean Default true Used to enable/disable collection of temporary jars. Temporary jars are those residing in the directory specified by the system property java.io.tmpdir. jars_per_second Type Integer Default 10 The maximum number of jars to process per second. Must be positive.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.35986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "sections": "<em>Java</em> <em>agent</em> <em>configuration</em>: Config file",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> reads its <em>configuration</em> from the newrelic.yml file. By default the <em>agent</em> looks for this file in the directory that contains newrelic.jar. You can override the config file&#x27;s location by setting the newrelic.config.file system property to a fully qualified file name"
      },
      "id": "603eb739e7b9d2a2432a07e0"
    },
    {
      "sections": [
        "Hostname logic in Java",
        "Display names",
        "Tip",
        "Instance names",
        "Hostname logic precedence",
        "Hosts and unique agent identifiers",
        "For more help"
      ],
      "title": "Hostname logic in Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "32a9b875cf20d27be147a4ca29b749f1612d94e2",
      "image": "https://docs.newrelic.com/static/026e7b6f7910842deb3f7c1960cad008/9e32a/upload.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/hostname-logic-java/",
      "published_at": "2021-10-18T05:35:39Z",
      "updated_at": "2021-09-14T09:17:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Java agent automatically assigns a host:port name to your JVMs. If the default name is not useful, you can set a display name to distinguish your JVMs in the New Relic UI. For supported frameworks, the Java agent uses the instance name instead of the display name. The Java agent uniquely identifies running agents by their host, port, and dispatcher, regardless of the environment used. Display names If the default host:port label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. Set the display name via configuration, either in an environment variable or in your newrelic.yml config file. The environment variable takes precedence over the config file value. After the JVM is restarted and the Java agent is reporting again , the display name will show in the JVM list as seen in the example below in addition to host:port. To set a display name: Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable. OR Set process_host.display_name in your newrelic.yml. Restart your JVM to see your changes in the New Relic UI. Tip You can also set the display name with a system property. Instance names For WebSphere and WebLogic users, the Java agent also reports the instance name for each active app server instance, which is visible in the APM Settings > Environment page. Generally, this name is provided by the app server. If an instance name is set, it will be used instead of the display name in the New Relic UI. Hostname logic precedence If there are multiple hostname settings (for example, you use WebSphere and also set the display_name property), the agent uses this precedence: display_name overrides the default name, and the WebSphere and WebLogic instance names. WebSphere and WebLogic instance names override the default name. The default (host:port) name has lowest precedence. Hosts and unique agent identifiers The Java agent uses hosts, ports, and dispatchers to uniquely identify multiple JVMs reporting to the same app name. Multiple agents running on the same server are therefore reported separately, as long as their ports or dispatcher names differ. The unique identifier is based on the following values: Host: An identifier for your app's parent server that is derived from the Operating System. This value is not configurable by the Java agent. Port: The port associated with the app server. If the agent can't determine the port number, or your app is not running in an app server, defaults to 0. This value is user-configurable. Dispatcher Name: The name of the app server. For example, Apache Tomcat, Glassfish, or WebLogic. If there is no active app server, defaults to Unknown. For more help Additional documentation resources include: Setting the hostname reported by the Java agent (manually overriding the hostname settings when the link between your APM app and Servers for Linux is broken) Add, rename, and remove hosts (add and remove hosts in APM)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.90363,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Hostname logic in <em>Java</em>",
        "sections": "Hostname logic in <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " name. The default (host:port) name has lowest precedence. Hosts and unique <em>agent</em> identifiers The <em>Java</em> <em>agent</em> uses hosts, ports, and dispatchers to uniquely identify multiple JVMs reporting to the same app name. Multiple <em>agents</em> running on the same server are therefore reported separately, as long"
      },
      "id": "6043cfbb64441ff20b378f0b"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/circuit-breaker-java-custom-instrumentation": [
    {
      "sections": [
        "Java XML instrumentation examples",
        "Edit XML file in UI",
        "XML file format",
        "Caution",
        "Root node: extension",
        "Instrumentation (child of extension)",
        "Pointcut (child of instrumentation)",
        "Child nodes for pointcut",
        "Child nodes for method",
        "Example",
        "Sample class",
        "Sample XML instrumentation file and explanation"
      ],
      "title": "Java XML instrumentation examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "e34a060717cb5620eec03de5dcf19f1be0b82fcf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples/",
      "published_at": "2021-10-18T05:38:05Z",
      "updated_at": "2021-07-09T00:54:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file that lists the methods and classes you want to instrument. This documentation shows an example XML instrumentation file. For more information, see Java instrumentation by XML. Edit XML file in UI To edit your XML file directly from the New Relic UI: Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. Select an edit existing XML file. Search the instrumentation history. XML file format The XML file format includes root and child nodes. Caution Do not instrument all of your methods, as this can lead to a metric grouping issue. Root node: extension The root node of an XML file is extension. It can have three different attributes: Value Definition name A unique but descriptive name identifying your XML extension. enabled Identifies whether the extension will be read by the Java agent. Default is true. If false, New Relic will ignore the extension. version The version of the extension. If two extensions have the same name, only the extension with the highest version will be used. Instrumentation (child of extension) The instrumentation node is a child of extension. It can have one attribute: metricPrefix. This is the prefix used for the metric names when the nameTransaction node is not specified. Default is CUSTOM. Pointcut (child of instrumentation) The pointcut is a child node of instrumentation and can have several attributes. Also, a pointcut can have several different child nodes. Value Definition transactionStartPoint If a transaction is not already in progress when this pointcut is reached, then a transaction will be started. If a transaction is already in progress, then that transaction will continue. A new transaction will not be created. metricNameFormat The name format to use for a metric. If not present, then this will default to the class name followed by the method name. You can only set the metricNameFormat on pointcuts where transactionStartPoint is set to false. excludeFromTransactionTrace When true the transaction trace will not be provided if this pointcut initiates the transaction. If the pointcut is reached in the middle of a transaction, then the transaction trace will still be present, but this method will be excluded from the call graph. ignoreTransaction When true the entire transaction will be ignored. transactionType Sets the type of the transaction. Possible values are background (default, reported as a non-web transaction) and web (reported as a web transaction). Child nodes for pointcut A pointcut can have several different child nodes: Value Definition nameTransaction If this element is present, the agent will name the transaction using the class name and method(s) instrumented by this pointcut. methodAnnotation The case sensitive full name of an annotation class including the package name. All methods that are marked with this annotation will be matched. className The case sensitive name of the class to match, including the package name. Pair this node with the method node. If this node is present on a pointcut, then the interfaceName node cannot be present on the same pointcut node. The className node has the attribute includeSubclasses. If true the methods on the class with the matching name will be instrumented along with the matching methods on any child class of this class. If false (default), only methods on the exact class specified will be instrumented. The className must follow these rules: Inner classes can be instrumented. The full package structure with dots between packages must be used. To match subclasses of the specified class, set the attribute includeSubclasses to true. interfaceName The case sensitive name of an interface, including the package name, whose implementation classes will be matched. Pair this node with the method node. If this node is present on a pointcut, then the className node cannot be present on the same pointcut node. The interfaceName must follow this rule: The full package structure with dots between packages must be used. method A method on the class to instrument. Pair this node with a className node. Also, the method node can have children. traceByReturnType The class name, including package, in the format used in bytecode, e.g. Ljava/lang/String;. All methods that return an object of that class will be matched. traceLambda A boolean indicating whether to match lambdas. The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non static methods (defaults to false); pattern - a string with the pattern to search for the lambda methods. Child nodes for method The method node can have several children. For more information and examples, see Troubleshooting Java custom instrumentation. Value Definition name The exact case sensitive name of the method to match. A method name node must follow these rules: Public, protected, private, and package methods can all be instrumented. Static and instance methods can be instrumented. Constructors cannot be instrumented. parameters The parameter types of the method specified in order. If the parameters element is not present, then all methods matching the name will be matched. This includes private and protected declarations. A method parameters node contains a list of the method's parameters, specified by type elements. Here are the major rules for the type elements: Primitives are specified using their normal name: int, float, double, long, byte, short, boolean, char. Objects require a full package structure. For example, do not use String in the XML; instead, use java.lang.String. Do not use generics with collection objects. For example, write java.util.List instead of java.util.List<String>. Include brackets for arrays. For example, an array of integers will be int[ ] and an array of strings will be java.lang.String[ ]. Include two sets of brackets for an array of arrays. For example, an array of arrays of longs would be long[ ][ ]. To send the parameter as an analytic event to New Relic One, add an XML attribute to the type element called attributeName. To use a method with no parameters, the parameters node needs to be present to match a \"no arguments\" method. returnType The case sensitive name of a class indicating a return type to match. All methods that return this class type will be matched. Example Here is a sample class and an XML file that could be used to instrument that class. Sample class package test; import java.util.HashMap; import java.util.Map; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class SampleTester { private String configName; private Map<String, Long> maxSampleTimes; public SampleTester(String pConfigName) { configName = pConfigName; maxSampleTimes = new HashMap<>(); } public void checkSample(String name, long[] times) { if (times != null) { maxSampleTimes.put(name, getFirst(times)); } else { maxSampleTimes.put(name, (long) getFirst()); } } private Long getFirst(long[] times) { return times[0]; } private int getFirst() { return 0; } public void printMaxRepeat(final long max) throws Exception { Runnable myRunnable = new Runnable() { public void run() { try { printMax(max); } catch (Exception e) { e.printStackTrace(); } } }; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(1); scheduledExecutor.scheduleWithFixedDelay(myRunnable, 0, 10000, TimeUnit.MILLISECONDS); } private void printMax(long max) { System.out.println(\"max is \" + max); } } Copy Sample XML instrumentation file and explanation <?xml version=\"1.0\" encoding=\"UTF-8\"?> <extension xmlns=\"https://newrelic.com/docs/java/xsd/v1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"newrelic-extension extension.xsd \" name=\"customExtension\" version=\"1.0\"> <instrumentation metricPrefix=\"EXAMPLE\"> <pointcut transactionStartPoint=\"true\"> <!--class name is preceded by package name--> <className>test.SampleTester</className> <method> <name>checkSample</name> <parameters> <type attributeName=\"sampleName\">java.lang.String</type> <type>long[]</type> </parameters> </method> <!--two methods with the same name but different signatures can share one node--> <method> <name>getFirst</name> </method> <method> <name>run</name> </method> </pointcut> <pointcut transactionStartPoint=\"false\" ignoreTransaction=\"false\" excludeFromTransactionTrace=\"false\" metricNameFormat=\"SampleTester/methods\"> <className>test.SampleTester</className> <method> <name>printMaxRepeat</name> </method> <method> <name>printMax</name> </method> </pointcut> </instrumentation> </extension> Copy The first block of the XML file specifies the name and version of the extension. As the XML extension is default enabled, that attribute is not specified. The second block specifies the methods in SampleClass that should be instrumented. A transaction is started at the beginning of the block. It is worth noting that in the example class, there are two methods that share a name (getFirst) but have different signatures. These are instrumented with a single method node. By removing the parameters node, all methods with the same name can be matched under one method node. In the third block, the specified methods do not have a transaction started on them. This is because the transaction has already been started in run. The transaction will not be ignored, and will be included in the transaction trace.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> XML <em>instrumentation</em> examples",
        "sections": "<em>Java</em> XML <em>instrumentation</em> examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "For your New Relic-monitored <em>Java</em> application, one <em>custom</em> <em>instrumentation</em> method is to use an XML file that lists the methods and classes you want to <em>instrument</em>. This documentation shows an example XML <em>instrumentation</em> file. For more information, see <em>Java</em> <em>instrumentation</em> by XML. Edit XML file in UI"
      },
      "id": "6043e05128ccbc04a22f94bd"
    },
    {
      "sections": [
        "Scala instrumentation",
        "Tip",
        "Scala frameworks",
        "Instrument Scala with the Scala API",
        "Important",
        "Use the Scala API",
        "Configure using the project/build.scala file",
        "Configure using the project/build.sbt file",
        "Segments",
        "Transactions",
        "Instrument Scala with the Java agent API",
        "More API functions",
        "Instrument Scala with XML instrumentation",
        "Additional instrumentation"
      ],
      "title": "Scala instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "7affd5ca652f6d59905d8cfc5ea4e6a57ffe793d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/frameworks/scala-installation-java/",
      "published_at": "2021-10-18T03:45:05Z",
      "updated_at": "2021-07-09T00:01:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic's Java agent installation directions. Tip For Heroku, see Java agent with Scala on Heroku. Scala frameworks If your framework is not natively supported by New Relic, or if you want to set up additional monitoring, custom instrumentation is a great way to dig deeper into your application. Instrument Scala with the Scala API The New Relic Scala agent API lets you control, customize, and extend the functionality of the APM Java agent using idiomatic Scala code. It can be used alongside the New Relic Java API as well as allow users to Create segments for synchronous and asynchronous anonymous functions Create segments for synchronous and asynchronous code blocks Create a transaction if one has not already been started Important For best results when using the API, ensure that you have the latest Java agent release. The New Relic Scala API requires Java agent 7.1.0 or higher. Use the Scala API To access the API class add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing S.V with the Scala version and X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing S.V with the Scala version and X.Y.Z with theJava agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Supported Scala versions are 2.10, 2.11, 2.12 and 2.13. Scala 3.0 users can use the 2.13 jar. The jar is deployed to Maven Central and it is also in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The underlying API methods are just stubs; the implementation is added when the Java agent is running. Segments To create segment for a synchronous code block use TraceOps.trace. For example: import com.newrelic.scala.api.TraceOps.trace trace(\"statement segment\") { val i = 1 val j = 2 println(i + j) } // trace can also be used as an expression val x: Int = trace(\"expression segment\") { val i = 1 val j = 2 i + j } println(x) // 2 Copy trace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.trace // implicit execution implicit val ec: ExecutionContext = ??? val x: Option[Int] = for { one <- trace(\"segment one\")(Option(1)) two <- trace(\"segment two\")(Option(one + 1)) three <- trace(\"segment three\")(Option(two + 1)) } yield three println(x) // Some(3) Copy If you want to create segment for an asynchronous code block containing a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the Future to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = asyncTrace(\"segment name\")(Future { Thread.sleep(5000) 1 }) x.foreach(println) // prints 1 on completion of Future Copy asyncTrace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three x.foreach(println) // prints 3 on completion of Future Copy If you want to create segment for a synchronous anonymous function use TraceOps.traceFun. For example: import com.newrelic.scala.api.TraceOps.traceFun val x: Option[Int] = Option(1) .map(traceFun(\"statement segment\")(i => i + 1)) println(x) //Some(2) Copy If you want to create segment for an asynchronous function that returns a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the function to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTraceFun // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = Future(1) .flatMap(asyncTraceFun(\"statement segment\")(i => Future(i + 1))) x.foreach(println) // prints 2 on completion of Future Copy Transactions Transactions can be created using the TraceOps.txn method. For example: import com.newrelic.scala.api.TraceOps.txn txn { val i = 1 val j = 2 println(i + j) } Copy txn can be used as a statement (as above) or as an expression import com.newrelic.scala.api.TraceOps.txn val i: Int = txn(1 + 2) //transaction created println(i) // 3 Copy txn can be used with any of the TraceOp methods to create segments. The example below create a transaction with 3 segments. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.{txn, asyncTrace} // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = txn( for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three ) x.foreach(println) // prints 3 on completion of Future Copy Instrument Scala with the Java agent API Instrument Scala to use the New Relic API class or annotations. Add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing X.Y.Z with the Java agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Import the NewRelic class and use it in your application: import com.newrelic.api.agent.NewRelic ... NewRelic.setTransactionName(null, \"/myTransaction\"); Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction. Instrument Scala with XML instrumentation XML instrumentation is available for any Scala application running with the Java agent. It allows instrumentation to be added without any changes to the code. For more information, see Java instrumentation by XML. Additional instrumentation If you use Kamon, take a look at the New Relic Kamon reporter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Scala <em>instrumentation</em>",
        "sections": "<em>Instrument</em> Scala with the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> is compatible with Scala, and supports New Relic API calls, annotations, and <em>custom</em> <em>instrumentation</em>. All information below is supplemental to New Relic&#x27;s <em>Java</em> <em>agent</em> installation directions. Tip For Heroku, see <em>Java</em> <em>agent</em> with Scala on Heroku. Scala frameworks If your"
      },
      "id": "6043b8bb196a671be4960f24"
    },
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-10-18T05:36:32Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.70784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/custom-instrumentation-editor-instrument-ui": [
    {
      "sections": [
        "Java XML instrumentation examples",
        "Edit XML file in UI",
        "XML file format",
        "Caution",
        "Root node: extension",
        "Instrumentation (child of extension)",
        "Pointcut (child of instrumentation)",
        "Child nodes for pointcut",
        "Child nodes for method",
        "Example",
        "Sample class",
        "Sample XML instrumentation file and explanation"
      ],
      "title": "Java XML instrumentation examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "e34a060717cb5620eec03de5dcf19f1be0b82fcf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples/",
      "published_at": "2021-10-18T05:38:05Z",
      "updated_at": "2021-07-09T00:54:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file that lists the methods and classes you want to instrument. This documentation shows an example XML instrumentation file. For more information, see Java instrumentation by XML. Edit XML file in UI To edit your XML file directly from the New Relic UI: Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. Select an edit existing XML file. Search the instrumentation history. XML file format The XML file format includes root and child nodes. Caution Do not instrument all of your methods, as this can lead to a metric grouping issue. Root node: extension The root node of an XML file is extension. It can have three different attributes: Value Definition name A unique but descriptive name identifying your XML extension. enabled Identifies whether the extension will be read by the Java agent. Default is true. If false, New Relic will ignore the extension. version The version of the extension. If two extensions have the same name, only the extension with the highest version will be used. Instrumentation (child of extension) The instrumentation node is a child of extension. It can have one attribute: metricPrefix. This is the prefix used for the metric names when the nameTransaction node is not specified. Default is CUSTOM. Pointcut (child of instrumentation) The pointcut is a child node of instrumentation and can have several attributes. Also, a pointcut can have several different child nodes. Value Definition transactionStartPoint If a transaction is not already in progress when this pointcut is reached, then a transaction will be started. If a transaction is already in progress, then that transaction will continue. A new transaction will not be created. metricNameFormat The name format to use for a metric. If not present, then this will default to the class name followed by the method name. You can only set the metricNameFormat on pointcuts where transactionStartPoint is set to false. excludeFromTransactionTrace When true the transaction trace will not be provided if this pointcut initiates the transaction. If the pointcut is reached in the middle of a transaction, then the transaction trace will still be present, but this method will be excluded from the call graph. ignoreTransaction When true the entire transaction will be ignored. transactionType Sets the type of the transaction. Possible values are background (default, reported as a non-web transaction) and web (reported as a web transaction). Child nodes for pointcut A pointcut can have several different child nodes: Value Definition nameTransaction If this element is present, the agent will name the transaction using the class name and method(s) instrumented by this pointcut. methodAnnotation The case sensitive full name of an annotation class including the package name. All methods that are marked with this annotation will be matched. className The case sensitive name of the class to match, including the package name. Pair this node with the method node. If this node is present on a pointcut, then the interfaceName node cannot be present on the same pointcut node. The className node has the attribute includeSubclasses. If true the methods on the class with the matching name will be instrumented along with the matching methods on any child class of this class. If false (default), only methods on the exact class specified will be instrumented. The className must follow these rules: Inner classes can be instrumented. The full package structure with dots between packages must be used. To match subclasses of the specified class, set the attribute includeSubclasses to true. interfaceName The case sensitive name of an interface, including the package name, whose implementation classes will be matched. Pair this node with the method node. If this node is present on a pointcut, then the className node cannot be present on the same pointcut node. The interfaceName must follow this rule: The full package structure with dots between packages must be used. method A method on the class to instrument. Pair this node with a className node. Also, the method node can have children. traceByReturnType The class name, including package, in the format used in bytecode, e.g. Ljava/lang/String;. All methods that return an object of that class will be matched. traceLambda A boolean indicating whether to match lambdas. The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non static methods (defaults to false); pattern - a string with the pattern to search for the lambda methods. Child nodes for method The method node can have several children. For more information and examples, see Troubleshooting Java custom instrumentation. Value Definition name The exact case sensitive name of the method to match. A method name node must follow these rules: Public, protected, private, and package methods can all be instrumented. Static and instance methods can be instrumented. Constructors cannot be instrumented. parameters The parameter types of the method specified in order. If the parameters element is not present, then all methods matching the name will be matched. This includes private and protected declarations. A method parameters node contains a list of the method's parameters, specified by type elements. Here are the major rules for the type elements: Primitives are specified using their normal name: int, float, double, long, byte, short, boolean, char. Objects require a full package structure. For example, do not use String in the XML; instead, use java.lang.String. Do not use generics with collection objects. For example, write java.util.List instead of java.util.List<String>. Include brackets for arrays. For example, an array of integers will be int[ ] and an array of strings will be java.lang.String[ ]. Include two sets of brackets for an array of arrays. For example, an array of arrays of longs would be long[ ][ ]. To send the parameter as an analytic event to New Relic One, add an XML attribute to the type element called attributeName. To use a method with no parameters, the parameters node needs to be present to match a \"no arguments\" method. returnType The case sensitive name of a class indicating a return type to match. All methods that return this class type will be matched. Example Here is a sample class and an XML file that could be used to instrument that class. Sample class package test; import java.util.HashMap; import java.util.Map; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class SampleTester { private String configName; private Map<String, Long> maxSampleTimes; public SampleTester(String pConfigName) { configName = pConfigName; maxSampleTimes = new HashMap<>(); } public void checkSample(String name, long[] times) { if (times != null) { maxSampleTimes.put(name, getFirst(times)); } else { maxSampleTimes.put(name, (long) getFirst()); } } private Long getFirst(long[] times) { return times[0]; } private int getFirst() { return 0; } public void printMaxRepeat(final long max) throws Exception { Runnable myRunnable = new Runnable() { public void run() { try { printMax(max); } catch (Exception e) { e.printStackTrace(); } } }; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(1); scheduledExecutor.scheduleWithFixedDelay(myRunnable, 0, 10000, TimeUnit.MILLISECONDS); } private void printMax(long max) { System.out.println(\"max is \" + max); } } Copy Sample XML instrumentation file and explanation <?xml version=\"1.0\" encoding=\"UTF-8\"?> <extension xmlns=\"https://newrelic.com/docs/java/xsd/v1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"newrelic-extension extension.xsd \" name=\"customExtension\" version=\"1.0\"> <instrumentation metricPrefix=\"EXAMPLE\"> <pointcut transactionStartPoint=\"true\"> <!--class name is preceded by package name--> <className>test.SampleTester</className> <method> <name>checkSample</name> <parameters> <type attributeName=\"sampleName\">java.lang.String</type> <type>long[]</type> </parameters> </method> <!--two methods with the same name but different signatures can share one node--> <method> <name>getFirst</name> </method> <method> <name>run</name> </method> </pointcut> <pointcut transactionStartPoint=\"false\" ignoreTransaction=\"false\" excludeFromTransactionTrace=\"false\" metricNameFormat=\"SampleTester/methods\"> <className>test.SampleTester</className> <method> <name>printMaxRepeat</name> </method> <method> <name>printMax</name> </method> </pointcut> </instrumentation> </extension> Copy The first block of the XML file specifies the name and version of the extension. As the XML extension is default enabled, that attribute is not specified. The second block specifies the methods in SampleClass that should be instrumented. A transaction is started at the beginning of the block. It is worth noting that in the example class, there are two methods that share a name (getFirst) but have different signatures. These are instrumented with a single method node. By removing the parameters node, all methods with the same name can be matched under one method node. In the third block, the specified methods do not have a transaction started on them. This is because the transaction has already been started in run. The transaction will not be ignored, and will be included in the transaction trace.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> XML <em>instrumentation</em> examples",
        "sections": "<em>Java</em> XML <em>instrumentation</em> examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "For your New Relic-monitored <em>Java</em> application, one <em>custom</em> <em>instrumentation</em> method is to use an XML file that lists the methods and classes you want to <em>instrument</em>. This documentation shows an example XML <em>instrumentation</em> file. For more information, see <em>Java</em> <em>instrumentation</em> by XML. Edit XML file in UI"
      },
      "id": "6043e05128ccbc04a22f94bd"
    },
    {
      "sections": [
        "Scala instrumentation",
        "Tip",
        "Scala frameworks",
        "Instrument Scala with the Scala API",
        "Important",
        "Use the Scala API",
        "Configure using the project/build.scala file",
        "Configure using the project/build.sbt file",
        "Segments",
        "Transactions",
        "Instrument Scala with the Java agent API",
        "More API functions",
        "Instrument Scala with XML instrumentation",
        "Additional instrumentation"
      ],
      "title": "Scala instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "7affd5ca652f6d59905d8cfc5ea4e6a57ffe793d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/frameworks/scala-installation-java/",
      "published_at": "2021-10-18T03:45:05Z",
      "updated_at": "2021-07-09T00:01:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic's Java agent installation directions. Tip For Heroku, see Java agent with Scala on Heroku. Scala frameworks If your framework is not natively supported by New Relic, or if you want to set up additional monitoring, custom instrumentation is a great way to dig deeper into your application. Instrument Scala with the Scala API The New Relic Scala agent API lets you control, customize, and extend the functionality of the APM Java agent using idiomatic Scala code. It can be used alongside the New Relic Java API as well as allow users to Create segments for synchronous and asynchronous anonymous functions Create segments for synchronous and asynchronous code blocks Create a transaction if one has not already been started Important For best results when using the API, ensure that you have the latest Java agent release. The New Relic Scala API requires Java agent 7.1.0 or higher. Use the Scala API To access the API class add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing S.V with the Scala version and X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing S.V with the Scala version and X.Y.Z with theJava agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Supported Scala versions are 2.10, 2.11, 2.12 and 2.13. Scala 3.0 users can use the 2.13 jar. The jar is deployed to Maven Central and it is also in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The underlying API methods are just stubs; the implementation is added when the Java agent is running. Segments To create segment for a synchronous code block use TraceOps.trace. For example: import com.newrelic.scala.api.TraceOps.trace trace(\"statement segment\") { val i = 1 val j = 2 println(i + j) } // trace can also be used as an expression val x: Int = trace(\"expression segment\") { val i = 1 val j = 2 i + j } println(x) // 2 Copy trace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.trace // implicit execution implicit val ec: ExecutionContext = ??? val x: Option[Int] = for { one <- trace(\"segment one\")(Option(1)) two <- trace(\"segment two\")(Option(one + 1)) three <- trace(\"segment three\")(Option(two + 1)) } yield three println(x) // Some(3) Copy If you want to create segment for an asynchronous code block containing a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the Future to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = asyncTrace(\"segment name\")(Future { Thread.sleep(5000) 1 }) x.foreach(println) // prints 1 on completion of Future Copy asyncTrace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three x.foreach(println) // prints 3 on completion of Future Copy If you want to create segment for a synchronous anonymous function use TraceOps.traceFun. For example: import com.newrelic.scala.api.TraceOps.traceFun val x: Option[Int] = Option(1) .map(traceFun(\"statement segment\")(i => i + 1)) println(x) //Some(2) Copy If you want to create segment for an asynchronous function that returns a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the function to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTraceFun // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = Future(1) .flatMap(asyncTraceFun(\"statement segment\")(i => Future(i + 1))) x.foreach(println) // prints 2 on completion of Future Copy Transactions Transactions can be created using the TraceOps.txn method. For example: import com.newrelic.scala.api.TraceOps.txn txn { val i = 1 val j = 2 println(i + j) } Copy txn can be used as a statement (as above) or as an expression import com.newrelic.scala.api.TraceOps.txn val i: Int = txn(1 + 2) //transaction created println(i) // 3 Copy txn can be used with any of the TraceOp methods to create segments. The example below create a transaction with 3 segments. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.{txn, asyncTrace} // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = txn( for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three ) x.foreach(println) // prints 3 on completion of Future Copy Instrument Scala with the Java agent API Instrument Scala to use the New Relic API class or annotations. Add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing X.Y.Z with the Java agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Import the NewRelic class and use it in your application: import com.newrelic.api.agent.NewRelic ... NewRelic.setTransactionName(null, \"/myTransaction\"); Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction. Instrument Scala with XML instrumentation XML instrumentation is available for any Scala application running with the Java agent. It allows instrumentation to be added without any changes to the code. For more information, see Java instrumentation by XML. Additional instrumentation If you use Kamon, take a look at the New Relic Kamon reporter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Scala <em>instrumentation</em>",
        "sections": "<em>Instrument</em> Scala with the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> is compatible with Scala, and supports New Relic API calls, annotations, and <em>custom</em> <em>instrumentation</em>. All information below is supplemental to New Relic&#x27;s <em>Java</em> <em>agent</em> installation directions. Tip For Heroku, see <em>Java</em> <em>agent</em> with Scala on Heroku. Scala frameworks If your"
      },
      "id": "6043b8bb196a671be4960f24"
    },
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-10-18T05:36:32Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.70784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples": [
    {
      "sections": [
        "Java XML instrumentation examples",
        "Edit XML file in UI",
        "XML file format",
        "Caution",
        "Root node: extension",
        "Instrumentation (child of extension)",
        "Pointcut (child of instrumentation)",
        "Child nodes for pointcut",
        "Child nodes for method",
        "Example",
        "Sample class",
        "Sample XML instrumentation file and explanation"
      ],
      "title": "Java XML instrumentation examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "e34a060717cb5620eec03de5dcf19f1be0b82fcf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples/",
      "published_at": "2021-10-18T05:38:05Z",
      "updated_at": "2021-07-09T00:54:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file that lists the methods and classes you want to instrument. This documentation shows an example XML instrumentation file. For more information, see Java instrumentation by XML. Edit XML file in UI To edit your XML file directly from the New Relic UI: Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. Select an edit existing XML file. Search the instrumentation history. XML file format The XML file format includes root and child nodes. Caution Do not instrument all of your methods, as this can lead to a metric grouping issue. Root node: extension The root node of an XML file is extension. It can have three different attributes: Value Definition name A unique but descriptive name identifying your XML extension. enabled Identifies whether the extension will be read by the Java agent. Default is true. If false, New Relic will ignore the extension. version The version of the extension. If two extensions have the same name, only the extension with the highest version will be used. Instrumentation (child of extension) The instrumentation node is a child of extension. It can have one attribute: metricPrefix. This is the prefix used for the metric names when the nameTransaction node is not specified. Default is CUSTOM. Pointcut (child of instrumentation) The pointcut is a child node of instrumentation and can have several attributes. Also, a pointcut can have several different child nodes. Value Definition transactionStartPoint If a transaction is not already in progress when this pointcut is reached, then a transaction will be started. If a transaction is already in progress, then that transaction will continue. A new transaction will not be created. metricNameFormat The name format to use for a metric. If not present, then this will default to the class name followed by the method name. You can only set the metricNameFormat on pointcuts where transactionStartPoint is set to false. excludeFromTransactionTrace When true the transaction trace will not be provided if this pointcut initiates the transaction. If the pointcut is reached in the middle of a transaction, then the transaction trace will still be present, but this method will be excluded from the call graph. ignoreTransaction When true the entire transaction will be ignored. transactionType Sets the type of the transaction. Possible values are background (default, reported as a non-web transaction) and web (reported as a web transaction). Child nodes for pointcut A pointcut can have several different child nodes: Value Definition nameTransaction If this element is present, the agent will name the transaction using the class name and method(s) instrumented by this pointcut. methodAnnotation The case sensitive full name of an annotation class including the package name. All methods that are marked with this annotation will be matched. className The case sensitive name of the class to match, including the package name. Pair this node with the method node. If this node is present on a pointcut, then the interfaceName node cannot be present on the same pointcut node. The className node has the attribute includeSubclasses. If true the methods on the class with the matching name will be instrumented along with the matching methods on any child class of this class. If false (default), only methods on the exact class specified will be instrumented. The className must follow these rules: Inner classes can be instrumented. The full package structure with dots between packages must be used. To match subclasses of the specified class, set the attribute includeSubclasses to true. interfaceName The case sensitive name of an interface, including the package name, whose implementation classes will be matched. Pair this node with the method node. If this node is present on a pointcut, then the className node cannot be present on the same pointcut node. The interfaceName must follow this rule: The full package structure with dots between packages must be used. method A method on the class to instrument. Pair this node with a className node. Also, the method node can have children. traceByReturnType The class name, including package, in the format used in bytecode, e.g. Ljava/lang/String;. All methods that return an object of that class will be matched. traceLambda A boolean indicating whether to match lambdas. The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non static methods (defaults to false); pattern - a string with the pattern to search for the lambda methods. Child nodes for method The method node can have several children. For more information and examples, see Troubleshooting Java custom instrumentation. Value Definition name The exact case sensitive name of the method to match. A method name node must follow these rules: Public, protected, private, and package methods can all be instrumented. Static and instance methods can be instrumented. Constructors cannot be instrumented. parameters The parameter types of the method specified in order. If the parameters element is not present, then all methods matching the name will be matched. This includes private and protected declarations. A method parameters node contains a list of the method's parameters, specified by type elements. Here are the major rules for the type elements: Primitives are specified using their normal name: int, float, double, long, byte, short, boolean, char. Objects require a full package structure. For example, do not use String in the XML; instead, use java.lang.String. Do not use generics with collection objects. For example, write java.util.List instead of java.util.List<String>. Include brackets for arrays. For example, an array of integers will be int[ ] and an array of strings will be java.lang.String[ ]. Include two sets of brackets for an array of arrays. For example, an array of arrays of longs would be long[ ][ ]. To send the parameter as an analytic event to New Relic One, add an XML attribute to the type element called attributeName. To use a method with no parameters, the parameters node needs to be present to match a \"no arguments\" method. returnType The case sensitive name of a class indicating a return type to match. All methods that return this class type will be matched. Example Here is a sample class and an XML file that could be used to instrument that class. Sample class package test; import java.util.HashMap; import java.util.Map; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class SampleTester { private String configName; private Map<String, Long> maxSampleTimes; public SampleTester(String pConfigName) { configName = pConfigName; maxSampleTimes = new HashMap<>(); } public void checkSample(String name, long[] times) { if (times != null) { maxSampleTimes.put(name, getFirst(times)); } else { maxSampleTimes.put(name, (long) getFirst()); } } private Long getFirst(long[] times) { return times[0]; } private int getFirst() { return 0; } public void printMaxRepeat(final long max) throws Exception { Runnable myRunnable = new Runnable() { public void run() { try { printMax(max); } catch (Exception e) { e.printStackTrace(); } } }; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(1); scheduledExecutor.scheduleWithFixedDelay(myRunnable, 0, 10000, TimeUnit.MILLISECONDS); } private void printMax(long max) { System.out.println(\"max is \" + max); } } Copy Sample XML instrumentation file and explanation <?xml version=\"1.0\" encoding=\"UTF-8\"?> <extension xmlns=\"https://newrelic.com/docs/java/xsd/v1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"newrelic-extension extension.xsd \" name=\"customExtension\" version=\"1.0\"> <instrumentation metricPrefix=\"EXAMPLE\"> <pointcut transactionStartPoint=\"true\"> <!--class name is preceded by package name--> <className>test.SampleTester</className> <method> <name>checkSample</name> <parameters> <type attributeName=\"sampleName\">java.lang.String</type> <type>long[]</type> </parameters> </method> <!--two methods with the same name but different signatures can share one node--> <method> <name>getFirst</name> </method> <method> <name>run</name> </method> </pointcut> <pointcut transactionStartPoint=\"false\" ignoreTransaction=\"false\" excludeFromTransactionTrace=\"false\" metricNameFormat=\"SampleTester/methods\"> <className>test.SampleTester</className> <method> <name>printMaxRepeat</name> </method> <method> <name>printMax</name> </method> </pointcut> </instrumentation> </extension> Copy The first block of the XML file specifies the name and version of the extension. As the XML extension is default enabled, that attribute is not specified. The second block specifies the methods in SampleClass that should be instrumented. A transaction is started at the beginning of the block. It is worth noting that in the example class, there are two methods that share a name (getFirst) but have different signatures. These are instrumented with a single method node. By removing the parameters node, all methods with the same name can be matched under one method node. In the third block, the specified methods do not have a transaction started on them. This is because the transaction has already been started in run. The transaction will not be ignored, and will be included in the transaction trace.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> XML <em>instrumentation</em> examples",
        "sections": "<em>Java</em> XML <em>instrumentation</em> examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "For your New Relic-monitored <em>Java</em> application, one <em>custom</em> <em>instrumentation</em> method is to use an XML file that lists the methods and classes you want to <em>instrument</em>. This documentation shows an example XML <em>instrumentation</em> file. For more information, see <em>Java</em> <em>instrumentation</em> by XML. Edit XML file in UI"
      },
      "id": "6043e05128ccbc04a22f94bd"
    },
    {
      "sections": [
        "Scala instrumentation",
        "Tip",
        "Scala frameworks",
        "Instrument Scala with the Scala API",
        "Important",
        "Use the Scala API",
        "Configure using the project/build.scala file",
        "Configure using the project/build.sbt file",
        "Segments",
        "Transactions",
        "Instrument Scala with the Java agent API",
        "More API functions",
        "Instrument Scala with XML instrumentation",
        "Additional instrumentation"
      ],
      "title": "Scala instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "7affd5ca652f6d59905d8cfc5ea4e6a57ffe793d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/frameworks/scala-installation-java/",
      "published_at": "2021-10-18T03:45:05Z",
      "updated_at": "2021-07-09T00:01:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic's Java agent installation directions. Tip For Heroku, see Java agent with Scala on Heroku. Scala frameworks If your framework is not natively supported by New Relic, or if you want to set up additional monitoring, custom instrumentation is a great way to dig deeper into your application. Instrument Scala with the Scala API The New Relic Scala agent API lets you control, customize, and extend the functionality of the APM Java agent using idiomatic Scala code. It can be used alongside the New Relic Java API as well as allow users to Create segments for synchronous and asynchronous anonymous functions Create segments for synchronous and asynchronous code blocks Create a transaction if one has not already been started Important For best results when using the API, ensure that you have the latest Java agent release. The New Relic Scala API requires Java agent 7.1.0 or higher. Use the Scala API To access the API class add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing S.V with the Scala version and X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing S.V with the Scala version and X.Y.Z with theJava agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Supported Scala versions are 2.10, 2.11, 2.12 and 2.13. Scala 3.0 users can use the 2.13 jar. The jar is deployed to Maven Central and it is also in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The underlying API methods are just stubs; the implementation is added when the Java agent is running. Segments To create segment for a synchronous code block use TraceOps.trace. For example: import com.newrelic.scala.api.TraceOps.trace trace(\"statement segment\") { val i = 1 val j = 2 println(i + j) } // trace can also be used as an expression val x: Int = trace(\"expression segment\") { val i = 1 val j = 2 i + j } println(x) // 2 Copy trace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.trace // implicit execution implicit val ec: ExecutionContext = ??? val x: Option[Int] = for { one <- trace(\"segment one\")(Option(1)) two <- trace(\"segment two\")(Option(one + 1)) three <- trace(\"segment three\")(Option(two + 1)) } yield three println(x) // Some(3) Copy If you want to create segment for an asynchronous code block containing a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the Future to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = asyncTrace(\"segment name\")(Future { Thread.sleep(5000) 1 }) x.foreach(println) // prints 1 on completion of Future Copy asyncTrace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three x.foreach(println) // prints 3 on completion of Future Copy If you want to create segment for a synchronous anonymous function use TraceOps.traceFun. For example: import com.newrelic.scala.api.TraceOps.traceFun val x: Option[Int] = Option(1) .map(traceFun(\"statement segment\")(i => i + 1)) println(x) //Some(2) Copy If you want to create segment for an asynchronous function that returns a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the function to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTraceFun // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = Future(1) .flatMap(asyncTraceFun(\"statement segment\")(i => Future(i + 1))) x.foreach(println) // prints 2 on completion of Future Copy Transactions Transactions can be created using the TraceOps.txn method. For example: import com.newrelic.scala.api.TraceOps.txn txn { val i = 1 val j = 2 println(i + j) } Copy txn can be used as a statement (as above) or as an expression import com.newrelic.scala.api.TraceOps.txn val i: Int = txn(1 + 2) //transaction created println(i) // 3 Copy txn can be used with any of the TraceOp methods to create segments. The example below create a transaction with 3 segments. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.{txn, asyncTrace} // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = txn( for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three ) x.foreach(println) // prints 3 on completion of Future Copy Instrument Scala with the Java agent API Instrument Scala to use the New Relic API class or annotations. Add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing X.Y.Z with the Java agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Import the NewRelic class and use it in your application: import com.newrelic.api.agent.NewRelic ... NewRelic.setTransactionName(null, \"/myTransaction\"); Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction. Instrument Scala with XML instrumentation XML instrumentation is available for any Scala application running with the Java agent. It allows instrumentation to be added without any changes to the code. For more information, see Java instrumentation by XML. Additional instrumentation If you use Kamon, take a look at the New Relic Kamon reporter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Scala <em>instrumentation</em>",
        "sections": "<em>Instrument</em> Scala with the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> is compatible with Scala, and supports New Relic API calls, annotations, and <em>custom</em> <em>instrumentation</em>. All information below is supplemental to New Relic&#x27;s <em>Java</em> <em>agent</em> installation directions. Tip For Heroku, see <em>Java</em> <em>agent</em> with Scala on Heroku. Scala frameworks If your"
      },
      "id": "6043b8bb196a671be4960f24"
    },
    {
      "sections": [
        "Messaging framework instrumentation",
        "Typical messaging",
        "Report the producing/consuming as external",
        "Add message metrics/custom parameters to current transaction",
        "Pass a distributed trace payload",
        "Edge cases",
        "Create a distributed trace payload and then receive a message",
        "Batch reading messages",
        "Capturing the processing time of the message",
        "For more help"
      ],
      "title": "Messaging framework instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "9b656fcf1790e65d1db825e35ab31c94b6561e08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are some messaging frameworks that New Relic doesnt support by default. If you are interested in instrumenting these frameworks with our API here are some guidelines to follow. Typical messaging In the typical case, there is a process that produces a message and a process that consumes the message. Some useful things you could do here are below. Note you must be within a transaction for these to report. Report the producing/consuming as external You can create MessageProduceParameters and MessageConsumeParameters with relevant data and then call reportAsExternal(Params) to report the calls as externals. For example, when producing a message this would look like: MessageProduceParameters params = MessageProduceParameters.library(\"libraryName\").destinationType(NAMED_TOPIC).destinationName(\"topicName\").inboundHeaders(null).build(); NewRelic.getAgent().getTransaction().getTracedMethod().reportAsExternal(params); Copy A similar solution would work on the consumer side. Add message metrics/custom parameters to current transaction If there is useful information you want to add to your current transaction about the message, you can do that easily by calling our addCustomParameter() API. This looks like this: NewRelic.addCustomParameter(\"topic-name\", topic); Copy Pass a distributed trace payload In order to track the work across processes/services, the messaging framework must have a way to pass along metadata with the message, whether its via headers or some other mechanism. You can create a distributed trace payload on the producer side that can be attached to the message and read on the consumer side. You must be in a transaction for this to work. To do this you would follow a pattern like this: @Trace(dispatcher = true) public void sendData(Producer producer){ final DistributedTracePayload payload = NewRelic.getAgent().getTransaction().createDistributedTracePayload(); headers.add(new RecordHeader(\"newrelic\", payload.text().getBytes(StandardCharsets.UTF_8))); data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\", headers); producer.send(data); } Copy And on the consumer side: @Trace(dispatcher = true) public void processData(ConsumerRecord record){ final Iterator<Header> nrHeaders = record.headers().headers(\"newrelic\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can instrument. Instrument Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra care. Below are suggestions on the best way to tackle them. Create a distributed trace payload and then receive a message The problem here is that you cant create a distributed trace payload and then accept a distributed trace payload within the same transaction in that order. This means that there are two attempts of distributed tracing and you have to choose which one you want. If you would like to accept the second payload rather than create the first one, you need to prevent the first payload from getting created. You can remove the custom instrumentation (if thats whats creating the payload) or disable instrumentation via our config Batch reading messages For batch consumption of messages, there is a problem of which distributed tracing payload you accept. If you are ok with linking just one of the distributed trace payloads then you can accept any one of the payloads in the batch but that will result in the rest of the payloads getting lost. However, if you want to see all of the distributed traces then youll need to create a transaction per message. The second solution could incur some overhead so take that into consideration when making a decision. A solution like that would look like: public void processMessages(ConsumerRecords<String, String> records) { for(ConsumerRecord<String, String> record: records) { processRecord(record); } } @Trace(dispatcher = true) private void processRecord(ConsumerRecord<String, String> record) { final Iterator<Header> nrHeaders = record.headers().headers(\"newrelicDTPayload\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This will only work if there isnt a transaction already started on the thread at this time. If there is one then just accepting one payload from the batch is your only solution. Capturing the processing time of the message If you would like to capture the processing time of a message then you will need to move the processing work into a method and then trace that method. For example: public void getMessages(){ KafkaConsumer consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(\"topic\")); while (true) { ConsumerRecords<String, String> recs = consumer.poll(10000); if (recs.count() == 0) { } else { for (ConsumerRecord<String, String> rec : recs) { processRec(rec); } } } } @Trace(dispatcher = true) private void processRec(ConsumerRecord<String, String> rec) { // some processing } Copy For more help Use the Guide to using the Java agent API to learn more about our Java agent API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.703186,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Messaging framework <em>instrumentation</em>",
        "sections": "Messaging framework <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.get<em>Agent</em>().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can <em>instrument</em>. <em>Instrument</em> Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra"
      },
      "id": "603ebc24196a67a6d7a83dc8"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/java-agent-custom-jmx-instrumentation-yaml": [
    {
      "sections": [
        "Java XML instrumentation examples",
        "Edit XML file in UI",
        "XML file format",
        "Caution",
        "Root node: extension",
        "Instrumentation (child of extension)",
        "Pointcut (child of instrumentation)",
        "Child nodes for pointcut",
        "Child nodes for method",
        "Example",
        "Sample class",
        "Sample XML instrumentation file and explanation"
      ],
      "title": "Java XML instrumentation examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "e34a060717cb5620eec03de5dcf19f1be0b82fcf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples/",
      "published_at": "2021-10-18T05:38:05Z",
      "updated_at": "2021-07-09T00:54:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file that lists the methods and classes you want to instrument. This documentation shows an example XML instrumentation file. For more information, see Java instrumentation by XML. Edit XML file in UI To edit your XML file directly from the New Relic UI: Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. Select an edit existing XML file. Search the instrumentation history. XML file format The XML file format includes root and child nodes. Caution Do not instrument all of your methods, as this can lead to a metric grouping issue. Root node: extension The root node of an XML file is extension. It can have three different attributes: Value Definition name A unique but descriptive name identifying your XML extension. enabled Identifies whether the extension will be read by the Java agent. Default is true. If false, New Relic will ignore the extension. version The version of the extension. If two extensions have the same name, only the extension with the highest version will be used. Instrumentation (child of extension) The instrumentation node is a child of extension. It can have one attribute: metricPrefix. This is the prefix used for the metric names when the nameTransaction node is not specified. Default is CUSTOM. Pointcut (child of instrumentation) The pointcut is a child node of instrumentation and can have several attributes. Also, a pointcut can have several different child nodes. Value Definition transactionStartPoint If a transaction is not already in progress when this pointcut is reached, then a transaction will be started. If a transaction is already in progress, then that transaction will continue. A new transaction will not be created. metricNameFormat The name format to use for a metric. If not present, then this will default to the class name followed by the method name. You can only set the metricNameFormat on pointcuts where transactionStartPoint is set to false. excludeFromTransactionTrace When true the transaction trace will not be provided if this pointcut initiates the transaction. If the pointcut is reached in the middle of a transaction, then the transaction trace will still be present, but this method will be excluded from the call graph. ignoreTransaction When true the entire transaction will be ignored. transactionType Sets the type of the transaction. Possible values are background (default, reported as a non-web transaction) and web (reported as a web transaction). Child nodes for pointcut A pointcut can have several different child nodes: Value Definition nameTransaction If this element is present, the agent will name the transaction using the class name and method(s) instrumented by this pointcut. methodAnnotation The case sensitive full name of an annotation class including the package name. All methods that are marked with this annotation will be matched. className The case sensitive name of the class to match, including the package name. Pair this node with the method node. If this node is present on a pointcut, then the interfaceName node cannot be present on the same pointcut node. The className node has the attribute includeSubclasses. If true the methods on the class with the matching name will be instrumented along with the matching methods on any child class of this class. If false (default), only methods on the exact class specified will be instrumented. The className must follow these rules: Inner classes can be instrumented. The full package structure with dots between packages must be used. To match subclasses of the specified class, set the attribute includeSubclasses to true. interfaceName The case sensitive name of an interface, including the package name, whose implementation classes will be matched. Pair this node with the method node. If this node is present on a pointcut, then the className node cannot be present on the same pointcut node. The interfaceName must follow this rule: The full package structure with dots between packages must be used. method A method on the class to instrument. Pair this node with a className node. Also, the method node can have children. traceByReturnType The class name, including package, in the format used in bytecode, e.g. Ljava/lang/String;. All methods that return an object of that class will be matched. traceLambda A boolean indicating whether to match lambdas. The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non static methods (defaults to false); pattern - a string with the pattern to search for the lambda methods. Child nodes for method The method node can have several children. For more information and examples, see Troubleshooting Java custom instrumentation. Value Definition name The exact case sensitive name of the method to match. A method name node must follow these rules: Public, protected, private, and package methods can all be instrumented. Static and instance methods can be instrumented. Constructors cannot be instrumented. parameters The parameter types of the method specified in order. If the parameters element is not present, then all methods matching the name will be matched. This includes private and protected declarations. A method parameters node contains a list of the method's parameters, specified by type elements. Here are the major rules for the type elements: Primitives are specified using their normal name: int, float, double, long, byte, short, boolean, char. Objects require a full package structure. For example, do not use String in the XML; instead, use java.lang.String. Do not use generics with collection objects. For example, write java.util.List instead of java.util.List<String>. Include brackets for arrays. For example, an array of integers will be int[ ] and an array of strings will be java.lang.String[ ]. Include two sets of brackets for an array of arrays. For example, an array of arrays of longs would be long[ ][ ]. To send the parameter as an analytic event to New Relic One, add an XML attribute to the type element called attributeName. To use a method with no parameters, the parameters node needs to be present to match a \"no arguments\" method. returnType The case sensitive name of a class indicating a return type to match. All methods that return this class type will be matched. Example Here is a sample class and an XML file that could be used to instrument that class. Sample class package test; import java.util.HashMap; import java.util.Map; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class SampleTester { private String configName; private Map<String, Long> maxSampleTimes; public SampleTester(String pConfigName) { configName = pConfigName; maxSampleTimes = new HashMap<>(); } public void checkSample(String name, long[] times) { if (times != null) { maxSampleTimes.put(name, getFirst(times)); } else { maxSampleTimes.put(name, (long) getFirst()); } } private Long getFirst(long[] times) { return times[0]; } private int getFirst() { return 0; } public void printMaxRepeat(final long max) throws Exception { Runnable myRunnable = new Runnable() { public void run() { try { printMax(max); } catch (Exception e) { e.printStackTrace(); } } }; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(1); scheduledExecutor.scheduleWithFixedDelay(myRunnable, 0, 10000, TimeUnit.MILLISECONDS); } private void printMax(long max) { System.out.println(\"max is \" + max); } } Copy Sample XML instrumentation file and explanation <?xml version=\"1.0\" encoding=\"UTF-8\"?> <extension xmlns=\"https://newrelic.com/docs/java/xsd/v1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"newrelic-extension extension.xsd \" name=\"customExtension\" version=\"1.0\"> <instrumentation metricPrefix=\"EXAMPLE\"> <pointcut transactionStartPoint=\"true\"> <!--class name is preceded by package name--> <className>test.SampleTester</className> <method> <name>checkSample</name> <parameters> <type attributeName=\"sampleName\">java.lang.String</type> <type>long[]</type> </parameters> </method> <!--two methods with the same name but different signatures can share one node--> <method> <name>getFirst</name> </method> <method> <name>run</name> </method> </pointcut> <pointcut transactionStartPoint=\"false\" ignoreTransaction=\"false\" excludeFromTransactionTrace=\"false\" metricNameFormat=\"SampleTester/methods\"> <className>test.SampleTester</className> <method> <name>printMaxRepeat</name> </method> <method> <name>printMax</name> </method> </pointcut> </instrumentation> </extension> Copy The first block of the XML file specifies the name and version of the extension. As the XML extension is default enabled, that attribute is not specified. The second block specifies the methods in SampleClass that should be instrumented. A transaction is started at the beginning of the block. It is worth noting that in the example class, there are two methods that share a name (getFirst) but have different signatures. These are instrumented with a single method node. By removing the parameters node, all methods with the same name can be matched under one method node. In the third block, the specified methods do not have a transaction started on them. This is because the transaction has already been started in run. The transaction will not be ignored, and will be included in the transaction trace.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> XML <em>instrumentation</em> examples",
        "sections": "<em>Java</em> XML <em>instrumentation</em> examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "For your New Relic-monitored <em>Java</em> application, one <em>custom</em> <em>instrumentation</em> method is to use an XML file that lists the methods and classes you want to <em>instrument</em>. This documentation shows an example XML <em>instrumentation</em> file. For more information, see <em>Java</em> <em>instrumentation</em> by XML. Edit XML file in UI"
      },
      "id": "6043e05128ccbc04a22f94bd"
    },
    {
      "sections": [
        "Scala instrumentation",
        "Tip",
        "Scala frameworks",
        "Instrument Scala with the Scala API",
        "Important",
        "Use the Scala API",
        "Configure using the project/build.scala file",
        "Configure using the project/build.sbt file",
        "Segments",
        "Transactions",
        "Instrument Scala with the Java agent API",
        "More API functions",
        "Instrument Scala with XML instrumentation",
        "Additional instrumentation"
      ],
      "title": "Scala instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "7affd5ca652f6d59905d8cfc5ea4e6a57ffe793d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/frameworks/scala-installation-java/",
      "published_at": "2021-10-18T03:45:05Z",
      "updated_at": "2021-07-09T00:01:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic's Java agent installation directions. Tip For Heroku, see Java agent with Scala on Heroku. Scala frameworks If your framework is not natively supported by New Relic, or if you want to set up additional monitoring, custom instrumentation is a great way to dig deeper into your application. Instrument Scala with the Scala API The New Relic Scala agent API lets you control, customize, and extend the functionality of the APM Java agent using idiomatic Scala code. It can be used alongside the New Relic Java API as well as allow users to Create segments for synchronous and asynchronous anonymous functions Create segments for synchronous and asynchronous code blocks Create a transaction if one has not already been started Important For best results when using the API, ensure that you have the latest Java agent release. The New Relic Scala API requires Java agent 7.1.0 or higher. Use the Scala API To access the API class add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing S.V with the Scala version and X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing S.V with the Scala version and X.Y.Z with theJava agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Supported Scala versions are 2.10, 2.11, 2.12 and 2.13. Scala 3.0 users can use the 2.13 jar. The jar is deployed to Maven Central and it is also in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The underlying API methods are just stubs; the implementation is added when the Java agent is running. Segments To create segment for a synchronous code block use TraceOps.trace. For example: import com.newrelic.scala.api.TraceOps.trace trace(\"statement segment\") { val i = 1 val j = 2 println(i + j) } // trace can also be used as an expression val x: Int = trace(\"expression segment\") { val i = 1 val j = 2 i + j } println(x) // 2 Copy trace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.trace // implicit execution implicit val ec: ExecutionContext = ??? val x: Option[Int] = for { one <- trace(\"segment one\")(Option(1)) two <- trace(\"segment two\")(Option(one + 1)) three <- trace(\"segment three\")(Option(two + 1)) } yield three println(x) // Some(3) Copy If you want to create segment for an asynchronous code block containing a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the Future to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = asyncTrace(\"segment name\")(Future { Thread.sleep(5000) 1 }) x.foreach(println) // prints 1 on completion of Future Copy asyncTrace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three x.foreach(println) // prints 3 on completion of Future Copy If you want to create segment for a synchronous anonymous function use TraceOps.traceFun. For example: import com.newrelic.scala.api.TraceOps.traceFun val x: Option[Int] = Option(1) .map(traceFun(\"statement segment\")(i => i + 1)) println(x) //Some(2) Copy If you want to create segment for an asynchronous function that returns a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the function to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTraceFun // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = Future(1) .flatMap(asyncTraceFun(\"statement segment\")(i => Future(i + 1))) x.foreach(println) // prints 2 on completion of Future Copy Transactions Transactions can be created using the TraceOps.txn method. For example: import com.newrelic.scala.api.TraceOps.txn txn { val i = 1 val j = 2 println(i + j) } Copy txn can be used as a statement (as above) or as an expression import com.newrelic.scala.api.TraceOps.txn val i: Int = txn(1 + 2) //transaction created println(i) // 3 Copy txn can be used with any of the TraceOp methods to create segments. The example below create a transaction with 3 segments. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.{txn, asyncTrace} // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = txn( for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three ) x.foreach(println) // prints 3 on completion of Future Copy Instrument Scala with the Java agent API Instrument Scala to use the New Relic API class or annotations. Add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing X.Y.Z with the Java agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Import the NewRelic class and use it in your application: import com.newrelic.api.agent.NewRelic ... NewRelic.setTransactionName(null, \"/myTransaction\"); Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction. Instrument Scala with XML instrumentation XML instrumentation is available for any Scala application running with the Java agent. It allows instrumentation to be added without any changes to the code. For more information, see Java instrumentation by XML. Additional instrumentation If you use Kamon, take a look at the New Relic Kamon reporter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Scala <em>instrumentation</em>",
        "sections": "<em>Instrument</em> Scala with the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> is compatible with Scala, and supports New Relic API calls, annotations, and <em>custom</em> <em>instrumentation</em>. All information below is supplemental to New Relic&#x27;s <em>Java</em> <em>agent</em> installation directions. Tip For Heroku, see <em>Java</em> <em>agent</em> with Scala on Heroku. Scala frameworks If your"
      },
      "id": "6043b8bb196a671be4960f24"
    },
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-10-18T05:36:32Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.70784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation": [
    {
      "sections": [
        "Java XML instrumentation examples",
        "Edit XML file in UI",
        "XML file format",
        "Caution",
        "Root node: extension",
        "Instrumentation (child of extension)",
        "Pointcut (child of instrumentation)",
        "Child nodes for pointcut",
        "Child nodes for method",
        "Example",
        "Sample class",
        "Sample XML instrumentation file and explanation"
      ],
      "title": "Java XML instrumentation examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "e34a060717cb5620eec03de5dcf19f1be0b82fcf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples/",
      "published_at": "2021-10-18T05:38:05Z",
      "updated_at": "2021-07-09T00:54:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file that lists the methods and classes you want to instrument. This documentation shows an example XML instrumentation file. For more information, see Java instrumentation by XML. Edit XML file in UI To edit your XML file directly from the New Relic UI: Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. Select an edit existing XML file. Search the instrumentation history. XML file format The XML file format includes root and child nodes. Caution Do not instrument all of your methods, as this can lead to a metric grouping issue. Root node: extension The root node of an XML file is extension. It can have three different attributes: Value Definition name A unique but descriptive name identifying your XML extension. enabled Identifies whether the extension will be read by the Java agent. Default is true. If false, New Relic will ignore the extension. version The version of the extension. If two extensions have the same name, only the extension with the highest version will be used. Instrumentation (child of extension) The instrumentation node is a child of extension. It can have one attribute: metricPrefix. This is the prefix used for the metric names when the nameTransaction node is not specified. Default is CUSTOM. Pointcut (child of instrumentation) The pointcut is a child node of instrumentation and can have several attributes. Also, a pointcut can have several different child nodes. Value Definition transactionStartPoint If a transaction is not already in progress when this pointcut is reached, then a transaction will be started. If a transaction is already in progress, then that transaction will continue. A new transaction will not be created. metricNameFormat The name format to use for a metric. If not present, then this will default to the class name followed by the method name. You can only set the metricNameFormat on pointcuts where transactionStartPoint is set to false. excludeFromTransactionTrace When true the transaction trace will not be provided if this pointcut initiates the transaction. If the pointcut is reached in the middle of a transaction, then the transaction trace will still be present, but this method will be excluded from the call graph. ignoreTransaction When true the entire transaction will be ignored. transactionType Sets the type of the transaction. Possible values are background (default, reported as a non-web transaction) and web (reported as a web transaction). Child nodes for pointcut A pointcut can have several different child nodes: Value Definition nameTransaction If this element is present, the agent will name the transaction using the class name and method(s) instrumented by this pointcut. methodAnnotation The case sensitive full name of an annotation class including the package name. All methods that are marked with this annotation will be matched. className The case sensitive name of the class to match, including the package name. Pair this node with the method node. If this node is present on a pointcut, then the interfaceName node cannot be present on the same pointcut node. The className node has the attribute includeSubclasses. If true the methods on the class with the matching name will be instrumented along with the matching methods on any child class of this class. If false (default), only methods on the exact class specified will be instrumented. The className must follow these rules: Inner classes can be instrumented. The full package structure with dots between packages must be used. To match subclasses of the specified class, set the attribute includeSubclasses to true. interfaceName The case sensitive name of an interface, including the package name, whose implementation classes will be matched. Pair this node with the method node. If this node is present on a pointcut, then the className node cannot be present on the same pointcut node. The interfaceName must follow this rule: The full package structure with dots between packages must be used. method A method on the class to instrument. Pair this node with a className node. Also, the method node can have children. traceByReturnType The class name, including package, in the format used in bytecode, e.g. Ljava/lang/String;. All methods that return an object of that class will be matched. traceLambda A boolean indicating whether to match lambdas. The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non static methods (defaults to false); pattern - a string with the pattern to search for the lambda methods. Child nodes for method The method node can have several children. For more information and examples, see Troubleshooting Java custom instrumentation. Value Definition name The exact case sensitive name of the method to match. A method name node must follow these rules: Public, protected, private, and package methods can all be instrumented. Static and instance methods can be instrumented. Constructors cannot be instrumented. parameters The parameter types of the method specified in order. If the parameters element is not present, then all methods matching the name will be matched. This includes private and protected declarations. A method parameters node contains a list of the method's parameters, specified by type elements. Here are the major rules for the type elements: Primitives are specified using their normal name: int, float, double, long, byte, short, boolean, char. Objects require a full package structure. For example, do not use String in the XML; instead, use java.lang.String. Do not use generics with collection objects. For example, write java.util.List instead of java.util.List<String>. Include brackets for arrays. For example, an array of integers will be int[ ] and an array of strings will be java.lang.String[ ]. Include two sets of brackets for an array of arrays. For example, an array of arrays of longs would be long[ ][ ]. To send the parameter as an analytic event to New Relic One, add an XML attribute to the type element called attributeName. To use a method with no parameters, the parameters node needs to be present to match a \"no arguments\" method. returnType The case sensitive name of a class indicating a return type to match. All methods that return this class type will be matched. Example Here is a sample class and an XML file that could be used to instrument that class. Sample class package test; import java.util.HashMap; import java.util.Map; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class SampleTester { private String configName; private Map<String, Long> maxSampleTimes; public SampleTester(String pConfigName) { configName = pConfigName; maxSampleTimes = new HashMap<>(); } public void checkSample(String name, long[] times) { if (times != null) { maxSampleTimes.put(name, getFirst(times)); } else { maxSampleTimes.put(name, (long) getFirst()); } } private Long getFirst(long[] times) { return times[0]; } private int getFirst() { return 0; } public void printMaxRepeat(final long max) throws Exception { Runnable myRunnable = new Runnable() { public void run() { try { printMax(max); } catch (Exception e) { e.printStackTrace(); } } }; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(1); scheduledExecutor.scheduleWithFixedDelay(myRunnable, 0, 10000, TimeUnit.MILLISECONDS); } private void printMax(long max) { System.out.println(\"max is \" + max); } } Copy Sample XML instrumentation file and explanation <?xml version=\"1.0\" encoding=\"UTF-8\"?> <extension xmlns=\"https://newrelic.com/docs/java/xsd/v1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"newrelic-extension extension.xsd \" name=\"customExtension\" version=\"1.0\"> <instrumentation metricPrefix=\"EXAMPLE\"> <pointcut transactionStartPoint=\"true\"> <!--class name is preceded by package name--> <className>test.SampleTester</className> <method> <name>checkSample</name> <parameters> <type attributeName=\"sampleName\">java.lang.String</type> <type>long[]</type> </parameters> </method> <!--two methods with the same name but different signatures can share one node--> <method> <name>getFirst</name> </method> <method> <name>run</name> </method> </pointcut> <pointcut transactionStartPoint=\"false\" ignoreTransaction=\"false\" excludeFromTransactionTrace=\"false\" metricNameFormat=\"SampleTester/methods\"> <className>test.SampleTester</className> <method> <name>printMaxRepeat</name> </method> <method> <name>printMax</name> </method> </pointcut> </instrumentation> </extension> Copy The first block of the XML file specifies the name and version of the extension. As the XML extension is default enabled, that attribute is not specified. The second block specifies the methods in SampleClass that should be instrumented. A transaction is started at the beginning of the block. It is worth noting that in the example class, there are two methods that share a name (getFirst) but have different signatures. These are instrumented with a single method node. By removing the parameters node, all methods with the same name can be matched under one method node. In the third block, the specified methods do not have a transaction started on them. This is because the transaction has already been started in run. The transaction will not be ignored, and will be included in the transaction trace.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> XML <em>instrumentation</em> examples",
        "sections": "<em>Java</em> XML <em>instrumentation</em> examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "For your New Relic-monitored <em>Java</em> application, one <em>custom</em> <em>instrumentation</em> method is to use an XML file that lists the methods and classes you want to <em>instrument</em>. This documentation shows an example XML <em>instrumentation</em> file. For more information, see <em>Java</em> <em>instrumentation</em> by XML. Edit XML file in UI"
      },
      "id": "6043e05128ccbc04a22f94bd"
    },
    {
      "sections": [
        "Scala instrumentation",
        "Tip",
        "Scala frameworks",
        "Instrument Scala with the Scala API",
        "Important",
        "Use the Scala API",
        "Configure using the project/build.scala file",
        "Configure using the project/build.sbt file",
        "Segments",
        "Transactions",
        "Instrument Scala with the Java agent API",
        "More API functions",
        "Instrument Scala with XML instrumentation",
        "Additional instrumentation"
      ],
      "title": "Scala instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "7affd5ca652f6d59905d8cfc5ea4e6a57ffe793d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/frameworks/scala-installation-java/",
      "published_at": "2021-10-18T03:45:05Z",
      "updated_at": "2021-07-09T00:01:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic's Java agent installation directions. Tip For Heroku, see Java agent with Scala on Heroku. Scala frameworks If your framework is not natively supported by New Relic, or if you want to set up additional monitoring, custom instrumentation is a great way to dig deeper into your application. Instrument Scala with the Scala API The New Relic Scala agent API lets you control, customize, and extend the functionality of the APM Java agent using idiomatic Scala code. It can be used alongside the New Relic Java API as well as allow users to Create segments for synchronous and asynchronous anonymous functions Create segments for synchronous and asynchronous code blocks Create a transaction if one has not already been started Important For best results when using the API, ensure that you have the latest Java agent release. The New Relic Scala API requires Java agent 7.1.0 or higher. Use the Scala API To access the API class add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing S.V with the Scala version and X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing S.V with the Scala version and X.Y.Z with theJava agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Supported Scala versions are 2.10, 2.11, 2.12 and 2.13. Scala 3.0 users can use the 2.13 jar. The jar is deployed to Maven Central and it is also in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The underlying API methods are just stubs; the implementation is added when the Java agent is running. Segments To create segment for a synchronous code block use TraceOps.trace. For example: import com.newrelic.scala.api.TraceOps.trace trace(\"statement segment\") { val i = 1 val j = 2 println(i + j) } // trace can also be used as an expression val x: Int = trace(\"expression segment\") { val i = 1 val j = 2 i + j } println(x) // 2 Copy trace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.trace // implicit execution implicit val ec: ExecutionContext = ??? val x: Option[Int] = for { one <- trace(\"segment one\")(Option(1)) two <- trace(\"segment two\")(Option(one + 1)) three <- trace(\"segment three\")(Option(two + 1)) } yield three println(x) // Some(3) Copy If you want to create segment for an asynchronous code block containing a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the Future to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = asyncTrace(\"segment name\")(Future { Thread.sleep(5000) 1 }) x.foreach(println) // prints 1 on completion of Future Copy asyncTrace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three x.foreach(println) // prints 3 on completion of Future Copy If you want to create segment for a synchronous anonymous function use TraceOps.traceFun. For example: import com.newrelic.scala.api.TraceOps.traceFun val x: Option[Int] = Option(1) .map(traceFun(\"statement segment\")(i => i + 1)) println(x) //Some(2) Copy If you want to create segment for an asynchronous function that returns a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the function to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTraceFun // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = Future(1) .flatMap(asyncTraceFun(\"statement segment\")(i => Future(i + 1))) x.foreach(println) // prints 2 on completion of Future Copy Transactions Transactions can be created using the TraceOps.txn method. For example: import com.newrelic.scala.api.TraceOps.txn txn { val i = 1 val j = 2 println(i + j) } Copy txn can be used as a statement (as above) or as an expression import com.newrelic.scala.api.TraceOps.txn val i: Int = txn(1 + 2) //transaction created println(i) // 3 Copy txn can be used with any of the TraceOp methods to create segments. The example below create a transaction with 3 segments. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.{txn, asyncTrace} // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = txn( for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three ) x.foreach(println) // prints 3 on completion of Future Copy Instrument Scala with the Java agent API Instrument Scala to use the New Relic API class or annotations. Add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing X.Y.Z with the Java agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Import the NewRelic class and use it in your application: import com.newrelic.api.agent.NewRelic ... NewRelic.setTransactionName(null, \"/myTransaction\"); Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction. Instrument Scala with XML instrumentation XML instrumentation is available for any Scala application running with the Java agent. It allows instrumentation to be added without any changes to the code. For more information, see Java instrumentation by XML. Additional instrumentation If you use Kamon, take a look at the New Relic Kamon reporter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Scala <em>instrumentation</em>",
        "sections": "<em>Instrument</em> Scala with the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> is compatible with Scala, and supports New Relic API calls, annotations, and <em>custom</em> <em>instrumentation</em>. All information below is supplemental to New Relic&#x27;s <em>Java</em> <em>agent</em> installation directions. Tip For Heroku, see <em>Java</em> <em>agent</em> with Scala on Heroku. Scala frameworks If your"
      },
      "id": "6043b8bb196a671be4960f24"
    },
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-10-18T05:36:32Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.70784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/java-instrumentation-xml": [
    {
      "sections": [
        "Java XML instrumentation examples",
        "Edit XML file in UI",
        "XML file format",
        "Caution",
        "Root node: extension",
        "Instrumentation (child of extension)",
        "Pointcut (child of instrumentation)",
        "Child nodes for pointcut",
        "Child nodes for method",
        "Example",
        "Sample class",
        "Sample XML instrumentation file and explanation"
      ],
      "title": "Java XML instrumentation examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "e34a060717cb5620eec03de5dcf19f1be0b82fcf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples/",
      "published_at": "2021-10-18T05:38:05Z",
      "updated_at": "2021-07-09T00:54:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file that lists the methods and classes you want to instrument. This documentation shows an example XML instrumentation file. For more information, see Java instrumentation by XML. Edit XML file in UI To edit your XML file directly from the New Relic UI: Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. Select an edit existing XML file. Search the instrumentation history. XML file format The XML file format includes root and child nodes. Caution Do not instrument all of your methods, as this can lead to a metric grouping issue. Root node: extension The root node of an XML file is extension. It can have three different attributes: Value Definition name A unique but descriptive name identifying your XML extension. enabled Identifies whether the extension will be read by the Java agent. Default is true. If false, New Relic will ignore the extension. version The version of the extension. If two extensions have the same name, only the extension with the highest version will be used. Instrumentation (child of extension) The instrumentation node is a child of extension. It can have one attribute: metricPrefix. This is the prefix used for the metric names when the nameTransaction node is not specified. Default is CUSTOM. Pointcut (child of instrumentation) The pointcut is a child node of instrumentation and can have several attributes. Also, a pointcut can have several different child nodes. Value Definition transactionStartPoint If a transaction is not already in progress when this pointcut is reached, then a transaction will be started. If a transaction is already in progress, then that transaction will continue. A new transaction will not be created. metricNameFormat The name format to use for a metric. If not present, then this will default to the class name followed by the method name. You can only set the metricNameFormat on pointcuts where transactionStartPoint is set to false. excludeFromTransactionTrace When true the transaction trace will not be provided if this pointcut initiates the transaction. If the pointcut is reached in the middle of a transaction, then the transaction trace will still be present, but this method will be excluded from the call graph. ignoreTransaction When true the entire transaction will be ignored. transactionType Sets the type of the transaction. Possible values are background (default, reported as a non-web transaction) and web (reported as a web transaction). Child nodes for pointcut A pointcut can have several different child nodes: Value Definition nameTransaction If this element is present, the agent will name the transaction using the class name and method(s) instrumented by this pointcut. methodAnnotation The case sensitive full name of an annotation class including the package name. All methods that are marked with this annotation will be matched. className The case sensitive name of the class to match, including the package name. Pair this node with the method node. If this node is present on a pointcut, then the interfaceName node cannot be present on the same pointcut node. The className node has the attribute includeSubclasses. If true the methods on the class with the matching name will be instrumented along with the matching methods on any child class of this class. If false (default), only methods on the exact class specified will be instrumented. The className must follow these rules: Inner classes can be instrumented. The full package structure with dots between packages must be used. To match subclasses of the specified class, set the attribute includeSubclasses to true. interfaceName The case sensitive name of an interface, including the package name, whose implementation classes will be matched. Pair this node with the method node. If this node is present on a pointcut, then the className node cannot be present on the same pointcut node. The interfaceName must follow this rule: The full package structure with dots between packages must be used. method A method on the class to instrument. Pair this node with a className node. Also, the method node can have children. traceByReturnType The class name, including package, in the format used in bytecode, e.g. Ljava/lang/String;. All methods that return an object of that class will be matched. traceLambda A boolean indicating whether to match lambdas. The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non static methods (defaults to false); pattern - a string with the pattern to search for the lambda methods. Child nodes for method The method node can have several children. For more information and examples, see Troubleshooting Java custom instrumentation. Value Definition name The exact case sensitive name of the method to match. A method name node must follow these rules: Public, protected, private, and package methods can all be instrumented. Static and instance methods can be instrumented. Constructors cannot be instrumented. parameters The parameter types of the method specified in order. If the parameters element is not present, then all methods matching the name will be matched. This includes private and protected declarations. A method parameters node contains a list of the method's parameters, specified by type elements. Here are the major rules for the type elements: Primitives are specified using their normal name: int, float, double, long, byte, short, boolean, char. Objects require a full package structure. For example, do not use String in the XML; instead, use java.lang.String. Do not use generics with collection objects. For example, write java.util.List instead of java.util.List<String>. Include brackets for arrays. For example, an array of integers will be int[ ] and an array of strings will be java.lang.String[ ]. Include two sets of brackets for an array of arrays. For example, an array of arrays of longs would be long[ ][ ]. To send the parameter as an analytic event to New Relic One, add an XML attribute to the type element called attributeName. To use a method with no parameters, the parameters node needs to be present to match a \"no arguments\" method. returnType The case sensitive name of a class indicating a return type to match. All methods that return this class type will be matched. Example Here is a sample class and an XML file that could be used to instrument that class. Sample class package test; import java.util.HashMap; import java.util.Map; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class SampleTester { private String configName; private Map<String, Long> maxSampleTimes; public SampleTester(String pConfigName) { configName = pConfigName; maxSampleTimes = new HashMap<>(); } public void checkSample(String name, long[] times) { if (times != null) { maxSampleTimes.put(name, getFirst(times)); } else { maxSampleTimes.put(name, (long) getFirst()); } } private Long getFirst(long[] times) { return times[0]; } private int getFirst() { return 0; } public void printMaxRepeat(final long max) throws Exception { Runnable myRunnable = new Runnable() { public void run() { try { printMax(max); } catch (Exception e) { e.printStackTrace(); } } }; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(1); scheduledExecutor.scheduleWithFixedDelay(myRunnable, 0, 10000, TimeUnit.MILLISECONDS); } private void printMax(long max) { System.out.println(\"max is \" + max); } } Copy Sample XML instrumentation file and explanation <?xml version=\"1.0\" encoding=\"UTF-8\"?> <extension xmlns=\"https://newrelic.com/docs/java/xsd/v1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"newrelic-extension extension.xsd \" name=\"customExtension\" version=\"1.0\"> <instrumentation metricPrefix=\"EXAMPLE\"> <pointcut transactionStartPoint=\"true\"> <!--class name is preceded by package name--> <className>test.SampleTester</className> <method> <name>checkSample</name> <parameters> <type attributeName=\"sampleName\">java.lang.String</type> <type>long[]</type> </parameters> </method> <!--two methods with the same name but different signatures can share one node--> <method> <name>getFirst</name> </method> <method> <name>run</name> </method> </pointcut> <pointcut transactionStartPoint=\"false\" ignoreTransaction=\"false\" excludeFromTransactionTrace=\"false\" metricNameFormat=\"SampleTester/methods\"> <className>test.SampleTester</className> <method> <name>printMaxRepeat</name> </method> <method> <name>printMax</name> </method> </pointcut> </instrumentation> </extension> Copy The first block of the XML file specifies the name and version of the extension. As the XML extension is default enabled, that attribute is not specified. The second block specifies the methods in SampleClass that should be instrumented. A transaction is started at the beginning of the block. It is worth noting that in the example class, there are two methods that share a name (getFirst) but have different signatures. These are instrumented with a single method node. By removing the parameters node, all methods with the same name can be matched under one method node. In the third block, the specified methods do not have a transaction started on them. This is because the transaction has already been started in run. The transaction will not be ignored, and will be included in the transaction trace.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> XML <em>instrumentation</em> examples",
        "sections": "<em>Java</em> XML <em>instrumentation</em> examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "For your New Relic-monitored <em>Java</em> application, one <em>custom</em> <em>instrumentation</em> method is to use an XML file that lists the methods and classes you want to <em>instrument</em>. This documentation shows an example XML <em>instrumentation</em> file. For more information, see <em>Java</em> <em>instrumentation</em> by XML. Edit XML file in UI"
      },
      "id": "6043e05128ccbc04a22f94bd"
    },
    {
      "sections": [
        "Scala instrumentation",
        "Tip",
        "Scala frameworks",
        "Instrument Scala with the Scala API",
        "Important",
        "Use the Scala API",
        "Configure using the project/build.scala file",
        "Configure using the project/build.sbt file",
        "Segments",
        "Transactions",
        "Instrument Scala with the Java agent API",
        "More API functions",
        "Instrument Scala with XML instrumentation",
        "Additional instrumentation"
      ],
      "title": "Scala instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "7affd5ca652f6d59905d8cfc5ea4e6a57ffe793d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/frameworks/scala-installation-java/",
      "published_at": "2021-10-18T03:45:05Z",
      "updated_at": "2021-07-09T00:01:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic's Java agent installation directions. Tip For Heroku, see Java agent with Scala on Heroku. Scala frameworks If your framework is not natively supported by New Relic, or if you want to set up additional monitoring, custom instrumentation is a great way to dig deeper into your application. Instrument Scala with the Scala API The New Relic Scala agent API lets you control, customize, and extend the functionality of the APM Java agent using idiomatic Scala code. It can be used alongside the New Relic Java API as well as allow users to Create segments for synchronous and asynchronous anonymous functions Create segments for synchronous and asynchronous code blocks Create a transaction if one has not already been started Important For best results when using the API, ensure that you have the latest Java agent release. The New Relic Scala API requires Java agent 7.1.0 or higher. Use the Scala API To access the API class add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing S.V with the Scala version and X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing S.V with the Scala version and X.Y.Z with theJava agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Supported Scala versions are 2.10, 2.11, 2.12 and 2.13. Scala 3.0 users can use the 2.13 jar. The jar is deployed to Maven Central and it is also in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The underlying API methods are just stubs; the implementation is added when the Java agent is running. Segments To create segment for a synchronous code block use TraceOps.trace. For example: import com.newrelic.scala.api.TraceOps.trace trace(\"statement segment\") { val i = 1 val j = 2 println(i + j) } // trace can also be used as an expression val x: Int = trace(\"expression segment\") { val i = 1 val j = 2 i + j } println(x) // 2 Copy trace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.trace // implicit execution implicit val ec: ExecutionContext = ??? val x: Option[Int] = for { one <- trace(\"segment one\")(Option(1)) two <- trace(\"segment two\")(Option(one + 1)) three <- trace(\"segment three\")(Option(two + 1)) } yield three println(x) // Some(3) Copy If you want to create segment for an asynchronous code block containing a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the Future to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = asyncTrace(\"segment name\")(Future { Thread.sleep(5000) 1 }) x.foreach(println) // prints 1 on completion of Future Copy asyncTrace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three x.foreach(println) // prints 3 on completion of Future Copy If you want to create segment for a synchronous anonymous function use TraceOps.traceFun. For example: import com.newrelic.scala.api.TraceOps.traceFun val x: Option[Int] = Option(1) .map(traceFun(\"statement segment\")(i => i + 1)) println(x) //Some(2) Copy If you want to create segment for an asynchronous function that returns a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the function to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTraceFun // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = Future(1) .flatMap(asyncTraceFun(\"statement segment\")(i => Future(i + 1))) x.foreach(println) // prints 2 on completion of Future Copy Transactions Transactions can be created using the TraceOps.txn method. For example: import com.newrelic.scala.api.TraceOps.txn txn { val i = 1 val j = 2 println(i + j) } Copy txn can be used as a statement (as above) or as an expression import com.newrelic.scala.api.TraceOps.txn val i: Int = txn(1 + 2) //transaction created println(i) // 3 Copy txn can be used with any of the TraceOp methods to create segments. The example below create a transaction with 3 segments. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.{txn, asyncTrace} // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = txn( for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three ) x.foreach(println) // prints 3 on completion of Future Copy Instrument Scala with the Java agent API Instrument Scala to use the New Relic API class or annotations. Add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing X.Y.Z with the Java agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Import the NewRelic class and use it in your application: import com.newrelic.api.agent.NewRelic ... NewRelic.setTransactionName(null, \"/myTransaction\"); Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction. Instrument Scala with XML instrumentation XML instrumentation is available for any Scala application running with the Java agent. It allows instrumentation to be added without any changes to the code. For more information, see Java instrumentation by XML. Additional instrumentation If you use Kamon, take a look at the New Relic Kamon reporter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Scala <em>instrumentation</em>",
        "sections": "<em>Instrument</em> Scala with the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> is compatible with Scala, and supports New Relic API calls, annotations, and <em>custom</em> <em>instrumentation</em>. All information below is supplemental to New Relic&#x27;s <em>Java</em> <em>agent</em> installation directions. Tip For Heroku, see <em>Java</em> <em>agent</em> with Scala on Heroku. Scala frameworks If your"
      },
      "id": "6043b8bb196a671be4960f24"
    },
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-10-18T05:36:32Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.70784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples": [
    {
      "sections": [
        "Scala instrumentation",
        "Tip",
        "Scala frameworks",
        "Instrument Scala with the Scala API",
        "Important",
        "Use the Scala API",
        "Configure using the project/build.scala file",
        "Configure using the project/build.sbt file",
        "Segments",
        "Transactions",
        "Instrument Scala with the Java agent API",
        "More API functions",
        "Instrument Scala with XML instrumentation",
        "Additional instrumentation"
      ],
      "title": "Scala instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "7affd5ca652f6d59905d8cfc5ea4e6a57ffe793d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/frameworks/scala-installation-java/",
      "published_at": "2021-10-18T03:45:05Z",
      "updated_at": "2021-07-09T00:01:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic's Java agent installation directions. Tip For Heroku, see Java agent with Scala on Heroku. Scala frameworks If your framework is not natively supported by New Relic, or if you want to set up additional monitoring, custom instrumentation is a great way to dig deeper into your application. Instrument Scala with the Scala API The New Relic Scala agent API lets you control, customize, and extend the functionality of the APM Java agent using idiomatic Scala code. It can be used alongside the New Relic Java API as well as allow users to Create segments for synchronous and asynchronous anonymous functions Create segments for synchronous and asynchronous code blocks Create a transaction if one has not already been started Important For best results when using the API, ensure that you have the latest Java agent release. The New Relic Scala API requires Java agent 7.1.0 or higher. Use the Scala API To access the API class add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing S.V with the Scala version and X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing S.V with the Scala version and X.Y.Z with theJava agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Supported Scala versions are 2.10, 2.11, 2.12 and 2.13. Scala 3.0 users can use the 2.13 jar. The jar is deployed to Maven Central and it is also in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The underlying API methods are just stubs; the implementation is added when the Java agent is running. Segments To create segment for a synchronous code block use TraceOps.trace. For example: import com.newrelic.scala.api.TraceOps.trace trace(\"statement segment\") { val i = 1 val j = 2 println(i + j) } // trace can also be used as an expression val x: Int = trace(\"expression segment\") { val i = 1 val j = 2 i + j } println(x) // 2 Copy trace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.trace // implicit execution implicit val ec: ExecutionContext = ??? val x: Option[Int] = for { one <- trace(\"segment one\")(Option(1)) two <- trace(\"segment two\")(Option(one + 1)) three <- trace(\"segment three\")(Option(two + 1)) } yield three println(x) // Some(3) Copy If you want to create segment for an asynchronous code block containing a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the Future to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = asyncTrace(\"segment name\")(Future { Thread.sleep(5000) 1 }) x.foreach(println) // prints 1 on completion of Future Copy asyncTrace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three x.foreach(println) // prints 3 on completion of Future Copy If you want to create segment for a synchronous anonymous function use TraceOps.traceFun. For example: import com.newrelic.scala.api.TraceOps.traceFun val x: Option[Int] = Option(1) .map(traceFun(\"statement segment\")(i => i + 1)) println(x) //Some(2) Copy If you want to create segment for an asynchronous function that returns a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the function to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTraceFun // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = Future(1) .flatMap(asyncTraceFun(\"statement segment\")(i => Future(i + 1))) x.foreach(println) // prints 2 on completion of Future Copy Transactions Transactions can be created using the TraceOps.txn method. For example: import com.newrelic.scala.api.TraceOps.txn txn { val i = 1 val j = 2 println(i + j) } Copy txn can be used as a statement (as above) or as an expression import com.newrelic.scala.api.TraceOps.txn val i: Int = txn(1 + 2) //transaction created println(i) // 3 Copy txn can be used with any of the TraceOp methods to create segments. The example below create a transaction with 3 segments. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.{txn, asyncTrace} // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = txn( for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three ) x.foreach(println) // prints 3 on completion of Future Copy Instrument Scala with the Java agent API Instrument Scala to use the New Relic API class or annotations. Add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing X.Y.Z with the Java agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Import the NewRelic class and use it in your application: import com.newrelic.api.agent.NewRelic ... NewRelic.setTransactionName(null, \"/myTransaction\"); Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction. Instrument Scala with XML instrumentation XML instrumentation is available for any Scala application running with the Java agent. It allows instrumentation to be added without any changes to the code. For more information, see Java instrumentation by XML. Additional instrumentation If you use Kamon, take a look at the New Relic Kamon reporter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Scala <em>instrumentation</em>",
        "sections": "<em>Instrument</em> Scala with the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> is compatible with Scala, and supports New Relic API calls, annotations, and <em>custom</em> <em>instrumentation</em>. All information below is supplemental to New Relic&#x27;s <em>Java</em> <em>agent</em> installation directions. Tip For Heroku, see <em>Java</em> <em>agent</em> with Scala on Heroku. Scala frameworks If your"
      },
      "id": "6043b8bb196a671be4960f24"
    },
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-10-18T05:36:32Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.70784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    },
    {
      "sections": [
        "Messaging framework instrumentation",
        "Typical messaging",
        "Report the producing/consuming as external",
        "Add message metrics/custom parameters to current transaction",
        "Pass a distributed trace payload",
        "Edge cases",
        "Create a distributed trace payload and then receive a message",
        "Batch reading messages",
        "Capturing the processing time of the message",
        "For more help"
      ],
      "title": "Messaging framework instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "9b656fcf1790e65d1db825e35ab31c94b6561e08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are some messaging frameworks that New Relic doesnt support by default. If you are interested in instrumenting these frameworks with our API here are some guidelines to follow. Typical messaging In the typical case, there is a process that produces a message and a process that consumes the message. Some useful things you could do here are below. Note you must be within a transaction for these to report. Report the producing/consuming as external You can create MessageProduceParameters and MessageConsumeParameters with relevant data and then call reportAsExternal(Params) to report the calls as externals. For example, when producing a message this would look like: MessageProduceParameters params = MessageProduceParameters.library(\"libraryName\").destinationType(NAMED_TOPIC).destinationName(\"topicName\").inboundHeaders(null).build(); NewRelic.getAgent().getTransaction().getTracedMethod().reportAsExternal(params); Copy A similar solution would work on the consumer side. Add message metrics/custom parameters to current transaction If there is useful information you want to add to your current transaction about the message, you can do that easily by calling our addCustomParameter() API. This looks like this: NewRelic.addCustomParameter(\"topic-name\", topic); Copy Pass a distributed trace payload In order to track the work across processes/services, the messaging framework must have a way to pass along metadata with the message, whether its via headers or some other mechanism. You can create a distributed trace payload on the producer side that can be attached to the message and read on the consumer side. You must be in a transaction for this to work. To do this you would follow a pattern like this: @Trace(dispatcher = true) public void sendData(Producer producer){ final DistributedTracePayload payload = NewRelic.getAgent().getTransaction().createDistributedTracePayload(); headers.add(new RecordHeader(\"newrelic\", payload.text().getBytes(StandardCharsets.UTF_8))); data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\", headers); producer.send(data); } Copy And on the consumer side: @Trace(dispatcher = true) public void processData(ConsumerRecord record){ final Iterator<Header> nrHeaders = record.headers().headers(\"newrelic\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can instrument. Instrument Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra care. Below are suggestions on the best way to tackle them. Create a distributed trace payload and then receive a message The problem here is that you cant create a distributed trace payload and then accept a distributed trace payload within the same transaction in that order. This means that there are two attempts of distributed tracing and you have to choose which one you want. If you would like to accept the second payload rather than create the first one, you need to prevent the first payload from getting created. You can remove the custom instrumentation (if thats whats creating the payload) or disable instrumentation via our config Batch reading messages For batch consumption of messages, there is a problem of which distributed tracing payload you accept. If you are ok with linking just one of the distributed trace payloads then you can accept any one of the payloads in the batch but that will result in the rest of the payloads getting lost. However, if you want to see all of the distributed traces then youll need to create a transaction per message. The second solution could incur some overhead so take that into consideration when making a decision. A solution like that would look like: public void processMessages(ConsumerRecords<String, String> records) { for(ConsumerRecord<String, String> record: records) { processRecord(record); } } @Trace(dispatcher = true) private void processRecord(ConsumerRecord<String, String> record) { final Iterator<Header> nrHeaders = record.headers().headers(\"newrelicDTPayload\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This will only work if there isnt a transaction already started on the thread at this time. If there is one then just accepting one payload from the batch is your only solution. Capturing the processing time of the message If you would like to capture the processing time of a message then you will need to move the processing work into a method and then trace that method. For example: public void getMessages(){ KafkaConsumer consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(\"topic\")); while (true) { ConsumerRecords<String, String> recs = consumer.poll(10000); if (recs.count() == 0) { } else { for (ConsumerRecord<String, String> rec : recs) { processRec(rec); } } } } @Trace(dispatcher = true) private void processRec(ConsumerRecord<String, String> rec) { // some processing } Copy For more help Use the Guide to using the Java agent API to learn more about our Java agent API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.703186,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Messaging framework <em>instrumentation</em>",
        "sections": "Messaging framework <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.get<em>Agent</em>().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can <em>instrument</em>. <em>Instrument</em> Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra"
      },
      "id": "603ebc24196a67a6d7a83dc8"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation": [
    {
      "sections": [
        "Java XML instrumentation examples",
        "Edit XML file in UI",
        "XML file format",
        "Caution",
        "Root node: extension",
        "Instrumentation (child of extension)",
        "Pointcut (child of instrumentation)",
        "Child nodes for pointcut",
        "Child nodes for method",
        "Example",
        "Sample class",
        "Sample XML instrumentation file and explanation"
      ],
      "title": "Java XML instrumentation examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "e34a060717cb5620eec03de5dcf19f1be0b82fcf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples/",
      "published_at": "2021-10-18T05:38:05Z",
      "updated_at": "2021-07-09T00:54:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file that lists the methods and classes you want to instrument. This documentation shows an example XML instrumentation file. For more information, see Java instrumentation by XML. Edit XML file in UI To edit your XML file directly from the New Relic UI: Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. Select an edit existing XML file. Search the instrumentation history. XML file format The XML file format includes root and child nodes. Caution Do not instrument all of your methods, as this can lead to a metric grouping issue. Root node: extension The root node of an XML file is extension. It can have three different attributes: Value Definition name A unique but descriptive name identifying your XML extension. enabled Identifies whether the extension will be read by the Java agent. Default is true. If false, New Relic will ignore the extension. version The version of the extension. If two extensions have the same name, only the extension with the highest version will be used. Instrumentation (child of extension) The instrumentation node is a child of extension. It can have one attribute: metricPrefix. This is the prefix used for the metric names when the nameTransaction node is not specified. Default is CUSTOM. Pointcut (child of instrumentation) The pointcut is a child node of instrumentation and can have several attributes. Also, a pointcut can have several different child nodes. Value Definition transactionStartPoint If a transaction is not already in progress when this pointcut is reached, then a transaction will be started. If a transaction is already in progress, then that transaction will continue. A new transaction will not be created. metricNameFormat The name format to use for a metric. If not present, then this will default to the class name followed by the method name. You can only set the metricNameFormat on pointcuts where transactionStartPoint is set to false. excludeFromTransactionTrace When true the transaction trace will not be provided if this pointcut initiates the transaction. If the pointcut is reached in the middle of a transaction, then the transaction trace will still be present, but this method will be excluded from the call graph. ignoreTransaction When true the entire transaction will be ignored. transactionType Sets the type of the transaction. Possible values are background (default, reported as a non-web transaction) and web (reported as a web transaction). Child nodes for pointcut A pointcut can have several different child nodes: Value Definition nameTransaction If this element is present, the agent will name the transaction using the class name and method(s) instrumented by this pointcut. methodAnnotation The case sensitive full name of an annotation class including the package name. All methods that are marked with this annotation will be matched. className The case sensitive name of the class to match, including the package name. Pair this node with the method node. If this node is present on a pointcut, then the interfaceName node cannot be present on the same pointcut node. The className node has the attribute includeSubclasses. If true the methods on the class with the matching name will be instrumented along with the matching methods on any child class of this class. If false (default), only methods on the exact class specified will be instrumented. The className must follow these rules: Inner classes can be instrumented. The full package structure with dots between packages must be used. To match subclasses of the specified class, set the attribute includeSubclasses to true. interfaceName The case sensitive name of an interface, including the package name, whose implementation classes will be matched. Pair this node with the method node. If this node is present on a pointcut, then the className node cannot be present on the same pointcut node. The interfaceName must follow this rule: The full package structure with dots between packages must be used. method A method on the class to instrument. Pair this node with a className node. Also, the method node can have children. traceByReturnType The class name, including package, in the format used in bytecode, e.g. Ljava/lang/String;. All methods that return an object of that class will be matched. traceLambda A boolean indicating whether to match lambdas. The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non static methods (defaults to false); pattern - a string with the pattern to search for the lambda methods. Child nodes for method The method node can have several children. For more information and examples, see Troubleshooting Java custom instrumentation. Value Definition name The exact case sensitive name of the method to match. A method name node must follow these rules: Public, protected, private, and package methods can all be instrumented. Static and instance methods can be instrumented. Constructors cannot be instrumented. parameters The parameter types of the method specified in order. If the parameters element is not present, then all methods matching the name will be matched. This includes private and protected declarations. A method parameters node contains a list of the method's parameters, specified by type elements. Here are the major rules for the type elements: Primitives are specified using their normal name: int, float, double, long, byte, short, boolean, char. Objects require a full package structure. For example, do not use String in the XML; instead, use java.lang.String. Do not use generics with collection objects. For example, write java.util.List instead of java.util.List<String>. Include brackets for arrays. For example, an array of integers will be int[ ] and an array of strings will be java.lang.String[ ]. Include two sets of brackets for an array of arrays. For example, an array of arrays of longs would be long[ ][ ]. To send the parameter as an analytic event to New Relic One, add an XML attribute to the type element called attributeName. To use a method with no parameters, the parameters node needs to be present to match a \"no arguments\" method. returnType The case sensitive name of a class indicating a return type to match. All methods that return this class type will be matched. Example Here is a sample class and an XML file that could be used to instrument that class. Sample class package test; import java.util.HashMap; import java.util.Map; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class SampleTester { private String configName; private Map<String, Long> maxSampleTimes; public SampleTester(String pConfigName) { configName = pConfigName; maxSampleTimes = new HashMap<>(); } public void checkSample(String name, long[] times) { if (times != null) { maxSampleTimes.put(name, getFirst(times)); } else { maxSampleTimes.put(name, (long) getFirst()); } } private Long getFirst(long[] times) { return times[0]; } private int getFirst() { return 0; } public void printMaxRepeat(final long max) throws Exception { Runnable myRunnable = new Runnable() { public void run() { try { printMax(max); } catch (Exception e) { e.printStackTrace(); } } }; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(1); scheduledExecutor.scheduleWithFixedDelay(myRunnable, 0, 10000, TimeUnit.MILLISECONDS); } private void printMax(long max) { System.out.println(\"max is \" + max); } } Copy Sample XML instrumentation file and explanation <?xml version=\"1.0\" encoding=\"UTF-8\"?> <extension xmlns=\"https://newrelic.com/docs/java/xsd/v1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"newrelic-extension extension.xsd \" name=\"customExtension\" version=\"1.0\"> <instrumentation metricPrefix=\"EXAMPLE\"> <pointcut transactionStartPoint=\"true\"> <!--class name is preceded by package name--> <className>test.SampleTester</className> <method> <name>checkSample</name> <parameters> <type attributeName=\"sampleName\">java.lang.String</type> <type>long[]</type> </parameters> </method> <!--two methods with the same name but different signatures can share one node--> <method> <name>getFirst</name> </method> <method> <name>run</name> </method> </pointcut> <pointcut transactionStartPoint=\"false\" ignoreTransaction=\"false\" excludeFromTransactionTrace=\"false\" metricNameFormat=\"SampleTester/methods\"> <className>test.SampleTester</className> <method> <name>printMaxRepeat</name> </method> <method> <name>printMax</name> </method> </pointcut> </instrumentation> </extension> Copy The first block of the XML file specifies the name and version of the extension. As the XML extension is default enabled, that attribute is not specified. The second block specifies the methods in SampleClass that should be instrumented. A transaction is started at the beginning of the block. It is worth noting that in the example class, there are two methods that share a name (getFirst) but have different signatures. These are instrumented with a single method node. By removing the parameters node, all methods with the same name can be matched under one method node. In the third block, the specified methods do not have a transaction started on them. This is because the transaction has already been started in run. The transaction will not be ignored, and will be included in the transaction trace.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> XML <em>instrumentation</em> examples",
        "sections": "<em>Java</em> XML <em>instrumentation</em> examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "For your New Relic-monitored <em>Java</em> application, one <em>custom</em> <em>instrumentation</em> method is to use an XML file that lists the methods and classes you want to <em>instrument</em>. This documentation shows an example XML <em>instrumentation</em> file. For more information, see <em>Java</em> <em>instrumentation</em> by XML. Edit XML file in UI"
      },
      "id": "6043e05128ccbc04a22f94bd"
    },
    {
      "sections": [
        "Scala instrumentation",
        "Tip",
        "Scala frameworks",
        "Instrument Scala with the Scala API",
        "Important",
        "Use the Scala API",
        "Configure using the project/build.scala file",
        "Configure using the project/build.sbt file",
        "Segments",
        "Transactions",
        "Instrument Scala with the Java agent API",
        "More API functions",
        "Instrument Scala with XML instrumentation",
        "Additional instrumentation"
      ],
      "title": "Scala instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "7affd5ca652f6d59905d8cfc5ea4e6a57ffe793d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/frameworks/scala-installation-java/",
      "published_at": "2021-10-18T03:45:05Z",
      "updated_at": "2021-07-09T00:01:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic's Java agent installation directions. Tip For Heroku, see Java agent with Scala on Heroku. Scala frameworks If your framework is not natively supported by New Relic, or if you want to set up additional monitoring, custom instrumentation is a great way to dig deeper into your application. Instrument Scala with the Scala API The New Relic Scala agent API lets you control, customize, and extend the functionality of the APM Java agent using idiomatic Scala code. It can be used alongside the New Relic Java API as well as allow users to Create segments for synchronous and asynchronous anonymous functions Create segments for synchronous and asynchronous code blocks Create a transaction if one has not already been started Important For best results when using the API, ensure that you have the latest Java agent release. The New Relic Scala API requires Java agent 7.1.0 or higher. Use the Scala API To access the API class add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing S.V with the Scala version and X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing S.V with the Scala version and X.Y.Z with theJava agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Supported Scala versions are 2.10, 2.11, 2.12 and 2.13. Scala 3.0 users can use the 2.13 jar. The jar is deployed to Maven Central and it is also in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The underlying API methods are just stubs; the implementation is added when the Java agent is running. Segments To create segment for a synchronous code block use TraceOps.trace. For example: import com.newrelic.scala.api.TraceOps.trace trace(\"statement segment\") { val i = 1 val j = 2 println(i + j) } // trace can also be used as an expression val x: Int = trace(\"expression segment\") { val i = 1 val j = 2 i + j } println(x) // 2 Copy trace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.trace // implicit execution implicit val ec: ExecutionContext = ??? val x: Option[Int] = for { one <- trace(\"segment one\")(Option(1)) two <- trace(\"segment two\")(Option(one + 1)) three <- trace(\"segment three\")(Option(two + 1)) } yield three println(x) // Some(3) Copy If you want to create segment for an asynchronous code block containing a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the Future to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = asyncTrace(\"segment name\")(Future { Thread.sleep(5000) 1 }) x.foreach(println) // prints 1 on completion of Future Copy asyncTrace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three x.foreach(println) // prints 3 on completion of Future Copy If you want to create segment for a synchronous anonymous function use TraceOps.traceFun. For example: import com.newrelic.scala.api.TraceOps.traceFun val x: Option[Int] = Option(1) .map(traceFun(\"statement segment\")(i => i + 1)) println(x) //Some(2) Copy If you want to create segment for an asynchronous function that returns a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the function to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTraceFun // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = Future(1) .flatMap(asyncTraceFun(\"statement segment\")(i => Future(i + 1))) x.foreach(println) // prints 2 on completion of Future Copy Transactions Transactions can be created using the TraceOps.txn method. For example: import com.newrelic.scala.api.TraceOps.txn txn { val i = 1 val j = 2 println(i + j) } Copy txn can be used as a statement (as above) or as an expression import com.newrelic.scala.api.TraceOps.txn val i: Int = txn(1 + 2) //transaction created println(i) // 3 Copy txn can be used with any of the TraceOp methods to create segments. The example below create a transaction with 3 segments. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.{txn, asyncTrace} // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = txn( for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three ) x.foreach(println) // prints 3 on completion of Future Copy Instrument Scala with the Java agent API Instrument Scala to use the New Relic API class or annotations. Add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing X.Y.Z with the Java agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Import the NewRelic class and use it in your application: import com.newrelic.api.agent.NewRelic ... NewRelic.setTransactionName(null, \"/myTransaction\"); Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction. Instrument Scala with XML instrumentation XML instrumentation is available for any Scala application running with the Java agent. It allows instrumentation to be added without any changes to the code. For more information, see Java instrumentation by XML. Additional instrumentation If you use Kamon, take a look at the New Relic Kamon reporter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Scala <em>instrumentation</em>",
        "sections": "<em>Instrument</em> Scala with the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> is compatible with Scala, and supports New Relic API calls, annotations, and <em>custom</em> <em>instrumentation</em>. All information below is supplemental to New Relic&#x27;s <em>Java</em> <em>agent</em> installation directions. Tip For Heroku, see <em>Java</em> <em>agent</em> with Scala on Heroku. Scala frameworks If your"
      },
      "id": "6043b8bb196a671be4960f24"
    },
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-10-18T05:36:32Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.70784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/troubleshooting-java-custom-instrumentation": [
    {
      "sections": [
        "Java XML instrumentation examples",
        "Edit XML file in UI",
        "XML file format",
        "Caution",
        "Root node: extension",
        "Instrumentation (child of extension)",
        "Pointcut (child of instrumentation)",
        "Child nodes for pointcut",
        "Child nodes for method",
        "Example",
        "Sample class",
        "Sample XML instrumentation file and explanation"
      ],
      "title": "Java XML instrumentation examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "e34a060717cb5620eec03de5dcf19f1be0b82fcf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples/",
      "published_at": "2021-10-18T05:38:05Z",
      "updated_at": "2021-07-09T00:54:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file that lists the methods and classes you want to instrument. This documentation shows an example XML instrumentation file. For more information, see Java instrumentation by XML. Edit XML file in UI To edit your XML file directly from the New Relic UI: Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. Select an edit existing XML file. Search the instrumentation history. XML file format The XML file format includes root and child nodes. Caution Do not instrument all of your methods, as this can lead to a metric grouping issue. Root node: extension The root node of an XML file is extension. It can have three different attributes: Value Definition name A unique but descriptive name identifying your XML extension. enabled Identifies whether the extension will be read by the Java agent. Default is true. If false, New Relic will ignore the extension. version The version of the extension. If two extensions have the same name, only the extension with the highest version will be used. Instrumentation (child of extension) The instrumentation node is a child of extension. It can have one attribute: metricPrefix. This is the prefix used for the metric names when the nameTransaction node is not specified. Default is CUSTOM. Pointcut (child of instrumentation) The pointcut is a child node of instrumentation and can have several attributes. Also, a pointcut can have several different child nodes. Value Definition transactionStartPoint If a transaction is not already in progress when this pointcut is reached, then a transaction will be started. If a transaction is already in progress, then that transaction will continue. A new transaction will not be created. metricNameFormat The name format to use for a metric. If not present, then this will default to the class name followed by the method name. You can only set the metricNameFormat on pointcuts where transactionStartPoint is set to false. excludeFromTransactionTrace When true the transaction trace will not be provided if this pointcut initiates the transaction. If the pointcut is reached in the middle of a transaction, then the transaction trace will still be present, but this method will be excluded from the call graph. ignoreTransaction When true the entire transaction will be ignored. transactionType Sets the type of the transaction. Possible values are background (default, reported as a non-web transaction) and web (reported as a web transaction). Child nodes for pointcut A pointcut can have several different child nodes: Value Definition nameTransaction If this element is present, the agent will name the transaction using the class name and method(s) instrumented by this pointcut. methodAnnotation The case sensitive full name of an annotation class including the package name. All methods that are marked with this annotation will be matched. className The case sensitive name of the class to match, including the package name. Pair this node with the method node. If this node is present on a pointcut, then the interfaceName node cannot be present on the same pointcut node. The className node has the attribute includeSubclasses. If true the methods on the class with the matching name will be instrumented along with the matching methods on any child class of this class. If false (default), only methods on the exact class specified will be instrumented. The className must follow these rules: Inner classes can be instrumented. The full package structure with dots between packages must be used. To match subclasses of the specified class, set the attribute includeSubclasses to true. interfaceName The case sensitive name of an interface, including the package name, whose implementation classes will be matched. Pair this node with the method node. If this node is present on a pointcut, then the className node cannot be present on the same pointcut node. The interfaceName must follow this rule: The full package structure with dots between packages must be used. method A method on the class to instrument. Pair this node with a className node. Also, the method node can have children. traceByReturnType The class name, including package, in the format used in bytecode, e.g. Ljava/lang/String;. All methods that return an object of that class will be matched. traceLambda A boolean indicating whether to match lambdas. The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non static methods (defaults to false); pattern - a string with the pattern to search for the lambda methods. Child nodes for method The method node can have several children. For more information and examples, see Troubleshooting Java custom instrumentation. Value Definition name The exact case sensitive name of the method to match. A method name node must follow these rules: Public, protected, private, and package methods can all be instrumented. Static and instance methods can be instrumented. Constructors cannot be instrumented. parameters The parameter types of the method specified in order. If the parameters element is not present, then all methods matching the name will be matched. This includes private and protected declarations. A method parameters node contains a list of the method's parameters, specified by type elements. Here are the major rules for the type elements: Primitives are specified using their normal name: int, float, double, long, byte, short, boolean, char. Objects require a full package structure. For example, do not use String in the XML; instead, use java.lang.String. Do not use generics with collection objects. For example, write java.util.List instead of java.util.List<String>. Include brackets for arrays. For example, an array of integers will be int[ ] and an array of strings will be java.lang.String[ ]. Include two sets of brackets for an array of arrays. For example, an array of arrays of longs would be long[ ][ ]. To send the parameter as an analytic event to New Relic One, add an XML attribute to the type element called attributeName. To use a method with no parameters, the parameters node needs to be present to match a \"no arguments\" method. returnType The case sensitive name of a class indicating a return type to match. All methods that return this class type will be matched. Example Here is a sample class and an XML file that could be used to instrument that class. Sample class package test; import java.util.HashMap; import java.util.Map; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class SampleTester { private String configName; private Map<String, Long> maxSampleTimes; public SampleTester(String pConfigName) { configName = pConfigName; maxSampleTimes = new HashMap<>(); } public void checkSample(String name, long[] times) { if (times != null) { maxSampleTimes.put(name, getFirst(times)); } else { maxSampleTimes.put(name, (long) getFirst()); } } private Long getFirst(long[] times) { return times[0]; } private int getFirst() { return 0; } public void printMaxRepeat(final long max) throws Exception { Runnable myRunnable = new Runnable() { public void run() { try { printMax(max); } catch (Exception e) { e.printStackTrace(); } } }; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(1); scheduledExecutor.scheduleWithFixedDelay(myRunnable, 0, 10000, TimeUnit.MILLISECONDS); } private void printMax(long max) { System.out.println(\"max is \" + max); } } Copy Sample XML instrumentation file and explanation <?xml version=\"1.0\" encoding=\"UTF-8\"?> <extension xmlns=\"https://newrelic.com/docs/java/xsd/v1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"newrelic-extension extension.xsd \" name=\"customExtension\" version=\"1.0\"> <instrumentation metricPrefix=\"EXAMPLE\"> <pointcut transactionStartPoint=\"true\"> <!--class name is preceded by package name--> <className>test.SampleTester</className> <method> <name>checkSample</name> <parameters> <type attributeName=\"sampleName\">java.lang.String</type> <type>long[]</type> </parameters> </method> <!--two methods with the same name but different signatures can share one node--> <method> <name>getFirst</name> </method> <method> <name>run</name> </method> </pointcut> <pointcut transactionStartPoint=\"false\" ignoreTransaction=\"false\" excludeFromTransactionTrace=\"false\" metricNameFormat=\"SampleTester/methods\"> <className>test.SampleTester</className> <method> <name>printMaxRepeat</name> </method> <method> <name>printMax</name> </method> </pointcut> </instrumentation> </extension> Copy The first block of the XML file specifies the name and version of the extension. As the XML extension is default enabled, that attribute is not specified. The second block specifies the methods in SampleClass that should be instrumented. A transaction is started at the beginning of the block. It is worth noting that in the example class, there are two methods that share a name (getFirst) but have different signatures. These are instrumented with a single method node. By removing the parameters node, all methods with the same name can be matched under one method node. In the third block, the specified methods do not have a transaction started on them. This is because the transaction has already been started in run. The transaction will not be ignored, and will be included in the transaction trace.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> XML <em>instrumentation</em> examples",
        "sections": "<em>Java</em> XML <em>instrumentation</em> examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "For your New Relic-monitored <em>Java</em> application, one <em>custom</em> <em>instrumentation</em> method is to use an XML file that lists the methods and classes you want to <em>instrument</em>. This documentation shows an example XML <em>instrumentation</em> file. For more information, see <em>Java</em> <em>instrumentation</em> by XML. Edit XML file in UI"
      },
      "id": "6043e05128ccbc04a22f94bd"
    },
    {
      "sections": [
        "Scala instrumentation",
        "Tip",
        "Scala frameworks",
        "Instrument Scala with the Scala API",
        "Important",
        "Use the Scala API",
        "Configure using the project/build.scala file",
        "Configure using the project/build.sbt file",
        "Segments",
        "Transactions",
        "Instrument Scala with the Java agent API",
        "More API functions",
        "Instrument Scala with XML instrumentation",
        "Additional instrumentation"
      ],
      "title": "Scala instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "7affd5ca652f6d59905d8cfc5ea4e6a57ffe793d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/frameworks/scala-installation-java/",
      "published_at": "2021-10-18T03:45:05Z",
      "updated_at": "2021-07-09T00:01:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent is compatible with Scala, and supports New Relic API calls, annotations, and custom instrumentation. All information below is supplemental to New Relic's Java agent installation directions. Tip For Heroku, see Java agent with Scala on Heroku. Scala frameworks If your framework is not natively supported by New Relic, or if you want to set up additional monitoring, custom instrumentation is a great way to dig deeper into your application. Instrument Scala with the Scala API The New Relic Scala agent API lets you control, customize, and extend the functionality of the APM Java agent using idiomatic Scala code. It can be used alongside the New Relic Java API as well as allow users to Create segments for synchronous and asynchronous anonymous functions Create segments for synchronous and asynchronous code blocks Create a transaction if one has not already been started Important For best results when using the API, ensure that you have the latest Java agent release. The New Relic Scala API requires Java agent 7.1.0 or higher. Use the Scala API To access the API class add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing S.V with the Scala version and X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing S.V with the Scala version and X.Y.Z with theJava agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-scala-api_S.V\" % \"X.Y.Z\" Copy Supported Scala versions are 2.10, 2.11, 2.12 and 2.13. Scala 3.0 users can use the 2.13 jar. The jar is deployed to Maven Central and it is also in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The underlying API methods are just stubs; the implementation is added when the Java agent is running. Segments To create segment for a synchronous code block use TraceOps.trace. For example: import com.newrelic.scala.api.TraceOps.trace trace(\"statement segment\") { val i = 1 val j = 2 println(i + j) } // trace can also be used as an expression val x: Int = trace(\"expression segment\") { val i = 1 val j = 2 i + j } println(x) // 2 Copy trace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.trace // implicit execution implicit val ec: ExecutionContext = ??? val x: Option[Int] = for { one <- trace(\"segment one\")(Option(1)) two <- trace(\"segment two\")(Option(one + 1)) three <- trace(\"segment three\")(Option(two + 1)) } yield three println(x) // Some(3) Copy If you want to create segment for an asynchronous code block containing a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the Future to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = asyncTrace(\"segment name\")(Future { Thread.sleep(5000) 1 }) x.foreach(println) // prints 1 on completion of Future Copy asyncTrace can also be used in Scala For comprehensions import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTrace // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three x.foreach(println) // prints 3 on completion of Future Copy If you want to create segment for a synchronous anonymous function use TraceOps.traceFun. For example: import com.newrelic.scala.api.TraceOps.traceFun val x: Option[Int] = Option(1) .map(traceFun(\"statement segment\")(i => i + 1)) println(x) //Some(2) Copy If you want to create segment for an asynchronous function that returns a Scala Future use TraceOps.asyncTrace. This will ensure the timing for the segment includes the time taken for the function to complete. In the example below segment time will be no less than 5 seconds due to the delay created in the wrapped Future. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.asyncTraceFun // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = Future(1) .flatMap(asyncTraceFun(\"statement segment\")(i => Future(i + 1))) x.foreach(println) // prints 2 on completion of Future Copy Transactions Transactions can be created using the TraceOps.txn method. For example: import com.newrelic.scala.api.TraceOps.txn txn { val i = 1 val j = 2 println(i + j) } Copy txn can be used as a statement (as above) or as an expression import com.newrelic.scala.api.TraceOps.txn val i: Int = txn(1 + 2) //transaction created println(i) // 3 Copy txn can be used with any of the TraceOp methods to create segments. The example below create a transaction with 3 segments. import scala.concurrent.{ExecutionContext, Future} import com.newrelic.scala.api.TraceOps.{txn, asyncTrace} // implicit execution implicit val ec: ExecutionContext = ??? val x: Future[Int] = txn( for { one <- asyncTrace(\"segment one\")(Future(1)) two <- asyncTrace(\"segment two\")(Future(one + 1)) three <- asyncTrace(\"segment three\")(Future(two + 1)) } yield three ) x.foreach(println) // prints 3 on completion of Future Copy Instrument Scala with the Java agent API Instrument Scala to use the New Relic API class or annotations. Add the following information to your Scala configuration file: Configure using the project/build.scala file Add the following line (replacing X.Y.Z with the Java agent version you use) to the appDependencies method in your application's project/build.scala file: \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Configure using the project/build.sbt file Add the following line (replacing X.Y.Z with the Java agent version you use) to your application's project/build.sbt file: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\" Copy Import the NewRelic class and use it in your application: import com.newrelic.api.agent.NewRelic ... NewRelic.setTransactionName(null, \"/myTransaction\"); Copy More API functions For more about the Java agent API and its functionality, see the Java agent API introduction. Instrument Scala with XML instrumentation XML instrumentation is available for any Scala application running with the Java agent. It allows instrumentation to be added without any changes to the code. For more information, see Java instrumentation by XML. Additional instrumentation If you use Kamon, take a look at the New Relic Kamon reporter.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Scala <em>instrumentation</em>",
        "sections": "<em>Instrument</em> Scala with the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> is compatible with Scala, and supports New Relic API calls, annotations, and <em>custom</em> <em>instrumentation</em>. All information below is supplemental to New Relic&#x27;s <em>Java</em> <em>agent</em> installation directions. Tip For Heroku, see <em>Java</em> <em>agent</em> with Scala on Heroku. Scala frameworks If your"
      },
      "id": "6043b8bb196a671be4960f24"
    },
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-10-18T05:36:32Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.70784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    }
  ],
  "/docs/agents/java-agent/features/jvms-page-java-view-app-server-metrics-jmx": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.30596,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "&#x27;s metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic <em>Java</em> <em>agent</em> JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic <em>Java</em> <em>agent</em>. No additional setup is needed, simply install the <em>Java</em> <em>agent</em>, make sure that the JFR service"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.79623,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " Asynchronous instrumentation For supported frameworks, the <em>Java</em> <em>agent</em> usually instruments async work automatically. However, you can use the <em>Java</em> <em>agent</em> API to extend this instrumentation. Other instrumented <em>features</em> EJB Session Beans 3.0 or higher JMX JSP (<em>Java</em> Server Pages) 2.0 to 2.2 Scala 2.9.3"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-10-18T05:35:40Z",
      "updated_at": "2021-09-27T15:21:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # Real-time profiling using Java Flight Recorder (JFR). # This feature reports dimensional metrics to the ingest endpoint configured by # metric_ingest_uri and events to the ingest endpoint configured by event_ingest_uri. # Both ingest endpoints default to US production but they will be automatically set to EU # production when using an EU license key. Other ingest endpoints can be configured manually. # Requires a JVM that provides the JFR library. jfr: # Set to true to enable Real-time profiling with JFR. # Default is false. enabled: false # Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. # Audit logging is extremely verbose and should only be used for troubleshooting purposes. # Default is false. audit_logging: false # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.87013,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;configuration&#x2F;<em>java</em>-<em>agent</em>-configuration-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    }
  ],
  "/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics": [
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.79623,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " Asynchronous instrumentation For supported frameworks, the <em>Java</em> <em>agent</em> usually instruments async work automatically. However, you can use the <em>Java</em> <em>agent</em> API to extend this instrumentation. Other instrumented <em>features</em> EJB Session Beans 3.0 or higher JMX JSP (<em>Java</em> Server Pages) 2.0 to 2.2 Scala 2.9.3"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "JVMs page (Java): View app server metrics from JMX",
        "View JVM metrics",
        "Tabs available by app server",
        "Metrics available by tab",
        "Data source metrics by app server",
        "Enable for Spring Boot 2.2 and higher with Tomcat",
        "Enable WebSphere PMI metrics",
        "Enable all statistic sets (recommended)",
        "Enable custom statistic sets (advanced)",
        "Collected WebSphere PMI metrics",
        "stats.ActiveCount",
        "maximumSize",
        "stats.CommittedCount",
        "stats.RolledbackCount",
        "stats.GlobalTimeoutCount",
        "stats.LiveCount",
        "WebLogic JMX metrics",
        "Tip",
        "ThreadCount",
        "TotalStartedThreadCount",
        "LoadedClassCount",
        "UnloadedClassCount",
        "HoggingThreadCount",
        "ExecuteThreadIdleCount",
        "StandbyThreadCount",
        "TransactionTotalCount",
        "TransactionCommittedTotalCount",
        "TransactionRolledBackTotalCount",
        "TransactionAbandonedTotalCount",
        "NumAvailable",
        "CurrCapacity",
        "ConnectionsTotalCount",
        "ActiveConnectionsCurrentCount",
        "LeakedConnectionCount",
        "PrepStmtCacheCurrentSize",
        "WaitingForConnectionCurrentCount",
        "WaitingForConnectionTotal",
        "WaitingForConnectionSuccessTotal",
        "WaitingForConnectionFailureTotal",
        "AccessTotalCount - MissTotalCount",
        "MissTotalCount",
        "WaiterCurrentCount",
        "DestroyedTotalCount",
        "BeansInUseCurrentCount",
        "PooledBeansCurrentCount",
        "TransactionsCommittedTotalCount +TransactionsRolledBackTotalCount +TransactionsTimedOutTotalCount",
        "TransactionsCommittedTotalCount",
        "TransactionsRolledBackTotalCount",
        "TransactionsTimedOutTotalCount"
      ],
      "title": "JVMs page (Java): View app server metrics from JMX",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "da87ac2a630aa7d23dcfcd29838c92a0ec1b3ec3",
      "image": "https://docs.newrelic.com/static/9fc8aafbabec1473134b718135fdef74/c1b63/apm_jvm.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/jvms-page-java-view-app-server-metrics-jmx/",
      "published_at": "2021-10-18T06:06:57Z",
      "updated_at": "2021-03-16T04:31:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's Java agent to collect and view additional metrics provided by the most common application servers via JMX. The collected metrics vary by app server and include measurements of thread pools, HTTP sessions, and transactions. View JVM metrics Application servers collect and report different metrics, which appear on APM's JVMs page. (For applications using New Relic via Heroku, the JVMs page is named Instances.) At a minimum, each app server collects and reports metric data on memory. For instructions on enabling JMX metrics, refer to your app server's documentation. To view JVM metrics: Go to one.newrelic.com > APM > (select an app) > Monitoring > JVMs > (select a JVM). From the selected JVM's Memory page, use any of New Relic's standard user interface functions to drill down into detailed information. To view other metrics, select any available tab. Optional: To use the thread profiler to look for bottlenecks in data on executing threads, select Profile this JVM. one.newrelic.com > APM > (select an app) > Monitoring > JVMs: Depending on the metrics your app server is reporting, one or more tabs appear on your JVM page. Tabs available by app server This table lists which tabs appear on the JVM page for app servers. If your app server does not report a particular type of metric data, the tab does not appear on your JVM page. App server Memory Thread pools HTTP sessions App server transactions Data sources Glassfish JBoss 5AS JBoss 6AS JBoss 6EAP JBoss 7AS Jetty Resin 3 Resin 4 Tomcat TomEE WebLogic Websphere Liberty Websphere Traditional WildFly Metrics available by tab Here is a summary of the metrics available from the JVM page. If the app server does not support a particular metric, that tab does not appear on your JVM page. JMX Metric charts Memory Heap memory usage: Each chart shows the used and committed heap space in MB for a given heap. Non-heap memory pool usage for the JVM: The used code cache and used CMS Perm Gen in MB. Garbage collection: The garbage collection CPU time. Class count: The loaded and unloaded class count for the JVM. Threads Thread count: The current number of active threads in the JVM. Thread pool: The active and idle thread count for the pool. On supported app servers, a chart shows each thread pool present in the app server, as well as the ratio of active to maximum thread count for each thread pool. HTTP sessions Session: The active, invalidated by timeout, and invalidated HTTP session counts for the application. On supported app servers, a chart shows each application present in the app server. App server transactions Active transaction: The number of active transactions within the app server's transaction manager. Created transaction: The change in the total number of created transactions per app server. Some app servers separate top level transactions and nested transactions. Finished transaction: The change in the total number of finished transactions per app server. Some app servers separate them by aborted and committed completed transactions. Data sources The metrics for the data source tab vary by app server. For more details, see Data source metrics by app server. For details on WebLogic's data source metrics, see WebLogic JMX metrics. Data source metrics by app server For supported app servers, the agent collects JMX data source metrics. You can view these metrics at one.newrelic.com > APM > (select an app) > Monitoring > JVMs > Data sources. To see these metrics, ensure that your data source has been properly configured for JMX monitoring for your app server. App server Metrics Tomcat Max connections: The maximum connections available for a data source. This is generally a configurable parameter. Active connections: The current number of active connections in a data source. Idle connections: The current number of idle connections in a data source. WebSphere Liberty Max connections: The maximum connections available for a data source. This is generally a configurable parameter. Active connections: The current number of active connections in a data source. Idle connections: The current number of idle connections in a data source. Wait time: The average amount of time a connections needs to wait before being handled. Destroyed connections: The number of destroyed connections. Resin Max connections: The maximum connections available for a data source. This is generally a configurable parameter. Active connections: The current number of active connections in a data source. Idle connections: The current number of idle connections in a data source. Created connections: The number of created connections. Enable for Spring Boot 2.2 and higher with Tomcat To enable New Relic to access Tomcat JMX metrics when running with Spring Boot 2.2 and higher, the system property server.tomcat.mbeanregistry.enabled must be set to true. See the Spring Boot 2.2 release notes. Enable WebSphere PMI metrics To enable New Relic to access WebSphere PMI metrics, you will need to configure WebSphere to monitor the necessary statistic sets. Enable all statistic sets (recommended) The simplest approach is to enable the collection of all statistic sets: If you are using Java 2 Security, ensure you have granted New Relic proper permissions. From the WebSphere admin console, select Monitoring and Tuning > Performance Monitoring Infrastructure (PMI) > (your server name). Select the Enable Performance Monitoring Infrastructure (PMI) checkbox. In the Currently monitored statistic set section, select All, then save your changes. Enable custom statistic sets (advanced) You can also collect only the PMI metrics that New Relic monitors by default. To collect only some PMI metrics: If you are using Java 2 Security, ensure you have granted New Relic proper permissions. From the WebSphere admin console, select Monitoring and Tuning > Performance Monitoring Infrastructure (PMI) > (selected app server). Select the Enable Performance Monitoring Infrastructure (PMI) checkbox. Select Custom. From the custom statistic set list, enable the following metrics: In the ThreadPool category, select the ActiveCount and PoolSize checkboxes. In the Servlet Session Manager category, select the ActiveCount and LiveCount checkboxes. In the Transaction Manager category, select the CommittedCount, RolledbackCount, and GlobalTimeoutCount checkboxes. From the Messages panel, select Save directly to the master configuration. Collected WebSphere PMI metrics When enabled, New Relic collects the following WebSphere PMI metrics. If you want other PMI metrics besides these to be collected and displayed in New Relic custom dashboards, use JMX instrumentation. stats.ActiveCount WebSphere PMI metrics Details Attribute stats.ActiveCount Object name pattern WebSphere:type=ThreadPool,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/ThreadPool/WebContainer/Active Copy Type Simple maximumSize WebSphere PMI metrics Details Attribute maximumSize Object name pattern WebSphere:type=ThreadPool,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/ThreadPool/WebContainer/Max Copy Type Simple stats.CommittedCount WebSphere PMI metrics Details Attribute stats.CommittedCount Object name pattern WebSphere:j2eeType=JTAResource,type=TransactionService,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/JTA/TransactionService/Committed Copy Type Simple stats.RolledbackCount WebSphere PMI metrics Details Attribute stats.RolledbackCount Object name pattern WebSphere:j2eeType=JTAResource,type=TransactionService,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/JTA/TransactionService/Rolled Back Copy Type Simple stats.GlobalTimeoutCount WebSphere PMI metrics Details Attribute stats.GlobalTimeoutCount Object name pattern WebSphere:j2eeType=JTAResource,type=TransactionService,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/JTA/TransactionService/Timed Out Copy Type Simple stats.LiveCount WebSphere PMI metrics Details Attribute stats.GlobalTimeoutCount Object name pattern WebSphere:type=SessionManager,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/Session/DefaultApplication#DefaultWebApplication.war/Active Copy Type Simple WebLogic JMX metrics In WebLogic, JMX is enabled by default. New Relic collects the following mbeans metrics. Tip To collect additional JMX metrics, use a custom YAML file. ThreadCount WebLogic JMX metrics Details Attribute ThreadCount Object name pattern java.lang:type=Threading Copy New Relic metric JmxBuiltIn/Threads/Thread Count Copy Type Simple TotalStartedThreadCount WebLogic JMX metrics Details Attribute TotalStartedThreadCount Object name pattern java.lang:type=Threading Copy New Relic metric JmxBuiltIn/Threads/TotalStartedCount Copy Type Simple LoadedClassCount WebLogic JMX metrics Details Attribute LoadedClassCount Object name pattern java.lang:type=ClassLoading Copy New Relic metric JmxBuiltIn/Classes/Loaded Copy Type Simple UnloadedClassCount WebLogic JMX metrics Details Attribute UnloadedClassCount Object name pattern java.lang:type=ClassLoading Copy New Relic metric JmxBuiltIn/Classes/Unloaded Copy Type Simple HoggingThreadCount WebLogic JMX metrics Details Attribute HoggingThreadCount Object name pattern com.bea:ServerRuntime=*,Name=ThreadPoolRuntime,Type=ThreadPoolRuntime Copy New Relic metric JmxBuiltIn/ThreadPool/{Name}/Active Copy Type Simple ExecuteThreadIdleCount WebLogic JMX metrics Details Attribute ExecuteThreadIdleCount Object name pattern com.bea:ServerRuntime=*,Name=ThreadPoolRuntime,Type=ThreadPoolRuntime Copy New Relic metric JmxBuiltIn/ThreadPool/{Name}/Idle Copy Type Simple StandbyThreadCount WebLogic JMX metrics Details Attribute StandbyThreadCount Object name pattern com.bea:ServerRuntime=*,Name=ThreadPoolRuntime,Type=ThreadPoolRuntime Copy New Relic metric JmxBuiltIn/ThreadPool/{Name}/Standby Copy Type Simple TransactionTotalCount WebLogic JMX metrics Details Attribute TransactionTotalCount Object name pattern com.bea:ServerRuntime=*,Name=JTARuntime,Type=JTARuntime Copy New Relic metric JmxBuiltIn/JTA/{Name}/Count Copy Type Monotonic TransactionCommittedTotalCount WebLogic JMX metrics Details Attribute TransactionCommittedTotalCount Object name pattern com.bea:ServerRuntime=*,Name=JTARuntime,Type=JTARuntime Copy New Relic metric JmxBuiltIn/JTA/{Name}/Committed Copy Type Monotonic TransactionRolledBackTotalCount WebLogic JMX metrics Details Attribute TransactionRolledBackTotalCount Object name pattern com.bea:ServerRuntime=*,Name=JTARuntime,Type=JTARuntime Copy New Relic metric JmxBuiltIn/JTA/{Name}/Rolled Back Copy Type Monotonic TransactionAbandonedTotalCount WebLogic JMX metrics Details Attribute TransactionAbandonedTotalCount Object name pattern com.bea:ServerRuntime=*,Name=JTARuntime,Type=JTARuntime Copy New Relic metric JmxBuiltIn/JTA/{Name}/Abandoned Copy Type Monotonic NumAvailable WebLogic JMX metrics Details Attribute NumAvailable Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/Available Copy Type Simple CurrCapacity WebLogic JMX metrics Details Attribute CurrCapacity Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/PoolSize Copy Type Simple ConnectionsTotalCount WebLogic JMX metrics Details Attribute ConnectionsTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/Created Copy Type Monotonic ActiveConnectionsCurrentCount WebLogic JMX metrics Details Attribute ActiveConnectionsCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/Active Copy Type Simple LeakedConnectionCount WebLogic JMX metrics Details Attribute LeakedConnectionCount Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/Leaked Copy Type Monotonic PrepStmtCacheCurrentSize WebLogic JMX metrics Details Attribute PrepStmtCacheCurrentSize Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Statement Cache/Size Copy Type Simple WaitingForConnectionCurrentCount WebLogic JMX metrics Details Attribute WaitingForConnectionCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Requests/Currently Waiting Copy Type Simple WaitingForConnectionTotal WebLogic JMX metrics Details Attribute WaitingForConnectionTotal Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Requests/Count Copy Type Monotonic WaitingForConnectionSuccessTotal WebLogic JMX metrics Details Attribute WaitingForConnectionSuccessTotal Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Requests/Successful Copy Type Monotonic WaitingForConnectionFailureTotal WebLogic JMX metrics Details Attribute WaitingForConnectionFailureTotal Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Requests/Failed Copy Type Monotonic AccessTotalCount - MissTotalCount WebLogic JMX metrics Details Attribute AccessTotalCount - MissTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Attempts/Successful Copy Type Monotonic MissTotalCount WebLogic JMX metrics Details Attribute MissTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Attempts/Failed Copy Type Monotonic WaiterCurrentCount WebLogic JMX metrics Details Attribute WaiterCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,*> Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Threads/Waiting Copy Type Simple DestroyedTotalCount WebLogic JMX metrics Details Attribute DestroyedTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Beans/Destroyed Copy Type Monotonic BeansInUseCurrentCount WebLogic JMX metrics Details Attribute BeansInUseCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Beans/Active Copy Type Simple PooledBeansCurrentCount WebLogic JMX metrics Details Attribute PooledBeansCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Beans/Available Copy Type Simple TransactionsCommittedTotalCount +TransactionsRolledBackTotalCount +TransactionsTimedOutTotalCount WebLogic JMX metrics Details Attribute TransactionsCommittedTotalCount +TransactionsRolledBackTotalCount +TransactionsTimedOutTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBTransactionRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Transactions/Application/{ApplicationRuntime}/Count Copy Type Monotonic TransactionsCommittedTotalCount WebLogic JMX metrics Details Attribute TransactionsCommittedTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBTransactionRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Transactions/Application/{ApplicationRuntime}/Committed Copy Type Monotonic TransactionsRolledBackTotalCount WebLogic JMX metrics Details Attribute TransactionsRolledBackTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBTransactionRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Transactions/Application/{ApplicationRuntime}/Rolled Back Copy Type Monotonic TransactionsTimedOutTotalCount WebLogic JMX metrics Details Attribute TransactionsTimedOutTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBTransactionRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Transactions/Application/{ApplicationRuntime}/Timed Out Copy Type Monotonic",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.750946,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "JVMs page (<em>Java</em>): View app server metrics from JMX",
        "sections": "JVMs page (<em>Java</em>): View app server metrics from JMX",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "You can use New Relic&#x27;s <em>Java</em> <em>agent</em> to collect and view additional metrics provided by the most common application servers via JMX. The collected metrics vary by app server and include measurements of thread pools, HTTP sessions, and transactions. View JVM metrics Application servers collect"
      },
      "id": "603eb1c3e7b9d2d4182a07dc"
    },
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-10-18T05:35:40Z",
      "updated_at": "2021-09-27T15:21:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # Real-time profiling using Java Flight Recorder (JFR). # This feature reports dimensional metrics to the ingest endpoint configured by # metric_ingest_uri and events to the ingest endpoint configured by event_ingest_uri. # Both ingest endpoints default to US production but they will be automatically set to EU # production when using an EU license key. Other ingest endpoints can be configured manually. # Requires a JVM that provides the JFR library. jfr: # Set to true to enable Real-time profiling with JFR. # Default is false. enabled: false # Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. # Audit logging is extremely verbose and should only be used for troubleshooting purposes. # Default is false. audit_logging: false # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.87013,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;configuration&#x2F;<em>java</em>-<em>agent</em>-configuration-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    }
  ],
  "/docs/agents/java-agent/frameworks/scala-installation-java": [
    {
      "sections": [
        "Java XML instrumentation examples",
        "Edit XML file in UI",
        "XML file format",
        "Caution",
        "Root node: extension",
        "Instrumentation (child of extension)",
        "Pointcut (child of instrumentation)",
        "Child nodes for pointcut",
        "Child nodes for method",
        "Example",
        "Sample class",
        "Sample XML instrumentation file and explanation"
      ],
      "title": "Java XML instrumentation examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "e34a060717cb5620eec03de5dcf19f1be0b82fcf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples/",
      "published_at": "2021-10-18T05:38:05Z",
      "updated_at": "2021-07-09T00:54:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For your New Relic-monitored Java application, one custom instrumentation method is to use an XML file that lists the methods and classes you want to instrument. This documentation shows an example XML instrumentation file. For more information, see Java instrumentation by XML. Edit XML file in UI To edit your XML file directly from the New Relic UI: Go to one.newrelic.com > APM > (select an app) > Settings > Instrumentation. From here you can: Download a sample XML file. Select an edit existing XML file. Search the instrumentation history. XML file format The XML file format includes root and child nodes. Caution Do not instrument all of your methods, as this can lead to a metric grouping issue. Root node: extension The root node of an XML file is extension. It can have three different attributes: Value Definition name A unique but descriptive name identifying your XML extension. enabled Identifies whether the extension will be read by the Java agent. Default is true. If false, New Relic will ignore the extension. version The version of the extension. If two extensions have the same name, only the extension with the highest version will be used. Instrumentation (child of extension) The instrumentation node is a child of extension. It can have one attribute: metricPrefix. This is the prefix used for the metric names when the nameTransaction node is not specified. Default is CUSTOM. Pointcut (child of instrumentation) The pointcut is a child node of instrumentation and can have several attributes. Also, a pointcut can have several different child nodes. Value Definition transactionStartPoint If a transaction is not already in progress when this pointcut is reached, then a transaction will be started. If a transaction is already in progress, then that transaction will continue. A new transaction will not be created. metricNameFormat The name format to use for a metric. If not present, then this will default to the class name followed by the method name. You can only set the metricNameFormat on pointcuts where transactionStartPoint is set to false. excludeFromTransactionTrace When true the transaction trace will not be provided if this pointcut initiates the transaction. If the pointcut is reached in the middle of a transaction, then the transaction trace will still be present, but this method will be excluded from the call graph. ignoreTransaction When true the entire transaction will be ignored. transactionType Sets the type of the transaction. Possible values are background (default, reported as a non-web transaction) and web (reported as a web transaction). Child nodes for pointcut A pointcut can have several different child nodes: Value Definition nameTransaction If this element is present, the agent will name the transaction using the class name and method(s) instrumented by this pointcut. methodAnnotation The case sensitive full name of an annotation class including the package name. All methods that are marked with this annotation will be matched. className The case sensitive name of the class to match, including the package name. Pair this node with the method node. If this node is present on a pointcut, then the interfaceName node cannot be present on the same pointcut node. The className node has the attribute includeSubclasses. If true the methods on the class with the matching name will be instrumented along with the matching methods on any child class of this class. If false (default), only methods on the exact class specified will be instrumented. The className must follow these rules: Inner classes can be instrumented. The full package structure with dots between packages must be used. To match subclasses of the specified class, set the attribute includeSubclasses to true. interfaceName The case sensitive name of an interface, including the package name, whose implementation classes will be matched. Pair this node with the method node. If this node is present on a pointcut, then the className node cannot be present on the same pointcut node. The interfaceName must follow this rule: The full package structure with dots between packages must be used. method A method on the class to instrument. Pair this node with a className node. Also, the method node can have children. traceByReturnType The class name, including package, in the format used in bytecode, e.g. Ljava/lang/String;. All methods that return an object of that class will be matched. traceLambda A boolean indicating whether to match lambdas. The traceLambda node has the attributes: includeNonstatic - a boolean indicating whether to match non static methods (defaults to false); pattern - a string with the pattern to search for the lambda methods. Child nodes for method The method node can have several children. For more information and examples, see Troubleshooting Java custom instrumentation. Value Definition name The exact case sensitive name of the method to match. A method name node must follow these rules: Public, protected, private, and package methods can all be instrumented. Static and instance methods can be instrumented. Constructors cannot be instrumented. parameters The parameter types of the method specified in order. If the parameters element is not present, then all methods matching the name will be matched. This includes private and protected declarations. A method parameters node contains a list of the method's parameters, specified by type elements. Here are the major rules for the type elements: Primitives are specified using their normal name: int, float, double, long, byte, short, boolean, char. Objects require a full package structure. For example, do not use String in the XML; instead, use java.lang.String. Do not use generics with collection objects. For example, write java.util.List instead of java.util.List<String>. Include brackets for arrays. For example, an array of integers will be int[ ] and an array of strings will be java.lang.String[ ]. Include two sets of brackets for an array of arrays. For example, an array of arrays of longs would be long[ ][ ]. To send the parameter as an analytic event to New Relic One, add an XML attribute to the type element called attributeName. To use a method with no parameters, the parameters node needs to be present to match a \"no arguments\" method. returnType The case sensitive name of a class indicating a return type to match. All methods that return this class type will be matched. Example Here is a sample class and an XML file that could be used to instrument that class. Sample class package test; import java.util.HashMap; import java.util.Map; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class SampleTester { private String configName; private Map<String, Long> maxSampleTimes; public SampleTester(String pConfigName) { configName = pConfigName; maxSampleTimes = new HashMap<>(); } public void checkSample(String name, long[] times) { if (times != null) { maxSampleTimes.put(name, getFirst(times)); } else { maxSampleTimes.put(name, (long) getFirst()); } } private Long getFirst(long[] times) { return times[0]; } private int getFirst() { return 0; } public void printMaxRepeat(final long max) throws Exception { Runnable myRunnable = new Runnable() { public void run() { try { printMax(max); } catch (Exception e) { e.printStackTrace(); } } }; ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(1); scheduledExecutor.scheduleWithFixedDelay(myRunnable, 0, 10000, TimeUnit.MILLISECONDS); } private void printMax(long max) { System.out.println(\"max is \" + max); } } Copy Sample XML instrumentation file and explanation <?xml version=\"1.0\" encoding=\"UTF-8\"?> <extension xmlns=\"https://newrelic.com/docs/java/xsd/v1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"newrelic-extension extension.xsd \" name=\"customExtension\" version=\"1.0\"> <instrumentation metricPrefix=\"EXAMPLE\"> <pointcut transactionStartPoint=\"true\"> <!--class name is preceded by package name--> <className>test.SampleTester</className> <method> <name>checkSample</name> <parameters> <type attributeName=\"sampleName\">java.lang.String</type> <type>long[]</type> </parameters> </method> <!--two methods with the same name but different signatures can share one node--> <method> <name>getFirst</name> </method> <method> <name>run</name> </method> </pointcut> <pointcut transactionStartPoint=\"false\" ignoreTransaction=\"false\" excludeFromTransactionTrace=\"false\" metricNameFormat=\"SampleTester/methods\"> <className>test.SampleTester</className> <method> <name>printMaxRepeat</name> </method> <method> <name>printMax</name> </method> </pointcut> </instrumentation> </extension> Copy The first block of the XML file specifies the name and version of the extension. As the XML extension is default enabled, that attribute is not specified. The second block specifies the methods in SampleClass that should be instrumented. A transaction is started at the beginning of the block. It is worth noting that in the example class, there are two methods that share a name (getFirst) but have different signatures. These are instrumented with a single method node. By removing the parameters node, all methods with the same name can be matched under one method node. In the third block, the specified methods do not have a transaction started on them. This is because the transaction has already been started in run. The transaction will not be ignored, and will be included in the transaction trace.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.18367,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> XML <em>instrumentation</em> examples",
        "sections": "<em>Java</em> XML <em>instrumentation</em> examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "For your New Relic-monitored <em>Java</em> application, one <em>custom</em> <em>instrumentation</em> method is to use an XML file that lists the methods and classes you want to <em>instrument</em>. This documentation shows an example XML <em>instrumentation</em> file. For more information, see <em>Java</em> <em>instrumentation</em> by XML. Edit XML file in UI"
      },
      "id": "6043e05128ccbc04a22f94bd"
    },
    {
      "sections": [
        "Custom JMX YAML examples",
        "Contents",
        "YAML example",
        "Example explanation",
        "Properties",
        "MBeans",
        "Attributes",
        "Type",
        "Metric names",
        "Tip",
        "Finding object and attribute names",
        "For more help"
      ],
      "title": "Custom JMX YAML examples",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "38e6f21e2a3344f554072dff9919df049db60224",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples/",
      "published_at": "2021-10-18T05:36:32Z",
      "updated_at": "2021-03-16T13:47:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is an example of a custom JMX YAML file for New Relic's Java agent, including value and definition, MBean, attributes, type, and names for metrics, objects, and attributes. For more information, including a video, see Custom JMX monitoring by YAML. Contents YAML example Here is an example of a custom JMX YAML file. YAML files are space senstive. name: TomcatCustom version: 1.0 enabled: true jmx: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: Catalina:type=Connector,port=8009 metrics: - attributes: bufferSize, maxHeaderCount - object_name: java.nio:type=BufferPool,name=* metrics: - attributes: Count type: monotonically_increasing Copy Example explanation Properties Value Definition name A descriptive name identifying your YAML custom instrumentation file, using one space before the property name. In the above example, the name is TomcatCustom. version The version of the extension file. Use a double. If two extensions have the same name, only the extension with the highest version will be used. Use one space before the property version. In the above example, the version is 1.0. enabled If true, the Java agent will read the extension. If false, the Java agent will ignore the extension. Use one space before the property enabled. The above example is enabled. MBeans Each line in the YAML starting with - object_name represents an MBean. For example, the following lines describe the information to be pulled from the first MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples metrics: - attributes: accessCount, cacheSize, hitsCount type: simple Copy The object_name property itself can match one or more MBeans. For example, the line below only matches one MBean: - object_name: Catalina:type=Cache,host=localhost,path=/examples Copy The following line could match multiple MBeans: - object_name: java.nio:type=BufferPool,name=* Copy The asterisk ( * ) wildcard can only be used with JDK 1.6 and higher. The three MBeans listed in the above example have the following object names: Catalina:type=Cache,host=localhost,path=/examples Catalina:type=Connector,port=8009 java.nio:type=BufferPool,name=* Copy Attributes The JMX example retrieves six different attributes from the three MBeans. New Relic's Java agent pulls these attributes from the first MBean: accessCount cacheSize hitsCount The agent pulls these attributes from the second MBean: bufferSize maxHeaderCount The agent pulls one attribute (Count) from third MBean. Type For type, use simple or monotonically_increasing. When type is not specified in the JMX YAML file, it defaults to monotonically_increasing. Value Definition simple The exact value of the attribute will be reported to New Relic each minute. monotonically_increasing The positive difference will be reported to New Relic each minute. In the example above, the attributes accessCount, cacheSize, and hitsCount will be reported as simple. The attributes bufferSize, maxHeaderCount, and Count will be reported as monotonically_increasing. If the hitsCount attribute value is always 5, then New Relic will report a 5 each minute. If the Count attribute value is always 5, then New Relic will report a 0 for the value each minute. If the Count attribute value changes from 5 to 7, then New Relic will report a 2 for that minute. Metric names When selecting custom dashboard metrics and not using the property root_metric_name, use the following format for all custom JMX metrics: JMX/beginning_of_object_name/type/any_properties_in_object_name/attribute_name Copy Tip Some object names do not include a type. In that case, a null will be present in the metric name. The configuration file does not use root_metric_name, so the following metrics will be created: JMX/Catalina/Cache/localhost/examples/accessCount JMX/Catalina/Cache/localhost/examples/cacheSize JMX/Catalina/Cache/localhost/examples/hitsCount JMX/Catalina/Connector/8009/bufferSize JMX/Catalina/Connector/8009/maxHeaderCount JMX/java.nio/BufferPool/direct/Count JMX/java.nio/BufferPool/mapped/Count Copy If you are using the property root_metric_name, then the metric will be your root metric name prefixed with JMX and followed by the attribute's name. You can use object name values by specifying the object name key in the root_metric_name between brackets {}. For example: Part of a configuration file: - object_name: Catalina:type=Cache,host=localhost,path=/examples root_metric_name: Tomcat/{host} metrics: - attributes: accessCount, cacheSize, hitsCount type: simple - object_name: mbean:type=Sample,host=localhost,path=* root_metric_name: SampleMBean metrics: - attributes: attOne, attTwo type: simple Copy Metric names: JMX/Tomcat/localhost/accessCount JMX/Tomcat/localhost/cacheSize JMX/Tomcat/localhost/hitsCount JMX/SampleMBean/attOne JMX/SampleMBean/attTwo Copy If an attribute does not actually exist on the MBean, then the metric will never appear in New Relic. Finding object and attribute names The easiest way to find available MBeans and its associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: Custom instrumentation with the Java agent (method tracers, examples) Custom JMX monitoring by YAML (YAML file structure, value and definition)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.70784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> JMX YAML examples",
        "sections": "<em>Custom</em> JMX YAML examples",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " associated attributes is to use the JConsole instructions for JDK 1.6. For more help Additional documentation resources include: <em>Custom</em> <em>instrumentation</em> with the <em>Java</em> <em>agent</em> (method tracers, examples) <em>Custom</em> JMX monitoring by YAML (YAML file structure, value and definition)"
      },
      "id": "603eb76a196a67cba6a83db6"
    },
    {
      "sections": [
        "Messaging framework instrumentation",
        "Typical messaging",
        "Report the producing/consuming as external",
        "Add message metrics/custom parameters to current transaction",
        "Pass a distributed trace payload",
        "Edge cases",
        "Create a distributed trace payload and then receive a message",
        "Batch reading messages",
        "Capturing the processing time of the message",
        "For more help"
      ],
      "title": "Messaging framework instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Custom instrumentation"
      ],
      "external_id": "9b656fcf1790e65d1db825e35ab31c94b6561e08",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are some messaging frameworks that New Relic doesnt support by default. If you are interested in instrumenting these frameworks with our API here are some guidelines to follow. Typical messaging In the typical case, there is a process that produces a message and a process that consumes the message. Some useful things you could do here are below. Note you must be within a transaction for these to report. Report the producing/consuming as external You can create MessageProduceParameters and MessageConsumeParameters with relevant data and then call reportAsExternal(Params) to report the calls as externals. For example, when producing a message this would look like: MessageProduceParameters params = MessageProduceParameters.library(\"libraryName\").destinationType(NAMED_TOPIC).destinationName(\"topicName\").inboundHeaders(null).build(); NewRelic.getAgent().getTransaction().getTracedMethod().reportAsExternal(params); Copy A similar solution would work on the consumer side. Add message metrics/custom parameters to current transaction If there is useful information you want to add to your current transaction about the message, you can do that easily by calling our addCustomParameter() API. This looks like this: NewRelic.addCustomParameter(\"topic-name\", topic); Copy Pass a distributed trace payload In order to track the work across processes/services, the messaging framework must have a way to pass along metadata with the message, whether its via headers or some other mechanism. You can create a distributed trace payload on the producer side that can be attached to the message and read on the consumer side. You must be in a transaction for this to work. To do this you would follow a pattern like this: @Trace(dispatcher = true) public void sendData(Producer producer){ final DistributedTracePayload payload = NewRelic.getAgent().getTransaction().createDistributedTracePayload(); headers.add(new RecordHeader(\"newrelic\", payload.text().getBytes(StandardCharsets.UTF_8))); data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\", headers); producer.send(data); } Copy And on the consumer side: @Trace(dispatcher = true) public void processData(ConsumerRecord record){ final Iterator<Header> nrHeaders = record.headers().headers(\"newrelic\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can instrument. Instrument Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra care. Below are suggestions on the best way to tackle them. Create a distributed trace payload and then receive a message The problem here is that you cant create a distributed trace payload and then accept a distributed trace payload within the same transaction in that order. This means that there are two attempts of distributed tracing and you have to choose which one you want. If you would like to accept the second payload rather than create the first one, you need to prevent the first payload from getting created. You can remove the custom instrumentation (if thats whats creating the payload) or disable instrumentation via our config Batch reading messages For batch consumption of messages, there is a problem of which distributed tracing payload you accept. If you are ok with linking just one of the distributed trace payloads then you can accept any one of the payloads in the batch but that will result in the rest of the payloads getting lost. However, if you want to see all of the distributed traces then youll need to create a transaction per message. The second solution could incur some overhead so take that into consideration when making a decision. A solution like that would look like: public void processMessages(ConsumerRecords<String, String> records) { for(ConsumerRecord<String, String> record: records) { processRecord(record); } } @Trace(dispatcher = true) private void processRecord(ConsumerRecord<String, String> record) { final Iterator<Header> nrHeaders = record.headers().headers(\"newrelicDTPayload\").iterator(); if (nrHeaders.hasNext()) { final Header nrHeader = nrHeaders.next(); final String payload = new String(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.getAgent().getTransaction().acceptDistributedTracePayload(payload); } } Copy This will only work if there isnt a transaction already started on the thread at this time. If there is one then just accepting one payload from the batch is your only solution. Capturing the processing time of the message If you would like to capture the processing time of a message then you will need to move the processing work into a method and then trace that method. For example: public void getMessages(){ KafkaConsumer consumer = new KafkaConsumer(props); consumer.subscribe(Arrays.asList(\"topic\")); while (true) { ConsumerRecords<String, String> recs = consumer.poll(10000); if (recs.count() == 0) { } else { for (ConsumerRecord<String, String> rec : recs) { processRec(rec); } } } } @Trace(dispatcher = true) private void processRec(ConsumerRecord<String, String> rec) { // some processing } Copy For more help Use the Guide to using the Java agent API to learn more about our Java agent API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.703186,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Messaging framework <em>instrumentation</em>",
        "sections": "Messaging framework <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "(nrHeader.value(), StandardCharsets.UTF_8); NewRelic.get<em>Agent</em>().getTransaction().acceptDistributedTracePayload(payload); } } Copy This example uses Kafka, which you can <em>instrument</em>. <em>Instrument</em> Kafka message queues provides information for instrumenting. Edge cases There are some edge cases that require extra"
      },
      "id": "603ebc24196a67a6d7a83dc8"
    }
  ],
  "/docs/agents/java-agent/getting-started/apm-agent-security-java": [
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.1282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the <em>get</em>Bulk() API method. The <em>Java</em> <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Compatibility and requirements for the Python agent",
        "Basic requirements",
        "Python package instrumentation",
        "Python version support",
        "Support for new Python releases",
        "End of support for Python releases reaching EOL",
        "Connect the agent to other Full-Stack Observability capabilities"
      ],
      "title": "Compatibility and requirements for the Python agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Getting started"
      ],
      "external_id": "bac256a07ebdd3c81f4f7eefdee029990831a57e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/getting-started/compatibility-requirements-python-agent/",
      "published_at": "2021-10-18T13:35:40Z",
      "updated_at": "2021-10-18T13:35:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Python agent, make sure your system meets these requirements. Basic requirements The Python agent supports many of the most common Python web frameworks. Additional configuration may be required depending on your specific hosting mechanism, hosting service, web framework, or back-end services. If you don't have one already, create a New Relic account. It's free, forever. Resource Requirements Operating systems UNIX-like operating systems including Linux, Solaris, FreeBSD, and macOS. The Python agent does not support Windows environments. Python Python (CPython/PyPy) versions supported: 2.7, 3.6, 3.7, 3.8, 3.9, and 3.10. Recommendation: Use Python version 3.6 or higher with our agent. Python versions 2.6 and 3.3 are supported only by Python agent versions 3.4.0.95 or lower. Python version 3.4 is supported only by Python agent versions 4.20.0.120 or lower. Python version 3.5 is supported only by Python agent versions 5.24.0.153 or lower. Python versions 2.7 and 3.6 follow our end of life (EOL) support requirements. Supported web frameworks Supported web frameworks include: Aiohttp Bottle CherryPy Django Falcon FastAPI Flask GraphQL gRPC Pylons Pyramid Sanic Starlette Tornado 6 Web2Py Unsupported frameworks Some WSGI servers, frameworks, and apps have special requirements. Although a specific Python WSGI web framework may not be supported, you can still use the agent. For unsupported frameworks, a breakout of time spent in key parts of the framework will not appear in web transaction performance breakdowns and transaction traces. In addition, the agent will not be able to meaningfully group any web transactions handled by specific handlers in your code that you use to make them more useful and targeted. In these situations you can use the Python agent API to name web transactions or add custom instrumentation. Hosting Web hosting mechanisms compliant with WSGI 1.0 (PEP 333). For example, you can install the Python agent in a Google App Engine flexible environment. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Other monitoring software If your application uses other monitoring software besides ours, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Python package instrumentation The agent also provides instrumentation for a range of other Python packages and modules. Instrumentation includes database queries, memcache requests, external service requests, instance-level details, and more. The results will appear automatically in APM's user interface within web transaction performance breakdowns and transaction traces for slow transactions. Python version support The agent in general will support all released and active Python branches. However, to keep up with upcoming changes, the agent will also follow this Python version support schedule. The version support policy does not replace the general New Relic agent and plugin end-of-life (EOL) policy. Support for new Python releases The following are proposed time ranges. The actual release date may vary. Python version Active long term support (LTS) start date Initial release date of Python agent with support 3.10 October 04, 2021 October 12, 2021 3.11 October 03, 2022 November 2022 End of support for Python releases reaching EOL The following are proposed time ranges. The actual release date may vary. Python version End of life (EOL) date Initial release date of Python agent dropping support 3.6 December 2021 Python agent versions released after March 2022 will not support Python 3.6. For more information, see our Python agent release notes. 2.7 January 1, 2020 TBD Connect the agent to other Full-Stack Observability capabilities The Python agent integrates with other capabilities to give you end-to-end visibility: Product Integration Browser monitoring The Python agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Python agent. Infrastructure monitoring When you install the Infrastructure monitoring and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure monitoring UI. For more information, see APM data in Infrastructure. Synthetic monitoring Synthetic transaction traces connect requests from synthetic monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.39628,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Python <em>agent</em>",
        "sections": "Compatibility and requirements for the Python <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " this Python version support schedule. The version support policy does not replace the general New Relic <em>agent</em> and plugin end-of-life (EOL) policy. Support for new Python releases The following are proposed time ranges. The actual release date may vary. Python version Active long term support (LTS) <em>start</em>"
      },
      "id": "6044108b64441fb65f378efc"
    },
    {
      "sections": [
        "Compatibility and requirements for the Node.js agent",
        "Node.js version support",
        "Tip",
        "Support for new Node.js releases",
        "End of support for Node.js releases reaching EOL",
        "Node.js 12 errors",
        "Supported Node.js frameworks",
        "EOL NOTICE",
        "Operating systems",
        "Datastores",
        "Instance details",
        "Messages queues",
        "Hosting services",
        "Process managers",
        "Security requirements",
        "Connect the agent to other New Relic features"
      ],
      "title": "Compatibility and requirements for the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Getting started"
      ],
      "external_id": "dd144d7ffce53c47f9dd6d872f61905157023f6f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/getting-started/compatibility-requirements-nodejs-agent/",
      "published_at": "2021-10-19T03:58:30Z",
      "updated_at": "2021-10-19T03:58:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Node.js agent is publicly available on the Node Package Manager (npm) repository as well as on GitHub. Before you install the Node.js agent, make sure your application meets the following system requirements. If you haven't already, create a New Relic account. It's free, forever. Node.js version support Tip For best performance, use the latest active long term support (LTS) version of Node.js. Support for new Node.js releases We will support the latest even versions of Node.js releases by the beginning of the following active long term support schedule. The version support policy does not replace the general agent and plugin end-of-life (EOL) policy. The following are proposed time ranges. The actual release date may vary. Node.js version Active long term support (LTS) start date Initial release date of Node.js agent with support 18 October 2022 April-October 2022 16 October 2021 July 26, 2021 with Node.js agent v8.0.0 End of support for Node.js releases reaching EOL When support for a new long term support agent version is made available, support for the Node.js agent version that reaches end-of-life during the same time period will simultaneously drop. The following are proposed time ranges. The actual release date may vary. Node.js version End of life (EOL) date Initial release date of Node.js agent dropping support 12 April 2022 April-October 2022 10 April 2021 As of July 26, 2021, we have discontinued support for Node.js 10 with v8 of the Node.js agent. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Node.js 12 errors For Node.js 12, the following change affects the Node.js agent: Errors resulting in unhandled rejections are not scoped to the transaction that was active when the rejected promise was created. This is because the promise responsible for triggering the init async hook is no longer passed through on the promise wrap instance. This breaks the linkage that associates a given promise rejection with the transaction it was scheduled in. Supported Node.js frameworks Express 4.6.0 or higher Restify Connect Hapi Koa 2.0.0 or higher (external module loaded with the agent) If you are using a supported framework with default routers, the Node.js agent can read these frameworks' route names as is. However, if you want more specific names than are provided by your framework, you may want to use one or more of the tools New Relic provides with the Node.js transaction naming API. EOL NOTICE We're discontinuing support for several capabilities in November 2021. This includes the Oracle Driver Package and Hapi versions prior to Hapi 19.2 for our Node.js agent. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Operating systems Linux SmartOS macOS 10.7 and higher Windows Server 2008 and higher Datastores The Node.js agent monitors the performance of Node.js application calls to these datastores: Cassandra Memcached MongoDB MySQL (via mysql and mysql2 packages) Redis Postgres (including the native and pure JavaScript packages) Instance details We collect instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your agent version. New Relic's Node.js agent version 1.31.0 or higher supports the following: Database npm module name Minimum module version Minimum agent version PostgreSQL pg 4.0.0 1.31.0 Redis redis 2.0.0 1.31.0 MongoDB mongodb 2.1.0 1.32.0 MySQL mysql 2.4.1 1.32.0 Memcached memcached 1.0.0 1.33.0 To request instance-level information from datastores currently not listed for your New Relic agent, get support at support.newrelic.com. Messages queues Message queue instrumentation is only available with the New Relic Node.js agent v2 or higher. Currently supported message queue instrumentation: amqplib For other message queue libraries, use custom instrumentation. Hosting services Google App Engine (GAE) flexible environment AWS EC2 Microsoft Azure Heroku Process managers In general, process managers that handle starting, stopping, and restarting of Node.js (like Forever) should be compatible with the Node.js agent. If you are using PM2, the minimum supported version of PM2 is 2.0. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Connect the agent to other New Relic features The Node.js agent integrates with other features to give you observability across your entire stack: Product Integration Browser monitoring The Node.js agent can add the benefits of browser monitoring when you enable auto-instrumentation. After enabling browser monitoring injection, simply follow our guide to installing browser monitoring with the Node.js agent. Once you've completed these steps, you can view your browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the Node.js agent. Infrastructure monitoring When you install the infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in infrastructure monitoring. New Relic dashboards The Node.js agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from synthetic monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.04209,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Node.js <em>agent</em>",
        "sections": "Compatibility and requirements for the Node.js <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " not replace the general <em>agent</em> and plugin end-of-life (EOL) policy. The following are proposed time ranges. The actual release date may vary. Node.js version Active long term support (LTS) <em>start</em> date Initial release date of Node.js <em>agent</em> with support 18 October 2022 April-October 2022 16 October 2021"
      },
      "id": "6043d8dae7b9d2d4415799df"
    }
  ],
  "/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent": [
    {
      "sections": [
        "Compatibility and requirements for the Python agent",
        "Basic requirements",
        "Python package instrumentation",
        "Python version support",
        "Support for new Python releases",
        "End of support for Python releases reaching EOL",
        "Connect the agent to other Full-Stack Observability capabilities"
      ],
      "title": "Compatibility and requirements for the Python agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Getting started"
      ],
      "external_id": "bac256a07ebdd3c81f4f7eefdee029990831a57e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/getting-started/compatibility-requirements-python-agent/",
      "published_at": "2021-10-18T13:35:40Z",
      "updated_at": "2021-10-18T13:35:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Python agent, make sure your system meets these requirements. Basic requirements The Python agent supports many of the most common Python web frameworks. Additional configuration may be required depending on your specific hosting mechanism, hosting service, web framework, or back-end services. If you don't have one already, create a New Relic account. It's free, forever. Resource Requirements Operating systems UNIX-like operating systems including Linux, Solaris, FreeBSD, and macOS. The Python agent does not support Windows environments. Python Python (CPython/PyPy) versions supported: 2.7, 3.6, 3.7, 3.8, 3.9, and 3.10. Recommendation: Use Python version 3.6 or higher with our agent. Python versions 2.6 and 3.3 are supported only by Python agent versions 3.4.0.95 or lower. Python version 3.4 is supported only by Python agent versions 4.20.0.120 or lower. Python version 3.5 is supported only by Python agent versions 5.24.0.153 or lower. Python versions 2.7 and 3.6 follow our end of life (EOL) support requirements. Supported web frameworks Supported web frameworks include: Aiohttp Bottle CherryPy Django Falcon FastAPI Flask GraphQL gRPC Pylons Pyramid Sanic Starlette Tornado 6 Web2Py Unsupported frameworks Some WSGI servers, frameworks, and apps have special requirements. Although a specific Python WSGI web framework may not be supported, you can still use the agent. For unsupported frameworks, a breakout of time spent in key parts of the framework will not appear in web transaction performance breakdowns and transaction traces. In addition, the agent will not be able to meaningfully group any web transactions handled by specific handlers in your code that you use to make them more useful and targeted. In these situations you can use the Python agent API to name web transactions or add custom instrumentation. Hosting Web hosting mechanisms compliant with WSGI 1.0 (PEP 333). For example, you can install the Python agent in a Google App Engine flexible environment. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Other monitoring software If your application uses other monitoring software besides ours, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Python package instrumentation The agent also provides instrumentation for a range of other Python packages and modules. Instrumentation includes database queries, memcache requests, external service requests, instance-level details, and more. The results will appear automatically in APM's user interface within web transaction performance breakdowns and transaction traces for slow transactions. Python version support The agent in general will support all released and active Python branches. However, to keep up with upcoming changes, the agent will also follow this Python version support schedule. The version support policy does not replace the general New Relic agent and plugin end-of-life (EOL) policy. Support for new Python releases The following are proposed time ranges. The actual release date may vary. Python version Active long term support (LTS) start date Initial release date of Python agent with support 3.10 October 04, 2021 October 12, 2021 3.11 October 03, 2022 November 2022 End of support for Python releases reaching EOL The following are proposed time ranges. The actual release date may vary. Python version End of life (EOL) date Initial release date of Python agent dropping support 3.6 December 2021 Python agent versions released after March 2022 will not support Python 3.6. For more information, see our Python agent release notes. 2.7 January 1, 2020 TBD Connect the agent to other Full-Stack Observability capabilities The Python agent integrates with other capabilities to give you end-to-end visibility: Product Integration Browser monitoring The Python agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Python agent. Infrastructure monitoring When you install the Infrastructure monitoring and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure monitoring UI. For more information, see APM data in Infrastructure. Synthetic monitoring Synthetic transaction traces connect requests from synthetic monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.39628,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Python <em>agent</em>",
        "sections": "Compatibility and requirements for the Python <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " this Python version support schedule. The version support policy does not replace the general New Relic <em>agent</em> and plugin end-of-life (EOL) policy. Support for new Python releases The following are proposed time ranges. The actual release date may vary. Python version Active long term support (LTS) <em>start</em>"
      },
      "id": "6044108b64441fb65f378efc"
    },
    {
      "sections": [
        "Compatibility and requirements for the Node.js agent",
        "Node.js version support",
        "Tip",
        "Support for new Node.js releases",
        "End of support for Node.js releases reaching EOL",
        "Node.js 12 errors",
        "Supported Node.js frameworks",
        "EOL NOTICE",
        "Operating systems",
        "Datastores",
        "Instance details",
        "Messages queues",
        "Hosting services",
        "Process managers",
        "Security requirements",
        "Connect the agent to other New Relic features"
      ],
      "title": "Compatibility and requirements for the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Getting started"
      ],
      "external_id": "dd144d7ffce53c47f9dd6d872f61905157023f6f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/getting-started/compatibility-requirements-nodejs-agent/",
      "published_at": "2021-10-19T03:58:30Z",
      "updated_at": "2021-10-19T03:58:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Node.js agent is publicly available on the Node Package Manager (npm) repository as well as on GitHub. Before you install the Node.js agent, make sure your application meets the following system requirements. If you haven't already, create a New Relic account. It's free, forever. Node.js version support Tip For best performance, use the latest active long term support (LTS) version of Node.js. Support for new Node.js releases We will support the latest even versions of Node.js releases by the beginning of the following active long term support schedule. The version support policy does not replace the general agent and plugin end-of-life (EOL) policy. The following are proposed time ranges. The actual release date may vary. Node.js version Active long term support (LTS) start date Initial release date of Node.js agent with support 18 October 2022 April-October 2022 16 October 2021 July 26, 2021 with Node.js agent v8.0.0 End of support for Node.js releases reaching EOL When support for a new long term support agent version is made available, support for the Node.js agent version that reaches end-of-life during the same time period will simultaneously drop. The following are proposed time ranges. The actual release date may vary. Node.js version End of life (EOL) date Initial release date of Node.js agent dropping support 12 April 2022 April-October 2022 10 April 2021 As of July 26, 2021, we have discontinued support for Node.js 10 with v8 of the Node.js agent. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Node.js 12 errors For Node.js 12, the following change affects the Node.js agent: Errors resulting in unhandled rejections are not scoped to the transaction that was active when the rejected promise was created. This is because the promise responsible for triggering the init async hook is no longer passed through on the promise wrap instance. This breaks the linkage that associates a given promise rejection with the transaction it was scheduled in. Supported Node.js frameworks Express 4.6.0 or higher Restify Connect Hapi Koa 2.0.0 or higher (external module loaded with the agent) If you are using a supported framework with default routers, the Node.js agent can read these frameworks' route names as is. However, if you want more specific names than are provided by your framework, you may want to use one or more of the tools New Relic provides with the Node.js transaction naming API. EOL NOTICE We're discontinuing support for several capabilities in November 2021. This includes the Oracle Driver Package and Hapi versions prior to Hapi 19.2 for our Node.js agent. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Operating systems Linux SmartOS macOS 10.7 and higher Windows Server 2008 and higher Datastores The Node.js agent monitors the performance of Node.js application calls to these datastores: Cassandra Memcached MongoDB MySQL (via mysql and mysql2 packages) Redis Postgres (including the native and pure JavaScript packages) Instance details We collect instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your agent version. New Relic's Node.js agent version 1.31.0 or higher supports the following: Database npm module name Minimum module version Minimum agent version PostgreSQL pg 4.0.0 1.31.0 Redis redis 2.0.0 1.31.0 MongoDB mongodb 2.1.0 1.32.0 MySQL mysql 2.4.1 1.32.0 Memcached memcached 1.0.0 1.33.0 To request instance-level information from datastores currently not listed for your New Relic agent, get support at support.newrelic.com. Messages queues Message queue instrumentation is only available with the New Relic Node.js agent v2 or higher. Currently supported message queue instrumentation: amqplib For other message queue libraries, use custom instrumentation. Hosting services Google App Engine (GAE) flexible environment AWS EC2 Microsoft Azure Heroku Process managers In general, process managers that handle starting, stopping, and restarting of Node.js (like Forever) should be compatible with the Node.js agent. If you are using PM2, the minimum supported version of PM2 is 2.0. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Connect the agent to other New Relic features The Node.js agent integrates with other features to give you observability across your entire stack: Product Integration Browser monitoring The Node.js agent can add the benefits of browser monitoring when you enable auto-instrumentation. After enabling browser monitoring injection, simply follow our guide to installing browser monitoring with the Node.js agent. Once you've completed these steps, you can view your browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the Node.js agent. Infrastructure monitoring When you install the infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in infrastructure monitoring. New Relic dashboards The Node.js agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from synthetic monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.04209,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Node.js <em>agent</em>",
        "sections": "Compatibility and requirements for the Node.js <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " not replace the general <em>agent</em> and plugin end-of-life (EOL) policy. The following are proposed time ranges. The actual release date may vary. Node.js version Active long term support (LTS) <em>start</em> date Initial release date of Node.js <em>agent</em> with support 18 October 2022 April-October 2022 16 October 2021"
      },
      "id": "6043d8dae7b9d2d4415799df"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.16377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ", substituting X.Y.Z with the latest <em>agent</em> version: web: target&#x2F;universal&#x2F;stage&#x2F;bin&#x2F;play-<em>getting</em>-<em>started</em> -Dhttp.port=${PORT} -J-javaagent:&#x2F;app&#x2F;target&#x2F;universal&#x2F;stage&#x2F;lib&#x2F;com.newrelic.<em>agent.java</em>.newrelic-<em>agent</em>-X.Y.Z.jar -J-Dnewrelic.config.file=conf&#x2F;newrelic.yml Copy OR Identify the path to newrelic.jar"
      },
      "id": "6043b879196a670bb4960f4b"
    }
  ],
  "/docs/agents/java-agent/getting-started/introduction-new-relic-java": [
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.12819,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the <em>get</em>Bulk() API method. The <em>Java</em> <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Compatibility and requirements for the Python agent",
        "Basic requirements",
        "Python package instrumentation",
        "Python version support",
        "Support for new Python releases",
        "End of support for Python releases reaching EOL",
        "Connect the agent to other Full-Stack Observability capabilities"
      ],
      "title": "Compatibility and requirements for the Python agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Getting started"
      ],
      "external_id": "bac256a07ebdd3c81f4f7eefdee029990831a57e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/getting-started/compatibility-requirements-python-agent/",
      "published_at": "2021-10-18T13:35:40Z",
      "updated_at": "2021-10-18T13:35:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Python agent, make sure your system meets these requirements. Basic requirements The Python agent supports many of the most common Python web frameworks. Additional configuration may be required depending on your specific hosting mechanism, hosting service, web framework, or back-end services. If you don't have one already, create a New Relic account. It's free, forever. Resource Requirements Operating systems UNIX-like operating systems including Linux, Solaris, FreeBSD, and macOS. The Python agent does not support Windows environments. Python Python (CPython/PyPy) versions supported: 2.7, 3.6, 3.7, 3.8, 3.9, and 3.10. Recommendation: Use Python version 3.6 or higher with our agent. Python versions 2.6 and 3.3 are supported only by Python agent versions 3.4.0.95 or lower. Python version 3.4 is supported only by Python agent versions 4.20.0.120 or lower. Python version 3.5 is supported only by Python agent versions 5.24.0.153 or lower. Python versions 2.7 and 3.6 follow our end of life (EOL) support requirements. Supported web frameworks Supported web frameworks include: Aiohttp Bottle CherryPy Django Falcon FastAPI Flask GraphQL gRPC Pylons Pyramid Sanic Starlette Tornado 6 Web2Py Unsupported frameworks Some WSGI servers, frameworks, and apps have special requirements. Although a specific Python WSGI web framework may not be supported, you can still use the agent. For unsupported frameworks, a breakout of time spent in key parts of the framework will not appear in web transaction performance breakdowns and transaction traces. In addition, the agent will not be able to meaningfully group any web transactions handled by specific handlers in your code that you use to make them more useful and targeted. In these situations you can use the Python agent API to name web transactions or add custom instrumentation. Hosting Web hosting mechanisms compliant with WSGI 1.0 (PEP 333). For example, you can install the Python agent in a Google App Engine flexible environment. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Other monitoring software If your application uses other monitoring software besides ours, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Python package instrumentation The agent also provides instrumentation for a range of other Python packages and modules. Instrumentation includes database queries, memcache requests, external service requests, instance-level details, and more. The results will appear automatically in APM's user interface within web transaction performance breakdowns and transaction traces for slow transactions. Python version support The agent in general will support all released and active Python branches. However, to keep up with upcoming changes, the agent will also follow this Python version support schedule. The version support policy does not replace the general New Relic agent and plugin end-of-life (EOL) policy. Support for new Python releases The following are proposed time ranges. The actual release date may vary. Python version Active long term support (LTS) start date Initial release date of Python agent with support 3.10 October 04, 2021 October 12, 2021 3.11 October 03, 2022 November 2022 End of support for Python releases reaching EOL The following are proposed time ranges. The actual release date may vary. Python version End of life (EOL) date Initial release date of Python agent dropping support 3.6 December 2021 Python agent versions released after March 2022 will not support Python 3.6. For more information, see our Python agent release notes. 2.7 January 1, 2020 TBD Connect the agent to other Full-Stack Observability capabilities The Python agent integrates with other capabilities to give you end-to-end visibility: Product Integration Browser monitoring The Python agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Python agent. Infrastructure monitoring When you install the Infrastructure monitoring and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure monitoring UI. For more information, see APM data in Infrastructure. Synthetic monitoring Synthetic transaction traces connect requests from synthetic monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.3962,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Python <em>agent</em>",
        "sections": "Compatibility and requirements for the Python <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " this Python version support schedule. The version support policy does not replace the general New Relic <em>agent</em> and plugin end-of-life (EOL) policy. Support for new Python releases The following are proposed time ranges. The actual release date may vary. Python version Active long term support (LTS) <em>start</em>"
      },
      "id": "6044108b64441fb65f378efc"
    },
    {
      "sections": [
        "Compatibility and requirements for the Node.js agent",
        "Node.js version support",
        "Tip",
        "Support for new Node.js releases",
        "End of support for Node.js releases reaching EOL",
        "Node.js 12 errors",
        "Supported Node.js frameworks",
        "EOL NOTICE",
        "Operating systems",
        "Datastores",
        "Instance details",
        "Messages queues",
        "Hosting services",
        "Process managers",
        "Security requirements",
        "Connect the agent to other New Relic features"
      ],
      "title": "Compatibility and requirements for the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Getting started"
      ],
      "external_id": "dd144d7ffce53c47f9dd6d872f61905157023f6f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/getting-started/compatibility-requirements-nodejs-agent/",
      "published_at": "2021-10-19T03:58:30Z",
      "updated_at": "2021-10-19T03:58:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Node.js agent is publicly available on the Node Package Manager (npm) repository as well as on GitHub. Before you install the Node.js agent, make sure your application meets the following system requirements. If you haven't already, create a New Relic account. It's free, forever. Node.js version support Tip For best performance, use the latest active long term support (LTS) version of Node.js. Support for new Node.js releases We will support the latest even versions of Node.js releases by the beginning of the following active long term support schedule. The version support policy does not replace the general agent and plugin end-of-life (EOL) policy. The following are proposed time ranges. The actual release date may vary. Node.js version Active long term support (LTS) start date Initial release date of Node.js agent with support 18 October 2022 April-October 2022 16 October 2021 July 26, 2021 with Node.js agent v8.0.0 End of support for Node.js releases reaching EOL When support for a new long term support agent version is made available, support for the Node.js agent version that reaches end-of-life during the same time period will simultaneously drop. The following are proposed time ranges. The actual release date may vary. Node.js version End of life (EOL) date Initial release date of Node.js agent dropping support 12 April 2022 April-October 2022 10 April 2021 As of July 26, 2021, we have discontinued support for Node.js 10 with v8 of the Node.js agent. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Node.js 12 errors For Node.js 12, the following change affects the Node.js agent: Errors resulting in unhandled rejections are not scoped to the transaction that was active when the rejected promise was created. This is because the promise responsible for triggering the init async hook is no longer passed through on the promise wrap instance. This breaks the linkage that associates a given promise rejection with the transaction it was scheduled in. Supported Node.js frameworks Express 4.6.0 or higher Restify Connect Hapi Koa 2.0.0 or higher (external module loaded with the agent) If you are using a supported framework with default routers, the Node.js agent can read these frameworks' route names as is. However, if you want more specific names than are provided by your framework, you may want to use one or more of the tools New Relic provides with the Node.js transaction naming API. EOL NOTICE We're discontinuing support for several capabilities in November 2021. This includes the Oracle Driver Package and Hapi versions prior to Hapi 19.2 for our Node.js agent. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Operating systems Linux SmartOS macOS 10.7 and higher Windows Server 2008 and higher Datastores The Node.js agent monitors the performance of Node.js application calls to these datastores: Cassandra Memcached MongoDB MySQL (via mysql and mysql2 packages) Redis Postgres (including the native and pure JavaScript packages) Instance details We collect instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your agent version. New Relic's Node.js agent version 1.31.0 or higher supports the following: Database npm module name Minimum module version Minimum agent version PostgreSQL pg 4.0.0 1.31.0 Redis redis 2.0.0 1.31.0 MongoDB mongodb 2.1.0 1.32.0 MySQL mysql 2.4.1 1.32.0 Memcached memcached 1.0.0 1.33.0 To request instance-level information from datastores currently not listed for your New Relic agent, get support at support.newrelic.com. Messages queues Message queue instrumentation is only available with the New Relic Node.js agent v2 or higher. Currently supported message queue instrumentation: amqplib For other message queue libraries, use custom instrumentation. Hosting services Google App Engine (GAE) flexible environment AWS EC2 Microsoft Azure Heroku Process managers In general, process managers that handle starting, stopping, and restarting of Node.js (like Forever) should be compatible with the Node.js agent. If you are using PM2, the minimum supported version of PM2 is 2.0. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Connect the agent to other New Relic features The Node.js agent integrates with other features to give you observability across your entire stack: Product Integration Browser monitoring The Node.js agent can add the benefits of browser monitoring when you enable auto-instrumentation. After enabling browser monitoring injection, simply follow our guide to installing browser monitoring with the Node.js agent. Once you've completed these steps, you can view your browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the Node.js agent. Infrastructure monitoring When you install the infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in infrastructure monitoring. New Relic dashboards The Node.js agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from synthetic monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.04201,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Node.js <em>agent</em>",
        "sections": "Compatibility and requirements for the Node.js <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " not replace the general <em>agent</em> and plugin end-of-life (EOL) policy. The following are proposed time ranges. The actual release date may vary. Node.js version Active long term support (LTS) <em>start</em> date Initial release date of Node.js <em>agent</em> with support 18 October 2022 April-October 2022 16 October 2021"
      },
      "id": "6043d8dae7b9d2d4415799df"
    }
  ],
  "/docs/agents/java-agent/heroku/java-agent-heroku": [
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.77205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>",
        "sections": "<em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "<em>Heroku</em> is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend <em>Heroku</em> with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and <em>Heroku</em>. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "No data appears with Heroku (Java)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears with Heroku (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "b08d6638b319ee5716e462566e8a8ad54a63fec5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/no-data-appears-heroku-java/",
      "published_at": "2021-10-18T02:47:34Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem After waiting a few minutes, data is not appearing in your Heroku app's APM Summary page. Solution Check the Heroku logs for errors with this Heroku toolbelt command: heroku logs --tail Copy Check that the files in your Heroku dyno match the file modifications from the Java on Heroku or Java with Scala on Heroku installation procedures. Use this Heroku toolbelt command: heroku run bash Copy Try the steps in No data appears (Java).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.03404,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears with <em>Heroku</em> (<em>Java</em>)",
        "sections": "No data appears with <em>Heroku</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem After waiting a few minutes, data is not appearing in your <em>Heroku</em> app&#x27;s APM Summary page. Solution Check the <em>Heroku</em> logs for errors with this <em>Heroku</em> toolbelt command: <em>heroku</em> logs --tail Copy Check that the files in your <em>Heroku</em> dyno match the file modifications from the <em>Java</em> on <em>Heroku</em> or <em>Java</em> with Scala on <em>Heroku</em> installation procedures. Use this <em>Heroku</em> toolbelt command: <em>heroku</em> run bash Copy Try the steps in No data appears (<em>Java</em>)."
      },
      "id": "6043b7c9e7b9d29b015799da"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.79076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " from additional datastores, get support at support.newrelic.com. Hosting services You can install the <em>Java</em> <em>agent</em> on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment <em>Heroku</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/heroku/java-agent-scala-heroku": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.83862,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and <em>Heroku</em>",
        "sections": "<em>Java</em> <em>agent</em> and <em>Heroku</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "<em>Heroku</em> is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend <em>Heroku</em> with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for <em>Heroku</em>. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "No data appears with Heroku (Java)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears with Heroku (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "b08d6638b319ee5716e462566e8a8ad54a63fec5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/no-data-appears-heroku-java/",
      "published_at": "2021-10-18T02:47:34Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem After waiting a few minutes, data is not appearing in your Heroku app's APM Summary page. Solution Check the Heroku logs for errors with this Heroku toolbelt command: heroku logs --tail Copy Check that the files in your Heroku dyno match the file modifications from the Java on Heroku or Java with Scala on Heroku installation procedures. Use this Heroku toolbelt command: heroku run bash Copy Try the steps in No data appears (Java).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.03404,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears with <em>Heroku</em> (<em>Java</em>)",
        "sections": "No data appears with <em>Heroku</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem After waiting a few minutes, data is not appearing in your <em>Heroku</em> app&#x27;s APM Summary page. Solution Check the <em>Heroku</em> logs for errors with this <em>Heroku</em> toolbelt command: <em>heroku</em> logs --tail Copy Check that the files in your <em>Heroku</em> dyno match the file modifications from the <em>Java</em> on <em>Heroku</em> or <em>Java</em> with Scala on <em>Heroku</em> installation procedures. Use this <em>Heroku</em> toolbelt command: <em>heroku</em> run bash Copy Try the steps in No data appears (<em>Java</em>)."
      },
      "id": "6043b7c9e7b9d29b015799da"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.79076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " from additional datastores, get support at support.newrelic.com. Hosting services You can install the <em>Java</em> <em>agent</em> on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment <em>Heroku</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/heroku/no-data-appears-heroku-java": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.83862,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and <em>Heroku</em>",
        "sections": "<em>Java</em> <em>agent</em> and <em>Heroku</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "<em>Heroku</em> is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend <em>Heroku</em> with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for <em>Heroku</em>. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.77203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>",
        "sections": "<em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "<em>Heroku</em> is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend <em>Heroku</em> with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and <em>Heroku</em>. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.79074,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " from additional datastores, get support at support.newrelic.com. Hosting services You can install the <em>Java</em> <em>agent</em> on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment <em>Heroku</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/index": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.07868,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This describes how to configure New Relic&#x27;s <em>Java</em> <em>agent</em> if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic&#x27;s procedures to install the <em>Java</em> <em>agent</em> on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.857025,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the Infrastructure and APM <em>agents</em> on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The <em>Java</em> <em>agent</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-10-18T05:35:40Z",
      "updated_at": "2021-09-27T15:21:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # Real-time profiling using Java Flight Recorder (JFR). # This feature reports dimensional metrics to the ingest endpoint configured by # metric_ingest_uri and events to the ingest endpoint configured by event_ingest_uri. # Both ingest endpoints default to US production but they will be automatically set to EU # production when using an EU license key. Other ingest endpoints can be configured manually. # Requires a JVM that provides the JFR library. jfr: # Set to true to enable Real-time profiling with JFR. # Default is false. enabled: false # Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. # Audit logging is extremely verbose and should only be used for troubleshooting purposes. # Default is false. audit_logging: false # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.9191,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " options visit https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;configuration&#x2F;<em>java</em>-<em>agent</em>-configuration-config-file. # # &lt;%= generated_for_user %&gt; # # This section is for settings common to all environments. # Do not add anything above this next line. common: &amp;default_settings"
      },
      "id": "603eb738e7b9d242542a0815"
    }
  ],
  "/docs/agents/java-agent/installation/include-java-agent-jvm-argument": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.19304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This describes how to configure New Relic&#x27;s <em>Java</em> <em>agent</em> if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic&#x27;s procedures to install the <em>Java</em> <em>agent</em> on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.34473,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (<em>Java</em>). For more help Additional documentation resources include: <em>Java</em> <em>agent</em> and Heroku (for non-Scala <em>installation</em> on Heroku) No data appears with Heroku (troubleshotoing steps after <em>installation</em>) Scala <em>installation</em> for <em>Java</em> (Scala <em>installation</em> if you don&#x27;t use Heroku)"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.45623,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "-in instrumentation After you install the <em>Java</em> <em>agent</em>, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the <em>agent</em> collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of <em>installation</em>. Even if your library"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/installation/install-java-agent-java-2-security": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.63452,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " Security and WebSphere, you must grant the <em>Java</em> <em>agent</em> <em>additional</em> permissions before it can execute properly. Browser monitoring To use browser monitoring when running the <em>Java</em> <em>agent</em> on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the <em>Java</em> <em>agent</em>"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "Tip",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-10-18T20:20:21Z",
      "updated_at": "2021-08-27T14:01:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendors documentation. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI From one.newrelic.com, click Add more data and then search for \"Java\". Select the Java app monitoring option and complete the process. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Javas built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agents jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, heres how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report data to your New Relic account. To copy your license key: Go to the API keys UI and get a license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Heres a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Heres a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you dont specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Lets say you want the same Docker image for every installation. However, you dont want to run the New Relic agent every time an engineer spins up a test app because you dont want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.246826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " property. In the main body of newrelic.yml, disable the <em>Java</em> <em>agent</em> by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific <em>agents</em> by specifying the environment at runtime. <em>Additional</em> Tomcat Dockerfile examples Tomcat with environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "950370b0bcc14b07fe7609be457f3ace862af0c8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-07-27T10:41:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>3.47.1</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.8525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "sections": "<em>Install</em> <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "6043b9c764441f130a378f20"
    }
  ],
  "/docs/agents/java-agent/installation/install-java-agent": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.19302,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This describes how to configure New Relic&#x27;s <em>Java</em> <em>agent</em> if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic&#x27;s procedures to install the <em>Java</em> <em>agent</em> on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.34472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (<em>Java</em>). For more help Additional documentation resources include: <em>Java</em> <em>agent</em> and Heroku (for non-Scala <em>installation</em> on Heroku) No data appears with Heroku (troubleshotoing steps after <em>installation</em>) Scala <em>installation</em> for <em>Java</em> (Scala <em>installation</em> if you don&#x27;t use Heroku)"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.456215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "-in instrumentation After you install the <em>Java</em> <em>agent</em>, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the <em>agent</em> collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of <em>installation</em>. Even if your library"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/installation/uninstall-java-agent": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.193,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This describes how to configure New Relic&#x27;s <em>Java</em> <em>agent</em> if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic&#x27;s procedures to install the <em>Java</em> <em>agent</em> on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.34471,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (<em>Java</em>). For more help Additional documentation resources include: <em>Java</em> <em>agent</em> and Heroku (for non-Scala <em>installation</em> on Heroku) No data appears with Heroku (troubleshotoing steps after <em>installation</em>) Scala <em>installation</em> for <em>Java</em> (Scala <em>installation</em> if you don&#x27;t use Heroku)"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.4562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "-in instrumentation After you install the <em>Java</em> <em>agent</em>, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the <em>agent</em> collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of <em>installation</em>. Even if your library"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/installation/update-java-agent": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-18T02:19:37Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.193,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This describes how to configure New Relic&#x27;s <em>Java</em> <em>agent</em> if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic&#x27;s procedures to install the <em>Java</em> <em>agent</em> on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.34471,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (<em>Java</em>). For more help Additional documentation resources include: <em>Java</em> <em>agent</em> and Heroku (for non-Scala <em>installation</em> on Heroku) No data appears with Heroku (troubleshotoing steps after <em>installation</em>) Scala <em>installation</em> for <em>Java</em> (Scala <em>installation</em> if you don&#x27;t use Heroku)"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.4562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "-in instrumentation After you install the <em>Java</em> <em>agent</em>, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the <em>agent</em> collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of <em>installation</em>. Even if your library"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/instrumentation/extension-additional-instrumentation-modules": [
    {
      "sections": [
        "Java agent: Instrument Kafka message queues",
        "Tip",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Important",
        "Enable Kafka distributed traces",
        "1. Enable distributed tracing in the config file",
        "2. Instrument the Kafka producer",
        "3. Instrument the Kafka consumer"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "05644cd866713698034d5419961a40af31d06b90",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues/",
      "published_at": "2021-10-18T05:42:58Z",
      "updated_at": "2021-08-21T03:31:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName Copy For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate Copy Tip For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. Important The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Copy Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Copy Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Copy Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: com.newrelic.instrumentation.kafka-clients-spans-0.11.0.0: enabled: true Copy 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } Copy 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key or under the W3C's traceparent and tracestate keys. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec) { // create a distributed trace headers map Headers dtHeaders = ConcurrentHashMapHeaders.build(HeaderType.MESSAGE); // Iterate through each record header and insert the trace headers into the dtHeaders map for (Header header : rec.headers()) { String headerValue = new String(header.value(), StandardCharsets.UTF_8); // using the newrelic key if (header.key().equals(\"newrelic\")) { dtHeaders.addHeader(\"newrelic\", headerValue); } // or using the W3C keys if (header.key().equals(\"traceparent\")) { dtHeaders.addHeader(\"traceparent\", headerValue); } if (header.key().equals(\"tracestate\")) { dtHeaders.addHeader(\"tracestate\", headerValue); } } // Accept distributed tracing headers to link this request to the originating request NewRelic.getAgent().getTransaction().acceptDistributedTraceHeaders(TransportType.Kafka, dtHeaders); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.28056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "sections": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka <em>instrumentation</em> is available in <em>Java</em> <em>agent</em> versions 4.12.0 or higher. For supported Kafka client versions, see <em>Java</em> compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View"
      },
      "id": "603ebc2464441f7ce84e8885"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.19466,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> custom"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Instrument browser monitoring with Java agent API",
        "Use Java agent API",
        "Disable auto-instrumentation on all pages",
        "Disable auto-instrumentation only on specific pages",
        "JSP manual instrumentation",
        "Raw HTML manual instrumentation",
        "Thymeleaf 2.1 or higher manual instrumentation",
        "ColdFusion CFML page manual instrumentation",
        "Java Server Faces (JSF) frameworks",
        "Play Groovy template manual instrumentation",
        "Play 2.2 or higher Scala template manual instrumentation",
        "Play 2.1 Scala template manual instrumentation",
        "Apache Velocity Tools manual instrumentation",
        "Apache Velocity manual instrumentation",
        "When the JSP engine compiles a JSP",
        "After the agent connects to the server",
        "When New Relic invokes the JSP",
        "When the agent calls the header and footer API"
      ],
      "title": "Instrument browser monitoring with Java agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "09af4a22935b0d48ad5702f331d61a14936e469b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/instrument-browser-monitoring-java-agent-api/",
      "published_at": "2021-10-18T05:41:55Z",
      "updated_at": "2021-07-09T02:00:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring gives you visibility into how your users are interacting with your Java application by using a JavaScript snippet (or \"agent\") to instrument your app's webpages. To install the browser agent via the UI, follow the procedures to install the browser agent. For example, you can: Enable an APM-monitored app. Enable with the copy/paste method. Enable by using the REST API. You can also manually instrument your webpages by using the Java agent API, as explained in this document. Use Java agent API If your framework does not allow you to enable browser monitoring from our UI, with the copy/paste method, or by using our REST API, you can manually instrument monitoring for your webpages. To do this, use our Java agent API. Make sure you are using the latest Java agent version. Disable auto-instrumentation. Disable auto-instrumentation on all pages Set the auto_instrument flag under browser_monitoring to false in your newrelic.yml. browser_monitoring: auto_instrument: false Copy Restart your application. Flush the app server's work cache. Flushing the work cache forces the app server to recompile JSPs, which is when auto-instrumentation occurs. Disable auto-instrumentation only on specific pages Use the disabled_auto_pages flag under the browser_monitoring stanza. For example, to disable auto-instrumentation on testpage_1.jsp and testpage_2.jsp, use the following: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy Access the Java agent API class by adding newrelic-api.jar to your application class path. Add the appropriate method to start time tracking, for example: com.newrelic.api.agent.NewRelic.getBrowserTimingHeader(). Add the appropriate method to stop time tracking, for example: com.newrelic.api.agent.NewRelic.getBrowserTimingFooter(). Find the appropriate methods based on the framework you are using: JSP manual instrumentation Insert the header as close to the top of <head> tag as possible but after the meta tags. Insert the footer before the </body> tag. <!DOCTYPE html> <html> <head><title>EXAMPLE</title> <meta charset=\"utf-8\"> <meta name=\"description\" content=\"Example header and footer call\">; <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> </head> <body> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingFooter() %> </body> </html> Copy Raw HTML manual instrumentation To manually instrument using raw HTML, include page load timing code in the HTTP response. Thymeleaf 2.1 or higher manual instrumentation <head> ... <div th:remove=\"tag\" th:utext=\"${T(com.newrelic.api.agent.NewRelic).getBrowserTimingHeader()}\"></div> </head> <body> ... <div th:utext=\"${T(com.newrelic.api.agent.NewRelic).getBrowserTimingFooter()}\"></div> </body> Copy ColdFusion CFML page manual instrumentation <cfobject type=\"Java\" class=\"com.newrelic.api.agent.NewRelic\" name=\"newRelic\"/> <cfset header = newRelic.getBrowserTimingHeader() /> <cfoutput>#header#</cfoutput> ... ... <cfset footer = newRelic.getBrowserTimingFooter() /> <cfoutput>#footer#</cfoutput> Copy Java Server Faces (JSF) frameworks Manual instrumentation is not available with JSF. To insert the Browser JavaScript snippet into your app's webpages, use the copy/paste method. Play Groovy template manual instrumentation ${com.newrelic.api.agent.NewRelic.getBrowserTimingHeader().raw()} ... ... ${com.newrelic.api.agent.NewRelic.getBrowserTimingFooter().raw()} Copy Play 2.2 or higher Scala template manual instrumentation Add the following to build.sbt, substituting the latest agent version for 3.x.x: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"3.x.x\" Copy In main.scala.html, add the following: @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingHeader()) ... ... @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingFooter()) Copy Play 2.1 Scala template manual instrumentation Add the following to Build.scala, substituting the lastest agent version for 2.x.x: appDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"2.x.x\" Copy In main.scala.html, add the following: @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingHeader()) ... ... @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingFooter())**Manual instrumentation with Apache Velocity Template Language (VTL)** Copy Apache Velocity Tools manual instrumentation If you are using Velocity Tools, define a NewRelic tool in toolbox.xml: <toolbox> <tool> <key>NewRelic</key> <scope>application</scope> <class>com.newrelic.api.agent.NewRelic</class> </tool> </toolbox> Copy Call the NewRelic API in your velocity template: $NewRelic.getBrowserTimingHeader() ... ... $NewRelic.getBrowserTimingFooter() Copy Apache Velocity manual instrumentation To ensure that all of your browser page views are not grouped under a single /velocity transaction (and to avoid metric grouping issues), disable your enable_auto_transaction_naming setting in your newrelic.yml file: enable_auto_transaction_naming: false Copy Add newrelic-api.jar to the classpath of Tomcat, typically in .../tomcat/bin/setenv.sh: CLASSPATH=$CLASSPATH:/opt/newrelic/newrelic-api.jar Copy OR Add the reference to this jar file to the end of an existing CLASSPATH=... line within that file. In each app, find WEB-INF/tools.xml and add the following tag: <toolbox scope=\"application\"> <tool class=\"com.newrelic.api.agent.NewRelic\" key=\"NewRelic\" /> </toolbox> Copy If a <toolbox scope=\"application\"> tag already exists, put the <tool ... /> within the tag. In each app, edit the Velocity template that the other pages in the application use. Add this tag within the <head> stanza before any <link> and <script> declarations and after any meta tags: $NewRelic.getBrowserTimingHeader() Copy Add this tag within the <body> stanza as the line right before the </body> tag, at the very bottom of the body: $NewRelic.getBrowserTimingFooter() Copy Restart the Tomcat server: If you are using Linux/Unix, add the following command line to the Users/Tomcat/bin directory: ./shutdown.sh ./startup.sh Copy If you are using Windows, go to your Users/Tomcat/bin directory, and add the following command line: % shutdown.bat % startup.bat Copy Check the log file to verify that the agent is instrumenting correctly. Set the log_level setting in newrelic.yml to log_level: finer and check for the following messages: When the JSP engine compiles a JSP May 17, 2011 9:33:18 AM NewRelic FINE: Compiling JSP: /jsp/header.jsp May 17, 2011 9:33:18 AM NewRelic FINE: Injecting browser timing header into: /jsp/header.jsp May 17, 2011 9:33:36 AM NewRelic FINE: Compiling JSP: /jsp/footer.jsp May 17, 2011 9:33:36 AM NewRelic FINE: Injecting browser timing footer into: /jsp/footer.jsp Copy After the agent connects to the server The JavaScript snippet is not inserted into the HTML response until after the agent connects to the server. May 17, 2011 9:43:21 AM NewRelic INFO: Real user monitoring is enabled with auto instrumentation Copy When New Relic invokes the JSP May 17, 2011 9:43:23 AM NewRelic FINER: Injecting browser timing header in a JSP. Content type is text/html May 17, 2011 9:43:23 AM NewRelic FINER: Injecting browser timing footer in a JSP. Content type is text/html Copy When the agent calls the header and footer API May 17, 2011 9:43:23 AM NewRelic FINEST: Got browser timing header in NewRelic API: <script>var NREUMQ=[];NREUMQ.push([\"mark\",\"firstbyte\",new Date().getTime()]);(function(){var d=document;var e=d.createElement(\"script\");e.type=\"text/javascript\";e.async=true;e.src=\"https://d7p9czrvs14ne.cloudfront.net/11/eum/rum.js\";var s=d.getElementsByTagName(\"script\")[0];s.parentNode.insertBefore(e,s);})();</script> May 17, 2011 9:43:23 AM NewRelic FINEST: Got browser timing footer in NewRelic API: <script type=\"text/javascript\" charset=\"utf-8\">NREUMQ.push([\"nrf2\",\"staging-beacon-1.newrelic.com\",\"8512b4d93f\",7449,\"M1RTYksFDEYDUxdcDgoeZERQSwhGEmQGRhVL\",0,413])</script> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.46294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Instrument</em> browser monitoring with <em>Java</em> <em>agent</em> API",
        "sections": "<em>Instrument</em> browser monitoring with <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ", with the copy&#x2F;paste method, or by using our REST API, you can manually <em>instrument</em> monitoring for your webpages. To do this, use our <em>Java</em> <em>agent</em> API. Make sure you are using the latest <em>Java</em> <em>agent</em> version. Disable auto-<em>instrumentation</em>. Disable auto-<em>instrumentation</em> on all pages Set the auto_<em>instrument</em> flag"
      },
      "id": "6043cd9564441f866e378ec8"
    }
  ],
  "/docs/agents/java-agent/instrumentation/ignore-transactions-using-api": [
    {
      "sections": [
        "Java agent: Instrument Kafka message queues",
        "Tip",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Important",
        "Enable Kafka distributed traces",
        "1. Enable distributed tracing in the config file",
        "2. Instrument the Kafka producer",
        "3. Instrument the Kafka consumer"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "05644cd866713698034d5419961a40af31d06b90",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues/",
      "published_at": "2021-10-18T05:42:58Z",
      "updated_at": "2021-08-21T03:31:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName Copy For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate Copy Tip For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. Important The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Copy Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Copy Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Copy Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: com.newrelic.instrumentation.kafka-clients-spans-0.11.0.0: enabled: true Copy 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } Copy 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key or under the W3C's traceparent and tracestate keys. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec) { // create a distributed trace headers map Headers dtHeaders = ConcurrentHashMapHeaders.build(HeaderType.MESSAGE); // Iterate through each record header and insert the trace headers into the dtHeaders map for (Header header : rec.headers()) { String headerValue = new String(header.value(), StandardCharsets.UTF_8); // using the newrelic key if (header.key().equals(\"newrelic\")) { dtHeaders.addHeader(\"newrelic\", headerValue); } // or using the W3C keys if (header.key().equals(\"traceparent\")) { dtHeaders.addHeader(\"traceparent\", headerValue); } if (header.key().equals(\"tracestate\")) { dtHeaders.addHeader(\"tracestate\", headerValue); } } // Accept distributed tracing headers to link this request to the originating request NewRelic.getAgent().getTransaction().acceptDistributedTraceHeaders(TransportType.Kafka, dtHeaders); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.28056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "sections": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka <em>instrumentation</em> is available in <em>Java</em> <em>agent</em> versions 4.12.0 or higher. For supported Kafka client versions, see <em>Java</em> compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View"
      },
      "id": "603ebc2464441f7ce84e8885"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.19466,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> custom"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Instrument browser monitoring with Java agent API",
        "Use Java agent API",
        "Disable auto-instrumentation on all pages",
        "Disable auto-instrumentation only on specific pages",
        "JSP manual instrumentation",
        "Raw HTML manual instrumentation",
        "Thymeleaf 2.1 or higher manual instrumentation",
        "ColdFusion CFML page manual instrumentation",
        "Java Server Faces (JSF) frameworks",
        "Play Groovy template manual instrumentation",
        "Play 2.2 or higher Scala template manual instrumentation",
        "Play 2.1 Scala template manual instrumentation",
        "Apache Velocity Tools manual instrumentation",
        "Apache Velocity manual instrumentation",
        "When the JSP engine compiles a JSP",
        "After the agent connects to the server",
        "When New Relic invokes the JSP",
        "When the agent calls the header and footer API"
      ],
      "title": "Instrument browser monitoring with Java agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "09af4a22935b0d48ad5702f331d61a14936e469b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/instrument-browser-monitoring-java-agent-api/",
      "published_at": "2021-10-18T05:41:55Z",
      "updated_at": "2021-07-09T02:00:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring gives you visibility into how your users are interacting with your Java application by using a JavaScript snippet (or \"agent\") to instrument your app's webpages. To install the browser agent via the UI, follow the procedures to install the browser agent. For example, you can: Enable an APM-monitored app. Enable with the copy/paste method. Enable by using the REST API. You can also manually instrument your webpages by using the Java agent API, as explained in this document. Use Java agent API If your framework does not allow you to enable browser monitoring from our UI, with the copy/paste method, or by using our REST API, you can manually instrument monitoring for your webpages. To do this, use our Java agent API. Make sure you are using the latest Java agent version. Disable auto-instrumentation. Disable auto-instrumentation on all pages Set the auto_instrument flag under browser_monitoring to false in your newrelic.yml. browser_monitoring: auto_instrument: false Copy Restart your application. Flush the app server's work cache. Flushing the work cache forces the app server to recompile JSPs, which is when auto-instrumentation occurs. Disable auto-instrumentation only on specific pages Use the disabled_auto_pages flag under the browser_monitoring stanza. For example, to disable auto-instrumentation on testpage_1.jsp and testpage_2.jsp, use the following: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy Access the Java agent API class by adding newrelic-api.jar to your application class path. Add the appropriate method to start time tracking, for example: com.newrelic.api.agent.NewRelic.getBrowserTimingHeader(). Add the appropriate method to stop time tracking, for example: com.newrelic.api.agent.NewRelic.getBrowserTimingFooter(). Find the appropriate methods based on the framework you are using: JSP manual instrumentation Insert the header as close to the top of <head> tag as possible but after the meta tags. Insert the footer before the </body> tag. <!DOCTYPE html> <html> <head><title>EXAMPLE</title> <meta charset=\"utf-8\"> <meta name=\"description\" content=\"Example header and footer call\">; <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> </head> <body> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingFooter() %> </body> </html> Copy Raw HTML manual instrumentation To manually instrument using raw HTML, include page load timing code in the HTTP response. Thymeleaf 2.1 or higher manual instrumentation <head> ... <div th:remove=\"tag\" th:utext=\"${T(com.newrelic.api.agent.NewRelic).getBrowserTimingHeader()}\"></div> </head> <body> ... <div th:utext=\"${T(com.newrelic.api.agent.NewRelic).getBrowserTimingFooter()}\"></div> </body> Copy ColdFusion CFML page manual instrumentation <cfobject type=\"Java\" class=\"com.newrelic.api.agent.NewRelic\" name=\"newRelic\"/> <cfset header = newRelic.getBrowserTimingHeader() /> <cfoutput>#header#</cfoutput> ... ... <cfset footer = newRelic.getBrowserTimingFooter() /> <cfoutput>#footer#</cfoutput> Copy Java Server Faces (JSF) frameworks Manual instrumentation is not available with JSF. To insert the Browser JavaScript snippet into your app's webpages, use the copy/paste method. Play Groovy template manual instrumentation ${com.newrelic.api.agent.NewRelic.getBrowserTimingHeader().raw()} ... ... ${com.newrelic.api.agent.NewRelic.getBrowserTimingFooter().raw()} Copy Play 2.2 or higher Scala template manual instrumentation Add the following to build.sbt, substituting the latest agent version for 3.x.x: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"3.x.x\" Copy In main.scala.html, add the following: @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingHeader()) ... ... @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingFooter()) Copy Play 2.1 Scala template manual instrumentation Add the following to Build.scala, substituting the lastest agent version for 2.x.x: appDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"2.x.x\" Copy In main.scala.html, add the following: @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingHeader()) ... ... @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingFooter())**Manual instrumentation with Apache Velocity Template Language (VTL)** Copy Apache Velocity Tools manual instrumentation If you are using Velocity Tools, define a NewRelic tool in toolbox.xml: <toolbox> <tool> <key>NewRelic</key> <scope>application</scope> <class>com.newrelic.api.agent.NewRelic</class> </tool> </toolbox> Copy Call the NewRelic API in your velocity template: $NewRelic.getBrowserTimingHeader() ... ... $NewRelic.getBrowserTimingFooter() Copy Apache Velocity manual instrumentation To ensure that all of your browser page views are not grouped under a single /velocity transaction (and to avoid metric grouping issues), disable your enable_auto_transaction_naming setting in your newrelic.yml file: enable_auto_transaction_naming: false Copy Add newrelic-api.jar to the classpath of Tomcat, typically in .../tomcat/bin/setenv.sh: CLASSPATH=$CLASSPATH:/opt/newrelic/newrelic-api.jar Copy OR Add the reference to this jar file to the end of an existing CLASSPATH=... line within that file. In each app, find WEB-INF/tools.xml and add the following tag: <toolbox scope=\"application\"> <tool class=\"com.newrelic.api.agent.NewRelic\" key=\"NewRelic\" /> </toolbox> Copy If a <toolbox scope=\"application\"> tag already exists, put the <tool ... /> within the tag. In each app, edit the Velocity template that the other pages in the application use. Add this tag within the <head> stanza before any <link> and <script> declarations and after any meta tags: $NewRelic.getBrowserTimingHeader() Copy Add this tag within the <body> stanza as the line right before the </body> tag, at the very bottom of the body: $NewRelic.getBrowserTimingFooter() Copy Restart the Tomcat server: If you are using Linux/Unix, add the following command line to the Users/Tomcat/bin directory: ./shutdown.sh ./startup.sh Copy If you are using Windows, go to your Users/Tomcat/bin directory, and add the following command line: % shutdown.bat % startup.bat Copy Check the log file to verify that the agent is instrumenting correctly. Set the log_level setting in newrelic.yml to log_level: finer and check for the following messages: When the JSP engine compiles a JSP May 17, 2011 9:33:18 AM NewRelic FINE: Compiling JSP: /jsp/header.jsp May 17, 2011 9:33:18 AM NewRelic FINE: Injecting browser timing header into: /jsp/header.jsp May 17, 2011 9:33:36 AM NewRelic FINE: Compiling JSP: /jsp/footer.jsp May 17, 2011 9:33:36 AM NewRelic FINE: Injecting browser timing footer into: /jsp/footer.jsp Copy After the agent connects to the server The JavaScript snippet is not inserted into the HTML response until after the agent connects to the server. May 17, 2011 9:43:21 AM NewRelic INFO: Real user monitoring is enabled with auto instrumentation Copy When New Relic invokes the JSP May 17, 2011 9:43:23 AM NewRelic FINER: Injecting browser timing header in a JSP. Content type is text/html May 17, 2011 9:43:23 AM NewRelic FINER: Injecting browser timing footer in a JSP. Content type is text/html Copy When the agent calls the header and footer API May 17, 2011 9:43:23 AM NewRelic FINEST: Got browser timing header in NewRelic API: <script>var NREUMQ=[];NREUMQ.push([\"mark\",\"firstbyte\",new Date().getTime()]);(function(){var d=document;var e=d.createElement(\"script\");e.type=\"text/javascript\";e.async=true;e.src=\"https://d7p9czrvs14ne.cloudfront.net/11/eum/rum.js\";var s=d.getElementsByTagName(\"script\")[0];s.parentNode.insertBefore(e,s);})();</script> May 17, 2011 9:43:23 AM NewRelic FINEST: Got browser timing footer in NewRelic API: <script type=\"text/javascript\" charset=\"utf-8\">NREUMQ.push([\"nrf2\",\"staging-beacon-1.newrelic.com\",\"8512b4d93f\",7449,\"M1RTYksFDEYDUxdcDgoeZERQSwhGEmQGRhVL\",0,413])</script> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.46294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Instrument</em> browser monitoring with <em>Java</em> <em>agent</em> API",
        "sections": "<em>Instrument</em> browser monitoring with <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ", with the copy&#x2F;paste method, or by using our REST API, you can manually <em>instrument</em> monitoring for your webpages. To do this, use our <em>Java</em> <em>agent</em> API. Make sure you are using the latest <em>Java</em> <em>agent</em> version. Disable auto-<em>instrumentation</em>. Disable auto-<em>instrumentation</em> on all pages Set the auto_<em>instrument</em> flag"
      },
      "id": "6043cd9564441f866e378ec8"
    }
  ],
  "/docs/agents/java-agent/instrumentation/instrument-browser-monitoring-java-agent-api": [
    {
      "sections": [
        "Java agent: Instrument Kafka message queues",
        "Tip",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Important",
        "Enable Kafka distributed traces",
        "1. Enable distributed tracing in the config file",
        "2. Instrument the Kafka producer",
        "3. Instrument the Kafka consumer"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "05644cd866713698034d5419961a40af31d06b90",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues/",
      "published_at": "2021-10-18T05:42:58Z",
      "updated_at": "2021-08-21T03:31:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName Copy For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate Copy Tip For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. Important The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Copy Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Copy Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Copy Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: com.newrelic.instrumentation.kafka-clients-spans-0.11.0.0: enabled: true Copy 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } Copy 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key or under the W3C's traceparent and tracestate keys. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec) { // create a distributed trace headers map Headers dtHeaders = ConcurrentHashMapHeaders.build(HeaderType.MESSAGE); // Iterate through each record header and insert the trace headers into the dtHeaders map for (Header header : rec.headers()) { String headerValue = new String(header.value(), StandardCharsets.UTF_8); // using the newrelic key if (header.key().equals(\"newrelic\")) { dtHeaders.addHeader(\"newrelic\", headerValue); } // or using the W3C keys if (header.key().equals(\"traceparent\")) { dtHeaders.addHeader(\"traceparent\", headerValue); } if (header.key().equals(\"tracestate\")) { dtHeaders.addHeader(\"tracestate\", headerValue); } } // Accept distributed tracing headers to link this request to the originating request NewRelic.getAgent().getTransaction().acceptDistributedTraceHeaders(TransportType.Kafka, dtHeaders); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.28056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "sections": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka <em>instrumentation</em> is available in <em>Java</em> <em>agent</em> versions 4.12.0 or higher. For supported Kafka client versions, see <em>Java</em> compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View"
      },
      "id": "603ebc2464441f7ce84e8885"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.19464,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> custom"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-10-18T05:35:40Z",
      "updated_at": "2021-09-27T15:21:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # Real-time profiling using Java Flight Recorder (JFR). # This feature reports dimensional metrics to the ingest endpoint configured by # metric_ingest_uri and events to the ingest endpoint configured by event_ingest_uri. # Both ingest endpoints default to US production but they will be automatically set to EU # production when using an EU license key. Other ingest endpoints can be configured manually. # Requires a JVM that provides the JFR library. jfr: # Set to true to enable Real-time profiling with JFR. # Default is false. enabled: false # Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. # Audit logging is extremely verbose and should only be used for troubleshooting purposes. # Default is false. audit_logging: false # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.04243,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ": # By default the <em>agent</em> automatically inserts API calls in compiled JSPs to # inject the monitoring <em>Java</em>Script into web pages. Not all rendering engines are supported. # See https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>instrumentation</em>&#x2F;new-relic-browser-<em>java</em>-<em>agent</em>#manual_<em>instrumentation</em>"
      },
      "id": "603eb738e7b9d242542a0815"
    }
  ],
  "/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues": [
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.19464,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> custom"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Instrument browser monitoring with Java agent API",
        "Use Java agent API",
        "Disable auto-instrumentation on all pages",
        "Disable auto-instrumentation only on specific pages",
        "JSP manual instrumentation",
        "Raw HTML manual instrumentation",
        "Thymeleaf 2.1 or higher manual instrumentation",
        "ColdFusion CFML page manual instrumentation",
        "Java Server Faces (JSF) frameworks",
        "Play Groovy template manual instrumentation",
        "Play 2.2 or higher Scala template manual instrumentation",
        "Play 2.1 Scala template manual instrumentation",
        "Apache Velocity Tools manual instrumentation",
        "Apache Velocity manual instrumentation",
        "When the JSP engine compiles a JSP",
        "After the agent connects to the server",
        "When New Relic invokes the JSP",
        "When the agent calls the header and footer API"
      ],
      "title": "Instrument browser monitoring with Java agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "09af4a22935b0d48ad5702f331d61a14936e469b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/instrument-browser-monitoring-java-agent-api/",
      "published_at": "2021-10-18T05:41:55Z",
      "updated_at": "2021-07-09T02:00:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring gives you visibility into how your users are interacting with your Java application by using a JavaScript snippet (or \"agent\") to instrument your app's webpages. To install the browser agent via the UI, follow the procedures to install the browser agent. For example, you can: Enable an APM-monitored app. Enable with the copy/paste method. Enable by using the REST API. You can also manually instrument your webpages by using the Java agent API, as explained in this document. Use Java agent API If your framework does not allow you to enable browser monitoring from our UI, with the copy/paste method, or by using our REST API, you can manually instrument monitoring for your webpages. To do this, use our Java agent API. Make sure you are using the latest Java agent version. Disable auto-instrumentation. Disable auto-instrumentation on all pages Set the auto_instrument flag under browser_monitoring to false in your newrelic.yml. browser_monitoring: auto_instrument: false Copy Restart your application. Flush the app server's work cache. Flushing the work cache forces the app server to recompile JSPs, which is when auto-instrumentation occurs. Disable auto-instrumentation only on specific pages Use the disabled_auto_pages flag under the browser_monitoring stanza. For example, to disable auto-instrumentation on testpage_1.jsp and testpage_2.jsp, use the following: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy Access the Java agent API class by adding newrelic-api.jar to your application class path. Add the appropriate method to start time tracking, for example: com.newrelic.api.agent.NewRelic.getBrowserTimingHeader(). Add the appropriate method to stop time tracking, for example: com.newrelic.api.agent.NewRelic.getBrowserTimingFooter(). Find the appropriate methods based on the framework you are using: JSP manual instrumentation Insert the header as close to the top of <head> tag as possible but after the meta tags. Insert the footer before the </body> tag. <!DOCTYPE html> <html> <head><title>EXAMPLE</title> <meta charset=\"utf-8\"> <meta name=\"description\" content=\"Example header and footer call\">; <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> </head> <body> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingFooter() %> </body> </html> Copy Raw HTML manual instrumentation To manually instrument using raw HTML, include page load timing code in the HTTP response. Thymeleaf 2.1 or higher manual instrumentation <head> ... <div th:remove=\"tag\" th:utext=\"${T(com.newrelic.api.agent.NewRelic).getBrowserTimingHeader()}\"></div> </head> <body> ... <div th:utext=\"${T(com.newrelic.api.agent.NewRelic).getBrowserTimingFooter()}\"></div> </body> Copy ColdFusion CFML page manual instrumentation <cfobject type=\"Java\" class=\"com.newrelic.api.agent.NewRelic\" name=\"newRelic\"/> <cfset header = newRelic.getBrowserTimingHeader() /> <cfoutput>#header#</cfoutput> ... ... <cfset footer = newRelic.getBrowserTimingFooter() /> <cfoutput>#footer#</cfoutput> Copy Java Server Faces (JSF) frameworks Manual instrumentation is not available with JSF. To insert the Browser JavaScript snippet into your app's webpages, use the copy/paste method. Play Groovy template manual instrumentation ${com.newrelic.api.agent.NewRelic.getBrowserTimingHeader().raw()} ... ... ${com.newrelic.api.agent.NewRelic.getBrowserTimingFooter().raw()} Copy Play 2.2 or higher Scala template manual instrumentation Add the following to build.sbt, substituting the latest agent version for 3.x.x: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"3.x.x\" Copy In main.scala.html, add the following: @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingHeader()) ... ... @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingFooter()) Copy Play 2.1 Scala template manual instrumentation Add the following to Build.scala, substituting the lastest agent version for 2.x.x: appDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"2.x.x\" Copy In main.scala.html, add the following: @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingHeader()) ... ... @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingFooter())**Manual instrumentation with Apache Velocity Template Language (VTL)** Copy Apache Velocity Tools manual instrumentation If you are using Velocity Tools, define a NewRelic tool in toolbox.xml: <toolbox> <tool> <key>NewRelic</key> <scope>application</scope> <class>com.newrelic.api.agent.NewRelic</class> </tool> </toolbox> Copy Call the NewRelic API in your velocity template: $NewRelic.getBrowserTimingHeader() ... ... $NewRelic.getBrowserTimingFooter() Copy Apache Velocity manual instrumentation To ensure that all of your browser page views are not grouped under a single /velocity transaction (and to avoid metric grouping issues), disable your enable_auto_transaction_naming setting in your newrelic.yml file: enable_auto_transaction_naming: false Copy Add newrelic-api.jar to the classpath of Tomcat, typically in .../tomcat/bin/setenv.sh: CLASSPATH=$CLASSPATH:/opt/newrelic/newrelic-api.jar Copy OR Add the reference to this jar file to the end of an existing CLASSPATH=... line within that file. In each app, find WEB-INF/tools.xml and add the following tag: <toolbox scope=\"application\"> <tool class=\"com.newrelic.api.agent.NewRelic\" key=\"NewRelic\" /> </toolbox> Copy If a <toolbox scope=\"application\"> tag already exists, put the <tool ... /> within the tag. In each app, edit the Velocity template that the other pages in the application use. Add this tag within the <head> stanza before any <link> and <script> declarations and after any meta tags: $NewRelic.getBrowserTimingHeader() Copy Add this tag within the <body> stanza as the line right before the </body> tag, at the very bottom of the body: $NewRelic.getBrowserTimingFooter() Copy Restart the Tomcat server: If you are using Linux/Unix, add the following command line to the Users/Tomcat/bin directory: ./shutdown.sh ./startup.sh Copy If you are using Windows, go to your Users/Tomcat/bin directory, and add the following command line: % shutdown.bat % startup.bat Copy Check the log file to verify that the agent is instrumenting correctly. Set the log_level setting in newrelic.yml to log_level: finer and check for the following messages: When the JSP engine compiles a JSP May 17, 2011 9:33:18 AM NewRelic FINE: Compiling JSP: /jsp/header.jsp May 17, 2011 9:33:18 AM NewRelic FINE: Injecting browser timing header into: /jsp/header.jsp May 17, 2011 9:33:36 AM NewRelic FINE: Compiling JSP: /jsp/footer.jsp May 17, 2011 9:33:36 AM NewRelic FINE: Injecting browser timing footer into: /jsp/footer.jsp Copy After the agent connects to the server The JavaScript snippet is not inserted into the HTML response until after the agent connects to the server. May 17, 2011 9:43:21 AM NewRelic INFO: Real user monitoring is enabled with auto instrumentation Copy When New Relic invokes the JSP May 17, 2011 9:43:23 AM NewRelic FINER: Injecting browser timing header in a JSP. Content type is text/html May 17, 2011 9:43:23 AM NewRelic FINER: Injecting browser timing footer in a JSP. Content type is text/html Copy When the agent calls the header and footer API May 17, 2011 9:43:23 AM NewRelic FINEST: Got browser timing header in NewRelic API: <script>var NREUMQ=[];NREUMQ.push([\"mark\",\"firstbyte\",new Date().getTime()]);(function(){var d=document;var e=d.createElement(\"script\");e.type=\"text/javascript\";e.async=true;e.src=\"https://d7p9czrvs14ne.cloudfront.net/11/eum/rum.js\";var s=d.getElementsByTagName(\"script\")[0];s.parentNode.insertBefore(e,s);})();</script> May 17, 2011 9:43:23 AM NewRelic FINEST: Got browser timing footer in NewRelic API: <script type=\"text/javascript\" charset=\"utf-8\">NREUMQ.push([\"nrf2\",\"staging-beacon-1.newrelic.com\",\"8512b4d93f\",7449,\"M1RTYksFDEYDUxdcDgoeZERQSwhGEmQGRhVL\",0,413])</script> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.46293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Instrument</em> browser monitoring with <em>Java</em> <em>agent</em> API",
        "sections": "<em>Instrument</em> browser monitoring with <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ", with the copy&#x2F;paste method, or by using our REST API, you can manually <em>instrument</em> monitoring for your webpages. To do this, use our <em>Java</em> <em>agent</em> API. Make sure you are using the latest <em>Java</em> <em>agent</em> version. Disable auto-<em>instrumentation</em>. Disable auto-<em>instrumentation</em> on all pages Set the auto_<em>instrument</em> flag"
      },
      "id": "6043cd9564441f866e378ec8"
    },
    {
      "sections": [
        "Java agent config file template"
      ],
      "title": "Java agent config file template",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "cab129eda0df59e172b299574d8e44fbb3c04617",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-config-file-template/",
      "published_at": "2021-10-18T05:35:40Z",
      "updated_at": "2021-09-27T15:21:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains a templated version of the newrelic.yml file that the Java agent reads for configuration. The config file format is YAML. While no knowledge of YAML is necessary to edit the file, be careful to maintain the proper indentation. Learn more about YAML on Wikipedia. When making changes to the newrelic.yml file, use a YAML validator to ensure the syntax is accurate and follow these rules: YML files are case sensitive. All indentations are in increments of two characters. Data in the same stanza of the file must use the same level of indentation, and sub-stanzas should be indented by an additional two spaces. For more information about structure, directories, and settings, see Java agent configuration. # This file configures the New Relic Agent. New Relic monitors # Java applications with deep visibility and low overhead. For more details and additional # configuration options visit https://docs.newrelic.com/docs/agents/java-agent/configuration/java-agent-configuration-config-file. # # <%= generated_for_user %> # # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings # ============================== LICENSE KEY =============================== # You must specify the license key associated with your New Relic # account. For example, if your license key is 12345 use this: # license_key: '12345' # The key binds your Agent's data to your account in the New Relic service. license_key: '<%= license_key %>' # Agent Enabled # Use this setting to disable the agent instead of removing it from the startup command. # Default is true. agent_enabled: true # Set the name of your application as you'd like it show up in New Relic. # If enable_auto_app_naming is false, the agent reports all data to this application. # Otherwise, the agent reports only background tasks (transactions for non-web applications) # to this application. To report data to more than one application # (useful for rollup reporting), separate the application names with \";\". # For example, to report data to \"My Application\" and \"My Application 2\" use this: # app_name: My Application;My Application 2 # This setting is required. Up to 3 different application names can be specified. # The first application name must be unique. app_name: My Application # To enable high security, set this property to true. When in high # security mode, the agent will use SSL and obfuscated SQL. Additionally, # request parameters and message parameters will not be sent to New Relic. high_security: false # Set to true to enable support for auto app naming. # The name of each web app is detected automatically # and the agent reports data separately for each one. # This provides a finer-grained performance breakdown for # web apps in New Relic. # Default is false. enable_auto_app_naming: false # Set to true to enable component-based transaction naming. # Set to false to use the URI of a web request as the name of the transaction. # Default is true. enable_auto_transaction_naming: true # The agent uses its own log file to keep its logging # separate from that of your application. Specify the log level here. # This setting is dynamic, so changes do not require restarting your application. # The levels in increasing order of verboseness are: # off, severe, warning, info, fine, finer, finest # Default is info. log_level: info # Log all data sent to and from New Relic in plain text. # This setting is dynamic, so changes do not require restarting your application. # Default is false. audit_mode: false # The number of backup log files to save. # Default is 1. log_file_count: 1 # The maximum number of kbytes to write to any one log file. # The log_file_count must be set greater than 1. # Default is 0 (no limit). log_limit_in_kbytes: 0 # Override other log rolling configuration and roll the logs daily. # Default is false. log_daily: false # The name of the log file. # Default is newrelic_agent.log. log_file_name: newrelic_agent.log # The log file directory. # Default is the logs directory in the newrelic.jar parent directory. #log_file_path: # Proxy settings for connecting to the New Relic server: # If a proxy is used, the host setting is required. Other settings # are optional. Default port is 8080. The username and password # settings will be used to authenticate to Basic Auth challenges # from a proxy server. Proxy scheme will allow the agent to # connect through proxies using the HTTPS scheme. #proxy_host: hostname #proxy_port: 8080 #proxy_user: username #proxy_password: password #proxy_scheme: https # Limits the number of lines to capture for each stack trace. # Default is 30 max_stack_trace_lines: 30 # Provides the ability to configure the attributes sent to New Relic. These # attributes can be found in transaction traces, traced errors, Insight's # transaction events, and Insight's page views. attributes: # When true, attributes will be sent to New Relic. The default is true. enabled: true #A comma separated list of attribute keys whose values should # be sent to New Relic. #include: # A comma separated list of attribute keys whose values should # not be sent to New Relic. #exclude: # Transaction tracer captures deep information about slow # transactions and sends this to the New Relic service once a # minute. Included in the transaction is the exact call sequence of # the transactions including any SQL statements issued. transaction_tracer: # Transaction tracer is enabled by default. Set this to false to turn it off. # This feature is not available to Lite accounts and is automatically disabled. # Default is true. enabled: true # Threshold in seconds for when to collect a transaction # trace. When the response time of a controller action exceeds # this threshold, a transaction trace will be recorded and sent to # New Relic. Valid values are any float value, or (default) \"apdex_f\", # which will use the threshold for the \"Frustrated\" Apdex level # (greater than four times the apdex_t value). # Default is apdex_f. transaction_threshold: apdex_f # When transaction tracer is on, SQL statements can optionally be # recorded. The recorder has three modes, \"off\" which sends no # SQL, \"raw\" which sends the SQL statement in its original form, # and \"obfuscated\", which strips out numeric and string literals. # Default is obfuscated. record_sql: obfuscated # Set this to true to log SQL statements instead of recording them. # SQL is logged using the record_sql mode. # Default is false. log_sql: false # Threshold in seconds for when to collect stack trace for a SQL # call. In other words, when SQL statements exceed this threshold, # then capture and send to New Relic the current stack trace. This is # helpful for pinpointing where long SQL calls originate from. # Default is 0.5 seconds. stack_trace_threshold: 0.5 # Determines whether the agent will capture query plans for slow # SQL queries. Only supported for MySQL and PostgreSQL. # Default is true. explain_enabled: true # Threshold for query execution time below which query plans will not # not be captured. Relevant only when `explain_enabled` is true. # Default is 0.5 seconds. explain_threshold: 0.5 # Use this setting to control the variety of transaction traces. # The higher the setting, the greater the variety. # Set this to 0 to always report the slowest transaction trace. # Default is 20. top_n: 20 # Error collector captures information about uncaught exceptions and # sends them to New Relic for viewing. error_collector: # This property enables the collection of errors. If the property is not # set or the property is set to false, then errors will not be collected. # Default is true. enabled: true # Use this property to exclude specific exceptions from being reported as errors # by providing a comma separated list of full class names. # The default is to exclude akka.actor.ActorKilledException. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_errors: akka.actor.ActorKilledException # Use this property to exclude specific http status codes from being reported as errors # by providing a comma separated list of status codes. # The default is to exclude 404s. If you want to override # this, you must provide any new value as an empty list is ignored. ignore_status_codes: 404 # Transaction Events are used for Histograms and Percentiles. Unaggregated data is collected # for each web transaction and sent to the server on harvest. transaction_events: # Set to false to disable transaction events. # Default is true. enabled: true # Events are collected up to the configured amount. Afterwards, events are sampled to # maintain an even distribution across the harvest cycle. # Default is 2000. Setting to 0 will disable. max_samples_stored: 2000 # Distributed tracing lets you see the path that a request takes through your distributed system. # Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition # guide before you enable this feature: https://docs.newrelic.com/docs/apm/distributed-tracing/getting-started/transition-guide-distributed-tracing # Default is false. distributed_tracing: enabled: false # Cross Application Tracing adds request and response headers to # external calls using supported HTTP libraries to provide better # performance data when calling applications monitored by other New Relic Agents. cross_application_tracer: # Set to false to disable cross application tracing. # Default is true. enabled: true # Thread profiler measures wall clock time, CPU time, and method call counts # in your application's threads as they run. # This feature is not available to Lite accounts and is automatically disabled. thread_profiler: # Set to false to disable the thread profiler. # Default is true. enabled: true # New Relic Real User Monitoring gives you insight into the performance real users are # experiencing with your website. This is accomplished by measuring the time it takes for # your users' browsers to download and render your web pages by injecting a small amount # of JavaScript code into the header and footer of each page. browser_monitoring: # By default the agent automatically inserts API calls in compiled JSPs to # inject the monitoring JavaScript into web pages. Not all rendering engines are supported. # See https://docs.newrelic.com/docs/agents/java-agent/instrumentation/new-relic-browser-java-agent#manual_instrumentation # for instructions to add these manually to your pages. # Set this attribute to false to turn off this behavior. auto_instrument: true class_transformer: # This instrumentation reports the name of the user principal returned from # HttpServletRequest.getUserPrincipal() when servlets and filters are invoked. com.newrelic.instrumentation.servlet-user: enabled: false com.newrelic.instrumentation.spring-aop-2: enabled: false # This instrumentation reports metrics for resultset operations. com.newrelic.instrumentation.jdbc-resultset: enabled: false # Classes loaded by classloaders in this list will not be instrumented. # This is a useful optimization for runtimes which use classloaders to # load dynamic classes which the agent would not instrument. classloader_excludes: groovy.lang.GroovyClassLoader$InnerLoader, org.codehaus.groovy.runtime.callsite.CallSiteClassLoader, com.collaxa.cube.engine.deployment.BPELClassLoader, org.springframework.data.convert.ClassGeneratingEntityInstantiator$ObjectInstantiatorClassGenerator, org.mvel2.optimizers.impl.asm.ASMAccessorOptimizer$ContextClassLoader, gw.internal.gosu.compiler.SingleServingGosuClassLoader, # Real-time profiling using Java Flight Recorder (JFR). # This feature reports dimensional metrics to the ingest endpoint configured by # metric_ingest_uri and events to the ingest endpoint configured by event_ingest_uri. # Both ingest endpoints default to US production but they will be automatically set to EU # production when using an EU license key. Other ingest endpoints can be configured manually. # Requires a JVM that provides the JFR library. jfr: # Set to true to enable Real-time profiling with JFR. # Default is false. enabled: false # Set to true to enable audit logging which will display all JFR metrics and events in each harvest batch. # Audit logging is extremely verbose and should only be used for troubleshooting purposes. # Default is false. audit_logging: false # User-configurable custom labels for this agent. Labels are name-value pairs. # There is a maximum of 64 labels per agent. Names and values are limited to 255 characters. # Names and values may not contain colons (:) or semicolons (;). labels: # An example label #label_name: label_value # Application Environments # ------------------------------------------ # Environment specific settings are in this section. # You can use the environment to override the default settings. # For example, to change the app_name setting. # Use -Dnewrelic.environment=<environment> on the Java startup command line # to set the environment. # The default environment is production. # NOTE if your application has other named environments, you should # provide configuration settings for these environments here. development: <<: *default_settings app_name: My Application (Development) test: <<: *default_settings app_name: My Application (Test) production: <<: *default_settings staging: <<: *default_settings app_name: My Application (Staging) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.04243,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> config file template",
        "sections": "<em>Java</em> <em>agent</em> config file template",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ": # By default the <em>agent</em> automatically inserts API calls in compiled JSPs to # inject the monitoring <em>Java</em>Script into web pages. Not all rendering engines are supported. # See https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>java</em>-<em>agent</em>&#x2F;<em>instrumentation</em>&#x2F;new-relic-browser-<em>java</em>-<em>agent</em>#manual_<em>instrumentation</em>"
      },
      "id": "603eb738e7b9d242542a0815"
    }
  ],
  "/docs/agents/java-agent/instrumentation/monitor-deployments-java-agent": [
    {
      "sections": [
        "Java agent: Instrument Kafka message queues",
        "Tip",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Important",
        "Enable Kafka distributed traces",
        "1. Enable distributed tracing in the config file",
        "2. Instrument the Kafka producer",
        "3. Instrument the Kafka consumer"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "05644cd866713698034d5419961a40af31d06b90",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues/",
      "published_at": "2021-10-18T05:42:58Z",
      "updated_at": "2021-08-21T03:31:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName Copy For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate Copy Tip For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. Important The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Copy Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Copy Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Copy Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: com.newrelic.instrumentation.kafka-clients-spans-0.11.0.0: enabled: true Copy 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } Copy 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key or under the W3C's traceparent and tracestate keys. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec) { // create a distributed trace headers map Headers dtHeaders = ConcurrentHashMapHeaders.build(HeaderType.MESSAGE); // Iterate through each record header and insert the trace headers into the dtHeaders map for (Header header : rec.headers()) { String headerValue = new String(header.value(), StandardCharsets.UTF_8); // using the newrelic key if (header.key().equals(\"newrelic\")) { dtHeaders.addHeader(\"newrelic\", headerValue); } // or using the W3C keys if (header.key().equals(\"traceparent\")) { dtHeaders.addHeader(\"traceparent\", headerValue); } if (header.key().equals(\"tracestate\")) { dtHeaders.addHeader(\"tracestate\", headerValue); } } // Accept distributed tracing headers to link this request to the originating request NewRelic.getAgent().getTransaction().acceptDistributedTraceHeaders(TransportType.Kafka, dtHeaders); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.28056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "sections": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka <em>instrumentation</em> is available in <em>Java</em> <em>agent</em> versions 4.12.0 or higher. For supported Kafka client versions, see <em>Java</em> compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View"
      },
      "id": "603ebc2464441f7ce84e8885"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.19462,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> custom"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Instrument browser monitoring with Java agent API",
        "Use Java agent API",
        "Disable auto-instrumentation on all pages",
        "Disable auto-instrumentation only on specific pages",
        "JSP manual instrumentation",
        "Raw HTML manual instrumentation",
        "Thymeleaf 2.1 or higher manual instrumentation",
        "ColdFusion CFML page manual instrumentation",
        "Java Server Faces (JSF) frameworks",
        "Play Groovy template manual instrumentation",
        "Play 2.2 or higher Scala template manual instrumentation",
        "Play 2.1 Scala template manual instrumentation",
        "Apache Velocity Tools manual instrumentation",
        "Apache Velocity manual instrumentation",
        "When the JSP engine compiles a JSP",
        "After the agent connects to the server",
        "When New Relic invokes the JSP",
        "When the agent calls the header and footer API"
      ],
      "title": "Instrument browser monitoring with Java agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "09af4a22935b0d48ad5702f331d61a14936e469b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/instrument-browser-monitoring-java-agent-api/",
      "published_at": "2021-10-18T05:41:55Z",
      "updated_at": "2021-07-09T02:00:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring gives you visibility into how your users are interacting with your Java application by using a JavaScript snippet (or \"agent\") to instrument your app's webpages. To install the browser agent via the UI, follow the procedures to install the browser agent. For example, you can: Enable an APM-monitored app. Enable with the copy/paste method. Enable by using the REST API. You can also manually instrument your webpages by using the Java agent API, as explained in this document. Use Java agent API If your framework does not allow you to enable browser monitoring from our UI, with the copy/paste method, or by using our REST API, you can manually instrument monitoring for your webpages. To do this, use our Java agent API. Make sure you are using the latest Java agent version. Disable auto-instrumentation. Disable auto-instrumentation on all pages Set the auto_instrument flag under browser_monitoring to false in your newrelic.yml. browser_monitoring: auto_instrument: false Copy Restart your application. Flush the app server's work cache. Flushing the work cache forces the app server to recompile JSPs, which is when auto-instrumentation occurs. Disable auto-instrumentation only on specific pages Use the disabled_auto_pages flag under the browser_monitoring stanza. For example, to disable auto-instrumentation on testpage_1.jsp and testpage_2.jsp, use the following: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy Access the Java agent API class by adding newrelic-api.jar to your application class path. Add the appropriate method to start time tracking, for example: com.newrelic.api.agent.NewRelic.getBrowserTimingHeader(). Add the appropriate method to stop time tracking, for example: com.newrelic.api.agent.NewRelic.getBrowserTimingFooter(). Find the appropriate methods based on the framework you are using: JSP manual instrumentation Insert the header as close to the top of <head> tag as possible but after the meta tags. Insert the footer before the </body> tag. <!DOCTYPE html> <html> <head><title>EXAMPLE</title> <meta charset=\"utf-8\"> <meta name=\"description\" content=\"Example header and footer call\">; <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> </head> <body> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingFooter() %> </body> </html> Copy Raw HTML manual instrumentation To manually instrument using raw HTML, include page load timing code in the HTTP response. Thymeleaf 2.1 or higher manual instrumentation <head> ... <div th:remove=\"tag\" th:utext=\"${T(com.newrelic.api.agent.NewRelic).getBrowserTimingHeader()}\"></div> </head> <body> ... <div th:utext=\"${T(com.newrelic.api.agent.NewRelic).getBrowserTimingFooter()}\"></div> </body> Copy ColdFusion CFML page manual instrumentation <cfobject type=\"Java\" class=\"com.newrelic.api.agent.NewRelic\" name=\"newRelic\"/> <cfset header = newRelic.getBrowserTimingHeader() /> <cfoutput>#header#</cfoutput> ... ... <cfset footer = newRelic.getBrowserTimingFooter() /> <cfoutput>#footer#</cfoutput> Copy Java Server Faces (JSF) frameworks Manual instrumentation is not available with JSF. To insert the Browser JavaScript snippet into your app's webpages, use the copy/paste method. Play Groovy template manual instrumentation ${com.newrelic.api.agent.NewRelic.getBrowserTimingHeader().raw()} ... ... ${com.newrelic.api.agent.NewRelic.getBrowserTimingFooter().raw()} Copy Play 2.2 or higher Scala template manual instrumentation Add the following to build.sbt, substituting the latest agent version for 3.x.x: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"3.x.x\" Copy In main.scala.html, add the following: @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingHeader()) ... ... @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingFooter()) Copy Play 2.1 Scala template manual instrumentation Add the following to Build.scala, substituting the lastest agent version for 2.x.x: appDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"2.x.x\" Copy In main.scala.html, add the following: @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingHeader()) ... ... @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingFooter())**Manual instrumentation with Apache Velocity Template Language (VTL)** Copy Apache Velocity Tools manual instrumentation If you are using Velocity Tools, define a NewRelic tool in toolbox.xml: <toolbox> <tool> <key>NewRelic</key> <scope>application</scope> <class>com.newrelic.api.agent.NewRelic</class> </tool> </toolbox> Copy Call the NewRelic API in your velocity template: $NewRelic.getBrowserTimingHeader() ... ... $NewRelic.getBrowserTimingFooter() Copy Apache Velocity manual instrumentation To ensure that all of your browser page views are not grouped under a single /velocity transaction (and to avoid metric grouping issues), disable your enable_auto_transaction_naming setting in your newrelic.yml file: enable_auto_transaction_naming: false Copy Add newrelic-api.jar to the classpath of Tomcat, typically in .../tomcat/bin/setenv.sh: CLASSPATH=$CLASSPATH:/opt/newrelic/newrelic-api.jar Copy OR Add the reference to this jar file to the end of an existing CLASSPATH=... line within that file. In each app, find WEB-INF/tools.xml and add the following tag: <toolbox scope=\"application\"> <tool class=\"com.newrelic.api.agent.NewRelic\" key=\"NewRelic\" /> </toolbox> Copy If a <toolbox scope=\"application\"> tag already exists, put the <tool ... /> within the tag. In each app, edit the Velocity template that the other pages in the application use. Add this tag within the <head> stanza before any <link> and <script> declarations and after any meta tags: $NewRelic.getBrowserTimingHeader() Copy Add this tag within the <body> stanza as the line right before the </body> tag, at the very bottom of the body: $NewRelic.getBrowserTimingFooter() Copy Restart the Tomcat server: If you are using Linux/Unix, add the following command line to the Users/Tomcat/bin directory: ./shutdown.sh ./startup.sh Copy If you are using Windows, go to your Users/Tomcat/bin directory, and add the following command line: % shutdown.bat % startup.bat Copy Check the log file to verify that the agent is instrumenting correctly. Set the log_level setting in newrelic.yml to log_level: finer and check for the following messages: When the JSP engine compiles a JSP May 17, 2011 9:33:18 AM NewRelic FINE: Compiling JSP: /jsp/header.jsp May 17, 2011 9:33:18 AM NewRelic FINE: Injecting browser timing header into: /jsp/header.jsp May 17, 2011 9:33:36 AM NewRelic FINE: Compiling JSP: /jsp/footer.jsp May 17, 2011 9:33:36 AM NewRelic FINE: Injecting browser timing footer into: /jsp/footer.jsp Copy After the agent connects to the server The JavaScript snippet is not inserted into the HTML response until after the agent connects to the server. May 17, 2011 9:43:21 AM NewRelic INFO: Real user monitoring is enabled with auto instrumentation Copy When New Relic invokes the JSP May 17, 2011 9:43:23 AM NewRelic FINER: Injecting browser timing header in a JSP. Content type is text/html May 17, 2011 9:43:23 AM NewRelic FINER: Injecting browser timing footer in a JSP. Content type is text/html Copy When the agent calls the header and footer API May 17, 2011 9:43:23 AM NewRelic FINEST: Got browser timing header in NewRelic API: <script>var NREUMQ=[];NREUMQ.push([\"mark\",\"firstbyte\",new Date().getTime()]);(function(){var d=document;var e=d.createElement(\"script\");e.type=\"text/javascript\";e.async=true;e.src=\"https://d7p9czrvs14ne.cloudfront.net/11/eum/rum.js\";var s=d.getElementsByTagName(\"script\")[0];s.parentNode.insertBefore(e,s);})();</script> May 17, 2011 9:43:23 AM NewRelic FINEST: Got browser timing footer in NewRelic API: <script type=\"text/javascript\" charset=\"utf-8\">NREUMQ.push([\"nrf2\",\"staging-beacon-1.newrelic.com\",\"8512b4d93f\",7449,\"M1RTYksFDEYDUxdcDgoeZERQSwhGEmQGRhVL\",0,413])</script> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.46293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Instrument</em> browser monitoring with <em>Java</em> <em>agent</em> API",
        "sections": "<em>Instrument</em> browser monitoring with <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ", with the copy&#x2F;paste method, or by using our REST API, you can manually <em>instrument</em> monitoring for your webpages. To do this, use our <em>Java</em> <em>agent</em> API. Make sure you are using the latest <em>Java</em> <em>agent</em> version. Disable auto-<em>instrumentation</em>. Disable auto-<em>instrumentation</em> on all pages Set the auto_<em>instrument</em> flag"
      },
      "id": "6043cd9564441f866e378ec8"
    }
  ],
  "/docs/agents/java-agent/instrumentation/transaction-naming-protocol": [
    {
      "sections": [
        "Java agent: Instrument Kafka message queues",
        "Tip",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Important",
        "Enable Kafka distributed traces",
        "1. Enable distributed tracing in the config file",
        "2. Instrument the Kafka producer",
        "3. Instrument the Kafka consumer"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "05644cd866713698034d5419961a40af31d06b90",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues/",
      "published_at": "2021-10-18T05:42:58Z",
      "updated_at": "2021-08-21T03:31:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName Copy For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate Copy Tip For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. Important The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Copy Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Copy Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Copy Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: com.newrelic.instrumentation.kafka-clients-spans-0.11.0.0: enabled: true Copy 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } Copy 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key or under the W3C's traceparent and tracestate keys. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec) { // create a distributed trace headers map Headers dtHeaders = ConcurrentHashMapHeaders.build(HeaderType.MESSAGE); // Iterate through each record header and insert the trace headers into the dtHeaders map for (Header header : rec.headers()) { String headerValue = new String(header.value(), StandardCharsets.UTF_8); // using the newrelic key if (header.key().equals(\"newrelic\")) { dtHeaders.addHeader(\"newrelic\", headerValue); } // or using the W3C keys if (header.key().equals(\"traceparent\")) { dtHeaders.addHeader(\"traceparent\", headerValue); } if (header.key().equals(\"tracestate\")) { dtHeaders.addHeader(\"tracestate\", headerValue); } } // Accept distributed tracing headers to link this request to the originating request NewRelic.getAgent().getTransaction().acceptDistributedTraceHeaders(TransportType.Kafka, dtHeaders); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.28056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "sections": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka <em>instrumentation</em> is available in <em>Java</em> <em>agent</em> versions 4.12.0 or higher. For supported Kafka client versions, see <em>Java</em> compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View"
      },
      "id": "603ebc2464441f7ce84e8885"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.19462,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> custom"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Instrument browser monitoring with Java agent API",
        "Use Java agent API",
        "Disable auto-instrumentation on all pages",
        "Disable auto-instrumentation only on specific pages",
        "JSP manual instrumentation",
        "Raw HTML manual instrumentation",
        "Thymeleaf 2.1 or higher manual instrumentation",
        "ColdFusion CFML page manual instrumentation",
        "Java Server Faces (JSF) frameworks",
        "Play Groovy template manual instrumentation",
        "Play 2.2 or higher Scala template manual instrumentation",
        "Play 2.1 Scala template manual instrumentation",
        "Apache Velocity Tools manual instrumentation",
        "Apache Velocity manual instrumentation",
        "When the JSP engine compiles a JSP",
        "After the agent connects to the server",
        "When New Relic invokes the JSP",
        "When the agent calls the header and footer API"
      ],
      "title": "Instrument browser monitoring with Java agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "09af4a22935b0d48ad5702f331d61a14936e469b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/instrument-browser-monitoring-java-agent-api/",
      "published_at": "2021-10-18T05:41:55Z",
      "updated_at": "2021-07-09T02:00:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring gives you visibility into how your users are interacting with your Java application by using a JavaScript snippet (or \"agent\") to instrument your app's webpages. To install the browser agent via the UI, follow the procedures to install the browser agent. For example, you can: Enable an APM-monitored app. Enable with the copy/paste method. Enable by using the REST API. You can also manually instrument your webpages by using the Java agent API, as explained in this document. Use Java agent API If your framework does not allow you to enable browser monitoring from our UI, with the copy/paste method, or by using our REST API, you can manually instrument monitoring for your webpages. To do this, use our Java agent API. Make sure you are using the latest Java agent version. Disable auto-instrumentation. Disable auto-instrumentation on all pages Set the auto_instrument flag under browser_monitoring to false in your newrelic.yml. browser_monitoring: auto_instrument: false Copy Restart your application. Flush the app server's work cache. Flushing the work cache forces the app server to recompile JSPs, which is when auto-instrumentation occurs. Disable auto-instrumentation only on specific pages Use the disabled_auto_pages flag under the browser_monitoring stanza. For example, to disable auto-instrumentation on testpage_1.jsp and testpage_2.jsp, use the following: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy Access the Java agent API class by adding newrelic-api.jar to your application class path. Add the appropriate method to start time tracking, for example: com.newrelic.api.agent.NewRelic.getBrowserTimingHeader(). Add the appropriate method to stop time tracking, for example: com.newrelic.api.agent.NewRelic.getBrowserTimingFooter(). Find the appropriate methods based on the framework you are using: JSP manual instrumentation Insert the header as close to the top of <head> tag as possible but after the meta tags. Insert the footer before the </body> tag. <!DOCTYPE html> <html> <head><title>EXAMPLE</title> <meta charset=\"utf-8\"> <meta name=\"description\" content=\"Example header and footer call\">; <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> </head> <body> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingFooter() %> </body> </html> Copy Raw HTML manual instrumentation To manually instrument using raw HTML, include page load timing code in the HTTP response. Thymeleaf 2.1 or higher manual instrumentation <head> ... <div th:remove=\"tag\" th:utext=\"${T(com.newrelic.api.agent.NewRelic).getBrowserTimingHeader()}\"></div> </head> <body> ... <div th:utext=\"${T(com.newrelic.api.agent.NewRelic).getBrowserTimingFooter()}\"></div> </body> Copy ColdFusion CFML page manual instrumentation <cfobject type=\"Java\" class=\"com.newrelic.api.agent.NewRelic\" name=\"newRelic\"/> <cfset header = newRelic.getBrowserTimingHeader() /> <cfoutput>#header#</cfoutput> ... ... <cfset footer = newRelic.getBrowserTimingFooter() /> <cfoutput>#footer#</cfoutput> Copy Java Server Faces (JSF) frameworks Manual instrumentation is not available with JSF. To insert the Browser JavaScript snippet into your app's webpages, use the copy/paste method. Play Groovy template manual instrumentation ${com.newrelic.api.agent.NewRelic.getBrowserTimingHeader().raw()} ... ... ${com.newrelic.api.agent.NewRelic.getBrowserTimingFooter().raw()} Copy Play 2.2 or higher Scala template manual instrumentation Add the following to build.sbt, substituting the latest agent version for 3.x.x: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"3.x.x\" Copy In main.scala.html, add the following: @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingHeader()) ... ... @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingFooter()) Copy Play 2.1 Scala template manual instrumentation Add the following to Build.scala, substituting the lastest agent version for 2.x.x: appDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"2.x.x\" Copy In main.scala.html, add the following: @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingHeader()) ... ... @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingFooter())**Manual instrumentation with Apache Velocity Template Language (VTL)** Copy Apache Velocity Tools manual instrumentation If you are using Velocity Tools, define a NewRelic tool in toolbox.xml: <toolbox> <tool> <key>NewRelic</key> <scope>application</scope> <class>com.newrelic.api.agent.NewRelic</class> </tool> </toolbox> Copy Call the NewRelic API in your velocity template: $NewRelic.getBrowserTimingHeader() ... ... $NewRelic.getBrowserTimingFooter() Copy Apache Velocity manual instrumentation To ensure that all of your browser page views are not grouped under a single /velocity transaction (and to avoid metric grouping issues), disable your enable_auto_transaction_naming setting in your newrelic.yml file: enable_auto_transaction_naming: false Copy Add newrelic-api.jar to the classpath of Tomcat, typically in .../tomcat/bin/setenv.sh: CLASSPATH=$CLASSPATH:/opt/newrelic/newrelic-api.jar Copy OR Add the reference to this jar file to the end of an existing CLASSPATH=... line within that file. In each app, find WEB-INF/tools.xml and add the following tag: <toolbox scope=\"application\"> <tool class=\"com.newrelic.api.agent.NewRelic\" key=\"NewRelic\" /> </toolbox> Copy If a <toolbox scope=\"application\"> tag already exists, put the <tool ... /> within the tag. In each app, edit the Velocity template that the other pages in the application use. Add this tag within the <head> stanza before any <link> and <script> declarations and after any meta tags: $NewRelic.getBrowserTimingHeader() Copy Add this tag within the <body> stanza as the line right before the </body> tag, at the very bottom of the body: $NewRelic.getBrowserTimingFooter() Copy Restart the Tomcat server: If you are using Linux/Unix, add the following command line to the Users/Tomcat/bin directory: ./shutdown.sh ./startup.sh Copy If you are using Windows, go to your Users/Tomcat/bin directory, and add the following command line: % shutdown.bat % startup.bat Copy Check the log file to verify that the agent is instrumenting correctly. Set the log_level setting in newrelic.yml to log_level: finer and check for the following messages: When the JSP engine compiles a JSP May 17, 2011 9:33:18 AM NewRelic FINE: Compiling JSP: /jsp/header.jsp May 17, 2011 9:33:18 AM NewRelic FINE: Injecting browser timing header into: /jsp/header.jsp May 17, 2011 9:33:36 AM NewRelic FINE: Compiling JSP: /jsp/footer.jsp May 17, 2011 9:33:36 AM NewRelic FINE: Injecting browser timing footer into: /jsp/footer.jsp Copy After the agent connects to the server The JavaScript snippet is not inserted into the HTML response until after the agent connects to the server. May 17, 2011 9:43:21 AM NewRelic INFO: Real user monitoring is enabled with auto instrumentation Copy When New Relic invokes the JSP May 17, 2011 9:43:23 AM NewRelic FINER: Injecting browser timing header in a JSP. Content type is text/html May 17, 2011 9:43:23 AM NewRelic FINER: Injecting browser timing footer in a JSP. Content type is text/html Copy When the agent calls the header and footer API May 17, 2011 9:43:23 AM NewRelic FINEST: Got browser timing header in NewRelic API: <script>var NREUMQ=[];NREUMQ.push([\"mark\",\"firstbyte\",new Date().getTime()]);(function(){var d=document;var e=d.createElement(\"script\");e.type=\"text/javascript\";e.async=true;e.src=\"https://d7p9czrvs14ne.cloudfront.net/11/eum/rum.js\";var s=d.getElementsByTagName(\"script\")[0];s.parentNode.insertBefore(e,s);})();</script> May 17, 2011 9:43:23 AM NewRelic FINEST: Got browser timing footer in NewRelic API: <script type=\"text/javascript\" charset=\"utf-8\">NREUMQ.push([\"nrf2\",\"staging-beacon-1.newrelic.com\",\"8512b4d93f\",7449,\"M1RTYksFDEYDUxdcDgoeZERQSwhGEmQGRhVL\",0,413])</script> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.46293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Instrument</em> browser monitoring with <em>Java</em> <em>agent</em> API",
        "sections": "<em>Instrument</em> browser monitoring with <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ", with the copy&#x2F;paste method, or by using our REST API, you can manually <em>instrument</em> monitoring for your webpages. To do this, use our <em>Java</em> <em>agent</em> API. Make sure you are using the latest <em>Java</em> <em>agent</em> version. Disable auto-<em>instrumentation</em>. Disable auto-<em>instrumentation</em> on all pages Set the auto_<em>instrument</em> flag"
      },
      "id": "6043cd9564441f866e378ec8"
    }
  ],
  "/docs/agents/java-agent/instrumentation/use-rabbitmq-or-jms-message-queues": [
    {
      "sections": [
        "Java agent: Instrument Kafka message queues",
        "Tip",
        "View Kafka metrics",
        "Enable Kafka event collection",
        "Important",
        "Enable Kafka distributed traces",
        "1. Enable distributed tracing in the config file",
        "2. Instrument the Kafka producer",
        "3. Instrument the Kafka consumer"
      ],
      "title": "Java agent: Instrument Kafka message queues",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "05644cd866713698034d5419961a40af31d06b90",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues/",
      "published_at": "2021-10-18T05:42:58Z",
      "updated_at": "2021-08-21T03:31:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent automatically collects data from Kafka's Java clients library. Because Kafka is a high-performance messaging system that generates a lot of data, you can customize the agent for your app's specific throughput and use cases. This document explains how to collect and view three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka instrumentation is available in Java agent versions 4.12.0 or higher. For supported Kafka client versions, see Java compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View Kafka metrics After installation, the agent automatically reports rich Kafka metrics with information about messaging rates, latency, lag, and more. The Java agent collects all Kafka consumer and producer metrics (but not connect or stream metrics). To view these metrics, create a custom dashboard: Go to the New Relic metric explorer. Use the metric explorer to locate your metrics. You can find Kafka metrics in this metric folder: MessageBroker/Kafka/Internal/KafkaMetricName Copy For example, the request-rate metric is located at: MessageBroker/Kafka/Internal/consumer-metrics/request-rate Copy Tip For a full list of Kafka consumer and producer metrics, see the Kafka documentation. Add the metrics you want to monitor to a dashboard by clicking Add to dashboard. Enable Kafka event collection You can configure the agent to collect event data instead of metric timeslice data (for the difference between metric timeslice and event data, see data collection). This allows you to use NRQL to filter and facet the default Kafka metrics. When enabled, the agent collects one Kafka event every 30 seconds. This event contains all of the the data from Kafka consumer and produce metrics captured since the previous event. Important The agent records up to 2000 events per harvest cycle, though you can change this value with max_samples_stored. Kafka event data is included in this pool. If you use the recordCustomEvent() API call to send custom events to New Relic and you send more than 2000 events, the agent will discard some Kafka or custom events. To enable Kafka event collection: Add the kafka.metrics.as_events.enabled element to your newrelic.yml config file: kafka.metrics.as_events.enabled: true Copy Restart your JVM. Use the event explorer to view your Kafka events, located in the KafkaMetrics event type. Or, use NRQL to query your events directly. For example: SELECT average('producer-metrics.record-send-rate') from KafkaMetrics SINCE 30 minutes ago timeseries Copy Enable Kafka distributed traces The Java agent can also collect distributed traces from Kafka clients. Enabling traces doesn't affect the agent's normal operations: it will still report metric or event data from Kafka. Impacts and requirements to consider before enabling: The instrumentation adds a 150 to 200 byte payload to message headers. If your Kafka messages are very small, traces can add significant processing and storage overhead. This additional payload size could cause Kafka to drop messages if they exceed your Kafka messaging size limit. For this reason, we recommend testing out Kafka distributed traces in a dev environment before enabling them in production. Distributed tracing is only available for Kafka client versions 0.11.0.0 or higher. If you have not enabled distributed tracing for your app before, read the Transition guide before enabling. To propagate W3C trace context via Kafka message headers, see the distributed tracing API usage guide for details on APIs that were released in Java agent 6.4.0. Note that adding additional headers to Kafka messages will further increase the payload size. To see these APIs in action, see Using Java agent trace APIs with Kafka. The complete process of enabling this is below but at a high level it involves these basic steps: 1) enable tracing via the agent config, and 2) calling the Java agent API to instrument transactions on both the producer and consumer side. To collect distributed traces from Kafka: 1. Enable distributed tracing in the config file If you have not enabled distributed tracing for your app before, read the distributed tracing transition guide before you enable it. To enable Kafka distributed tracings, enable two settings in your newrelic.yml config file: Set the distributed_tracing element to true: distributed_tracing: enabled: true Copy Enable the Kafka-specific distributed tracing features by adding the following to your config file: class_transformer: com.newrelic.instrumentation.kafka-clients-spans-0.11.0.0: enabled: true Copy 2. Instrument the Kafka producer To instrument your Kafka producer, you'll need to start a transaction before any calls to Producer.send(ProducerRecord<K, V> record). To do this, add the Java agent @Trace(dispatcher = true) annotation to the method. For example: @Trace(dispatcher = true) public static void createAndSend(KafkaProducer<String, String> producer){ ProducerRecord<String, String> data = new ProducerRecord<String, String>(\"topic\", \"key\", \"value\"); producer.send(data); } Copy 3. Instrument the Kafka consumer To instrument your Kafka consumer, you'll need to start a transaction when the message is being processed. The agent stores the distributed tracing payload header under the newrelic key or under the W3C's traceparent and tracestate keys. Retrieve the header, then call the New Relic transaction API to accept the payload. For example: @Trace(dispatcher = true) private static void processMessage(ConsumerRecord<String, String> rec) { // create a distributed trace headers map Headers dtHeaders = ConcurrentHashMapHeaders.build(HeaderType.MESSAGE); // Iterate through each record header and insert the trace headers into the dtHeaders map for (Header header : rec.headers()) { String headerValue = new String(header.value(), StandardCharsets.UTF_8); // using the newrelic key if (header.key().equals(\"newrelic\")) { dtHeaders.addHeader(\"newrelic\", headerValue); } // or using the W3C keys if (header.key().equals(\"traceparent\")) { dtHeaders.addHeader(\"traceparent\", headerValue); } if (header.key().equals(\"tracestate\")) { dtHeaders.addHeader(\"tracestate\", headerValue); } } // Accept distributed tracing headers to link this request to the originating request NewRelic.getAgent().getTransaction().acceptDistributedTraceHeaders(TransportType.Kafka, dtHeaders); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.280556,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "sections": "<em>Java</em> <em>agent</em>: <em>Instrument</em> Kafka message queues",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " three types of Kafka data: Kafka metrics Kafka events Kafka distributed traces Kafka <em>instrumentation</em> is available in <em>Java</em> <em>agent</em> versions 4.12.0 or higher. For supported Kafka client versions, see <em>Java</em> compatibility and requirements. Tip For our Kafka integration, see Kafka monitoring integration. View"
      },
      "id": "603ebc2464441f7ce84e8885"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-18T03:45:04Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.194595,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> custom"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Instrument browser monitoring with Java agent API",
        "Use Java agent API",
        "Disable auto-instrumentation on all pages",
        "Disable auto-instrumentation only on specific pages",
        "JSP manual instrumentation",
        "Raw HTML manual instrumentation",
        "Thymeleaf 2.1 or higher manual instrumentation",
        "ColdFusion CFML page manual instrumentation",
        "Java Server Faces (JSF) frameworks",
        "Play Groovy template manual instrumentation",
        "Play 2.2 or higher Scala template manual instrumentation",
        "Play 2.1 Scala template manual instrumentation",
        "Apache Velocity Tools manual instrumentation",
        "Apache Velocity manual instrumentation",
        "When the JSP engine compiles a JSP",
        "After the agent connects to the server",
        "When New Relic invokes the JSP",
        "When the agent calls the header and footer API"
      ],
      "title": "Instrument browser monitoring with Java agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Instrumentation"
      ],
      "external_id": "09af4a22935b0d48ad5702f331d61a14936e469b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/instrumentation/instrument-browser-monitoring-java-agent-api/",
      "published_at": "2021-10-18T05:41:55Z",
      "updated_at": "2021-07-09T02:00:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring gives you visibility into how your users are interacting with your Java application by using a JavaScript snippet (or \"agent\") to instrument your app's webpages. To install the browser agent via the UI, follow the procedures to install the browser agent. For example, you can: Enable an APM-monitored app. Enable with the copy/paste method. Enable by using the REST API. You can also manually instrument your webpages by using the Java agent API, as explained in this document. Use Java agent API If your framework does not allow you to enable browser monitoring from our UI, with the copy/paste method, or by using our REST API, you can manually instrument monitoring for your webpages. To do this, use our Java agent API. Make sure you are using the latest Java agent version. Disable auto-instrumentation. Disable auto-instrumentation on all pages Set the auto_instrument flag under browser_monitoring to false in your newrelic.yml. browser_monitoring: auto_instrument: false Copy Restart your application. Flush the app server's work cache. Flushing the work cache forces the app server to recompile JSPs, which is when auto-instrumentation occurs. Disable auto-instrumentation only on specific pages Use the disabled_auto_pages flag under the browser_monitoring stanza. For example, to disable auto-instrumentation on testpage_1.jsp and testpage_2.jsp, use the following: browser_monitoring: disabled_auto_pages: /WEB-INF/jsp/testpage_1.jsp, /WEB-INF/jsp/testpage_2.jsp Copy Access the Java agent API class by adding newrelic-api.jar to your application class path. Add the appropriate method to start time tracking, for example: com.newrelic.api.agent.NewRelic.getBrowserTimingHeader(). Add the appropriate method to stop time tracking, for example: com.newrelic.api.agent.NewRelic.getBrowserTimingFooter(). Find the appropriate methods based on the framework you are using: JSP manual instrumentation Insert the header as close to the top of <head> tag as possible but after the meta tags. Insert the footer before the </body> tag. <!DOCTYPE html> <html> <head><title>EXAMPLE</title> <meta charset=\"utf-8\"> <meta name=\"description\" content=\"Example header and footer call\">; <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> </head> <body> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingFooter() %> </body> </html> Copy Raw HTML manual instrumentation To manually instrument using raw HTML, include page load timing code in the HTTP response. Thymeleaf 2.1 or higher manual instrumentation <head> ... <div th:remove=\"tag\" th:utext=\"${T(com.newrelic.api.agent.NewRelic).getBrowserTimingHeader()}\"></div> </head> <body> ... <div th:utext=\"${T(com.newrelic.api.agent.NewRelic).getBrowserTimingFooter()}\"></div> </body> Copy ColdFusion CFML page manual instrumentation <cfobject type=\"Java\" class=\"com.newrelic.api.agent.NewRelic\" name=\"newRelic\"/> <cfset header = newRelic.getBrowserTimingHeader() /> <cfoutput>#header#</cfoutput> ... ... <cfset footer = newRelic.getBrowserTimingFooter() /> <cfoutput>#footer#</cfoutput> Copy Java Server Faces (JSF) frameworks Manual instrumentation is not available with JSF. To insert the Browser JavaScript snippet into your app's webpages, use the copy/paste method. Play Groovy template manual instrumentation ${com.newrelic.api.agent.NewRelic.getBrowserTimingHeader().raw()} ... ... ${com.newrelic.api.agent.NewRelic.getBrowserTimingFooter().raw()} Copy Play 2.2 or higher Scala template manual instrumentation Add the following to build.sbt, substituting the latest agent version for 3.x.x: libraryDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"3.x.x\" Copy In main.scala.html, add the following: @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingHeader()) ... ... @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingFooter()) Copy Play 2.1 Scala template manual instrumentation Add the following to Build.scala, substituting the lastest agent version for 2.x.x: appDependencies += \"com.newrelic.agent.java\" % \"newrelic-api\" % \"2.x.x\" Copy In main.scala.html, add the following: @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingHeader()) ... ... @Html(com.newrelic.api.agent.NewRelic.getBrowserTimingFooter())**Manual instrumentation with Apache Velocity Template Language (VTL)** Copy Apache Velocity Tools manual instrumentation If you are using Velocity Tools, define a NewRelic tool in toolbox.xml: <toolbox> <tool> <key>NewRelic</key> <scope>application</scope> <class>com.newrelic.api.agent.NewRelic</class> </tool> </toolbox> Copy Call the NewRelic API in your velocity template: $NewRelic.getBrowserTimingHeader() ... ... $NewRelic.getBrowserTimingFooter() Copy Apache Velocity manual instrumentation To ensure that all of your browser page views are not grouped under a single /velocity transaction (and to avoid metric grouping issues), disable your enable_auto_transaction_naming setting in your newrelic.yml file: enable_auto_transaction_naming: false Copy Add newrelic-api.jar to the classpath of Tomcat, typically in .../tomcat/bin/setenv.sh: CLASSPATH=$CLASSPATH:/opt/newrelic/newrelic-api.jar Copy OR Add the reference to this jar file to the end of an existing CLASSPATH=... line within that file. In each app, find WEB-INF/tools.xml and add the following tag: <toolbox scope=\"application\"> <tool class=\"com.newrelic.api.agent.NewRelic\" key=\"NewRelic\" /> </toolbox> Copy If a <toolbox scope=\"application\"> tag already exists, put the <tool ... /> within the tag. In each app, edit the Velocity template that the other pages in the application use. Add this tag within the <head> stanza before any <link> and <script> declarations and after any meta tags: $NewRelic.getBrowserTimingHeader() Copy Add this tag within the <body> stanza as the line right before the </body> tag, at the very bottom of the body: $NewRelic.getBrowserTimingFooter() Copy Restart the Tomcat server: If you are using Linux/Unix, add the following command line to the Users/Tomcat/bin directory: ./shutdown.sh ./startup.sh Copy If you are using Windows, go to your Users/Tomcat/bin directory, and add the following command line: % shutdown.bat % startup.bat Copy Check the log file to verify that the agent is instrumenting correctly. Set the log_level setting in newrelic.yml to log_level: finer and check for the following messages: When the JSP engine compiles a JSP May 17, 2011 9:33:18 AM NewRelic FINE: Compiling JSP: /jsp/header.jsp May 17, 2011 9:33:18 AM NewRelic FINE: Injecting browser timing header into: /jsp/header.jsp May 17, 2011 9:33:36 AM NewRelic FINE: Compiling JSP: /jsp/footer.jsp May 17, 2011 9:33:36 AM NewRelic FINE: Injecting browser timing footer into: /jsp/footer.jsp Copy After the agent connects to the server The JavaScript snippet is not inserted into the HTML response until after the agent connects to the server. May 17, 2011 9:43:21 AM NewRelic INFO: Real user monitoring is enabled with auto instrumentation Copy When New Relic invokes the JSP May 17, 2011 9:43:23 AM NewRelic FINER: Injecting browser timing header in a JSP. Content type is text/html May 17, 2011 9:43:23 AM NewRelic FINER: Injecting browser timing footer in a JSP. Content type is text/html Copy When the agent calls the header and footer API May 17, 2011 9:43:23 AM NewRelic FINEST: Got browser timing header in NewRelic API: <script>var NREUMQ=[];NREUMQ.push([\"mark\",\"firstbyte\",new Date().getTime()]);(function(){var d=document;var e=d.createElement(\"script\");e.type=\"text/javascript\";e.async=true;e.src=\"https://d7p9czrvs14ne.cloudfront.net/11/eum/rum.js\";var s=d.getElementsByTagName(\"script\")[0];s.parentNode.insertBefore(e,s);})();</script> May 17, 2011 9:43:23 AM NewRelic FINEST: Got browser timing footer in NewRelic API: <script type=\"text/javascript\" charset=\"utf-8\">NREUMQ.push([\"nrf2\",\"staging-beacon-1.newrelic.com\",\"8512b4d93f\",7449,\"M1RTYksFDEYDUxdcDgoeZERQSwhGEmQGRhVL\",0,413])</script> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.46293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Instrument</em> browser monitoring with <em>Java</em> <em>agent</em> API",
        "sections": "<em>Instrument</em> browser monitoring with <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ", with the copy&#x2F;paste method, or by using our REST API, you can manually <em>instrument</em> monitoring for your webpages. To do this, use our <em>Java</em> <em>agent</em> API. Make sure you are using the latest <em>Java</em> <em>agent</em> version. Disable auto-<em>instrumentation</em>. Disable auto-<em>instrumentation</em> on all pages Set the auto_<em>instrument</em> flag"
      },
      "id": "6043cd9564441f866e378ec8"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/all-hosts-appear-localhost": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.6226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/application-server-jmx-setup": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62259,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/determine-permissions-requirements-java": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62259,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/error-bootstrapping-new-relic-java-agent": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62259,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/errors-starting-java-app-server": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62259,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/firewall-or-traffic-connectivity-failures": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.577835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/gather-troubleshooting-information-java": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.577835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.622574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.577835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/host-links-missing-java-apps-apm-summary": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.622574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.577835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/java-solr-data-does-not-appear": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.622574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.622574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/no-browser-data-appears-java": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62257,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/no-data-appears-java": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62257,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/no-log-file-java": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62257,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/no-stack-traces-java": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62257,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57781,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/resolve-metric-grouping-issues-java-apps": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57781,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.57781,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/update-java-config-legacy-agent-versions": [
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-10-18T02:28:01Z",
      "updated_at": "2021-09-14T07:18:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.62256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and Heroku",
        "sections": "<em>Java</em> <em>agent</em> and Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend Heroku with metrics from APM or browser monitoring. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for Heroku. Compatibility"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-10-18T02:46:44Z",
      "updated_at": "2021-09-14T04:41:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > APM. Get the New Relic Java agent. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find more add ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.577805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "sections": "<em>Java</em> <em>agent</em> with Scala on Heroku",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and Heroku. Compatibility and requirements"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-10-18T05:39:03Z",
      "updated_at": "2021-07-22T06:52:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where youre wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVMs life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Important The flamegraph feature is only compatible with the New Relic Java agent JFR service usage scenario. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your applications overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.29737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an applications deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where youre wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/agent-attributes": [
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-10-18T02:25:25Z",
      "updated_at": "2021-09-14T10:31:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the data explorer to start building a chart. Select the advanced (NRQL) mode to refine your query. In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.20026,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0 or higher Go"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.16272,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " transaction collects both metric timeslice and event <em>data</em>. Custom instrumentation for already instrumented transactions collects only metric timeslice <em>data</em>. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    },
    {
      "sections": [
        "Manage errors in APM: Collect, ignore, or mark as expected",
        "Collect errors not instrumented by default",
        "Ignore errors",
        "Tip",
        "Ignore errors using server-side configuration in the UI",
        "Ignore errors using agent configuration",
        "Expected errors (Java, Node.js, Python, Ruby, and .NET only)",
        "View errors in the UI"
      ],
      "title": "Manage errors in APM: Collect, ignore, or mark as expected",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ebd20f78d5084c48b1669ae33569da3f829fec6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/",
      "published_at": "2021-10-18T02:24:48Z",
      "updated_at": "2021-08-20T14:59:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM agents automatically report error data for supported frameworks. To optimize error reporting and alerting, you can further manage errors in order to: Catch errors that we don't instrument by default. Ignore errors that you don't want reported at all. Filter out noise from expected errors so you can focus on the errors that are affecting performance. (Java, Ruby, Node, Python, and .NET agents only) Collect errors not instrumented by default APM agents include API calls to report (or \"notice\") errors. These are useful when APM doesn't instrument your framework automatically or when there are particular errors that aren't caught for your supported framework. To learn how to get an APM agent to report an error, see the agent-specific API documentation: C SDK: newrelic_notice_error() Go: NoticeError() Java: NoticeError() .NET: NoticeError() Node.js: noticeError() PHP: newrelic_notice_error() Python: notice_error() Ruby: notice_error() Ignore errors Sometimes the APM agent instruments an error that you don't want reported, such as errors that contain sensitive information like user login errors. If you don't want an error to report to the our collector, you can ignore the error, and the APM agent discards the error entirely. Tip For Java, Ruby, Node.js, and Python: If you want to report errors to APM but don't want those errors to affect your Apdex or error rate, mark them as expected instead. There are two ways to ignore errors: through the agent configuration or through server-side configuration in the UI: Ignore errors using server-side configuration in the UI This option depends on whether the agent supports server-side configuration. If it is not already enabled, enable server-side configuration. Go to the Server-side configuration menu for the application that has errors that you want to ignore. Under Error collection, look for Ignore from error collection. Add the HTTP code or the Error class for the errors that you want to ignore. Select Save server-side configuration. Ignore errors using agent configuration To ignore an error using the agent configuration, see the configuration documentation for your agent: C SDK: Not available. For more information, see the C SDK errors example on GitHub. Go: ErrorCollector.IgnoreStatusCodes. Java: error_collector.ignore_classes, error_collector.ignore_classes.message, or error_collector.ignore_status_codes. For additional information, see Java agent error configuration. .NET: ignoreErrors or ignoreStatusCodes. Node.js: ignore_status_codes, ignore_classes, or ignore_messages. PHP: error_collector.ignore_exceptions or error_collector.ignore_errors. Python: error_collector.ignore_classes or error_collector.ignore_status_codes. Ruby: error_collector.ignore_errors. Expected errors (Java, Node.js, Python, Ruby, and .NET only) For the below APM agents, you can mark errors as expected. These errors will be reported to APM and available for viewing, but they won't affect the Apdex or error rate (or alert conditions based on error rate). To configure errors as expected, see the agent-specific documentation: Java Ruby Node.js .NET Python If expected errors are enabled, APM's Error analytics page will, by default, have a filter applied with the error.expected attribute set to false, meaning expected errors will not be displayed. To view expected errors, turn off the error.expected filter. To view expected errors, query your data: To view charts of expected errors, create a query for the error.expected attribute. To create alert conditions for NRQL queries, use the error.expected attribute. View errors in the UI Among other places, error data appears in these parts of the UI: Error analytics page: shows in-depth charts and visual analysis of errors. APM Overview page: shows a high-level view of your application, which includes errors. Alert conditions: can be based on error rate. The transactionError event: contains underlying error data, which can be used in NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.18086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "sections": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>APM</em> <em>agents</em> automatically report error <em>data</em> for supported frameworks. To optimize error reporting and alerting, you can further <em>manage</em> errors in order to: Catch errors that we don&#x27;t instrument by default. Ignore errors that you don&#x27;t want reported at all. Filter out noise from expected errors so you"
      },
      "id": "6043f7d6196a67c1d4960f72"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/collect-custom-metrics": [
    {
      "sections": [
        "Glossary",
        "account dropdown",
        "account switcher",
        "administrator",
        "agent",
        "agent API",
        "aggregated metrics",
        "aggregation delay",
        "aggregation function",
        "aggregation method",
        "aggregation_timer",
        "aggregation window",
        "alert",
        "alert condition",
        "alert evaluation",
        "alert policy",
        "apdex",
        "apdex_f",
        "apdex_t",
        "API (application programming interface)",
        "APM",
        "application",
        "application ID",
        "application name",
        "Applied Intelligence (AI)",
        "attribute",
        "availability monitoring",
        "browser",
        "Browser monitoring",
        "background external",
        "child account",
        "cloud-based integration",
        "collector",
        "Command line interface (CLI)",
        "compute unit (CU)",
        "condition_id",
        "CPM (calls per minute)",
        "CPU burn",
        "custom attribute",
        "custom dashboard",
        "custom event",
        "custom instrumentation",
        "custom metric",
        "data collector",
        "data explorer",
        "degradation period",
        "dimensional metric",
        "Docker",
        "downtime",
        "entity",
        "event",
        "expected error",
        "exporter",
        "Flex",
        "framework",
        "harvest cycle",
        "health status indicator",
        "host",
        "host ID",
        "ignored error",
        "incident",
        "Infrastructure monitoring",
        "Insights",
        "instance ID",
        "instrumentation",
        "integration",
        "interaction",
        "interaction trace",
        "inventory data",
        "key transaction",
        "launcher",
        "log",
        "Log monitoring",
        "Logs",
        "Logs in context",
        "master account",
        "metric",
        "metric timeslice",
        "metric grouping issue",
        "minion",
        "Mobile monitoring",
        "monitor",
        "NerdGraph",
        "Nerdlet",
        "Nerdpack",
        "New Relic Edge with Infinite Tracing",
        "New Relic One",
        "New Relic One catalog",
        "NRQL (New Relic query language)",
        "non-web transaction",
        "notification",
        "notification channel",
        "on-host integration",
        "owner",
        "page load timing",
        "parameter",
        "parent account",
        "permalink",
        "pinger",
        "Plugins",
        "polling interval (AWS)",
        "PPM (pages per minute)",
        "private location",
        "recovery period",
        "response time",
        "restricted user",
        "rollup",
        "root span",
        "RPM",
        "RUM (real user monitoring)",
        "runbook",
        "SAML (Security Assertion Markup Language)",
        "Selenium",
        "service",
        "signal",
        "signal filter",
        "span",
        "SSL certificate",
        "SSO (single sign on)",
        "streaming algorithm",
        "sub-accounts",
        "Synthetic monitoring",
        "target",
        "tag",
        "thresholds",
        "throughput",
        "tier",
        "time picker",
        "time range",
        "timeslice data",
        "trace",
        "traffic light",
        "transaction",
        "transaction trace",
        "UI",
        "user",
        "UTC",
        "value function (metrics)",
        "violation",
        "web external",
        "web transaction",
        "WebDriverJS",
        "workload"
      ],
      "title": "Glossary",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "756954560251823f905fe44d0ebea119cf983160",
      "image": "https://docs.newrelic.com/static/44172b3e07c1f24191825360676b9d99/c1b63/account-dropdown.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary/",
      "published_at": "2021-10-19T05:57:53Z",
      "updated_at": "2021-10-19T05:57:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "A glossary of common terminology you may encounter. account dropdown In the upper right of the New Relic UI, the account dropdown gives you access to your account settings. If you're trying to switch between accounts, use the account switcher. account switcher If you have access to more than one account in a multi-account organization, you can use the account switcher to switch between accounts. This is located in the top right of most New Relic UI pages. For more on factors that affect access to accounts, see Factors affecting access. To find account settings, use the account dropdown. administrator A type of user role on a New Relic account. For more information, see Users. agent At New Relic, an agent is a piece of monitoring software that provides integrations with various technologies (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic integrations Install agents agent API Some New Relic agents have agent APIs that allow you to extend the functionality of an agent. You can use the API to control, customize and extend the functionality of the agent. Here are some agent API docs: APM agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API Browser agent: Browser agent API Mobile agents: iOS SDK API Android SDK API aggregated metrics Aggregated metric data summarizes calls to specific methods in your application, including how many times each one was called and response times. In the New Relic UI, you see the class and method names along with their aggregate numbers. Metric data aggregation depends on the New Relic tool and your subscription level. For more information, see the documentation about data retention. aggregation delay The length of time in seconds to wait for the aggregation window to fill with data. Required when using CADENCE or EVENT_FLOW aggreation_method types. aggregation function You can use NRQL query functions, such as sum(), average(), or latest() to choose how the data points in an aggregation window should be processed into a single data point. The single aggregated data point is what's passed through the alert evaluation process. aggregation method New Relic aggregates data into windows, and needs to determine when the current window ends and the next one begins. The aggregation_method is the logic that tells us when we have all the data for a given aggregation window. Once the window is closed, the data is aggregated into a single point and evaluated against the threshold. This field is optional. One of the following three values can be specified: *EVENT_FLOW: (Default) Each aggregation window will wait until it starts to see timestamps arrive that are past its own delay setting. Once this occurs, the data is published. Relies on the timestamps of arriving data, so wall-clock time is no longer relevant. Works best for sources that come in frequently and with low event spread (high througput metrics) *CADENCE: Classic New Relic logic where each evaluation window waits exactly as long as the aggregation_delay setting, using the wall-clock time as a timer. aggregation_delay is required when using this option. Data arriving too late will be dropped, which can cause false alerts. *EVENT_TIMER: Each aggregation window has a timer on it, set to the aggregation_timer setting. The Timer starts running as soon as the first data point appears for that aggregation window (based on the data points timestamp). The aggregation_timer is reset for each new data point that arrives for that window. Once the aggregation_timer reaches 0, the aggregation window is published. Ideal for sparse and batched data, such as cloud integrations and infrequent error logs. aggregation_timer The length of time in seconds to wait after each data point received, to ensure the entire batch is processed. Required when using EVENT_TIMER aggregation_method type. aggregation window Streaming alerts gathers data together into specific amounts of time. These windows of time are customizable. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. alert An alert communicates an event or incident that designated personnel can track through Alerts. For an explanation of how basic alerts concepts are related, see Concepts and workflow. alert condition An alert condition (or condition), identified by its unique numeric condition_id, contains the criteria for creating a violation. The condition includes the threshold that is set for a metric timeslice or a custom metric over time on a chosen target. For an explanation of how a condition relates to other basic alerts concepts, see Concepts and workflow. alert evaluation Streaming data is assessed on a set of aggregation windows to determine if an alert condition is violating or recovering. The aggregation window time is how long we'll collect data before running the NRQL query condition. The offset evaluation time is how long you want us to wait for late data before assessing it. If a window doesn't have any data points, it's treated as a gap for loss of signal. alert policy A collection of one or more conditions, one or more notification channels, and an Incident preference setting. If a condition contained within the policy opens a violation, an incident may be opened depending on the Incident preference setting. Notifications will then be sent to all channels attached to the policy. For an explanation of how a policy relates to other basic alerts concepts, see Concepts and workflow. apdex Apdex is an industry-standard way to measure users' satisfaction with the response time of an application or service. New Relic rates each response as Satisfied, Tolerated, or Frustrated, and uses these ratings to calculate an overall user satisfaction score. For more information, see Apdex: Measure user satisfaction. apdex_f The response time above which a transaction are rated frustrating. Defaults to four times apdex_t. Requests that complete in less than apdex_t are rated satisfied. Requests that take longer than apdex_t, but less than four times apdex_t (apdex_f), are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. apdex_t The response time above which a transaction is considered tolerable. The default value is 0.5 seconds, but you can change this in your Apdex settings. Requests that complete in less than apdex_t are rated satisfied. Requests that take more than apdex_t, but less than apdex_f, are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. API (application programming interface) New Relic offers a variety of APIs and SDKs. For more information, see the introduction to New Relic's APIs. APM New Relic's APM (application performance monitoring) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. application For New Relic purposes, any program instrumented by New Relic. application ID Some New Relic solutions assign a monitored application a unique application ID, often shortened to app ID. When present, this ID is available in the UI. It is also reported as an attribute and can be queried. For how to determine this, see Find app ID. application name The name that New Relic combines with your license key to uniquely identify a particular app. For more information, see Name your application. Applied Intelligence (AI) Applied Intelligence (AI) helps you find, troubleshoot, and resolve problems more quickly. Specifically, its a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. Applied Intelligence includes Alerts, Incident Intelligence, and Proactive Detection. attribute Attributes are key-value pairs attached to data objects reported to New Relic. Attributes add detail, and they're similar to tags or labels in other SaaS software. You can explore this data by querying or searching via the UI or by using the data dictionary. Examples: APM reports a Transaction event. This includes timing data for the transaction in a duration attribute, which might have a value of .002. Our Infrastructure Monitoring reports a ProcessSample event. This includes a variety of CPU usage attributes, including a cpuSystemPercent attribute, which might have a value of .01. Our Telemetry SDK reports a Metric data type for storing metrics, with attached attributes like metricName and newrelic.source. Some New Relic tools allow you to report custom attributes to enhance your monitoring. For more information about attributes in APM, see Agent attributes. availability monitoring See Types of Synthetics monitors. browser The New Relic UI supports most browsers. For more information, see Supported browsers. For our end-user browser monitoring tool, see Browser Monitoring. Browser monitoring A Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. background external See web external. child account See parent account. cloud-based integration New Relic offers cloud-based integrations with providers such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. collector The component that collects data from New Relic agents running on an app server, mobile device, or end-user browser. While the agent is installed on a user's app server, the collectors are centrally located in New Relic's data center. In order to contact the collector, the agent must be able to reach New Relic's domains and IP addresses. (The exact domain or IP depends on the New Relic monitoring tool.) The collector receives and interprets this data, and stores it in a database. The data is then retrieved and presented in the New Relic UI and by our various REST APIs. Command line interface (CLI) Our command line interface (CLI) is a tool you can use to build a New Relic application. This is the same tool our own engineers use. Go here for quick start instructions. Go to our Developer site for sample apps and guides. compute unit (CU) A unit of measurement that determines your pricing for some New Relic products governed by our original product-based pricing plan. For more information, see Compute unit pricing. condition_id See alert condition. CPM (calls per minute) The number of calls your application receives each minute. This usually corresponds to the number of page views or external connections, and is usually the same as RPM (requests per minute). CPU burn The time consumed by code minus the wait time for a transaction. This is the time actually spent processing the transaction. It appears in the New Relic UI at the top of the transaction view for the agents that provide it (Ruby and PHP only). custom attribute A key-value pair added to a transaction or event in order to gain additional information about it. For more information, see custom attributes. custom dashboard A customizable dashboard with charts and tables that includes data from multiple New Relic data sources. For more information, see dashboards. custom event An event, in New Relic terms, is a data object with attached attributes. New Relic reports default event types, like Transaction and TransactionError. You can also create your own events. Events can be queried, and are used in some other features. You can generate custom events with APM agents, the browser monitoring agent, the mobile monitoring agents, and via the Event API. Alternatively, you can add custom attributes to some existing default New Relic events. custom instrumentation Custom instrumentation allows you to extend New Relic's monitoring to instrument code elements New Relic doesn't automatically instrument. Custom instrumentation is useful when your framework is not supported by New Relic, or when New Relic fails to pick up some element of your program. You can also use custom instrumentation to block a transaction from being reported entirely. For more information, see Custom instrumentation. custom metric Metric timeslice data that is manually recorded via an API call. Custom metrics allow you to record arbitrary metrics; for example, timing or computer resource data. All custom metric names must be prefixed with Custom/. For more information, see Custom metrics. Not to be confused with custom instrumentation data. data collector See collector. data explorer Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. For more on using the data explorer, see Introduction to the data explorer. degradation period When a data source enters a violating state, a degradation period of time begins. The degradation period is set in the condition's threshold. A violation will open if the source stays in a violating state for the entire degradation period. In addition: If the data source enters a non-violating state before the entire time has elapsed, the degradation period countdown is reset, and a violation does not open. If your alert condition threshold is configured as at least once in, the degradation period always lasts a single minute. dimensional metric A dimensional metric is a metric that has multiple attributes, also known as dimensions. At New Relic, we report dimensional metrics using the Metric data type. For more on other metric data types, see Metric data. Docker An open platform for distributed applications, which allows you to assemble multi-container portable apps. Infrastructure Monitoring includes integrated Docker monitoring. For more information about Docker, see the Docker website. downtime The period of time when customers cannot access your site and your app is not reporting to New Relic. For more information, see Synthetic Monitoring and Types of synthetic monitors. entity In New Relic, an entity is anything we can identify that has data you can monitor. An entity can be something you monitor directly, like applications and microservices, or indirectly, like data centers. You can identify one or more entities to be targets for alert conditions. In the Alerts API, the entity being monitored is identified with an entity_id. For more on this, see What are entities? event The word event is a general term that can have many meanings. At New Relic, event can have several meanings: At New Relic, event data is one of our core data types. Event data represents a record of a single event at a particular moment in time. Events can vary by type (for example, Transaction or Mobile, and will have associated attributes (for example, timestamp or transactionName). For more details, see Event data. For our infrastructure monitoring, the word event can be used to refer to important system and host activity. For example, a configuration change for a monitored host would be registered on Infrastructure's Events UI page. For alerts, the Events UI page displays a list of alerts-related incidents for your monitored entities. Events are reported for a violation opening and for closing. In some contexts, event can refer to any NRQL-queryable data type. For example, when you run a NRQL query, you will see a count of inspected events: this refers to a count of all data types queried. expected error An expected error is a common error that you don't want to affect your Apdex score or error rate. For more information, see Manage errors in APM. exporter At New Relic, an exporter is a type of integration that reports telemetry data to New Relic from a third-party (non-New Relic) telemetry tool. For examples, see Exporters, or search our integrations. Flex New Relic Flex is an application-agnostic, all-in-one integration. With it, you can build your own integration that collects metric data from a wide variety of services, and that can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text) to the terminal. It's a recommended way to create a custom integration, because it doesn't require coding skills. framework A framework is a structured collection of pre-defined functions, into which an application builder inserts their own code to build their application. A framework is not the same as a library. While a library is a collection of functions you can call as needed, a framework is a skeleton for your application. The functions in that framework then call your functions. For more about the distinction between a framework and a library, see What is the difference between a framework and a library?. New Relic automatically instruments many common frameworks. For more about the frameworks New Relic supports, see the agent-specific documentation: C SDK supported frameworks Go supported frameworks Java supported frameworks .NET supported frameworks Node.js supported frameworks PHP supported frameworks Python supported frameworks Ruby supported frameworks harvest cycle The period of time between each connection from a New Relic agent to the collector. Between harvest cycles, an agent collects and caches data. At the end of the cycle an agent reports those data to the collector, then begins a new harvest cycle. health status indicator Some New Relic UI pages have a health status indicator appearing next to an index of monitored entities. This is a colored bar (generally green, yellow, red, or gray) indicating the status of your app or other entity monitored by New Relic. It also indicates whether the entity has any alert policies assigned to it and whether there are any policy violations. In general, the colored bar will be green, yellow, red, or gray to indicate the health status. Exceptions: Our REST API (v2) uses orange instead of yellow for the application's health and reporting status. Service maps use different criteria for reporting the health of a connection between an app and an external service not monitored by New Relic (for example, a third party API). host At New Relic, a host means one of the following: A physical machine is a hardware-based device with dedicated physical resources, including memory, processing, and storage. Each machine has its own OS which applications run on. A virtual machine (VM) is the software implementation of a physical machine that executes programs like a physical machine. One or more virtual machines can run on a physical machine. Each virtual machine has its own OS and allocated virtual machine resources such as RAM and CPU. A cloud instance is a type of virtual machine that is run in the public cloud. In this context, virtual machines and cloud instances are different from Java Virtual Machines (JVMs) and containers. host ID Each host identified by APM is assigned a host ID. This ID is used to uniquely identify it, and to retrieve data about that host via the REST API. For more information, see List host ID. ignored error An error that you have told the APM agent not to report to the collector. For more information, see Manage errors in APM. incident An incident is a collection of one or more violations of the conditions defined in an alert policy. An incident record includes all of the open and close time stamps for each violation, as well as chart snapshots of the data being evaluated around the time of each violation. You can view detailed information from the Incidents pages in the user interface. You can also select your preference for how we roll up violations into the incident. For an explanation of how an incident relates to other basic alerts concepts, see Concepts and workflow. Infrastructure monitoring By connecting changes in host performance to changes in your configuration, infrastructure monitoring provides real-time metrics and powerful analytics that reduce your mean-time-to-resolution (MTTR). Infrastructure is specifically designed for complex environments that need flexible, dynamic server monitoring, from a physical datacenter to thousands of Amazon Elastic Compute Cloud (Amazon EC2) instances and other types of integrations. Insights Insights was the name for the New Relic product that previously governed the reporting of custom events, as well as the ability to query and chart your New Relic data. These features are now a fundamental part of the New Relic One platform and are no longer governed by the Insights product or name. To learn more about these features: Event API for reporting custom events Query and chart data For historical reasons, the word \"Insights\" is still used in some places. For example: Some APM agents still have Insights language in their codebase. For example, the Java agent custom_insights_events configuration. For New Relic organizations on our original pricing plan, Insights Pro is still the product name governing custom event data ingest and retention. There is an API key called the Insights insert key. instance ID Each instance identified by New Relic is assigned a unique instance ID. Instance IDs are most commonly found for JVMs (Java Virtual Machines), but can exist for each agent. This ID is used to uniquely identify it, and to retrieve data about that instance via the REST API. For more information, see List instance IDs. instrumentation The collection of data from an application or host. When New Relic instruments a framework, it detects the methods and calls used by that framework, and intelligently groups them together. integration At New Relic, an integration refers to a solution that integrates with a specific technology (like a web framework or a type of database). See Integrations. interaction In our mobile monitoring, an interaction is a specific code path initiated by a user interaction (usually a button press). An interaction is the mobile equivalent of a transaction, and like a transaction an interaction can be traced and monitored. You can see much of the data included in an interaction in the BrowserInteraction event. interaction trace An interaction trace is a complete picture of a single interaction. With interaction traces, New Relic gives you much deeper visibility into a single slow interaction, which can help you understand a broader problem. Interaction traces are the mobile equivalent of a transaction trace. For more information, see Creating interactions (iOS) and Creating interactions (Android). inventory data Inventory data is information about the status or configuration of a service or host. Examples of inventory data include: Configuration settings Name of the host the service is on Amazon AWS region Port being used For more information, see Understand and use data. key transaction A web transaction that the user has marked as particularly important; for example, key business events (such as signups or purchase confirmations), or transactions with a high performance impact (such as searches). Key transactions have their own pages in the UI and other customized values. For more information, see Key transactions. launcher A launcher is a specific piece of code you can include when you create a New Relic One app. It creates the tile on the homepage that you click to launch the app. For more information, see the documentation about core UI components. log A log is a message about a system used to understand the activity of the system and to diagnose problems. For more information on how we use log data, see Log management. Log monitoring Our log management and monitoring features give you the tools to collect, process, explore, visualize, and alert on your log data using your existing log forwarder. With all of your log data in one place, you'll be able to make better decisions, detect and resolve problems more quickly, and see your logs in context to troubleshoot faster. Logs Our Logs feature is a scalable log management platform that allows you to connect your log data with the rest of your telemetry data. Pre-built plugins with some of the most common open-source logging tools make it simple to send your data from anywhere to New Relic. Logs in context Logs in context makes it easy to link to your log data with related data across the rest of our platform. Bringing all of this data together in a single tool allows you to quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. master account See parent account. metric A metric is a numeric measurement. Metric data is a broad category because there are several ways to make and report measurements. For more about how metrics are reported at New Relic, see New Relic data types. metric timeslice New Relic reports metrics in several ways. One variety of metric data is called metric timeslice data; this is the type of data used to generate many of the charts in APM, mobile monitoring, and browser monitoring (for more details, see metric timeslice data). Over time, metric timeslice data is aggregated into longer timeslice data records for more efficient storage. For more about how we aggregate this type of data, see Data aggregation. For how to query this type of data, see Query metric timeslice data. metric grouping issue A metric grouping issue occurs when an account sends too many differently named metric timeslice data points to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. For more information, see Metric grouping issues. minion The software that accepts monitor jobs from a private location. A minion is a packaged virtual appliance that runs in your hypervisor. For more information, see Private locations overview and install and configure private minions. Mobile monitoring Mobile monitoring allows you to monitor and manage the performance of your mobile apps on Android, iOS, tvOS, and other systems. Mobile monitoring provides end-to-end details, including crashes, throughput, HTTP requests, error traces, and more. Not to be confused with New Relic's own mobile apps for Android, iPhone, and iPad. monitor For our Synthetic Monitoring, a monitor ensures your website or API endpoint is available. For more information, see Adding and editing monitors. NerdGraph NerdGraph is our GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. You can use our NerdGraph GraphiQL explorer to explore the schema and find definitions. With valid New Relic API key, you can try it out yourself at api.newrelic.com/graphiql. Nerdlet A Nerdlet is a component of a New Relic One application. It's a specific UI view, represented by a React JavaScript package. For more information, see Nerdpack file structure. Nerdpack A Nerdpack is a component of a New Relic One application. It's the package containing all the files needed by that application. For more information, see Nerdpack file structure. New Relic Edge with Infinite Tracing New Relic Edge with Infinite Tracing is a fully managed, distributed tracing service that observes 100% of your application traces, then provides actionable data so you can solve issues faster. For more information, see /docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works. New Relic One For more information, see Introduction to New Relic One. New Relic One catalog Our catalog is a collection of applications built on the New Relic One platform. The catalog includes custom apps we've built, public open source apps, and any apps that you buid. You can browse the catalog on New Relic One. NRQL (New Relic query language) NRQL is a query language, similar in form to SQL, that allows you to query the data stored in your New Relic account. non-web transaction APM identifies transactions as either web or non-web. When New Relic does not detect a transaction was initiated by a web request, this is called a non-web transaction. For more information, see Background processes and other non-web transactions. notification The message sent when an incident opens, is acknowledged, or closes. The type of notification is defined by the alert policy's notification channel. For an explanation of how notifications relate to other basic alerts concepts, see Concepts and workflow. notification channel Where we send a notification when an incident opens, is acknowledged, or closes. Available channels include email, mobile push notifications, webhooks, and more. on-host integration On-host integrations refer to integrations that reside on your own servers or hosts and that communicate with our infrastructure agent. For more information, see Introduction to on-host integrations. owner For accounts on our original pricing plan, this is a type of user role: the user who initially created the account. For more information, see Users. page load timing With page load timing, New Relic monitors the full load time for end-user browsers. New Relic's application agents dynamically inject JavaScript into the page, then capture the following key load points: Navigation start: The user initiates the transaction. First byte: The browser receives the requested page. DOM ready: The browser has finished parsing DOM. Page ready: Page loading is complete. Page load timing is sometimes referred to as RUM, or real user monitoring. Unlike standard RUM, page load timing also captures JavaScript errors and AJAX requests. For more information, see Page load timing process. parameter Deprecated term; see attribute. parent account New Relic organizations can have a parent/child account structure. This structure was much more important for organizations on our original user model, but is still used for some features for organizations on the New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as \"master accounts\", and child accounts were previously referred to as \"sub-accounts\". permalink A unique URL that links to a view of your application at a specific point in time. Permalinks are useful for troubleshooting and for sharing interesting time windows with colleagues. pinger The component of New Relic that connects to your website to verify your website is accessible. New Relic has pingers in Europe, Asia, and the United States. Each pinger attempts to contact your website at least once every two minutes. If enough pingers are unable to reach your website, your application will be considered down. For in-depth scriptable testing, including real browser tests and tests of API endpoints, see Synthetic Monitoring. Synthetic Monitoring includes free ping monitoring, which allows you to monitor your website from locations around the world. For more information, see Types of Synthetic monitors. Plugins Plugins provides an open platform to monitor critical information about your entire stack. New Relic partners, PaAS and SaAS providers, third-party vendors, and plugin users can: Quickly install and use publicly available plugins in Plugin Central. Develop your own plugin agents to collect the metric data that matters most to your business. Publish your plugins for public or private access. polling interval (AWS) Our Amazon integrations query your AWS services according to a polling interval, which varies depending on the integration. Each polling interval occurs for every AWS entity. For example, if you have thirteen Elastic Load Balancers (ELB), each one will be polled every five minutes. Depending on the AWS integration, there may be delays in the timing between the API request and the metric data returned. If you notice unusual delays, follow the integration troubleshooting procedures. PPM (pages per minute) The number of pages per minute your application serves. private location A Synthetic monitor feature that allows you to run Synthetic monitors from within your own systems by creating private minions. Private locations allow you to extend your Synthetic coverage to new geographical locations, and to monitor websites behind your firewall such as an intranet site. For more information, see Private locations overview. recovery period A recovery period of time begins when a data source enters a non-violating state after being in a violating state. The recovery period is set in the condition's threshold. A violation will close when a source remains in a non-violating state and the recovery period time has elapsed. If the data source enters a violating state before the time has elapsed, the recovery period clock will reset and the violation won't close. response time The duration of time between a request for service and a response. For more information, see Response time. restricted user A type of user role on a New Relic account. For more information, see Users. rollup Using the same application name for multiple applications. This allows you to combine data in APM, either from multiple applications, or from multiple instances of an application. For more information, see Rolling up app data. root span For distributed tracing, the root span is the first span in a trace. In many cases, the root span duration will represent the duration of the entire trace, or be very close to it. However, for more complex, modern systems that use a lot of asynchronous, non-blocking processes, this will not be true. For those systems, the root spans duration may be significantly less than the duration of the trace. RPM The term RPM usually refers to the number of requests per minute your application receives from users. This is usually the same as CPM (calls per minute). Historically, some New Relic monitoring solutions, like APM and Browser Monitoring, used to contain RPM in the URL; for example, https://rpm.newrelic.com. This language use originally referred to Rails performance management because the first iteration of our product monitored Ruby on Rails applications. We monitor many more languages and systems than Ruby now. RUM (real user monitoring) See page load timing. runbook A runbook contains standard procedures and operations typically used by system administrators, network operations staff, and other personnel to handle outages, alert incidents, and other situations. If your organization stores runbook instructions as URLs, you can link this information to an alerts policy so your personnel has easy access to this information when an incident violates the defined policy thresholds. SAML (Security Assertion Markup Language) SAML is an XML-based data format for sharing authentication data between two parties. New Relic accounts must obtain a SAML certificate in order to enable Single Sign On for their users. For more information, see SAML service providers. Selenium Selenium is an open-source browser testing suite. Synthetics uses Selenium to test monitored websites with real browsers. For more information, see monitor types. service A service is a cluster of runtime server processes that accomplish a particular task, usually service requests. Unlike an application, a service is not usually invoked by a human. New Relic offers a variety of integrations that allow you to report data from your services. signal The stream of telemetry data that's watched and alerted on. You use NRQL queries to define a signal. signal filter When we receive data and it's routed to the streaming alerts platform, your NRQL WHERE clause will filter the data coming in. The filtered streaming data is what's evaluated for loss of signal violations, for example. span In a distributed trace, a span is a \"named, timed operation representing a contiguous segment of work in that trace\" (from OpenTracing.io definition). For distributed tracing, spans are displayed in the distributed tracing UI, and the data type Span is available to be queried. See also root span. SSL certificate SSL certificates encrypt data that is being transmitted. While New Relic refers to security certificates as SSL because it is a more commonly used term, all certificates adhere to industry standards for secure encryption in transit. SSO (single sign on) SSO (single sign on) allows you to manage user authentication in New Relic using an external SSO provider. For more information, see Setting up SSO. streaming algorithm This is what determines when the data in an aggregation window is processed. The streaming algorithm uses your server's clock time and the aggregation window size to trigger the alert evaluation process. sub-accounts See master account. Synthetic monitoring Synthetic monitoring allows you to monitor your website or API endpoint via automated, scriptable tools. Use free ping monitor to ensure your website is accessible, or expand your monitoring with browser monitors, which test your website with real browsers. Go further with scripting, to script browsers or API monitors for sophisticated testing. target A target is a resource or component monitored by a New Relic monitoring tool that has been identified in an alert condition. When the data source for that target crosses the defined critical threshold, we will open a violation. Depending on your policy's Incident preference setting, Alerts may create an incident record and send notifications through the defined channels. See also entity. tag Tags are key:value metadata added to monitored apps, hosts, dashboards, and other entities to help you organize your data at a high level. For details, see Tags. thresholds Thresholds are alert condition settings that define a violation. Threshold values include the value a data source must pass to trigger a violation and the time-related settings that define a violation; for example: Passing a certain value for at least x minutes Passing a certain value only once in x minutes While the data source passes a certain value, a degradation period starts. Likewise, when that data source stops passing a certain value, a recovery period starts. The durations of these two time periods are defined in the alert condition threshold settings. Thresholds have a required critical (red) threshold and an optional warning (yellow) threshold. In the UI, the entity's health status indicator will change to yellow or red when a threshold has been crossed and a violation will open. For more information, see Define thresholds. For an explanation of how thresholds relate to other basic Alerts concepts, see Concepts and workflow. throughput Throughput is a measurement of user activity for a monitored application. APM throughput and Browser Monitoring throughput are measured in different ways: APM: requests per minute (RPM) Browser: page views per minute (PPM) tier A tier can refer to how New Relic categorizes or visualizes the various agent language ecosystems that we support. For example: In APM, the color-coded categories that appear on your app's main Overview chart show response time spent in various functions, processes, or agents as tiers; for example, request queuing, garbage collection, Middleware, JVMs, etc. In New Relic labels, TIER can be used to define or classify the client-server architecture; for example, front-end and back-end tiers. \"Tier\" may sometimes be used to refer to our pricing editions. time picker By default the New Relic UI shows data for the past 30 minutes, ending now. To change the time window, use the time picker. time range A time range can refer to a length of time selected in the New Relic UI. New Relic displays a time range depending on the range you select using the time picker. timeslice data See metric timeslice data. trace A trace is a description of how a request travels through a system. Trace data helps you understand the performance of your system and diagnose problems. For more information on how we use trace data, see New Relic data types. traffic light See health status. transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. For more information, see documentation about web transactions and non-web transactions. The term transaction is also sometimes used in Browser Monitoring. In that case, it primarily refers to activity beginning with a browser-side web request and ending with a complete page load. transaction trace A transaction trace is a complete picture of a single transaction, down to the database queries and exact invocation patterns. With transaction traces, New Relic gives you much deeper visibility into a single slow transaction, which can help you understand a broader problem. For more information, see Transaction traces. UI The New Relic user interface. For more information, see Standard page functions. user A user can refer to a specific user role in a New Relic account. For more information, see Users. UTC Universal Time Coordinated (UTC), or Coordinated Universal Time, is a standard timestamp for synchronizing time around the world. value function (metrics) The numeric value obtained from metric timeslice data; for example, an average, minimum, maximum, total, sample size, etc. violation A violation occurs when the entity monitored by an alert condition reports a value that crosses the thresholds defined in that condition. For an explanation of how violations relate to other basic alerts concepts, see Concepts and workflow. You can view a summary of the violations for a selected incident's page. You can also view the violations for a specific entity from the product's UI. web external Web external is the term applied to the portion of time spent in transactions to external applications from within the code of the application you are monitoring. That time can be a call to a third party company (a payment provider, for example) or it could be a call to another microservice within your own company. Web external demonstrates how performance is impacted by your code executing outside the application you are measuring. web transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. Web transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. For more information, see Web transactions and Non-web transactions. WebDriverJS WebDriver is a Selenium component, used to control Synthetics scripted browsers. Specifically, Synthetics uses WebDriverJS, a Node.js-based flavor of Selenium. For more information, see Writing scripted browsers and Scripted browser examples. workload A workload represents a group of entities that work together to provide a digital service. For more information, see Workloads.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.36996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>custom</em> <em>metric</em>",
        "body": ". Here are some agent API docs: <em>APM</em> agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API <em>Browser</em> agent: <em>Browser</em> agent API <em>Mobile</em> agents: iOS SDK API Android SDK API aggregated <em>metrics</em> Aggregated <em>metric</em> data summarizes calls"
      },
      "id": "603eb6f5e7b9d288392a07fc"
    },
    {
      "sections": [
        "Introduction to New Relic",
        "Get started with New Relic",
        "All the answers in one place",
        "Bring all your data together",
        "Analyze your data",
        "Respond to incidents faster"
      ],
      "title": "Introduction to New Relic",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "bd62b563a23cb35cc2aabc7f1f44e3dcacbce3cf",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/introduction-new-relic/",
      "published_at": "2021-10-19T01:44:41Z",
      "updated_at": "2021-10-19T01:44:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic is an observability platform that helps you build better software. You can bring in data from any digital source so that you can fully understand your system and how to improve it. With New Relic, you can: Bring all your data together: Instrument everything and import data from across your technology stack using our agents, integrations, and APIs, and access it from a single UI. Analyze your data: Get all your data at your fingertips to find the root causes of problems and optimize your systems. Build dashboards and charts or use our powerful query language. Respond to incidents quickly: Our machine learning solution proactively detects and explains anomalies and warns you before they become problems. Get started with New Relic Here's how you can quickly get started capturing and analyzing your data: If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever! Follow the steps in our Add your data UI page to get data flowing in. For your first install, we recommend the Guided install option, which will setup many integrations with a single command. Once you have data coming into New Relic, learn more about the New Relic UI or set up Alerts. All the answers in one place New Relic is built for full stack observability. It links all relevant data so that you get the whole picture of everything that enables your systems to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Monitoring vs. observability: New Relic provides answers to essential questions in one place. As just one example of what you can do with New Relic, imagine you are a Kubernetes administrator overseeing many clusters and pods of software containers. Where do you start troubleshooting? This short video shows how you can locate a problem cluster and use distributed tracing to find relevant logs: Bring all your data together Capture, organize, and make sense of your data in our Telemetry Data Platformno matter where it comes from. Use our agents and integrations to automatically collect data from common frameworks and tools, or use our APIs for data thats more specific to your business or technology. If you don't see your technologies or tasks listed here, see a larger list at New Relic integrations. If you want to... New Relic can help you... Instrument your application Instrument your code: Use our APM agents to automatically instrument your applications in C, Go, Java, .NET, Node.js, PHP, Python, and Ruby. Track transactions: Gather distributed tracing details as your transactions cross boundaries between apps and services. Instrument your environment Instrument your infrastructure: Observe your entire environment (including Linux, Windows, AWS, Azure, Google Cloud Platform, Kubernetes, Docker, and more). Collect and centralize logs: See your log data in context with your other application and infrastructure data. Save time switching between tools and reach solutions more quickly. Instrument your digital experiences Enhance browser performance: Decrease page load times, as well as triage and eliminate errors. Monitor mobile apps: Troubleshoot crashes and check the health of your Android and iOS apps with our mobile agents. Simulate user activity: Ensure youre meeting customer expectations by running automated checks to monitor key user flows and experiences. Send data via APIs or build your own solution Collect data without an agent: Call our APIs directly if you prefer to use OpenTelemetry or other agents. Build your own integration: You can use our Flex tool, or one of language-specific SDKs for creating your own exporters to send data to New Relic. As a full user you get access to our entire set of observability tools in New Relic One: Application monitoring Browser monitoring Mobile monitoring Synthetic monitoring Serverless monitoring Infrastructure monitoring Log management You can start anywhere, but you'll never get lost. True observability across your entire stack means that you're in control. Analyze your data With your data secure at New Relic, our platform can alert you to problems and help you organize, process, and understand your data, whether it's metrics, events, logs, or traces: Explore your data visually: Jump into our data explorer to navigate all your data and make connections between your entities without any knowledge of query languages. Query and visualize your data: Use our curated dashboard visualizations or create your own. Use NRQL (New Relic Query Language) to slice and dice your data and dig deeper into questions. Query your data programmatically: Access your data through our NerdGraph GraphQL API. Easily prototype queries in our GraphiQL editor. Respond to incidents faster DevOps, site-reliability, and network operation teams need reliable, real-time alerts and anomaly detection to ensure their systems are always up and running efficiently. Let Applied Intelligence, our hybrid machine learning engine, automatically detect anomalies, reduce alert noise, and enrich incidents with context so that you can respond faster to incidents. Proactive detection: Be notified of unusual app behavior and get an analysis of this unusual behavior sent to Slack. Not using Slack? Set up a webhook to deliver messages when you need them. Get notifications: Set up alerts across your data sources and get notified when systems need your attention. Preserve your attention and control how many threshold violations should fire before you're notified.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.18068,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " solutions more quickly. Instrument your digital experiences Enhance <em>browser</em> performance: Decrease page load times, as well as triage and eliminate errors. Monitor <em>mobile</em> apps: Troubleshoot crashes and check the health of your Android and iOS apps with our <em>mobile</em> agents. Simulate user activity: Ensure"
      },
      "id": "6043ad0764441f5a06378ecd"
    },
    {
      "sections": [
        "Know your data limits",
        "Responses to limit violations",
        "System limits UI",
        "Troubleshooting system limits",
        "Account-level limits",
        "Data ingest API limits",
        "Finding other agent and integration limits"
      ],
      "title": "Know your data limits",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "d6ff940e92c5d1a3ae34f391e9fa3be5dfa21c2f",
      "image": "https://docs.newrelic.com/static/8ee61e3091f6e044202cff92026afada/8c557/limits-graph.png",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/view-system-limits/",
      "published_at": "2021-10-19T03:58:30Z",
      "updated_at": "2021-10-19T03:58:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure our systems are always up and ready to support you, and to keep you from unintended use, we place limits on the amount of data you can send, query, and store. Responses to limit violations Limits are enforced per child account, and across our APIs. You might reach a limit if you start monitoring a new high-traffic application, or have a sudden data spike. When you do reach a limit, New Relic responds according to the type of data and the limit thats reached. For example: We place a limit on the number of ingested requests per minute (RPM) per data type. When this limit is reached, we stop accepting data and return a 429 status code for the duration of the minute. For queries, we place limits on the number of queries per minute and the number of records inspected (see query limits). When the number of queries per minute limit is reached, New Relic will begin rejecting queries until the number of queries is below the limit. When the records inspected limit is reached, New Relic will reject traffic from the source scanning the largest number of records and attempt to allow traffic from other sources. For metrics, we place a limit on the number of unique timeseries (cardinality) per account and per metric. When this limit is reached, aggregated data is turned off for the rest of the UTC day. For every major limit violation, New Relic creates an NrIntegrationError event for that account, which has these limit-related attributes: Attribute Description category RateLimit or ApiLimit. The RateLimit category is used for limits based on a unit of time such as the number of requests ingested per minute. The ApiLimit is used for constant limits, such as the number of attributes on a record. limitName The name of the limit. message Describes the limit and the impact. limitValue The limit reached. System limits UI The system Limits page (from the account dropdown, click Manage your data and click Limits on the left) displays when your account has encountered a rate limit in the specified time period. The page displays a default period of 24 hours; you can set a custom range from the top-right of the page. Non-limit-related NrIntegrationError events are not displayed here. In addition, this page does not display information about limits you have not hit, or how close you are to reaching a limit. For more on creating queries and alerts for data ingest and billing metrics, see Query billing/usage data. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a chart on the Limits UI page displaying a cardinality violation limit issue. To add more detail, or build a dashboard, click the View NRQL button on the chart to see the NRQL powering this view. The graph displays each unique limit type that was reached during the selected time-period. This can help you find any trends based on time. The Limits page also provides a table where you can find the limit name, the limit event message associated with it, and last occurrence time and date. If you click a limit in the table, you see more about what happened, and when. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a limit events table on the Limits UI page. Troubleshooting system limits To troubleshoot limits when you reach them, click the limit info in the table, and then follow the docs link that's provided. Different limits have different solutions. Account-level limits The following table includes general max limits that apply across all New Relic accounts. Specific New Relic tools, like agents and integrations, have their own limits and configurations, and might be lower than these theoretical maximum limits. Limited condition Limit Rate of NRDB record * ingest 55 million per account per minute Max NRDB records * ingested per API call 1MB (10^6 bytes) Max attribute value size 1KB (10^3 bytes) Max payload size 1MB (10^6 bytes) Max total attributes per data type (including default attributes) 254 (less for some tools; for example, 64 for agents) Number of unique custom data types 250 per account per day (applies to custom events because that's source of new data types) APM limits Agent instances: 50K per account Agent instances per app: 10K APM apps/services: 10K per second Browser: number of page views 1M per minute per app Distributed tracing: Max age of span timestamp values 20 minutes. Timestamp must be within 20 minutes of current time at ingest or within 20 minutes from the time the last span with the same trace.id was received by New Relic. Distributed tracing: Max spans per minute per account Dependent on agreement. Max limit: 2M. Distributed tracing: Max spans per trace 50K Distributed tracing: Max attributes per span 200 Rate of metric timeslice data (used by APM, browser, mobile) Ingest: 2 million per minute Rate of names: 4 million per minute per account Number per monitored app: 300K Mobile monitoring: number of crashes reported 10K per hour Infrastructure agents, integrations Number of infrastructure agents and/or integrations: 5K per account Gross number of new monitored containers: 5K per hour per account Query limits NRDB records * inspected: 100 billion per account per hour Rate of queries: 20 per account per second See other query limits * NRDB records refers to database records for our core data types, which includes events, metrics (dimensional), logs, and distributed tracing (span) data, all stored in the New Relic database (NRDB). This does not include metric timeslice data. Data ingest API limits Our ingest APIs have additional limits that may override the more general account-level limits. Note that these limits also apply to our tools that use these APIs (like our Telemetry SDKs or our open source telemetry integrations). Metric API (dimensional metrics) Event API Log API Trace API Finding other agent and integration limits To find limits for our other agents and integrations, which will override more general account-level limits, see the docs for those tools: you can search our solutions here. Some default reporting limits are located in these tools' configuration docs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.23097,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " trace.id was received by New Relic. Distributed tracing: Max spans per minute per account Dependent on agreement. Max limit: 2M. Distributed tracing: Max spans per trace 50K Distributed tracing: Max attributes per span 200 Rate of <em>metric</em> timeslice data (used by <em>APM</em>, <em>browser</em>, <em>mobile</em>) Ingest: 2 million per"
      },
      "id": "60446a7c64441f48d7378f2b"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/custom-instrumentation": [
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-10-18T02:25:25Z",
      "updated_at": "2021-09-14T10:31:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the data explorer to start building a chart. Select the advanced (NRQL) mode to refine your query. In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.20024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0 or higher Go"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-10-18T02:23:52Z",
      "updated_at": "2021-09-14T09:18:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in APM and dashboards. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.16196,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to each of these destinations. You can also collect custom attributes to send additional <em>data</em> to New Relic. Attribute destination flow This diagram illustrates how an <em>agent</em> decides to send attributes to each destination. <em>Agent</em> attribute collection: An <em>agent</em> makes three different decisions when sending"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Manage errors in APM: Collect, ignore, or mark as expected",
        "Collect errors not instrumented by default",
        "Ignore errors",
        "Tip",
        "Ignore errors using server-side configuration in the UI",
        "Ignore errors using agent configuration",
        "Expected errors (Java, Node.js, Python, Ruby, and .NET only)",
        "View errors in the UI"
      ],
      "title": "Manage errors in APM: Collect, ignore, or mark as expected",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ebd20f78d5084c48b1669ae33569da3f829fec6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/",
      "published_at": "2021-10-18T02:24:48Z",
      "updated_at": "2021-08-20T14:59:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM agents automatically report error data for supported frameworks. To optimize error reporting and alerting, you can further manage errors in order to: Catch errors that we don't instrument by default. Ignore errors that you don't want reported at all. Filter out noise from expected errors so you can focus on the errors that are affecting performance. (Java, Ruby, Node, Python, and .NET agents only) Collect errors not instrumented by default APM agents include API calls to report (or \"notice\") errors. These are useful when APM doesn't instrument your framework automatically or when there are particular errors that aren't caught for your supported framework. To learn how to get an APM agent to report an error, see the agent-specific API documentation: C SDK: newrelic_notice_error() Go: NoticeError() Java: NoticeError() .NET: NoticeError() Node.js: noticeError() PHP: newrelic_notice_error() Python: notice_error() Ruby: notice_error() Ignore errors Sometimes the APM agent instruments an error that you don't want reported, such as errors that contain sensitive information like user login errors. If you don't want an error to report to the our collector, you can ignore the error, and the APM agent discards the error entirely. Tip For Java, Ruby, Node.js, and Python: If you want to report errors to APM but don't want those errors to affect your Apdex or error rate, mark them as expected instead. There are two ways to ignore errors: through the agent configuration or through server-side configuration in the UI: Ignore errors using server-side configuration in the UI This option depends on whether the agent supports server-side configuration. If it is not already enabled, enable server-side configuration. Go to the Server-side configuration menu for the application that has errors that you want to ignore. Under Error collection, look for Ignore from error collection. Add the HTTP code or the Error class for the errors that you want to ignore. Select Save server-side configuration. Ignore errors using agent configuration To ignore an error using the agent configuration, see the configuration documentation for your agent: C SDK: Not available. For more information, see the C SDK errors example on GitHub. Go: ErrorCollector.IgnoreStatusCodes. Java: error_collector.ignore_classes, error_collector.ignore_classes.message, or error_collector.ignore_status_codes. For additional information, see Java agent error configuration. .NET: ignoreErrors or ignoreStatusCodes. Node.js: ignore_status_codes, ignore_classes, or ignore_messages. PHP: error_collector.ignore_exceptions or error_collector.ignore_errors. Python: error_collector.ignore_classes or error_collector.ignore_status_codes. Ruby: error_collector.ignore_errors. Expected errors (Java, Node.js, Python, Ruby, and .NET only) For the below APM agents, you can mark errors as expected. These errors will be reported to APM and available for viewing, but they won't affect the Apdex or error rate (or alert conditions based on error rate). To configure errors as expected, see the agent-specific documentation: Java Ruby Node.js .NET Python If expected errors are enabled, APM's Error analytics page will, by default, have a filter applied with the error.expected attribute set to false, meaning expected errors will not be displayed. To view expected errors, turn off the error.expected filter. To view expected errors, query your data: To view charts of expected errors, create a query for the error.expected attribute. To create alert conditions for NRQL queries, use the error.expected attribute. View errors in the UI Among other places, error data appears in these parts of the UI: Error analytics page: shows in-depth charts and visual analysis of errors. APM Overview page: shows a high-level view of your application, which includes errors. Alert conditions: can be based on error rate. The transactionError event: contains underlying error data, which can be used in NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.18086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "sections": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>APM</em> <em>agents</em> automatically report error <em>data</em> for supported frameworks. To optimize error reporting and alerting, you can further <em>manage</em> errors in order to: Catch errors that we don&#x27;t instrument by default. Ignore errors that you don&#x27;t want reported at all. Filter out noise from expected errors so you"
      },
      "id": "6043f7d6196a67c1d4960f72"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes": [
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-10-18T02:25:25Z",
      "updated_at": "2021-09-14T10:31:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the data explorer to start building a chart. Select the advanced (NRQL) mode to refine your query. In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.20024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0 or higher Go"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.16269,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " transaction collects both metric timeslice and event <em>data</em>. Custom instrumentation for already instrumented transactions collects only metric timeslice <em>data</em>. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-10-18T02:23:52Z",
      "updated_at": "2021-09-14T09:18:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in APM and dashboards. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.16196,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to each of these destinations. You can also collect custom attributes to send additional <em>data</em> to New Relic. Attribute destination flow This diagram illustrates how an <em>agent</em> decides to send attributes to each destination. <em>Agent</em> attribute collection: An <em>agent</em> makes three different decisions when sending"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected": [
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-10-18T02:25:25Z",
      "updated_at": "2021-09-14T10:31:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the data explorer to start building a chart. Select the advanced (NRQL) mode to refine your query. In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.20023,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0 or higher Go"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.16269,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " transaction collects both metric timeslice and event <em>data</em>. Custom instrumentation for already instrumented transactions collects only metric timeslice <em>data</em>. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-10-18T02:23:52Z",
      "updated_at": "2021-09-14T09:18:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in APM and dashboards. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.16194,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to each of these destinations. You can also collect custom attributes to send additional <em>data</em> to New Relic. Attribute destination flow This diagram illustrates how an <em>agent</em> decides to send attributes to each destination. <em>Agent</em> attribute collection: An <em>agent</em> makes three different decisions when sending"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/real-time-streaming": [
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.16269,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " transaction collects both metric timeslice and event <em>data</em>. Custom instrumentation for already instrumented transactions collects only metric timeslice <em>data</em>. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-10-18T02:23:52Z",
      "updated_at": "2021-09-14T09:18:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in APM and dashboards. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.16194,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to each of these destinations. You can also collect custom attributes to send additional <em>data</em> to New Relic. Attribute destination flow This diagram illustrates how an <em>agent</em> decides to send attributes to each destination. <em>Agent</em> attribute collection: An <em>agent</em> makes three different decisions when sending"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Manage errors in APM: Collect, ignore, or mark as expected",
        "Collect errors not instrumented by default",
        "Ignore errors",
        "Tip",
        "Ignore errors using server-side configuration in the UI",
        "Ignore errors using agent configuration",
        "Expected errors (Java, Node.js, Python, Ruby, and .NET only)",
        "View errors in the UI"
      ],
      "title": "Manage errors in APM: Collect, ignore, or mark as expected",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ebd20f78d5084c48b1669ae33569da3f829fec6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/",
      "published_at": "2021-10-18T02:24:48Z",
      "updated_at": "2021-08-20T14:59:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM agents automatically report error data for supported frameworks. To optimize error reporting and alerting, you can further manage errors in order to: Catch errors that we don't instrument by default. Ignore errors that you don't want reported at all. Filter out noise from expected errors so you can focus on the errors that are affecting performance. (Java, Ruby, Node, Python, and .NET agents only) Collect errors not instrumented by default APM agents include API calls to report (or \"notice\") errors. These are useful when APM doesn't instrument your framework automatically or when there are particular errors that aren't caught for your supported framework. To learn how to get an APM agent to report an error, see the agent-specific API documentation: C SDK: newrelic_notice_error() Go: NoticeError() Java: NoticeError() .NET: NoticeError() Node.js: noticeError() PHP: newrelic_notice_error() Python: notice_error() Ruby: notice_error() Ignore errors Sometimes the APM agent instruments an error that you don't want reported, such as errors that contain sensitive information like user login errors. If you don't want an error to report to the our collector, you can ignore the error, and the APM agent discards the error entirely. Tip For Java, Ruby, Node.js, and Python: If you want to report errors to APM but don't want those errors to affect your Apdex or error rate, mark them as expected instead. There are two ways to ignore errors: through the agent configuration or through server-side configuration in the UI: Ignore errors using server-side configuration in the UI This option depends on whether the agent supports server-side configuration. If it is not already enabled, enable server-side configuration. Go to the Server-side configuration menu for the application that has errors that you want to ignore. Under Error collection, look for Ignore from error collection. Add the HTTP code or the Error class for the errors that you want to ignore. Select Save server-side configuration. Ignore errors using agent configuration To ignore an error using the agent configuration, see the configuration documentation for your agent: C SDK: Not available. For more information, see the C SDK errors example on GitHub. Go: ErrorCollector.IgnoreStatusCodes. Java: error_collector.ignore_classes, error_collector.ignore_classes.message, or error_collector.ignore_status_codes. For additional information, see Java agent error configuration. .NET: ignoreErrors or ignoreStatusCodes. Node.js: ignore_status_codes, ignore_classes, or ignore_messages. PHP: error_collector.ignore_exceptions or error_collector.ignore_errors. Python: error_collector.ignore_classes or error_collector.ignore_status_codes. Ruby: error_collector.ignore_errors. Expected errors (Java, Node.js, Python, Ruby, and .NET only) For the below APM agents, you can mark errors as expected. These errors will be reported to APM and available for viewing, but they won't affect the Apdex or error rate (or alert conditions based on error rate). To configure errors as expected, see the agent-specific documentation: Java Ruby Node.js .NET Python If expected errors are enabled, APM's Error analytics page will, by default, have a filter applied with the error.expected attribute set to false, meaning expected errors will not be displayed. To view expected errors, turn off the error.expected filter. To view expected errors, query your data: To view charts of expected errors, create a query for the error.expected attribute. To create alert conditions for NRQL queries, use the error.expected attribute. View errors in the UI Among other places, error data appears in these parts of the UI: Error analytics page: shows in-depth charts and visual analysis of errors. APM Overview page: shows a high-level view of your application, which includes errors. Alert conditions: can be based on error rate. The transactionError event: contains underlying error data, which can be used in NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.18085,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "sections": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>APM</em> <em>agents</em> automatically report error <em>data</em> for supported frameworks. To optimize error reporting and alerting, you can further <em>manage</em> errors in order to: Catch errors that we don&#x27;t instrument by default. Ignore errors that you don&#x27;t want reported at all. Filter out noise from expected errors so you"
      },
      "id": "6043f7d6196a67c1d4960f72"
    }
  ],
  "/docs/agents/manage-apm-agents/app-naming/name-your-application": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-10-18T02:26:15Z",
      "updated_at": "2021-09-14T10:33:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.43652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use multiple <em>names</em> for an <em>app</em>",
        "sections": "<em>Name</em> <em>app</em> instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same <em>app</em> <em>name</em>, <em>agent</em> language, and license key, New Relic aggregates their data into a single New Relic-monitored <em>app</em>. You can also view data for the individual hosts and instances from the <em>app</em>&#x27;s New Relic <em>APM</em> Overview page. To segment your <em>app</em> in a different way, or to work with each"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-10-18T02:25:25Z",
      "updated_at": "2021-09-14T10:31:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the data explorer to start building a chart. Select the advanced (NRQL) mode to refine your query. In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.7018,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0 or higher Go"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.67588,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go <em>app</em>. Java custom instrumentation New Relic&#x27;s Java <em>agent</em> supports"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    }
  ],
  "/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app": [
    {
      "sections": [
        "Name or change the name of your application",
        "Important",
        "Changing the name vs. the alias",
        "Give each app a descriptive name",
        "Assign the name in your config file",
        "Change the application's alias",
        "Tip",
        "Using multiple names for an app"
      ],
      "title": "Name or change the name of your application",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "bfd84f5a7908a84cbe4fa4e8ccb44be94997c85b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/name-your-application/",
      "published_at": "2021-10-18T02:25:25Z",
      "updated_at": "2021-07-09T04:49:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic connects metrics to individual applications using your license key and the primary application name. You can change the app's name in your config file, or assign an alias to the app to change how it appears in the New Relic UI. Important If you do not specify the app name in your New Relic configuration file, most New Relic agents provide a generic application name by default. To ensure all aggregated data for the same app is reported accurately, make sure you give each app a descriptive name. Changing the name vs. the alias You can assign a new app name or change the app alias. These have two different effects: Term How to change it Effect Name Assign the name in your config file Changing the app name in the agent's configuration file will cause the application to report to a new heading in the New Relic user interface, with a total discontinuity of data. This is useful, for example, if you want to start over and report new data. If no other agents are reporting to the old app name, the old app name will appear gray and can be deleted. Alias Change the alias in the APM Settings UI Creating an alias for the app name only changes how the app name appears in the New Relic UI. Changing the alias does not affect how data is reported. It simply helps you keep track of your data with a useful alias. Give each app a descriptive name By default, most New Relic agents provide a default application name, such as My Application or PHP Application, for each app that is linked to your account. Important We recommend changing the default name of an app to a more descriptive name before deployment, and it can be up to 128 characters long. Each unique app name creates a new application record in your New Relic UI, which allows you to: Run an application on more than one host, and have all the data aggregated (collected) under the same name. Run multiple applications on a single host, and have all the data aggregated (collected) under different names. Assign the name in your config file To change the app name, set the app name value in the agent's configuration file. If you have deployed an app via one APM agent, and then deploy another app with the same name via a different APM agent, New Relic will automatically append the agent language name to the end of the second app's name. For example, if you deploy a Node.js app named New-App, and then deploy a .NET app named New-App, New Relic will automatically append the second app name as New-App (DOTNET). Agent Configuration file value C Identify a maximum of three names separated by a semicolon ;in your newrelic_app_config_t* config;. Go Set AppName to a maximum of three names separated by a semicolon. Java See the options for naming your Java application. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP See the options for naming your PHP application. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. Change the application's alias The application name you set in the New Relic user interface is a human-readable alias. If you rename your app, the visible name is updated everywhere in the New Relic UI, including in linked browser apps. Initially, this alias is the same as the app's identifier name in the New Relic agent configuration file. However, changing the UI alias does not affect the underlying app name used for data rollup, which is set in the agent config file. The application must be actively reporting data to change the alias. Changing the UI alias will cause all agents that report under the app identifier to restart themselves. To change the alias for your application's name in the New Relic user interface: Go to one.newrelic.com > APM > (select an app) > Settings > Application. In the Application alias field, type a new name (alias) for the selected app. Select Save application settings. Tip You can also change the app's alias with the New Relic REST API. Using multiple names for an app By giving your app multiple names, you can aggregate metrics for multiple agents across an entire app or service. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.15228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Name</em> or change the <em>name</em> of your <em>application</em>",
        "sections": "<em>Name</em> or change the <em>name</em> of your <em>application</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": ", for example, if you want to start over and report new data. If no other <em>agents</em> are reporting to the old <em>app</em> <em>name</em>, the old <em>app</em> <em>name</em> will appear gray and can be deleted. Alias Change the alias in the <em>APM</em> Settings UI Creating an alias for the <em>app</em> <em>name</em> only changes how the <em>app</em> <em>name</em> appears in the New Relic"
      },
      "id": "603eb81264441fa6a74e889a"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-10-18T02:25:25Z",
      "updated_at": "2021-09-14T10:31:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the data explorer to start building a chart. Select the advanced (NRQL) mode to refine your query. In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.7018,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0 or higher Go"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.67588,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go <em>app</em>. Java custom instrumentation New Relic&#x27;s Java <em>agent</em> supports"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/add-rename-remove-hosts": [
    {
      "sections": [
        "Enable configurable security policies",
        "Important",
        "Compatibility and requirements",
        "Caution",
        "Example configuration",
        "Java agent: YAML example",
        ".NET agent: XML example",
        "Ruby agent: YAML example",
        "Available policy options",
        "For more help"
      ],
      "title": "Enable configurable security policies",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "1f645201e6e79a35f84334b11415e8a2a0edf665",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/enable-configurable-security-policies/",
      "published_at": "2021-10-18T02:27:11Z",
      "updated_at": "2021-09-14T14:49:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important APM's configurable security policies is available in limited release for approved New Relic accounts. APM's configurable security policies gives you granular control over configuration options related to your account's data security. This document explains how to enable account-wide security policies and the options available. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Compatibility and requirements APM agent versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security policies Caution Security policies apply account-wide. Once enabled, they can only be edited or disabled with the help of New Relic support. If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your APM agent's high security mode, which is set in the configuration file. High security mode and configurable security policies do not apply to Lambda monitoring or use of the New Relic Event API. For the limited release, there is no UI component. If you are participating in the limited release, follow this procedure to set up your accounts: Choose the accounts on which to enable configurable security policies. Choose the configurable security policies options that you want for those accounts. Inform your New Relic sales rep of the options that you have chosen. Ensure your agent versions support this feature. Update agents if necessary. When you receive the security token based on the security policies options that you chose, insert the security token into the agent configuration file(s). See examples. Delete the high security mode enabled flag from your config file(s). High security mode (HSM) at the agent level is different than high security mode at the account level. Be sure to disable HSM in the agent's config file, as explained in this procedure. Having both the security token and the HSM flag will result in the agent disconnecting. Example configuration Here are some example configuration examples for enabling the configurable security policies: Java agent: YAML example The Java agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy .NET agent: XML example The .NET agent uses a XML file for configuration. Here is an example snippet enabling security policies: ... <configuration agentenabled=\"true\" xmlns=\"urn:newrelic-config\"> <service licensekey=\"YOUR_LICENSE_KEY\"> <application> <name>YOUR_APPLICATION_NAME</name> </application> <securityPoliciesToken>YOUR_TOKEN</securityPoliciesToken> <log level=\"info\"> </log></service></configuration> ... Copy If you prefer to use an environment variable, it would look like this: NEW_RELIC_SECURITY_POLICIES_TOKEN=YOUR_TOKEN Copy Ruby agent: YAML example The Ruby agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy Available policy options Here are the settings you can choose when creating your policies. Some of these options will not be available for some agents. Setting Effect Database query collection Options: Enabled: Collects obfuscated database query data. Obfuscated queries generally appear along with slow query details in the APM or New Relic One UI. Disabled: Prevents the collection of obfuscated database query data. Raw query data is not collected once configurable security policies is enabled. attributes.include list Go, Java, .NET, Node.js, Ruby only Options: Enabled: attributes.include list functions normally; attribute keys found in the attributes.include list are recorded. Disabled: Ignores the list of allowed attributes listed in the attributes.include property in agent configuration; no intrinsic request parameter attributes will be collected. Whitelisting attributes at the account level is not supported. Raw exception messages Options: Enabled: Allows recording of all raw exception messages. Disabled: Prevents recording of all raw exception messages. The messages may be either obfuscated or completely removed, depending on the agent. Custom events Options: Enabled: Allows the recording of custom events that are created and sent up via an agent API. Disabled: Prevents recording of any custom events collect by an agent API. Custom attributes Options: Enabled: Allows for the collection of custom attributes passed in by the New Relic agent. Disabled: Prevents collection of custom attributes that are collected by the New Relic agent. Custom instrumentation editor Java only Options: Enabled: Allows custom instrumentation of the agent, using the custom instrumentation editor. Disabled: Prevents custom instrumentation of the agent using the custom instrumentation editor. Instrumentation previously done via the editor is also disabled. Access to the custom instrumentation editor is only available to New Relic account Owners and Admins. Message parameters Java and Ruby only Options: Enabled: Allows the collection of message parameters (message.parameters.*). Disabled: Prevents collection of message parameters. Job arguments Ruby only Options: Enabled: Allows the collection of job arguments (job.(type).args.*). Disabled: Prevents the collection of job arguments. For more help For more information about configuration file settings, refer to your specific agent's documentation. If you are a New Relic customer and interested in the limited release of configurable security policies, contact your New Relic sales rep.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.29128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable <em>configurable</em> security policies",
        "sections": "Enable <em>configurable</em> security policies",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": ". If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your <em>APM</em> <em>agent</em>&#x27;s high security mode, which is set in the <em>configuration</em> file. High security mode and configurable security policies do not apply to Lambda monitoring or use"
      },
      "id": "6043d4a8196a6773a1960f68"
    },
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-10-18T03:55:42Z",
      "updated_at": "2021-09-14T10:34:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.1689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> <em>configuration</em>",
        "sections": "Server-side <em>agent</em> <em>configuration</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side <em>configuration</em> precedence This feature provides the convenience of managing the available <em>configuration</em>"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.02861,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " instrumentation: <em>Configuration</em> file: Use the <em>agent</em> <em>configuration</em> file to specify the functions and methods you want instrumented. The <em>agent</em> <em>configuration</em> file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/enable-configurable-security-policies": [
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-10-18T03:55:42Z",
      "updated_at": "2021-09-14T10:34:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.1689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> <em>configuration</em>",
        "sections": "Server-side <em>agent</em> <em>configuration</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side <em>configuration</em> precedence This feature provides the convenience of managing the available <em>configuration</em>"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.02861,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " instrumentation: <em>Configuration</em> file: Use the <em>agent</em> <em>configuration</em> file to specify the functions and methods you want instrumented. The <em>agent</em> <em>configuration</em> file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-10-18T02:26:15Z",
      "updated_at": "2021-09-14T10:33:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.40456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work with each"
      },
      "id": "603ebde1196a677dbaa83dec"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/high-security-mode": [
    {
      "sections": [
        "Enable configurable security policies",
        "Important",
        "Compatibility and requirements",
        "Caution",
        "Example configuration",
        "Java agent: YAML example",
        ".NET agent: XML example",
        "Ruby agent: YAML example",
        "Available policy options",
        "For more help"
      ],
      "title": "Enable configurable security policies",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "1f645201e6e79a35f84334b11415e8a2a0edf665",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/enable-configurable-security-policies/",
      "published_at": "2021-10-18T02:27:11Z",
      "updated_at": "2021-09-14T14:49:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important APM's configurable security policies is available in limited release for approved New Relic accounts. APM's configurable security policies gives you granular control over configuration options related to your account's data security. This document explains how to enable account-wide security policies and the options available. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Compatibility and requirements APM agent versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security policies Caution Security policies apply account-wide. Once enabled, they can only be edited or disabled with the help of New Relic support. If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your APM agent's high security mode, which is set in the configuration file. High security mode and configurable security policies do not apply to Lambda monitoring or use of the New Relic Event API. For the limited release, there is no UI component. If you are participating in the limited release, follow this procedure to set up your accounts: Choose the accounts on which to enable configurable security policies. Choose the configurable security policies options that you want for those accounts. Inform your New Relic sales rep of the options that you have chosen. Ensure your agent versions support this feature. Update agents if necessary. When you receive the security token based on the security policies options that you chose, insert the security token into the agent configuration file(s). See examples. Delete the high security mode enabled flag from your config file(s). High security mode (HSM) at the agent level is different than high security mode at the account level. Be sure to disable HSM in the agent's config file, as explained in this procedure. Having both the security token and the HSM flag will result in the agent disconnecting. Example configuration Here are some example configuration examples for enabling the configurable security policies: Java agent: YAML example The Java agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy .NET agent: XML example The .NET agent uses a XML file for configuration. Here is an example snippet enabling security policies: ... <configuration agentenabled=\"true\" xmlns=\"urn:newrelic-config\"> <service licensekey=\"YOUR_LICENSE_KEY\"> <application> <name>YOUR_APPLICATION_NAME</name> </application> <securityPoliciesToken>YOUR_TOKEN</securityPoliciesToken> <log level=\"info\"> </log></service></configuration> ... Copy If you prefer to use an environment variable, it would look like this: NEW_RELIC_SECURITY_POLICIES_TOKEN=YOUR_TOKEN Copy Ruby agent: YAML example The Ruby agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy Available policy options Here are the settings you can choose when creating your policies. Some of these options will not be available for some agents. Setting Effect Database query collection Options: Enabled: Collects obfuscated database query data. Obfuscated queries generally appear along with slow query details in the APM or New Relic One UI. Disabled: Prevents the collection of obfuscated database query data. Raw query data is not collected once configurable security policies is enabled. attributes.include list Go, Java, .NET, Node.js, Ruby only Options: Enabled: attributes.include list functions normally; attribute keys found in the attributes.include list are recorded. Disabled: Ignores the list of allowed attributes listed in the attributes.include property in agent configuration; no intrinsic request parameter attributes will be collected. Whitelisting attributes at the account level is not supported. Raw exception messages Options: Enabled: Allows recording of all raw exception messages. Disabled: Prevents recording of all raw exception messages. The messages may be either obfuscated or completely removed, depending on the agent. Custom events Options: Enabled: Allows the recording of custom events that are created and sent up via an agent API. Disabled: Prevents recording of any custom events collect by an agent API. Custom attributes Options: Enabled: Allows for the collection of custom attributes passed in by the New Relic agent. Disabled: Prevents collection of custom attributes that are collected by the New Relic agent. Custom instrumentation editor Java only Options: Enabled: Allows custom instrumentation of the agent, using the custom instrumentation editor. Disabled: Prevents custom instrumentation of the agent using the custom instrumentation editor. Instrumentation previously done via the editor is also disabled. Access to the custom instrumentation editor is only available to New Relic account Owners and Admins. Message parameters Java and Ruby only Options: Enabled: Allows the collection of message parameters (message.parameters.*). Disabled: Prevents collection of message parameters. Job arguments Ruby only Options: Enabled: Allows the collection of job arguments (job.(type).args.*). Disabled: Prevents the collection of job arguments. For more help For more information about configuration file settings, refer to your specific agent's documentation. If you are a New Relic customer and interested in the limited release of configurable security policies, contact your New Relic sales rep.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.29128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable <em>configurable</em> security policies",
        "sections": "Enable <em>configurable</em> security policies",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": ". If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your <em>APM</em> <em>agent</em>&#x27;s high security mode, which is set in the <em>configuration</em> file. High security mode and configurable security policies do not apply to Lambda monitoring or use"
      },
      "id": "6043d4a8196a6773a1960f68"
    },
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-10-18T03:55:42Z",
      "updated_at": "2021-09-14T10:34:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.1689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> <em>configuration</em>",
        "sections": "Server-side <em>agent</em> <em>configuration</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side <em>configuration</em> precedence This feature provides the convenience of managing the available <em>configuration</em>"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.02861,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " instrumentation: <em>Configuration</em> file: Use the <em>agent</em> <em>configuration</em> file to specify the functions and methods you want instrumented. The <em>agent</em> <em>configuration</em> file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration": [
    {
      "sections": [
        "Enable configurable security policies",
        "Important",
        "Compatibility and requirements",
        "Caution",
        "Example configuration",
        "Java agent: YAML example",
        ".NET agent: XML example",
        "Ruby agent: YAML example",
        "Available policy options",
        "For more help"
      ],
      "title": "Enable configurable security policies",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "1f645201e6e79a35f84334b11415e8a2a0edf665",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/enable-configurable-security-policies/",
      "published_at": "2021-10-18T02:27:11Z",
      "updated_at": "2021-09-14T14:49:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important APM's configurable security policies is available in limited release for approved New Relic accounts. APM's configurable security policies gives you granular control over configuration options related to your account's data security. This document explains how to enable account-wide security policies and the options available. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Compatibility and requirements APM agent versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security policies Caution Security policies apply account-wide. Once enabled, they can only be edited or disabled with the help of New Relic support. If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your APM agent's high security mode, which is set in the configuration file. High security mode and configurable security policies do not apply to Lambda monitoring or use of the New Relic Event API. For the limited release, there is no UI component. If you are participating in the limited release, follow this procedure to set up your accounts: Choose the accounts on which to enable configurable security policies. Choose the configurable security policies options that you want for those accounts. Inform your New Relic sales rep of the options that you have chosen. Ensure your agent versions support this feature. Update agents if necessary. When you receive the security token based on the security policies options that you chose, insert the security token into the agent configuration file(s). See examples. Delete the high security mode enabled flag from your config file(s). High security mode (HSM) at the agent level is different than high security mode at the account level. Be sure to disable HSM in the agent's config file, as explained in this procedure. Having both the security token and the HSM flag will result in the agent disconnecting. Example configuration Here are some example configuration examples for enabling the configurable security policies: Java agent: YAML example The Java agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy .NET agent: XML example The .NET agent uses a XML file for configuration. Here is an example snippet enabling security policies: ... <configuration agentenabled=\"true\" xmlns=\"urn:newrelic-config\"> <service licensekey=\"YOUR_LICENSE_KEY\"> <application> <name>YOUR_APPLICATION_NAME</name> </application> <securityPoliciesToken>YOUR_TOKEN</securityPoliciesToken> <log level=\"info\"> </log></service></configuration> ... Copy If you prefer to use an environment variable, it would look like this: NEW_RELIC_SECURITY_POLICIES_TOKEN=YOUR_TOKEN Copy Ruby agent: YAML example The Ruby agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy Available policy options Here are the settings you can choose when creating your policies. Some of these options will not be available for some agents. Setting Effect Database query collection Options: Enabled: Collects obfuscated database query data. Obfuscated queries generally appear along with slow query details in the APM or New Relic One UI. Disabled: Prevents the collection of obfuscated database query data. Raw query data is not collected once configurable security policies is enabled. attributes.include list Go, Java, .NET, Node.js, Ruby only Options: Enabled: attributes.include list functions normally; attribute keys found in the attributes.include list are recorded. Disabled: Ignores the list of allowed attributes listed in the attributes.include property in agent configuration; no intrinsic request parameter attributes will be collected. Whitelisting attributes at the account level is not supported. Raw exception messages Options: Enabled: Allows recording of all raw exception messages. Disabled: Prevents recording of all raw exception messages. The messages may be either obfuscated or completely removed, depending on the agent. Custom events Options: Enabled: Allows the recording of custom events that are created and sent up via an agent API. Disabled: Prevents recording of any custom events collect by an agent API. Custom attributes Options: Enabled: Allows for the collection of custom attributes passed in by the New Relic agent. Disabled: Prevents collection of custom attributes that are collected by the New Relic agent. Custom instrumentation editor Java only Options: Enabled: Allows custom instrumentation of the agent, using the custom instrumentation editor. Disabled: Prevents custom instrumentation of the agent using the custom instrumentation editor. Instrumentation previously done via the editor is also disabled. Access to the custom instrumentation editor is only available to New Relic account Owners and Admins. Message parameters Java and Ruby only Options: Enabled: Allows the collection of message parameters (message.parameters.*). Disabled: Prevents collection of message parameters. Job arguments Ruby only Options: Enabled: Allows the collection of job arguments (job.(type).args.*). Disabled: Prevents the collection of job arguments. For more help For more information about configuration file settings, refer to your specific agent's documentation. If you are a New Relic customer and interested in the limited release of configurable security policies, contact your New Relic sales rep.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.29126,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable <em>configurable</em> security policies",
        "sections": "Enable <em>configurable</em> security policies",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": ". If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your <em>APM</em> <em>agent</em>&#x27;s high security mode, which is set in the <em>configuration</em> file. High security mode and configurable security policies do not apply to Lambda monitoring or use"
      },
      "id": "6043d4a8196a6773a1960f68"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.0286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " instrumentation: <em>Configuration</em> file: Use the <em>agent</em> <em>configuration</em> file to specify the functions and methods you want instrumented. The <em>agent</em> <em>configuration</em> file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-10-18T02:26:15Z",
      "updated_at": "2021-09-14T10:33:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.40456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work with each"
      },
      "id": "603ebde1196a677dbaa83dec"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/view-config-values-your-app": [
    {
      "sections": [
        "Enable configurable security policies",
        "Important",
        "Compatibility and requirements",
        "Caution",
        "Example configuration",
        "Java agent: YAML example",
        ".NET agent: XML example",
        "Ruby agent: YAML example",
        "Available policy options",
        "For more help"
      ],
      "title": "Enable configurable security policies",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "1f645201e6e79a35f84334b11415e8a2a0edf665",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/enable-configurable-security-policies/",
      "published_at": "2021-10-18T02:27:11Z",
      "updated_at": "2021-09-14T14:49:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important APM's configurable security policies is available in limited release for approved New Relic accounts. APM's configurable security policies gives you granular control over configuration options related to your account's data security. This document explains how to enable account-wide security policies and the options available. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Compatibility and requirements APM agent versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security policies Caution Security policies apply account-wide. Once enabled, they can only be edited or disabled with the help of New Relic support. If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your APM agent's high security mode, which is set in the configuration file. High security mode and configurable security policies do not apply to Lambda monitoring or use of the New Relic Event API. For the limited release, there is no UI component. If you are participating in the limited release, follow this procedure to set up your accounts: Choose the accounts on which to enable configurable security policies. Choose the configurable security policies options that you want for those accounts. Inform your New Relic sales rep of the options that you have chosen. Ensure your agent versions support this feature. Update agents if necessary. When you receive the security token based on the security policies options that you chose, insert the security token into the agent configuration file(s). See examples. Delete the high security mode enabled flag from your config file(s). High security mode (HSM) at the agent level is different than high security mode at the account level. Be sure to disable HSM in the agent's config file, as explained in this procedure. Having both the security token and the HSM flag will result in the agent disconnecting. Example configuration Here are some example configuration examples for enabling the configurable security policies: Java agent: YAML example The Java agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy .NET agent: XML example The .NET agent uses a XML file for configuration. Here is an example snippet enabling security policies: ... <configuration agentenabled=\"true\" xmlns=\"urn:newrelic-config\"> <service licensekey=\"YOUR_LICENSE_KEY\"> <application> <name>YOUR_APPLICATION_NAME</name> </application> <securityPoliciesToken>YOUR_TOKEN</securityPoliciesToken> <log level=\"info\"> </log></service></configuration> ... Copy If you prefer to use an environment variable, it would look like this: NEW_RELIC_SECURITY_POLICIES_TOKEN=YOUR_TOKEN Copy Ruby agent: YAML example The Ruby agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy Available policy options Here are the settings you can choose when creating your policies. Some of these options will not be available for some agents. Setting Effect Database query collection Options: Enabled: Collects obfuscated database query data. Obfuscated queries generally appear along with slow query details in the APM or New Relic One UI. Disabled: Prevents the collection of obfuscated database query data. Raw query data is not collected once configurable security policies is enabled. attributes.include list Go, Java, .NET, Node.js, Ruby only Options: Enabled: attributes.include list functions normally; attribute keys found in the attributes.include list are recorded. Disabled: Ignores the list of allowed attributes listed in the attributes.include property in agent configuration; no intrinsic request parameter attributes will be collected. Whitelisting attributes at the account level is not supported. Raw exception messages Options: Enabled: Allows recording of all raw exception messages. Disabled: Prevents recording of all raw exception messages. The messages may be either obfuscated or completely removed, depending on the agent. Custom events Options: Enabled: Allows the recording of custom events that are created and sent up via an agent API. Disabled: Prevents recording of any custom events collect by an agent API. Custom attributes Options: Enabled: Allows for the collection of custom attributes passed in by the New Relic agent. Disabled: Prevents collection of custom attributes that are collected by the New Relic agent. Custom instrumentation editor Java only Options: Enabled: Allows custom instrumentation of the agent, using the custom instrumentation editor. Disabled: Prevents custom instrumentation of the agent using the custom instrumentation editor. Instrumentation previously done via the editor is also disabled. Access to the custom instrumentation editor is only available to New Relic account Owners and Admins. Message parameters Java and Ruby only Options: Enabled: Allows the collection of message parameters (message.parameters.*). Disabled: Prevents collection of message parameters. Job arguments Ruby only Options: Enabled: Allows the collection of job arguments (job.(type).args.*). Disabled: Prevents the collection of job arguments. For more help For more information about configuration file settings, refer to your specific agent's documentation. If you are a New Relic customer and interested in the limited release of configurable security policies, contact your New Relic sales rep.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.29126,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable <em>configurable</em> security policies",
        "sections": "Enable <em>configurable</em> security policies",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": ". If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your <em>APM</em> <em>agent</em>&#x27;s high security mode, which is set in the <em>configuration</em> file. High security mode and configurable security policies do not apply to Lambda monitoring or use"
      },
      "id": "6043d4a8196a6773a1960f68"
    },
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "928ff211d9e5aa0e02dc64ed344e8cbbd3ea91b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-10-18T03:55:42Z",
      "updated_at": "2021-09-14T10:34:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.16888,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> <em>configuration</em>",
        "sections": "Server-side <em>agent</em> <em>configuration</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side <em>configuration</em> precedence This feature provides the convenience of managing the available <em>configuration</em>"
      },
      "id": "6043c83b64441fc5d6378ed1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.0286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " instrumentation: <em>Configuration</em> file: Use the <em>agent</em> <em>configuration</em> file to specify the functions and methods you want instrumented. The <em>agent</em> <em>configuration</em> file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    }
  ],
  "/docs/agents/manage-apm-agents/troubleshooting/agent-nrintegrationerrors-appear-insights": [
    {
      "sections": [
        "Get environment data about your APM app",
        "Problem",
        "Solution"
      ],
      "title": "Get environment data about your APM app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Troubleshooting"
      ],
      "external_id": "9069ed185cb57e0fad63414989a52238f2c5378c",
      "image": "https://docs.newrelic.com/static/1a6d2627ddd9082d34cdd5b81cc29035/c1b63/troubleshooting-apm-environment.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/troubleshooting/get-environment-data-about-your-apm-app/",
      "published_at": "2021-10-18T12:43:55Z",
      "updated_at": "2021-05-16T12:35:18Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You need an easy way to get information about your application's environment, such as: What services a particular agent version is using What apps have outdated agent versions What hosts use which agents What values apply to specific agent settings Solution To see which services and settings apply to an agent, or to see which agent uses a specific service or setting, go to one.newrelic.com. Click on your app in the list, then click Settings > Environment > Environment snapshot. The Environment snapshot page helps you connect payloads from agents that include environment data, so you have a sense of what monitoring data is recorded. This also helps you more easily identify discrepancies across your services, and determine what might need to be updated. In the following example, the user mouses over the second agent on the list. Most of the settings for this agent are consistent with others, but it's easy to see specific host settings for logical processors, physical cores, and Ruby patch levels. Also notice that this agent is using an earlier Ruby version. one.newrelic.com > APM > Settings > Environment > Environment snapshot: To see specific settings that apply to an agent and its services, or to see which of a setting's values apply to specific agents, mouse over any agent or value. Information on the Environment snapshot page depends on the APM agent you use. For example, apps using the Ruby agent show settings for gems, while apps using the Java agent show settings for jars.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.70709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get environment data about your <em>APM</em> app",
        "sections": "Get environment data about your <em>APM</em> app",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " and its services, or to see which of a setting&#x27;s values apply to specific <em>agents</em>, mouse over any <em>agent</em> or value. Information on the Environment snapshot page depends on the <em>APM</em> <em>agent</em> you use. For example, apps using the Ruby <em>agent</em> show settings for gems, while apps using the Java <em>agent</em> show settings for jars."
      },
      "id": "603e7f6064441f5b464e888f"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-10-18T02:25:25Z",
      "updated_at": "2021-09-14T10:31:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the data explorer to start building a chart. Select the advanced (NRQL) mode to refine your query. In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.775764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0 or higher Go"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.75052,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": ": Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the <em>APM</em> Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    }
  ],
  "/docs/agents/manage-apm-agents/troubleshooting/get-environment-data-about-your-apm-app": [
    {
      "sections": [
        "APM agent NRIntegrationError config mismatch issue",
        "Problem",
        "Solution",
        "Go",
        "Tip",
        "Java",
        ".NET",
        "Node.js",
        "Python",
        "Ruby"
      ],
      "title": "APM agent NRIntegrationError config mismatch issue",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Troubleshooting"
      ],
      "external_id": "9d5fdee59e1e3c4d6adc390741171e86274d1caa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/troubleshooting/agent-nrintegrationerrors-appear-insights/",
      "published_at": "2021-10-18T20:55:11Z",
      "updated_at": "2021-08-09T00:02:55Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem An NrIntegrationError event is generated that has the following message: Configuration mismatch: Agent configured harvest limit for EVENT TYPE exceeds maximum limit; limit adjusted to LIMIT Copy Solution This is caused by a configuration mismatch with the agent. See the relevant agent solution to resolve your configuration mismatch: Go In your newrelic.Config: For transaction events, adjust the value of TransactionEvents.MaxSamplesStored. Tip The Go Agent currently does not support adjusting this value for custom events. Java In your newrelic.yml: For transaction events, adjust the value of transaction_events.max_samples_stored. For custom events, adjust the value of custom_events.max_samples_stored. .NET In your newrelic.config: For transaction events, adjust the value of the maximumSamplesStored attribute under the transactionEvents element. For custom events, adjust the value of the maximumSamplesStored attribute under the customEvents element. Node.js For transaction events, in the transaction_events: { section of your app's newrelic.js, adjust the value of max_samples_per_minute. For custom events, in the custom_insights_events: { section of your app's newrelic.js, adjust the value of max_samples_stored. Python In your newrelic.ini: For transaction events, adjust the value of event_harvest_config. harvest_limits.analytic_event_data. For custom events, adjust the value of event_harvest_config.harvest_limits.custom_event_data. For error events, adjust the value of event_harvest_config.harvest_limits.error_event_data. For span events, adjust the value of event_harvest_config.harvest_limits.span_event_data. Ruby In your newrelic.yml: For transaction events, adjust the value of analytics_events.max_samples_stored. For custom events, adjust the value of custom_events.max_samples_stored. For error events, adjust the value of error_collector.max_event_samples_stored. Tip This error does not apply to the C SDK or PHP agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.31335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>APM</em> <em>agent</em> NRIntegrationError config mismatch issue",
        "sections": "<em>APM</em> <em>agent</em> NRIntegrationError config mismatch issue",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "Problem An NrIntegrationError event is generated that has the following message: Configuration mismatch: <em>Agent</em> configured harvest limit for EVENT TYPE exceeds maximum limit; limit adjusted to LIMIT Copy Solution This is caused by a configuration mismatch with the <em>agent</em>. See the relevant <em>agent</em>"
      },
      "id": "603ec0f9e7b9d2da412a07d6"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-10-18T02:25:25Z",
      "updated_at": "2021-09-14T10:31:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the data explorer to start building a chart. Select the advanced (NRQL) mode to refine your query. In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.775764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0 or higher Go"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Custom instrumentation",
        "Important",
        "When to use custom instrumentation",
        "Implement custom instrumentation",
        "C SDK custom instrumentation",
        "Go custom instrumentation",
        "Java custom instrumentation",
        ".NET custom instrumentation",
        "Node.js custom instrumentation",
        "PHP custom instrumentation",
        "Python custom instrumentation",
        "Ruby custom instrumentation",
        "Grouping issues"
      ],
      "title": "Custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "2e6cd68b3d93f9ed716ca25b96aac87d4520de75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/custom-instrumentation/",
      "published_at": "2021-10-18T02:24:45Z",
      "updated_at": "2021-09-14T09:20:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web transactions and non-web transactions, such as background tasks. New Relic normally produces complete information automatically, without any need to modify your application code. However, if you are not using a supported framework, you may need to add custom instrumentation. Custom instrumentation is also useful to: Add detail to your transaction traces. Block instrumentation on selected transactions you do not want instrumented. Instrument a part of your code that New Relic simply is not picking up. Custom instrumentation that creates a new transaction collects both metric timeslice and event data. Custom instrumentation for already instrumented transactions collects only metric timeslice data. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. When to use custom instrumentation Custom instrumentation allows you to track interactions that are not captured by New Relic's automatic instrumentation. Custom instrumentation can also add detail to your transaction traces, to help you identify key issues. New Relic collects data from many frameworks automatically. If you are using a supported framework, you should not need custom instrumentation to collect metric timeslices, events, and traces. However, if you encounter any of these situations, you may need custom instrumentation: Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the APM Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working. Implement custom instrumentation Each agent implements custom instrumentation differently: C SDK custom instrumentation For applications monitored by the C SDK, you must manually instrument transactions, segments, and errors. For more information, see the C SDK instrumentation procedures. Go custom instrumentation Because Golang apps run from a compiled, native binary file, all New Relic instrumentation must be done manually. See Instrument Go transactions and Instrument Go segments for how to set up instrumentation in your Go app. Java custom instrumentation New Relic's Java agent supports two methods of custom instrumentation: Annotation: Add @Trace annotations to your code to ensure New Relic instruments specific methods. Annotation is easy to implement, if you are instrumenting only a few methods. For more complex instrumentation, or if you are unable to modify your code, use XML. XML: Define the methods you want New Relic to monitor in an XML file. XML instrumentation is flexible and doesn't require editing your code, but is more difficult to troubleshoot than annotation. For more information, see Java custom instrumentation. .NET custom instrumentation New Relic's .NET agent supports two methods of custom instrumentation: Attributes: Annotate your code with agent API calls to instrument specific methods. Annotation is easy to implement, but requires editing your source code. XML: Define the methods you want New Relic to instrument in an XML file. XML instrumentation does not require modifying your source code, but is more complicated to create and keep updated than attribute instrumentation. For more information, see Introduction to .NET custom instrumentation. Node.js custom instrumentation New Relic's Node.js agent uses API calls for custom instrumentation. For more information, see Node.js custom instrumentation. PHP custom instrumentation New Relic's PHP agent uses API calls for custom instrumentation. For more information, see PHP custom instrumentation. Python custom instrumentation New Relic's Python agent supports two methods of custom instrumentation: Configuration file: Use the agent configuration file to specify the functions and methods you want instrumented. The agent configuration file is easy to set up, and it does not require you to modify your code. However, it is less flexible than API calls. API calls: Edit your code to call the New Relic Python API. The API is more flexible than instrumentation via the configuration file, but it requires you to modify your code. For more information, see Python custom instrumentation. Ruby custom instrumentation New Relic's Ruby agent uses API calls to define target methods and add transaction tracers to them. For more information, see Ruby custom instrumentation. Grouping issues A metric grouping issue occurs when an account sends too many differently-named metric timeslices to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. Custom instrumentation can cause metric grouping issues if you introduce too many uniquely-named metric timeslices that New Relic cannot effectively group. If you send thousands of metrics, New Relic may apply rules to reduce the number of transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.75052,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": ": Transactions do not appear in the UI. Transaction traces include large blocks of application code time without full detail. If you are using a supported framework, but are not seeing transaction on the <em>APM</em> Transactions page, get support at support.newrelic.com to ensure the framework instrumentation is working"
      },
      "id": "603eb8b928ccbc1a79eba78c"
    }
  ],
  "/docs/agents/net-agent/api-guides/guide-using-net-agent-api": [
    {
      "sections": [
        "SetApplicationName (.NET agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Important",
        "Parameters",
        "Examples"
      ],
      "title": "SetApplicationName (.NET agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "3fb6b95c0ba28e634b4bff22b55f29fb9163f2ae",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/net-agent-api/set-application-name/",
      "published_at": "2021-10-18T05:47:59Z",
      "updated_at": "2021-10-01T14:07:17Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.Api.Agent.NewRelic.SetApplicationName(string $name[, string $name_2, string $name_3]) Copy Set the app name for data rollup. Requirements Agent version 5.0.136.0 or higher. Compatible with all app types. Description Set the application name(s) reported to New Relic. For more information about application naming, see Name your .NET application. This method is intended to be called once, during startup of an application. Important Updating the app name forces the agent to restart. The agent discards any unreported data associated with previous app names. Changing the app name multiple times during the lifecycle of an application is not recommended due to the associated data loss. Parameters Parameter Description $name string Required. The primary application name. $name_2 $name_3 string Optional. Second and third names for app rollup. For more information, see Use multiple names for an app. Examples NewRelic.Api.Agent.NewRelic.SetApplicationName(\"AppName1\", \"AppName2\"); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.48831,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SetApplicationName (.<em>NET</em> <em>agent</em> <em>API</em>)",
        "sections": "SetApplicationName (.<em>NET</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax NewRelic.<em>Api.Agent</em>.NewRelic.SetApplicationName(string $name[, string $name_2, string $name_3]) Copy Set the app name for data rollup. Requirements <em>Agent</em> version 5.0.136.0 or higher. Compatible with all app types. Description Set the application name(s) reported to New Relic. For more"
      },
      "id": "6044132628ccbc6f972e99b3"
    },
    {
      "sections": [
        "Node.js agent API",
        "Request names",
        "Tip",
        "Requirements",
        "Avoid metric grouping issues",
        "Guidelines",
        "URL pattern matching",
        "Load the request naming API",
        "Request API calls",
        "newrelic.setTransactionName(name)",
        "newrelic.setControllerName(name, [action])",
        "Custom instrumentation API calls",
        "newrelic.instrument(moduleName, onRequire [, onError])",
        "newrelic.instrumentDatastore(moduleName, onRequire [, onError])",
        "newrelic.instrumentLoadedModule(moduleName, moduleInstance)",
        "Important",
        "newrelic.instrumentMessages(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentWebframework(moduleName, onRequire [, onError])",
        "newrelic.startWebTransaction(url, handle)",
        "newrelic.startBackgroundTransaction(name, [group], handle)",
        "newrelic.getTransaction()",
        "newrelic.endTransaction()",
        "newrelic.startSegment(name, record, handler, callback)",
        "Custom metrics API calls",
        "newrelic.recordMetric(name, value)",
        "newrelic.incrementMetric(name, [amount])",
        "Custom events API calls",
        "newrelic.recordCustomEvent(eventType, attributes)",
        "Recording a custom event",
        "Transaction handle methods",
        "transactionHandle.end([callback])",
        "transactionHandle.ignore()",
        "transactionHandle.insertDistributedTraceHeaders(headers)",
        "Generating distributed trace headers",
        "transactionHandle.acceptDistributedTraceHeaders(transportType, headers)",
        "Accept incoming distributed trace headers",
        "transactionHandle.createDistributedTracePayload()",
        "Caution",
        "Link a nested background transaction",
        "Place payload on an outgoing request",
        "transactionHandle.acceptDistributedTracePayload(payload)",
        "transactionHandle.isSampled()",
        "Other API calls",
        "newrelic.addCustomAttribute(name, value)",
        "Add custom attribute",
        "newrelic.addCustomAttributes(attributes)",
        "Adding custom attributes",
        "newrelic.addCustomSpanAttribute(name, value)",
        "Add custom span attribute",
        "newrelic.addCustomSpanAttributes(attributes)",
        "Add custom span attributes",
        "newrelic.getBrowserTimingHeader()",
        "newrelic.setIgnoreTransaction(ignored)",
        "newrelic.noticeError(error, [customParameters])",
        "newrelic.shutdown([options], callback)",
        "newrelic.getLinkingMetadata()",
        "newrelic.getTraceMetadata()",
        "Rules for naming and ignoring requests",
        "rules.name",
        "Optional rules attributes [#optional-rules]",
        "Testing your naming rules [#testing-rules]",
        "Naming rule examples [#examples-rules]",
        "Match full URL",
        "Replace first match in URL",
        "Replace all matches in any URL",
        "Match group references",
        "rules.ignore",
        "Naming rule example",
        "Ignoring rule example",
        "API calls for rules",
        "newrelic.addNamingRule(pattern, name)",
        "newrelic.addIgnoringRule(pattern)"
      ],
      "title": "Node.js agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "API guides"
      ],
      "external_id": "dd0838adbfafc7e5988ed77ad3ad039cdce29ec0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/api-guides/nodejs-agent-api/",
      "published_at": "2021-10-18T02:58:57Z",
      "updated_at": "2021-09-30T20:50:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several tools to help obtain the information needed to provide useful metrics about your Node.js application. These include: Reading the route names (if used) from the Express and Restify routers Using the API to name the current request, either with simple names or groups of controllers with actions Support rules that are stored in your agent's configuration that can mark requests to be renamed or ignored based on regular expressions matched against the request's raw URLs (also available as API calls) The number of names that New Relic tracks needs to be small enough so that the user experience is robust. It also needs to be large enough to provide the right amount of information (without overwhelming you with data) so that you can identify problem spots in your applications more easily. For more information, see the Node.js agent configuration documentation and the Node.js agent API documentation on Github. Request names The Node.js agent captures the HTTP method along with a potentially parameterized path (such as /user/:id) or a regular expression (such as /^/user/([-0-9a-f]+)$/). These pieces of information become part of the request name. If you have support for slow transaction traces and have enabled capture_params in your config file, the transaction trace will also have the request's parameters and their values attached to it. If you are dissatisfied with the request names that the Node.js agent uses, you can use API calls to create more descriptive names. Tip If grouping your requests under the generic name, then /* is sufficient, and you do not need to customize your configuration file or API calls. Requirements New Relic uses request names to group requests for many charts and tables. The value of these visualizations will drop as the number of different request names increases. For example, do not include potentially dynamic data like GUIDs, numerical IDs, or timestamps in the request names you create. If your request is slow enough to generate a transaction trace, that trace will contain the original URL. If you enable parameter capture, the parameters will also be attached to the trace. Tip Avoid having more than 50 different transaction names. For example, if you have more than a couple hundred different request names, rethink your naming strategy. Avoid metric grouping issues The request naming API helps New Relic avoid problems with trying to handle too many metrics, which sometimes is referred to as \"metric explosion.\" New Relic has several strategies to deal with these issues; the most severe is simply to add offending applications to your deny list. The main reason for you to be careful in using these request-naming tools is to prevent that from happening to your applications. For more information, see Metric grouping issues. Guidelines Define your configuration rules from the most specific to the most general. The first rules listed in your config file or added with the Node.js transaction naming API will be applied first and should be narrowly targeted. More general \"fall-through\" rules should be added toward the end of the list, because they will be evaluated in the order they were configured or added using the Node.js transaction naming API. URL pattern matching An online retailer has a URL pattern like this: /user/customers/all/prospects /user/customers/all/current /user/customers/all/returning /user/customers/John /user/customers/Jane Copy The retailer could create rules like this: // newrelic.js exports.config={ //other configuration rules:{ name:[ { pattern: \"/user/customers/all/prospects/\", name: \"/user/customers/all/prospects\" }, { pattern: \"/user/customers/all/.*\", name: \"/user/customers/all\" }, { pattern: \"/user/customers/.*\", name: \"/user/customers/:customer\" } ] } } Copy With these rules, the retailer would create three transaction names: /user/customers/:customer /user/customers/all /user/customers/all/prospects If the retailer reversed the order, the rules would catch all transactions in :customer, which would not be as useful. Load the request naming API Make sure that loading the New Relic module is the first thing your application does, as it needs to bootstrap itself before the rest of your application loads: var newrelic = require('newrelic'); Copy This returns the request naming API. You can safely require the module from multiple modules in your application, as it only initializes itself once. Request API calls Here is a summary of the Request API calls for New Relic's Node.js agent. newrelic.setTransactionName(name) newrelic.setTransactionName(name) Copy Name the current request, following the request naming requirements. You can call this function anywhere within the context of an HTTP request handler, at any time after handling of the request has started, but before the request has finished. In general, if the request and response objects are in scope, you can set the name. Explicitly calling newrelic.setTransactionName() will override any names set by Express or Restify routes. Also, calls to newrelic.setTransactionName() and newrelic.setControllerName() will overwrite each other. The last one to run before the request ends wins. newrelic.setControllerName(name, [action]) newrelic.setControllerName(name, [action]) Copy Name the current request using a controller-style pattern, optionally including the current controller action. If the action is omitted, New Relic will include the HTTP method (GET, POST, etc.) as the action. The rules for when you can call newrelic.setControllerName() are the same as they are for newrelic.setTransactionName(), including the request naming requirements. Explicitly calling newrelic.setControllerName() will override any names set by Express or Restify routes. Also, calls to newrelic.setTransactionName() and newrelic.setControllerName() will overwrite each other. The last one to run before the request ends wins. Custom instrumentation API calls Use these API calls to expand your instrumentation with custom instrumentation. newrelic.instrument(moduleName, onRequire [, onError]) newrelic.instrument(moduleName, onRequire [, onError]) Copy Sets an instrumentation callback for a specific module. The provided onRequire callback will be fired when the given module is loaded with require. The moduleName parameter should be the string that will be passed to require; for example, 'express' or 'amqplib/callback_api'. The optional onError callback is called if the onRequire parameters throws an error. This is useful for debugging your instrumentation. Use this method to: Add instrumentation for modules not currently instrumented by New Relic. Instrument your own code. Replace the Node.js agent's built-in instrumentation with your own. For more information, see New Relic's Node.js instrumentation tutorial on Github. newrelic.instrumentDatastore(moduleName, onRequire [, onError]) newrelic.instrumentDatastore(moduleName, onRequire [, onError]) Copy Sets an instrumentation callback for a datastore module. This method is just like newrelic.instrument(), except it provides a datastore-specialized shim. For more information, see New Relic's Node.js datastore instrumentation tutorial on Github. newrelic.instrumentLoadedModule(moduleName, moduleInstance) newrelic.instrumentLoadedModule(moduleName, moduleInstance) Copy The instrumentLoadedModule method allows you to add stock instrumentation to specific modules in situations where it's impossible to have require('newrelic'); as the first line of your app's main module. // load the agent const newrelic = require('newrelic') // module loaded before newrelic const expressModule = require('express') // instrument express _after_ the agent has been loaded newrelic.instrumentLoadedModule( 'express', // the module's name, as a string expressModule // the module instance ); Copy Important This method cannot instrument any arbitrary module. Its purpose is to add modules that were missed because the agent was not loaded as the first thing in your program. The instrumentLoadedModule method can only instrument modules the agent would normally instrument. You can see a list of these modules in the agent's lib/instrumentations module. newrelic.instrumentMessages(moduleName, onRequire \\[, onError]) newrelic.instrumentMessages(moduleName, onRequire [, onError]) Copy Sets an instrumentation callback for a message service client module. This method is just like newrelic.instrument(), except it provides a message-service-specialized shim. For more information, see New Relic's Node.js message service instrumentation tutorial on Github. newrelic.instrumentWebframework(moduleName, onRequire [, onError]) newrelic.instrumentWebframework(moduleName, onRequire [, onError]) Copy Sets an instrumentation callback for a web framework module. This method is just like newrelic.instrument(), except it provides a web-framework-specialized shim. For more information, see New Relic's Node.js web framework instrumentation tutorial on Github. newrelic.startWebTransaction(url, handle) newrelic.startWebTransaction(url, handle) Copy Instrument the specified web transaction. Using this API call, you can instrument transactions that New Relic does not automatically detect. The url defines the transaction name and needs to be static. Do not include variable data such as user ID. The handle defines the function you want to instrument. New Relic will capture any metrics that would be captured by auto-instrumentation, as well as manual instrumentation via startSegment(). You must handle custom transactions manually by calling newrelic.getTransaction() at the start of your transaction, and then call transaction.end() when you are finished. New Relic begins timing the transaction when newrelic.startWebTransaction() is called and ends the transaction when transaction.end() is called. You can also return a promise to indicate the end of the transaction. Please note that if this promise rejects, it does not automatically hook into New Relics error tracking. This needs to be done manually with noticeError(). newrelic.startBackgroundTransaction(name, [group], handle) newrelic.startBackgroundTransaction(name, [group], handle) Copy Instrument the specified background transaction. Using this API call, you can expand New Relic's instrumentation to capture data from background transactions. The name defines the transaction name and needs to be static. Do not include variable data such as user ID. The group is optional, and it allows you to group similar jobs together via the transaction type in the user interface. Like name, the group needs to be static. The handle defines a function that includes the entire background job you want to instrument. New Relic will capture any metrics that would be captured by auto-instrumentation, as well as manual instrumentation via startSegment(). You must handle custom transactions manually by calling newrelic.getTransaction() at the start of your transaction, and then call transaction.end() when you are finished. New Relic begins timing the transaction when newrelic.startBackgroundTransaction() is called and ends the transaction when transaction.end() is called. You can also return a promise to indicate the end of the transaction. Please note that if this promise rejects, it does not automatically hook into New Relics error tracking. This needs to be done manually with noticeError(). newrelic.getTransaction() newrelic.getTransaction() Copy Returns a handle on the currently executing transaction. This handle can then be used to interact with a given transaction safely from any context. It is best used with newrelic.startWebTransaction() and newrelic.startBackgroundTransaction(). Please refer to the transaction handle section for more details. newrelic.endTransaction() newrelic.endTransaction() Copy End the current web or background custom transaction. This method requires being in the correct transaction context when called. This API call takes no arguments. newrelic.startSegment(name, record, handler, callback) newrelic.startSegment(name, record, handler, callback) Copy Instrument a particular method to improve visibility into a transaction, or optionally turn it into a metric. The name defines a name for the segment. This name will be visible in transaction traces and as a new metric in the New Relic UI. The record flag defines whether the segment should be recorded as a metric. The handler is the function you want to track as a segment. The optional callback is a function passed to the handler to fire after its work is done. The agent begins timing the segment when startSegment is called. The segment is ended when either the handler finishes executing, or callback is fired, if it is provided. Custom metrics API calls Use these API calls to record additional arbitrary metrics: newrelic.recordMetric(name, value) newrelic.recordMetric(name, value) Copy Use recordMetric to record an event-based metric, usually associated with a particular duration. The name must be a string following standard metric naming rules. The value will usually be a number, but it can also be an object. When value is a numeric value, it should represent the magnitude of a measurement associated with an event; for example, the duration for a particular method call. When value is an object, it must contain count, total, min, max, and sumOfSquares keys, all with number values. This form is useful to aggregate metrics on your own and report them periodically; for example, from a setInterval. These values will be aggregated with any previously collected values for the same metric. The names of these keys match the names of the keys used by the platform API. newrelic.incrementMetric(name, [amount]) newrelic.incrementMetric(name, [amount]) Copy Use incrementMetric to update a metric that acts as a simple counter. The count of the selected metric will be incremented by the specified amount, defaulting to 1. Custom events API calls Use these API calls to record additional events: newrelic.recordCustomEvent(eventType, attributes) newrelic.recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. Recording a custom event The following example demonstrates recording a custom event with multiple attributes. const attributes = { attribute1: 'value1', attribute2: 2 } newrelic.recordCustomEvent('MessagingEvent', attributes) Copy Transaction handle methods This section details the methods provided by the TransactionHandle class instance that can be obtained through newrelic.getTransaction(). Use these methods to interact directly with the current transaction: transactionHandle.end([callback]) transactionHandle.end([callback]) Copy Use transactionHandle.end to end the transaction referenced by the handle instance. The callback is invoked when the transaction has fully ended. The finished transaction passed to the callback as the first argument. transactionHandle.ignore() transactionHandle.ignore() Copy Use transactionHandle.ignore to ignore the transaction referenced by the handle instance. transactionHandle.insertDistributedTraceHeaders(headers) transactionHandle.insertDistributedTraceHeaders(headers) Copy Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call acceptDistributedTraceHeaders, first read Enable distributed tracing with agent APIs. transactionHandle.insertDistributedTraceHeaders is used to implement distributed tracing. It modifies the headers map that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with distributed_tracing.exclude_newrelic_header: true in the config. This method replaces the deprecated createDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Generating distributed trace headers In the following example, by calling insertDistributedTraceHeaders with an empty object, the appropriate Distributed Trace headers and W3C Trace Context headers will be generated for the transaction. // Call newrelic.getTransaction to retrieve a handle on the current transaction. const transactionHandle = newrelic.getTransaction() // This could be a header object from an incoming request as well const headersObject = {} newrelic.startBackgroundTransaction('background task', function executeTransaction() { const transaction = newrelic.getTransaction() // generate the headers transaction.insertDistributedTraceHeaders(headersObject) }) Copy transactionHandle.acceptDistributedTraceHeaders(transportType, headers) transactionHandle.acceptDistributedTraceHeaders(transportType, headers) Copy Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call insertDistributedTraceHeaders, first read Enable distributed tracing with agent APIs. transactionHandle.acceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by insertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated (and now removed as of version 7.0.0) acceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. transportType should be one of the following strings: AMQP HTTP HTTPS IronMQ JMS Kafka Other Queue Unknown headers should be an object containing all the headers in the incoming request. The keys must be lowercase. Accept incoming distributed trace headers The following example demonstrates adding distributed trace headers retrieved from a Kafka message. In this example, we assume that the incoming Kafka message has Distributed Trace headers inserted. // incoming Kafka message headers const headersObject = message.headers // Call newrelic.getTransaction to retrieve a handle on the current transaction. const transactionHandle = newrelic.getTransaction() newrelic.startBackgroundTransaction('background task', function executeTransaction() { const transaction = newrelic.getTransaction() // accept the headers transaction.acceptDistributedTraceHeaders('Kafka', headersObject) }) Copy transactionHandle.createDistributedTracePayload() transactionHandle.createDistributedTracePayload() Copy Caution This method is deprecated and was removed in version 7.0.0! Please use insertDistributedTraceHeaders. Important This API requires distributed tracing to be enabled. For instructions on how to use this call, along with its partner call acceptDistributedTracePayload, see Enable distributed tracing with agent APIs. This call is used to implement distributed tracing. It generates a payload that is read by the receiving application with acceptDistributedTracePayload. Important Note: In order to maintain proper ordering of spans in a trace, you must generate the payload in the context of the span that sends it. The DistributedTracePayload object has two available methods used for generating the payload in different formats: DistributedTracePayload#text: returns a JSON representation of the payload. Link a nested background transaction // Call newrelic.getTransaction to retrieve a handle on the current transaction. var transactionHandle = newrelic.getTransaction() var payload = transactionHandle.createDistributedTracePayload() var jsonPayload = payload.text() newrelic.startBackgroundTransaction('background task', function executeTransaction() { var backgroundHandle = newrelic.getTransaction() // Link the nested transaction by accepting the payload with the background transaction's handle backgroundHandle.acceptDistributedTracePayload(jsonPayload) }) Copy DistributedTracePayload#httpSafe: returns a base64 encoded JSON representation of the payload. Place payload on an outgoing request // Call newrelic.getTransaction to retrieve a handle on the current transaction. var transactionHandle = newrelic.getTransaction() var payload = transactionHandle.createDistributedTracePayload() // Place the base64 encoded value on an outbound request header. req.headers[myTracingHeader] = payload.httpSafe() Copy transactionHandle.acceptDistributedTracePayload(payload) transactionHandle.acceptDistributedTracePayload(payload) Copy Caution This method is deprecated and was removed in version 7.0.0! Please use acceptDistributedTraceHeaders. Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call createDistributedTracePayload, first read Enable distributed tracing with agent APIs. transactionHandle.acceptDistributedTracePayload is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting the payload generated by createDistributedTracePayload. transactionHandle.isSampled() transactionHandle.isSampled() Copy Returns whether this trace is being sampled. Other API calls New Relic's Node.js agent includes additional API calls. newrelic.addCustomAttribute(name, value) newrelic.addCustomAttribute(name, value) Copy Set a custom attribute value to be displayed along with the transaction trace in the New Relic UI. This must be called within the context of a transaction so it has a place to set the custom attributes. Custom attributes will appear in APM's transaction trace detail view and in errors for the transaction. Add custom attribute newrelic.addCustomAttribute('attribute1', 'value1') Copy Caution If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomAttributes(attributes) newrelic.addCustomAttributes(attributes) Copy Set multiple custom attribute values to be displayed along with the transaction trace in the New Relic UI. The attributes should be passed as a single object. This must be called within the context of a transaction so it has a place to set the custom attributes. Custom attributes will appear in the transaction trace detail view and in errors for the transaction. Adding custom attributes const attributes = { attribute1: 'value1', attribute2: 2 } newrelic.addCustomAttributes(attributes) Copy Caution If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomSpanAttribute(name, value) newrelic.addCustomSpanAttribute(name, value) Copy Set a custom span attribute value to be displayed along with a transaction trace span in the New Relic UI. This must be called within the context of an active segment/span so it has a place to set the custom span attributes. Custom span attributes will appear in the Attributes section of the span detail view. Add custom span attribute newrelic.addCustomSpanAttribute('attribute1', 'value') Copy Important This API requires distributed tracing and span events to be enabled. Caution If you want to use your custom span attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomSpanAttributes(attributes) newrelic.addCustomSpanAttributes(attributes) Copy Set multiple custom span attribute values to be displayed along with the transaction trace spans in the New Relic UI. The attributes should be passed as a single object. This must be called within the context of an active segment/span so it has a place to set the custom span attributes. Custom span attributes will appear in the Attributes section of the span detail view. Add custom span attributes const attributes = { attribute1: 'value1', attribute2: 'value2' } newrelic.addCustomSpanAttributes(attributes) Copy Important This API requires distributed tracing and span events to be enabled. Caution If you want to use your custom span attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.getBrowserTimingHeader() newrelic.getBrowserTimingHeader() Copy Returns the HTML snippet to be inserted into the header of HTML pages to enable browser monitoring. The HTML will instruct the browser to fetch a small JavaScript file and start the page timer. newrelic.setIgnoreTransaction(ignored) newrelic.setIgnoreTransaction(ignored) Copy Tell the module whether or not to ignore a given request. This allows you to explicitly filter long-polling, irrelevant routes or requests you know will be time-consuming. This also allows you to gather metrics for requests that otherwise would be ignored. To ignore the transaction, set the parameter to true will ignore the transaction. To prevent a transaction from being ignored with this function, pass the parameter false. Passing null or undefined will not change whether the transaction is ignored. Caution This method is deprecated and was removed in version 7.0.0. Please use transactionHandle.ignore() newrelic.noticeError(error, [customParameters]) newrelic.noticeError(error, [customParameters]) Copy Use this call if your app is doing its own error handling with domains or try/catch clauses, but you want all of the information about how many errors are coming out of the app to be centrally managed. Unlike other Node.js calls, this can be used outside of route handlers, but it will have additional context if called from within transaction scope. Caution Errors recorded using this method do not obey the ignore_status_codes configuration value. newrelic.shutdown([options], callback) newrelic.shutdown([options], callback) Copy Use this method to gracefully shut down the agent. Option name Type Attributes Default Description collectPendingData boolean Optional false Tell the agent whether to send any pending data to the New Relic collector before shutting down. collectPendingData boolean Optional false Tell the agent whether to send any pending data to the New Relic collector before shutting down. timeout number Optional 0 The default time before forcing a shutdown. When collectPendingData is true, the agent will wait for a connection before shutting down. This timeout is useful for short lived processes, like AWS Lambda, in order to keep the process from staying open too long, while trying to connect. waitForIdle boolean Optional false If true, the agent will not shut down until there are no active transactions. Example: newrelic.shutdown({collectPendingData: true, timeout: 10000}, (error) => { process.exit() }) Copy newrelic.getLinkingMetadata() newrelic.getLinkingMetadata() Copy Returns key/value pairs which can be used to link traces or entities. It will only contain items with meaningful values. For instance, if distributed tracing is disabled, trace.id will not be included. newrelic.getTraceMetadata() newrelic.getTraceMetadata() Copy Returns and object containing the current trace ID and span ID. Important This API requires distributed tracing to be enabled or an empty object will be returned. Rules for naming and ignoring requests If you do not want to put calls to the New Relic module directly into your application code, you can use pattern-based rules to name requests. There are two sets of rules: one for renaming requests, and one to mark requests to be ignored by New Relic's instrumentation. Here is the structure for rules in New Relic's Node.js agent. rules.name A list of rules of the format {pattern : \"pattern\", name : \"name\"} for matching incoming request URLs to pattern and naming the matching New Relic transaction's name. This acts as a regex replace, where you can set the pattern either as a string, or as a JavaScript regular expression literal, and both pattern and name are required. When passing a regex as a string, escape backslashes, as the agent does not keep them when given as a string in a pattern. Define your configuration rules from the most specific to the most general, as the patterns will be evaluated in order and are terminal in nature. For more information, see the naming guidelines. This can also be set with the environment variable NEW_RELIC_NAMING_RULES, with multiple rules passed in as a list of comma-delimited JSON object literals: NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}' Copy Optional rules attributes [#optional-rules] Additional optional attributes are available: Optional rules attributes Description terminate_chain Default: true When set to true (default), no further rules will be evaluated if this rule is a match. Setting this to false is useful when multiple rules should be used together. For example, one rule could be replacing a common pattern in many different URLs, while subsequent rule(s) would be more specific. replace_all Default: false When set to true, all matches of the pattern will be replaced. Otherwise, only the first match will be replaced. Using the g flag with regular expression literal will have the same effect. For example: pattern: '[0-9]+', replace_all: true Copy This has the same effect as pattern: /[0-9]+/g. precedence By default the rules are evaluated in order, from first to last. If you prefer to have complete control over the order, you can give each rule a precedence attribute. The precedence is an integer number, and rules are evaluated in ascending order. If precedence is not explicitly defined, it will be set to 500 by default. Additional attributes are ignored. Testing your naming rules [#testing-rules] The Node.js agent comes with a command-line tool for testing naming rules. For more information, run the following command in terminal window in a directory where your app is installed: node node_modules/.bin/newrelic-naming-rules Copy Naming rule examples [#examples-rules] Here are some examples of naming rules and the results. Match full URL pattern: \"^/items/[0-9]+$\", name: \"/items/:id\" Copy will result in: /items/123 => /items/:id /orders/123 => /orders/123 (not replaced since the rule is a full match) Copy Replace first match in URL pattern: \"[0-9]+\", name: \":id\" Copy will result in: /orders/123 => /orders/:id /items/123 => /items/:id /orders/123/items/123 => /orders/:id/items/123 Copy Replace all matches in any URL pattern: \"[0-9]+\", name: \":id\", replace_all: true Copy will result in: /orders/123/items/123 => /orders/:id/items/:id Copy Match group references Using regular expression match group references: pattern: '^/(items|orders)/[0-9]+$', name: '/\\\\1/:id' Copy will result in: /orders/123 => /orders/:id /items/123 => /items/:id Copy rules.ignore This can also be set via the environment variable NEW_RELIC_IGNORING_RULES, with multiple rules passed in as a list of comma-delimited patterns. Currently there is no way to escape commas in patterns. NEW_RELIC_IGNORING_RULES='^/socket\\.io/\\*/xhr-polling,ignore_me' Copy Here are full examples of how rules are included in the configuration file: Naming rule example // newrelic.js exports.config = { // other configuration rules : { name : [ { pattern: \"/tables/name-here\", name: \"/name-hererule1\" } ] } Copy Ignoring rule example If you are using socket.io, you will have a use case for ignoring rules right out of the box. To keep socket.io long-polling from dominating your response-time metrics and affecting the Apdex metrics for your application, add a rule such as: // newrelic.js exports.config = { // other configuration rules : { ignore : [ '^\\/socket\\.io\\/.*\\/xhr-polling' ] } }; Copy API calls for rules Here are the API calls for naming and ignoring rules with New Relic's Node.js agent. newrelic.addNamingRule(pattern, name) Programmatic version of rules.name. Once naming rules are added, they cannot be removed until the Node process is restarted. They can also be added via the Node.js agent's configuration. Both parameters are required. newrelic.addIgnoringRule(pattern) Programmatic version of rules.ignore. Once ignoring rules are added, they cannot be removed until the Node process is restarted. They can also be added via the Node.js agent's configuration. This parameter is required.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.168465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js <em>agent</em> <em>API</em>",
        "sections": "Node.js <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": " of controllers with actions Support rules that are stored in your <em>agent</em>&#x27;s configuration that can mark requests to be renamed or ignored based on regular expressions matched against the request&#x27;s raw URLs (also available as <em>API</em> calls) The number of names that New Relic tracks needs to be small enough so"
      },
      "id": "6043daa7196a67e488960f4f"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "50a42a3ff33b7b1d3517e6d2fec0108aa74a5979",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-10-18T21:02:09Z",
      "updated_at": "2021-09-20T19:35:51Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (e.g. TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (e.g. http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.17108,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "6044124428ccbc5ced2c6087"
    }
  ],
  "/docs/agents/net-agent/attributes/custom-attributes-net": [
    {
      "sections": [
        "Enable and disable attributes (.NET)",
        "Attribute rules",
        "Root level takes precedence for enabled.",
        "Destination enabled takes precedence over include and exclude.",
        "Attribute is included if the destination is enabled.",
        "Exclude always supersedes include.",
        "Keys are case sensitive.",
        "Use an asterisk * for wildcards.",
        "Most specific setting for a key takes priority.",
        "Include or exclude affects the specific destination.",
        "Obsolete properties",
        "analyticsEvents replaced by transactionEvents",
        "requestParameters replaced by request.parameters.*",
        "parameterGroups: enable and ignore replaced by attributes true, include and exclude",
        "captureAttributes flag replaced by attributes sub-elements"
      ],
      "title": "Enable and disable attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "71d8c3a6ad5df2a487ce2fe102de9ec875f1901d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/enable-disable-attributes-net/",
      "published_at": "2021-10-18T10:47:47Z",
      "updated_at": "2021-09-20T19:34:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes the rules New Relic uses to determine which attributes to include or exclude for a destination. This also includes a summary of the .NET agent properties that were no longer available with the release of New Relic agent attributes in versions 9.0 or higher. Attribute rules New Relic follows these rules to determine which attributes to include or exclude: Root level takes precedence for enabled. The attributes.enabled field overrides all other settings. When false, no attributes will be reported to New Relic. Example configuration: <attributes enabled=\"false\"> <include>foo</include> <include>bar</include> </attributes> <transactionTracer enabled=\"true\"> <attributes enabled=\"true\"/> </transactionTracer> Copy Example output: Keys passed in: foo, bar, bat Keys included for all destinations: Keys excluded for all destinations: foo, bar, bat Copy Destination enabled takes precedence over include and exclude. The {destination}.attributes.enabled flags take precedence over include and exclude keys. Example configuration: <attributes enabled=\"true\"> <include>one</include> <include>two</include> </attributes> <transactionTracer enabled=\"true\"> <attributes enabled=\"false\"> <include>three</include> <include>four</include> </attributes> </transactionTracer> Copy Example output: Keys passed in: one, two, three, four Keys included for transaction traces: Keys excluded for transaction traces: one, two, three, four Copy Attribute is included if the destination is enabled. If a destination is enabled, all user attributes are sent to that destination by default. All user attributes default to true. However, by default, request attributes and message parameters are disabled for all destinations. Example configuration: <attributes enabled=\"true\"> <exclude>myAttKey</exclude> </attributes> Copy Example output: Keys passed in: foo, bar, myAttKey Keys included: foo, bar Keys excluded: myAttKey Copy Exclude always supersedes include. If the same key is listed in the include and exclude lists, then attributes with the specified key will be excluded. Example configuration: <attributes enabled=\"true\"> <include>foo</include> <include>myCustomAtt</include> <exclude>password</exclude> <exclude>myCustomAtt</exclude> </attributes> Copy Example output: Keys passed in: foo, myCustomAtt, password Keys included: foo Keys excluded: password, myCustomAtt Copy Keys are case sensitive. Keys are case sensitive. Example configuration: <attributes enabled=\"true\"> <exclude>password</exclude> <exclude>PaSsWoRd</exclude> </attributes> Copy Example output: Keys passed in: password, Password, PASSWORD, PaSsWoRd, PassWORD Keys included: Password, PASSWORD, PassWORD Keys excluded: password, PaSsWoRd Copy Use an asterisk * for wildcards. You can use an asterisk * at the end of a key as a wildcard. This will match all attributes with the same prefix. Example configuration: <attributes enabled=\"true\"> <include>custom*</include> <exclude>request.parameters.*</exclude> </attributes> Copy Example output: Keys passed in: custom, custom.key1, custom.key2, request.parameters., request.parameters.foo, request.parameters.bar Keys included: custom, custom.key1, custom.key2 Keys excluded: request.parameters., request.parameters.foo, request.parameters.bar Copy Most specific setting for a key takes priority. If multiple include or exclude attributes affect the same key, the most specific setting will have priority. Example configuration: <attributes enabled=\"true\"> <include>request.parameters.foo</include> <exclude>request.parameters.*</exclude> </attributes> Copy Example output: Keys passed in: request.parameters., request.parameters.foo, request.parameters.bar Keys included: request.parameters.foo Keys excluded: request.parameters., request.parameters.bar Copy Include or exclude affects the specific destination. If the attribute include or exclude is specified on a destination, then it only impacts that destination. Example configuration: <attributes enabled=\"true\"> <include>foo</include> </attributes> <transactionEvents enabled=\"true\"> <attributes enabled=\"true\"> <exclude>foo</exclude> </attributes> </transactionEvents> Copy Example output: Keys passed in: foo Keys included for transaction events: Keys included for other destinations: foo Keys excluded for transaction events: foo Copy Obsolete properties The following properties are not available in the .NET agent v9.0. Please visit the .NET agent 8.x to 9.x migration guide page for replacement properties when upgrading your .NET agent. analyticsEvents replaced by transactionEvents The analyticsEvents element in newrelic.config is obsolete. Enable the transactionEvents element in newrelic.config: <transactionEvents enabled=\"true\"/> Copy requestParameters replaced by request.parameters.* By default, request parameters are not sent to New Relic. Add request.parameters.* to the attributes.include list to enable request parameter collection. <attributes> <include>request.parameters.*</include> </attributes> Copy parameterGroups: enable and ignore replaced by attributes true, include and exclude The parameterGroups value and its enabled and ignore settings are obsolete. By default, customParameters and responseHeaderParameters are instrumented, while serviceRequestParameters are not instrumented. To customize these settings: Use the enabled flag to enable instrumentation. Use include and exclude to toggle instrumentation for specific attributes. For example: <attributes enabled=\"true\"> <include>service.request.*</include> <exclude>response.headers.*</exclude> <exclude>myCustomApiKey.*</exclude> </attributes> Copy For more information on configuring attributes, see the attributes examples. captureAttributes flag replaced by attributes sub-elements The capture attributes flag on browserMonitoring, transactionTracer, transactionEvents, and errorCollector is obsolete. Instead, use the attributes sub-element to configure attribute settings for each of these destinations. New property Example browserMonitoring <browserMonitoring enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </browserMonitoring> Copy transactionTracer <transactionTracer enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </transactionTracer> Copy transactionEvents <transactionEvents enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </transactionEvents> Copy errorCollector <errorCollector enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </errorCollector>> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.3158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable and disable <em>attributes</em> (.<em>NET</em>)",
        "sections": "Enable and disable <em>attributes</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This describes the rules New Relic uses to determine which <em>attributes</em> to include or exclude for a destination. This also includes a summary of the .<em>NET</em> <em>agent</em> properties that were no longer available with the release of New Relic <em>agent</em> <em>attributes</em> in versions 9.0 or higher. Attribute rules New Relic"
      },
      "id": "603ed634196a67b796a83d9f"
    },
    {
      "sections": [
        "SetUserParameters (.NET agent)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples",
        "Record three user attributes",
        "Record two user attributes and one empty attribute"
      ],
      "title": "SetUserParameters (.NET agent)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "23e2d652abbd86b20905ee0296bbca03f95ca5a1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/net-agent-api/set-user-parameters/",
      "published_at": "2021-10-18T05:48:57Z",
      "updated_at": "2021-09-20T19:35:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.Api.Agent.NewRelic.SetUserParameters(string $user_value, string $account_value, string $product_value) Copy Create user-related custom attributes. AddCustomAttribute() is more flexible. Requirements Compatible with all agent versions. Must be called inside a transaction. Description Tip This call only allows you to assign values to pre-existing keys. For a more flexible method to create key/value pairs, use AddCustomAttribute(). Define user-related custom attributes to associate with a browser page view (user name, account name, and product name). The values are automatically associated with pre-existing keys (user, account, and product), then attached to the parent APM transaction. You can also attach (or \"forward\") these attributes to browser PageView events. Parameters Parameter Description $user_value string Required (can be null). Specify a name or username to associate with this page view. This value is assigned to the user key. $account_value string Required (can be null). Specify the name of a user account to associate with this page view. This value is assigned to the account key. $product_value string Required (can be null). Specify the name of a product to associate with this page view. This value is assigned to the product key. Examples Record three user attributes NewRelic.Api.Agent.NewRelic.SetUserParameters(\"MyUserName\", \"MyAccountName\", \"MyProductName\"); Copy Record two user attributes and one empty attribute NewRelic.Api.Agent.NewRelic.SetUserParameters(\"MyUserName\", \"\", \"MyProductName\"); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.02846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SetUserParameters (.<em>NET</em> <em>agent</em>)",
        "sections": "SetUserParameters (.<em>NET</em> <em>agent</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Syntax NewRelic.Api.<em>Agent</em>.NewRelic.SetUserParameters(string $user_value, string $account_value, string $product_value) Copy Create user-related custom <em>attributes</em>. AddCustomAttribute() is more flexible. Requirements Compatible with all <em>agent</em> versions. Must be called inside a transaction. Description"
      },
      "id": "6043d56428ccbcb1ea2c60e4"
    },
    {
      "sections": [
        ".NET agent configuration",
        "Important",
        "Configuration overview",
        "Configuration methods and precedence levels",
        "Required environment variables",
        "Caution",
        ".NET Framework environment variables",
        ".NET Core environment variables",
        "Profiler conflict explanation",
        "Optional environment variables",
        "Setup options, newrelic.config",
        "Configuration element",
        "agentEnabled",
        "maxStackTraceLines",
        "timingPrecision",
        "Service element",
        "licenseKey (required)",
        "sendEnvironmentInfo",
        "syncStartup",
        "sendDataOnExit",
        "sendDataOnExitThreshold",
        "completeTransactionsOnThread",
        "requestTimeout",
        "autoStart",
        "Obscuring key element",
        "Proxy element",
        "host",
        "port",
        "uriPath",
        "domain",
        "user",
        "password",
        "passwordObfuscated",
        "Log element",
        "level",
        "auditLog",
        "console",
        "directory",
        "fileName",
        "Application element (required)",
        "name",
        "disableSamplers",
        "Data transmission element",
        "putForDataSend",
        "Host name",
        "Set using config file",
        "Set using environment variable",
        "Cloud platform utilization",
        "detectAws",
        "detectAzure",
        "detectGcp",
        "detectPcf",
        "detectDocker",
        "detectKubernetes",
        "Instrumentation options",
        "Instrumentation element",
        "Applications element (instrumentation)",
        "Attributes element",
        "enabled",
        "include",
        "exclude",
        "Feature options",
        "App pools",
        "defaultBehavior",
        "applicationPool",
        "Cross application traces",
        "Error collection",
        "Tip",
        "captureEvents",
        "maxEventSamplesStored",
        "ignoreClasses",
        "ignoreMessages",
        "ignoreErrors (obsolete)",
        "ignoreStatusCodes",
        "expectedClasses",
        "expectedMessages",
        "expectedStatusCodes",
        "attributes",
        "High security mode",
        "Strip exception messages",
        "Transaction events",
        "maximumSamplesStored",
        "Custom events",
        "Custom parameters",
        "Labels (tags)",
        "Browser instrumentation",
        "autoInstrument",
        "requestPathsExcluded",
        "Slow queries",
        "Transaction traces",
        "transactionThreshold",
        "recordSql",
        "explainEnabled",
        "explainThreshold",
        "maxSegments",
        "maxExplainPlans",
        "maxStackTrace",
        "Datastore tracer",
        "instanceReporting",
        "databaseNameReporting",
        "queryParameters",
        "Distributed tracing",
        "excludeNewrelicHeader",
        "Disable span events via config file",
        "Disable span events via environment variable",
        "Infinite Tracing",
        "trace_observer",
        "Span events",
        "Capture HTTP Request Headers",
        "Settings in app.config or web.config",
        "Enable and disable the agent",
        "Application name",
        "License key",
        "Change newrelic.config location",
        "Settings in appsettings.json"
      ],
      "title": ".NET agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Configuration"
      ],
      "external_id": "b89fa7fc399f2729bfee8f5106e777798a73177a",
      "image": "https://docs.newrelic.com/static/cffd7eb2d22c8e338531c38f35208c7c/c1b63/net-agent-config-settings-precedence_0.png",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/configuration/net-agent-configuration/",
      "published_at": "2021-10-19T05:54:03Z",
      "updated_at": "2021-09-20T19:41:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains the configuration options for the APM .NET agent. Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Configuration overview APM agent configuration options allow you to control some aspects of how the agent behaves. Some of these config options are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as: setting a log level, setting up proxy host access, excluding certain attributes, and enabling distributed tracing. The .NET agent gets its configuration from the newrelic.config file, which is generated as part of the install process. By default, only a global newrelic.config file is created, but you can also create app-local newrelic.config files for finer control over a multi-app system. Other ways to set config options include: using environment variables, or setting server-side configuration from the UI. For more on the various config options and what overrides what, see Config settings precedence. Support for both .NET Framework and .NET Core use the same configuration options and have the same APM features, unless otherwise stated. If you make changes to the config file and want to validate that it's in the right format, you can check it against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows) with any XSD validator. Important For IIS: after you change your newrelic.config or app.config file, perform an IISRESET from an administrative command prompt. Log level adjustments do not require a reset. Configuration methods and precedence levels Upon installation, the .NET agent's configuration file (newrelic.config) applies to all monitored applications, but you can configure the agent in other ways. Here's a diagram showing how different configuration options take precedence over one another: This diagram explains the order of precedence for different ways you might configure the .NET agent. Here are details about the configuration methods shown in the diagram, and their precedence levels: .NET configuration Details and precedence web.config or app.config or appsettings.json Configuration settings set in these files take highest precedence. However, if the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Environment variables Second-highest precedence. For more about these, see .NET environment variables. Server-side configuration Third-highest precedence. A limited number of server-side configuration settings are available; the other settings will come from other configuration sources. App-local newrelic.config Fourth-highest precedence. You can create app-local newrelic.config files to configure individual apps on a multi-app system. These local configuration files override settings in the global newrelic.config file. The agent looks for app-local config files in the following directories, in this order: A directory specified in your web.config or app.config file with the NewRelic.ConfigFile property The web app's root directory (with the app.config or web.config) The directory containing your app's executable file Note that the app-local config file must be complete and validate against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows). Default (global) newrelic.config Default source and the lowest precedence. Will configure all applications on a host in the absence of other config files. The global config file is located in the New Relic agent home directory: %PROGRAMDATA%\\New Relic\\.NET Agent Required environment variables New Relic's .NET agent relies on environment variables to tell the .NET Common Language Runtime (CLR) to attach New Relic to your processes. Some .NET agent install procedures (like the MSI installer) will automatically set these variables for you; some procedures will require you to manually set them. Caution Security recommendation: You should consider what users can set system environment variables. You should also secure the accounts under which your applications execute to prevent user environment variables overriding system environment variables .NET Framework environment variables For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. .NET Core environment variables For .NET Core, the following variables are required: Linux: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path/to/agent/directory CORECLR_PROFILER_PATH=\"${CORECLR_NEWRELIC_HOME}/libNewRelicProfiler.so\" Copy Windows: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. If your system has previously used monitoring services (non-New Relic), you may have a \"profiler conflict\" when trying to install and use the New Relic agent. More details: Profiler conflict explanation New Relics .NET agents rely on environment variables to tell the .NET Common Language Runtime (CLR) to load New Relic into your processes. The install-related environment variables are Microsoft variables, not New Relic variables. They can be used by other .NET profilers, and only one profiler can be attached to a process at a time. For this reason, if you have used previous application monitoring products, you may have profiler conflicts. For specific install instructions, see the .NET agent install documentation. Optional environment variables Some configuration options in New Relic's .NET agent can be set via environment variables as an alternative to setting them in a config file. Below is a list of environment variables recognized by the .NET agent with example values. NEW_RELIC_LICENSE_KEY=XXXXXXXX NEW_RELIC_LOG=MyApp.log NEW_RELIC_APP_NAME=Descriptive Name MAX_TRANSACTION_SAMPLES_STORED=500 MAX_EVENT_SAMPLES_STORED=500 NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_SPAN_EVENTS_ENABLED=false NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED=2000 NEW_RELIC_LABELS=foo:bar;zip:zap NEW_RELIC_CONFIG_OBSCURING_KEY=XXXXXXXX NEW_RELIC_DISABLE_SAMPLERS=true NEWRELIC_PROFILER_LOG_DIRECTORY=path\\to\\a\\directory (not configurable via config file) NEWRELIC_LOG_DIRECTORY=path\\to\\a\\directory (Insert a directory where you want to put the agent and profiler logs. You can't set this directory for both agent and profiler logs in the configuration file.) NEWRELIC_LOG_LEVEL=off|error|warn|info|debug|finest|all Copy Setup options, newrelic.config Use these options to setup and configure your agent via the newrelic.config file. The New Relic .NET agent supports the following categories of setup options: Configuration element Service element Obscuring key element Proxy element Log element Application element (configuration) Data transmission element Host name Configuration element The root element of the configuration document is a configuration element. <configuration xmlns=\"urn:newrelic-config\" agentEnabled=\"true\" maxStackTraceLines=\"50\" timingPrecision=\"low\"> Copy The configuration element supports the following attributes: agentEnabled Type Boolean Default true Enable or disable the New Relic agent. maxStackTraceLines Type Integer Default 80 The maximum number of stack frames to trace in any stack dump. timingPrecision Type String Default low Controls the precision of the timers. High precision will provide better data, but at a lower execution speed. Possible values are high and low. Service element The first child of the configuration element is a service element. The service element configures the agent's connection to the New Relic service. <service licenseKey=\"YOUR_LICENSE_KEY\" sendEnvironmentInfo=\"true\" syncStartup=\"false\" sendDataOnExit=\"false\" sendDataOnExitThreshold=\"60000\" autoStart=\"true\"/> Copy The service element supports the following attributes: licenseKey (required) Type String Default (none) Your New Relic license key. New Relic uses the license key to match your app's data to the correct account in the UI. Set the license key via environment variable. Alternatively, set the NEW_RELIC_LICENSE_KEY environment variable in the application's environment. NEW_RELIC_LICENSE_KEY=XXXXXXXX Copy sendEnvironmentInfo Type Boolean Default true Instructs the agent to record execution environment information. Environment information includes operating system, agent version, and which assemblies are available. syncStartup Type Boolean Default false Block application startup until the agent connects to New Relic. If set to true, the first transaction may take substantially longer to complete, because it is blocked until the connection to New Relic is finished. sendDataOnExit Type Boolean Default false Block application shutdown until the agent sends all data from the latest harvest cycle. sendDataOnExitThreshold Type Integer Default 60000 Unit Milliseconds The minimum amount of time the process must run before the agent blocks it from shutting down. This setting only applies when sendDataOnExit is true. completeTransactionsOnThread Type Boolean Default false If false, the agent uses a pool thread to complete the transaction processing. If true, the agent will complete transaction processing on the request thread. requestTimeout Type Integer Default 2000 (sendDataOnExit enabled) 120000 (sendDataOnExit disabled) Unit Milliseconds The agent's request timeout when communicating with New Relic. autoStart Type Boolean Default True Automatically start the .NET agent when the first instrumented method is hit. Obscuring key element The obscuringKey element is an optional child of the service element. The .NET Agent uses this value to deobfuscate supported configuration values. For example, when an obfuscated proxy password is supplied, it will be deobfuscated using this key. <service licenseKey=\"YOUR_LICENSE_KEY\"> <obscuringKey>OBSCURING_KEY</obscuringKey> </service> Copy The obscuring key may also be configured by setting the NEW_RELIC_CONFIG_OBSCURING_KEY environment variable. Caution Security recommendation: The placement of the obscuring Key in the same configuration file as an obfuscated value may pose a security risk. Consider placing the obscuring key in an environment variable and limiting access to environment variables within your environment. Proxy element The proxy element is an optional child of the service element. The proxy element is used when the agent communicates to the New Relic back-end service via a proxy. <service licenseKey=\"YOUR_LICENSE_KEY\"> <proxy host=\"hostname\" port=\"PROXY_PORT\" uriPath=\"path/to/something.aspx\" domain=\"mydomain.com\" user=\"PROXY_USERNAME\" password=\"PROXY_PASSWORD\" passwordObfuscated=\"OBFUSCATED_PROXY_PASSWORD\"/> </service> Copy The proxy element supports the following attributes: host Type String Default (none) Defines the proxy host. port Type Integer Default 8080 Defines the proxy port. uriPath Type String Default (none) Optionally define a proxy URI path. domain Type String Default (none) Optionally define a domain to use when authenticating with the proxy server. user Type String Default (none) Optionally define a user name for authentication. password Type String Default (none) Optionally define a password for authentication. passwordObfuscated Type String Default (none) For additional security, the .NET Agent supports the use of an obfuscated proxy password with the passwordObfuscated attribute. The obfuscated proxy password is generated using the following New Relic CLI command: newrelic agent config obfuscate --key OBSCURING_KEY --value \"CLEAR_TEXT_PROXY_PASSWORD\" Copy Important When using an obfuscated proxy password, the obscuring key must also be configured. Log element The log element is a child of the configuration element. The log element configures New Relic's logging . The agent generates its own log file to keep its logging information separate from your application's logs. <log level=\"info\" auditLog=\"false\" console=\"false\" directory=\"PATH\\TO\\LOG\\DIRECTORY\" fileName=\"FILENAME.log\" /> Copy The log element supports the following attributes: level Type String Default info Defines the level of detail recorded in the log file. Possible values, in increasing order of detail, are: off error warn info debug finest all Alternatively, set the NEWRELIC_LOG_LEVEL environment variable in the application's environment. Important Increasing the log level will increase New Relic's performance impact. auditLog Type Boolean Default false Records all data sent to and received from New Relic in both an auditlog log file and the standard log file. console Type Boolean Default false Send log messages to the console, in addition to the log file. directory Type String Default C:\\ProgramData\\New Relic\\.NET Agent\\Logs The directory to hold log files generated by the agent. If this is omitted, then a directory named logs in the New Relic agent install area will be used by default. fileName Type String Default (none) Defines a name for the log file. If you do not define a fileName, the name is derived from the name of the monitored process. Alternatively, set the NEW_RELIC_LOG environment variable in the application's environment. NEW_RELIC_LOG=MyApp.log Copy Application element (required) The application element is a child of the configuration element. This required element defines your application name, and disables or enables sampling. name Type String Default My Application The name of your .NET application is a child of the application element. New Relic will aggregate your data according to this name. For example, if you have two running applications named AppA and AppB, you will see two applications in the New Relic interface: AppA and AppB. You can also assign up to three names to your app. The first name is the primary name. For example: <application> <name>MY APPLICATION PRIMARY</name> <name>SECOND APP NAME</name> <name>THIRD APP NAME</name> </application> Copy Alternatively, set the NEW_RELIC_APP_NAME environment variable in the application's environment. NEW_RELIC_APP_NAME=Descriptive Name Copy disableSamplers Type Boolean Default false Samplers collect information about memory and CPU consumption. Set this to true to disable sampling. Alternatively, set the NEW_RELIC_DISABLE_SAMPLERS environment variable in the application's environment. NEW_RELIC_DISABLE_SAMPLERS=true Copy Data transmission element The dataTransmission element is a child of the configuration element. This element affects how data is sent to New Relic and can be used if you have specific data transmission requirements. <dataTransmission putForDataSend=\"false\" compressedContentEncoding=\"deflate\"/> Copy The dataTransmission element supports the following attributes: putForDataSend Type Boolean Default false Defines the HTTP method used when sending data to New Relic. Set this to true to enable using the PUT method when sending data. The POST method is used by default. Host name If the default host name label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. After the application process is restarted and the .NET agent is reporting again, the display name will appear in the Servers drop-down list. This host name setting does not affect the list of hosts on your application's Summary page. To set a display name, choose one of the following options. The environment variable takes precedence over the config file value. Then restart your application to see your changes in the New Relic UI. Set using config file Set the displayName attribute in the processHost element in newrelic.config. The processHost element is a child of the configuration element. <configuration . . . > <processHost displayName=\"CUSTOM_NAME\" /> </configuration> Copy Set using environment variable Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable: NEW_RELIC_PROCESS_HOST_DISPLAY_NAME = \"CUSTOM_NAME\" Copy Cloud platform utilization Configures the utilization configuration element to control how the agent collects utilization information and sends it to the New Relic service to determine pricing. The agent can collect information from Amazon Web Services (AWS) EC2 instances, Docker containers, Azure, Google Cloud Platform, Pivotal Cloud Foundry, and Kubernetes. detectAws Type Boolean Default true Determines whether the agent polls AWS metadata API. detectAzure Type Boolean Default true Determines whether the agent polls Azure metadata API. detectGcp Type Boolean Default true Determines whether the agent polls GCP metadata API. detectPcf Type Boolean Default true Determines whether the agent polls PCF information from environment variables. detectDocker Type Boolean Default true Determines whether the agent reads Docker information from the file system. detectKubernetes Type Boolean Default true Determines whether the agent polls Kubernetes information from environment variables. Instrumentation options Use these options to configure which elements of your application and environment to instrument. New Relic for .NET supports the following categories of instrumentation options: Instrumentation element Applications element (instrumentation) Attributes element Instrumentation element The instrumentation element is a child of the configuration element. By default, the .NET agent instruments IIS asp worker processes and Azure web and worker roles. To instrument other processes, see Instrumenting custom applications. Applications element (instrumentation) The applications element is a child of the instrumentation element. The applications element specifies which non-web apps to instrument. It contains a name attribute. Important This is not the same as the application (configuration) element, which is a child of the configuration element. <instrumentation> <applications> <application name=\"MyService1.exe\" /> <application name=\"MyService2.exe\" /> <application name=\"MyService3.exe\" /> </applications> </instrumentation> Copy Attributes element An attribute is a key/value pair that determines the properties of an event or transaction. Each attribute is sent to APM transaction traces, APM error traces, Transaction events, TransactionError events, or PageView events. The primary attributes element enables or disables attribute collection for the .NET agent, and defines specific attributes to collect or exclude. You can also configure attribute settings based on their destination: Error collection, transaction traces, browser instrumentation, and transaction events. In this example, the agent excludes all attributes whose key begins with myApiKey (myApiKey.bar, myApiKey.value), but collects the custom attribute myApiKey.foo. <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> Copy You can view the .NET APM attributes on the .NET agent attributes page. You can also define custom attributes with the agent API call AddCustomAttribute. enabled Type Boolean Default true Enable or disable attribute collection. When set to false in the primary attribute element, this setting overrides all attribute settings for individual destinations. include Type String Default (none) If attributes are enabled, the agent will collect all attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. exclude Type String Default (none) If attributes are enabled, the agent will not collect attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. Feature options Use these options to enable, disable, and configure New Relic features. New Relic for .NET allows you to configure the following features: App pools Cross application traces Error collection High security mode Strip exception messages Transaction events Custom events Custom parameters Tags/labels Browser instrumentation Slow Queries Transaction traces Datastore tracer Distributed tracing Span events Capture HTTP Request Headers App pools Important This is only applicable to a system's global config file. The applicationPools element is a child of the configuration element. The applicationPools element specifies for the profiler exactly which application pools to instrument and uses the same name as the IIS application pool name. This configuration element is useful when you may need to instrument only a small subset of your app pools. For example, a given server might have several hundred application pools, but only a few of those pools need to be instrumented by the .NET agent. Here is an example of disabling instrumentation for specific application pools: <applicationPools> <applicationPool name=\"Foo\" instrument=\"false\"/> <applicationPool name=\"Bar\" instrument=\"false\"/> </applicationPools> Copy Here is an example of disabling instrumentation for all application pools currently executing on the server and enabling instrumentation for specific application pools: <applicationPools> <defaultBehavior instrument=\"false\"/> <applicationPool name=\"Foo\" instrument=\"true\"/> <applicationPool name=\"Bar\" instrument=\"true\"/> </applicationPools> Copy The applicationPools element supports the following elements: defaultBehavior Type Boolean Default false Defines how the .NET agent will behave on a \"global\" level for application pools served via IIS. The .NET agent instruments all application pools by default. When true, application pools listed under applicationPool with an instrument attribute set to false will not be instrumented. Essentially, when set to false, the application pool list acts as an allow list. When set to true, the application pool list acts as a deny list. applicationPool Defines instrumentation behavior for a specific application pool. The name attribute is the name of an application pool. Enable or disable profiling in the instrument attribute. Define this application in the name attribute. Cross application traces The crossApplicationTracer element is a child of the configuration element. crossApplicationTracer links transaction traces across applications. When linked in a service-oriented architecture, all instrumented applications that communicate with each other via HTTP will now \"link\" transaction traces with the applications that they call and the applications they are called by. Cross application tracing makes it easier to understand the performance relationship between services and applications. <crossApplicationTracer enabled=\"true\"/> Copy The crossApplicationTracer element supports the following attribute: enabled Type Boolean Default true Enable or disable cross application tracing Error collection The errorCollector element is a child of the configuration element. errorCollector configures error collection, which captures information about uncaught exceptions and sends them to New Relic. <errorCollector enabled=\"true\" captureEvents=\"true\" maxEventSamplesStored=\"100\"> <ignoreClasses> <errorClass>System.IO.FileNotFoundException</errorClass> <errorClass>System.Threading.ThreadAbortException</errorClass> </ignoreClasses> <ignoreMessages> <errorClass name=\"System.Exception\"> <message>Ignore message</message> <message>Ignore too</message> </errorClass> </ignoreMessages> <ignoreStatusCodes> <code>401</code> <code>404</code> </ignoreStatusCodes> <expectedClasses> <errorClass>System.ArgumentNullException</errorClass> <errorClass>System.ArgumentOutOfRangeException</errorClass> </expectedClasses> <expectedMessages> <errorClass name=\"System.Exception\"> <message>Expected message</message> <message>Expected too</message> </errorClass> </expectedMessages> <expectedStatusCodes>403,500-505</expectedStatusCodes> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </errorCollector> Copy Tip For an overview of error configuration in APM, see Manage errors in APM. Important expectedClasses, expectedMessages, and expectedStatusCodes configuration settings require .NET agent version 8.31.0.0 or higher. The errorCollector element supports the following elements and attributes: enabled Type Boolean Default true Enable or disable the error collector. captureEvents Type Boolean Default true Enable or disable the capturing of error events. maxEventSamplesStored Type Integer Default 100 Reservoir limit for error events. ignoreClasses A list of fully qualified class names to be ignored. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreErrors (obsolete) Type String Default (none) Lists specific exceptions to not report to New Relic. The full name of the exception should be used, such as System.IO.FileNotFoundException. ignoreStatusCodes Type String Default (none) Lists specific HTTP error codes to not report to New Relic. You can use standard integral HTTP error codes, such as just 401, or you may use Microsoft full status codes with decimal points, such as 401.4 or 403.18. The status codes should be equal to or greater than 400. expectedClasses A list of fully qualified class names to be marked as expected. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedStatusCodes A comma separated list of status codes. The list may include integer ranges, using a single dash (-) and will be inclusive of both the starting and ending integer in the range. attributes Use this sub-element to customize your agent attribute settings for error traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. High security mode The highSecurity element is a child of the configuration element. To enable high security mode, set this property to true and enable the high security property in the New Relic user interface. Enabling high security turns SSL on; request parameters, custom parameters and HTTP request headers are not collected; strip exception messages is enabled; and queries can't be sent to New Relic in their raw form. enabled Type Boolean Default false Enable or disable high security mode. Example: <highSecurity enabled=\"true\"/> Copy Strip exception messages The stripExceptionMessages element is a child of the configuration element. To enable strip exception messages, set this property to true. By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. enabled Type Boolean Default false Enable or disable strip exception messages. Example: <stripExceptionMessages enabled=\"true\"/> Copy Transaction events The transactionEvents element is a child of the configuration element. Use transactionEvents to configure transaction events. <transactionEvents enabled=\"true\" maximumSamplesStored=\"10000\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionEvents> Copy The transactionEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_TRANSACTION_SAMPLES_STORED environment variable in the application's environment. MAX_TRANSACTION_SAMPLES_STORED=500 Copy attributes Use this sub-element to customize your agent attribute settings for transaction events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to transaction events. Attribute settings can be applied globally to all event types to with this configuration setting. Caution When distributed tracing and/or Infinite Tracing are enabled, information from transaction events is applied to the root Span Event of the transaction. Consider applying any attribute settings for transaction events to span events and/or apply them as Global Attribute settings. Custom events The customEvents element is a child of the configuration element. Use customEvents to configure custom events. <customEvents enabled=\"true\" maximumSamplesStored=\"10000\"/> Copy The CustomEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_EVENT_SAMPLES_STORED environment variable in the application's environment. MAX_EVENT_SAMPLES_STORED=500 Copy Custom parameters The customParameters element is a child of the configuration element. Use customParameters to configure custom parameters. <customParameters enabled=\"true\" /> Copy The CustomParameters element supports the following attributes: enabled Type Boolean Default true Enable or disable the capture of custom parameters. Labels (tags) The labels element is a child of the configuration element. This sets tag names and values. The list is a semicolon delimited list of colon-separated name and value pairs. You can also use with the NEW_RELIC_LABELS environment variable. Example: <labels>foo:bar;zip:zap</labels> Copy Browser instrumentation The browserMonitoring element is a child of the configuration element. browserMonitoring configures browser monitoring in your .NET application. Browser gives you insight your end users' performance experience. This is accomplished by measuring the time it takes for your users' browsers to download and render your webpages by injecting a small amount of JavaScript code into the header and footer of each page. // If you use both the Exclude and Attribute elements // the Exclude element must be listed first. <browserMonitoring autoInstrument=\"true\"> <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </browserMonitoring> Copy The browserMonitoring element supports the following attributes: autoInstrument Type Boolean Default true By default the agent automatically injects the browser agent JavaScript. To turn off automatic injection, set this attribute to false. attributes Use this sub-element to customize your agent attribute settings for browser monitoring. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. requestPathsExcluded Use this sub-element to prevent the browser agent from being injected in specific pages. The element is used as follows: <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> Copy The agent will not inject the browser agent into pages whose URL matches one of the specified regular expressions. The regular expression should follow Microsoft guidelines for the Regex class. It is a reference to the virtual directory of the path in your application and not the full URL of the path you wish to exclude. For example, to exclude the pages in https://www.mywebsite.com/mywebpages/ you would simply insert /mywebpages/ as the path regex value. The requestPathsExcluded element should be used in cases where it is impossible or undesirable to use the DisableBrowserMonitoring() call. To minimize a possible performance impact try to use as few regular expressions as possible and keep them as simple as possible. Slow queries The slowSql element is a child of the configuration element. slowSql configures capturing information about slow query executions, and captures and obfuscates explain plans for these queries. <slowSql enabled=\"true\"/> Copy The slowSql element supports the following attribute: enabled Type Boolean Default true Enable or disable slow query tracing. Transaction traces The transactionTracer element is a child of the configuration element. transactionTracer configures transaction traces. Included in the trace is the exact call sequence of the transactions, including any query statements issued. <transactionTracer enabled=\"true\" transactionThreshold=\"apdex_f\" recordSql=\"obfuscated\" explainEnabled=\"true\" explainThreshold=\"500\" maxSegments=\"3000\" maxExplainPlans=\"20\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionTracer> Copy The transactionTracer element supports the following attributes: enabled Type Boolean Default true Enable or disable transaction traces. transactionThreshold Type String Default apdex_f Defines the threshold for transaction traces. If a transaction takes longer than the threshold, it is eligible for being traced. See transaction trace basics for more about the rules governing traces. The default value is apdex_f, which sets the threshold to four times the application's apdex_t value. For more information about apdex_t, see Apdex. You can also set the threshold to be a specific time value in milliseconds. recordSql Type String Default obfuscated Select a query tracing policy. Options are off, which records nothing; obfuscated, which records an obfuscated version of the query; or raw, which records the query exactly as it is issued to the database. Caution Recording raw queries may capture sensitive information. explainEnabled Type Boolean Default false When true, the agent captures EXPLAIN statements for slow queries. explainThreshold Type Integer Default 500 Unit Milliseconds The agent collects slow query data for queries that exceed this threshold, along with any available explain plans, as part of transaction traces. maxSegments Type Integer Default 3000 The maximum number of segments to collect in a transaction trace. maxExplainPlans Type Integer Default 20 The maximum number of explain plans to collect during a harvest cycle. maxStackTrace Type Integer Default 0 By default maxStackTrace is set to 0, which disables stack traces as part of a transaction trace. If this value is set greater than 0, then stack traces will be captured for transaction traces. attributes Use this sub-element to customize your agent attribute settings for transaction traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Datastore tracer The datastoreTracer element is a child of the configuration element. <datastoreTracer> <instanceReporting enabled=\"true\" /> <databaseNameReporting enabled=\"true\" /> <queryParameters enabled=\"false\" /> </datastoreTracer> Copy The datastoreTracer element supports the following sub-elements: instanceReporting Use this sub-element to enable collection of datastore instance metrics (such as the host and port) for some database drivers. These are reported on slow query traces and transaction traces. The default value of attribute enabled is true. databaseNameReporting Use this sub-element to enable collection of the database name on slow query traces and transaction traces for some database drivers. The default value of attribute enabled is true. queryParameters Use this sub-element to enable collection of the SQL query parameters on slow query traces. The default value of attribute enabled is false. Caution Recording query parameters may capture sensitive information. The transactionTracer.recordSql configuration option must be set to raw or this option is ignored. Distributed tracing The distributedTracing element is a child of the configuration element. <distributedTracing enabled=\"false\" excludeNewrelicHeader=\"false\"/> Copy Distributed tracing lets you see the path that a request takes as it travels through a distributed system. Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the planning guide. Important Requires .NET agent version 8.6.45.0 or higher. The distributedTracing element supports the following attributes: To enable or disable, see Enable distributed tracing. enabled Type Boolean Default false Alternatively, enable distributed tracing via the NEW_RELIC_DISTRIBUTED_TRACING_ENABLED environment variable in the application's environment. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy excludeNewrelicHeader Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. Distributed tracing reports span events. Span event reporting is enabled by default, but distributed tracing must be enabled for spans to be reported. To disable span events, choose one of the following options: Disable span events via config file Set the <spanEvents> element to false to disable via the newrelic.config file. This element is a child of the <configuration> element. <configuration . . . > <spanEvents enabled=\"false\" /> </configuration> Copy Disable span events via environment variable Set the NEW_RELIC_SPAN_EVENTS_ENABLED environment variable in the application's environment. NEW_RELIC_SPAN_EVENTS_ENABLED=false Copy Infinite Tracing Infinite Tracing extends the distributed tracing service by employing a trace observer that is external to the agent. It observes 100% of your application traces across various services and provides actionable data so you can solve issues faster. Important Infinite Tracing requires .NET Agent version 8.30 or higher. To turn on Infinite Tracing, enable distributed tracing and add the additional settings below <configuration . . . > <distributedTracing enabled=\"true\" /> <infiniteTracing> <trace_observer host=\"YOUR_TRACE_OBSERVER_HOST\" /> </infiniteTracing> </configuration> Copy The infiniteTracing element supports the following elements: trace_observer The trace_observer element identifies an observer host that is independent from the agent. For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint. The trace observer may be configured using the NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST environment variable as well. Important When configuring the trace observer, you should not supply the protocol as part of the host. For example, use myhost.infinitetracing.com instead of https://myhost.infinitetracing.com. Span events The spanEvents element is a child of the configuration element. Use spanEvents to configure span events. <spanEvents enabled=\"true\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </spanEvents> Copy The spanEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Int Default 2000 The maximum number of samples to store in memory at a time. This may be configured using the NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED environment variable as well. Important This configuration option is only available in the .NET Agent v9.0 or higher. attributes Use this sub-element to customize your agent attribute settings for span events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to span events. Attribute settings may be applied globally to all event types to with this configuration setting. Capture HTTP Request Headers The allowAllHeaders element is a child of the configuration element. Set this to true to allow the .NET Agent to capture all HTTP request headers as request.headers.{http-header-name} attributes. Set this to false to only allow the .NET agent to collect the following HTTP request headers: request.headers.referer request.headers.accept request.headers.content-length request.headers.host request.headers.user-agent Copy enabled Type Boolean Default false Enable or disable HTTP request headers capture. Example: <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> </attributes> Copy Important The allowAllHeaders setting is only available in the .NET Agent version 8.40.0+. When using allowAllHeaders to capture attributes, the captured request header attributes are still being controlled by the root level and destination level attributes settings. Without setting the request.header.* in the include list under the attributes element (see the following), the .NET Agent still filters out all header attributes. The default newrelic.config is set to include the request.header.*. <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> ... </attributes> Copy The default newrelic.config is also set to explicitly exclude the following HTTP request headers to prevent the .NET Agent collecting unwanted data. <attributes enabled=\"true\"> <exclude>request.headers.cookie</exclude> <exclude>request.headers.authorization</exclude> <exclude>request.headers.proxy-authorization</exclude> <exclude>request.headers.x-*</exclude> </attributes> Copy Settings in app.config or web.config For ASP.NET and .NET Framework console apps you can also configure the following settings in your app's app.config or web.config, within the outermost element, <configuration>: Enable and disable the agent <appSettings> <add key = \"NewRelic.AgentEnabled\" value=\"false\" /> </appSettings> Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Application name For more information, see Name your .NET application. <appSettings> <add key = \"NewRelic.AppName\" value =\"Descriptive Name\" /> </appSettings> Copy License key <appSettings> <add key = \"NewRelic.LicenseKey\" value =\"XXXXXXXX\" /> </appSettings> Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. <appSettings> <add key = \"NewRelic.ConfigFile\" value=\"C:\\Path-to-alternate-config-dir\\newrelic.config\" /> </appSettings> Copy Settings in appsettings.json For .NET Core apps, you can configure the following settings in appsettings.json if the following is true: The appsettings.json file must be located in the current working directory of the application. The application must have the following dependencies: Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.EnvironmentVariables Enable and disable the agent { \"NewRelic.AgentEnabled\":\"false\" } Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled setting in this file will be ignored. Application name For more information, see Name your .NET application. { \"NewRelic.AppName\": \"Descriptive Name\" } Copy License key { \"NewRelic.LicenseKey\": \"XXXXXXXX\" } Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. { \"NewRelic.ConfigFile\": \"C:\\\\Path-to-alternate-config-dir\\\\newrelic.config\" } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.417076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> configuration",
        "sections": ".<em>NET</em> <em>agent</em> configuration",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": ", such as: setting a log level, setting up proxy host access, excluding certain <em>attributes</em>, and enabling distributed tracing. The .<em>NET</em> <em>agent</em> gets its configuration from the newrelic.config file, which is generated as part of the install process. By default, only a global newrelic.config file is created, but you"
      },
      "id": "60446c3b196a679d6a960f7a"
    }
  ],
  "/docs/agents/net-agent/attributes/enable-disable-attributes-net": [
    {
      "sections": [
        ".NET custom attributes"
      ],
      "title": ".NET custom attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "491bfa6b3b5646899f6b0fbf541e1e6172593219",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/custom-attributes-net/",
      "published_at": "2021-10-18T20:55:46Z",
      "updated_at": "2021-09-20T19:34:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can create custom attributes using the AddCustomAttribute API. When adding custom attribute values to transactions, custom events, spans, and errors, the API accepts an object. This describes how these values are processed and how they will appear in APM. In all cases, NULL values are not recorded. .NET type How the value will be represented byte, Int16, Int32, Int64 sbyte, UInt16, UInt32, UInt64 As an integral value float, double, decimal A decimal-based number string A string truncated after 255-bytes. Empty strings are supported. bool True or false DateTime A string representation following the ISO-8601 format, including time zone information: 2020-02-13T11:31:19.5767650-08:00 TimeSpan A decimal-based number representing number of seconds. everything else the ToString() method will be applied.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.31577,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> custom <em>attributes</em>",
        "sections": ".<em>NET</em> custom <em>attributes</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "<em>Attributes</em> are key-value pairs containing information that determines the properties of an event or transaction. You can create custom <em>attributes</em> using the AddCustomAttribute API. When adding custom attribute values to transactions, custom events, spans, and errors, the API accepts an object"
      },
      "id": "60441bcf196a670a80960f3a"
    },
    {
      "sections": [
        "SetUserParameters (.NET agent)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples",
        "Record three user attributes",
        "Record two user attributes and one empty attribute"
      ],
      "title": "SetUserParameters (.NET agent)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "23e2d652abbd86b20905ee0296bbca03f95ca5a1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/net-agent-api/set-user-parameters/",
      "published_at": "2021-10-18T05:48:57Z",
      "updated_at": "2021-09-20T19:35:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.Api.Agent.NewRelic.SetUserParameters(string $user_value, string $account_value, string $product_value) Copy Create user-related custom attributes. AddCustomAttribute() is more flexible. Requirements Compatible with all agent versions. Must be called inside a transaction. Description Tip This call only allows you to assign values to pre-existing keys. For a more flexible method to create key/value pairs, use AddCustomAttribute(). Define user-related custom attributes to associate with a browser page view (user name, account name, and product name). The values are automatically associated with pre-existing keys (user, account, and product), then attached to the parent APM transaction. You can also attach (or \"forward\") these attributes to browser PageView events. Parameters Parameter Description $user_value string Required (can be null). Specify a name or username to associate with this page view. This value is assigned to the user key. $account_value string Required (can be null). Specify the name of a user account to associate with this page view. This value is assigned to the account key. $product_value string Required (can be null). Specify the name of a product to associate with this page view. This value is assigned to the product key. Examples Record three user attributes NewRelic.Api.Agent.NewRelic.SetUserParameters(\"MyUserName\", \"MyAccountName\", \"MyProductName\"); Copy Record two user attributes and one empty attribute NewRelic.Api.Agent.NewRelic.SetUserParameters(\"MyUserName\", \"\", \"MyProductName\"); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.02845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SetUserParameters (.<em>NET</em> <em>agent</em>)",
        "sections": "SetUserParameters (.<em>NET</em> <em>agent</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Syntax NewRelic.Api.<em>Agent</em>.NewRelic.SetUserParameters(string $user_value, string $account_value, string $product_value) Copy Create user-related custom <em>attributes</em>. AddCustomAttribute() is more flexible. Requirements Compatible with all <em>agent</em> versions. Must be called inside a transaction. Description"
      },
      "id": "6043d56428ccbcb1ea2c60e4"
    },
    {
      "sections": [
        ".NET agent configuration",
        "Important",
        "Configuration overview",
        "Configuration methods and precedence levels",
        "Required environment variables",
        "Caution",
        ".NET Framework environment variables",
        ".NET Core environment variables",
        "Profiler conflict explanation",
        "Optional environment variables",
        "Setup options, newrelic.config",
        "Configuration element",
        "agentEnabled",
        "maxStackTraceLines",
        "timingPrecision",
        "Service element",
        "licenseKey (required)",
        "sendEnvironmentInfo",
        "syncStartup",
        "sendDataOnExit",
        "sendDataOnExitThreshold",
        "completeTransactionsOnThread",
        "requestTimeout",
        "autoStart",
        "Obscuring key element",
        "Proxy element",
        "host",
        "port",
        "uriPath",
        "domain",
        "user",
        "password",
        "passwordObfuscated",
        "Log element",
        "level",
        "auditLog",
        "console",
        "directory",
        "fileName",
        "Application element (required)",
        "name",
        "disableSamplers",
        "Data transmission element",
        "putForDataSend",
        "Host name",
        "Set using config file",
        "Set using environment variable",
        "Cloud platform utilization",
        "detectAws",
        "detectAzure",
        "detectGcp",
        "detectPcf",
        "detectDocker",
        "detectKubernetes",
        "Instrumentation options",
        "Instrumentation element",
        "Applications element (instrumentation)",
        "Attributes element",
        "enabled",
        "include",
        "exclude",
        "Feature options",
        "App pools",
        "defaultBehavior",
        "applicationPool",
        "Cross application traces",
        "Error collection",
        "Tip",
        "captureEvents",
        "maxEventSamplesStored",
        "ignoreClasses",
        "ignoreMessages",
        "ignoreErrors (obsolete)",
        "ignoreStatusCodes",
        "expectedClasses",
        "expectedMessages",
        "expectedStatusCodes",
        "attributes",
        "High security mode",
        "Strip exception messages",
        "Transaction events",
        "maximumSamplesStored",
        "Custom events",
        "Custom parameters",
        "Labels (tags)",
        "Browser instrumentation",
        "autoInstrument",
        "requestPathsExcluded",
        "Slow queries",
        "Transaction traces",
        "transactionThreshold",
        "recordSql",
        "explainEnabled",
        "explainThreshold",
        "maxSegments",
        "maxExplainPlans",
        "maxStackTrace",
        "Datastore tracer",
        "instanceReporting",
        "databaseNameReporting",
        "queryParameters",
        "Distributed tracing",
        "excludeNewrelicHeader",
        "Disable span events via config file",
        "Disable span events via environment variable",
        "Infinite Tracing",
        "trace_observer",
        "Span events",
        "Capture HTTP Request Headers",
        "Settings in app.config or web.config",
        "Enable and disable the agent",
        "Application name",
        "License key",
        "Change newrelic.config location",
        "Settings in appsettings.json"
      ],
      "title": ".NET agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Configuration"
      ],
      "external_id": "b89fa7fc399f2729bfee8f5106e777798a73177a",
      "image": "https://docs.newrelic.com/static/cffd7eb2d22c8e338531c38f35208c7c/c1b63/net-agent-config-settings-precedence_0.png",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/configuration/net-agent-configuration/",
      "published_at": "2021-10-19T05:54:03Z",
      "updated_at": "2021-09-20T19:41:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains the configuration options for the APM .NET agent. Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Configuration overview APM agent configuration options allow you to control some aspects of how the agent behaves. Some of these config options are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as: setting a log level, setting up proxy host access, excluding certain attributes, and enabling distributed tracing. The .NET agent gets its configuration from the newrelic.config file, which is generated as part of the install process. By default, only a global newrelic.config file is created, but you can also create app-local newrelic.config files for finer control over a multi-app system. Other ways to set config options include: using environment variables, or setting server-side configuration from the UI. For more on the various config options and what overrides what, see Config settings precedence. Support for both .NET Framework and .NET Core use the same configuration options and have the same APM features, unless otherwise stated. If you make changes to the config file and want to validate that it's in the right format, you can check it against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows) with any XSD validator. Important For IIS: after you change your newrelic.config or app.config file, perform an IISRESET from an administrative command prompt. Log level adjustments do not require a reset. Configuration methods and precedence levels Upon installation, the .NET agent's configuration file (newrelic.config) applies to all monitored applications, but you can configure the agent in other ways. Here's a diagram showing how different configuration options take precedence over one another: This diagram explains the order of precedence for different ways you might configure the .NET agent. Here are details about the configuration methods shown in the diagram, and their precedence levels: .NET configuration Details and precedence web.config or app.config or appsettings.json Configuration settings set in these files take highest precedence. However, if the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Environment variables Second-highest precedence. For more about these, see .NET environment variables. Server-side configuration Third-highest precedence. A limited number of server-side configuration settings are available; the other settings will come from other configuration sources. App-local newrelic.config Fourth-highest precedence. You can create app-local newrelic.config files to configure individual apps on a multi-app system. These local configuration files override settings in the global newrelic.config file. The agent looks for app-local config files in the following directories, in this order: A directory specified in your web.config or app.config file with the NewRelic.ConfigFile property The web app's root directory (with the app.config or web.config) The directory containing your app's executable file Note that the app-local config file must be complete and validate against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows). Default (global) newrelic.config Default source and the lowest precedence. Will configure all applications on a host in the absence of other config files. The global config file is located in the New Relic agent home directory: %PROGRAMDATA%\\New Relic\\.NET Agent Required environment variables New Relic's .NET agent relies on environment variables to tell the .NET Common Language Runtime (CLR) to attach New Relic to your processes. Some .NET agent install procedures (like the MSI installer) will automatically set these variables for you; some procedures will require you to manually set them. Caution Security recommendation: You should consider what users can set system environment variables. You should also secure the accounts under which your applications execute to prevent user environment variables overriding system environment variables .NET Framework environment variables For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. .NET Core environment variables For .NET Core, the following variables are required: Linux: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path/to/agent/directory CORECLR_PROFILER_PATH=\"${CORECLR_NEWRELIC_HOME}/libNewRelicProfiler.so\" Copy Windows: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. If your system has previously used monitoring services (non-New Relic), you may have a \"profiler conflict\" when trying to install and use the New Relic agent. More details: Profiler conflict explanation New Relics .NET agents rely on environment variables to tell the .NET Common Language Runtime (CLR) to load New Relic into your processes. The install-related environment variables are Microsoft variables, not New Relic variables. They can be used by other .NET profilers, and only one profiler can be attached to a process at a time. For this reason, if you have used previous application monitoring products, you may have profiler conflicts. For specific install instructions, see the .NET agent install documentation. Optional environment variables Some configuration options in New Relic's .NET agent can be set via environment variables as an alternative to setting them in a config file. Below is a list of environment variables recognized by the .NET agent with example values. NEW_RELIC_LICENSE_KEY=XXXXXXXX NEW_RELIC_LOG=MyApp.log NEW_RELIC_APP_NAME=Descriptive Name MAX_TRANSACTION_SAMPLES_STORED=500 MAX_EVENT_SAMPLES_STORED=500 NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_SPAN_EVENTS_ENABLED=false NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED=2000 NEW_RELIC_LABELS=foo:bar;zip:zap NEW_RELIC_CONFIG_OBSCURING_KEY=XXXXXXXX NEW_RELIC_DISABLE_SAMPLERS=true NEWRELIC_PROFILER_LOG_DIRECTORY=path\\to\\a\\directory (not configurable via config file) NEWRELIC_LOG_DIRECTORY=path\\to\\a\\directory (Insert a directory where you want to put the agent and profiler logs. You can't set this directory for both agent and profiler logs in the configuration file.) NEWRELIC_LOG_LEVEL=off|error|warn|info|debug|finest|all Copy Setup options, newrelic.config Use these options to setup and configure your agent via the newrelic.config file. The New Relic .NET agent supports the following categories of setup options: Configuration element Service element Obscuring key element Proxy element Log element Application element (configuration) Data transmission element Host name Configuration element The root element of the configuration document is a configuration element. <configuration xmlns=\"urn:newrelic-config\" agentEnabled=\"true\" maxStackTraceLines=\"50\" timingPrecision=\"low\"> Copy The configuration element supports the following attributes: agentEnabled Type Boolean Default true Enable or disable the New Relic agent. maxStackTraceLines Type Integer Default 80 The maximum number of stack frames to trace in any stack dump. timingPrecision Type String Default low Controls the precision of the timers. High precision will provide better data, but at a lower execution speed. Possible values are high and low. Service element The first child of the configuration element is a service element. The service element configures the agent's connection to the New Relic service. <service licenseKey=\"YOUR_LICENSE_KEY\" sendEnvironmentInfo=\"true\" syncStartup=\"false\" sendDataOnExit=\"false\" sendDataOnExitThreshold=\"60000\" autoStart=\"true\"/> Copy The service element supports the following attributes: licenseKey (required) Type String Default (none) Your New Relic license key. New Relic uses the license key to match your app's data to the correct account in the UI. Set the license key via environment variable. Alternatively, set the NEW_RELIC_LICENSE_KEY environment variable in the application's environment. NEW_RELIC_LICENSE_KEY=XXXXXXXX Copy sendEnvironmentInfo Type Boolean Default true Instructs the agent to record execution environment information. Environment information includes operating system, agent version, and which assemblies are available. syncStartup Type Boolean Default false Block application startup until the agent connects to New Relic. If set to true, the first transaction may take substantially longer to complete, because it is blocked until the connection to New Relic is finished. sendDataOnExit Type Boolean Default false Block application shutdown until the agent sends all data from the latest harvest cycle. sendDataOnExitThreshold Type Integer Default 60000 Unit Milliseconds The minimum amount of time the process must run before the agent blocks it from shutting down. This setting only applies when sendDataOnExit is true. completeTransactionsOnThread Type Boolean Default false If false, the agent uses a pool thread to complete the transaction processing. If true, the agent will complete transaction processing on the request thread. requestTimeout Type Integer Default 2000 (sendDataOnExit enabled) 120000 (sendDataOnExit disabled) Unit Milliseconds The agent's request timeout when communicating with New Relic. autoStart Type Boolean Default True Automatically start the .NET agent when the first instrumented method is hit. Obscuring key element The obscuringKey element is an optional child of the service element. The .NET Agent uses this value to deobfuscate supported configuration values. For example, when an obfuscated proxy password is supplied, it will be deobfuscated using this key. <service licenseKey=\"YOUR_LICENSE_KEY\"> <obscuringKey>OBSCURING_KEY</obscuringKey> </service> Copy The obscuring key may also be configured by setting the NEW_RELIC_CONFIG_OBSCURING_KEY environment variable. Caution Security recommendation: The placement of the obscuring Key in the same configuration file as an obfuscated value may pose a security risk. Consider placing the obscuring key in an environment variable and limiting access to environment variables within your environment. Proxy element The proxy element is an optional child of the service element. The proxy element is used when the agent communicates to the New Relic back-end service via a proxy. <service licenseKey=\"YOUR_LICENSE_KEY\"> <proxy host=\"hostname\" port=\"PROXY_PORT\" uriPath=\"path/to/something.aspx\" domain=\"mydomain.com\" user=\"PROXY_USERNAME\" password=\"PROXY_PASSWORD\" passwordObfuscated=\"OBFUSCATED_PROXY_PASSWORD\"/> </service> Copy The proxy element supports the following attributes: host Type String Default (none) Defines the proxy host. port Type Integer Default 8080 Defines the proxy port. uriPath Type String Default (none) Optionally define a proxy URI path. domain Type String Default (none) Optionally define a domain to use when authenticating with the proxy server. user Type String Default (none) Optionally define a user name for authentication. password Type String Default (none) Optionally define a password for authentication. passwordObfuscated Type String Default (none) For additional security, the .NET Agent supports the use of an obfuscated proxy password with the passwordObfuscated attribute. The obfuscated proxy password is generated using the following New Relic CLI command: newrelic agent config obfuscate --key OBSCURING_KEY --value \"CLEAR_TEXT_PROXY_PASSWORD\" Copy Important When using an obfuscated proxy password, the obscuring key must also be configured. Log element The log element is a child of the configuration element. The log element configures New Relic's logging . The agent generates its own log file to keep its logging information separate from your application's logs. <log level=\"info\" auditLog=\"false\" console=\"false\" directory=\"PATH\\TO\\LOG\\DIRECTORY\" fileName=\"FILENAME.log\" /> Copy The log element supports the following attributes: level Type String Default info Defines the level of detail recorded in the log file. Possible values, in increasing order of detail, are: off error warn info debug finest all Alternatively, set the NEWRELIC_LOG_LEVEL environment variable in the application's environment. Important Increasing the log level will increase New Relic's performance impact. auditLog Type Boolean Default false Records all data sent to and received from New Relic in both an auditlog log file and the standard log file. console Type Boolean Default false Send log messages to the console, in addition to the log file. directory Type String Default C:\\ProgramData\\New Relic\\.NET Agent\\Logs The directory to hold log files generated by the agent. If this is omitted, then a directory named logs in the New Relic agent install area will be used by default. fileName Type String Default (none) Defines a name for the log file. If you do not define a fileName, the name is derived from the name of the monitored process. Alternatively, set the NEW_RELIC_LOG environment variable in the application's environment. NEW_RELIC_LOG=MyApp.log Copy Application element (required) The application element is a child of the configuration element. This required element defines your application name, and disables or enables sampling. name Type String Default My Application The name of your .NET application is a child of the application element. New Relic will aggregate your data according to this name. For example, if you have two running applications named AppA and AppB, you will see two applications in the New Relic interface: AppA and AppB. You can also assign up to three names to your app. The first name is the primary name. For example: <application> <name>MY APPLICATION PRIMARY</name> <name>SECOND APP NAME</name> <name>THIRD APP NAME</name> </application> Copy Alternatively, set the NEW_RELIC_APP_NAME environment variable in the application's environment. NEW_RELIC_APP_NAME=Descriptive Name Copy disableSamplers Type Boolean Default false Samplers collect information about memory and CPU consumption. Set this to true to disable sampling. Alternatively, set the NEW_RELIC_DISABLE_SAMPLERS environment variable in the application's environment. NEW_RELIC_DISABLE_SAMPLERS=true Copy Data transmission element The dataTransmission element is a child of the configuration element. This element affects how data is sent to New Relic and can be used if you have specific data transmission requirements. <dataTransmission putForDataSend=\"false\" compressedContentEncoding=\"deflate\"/> Copy The dataTransmission element supports the following attributes: putForDataSend Type Boolean Default false Defines the HTTP method used when sending data to New Relic. Set this to true to enable using the PUT method when sending data. The POST method is used by default. Host name If the default host name label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. After the application process is restarted and the .NET agent is reporting again, the display name will appear in the Servers drop-down list. This host name setting does not affect the list of hosts on your application's Summary page. To set a display name, choose one of the following options. The environment variable takes precedence over the config file value. Then restart your application to see your changes in the New Relic UI. Set using config file Set the displayName attribute in the processHost element in newrelic.config. The processHost element is a child of the configuration element. <configuration . . . > <processHost displayName=\"CUSTOM_NAME\" /> </configuration> Copy Set using environment variable Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable: NEW_RELIC_PROCESS_HOST_DISPLAY_NAME = \"CUSTOM_NAME\" Copy Cloud platform utilization Configures the utilization configuration element to control how the agent collects utilization information and sends it to the New Relic service to determine pricing. The agent can collect information from Amazon Web Services (AWS) EC2 instances, Docker containers, Azure, Google Cloud Platform, Pivotal Cloud Foundry, and Kubernetes. detectAws Type Boolean Default true Determines whether the agent polls AWS metadata API. detectAzure Type Boolean Default true Determines whether the agent polls Azure metadata API. detectGcp Type Boolean Default true Determines whether the agent polls GCP metadata API. detectPcf Type Boolean Default true Determines whether the agent polls PCF information from environment variables. detectDocker Type Boolean Default true Determines whether the agent reads Docker information from the file system. detectKubernetes Type Boolean Default true Determines whether the agent polls Kubernetes information from environment variables. Instrumentation options Use these options to configure which elements of your application and environment to instrument. New Relic for .NET supports the following categories of instrumentation options: Instrumentation element Applications element (instrumentation) Attributes element Instrumentation element The instrumentation element is a child of the configuration element. By default, the .NET agent instruments IIS asp worker processes and Azure web and worker roles. To instrument other processes, see Instrumenting custom applications. Applications element (instrumentation) The applications element is a child of the instrumentation element. The applications element specifies which non-web apps to instrument. It contains a name attribute. Important This is not the same as the application (configuration) element, which is a child of the configuration element. <instrumentation> <applications> <application name=\"MyService1.exe\" /> <application name=\"MyService2.exe\" /> <application name=\"MyService3.exe\" /> </applications> </instrumentation> Copy Attributes element An attribute is a key/value pair that determines the properties of an event or transaction. Each attribute is sent to APM transaction traces, APM error traces, Transaction events, TransactionError events, or PageView events. The primary attributes element enables or disables attribute collection for the .NET agent, and defines specific attributes to collect or exclude. You can also configure attribute settings based on their destination: Error collection, transaction traces, browser instrumentation, and transaction events. In this example, the agent excludes all attributes whose key begins with myApiKey (myApiKey.bar, myApiKey.value), but collects the custom attribute myApiKey.foo. <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> Copy You can view the .NET APM attributes on the .NET agent attributes page. You can also define custom attributes with the agent API call AddCustomAttribute. enabled Type Boolean Default true Enable or disable attribute collection. When set to false in the primary attribute element, this setting overrides all attribute settings for individual destinations. include Type String Default (none) If attributes are enabled, the agent will collect all attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. exclude Type String Default (none) If attributes are enabled, the agent will not collect attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. Feature options Use these options to enable, disable, and configure New Relic features. New Relic for .NET allows you to configure the following features: App pools Cross application traces Error collection High security mode Strip exception messages Transaction events Custom events Custom parameters Tags/labels Browser instrumentation Slow Queries Transaction traces Datastore tracer Distributed tracing Span events Capture HTTP Request Headers App pools Important This is only applicable to a system's global config file. The applicationPools element is a child of the configuration element. The applicationPools element specifies for the profiler exactly which application pools to instrument and uses the same name as the IIS application pool name. This configuration element is useful when you may need to instrument only a small subset of your app pools. For example, a given server might have several hundred application pools, but only a few of those pools need to be instrumented by the .NET agent. Here is an example of disabling instrumentation for specific application pools: <applicationPools> <applicationPool name=\"Foo\" instrument=\"false\"/> <applicationPool name=\"Bar\" instrument=\"false\"/> </applicationPools> Copy Here is an example of disabling instrumentation for all application pools currently executing on the server and enabling instrumentation for specific application pools: <applicationPools> <defaultBehavior instrument=\"false\"/> <applicationPool name=\"Foo\" instrument=\"true\"/> <applicationPool name=\"Bar\" instrument=\"true\"/> </applicationPools> Copy The applicationPools element supports the following elements: defaultBehavior Type Boolean Default false Defines how the .NET agent will behave on a \"global\" level for application pools served via IIS. The .NET agent instruments all application pools by default. When true, application pools listed under applicationPool with an instrument attribute set to false will not be instrumented. Essentially, when set to false, the application pool list acts as an allow list. When set to true, the application pool list acts as a deny list. applicationPool Defines instrumentation behavior for a specific application pool. The name attribute is the name of an application pool. Enable or disable profiling in the instrument attribute. Define this application in the name attribute. Cross application traces The crossApplicationTracer element is a child of the configuration element. crossApplicationTracer links transaction traces across applications. When linked in a service-oriented architecture, all instrumented applications that communicate with each other via HTTP will now \"link\" transaction traces with the applications that they call and the applications they are called by. Cross application tracing makes it easier to understand the performance relationship between services and applications. <crossApplicationTracer enabled=\"true\"/> Copy The crossApplicationTracer element supports the following attribute: enabled Type Boolean Default true Enable or disable cross application tracing Error collection The errorCollector element is a child of the configuration element. errorCollector configures error collection, which captures information about uncaught exceptions and sends them to New Relic. <errorCollector enabled=\"true\" captureEvents=\"true\" maxEventSamplesStored=\"100\"> <ignoreClasses> <errorClass>System.IO.FileNotFoundException</errorClass> <errorClass>System.Threading.ThreadAbortException</errorClass> </ignoreClasses> <ignoreMessages> <errorClass name=\"System.Exception\"> <message>Ignore message</message> <message>Ignore too</message> </errorClass> </ignoreMessages> <ignoreStatusCodes> <code>401</code> <code>404</code> </ignoreStatusCodes> <expectedClasses> <errorClass>System.ArgumentNullException</errorClass> <errorClass>System.ArgumentOutOfRangeException</errorClass> </expectedClasses> <expectedMessages> <errorClass name=\"System.Exception\"> <message>Expected message</message> <message>Expected too</message> </errorClass> </expectedMessages> <expectedStatusCodes>403,500-505</expectedStatusCodes> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </errorCollector> Copy Tip For an overview of error configuration in APM, see Manage errors in APM. Important expectedClasses, expectedMessages, and expectedStatusCodes configuration settings require .NET agent version 8.31.0.0 or higher. The errorCollector element supports the following elements and attributes: enabled Type Boolean Default true Enable or disable the error collector. captureEvents Type Boolean Default true Enable or disable the capturing of error events. maxEventSamplesStored Type Integer Default 100 Reservoir limit for error events. ignoreClasses A list of fully qualified class names to be ignored. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreErrors (obsolete) Type String Default (none) Lists specific exceptions to not report to New Relic. The full name of the exception should be used, such as System.IO.FileNotFoundException. ignoreStatusCodes Type String Default (none) Lists specific HTTP error codes to not report to New Relic. You can use standard integral HTTP error codes, such as just 401, or you may use Microsoft full status codes with decimal points, such as 401.4 or 403.18. The status codes should be equal to or greater than 400. expectedClasses A list of fully qualified class names to be marked as expected. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedStatusCodes A comma separated list of status codes. The list may include integer ranges, using a single dash (-) and will be inclusive of both the starting and ending integer in the range. attributes Use this sub-element to customize your agent attribute settings for error traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. High security mode The highSecurity element is a child of the configuration element. To enable high security mode, set this property to true and enable the high security property in the New Relic user interface. Enabling high security turns SSL on; request parameters, custom parameters and HTTP request headers are not collected; strip exception messages is enabled; and queries can't be sent to New Relic in their raw form. enabled Type Boolean Default false Enable or disable high security mode. Example: <highSecurity enabled=\"true\"/> Copy Strip exception messages The stripExceptionMessages element is a child of the configuration element. To enable strip exception messages, set this property to true. By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. enabled Type Boolean Default false Enable or disable strip exception messages. Example: <stripExceptionMessages enabled=\"true\"/> Copy Transaction events The transactionEvents element is a child of the configuration element. Use transactionEvents to configure transaction events. <transactionEvents enabled=\"true\" maximumSamplesStored=\"10000\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionEvents> Copy The transactionEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_TRANSACTION_SAMPLES_STORED environment variable in the application's environment. MAX_TRANSACTION_SAMPLES_STORED=500 Copy attributes Use this sub-element to customize your agent attribute settings for transaction events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to transaction events. Attribute settings can be applied globally to all event types to with this configuration setting. Caution When distributed tracing and/or Infinite Tracing are enabled, information from transaction events is applied to the root Span Event of the transaction. Consider applying any attribute settings for transaction events to span events and/or apply them as Global Attribute settings. Custom events The customEvents element is a child of the configuration element. Use customEvents to configure custom events. <customEvents enabled=\"true\" maximumSamplesStored=\"10000\"/> Copy The CustomEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_EVENT_SAMPLES_STORED environment variable in the application's environment. MAX_EVENT_SAMPLES_STORED=500 Copy Custom parameters The customParameters element is a child of the configuration element. Use customParameters to configure custom parameters. <customParameters enabled=\"true\" /> Copy The CustomParameters element supports the following attributes: enabled Type Boolean Default true Enable or disable the capture of custom parameters. Labels (tags) The labels element is a child of the configuration element. This sets tag names and values. The list is a semicolon delimited list of colon-separated name and value pairs. You can also use with the NEW_RELIC_LABELS environment variable. Example: <labels>foo:bar;zip:zap</labels> Copy Browser instrumentation The browserMonitoring element is a child of the configuration element. browserMonitoring configures browser monitoring in your .NET application. Browser gives you insight your end users' performance experience. This is accomplished by measuring the time it takes for your users' browsers to download and render your webpages by injecting a small amount of JavaScript code into the header and footer of each page. // If you use both the Exclude and Attribute elements // the Exclude element must be listed first. <browserMonitoring autoInstrument=\"true\"> <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </browserMonitoring> Copy The browserMonitoring element supports the following attributes: autoInstrument Type Boolean Default true By default the agent automatically injects the browser agent JavaScript. To turn off automatic injection, set this attribute to false. attributes Use this sub-element to customize your agent attribute settings for browser monitoring. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. requestPathsExcluded Use this sub-element to prevent the browser agent from being injected in specific pages. The element is used as follows: <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> Copy The agent will not inject the browser agent into pages whose URL matches one of the specified regular expressions. The regular expression should follow Microsoft guidelines for the Regex class. It is a reference to the virtual directory of the path in your application and not the full URL of the path you wish to exclude. For example, to exclude the pages in https://www.mywebsite.com/mywebpages/ you would simply insert /mywebpages/ as the path regex value. The requestPathsExcluded element should be used in cases where it is impossible or undesirable to use the DisableBrowserMonitoring() call. To minimize a possible performance impact try to use as few regular expressions as possible and keep them as simple as possible. Slow queries The slowSql element is a child of the configuration element. slowSql configures capturing information about slow query executions, and captures and obfuscates explain plans for these queries. <slowSql enabled=\"true\"/> Copy The slowSql element supports the following attribute: enabled Type Boolean Default true Enable or disable slow query tracing. Transaction traces The transactionTracer element is a child of the configuration element. transactionTracer configures transaction traces. Included in the trace is the exact call sequence of the transactions, including any query statements issued. <transactionTracer enabled=\"true\" transactionThreshold=\"apdex_f\" recordSql=\"obfuscated\" explainEnabled=\"true\" explainThreshold=\"500\" maxSegments=\"3000\" maxExplainPlans=\"20\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionTracer> Copy The transactionTracer element supports the following attributes: enabled Type Boolean Default true Enable or disable transaction traces. transactionThreshold Type String Default apdex_f Defines the threshold for transaction traces. If a transaction takes longer than the threshold, it is eligible for being traced. See transaction trace basics for more about the rules governing traces. The default value is apdex_f, which sets the threshold to four times the application's apdex_t value. For more information about apdex_t, see Apdex. You can also set the threshold to be a specific time value in milliseconds. recordSql Type String Default obfuscated Select a query tracing policy. Options are off, which records nothing; obfuscated, which records an obfuscated version of the query; or raw, which records the query exactly as it is issued to the database. Caution Recording raw queries may capture sensitive information. explainEnabled Type Boolean Default false When true, the agent captures EXPLAIN statements for slow queries. explainThreshold Type Integer Default 500 Unit Milliseconds The agent collects slow query data for queries that exceed this threshold, along with any available explain plans, as part of transaction traces. maxSegments Type Integer Default 3000 The maximum number of segments to collect in a transaction trace. maxExplainPlans Type Integer Default 20 The maximum number of explain plans to collect during a harvest cycle. maxStackTrace Type Integer Default 0 By default maxStackTrace is set to 0, which disables stack traces as part of a transaction trace. If this value is set greater than 0, then stack traces will be captured for transaction traces. attributes Use this sub-element to customize your agent attribute settings for transaction traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Datastore tracer The datastoreTracer element is a child of the configuration element. <datastoreTracer> <instanceReporting enabled=\"true\" /> <databaseNameReporting enabled=\"true\" /> <queryParameters enabled=\"false\" /> </datastoreTracer> Copy The datastoreTracer element supports the following sub-elements: instanceReporting Use this sub-element to enable collection of datastore instance metrics (such as the host and port) for some database drivers. These are reported on slow query traces and transaction traces. The default value of attribute enabled is true. databaseNameReporting Use this sub-element to enable collection of the database name on slow query traces and transaction traces for some database drivers. The default value of attribute enabled is true. queryParameters Use this sub-element to enable collection of the SQL query parameters on slow query traces. The default value of attribute enabled is false. Caution Recording query parameters may capture sensitive information. The transactionTracer.recordSql configuration option must be set to raw or this option is ignored. Distributed tracing The distributedTracing element is a child of the configuration element. <distributedTracing enabled=\"false\" excludeNewrelicHeader=\"false\"/> Copy Distributed tracing lets you see the path that a request takes as it travels through a distributed system. Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the planning guide. Important Requires .NET agent version 8.6.45.0 or higher. The distributedTracing element supports the following attributes: To enable or disable, see Enable distributed tracing. enabled Type Boolean Default false Alternatively, enable distributed tracing via the NEW_RELIC_DISTRIBUTED_TRACING_ENABLED environment variable in the application's environment. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy excludeNewrelicHeader Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. Distributed tracing reports span events. Span event reporting is enabled by default, but distributed tracing must be enabled for spans to be reported. To disable span events, choose one of the following options: Disable span events via config file Set the <spanEvents> element to false to disable via the newrelic.config file. This element is a child of the <configuration> element. <configuration . . . > <spanEvents enabled=\"false\" /> </configuration> Copy Disable span events via environment variable Set the NEW_RELIC_SPAN_EVENTS_ENABLED environment variable in the application's environment. NEW_RELIC_SPAN_EVENTS_ENABLED=false Copy Infinite Tracing Infinite Tracing extends the distributed tracing service by employing a trace observer that is external to the agent. It observes 100% of your application traces across various services and provides actionable data so you can solve issues faster. Important Infinite Tracing requires .NET Agent version 8.30 or higher. To turn on Infinite Tracing, enable distributed tracing and add the additional settings below <configuration . . . > <distributedTracing enabled=\"true\" /> <infiniteTracing> <trace_observer host=\"YOUR_TRACE_OBSERVER_HOST\" /> </infiniteTracing> </configuration> Copy The infiniteTracing element supports the following elements: trace_observer The trace_observer element identifies an observer host that is independent from the agent. For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint. The trace observer may be configured using the NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST environment variable as well. Important When configuring the trace observer, you should not supply the protocol as part of the host. For example, use myhost.infinitetracing.com instead of https://myhost.infinitetracing.com. Span events The spanEvents element is a child of the configuration element. Use spanEvents to configure span events. <spanEvents enabled=\"true\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </spanEvents> Copy The spanEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Int Default 2000 The maximum number of samples to store in memory at a time. This may be configured using the NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED environment variable as well. Important This configuration option is only available in the .NET Agent v9.0 or higher. attributes Use this sub-element to customize your agent attribute settings for span events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to span events. Attribute settings may be applied globally to all event types to with this configuration setting. Capture HTTP Request Headers The allowAllHeaders element is a child of the configuration element. Set this to true to allow the .NET Agent to capture all HTTP request headers as request.headers.{http-header-name} attributes. Set this to false to only allow the .NET agent to collect the following HTTP request headers: request.headers.referer request.headers.accept request.headers.content-length request.headers.host request.headers.user-agent Copy enabled Type Boolean Default false Enable or disable HTTP request headers capture. Example: <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> </attributes> Copy Important The allowAllHeaders setting is only available in the .NET Agent version 8.40.0+. When using allowAllHeaders to capture attributes, the captured request header attributes are still being controlled by the root level and destination level attributes settings. Without setting the request.header.* in the include list under the attributes element (see the following), the .NET Agent still filters out all header attributes. The default newrelic.config is set to include the request.header.*. <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> ... </attributes> Copy The default newrelic.config is also set to explicitly exclude the following HTTP request headers to prevent the .NET Agent collecting unwanted data. <attributes enabled=\"true\"> <exclude>request.headers.cookie</exclude> <exclude>request.headers.authorization</exclude> <exclude>request.headers.proxy-authorization</exclude> <exclude>request.headers.x-*</exclude> </attributes> Copy Settings in app.config or web.config For ASP.NET and .NET Framework console apps you can also configure the following settings in your app's app.config or web.config, within the outermost element, <configuration>: Enable and disable the agent <appSettings> <add key = \"NewRelic.AgentEnabled\" value=\"false\" /> </appSettings> Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Application name For more information, see Name your .NET application. <appSettings> <add key = \"NewRelic.AppName\" value =\"Descriptive Name\" /> </appSettings> Copy License key <appSettings> <add key = \"NewRelic.LicenseKey\" value =\"XXXXXXXX\" /> </appSettings> Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. <appSettings> <add key = \"NewRelic.ConfigFile\" value=\"C:\\Path-to-alternate-config-dir\\newrelic.config\" /> </appSettings> Copy Settings in appsettings.json For .NET Core apps, you can configure the following settings in appsettings.json if the following is true: The appsettings.json file must be located in the current working directory of the application. The application must have the following dependencies: Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.EnvironmentVariables Enable and disable the agent { \"NewRelic.AgentEnabled\":\"false\" } Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled setting in this file will be ignored. Application name For more information, see Name your .NET application. { \"NewRelic.AppName\": \"Descriptive Name\" } Copy License key { \"NewRelic.LicenseKey\": \"XXXXXXXX\" } Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. { \"NewRelic.ConfigFile\": \"C:\\\\Path-to-alternate-config-dir\\\\newrelic.config\" } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.41707,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> configuration",
        "sections": ".<em>NET</em> <em>agent</em> configuration",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": ", such as: setting a log level, setting up proxy host access, excluding certain <em>attributes</em>, and enabling distributed tracing. The .<em>NET</em> <em>agent</em> gets its configuration from the newrelic.config file, which is generated as part of the install process. By default, only a global newrelic.config file is created, but you"
      },
      "id": "60446c3b196a679d6a960f7a"
    }
  ],
  "/docs/agents/net-agent/attributes/net-attribute-examples": [
    {
      "sections": [
        "Enable and disable attributes (.NET)",
        "Attribute rules",
        "Root level takes precedence for enabled.",
        "Destination enabled takes precedence over include and exclude.",
        "Attribute is included if the destination is enabled.",
        "Exclude always supersedes include.",
        "Keys are case sensitive.",
        "Use an asterisk * for wildcards.",
        "Most specific setting for a key takes priority.",
        "Include or exclude affects the specific destination.",
        "Obsolete properties",
        "analyticsEvents replaced by transactionEvents",
        "requestParameters replaced by request.parameters.*",
        "parameterGroups: enable and ignore replaced by attributes true, include and exclude",
        "captureAttributes flag replaced by attributes sub-elements"
      ],
      "title": "Enable and disable attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "71d8c3a6ad5df2a487ce2fe102de9ec875f1901d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/enable-disable-attributes-net/",
      "published_at": "2021-10-18T10:47:47Z",
      "updated_at": "2021-09-20T19:34:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes the rules New Relic uses to determine which attributes to include or exclude for a destination. This also includes a summary of the .NET agent properties that were no longer available with the release of New Relic agent attributes in versions 9.0 or higher. Attribute rules New Relic follows these rules to determine which attributes to include or exclude: Root level takes precedence for enabled. The attributes.enabled field overrides all other settings. When false, no attributes will be reported to New Relic. Example configuration: <attributes enabled=\"false\"> <include>foo</include> <include>bar</include> </attributes> <transactionTracer enabled=\"true\"> <attributes enabled=\"true\"/> </transactionTracer> Copy Example output: Keys passed in: foo, bar, bat Keys included for all destinations: Keys excluded for all destinations: foo, bar, bat Copy Destination enabled takes precedence over include and exclude. The {destination}.attributes.enabled flags take precedence over include and exclude keys. Example configuration: <attributes enabled=\"true\"> <include>one</include> <include>two</include> </attributes> <transactionTracer enabled=\"true\"> <attributes enabled=\"false\"> <include>three</include> <include>four</include> </attributes> </transactionTracer> Copy Example output: Keys passed in: one, two, three, four Keys included for transaction traces: Keys excluded for transaction traces: one, two, three, four Copy Attribute is included if the destination is enabled. If a destination is enabled, all user attributes are sent to that destination by default. All user attributes default to true. However, by default, request attributes and message parameters are disabled for all destinations. Example configuration: <attributes enabled=\"true\"> <exclude>myAttKey</exclude> </attributes> Copy Example output: Keys passed in: foo, bar, myAttKey Keys included: foo, bar Keys excluded: myAttKey Copy Exclude always supersedes include. If the same key is listed in the include and exclude lists, then attributes with the specified key will be excluded. Example configuration: <attributes enabled=\"true\"> <include>foo</include> <include>myCustomAtt</include> <exclude>password</exclude> <exclude>myCustomAtt</exclude> </attributes> Copy Example output: Keys passed in: foo, myCustomAtt, password Keys included: foo Keys excluded: password, myCustomAtt Copy Keys are case sensitive. Keys are case sensitive. Example configuration: <attributes enabled=\"true\"> <exclude>password</exclude> <exclude>PaSsWoRd</exclude> </attributes> Copy Example output: Keys passed in: password, Password, PASSWORD, PaSsWoRd, PassWORD Keys included: Password, PASSWORD, PassWORD Keys excluded: password, PaSsWoRd Copy Use an asterisk * for wildcards. You can use an asterisk * at the end of a key as a wildcard. This will match all attributes with the same prefix. Example configuration: <attributes enabled=\"true\"> <include>custom*</include> <exclude>request.parameters.*</exclude> </attributes> Copy Example output: Keys passed in: custom, custom.key1, custom.key2, request.parameters., request.parameters.foo, request.parameters.bar Keys included: custom, custom.key1, custom.key2 Keys excluded: request.parameters., request.parameters.foo, request.parameters.bar Copy Most specific setting for a key takes priority. If multiple include or exclude attributes affect the same key, the most specific setting will have priority. Example configuration: <attributes enabled=\"true\"> <include>request.parameters.foo</include> <exclude>request.parameters.*</exclude> </attributes> Copy Example output: Keys passed in: request.parameters., request.parameters.foo, request.parameters.bar Keys included: request.parameters.foo Keys excluded: request.parameters., request.parameters.bar Copy Include or exclude affects the specific destination. If the attribute include or exclude is specified on a destination, then it only impacts that destination. Example configuration: <attributes enabled=\"true\"> <include>foo</include> </attributes> <transactionEvents enabled=\"true\"> <attributes enabled=\"true\"> <exclude>foo</exclude> </attributes> </transactionEvents> Copy Example output: Keys passed in: foo Keys included for transaction events: Keys included for other destinations: foo Keys excluded for transaction events: foo Copy Obsolete properties The following properties are not available in the .NET agent v9.0. Please visit the .NET agent 8.x to 9.x migration guide page for replacement properties when upgrading your .NET agent. analyticsEvents replaced by transactionEvents The analyticsEvents element in newrelic.config is obsolete. Enable the transactionEvents element in newrelic.config: <transactionEvents enabled=\"true\"/> Copy requestParameters replaced by request.parameters.* By default, request parameters are not sent to New Relic. Add request.parameters.* to the attributes.include list to enable request parameter collection. <attributes> <include>request.parameters.*</include> </attributes> Copy parameterGroups: enable and ignore replaced by attributes true, include and exclude The parameterGroups value and its enabled and ignore settings are obsolete. By default, customParameters and responseHeaderParameters are instrumented, while serviceRequestParameters are not instrumented. To customize these settings: Use the enabled flag to enable instrumentation. Use include and exclude to toggle instrumentation for specific attributes. For example: <attributes enabled=\"true\"> <include>service.request.*</include> <exclude>response.headers.*</exclude> <exclude>myCustomApiKey.*</exclude> </attributes> Copy For more information on configuring attributes, see the attributes examples. captureAttributes flag replaced by attributes sub-elements The capture attributes flag on browserMonitoring, transactionTracer, transactionEvents, and errorCollector is obsolete. Instead, use the attributes sub-element to configure attribute settings for each of these destinations. New property Example browserMonitoring <browserMonitoring enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </browserMonitoring> Copy transactionTracer <transactionTracer enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </transactionTracer> Copy transactionEvents <transactionEvents enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </transactionEvents> Copy errorCollector <errorCollector enabled=\"true\"> <attributes enabled=\"false\"> <include>myKey.*</include> <exclude>myKey.foo</exclude> </attributes> </errorCollector>> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.3158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable and disable <em>attributes</em> (.<em>NET</em>)",
        "sections": "Enable and disable <em>attributes</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This describes the rules New Relic uses to determine which <em>attributes</em> to include or exclude for a destination. This also includes a summary of the .<em>NET</em> <em>agent</em> properties that were no longer available with the release of New Relic <em>agent</em> <em>attributes</em> in versions 9.0 or higher. Attribute rules New Relic"
      },
      "id": "603ed634196a67b796a83d9f"
    },
    {
      "sections": [
        ".NET custom attributes"
      ],
      "title": ".NET custom attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Attributes"
      ],
      "external_id": "491bfa6b3b5646899f6b0fbf541e1e6172593219",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/attributes/custom-attributes-net/",
      "published_at": "2021-10-18T20:55:46Z",
      "updated_at": "2021-09-20T19:34:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can create custom attributes using the AddCustomAttribute API. When adding custom attribute values to transactions, custom events, spans, and errors, the API accepts an object. This describes how these values are processed and how they will appear in APM. In all cases, NULL values are not recorded. .NET type How the value will be represented byte, Int16, Int32, Int64 sbyte, UInt16, UInt32, UInt64 As an integral value float, double, decimal A decimal-based number string A string truncated after 255-bytes. Empty strings are supported. bool True or false DateTime A string representation following the ISO-8601 format, including time zone information: 2020-02-13T11:31:19.5767650-08:00 TimeSpan A decimal-based number representing number of seconds. everything else the ToString() method will be applied.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.31577,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> custom <em>attributes</em>",
        "sections": ".<em>NET</em> custom <em>attributes</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "<em>Attributes</em> are key-value pairs containing information that determines the properties of an event or transaction. You can create custom <em>attributes</em> using the AddCustomAttribute API. When adding custom attribute values to transactions, custom events, spans, and errors, the API accepts an object"
      },
      "id": "60441bcf196a670a80960f3a"
    },
    {
      "sections": [
        "SetUserParameters (.NET agent)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples",
        "Record three user attributes",
        "Record two user attributes and one empty attribute"
      ],
      "title": "SetUserParameters (.NET agent)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "23e2d652abbd86b20905ee0296bbca03f95ca5a1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/net-agent-api/set-user-parameters/",
      "published_at": "2021-10-18T05:48:57Z",
      "updated_at": "2021-09-20T19:35:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.Api.Agent.NewRelic.SetUserParameters(string $user_value, string $account_value, string $product_value) Copy Create user-related custom attributes. AddCustomAttribute() is more flexible. Requirements Compatible with all agent versions. Must be called inside a transaction. Description Tip This call only allows you to assign values to pre-existing keys. For a more flexible method to create key/value pairs, use AddCustomAttribute(). Define user-related custom attributes to associate with a browser page view (user name, account name, and product name). The values are automatically associated with pre-existing keys (user, account, and product), then attached to the parent APM transaction. You can also attach (or \"forward\") these attributes to browser PageView events. Parameters Parameter Description $user_value string Required (can be null). Specify a name or username to associate with this page view. This value is assigned to the user key. $account_value string Required (can be null). Specify the name of a user account to associate with this page view. This value is assigned to the account key. $product_value string Required (can be null). Specify the name of a product to associate with this page view. This value is assigned to the product key. Examples Record three user attributes NewRelic.Api.Agent.NewRelic.SetUserParameters(\"MyUserName\", \"MyAccountName\", \"MyProductName\"); Copy Record two user attributes and one empty attribute NewRelic.Api.Agent.NewRelic.SetUserParameters(\"MyUserName\", \"\", \"MyProductName\"); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.02845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "SetUserParameters (.<em>NET</em> <em>agent</em>)",
        "sections": "SetUserParameters (.<em>NET</em> <em>agent</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Syntax NewRelic.Api.<em>Agent</em>.NewRelic.SetUserParameters(string $user_value, string $account_value, string $product_value) Copy Create user-related custom <em>attributes</em>. AddCustomAttribute() is more flexible. Requirements Compatible with all <em>agent</em> versions. Must be called inside a transaction. Description"
      },
      "id": "6043d56428ccbcb1ea2c60e4"
    }
  ],
  "/docs/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic": [
    {
      "sections": [
        "Install the .NET agent on Azure Web Apps",
        "Installation options",
        "Disable Application Insights",
        "Install using the New Relic Azure Site Extension (Windows Only)",
        "Install using NuGet (.NET Framework)",
        "Install using NuGet (.NET Core)",
        "Log file configuration for Windows",
        "Log file configuration for Linux",
        "Environment variables for Windows",
        "Environment variables for Linux",
        "Add New Relic app settings to Azure App Services",
        "View your app's performance",
        "Troubleshooting"
      ],
      "title": "Install the .NET agent on Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "5cb6afb3ad05fdc243d2cf110f4df1e7e027740d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-web-apps/",
      "published_at": "2021-10-18T11:17:40Z",
      "updated_at": "2021-07-27T11:22:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install New Relic's .NET agent for application performance monitoring on your Azure Web App. (This is not the same as installing the infrastructure monitoring integrations for Microsoft Azure.) Recommendation: Before following these instructions, read the .NET agent installation overview. Installation options Use any of the following methods to add the New Relic .NET agent to your Azure-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, the easiest and most reliable option is to use the publicly maintained Azure site extension. Note: Azure Site Extensions are only currently available for Windows App Service Resources. Install using the Azure Site Extension For developer teams, or anyone needing to deploy the agent on a Linux App Service Resource, installing via nuget is the best option: Install using NuGet (.NET Framework) Install using NuGet (.NET Core) In order to monitor non-web apps (including WebJobs), or ASP.NET Core apps targeting .NET Framework, you must explicitly enable the agent for that application's .exe process via one of these two methods: Enable via placement of local newrelic.config file. Enable via application config file In addition, WebJobs may need custom instrumentation for transactions to appear in APM, and additional configuration if they run for less than one minute. Disable Application Insights Both New Relic's .NET agent and Microsoft Application Insights rely on the CLR Profiler, but only one may be active at a time. You must disable Application Insights in order for the .NET agent to function properly. For more information, see our Application Insights troubleshooting procedures. Install using the New Relic Azure Site Extension (Windows Only) To install the .NET agent for an Azure Web App using the New Relic Azure Site Extension: Shut down your web application before installing the New Relic Azure Site Extension. Add the site extension: Navigate to http://[yoursitename].scm.azurewebsites.net, then select Site extensions > Gallery. Select the plus icon next to the New Relic site extension. In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app to use the new version of the agent. Install using NuGet (.NET Framework) The NuGet installation method packages the New Relic Agent with your application so that it is available to the Azure Web App Host. The NuGet packages in this procedure support only the old packages.config. They do not support the current PackageReference format. For more information, see Microsoft's package reference documentation. For multi-project solutions, make sure you have selected the correct project (for example, a specific web app project) before installing the NuGet package. If you are upgrading the .NET Framework agent using NuGet, any changes you made in the newrelic.config will be overwritten. To preserve any changes, save your newrelic.config outside of your project, then restore it after upgrading. To install the .NET agent on an Azure Web App using NuGet: In the Azure portal, verify your Azure Platform (32-bit or 64-bit): From the Azure sidebar menu, select App Services > Your Application > Settings > Configuration > General settings. Open your application in Visual Studio, and install the New Relic NuGet package by running the appropriate command from the Package manager console: 32-bit: Install-Package NewRelic.Azure.WebSites 64-bit: Install-Package NewRelic.Azure.WebSites.x64 Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Key Value COR_ENABLE_PROFILING 1 COR_PROFILER {71DA0A04-7777-4EC6-9643-7D28B46A8A41} COR_PROFILER_PATH D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Install using NuGet (.NET Core) The NuGet installation method packages the New Relic Agent with your application so that it is available to the Azure Web App Host. New Relic .NET Core agent supports Linux and Windows applications on Azure App Services. The installation process for Azure App Services differs from the .NET Core agent installation procedures for Linux and Windows. To install the .NET agent on an Azure Web App using NuGet: Install the NewRelic.Agent NuGet package. Modify the log node by adding a directory attribute to your newrelic.config file (Note: If Visual Studio prevents you from editing the newrelic.config file that was added to your project by NuGet then you will need to make a local copy of this in your application): Log file configuration for Windows <log directory=\"D:\\Home\\LogFiles\\NewRelic\" level=\"info\"></log> Copy Log file configuration for Linux <log directory=\"/home/LogFiles/NewRelic\" level=\"info\"></log> Copy Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Environment variables for Windows Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH_32 D:\\Home\\site\\wwwroot\\newrelic\\x86\\NewRelic.Profiler.dll CORECLR_PROFILER_PATH_64 D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll CORECLR_NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic Environment variables for Linux Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH /home/site/wwwroot/newrelic/libNewRelicProfiler.so CORECLR_NEWRELIC_HOME /home/site/wwwroot/newrelic NEWRELIC_PROFILER_LOG_DIRECTORY /home/LogFiles/NewRelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Add New Relic app settings to Azure App Services To add your app settings: Make sure you have your license key before adding the New Relic .NET agent's app settings. In the Azure portal, open the web app you want to monitor, then select Configuration > Application settings. From Application settings, select + New application setting and add these key/value pairs: Key Value NEW_RELIC_LICENSE_KEY YOUR_LICENSE_KEY NEW_RELIC_APP_NAME YOUR_APP_NAME Save and restart your web app. Setting the license key and app name with Application settings will override the newrelic.config. To verify your app's environment variables in your app's Kudu diagnostic console, go to Environment > Environment variables. For example: https://myappname.scm.azurewebsites.net/Env.cshtml#envVariables Copy View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Web Apps. To view your app's performance in New Relic: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure portal by going to New Relic Accounts > (select your app). Troubleshooting If no data appears after installing the agent, generating traffic for your app, and waiting a few minutes, try these troubleshooting tips: Make sure that all files in the newrelic directory at the root of your app got published to Azure. Make sure the environment variables are set correctly. Make sure Microsoft Application Insights is not installed and configured on the application. For more information, see the Application Insights troubleshooting procedures. Refer to additional Azure troubleshooting procedures as applicable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.48631,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": " <em>installation</em> overview. <em>Installation</em> options Use any of the following methods to add the New Relic .<em>NET</em> <em>agent</em> to your <em>Azure</em>-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, the easiest and most"
      },
      "id": "603e8e7c28ccbc420ceba748"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Cloud Services",
        "Important",
        "Check Web or Worker role's location",
        "Install the NuGet package for Cloud Services",
        "Instrument Worker role",
        "Custom instrumentation example for Worker role",
        "Custom instrumentation file deployment",
        "Optional: Create custom config file",
        "View your app's performance"
      ],
      "title": "Install the .NET agent on Azure Cloud Services",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "afe3e181b9ec18fa0b2be3e76f7c9b20d247d21e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services/",
      "published_at": "2021-10-18T11:16:49Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET agent on Microsoft's Azure Cloud Services platform. This is not the same as installing the Infrastructure integrations for Microsoft Azure. To make sure you are using the most relevant instructions, first see the .NET agent install overview. Important Before installing the NuGet package into a multi-project Visual Studio solution, make sure you have selected the correct project for your New Relic .NET application (for example, a specific website project). Check Web or Worker role's location If Service files are nested within a Solution folder, the NuGet installer cannot locate or update the necessary files. This will cause issues with the .NET agent setup, which will in turn prevent the agent from reporting metrics on your Cloud Service. Recommendation: Place the Web or Worker role at the root of the solution before installing the NuGet package. Once the New Relic .NET agent is installed, you can move the Cloud role back into the Solution folder. Install the NuGet package for Cloud Services Important The NuGet packages in this procedure support only the old packages.config. They do not support the new PackageReference format. For more information see Microsoft's package reference documentation For multi-project solutions, make sure you have selected the correct project (for example, a specific website project) before installing the NuGet package. Open your Visual Studio solution, or create a new one by selecting File > New > Project. For multi-project solutions, make sure you have selected the correct project (for example, a specific website project). If you do not already have an Azure Cloud Service project in your solution, add one by right-clicking your app in the Solution Explorer and selecting Add Windows Azure Cloud Service Project. Open the Package Manager console by selecting Tools > Library Package Manager > Package Manager Console. Set your project as the default project. From the Package Manager command prompt, type Install-Package NewRelicWindowsAzure and press Enter. Follow the prompts to enter your New Relic license key and your application name as you want it to appear in the New Relic UI. Or, use your solution name as the default app name. From the Solution Explorer, right-click your Azure Cloud Service project, and select Publish. If this is your first time deploying this app to Azure, enter your Azure credentials. If applicable, instrument methods for Worker roles. Instrument Worker role A Worker role is a non-web process run as an Azure Cloud Service. To instrument a Worker role, you must create custom transactions. The .NET agent automatically instruments external calls and database calls, but it does not instrument default methods for transactions. Creating custom transactions solves this. After the Worker role starts up and the method executes, transaction data will appear in the APM Summary and Transactions pages under the Non-web category. The NuGet installer automatically adds the NewRelic.AppName parameter to the application config. This appears as <YOUR_WORKER_ROLE_NAME>.dll.config in E:\\approot. The .NET agent also automatically instruments WaWorkerHost.exe. This is the name of the actual Worker role process. Custom instrumentation example for Worker role This is a custom instrumentation example for a Worker role. It creates a custom transaction named ProcessMessage. The transaction begins when the ProcessMessage method is entered, and it ends when the method returns. The following example uses MyWorkerRole as the namespace. If you do not specify a name, it will default to the Solution name. namespace MyWorkerRole { public class NotificationQueue { public bool ProcessMessage(Message message) { // code to process message } } } Copy Here is the custom instrumentation file for the code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerfactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Custom/ProcessMessage\"> <match assemblyname=\"MyWorkerRole\" classname=\"MyWorkerRole.NotificationQueue\"> <exactmethodmatcher methodName=\"ProcessMessage\" /> </match> </tracerfactory> </instrumentation> </extension> Copy On a local installation, place this instrumentation file in C:\\ProgramData\\New Relic\\.NET Agent\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an Azure Cloud Service deployment: In your Azure Cloud project, add the instrumentation file to your Worker role inside the Roles folder. After installing the New Relic .NET agent NuGet package, locate newrelic.cmd in your Worker Role project. Find the statement IF %ERRORLEVEL% EQU 0 within the :INSTALL_NEWRELIC_AGENT block, and add the following statement to the conditional: IF %ERRORLEVEL% EQU 0 ( copy /Y \"%RoleRoot%\\approot\\MyInstrumentation.xml\" \"%NR_HOME%\\extensions\" >> %RoleRoot%\\nr.log ) ELSE ( Copy In this example, the newrelic.cmd batch file copies the custom instrumentation file to the Extensions folder in D:\\ProgramData\\New Relic\\.NET Agent\\, or %NR_HOME%. This example uses MyInstrumentation.xml, but any name will work as long as the file name and copy command match, and the file is valid XML. Optional: Create custom config file You can create a custom configuration file in Visual Studio. This allows you to make changes to newrelic.config inside Visual Studio, without having to remote into your Azure Role instance every time you make a change. Whenever you publish your app, the config file in Visual Studio is automatically uploaded to the remote host. The choices you make with the installation wizard do not matter. Installing locally does not affect your Azure development environment. In Visual Studio, select the Solution Explorer, then open NewRelicAgent_x64_XYZ.msi. Follow the steps to install the agent locally. Import newrelic.config into your project: In Solution Explorer > Cloud Project, right-click the Web Role, then select Add > Existing Item. Navigate to C: \\ ProgramData \\ New Relic \\ .NET Agent and select newrelic.config. From C: \\ ProgramData \\ New Relic \\ .NET Agent, edit newrelic.cmd. In the :INSTALL_NEWRELIC_AGENT section, find this statement: IF $ERRORLEVEL% EQU 0 ( Copy Add the following code as another statement inside the IF block, then save the file: copy /Y \"%RoleRoot%\\approot\\newrelic.config\" \"%NR_HOME%\" >> %RoleRoot%\\nr.log Copy You can now edit the newrelic.config hosted in Visual Studio. Whenever you publish your app, the copy command will upload the config file to the remote host. View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Cloud Services. To view your app's performance in APM: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure Portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure Portal by going to New Relic Accounts > choose your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.35572,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&gt; &lt;&#x2F;tracerfactory&gt; &lt;&#x2F;instrumentation&gt; &lt;&#x2F;extension&gt; Copy On a local <em>installation</em>, place this instrumentation file in C:\\ProgramData\\New Relic\\.<em>NET</em> <em>Agent</em>\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an <em>Azure</em> Cloud Service deployment: In your"
      },
      "id": "603e8e7ee7b9d2b4d42a07e3"
    },
    {
      "sections": [
        "Install .NET agent on Azure Service Fabric",
        "Important",
        "Install using NuGet",
        ".NET Framework",
        ".NET Core for Windows",
        ".NET Core for Linux"
      ],
      "title": "Install .NET agent on Azure Service Fabric",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "c520de26567fd173a0ac7b19ac0044a5757862bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-service-fabric/",
      "published_at": "2021-10-18T11:17:40Z",
      "updated_at": "2021-03-13T02:21:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET Framework agent and .NET Core agent on Azure Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft Azure. Install .NET agent on Azure Service Fabric Important In most cases, installing the .NET agent in an Azure Service Fabric environment can be performed using the standard install procedures for either Windows or Linux. This document highlights some alternate ways you can install the agent. You will need to ensure the agent gets installed on all nodes in your cluster. To monitor multiple nodes, you may want to integrate the install into your deployment process. If you are using containers in your Service Fabric environment you should read Install for Docker. You can also install the agent in a Service Fabric environment using NuGet. NuGet is often a good option for developers because the agent gets deployed along with your application. Though, using NuGet requires some manual installation procedures. See Install with NuGet. Install using NuGet To install the .NET agent using NuGet: Follow the standard NuGet install procedures. When using NuGet, you must set some environment variables. This can be done in your application's ServiceManifest.xml file. See the relevant instructions below: .NET Framework In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage Name=\"Code\" Version=\"1.0.0\"> </CodePackage> <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"COR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"COR_PROFILER\" Value=\"{71DA0A04-7777-4EC6-9643-7D28B46A8A41}\" /> <EnvironmentVariable Name=\"COR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Windows In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Linux In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\"./newrelic/libNewRelicProfiler.so\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\"./newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy For the .NET Framework only: Edit your app.config file and add the NewRelic.AgentEnabled app setting: <appSettings> ... <add key=\"NewRelic.AgentEnabled\" value=\"true\" /> ... </appSettings> Copy If your application is generating traffic, data should appear in your APM account in several minutes. If data does not appear, try these troubleshooting steps: Make sure that all files in the newrelic directory at the root of your app was published to Azure. Make sure the environment variables are set correctly. See the general troubleshooting documentation to check for common errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.2791,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "This document explains how to install APM&#x27;s .<em>NET</em> Framework <em>agent</em> and .<em>NET</em> Core <em>agent</em> on <em>Azure</em> Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft <em>Azure</em>. Install .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric Important In most cases, installing the .<em>NET</em> <em>agent</em>"
      },
      "id": "6043c8a6e7b9d24fa25799bc"
    }
  ],
  "/docs/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services": [
    {
      "sections": [
        "Install the .NET agent on Azure Web Apps",
        "Installation options",
        "Disable Application Insights",
        "Install using the New Relic Azure Site Extension (Windows Only)",
        "Install using NuGet (.NET Framework)",
        "Install using NuGet (.NET Core)",
        "Log file configuration for Windows",
        "Log file configuration for Linux",
        "Environment variables for Windows",
        "Environment variables for Linux",
        "Add New Relic app settings to Azure App Services",
        "View your app's performance",
        "Troubleshooting"
      ],
      "title": "Install the .NET agent on Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "5cb6afb3ad05fdc243d2cf110f4df1e7e027740d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-web-apps/",
      "published_at": "2021-10-18T11:17:40Z",
      "updated_at": "2021-07-27T11:22:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install New Relic's .NET agent for application performance monitoring on your Azure Web App. (This is not the same as installing the infrastructure monitoring integrations for Microsoft Azure.) Recommendation: Before following these instructions, read the .NET agent installation overview. Installation options Use any of the following methods to add the New Relic .NET agent to your Azure-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, the easiest and most reliable option is to use the publicly maintained Azure site extension. Note: Azure Site Extensions are only currently available for Windows App Service Resources. Install using the Azure Site Extension For developer teams, or anyone needing to deploy the agent on a Linux App Service Resource, installing via nuget is the best option: Install using NuGet (.NET Framework) Install using NuGet (.NET Core) In order to monitor non-web apps (including WebJobs), or ASP.NET Core apps targeting .NET Framework, you must explicitly enable the agent for that application's .exe process via one of these two methods: Enable via placement of local newrelic.config file. Enable via application config file In addition, WebJobs may need custom instrumentation for transactions to appear in APM, and additional configuration if they run for less than one minute. Disable Application Insights Both New Relic's .NET agent and Microsoft Application Insights rely on the CLR Profiler, but only one may be active at a time. You must disable Application Insights in order for the .NET agent to function properly. For more information, see our Application Insights troubleshooting procedures. Install using the New Relic Azure Site Extension (Windows Only) To install the .NET agent for an Azure Web App using the New Relic Azure Site Extension: Shut down your web application before installing the New Relic Azure Site Extension. Add the site extension: Navigate to http://[yoursitename].scm.azurewebsites.net, then select Site extensions > Gallery. Select the plus icon next to the New Relic site extension. In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app to use the new version of the agent. Install using NuGet (.NET Framework) The NuGet installation method packages the New Relic Agent with your application so that it is available to the Azure Web App Host. The NuGet packages in this procedure support only the old packages.config. They do not support the current PackageReference format. For more information, see Microsoft's package reference documentation. For multi-project solutions, make sure you have selected the correct project (for example, a specific web app project) before installing the NuGet package. If you are upgrading the .NET Framework agent using NuGet, any changes you made in the newrelic.config will be overwritten. To preserve any changes, save your newrelic.config outside of your project, then restore it after upgrading. To install the .NET agent on an Azure Web App using NuGet: In the Azure portal, verify your Azure Platform (32-bit or 64-bit): From the Azure sidebar menu, select App Services > Your Application > Settings > Configuration > General settings. Open your application in Visual Studio, and install the New Relic NuGet package by running the appropriate command from the Package manager console: 32-bit: Install-Package NewRelic.Azure.WebSites 64-bit: Install-Package NewRelic.Azure.WebSites.x64 Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Key Value COR_ENABLE_PROFILING 1 COR_PROFILER {71DA0A04-7777-4EC6-9643-7D28B46A8A41} COR_PROFILER_PATH D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Install using NuGet (.NET Core) The NuGet installation method packages the New Relic Agent with your application so that it is available to the Azure Web App Host. New Relic .NET Core agent supports Linux and Windows applications on Azure App Services. The installation process for Azure App Services differs from the .NET Core agent installation procedures for Linux and Windows. To install the .NET agent on an Azure Web App using NuGet: Install the NewRelic.Agent NuGet package. Modify the log node by adding a directory attribute to your newrelic.config file (Note: If Visual Studio prevents you from editing the newrelic.config file that was added to your project by NuGet then you will need to make a local copy of this in your application): Log file configuration for Windows <log directory=\"D:\\Home\\LogFiles\\NewRelic\" level=\"info\"></log> Copy Log file configuration for Linux <log directory=\"/home/LogFiles/NewRelic\" level=\"info\"></log> Copy Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Environment variables for Windows Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH_32 D:\\Home\\site\\wwwroot\\newrelic\\x86\\NewRelic.Profiler.dll CORECLR_PROFILER_PATH_64 D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll CORECLR_NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic Environment variables for Linux Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH /home/site/wwwroot/newrelic/libNewRelicProfiler.so CORECLR_NEWRELIC_HOME /home/site/wwwroot/newrelic NEWRELIC_PROFILER_LOG_DIRECTORY /home/LogFiles/NewRelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Add New Relic app settings to Azure App Services To add your app settings: Make sure you have your license key before adding the New Relic .NET agent's app settings. In the Azure portal, open the web app you want to monitor, then select Configuration > Application settings. From Application settings, select + New application setting and add these key/value pairs: Key Value NEW_RELIC_LICENSE_KEY YOUR_LICENSE_KEY NEW_RELIC_APP_NAME YOUR_APP_NAME Save and restart your web app. Setting the license key and app name with Application settings will override the newrelic.config. To verify your app's environment variables in your app's Kudu diagnostic console, go to Environment > Environment variables. For example: https://myappname.scm.azurewebsites.net/Env.cshtml#envVariables Copy View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Web Apps. To view your app's performance in New Relic: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure portal by going to New Relic Accounts > (select your app). Troubleshooting If no data appears after installing the agent, generating traffic for your app, and waiting a few minutes, try these troubleshooting tips: Make sure that all files in the newrelic directory at the root of your app got published to Azure. Make sure the environment variables are set correctly. Make sure Microsoft Application Insights is not installed and configured on the application. For more information, see the Application Insights troubleshooting procedures. Refer to additional Azure troubleshooting procedures as applicable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.48631,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": " <em>installation</em> overview. <em>Installation</em> options Use any of the following methods to add the New Relic .<em>NET</em> <em>agent</em> to your <em>Azure</em>-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, the easiest and most"
      },
      "id": "603e8e7c28ccbc420ceba748"
    },
    {
      "sections": [
        "Install Azure Marketplace app with New Relic",
        "End of life notice",
        "Install New Relic .NET agent"
      ],
      "title": "Install Azure Marketplace app with New Relic",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "aef2e193486dd4993ae483d01735a03537b138b2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic/",
      "published_at": "2021-10-18T10:43:45Z",
      "updated_at": "2021-03-13T02:42:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "End of life notice As of October 2017 you cannot create a New Relic account through Microsoft's Azure Marketplace Portal. Instead, if you have an Azure ID but do not already have a New Relic account, contact New Relic Sales. For more information, see the Azure transition information in New Relic's Online Technical Community. Install New Relic .NET agent Continue with the procedures to install the New Relic .NET agent with your Azure app as applicable for: Microsoft's Web App Services in the Azure Portal Microsoft's Cloud Services platform The .NET agent's support for Microsoft Azure is not the same as Infrastructure monitoring's integrations with Azure. Azure integrations have separate integration installation procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.27942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Azure</em> Marketplace app with New Relic",
        "sections": "<em>Install</em> New Relic .<em>NET</em> <em>agent</em>",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&#x27;s Online Technical Community. Install New Relic .<em>NET</em> <em>agent</em> Continue with the procedures to install the New Relic .<em>NET</em> <em>agent</em> with your <em>Azure</em> app as applicable for: Microsoft&#x27;s Web App Services in the <em>Azure</em> Portal Microsoft&#x27;s Cloud Services platform The .<em>NET</em> <em>agent</em>&#x27;s support for Microsoft <em>Azure</em> is not the same as Infrastructure monitoring&#x27;s integrations with <em>Azure</em>. <em>Azure</em> integrations have separate integration <em>installation</em> procedures."
      },
      "id": "6043c3ade7b9d24ead5799b2"
    },
    {
      "sections": [
        "Install .NET agent on Azure Service Fabric",
        "Important",
        "Install using NuGet",
        ".NET Framework",
        ".NET Core for Windows",
        ".NET Core for Linux"
      ],
      "title": "Install .NET agent on Azure Service Fabric",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "c520de26567fd173a0ac7b19ac0044a5757862bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-service-fabric/",
      "published_at": "2021-10-18T11:17:40Z",
      "updated_at": "2021-03-13T02:21:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET Framework agent and .NET Core agent on Azure Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft Azure. Install .NET agent on Azure Service Fabric Important In most cases, installing the .NET agent in an Azure Service Fabric environment can be performed using the standard install procedures for either Windows or Linux. This document highlights some alternate ways you can install the agent. You will need to ensure the agent gets installed on all nodes in your cluster. To monitor multiple nodes, you may want to integrate the install into your deployment process. If you are using containers in your Service Fabric environment you should read Install for Docker. You can also install the agent in a Service Fabric environment using NuGet. NuGet is often a good option for developers because the agent gets deployed along with your application. Though, using NuGet requires some manual installation procedures. See Install with NuGet. Install using NuGet To install the .NET agent using NuGet: Follow the standard NuGet install procedures. When using NuGet, you must set some environment variables. This can be done in your application's ServiceManifest.xml file. See the relevant instructions below: .NET Framework In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage Name=\"Code\" Version=\"1.0.0\"> </CodePackage> <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"COR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"COR_PROFILER\" Value=\"{71DA0A04-7777-4EC6-9643-7D28B46A8A41}\" /> <EnvironmentVariable Name=\"COR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Windows In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Linux In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\"./newrelic/libNewRelicProfiler.so\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\"./newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy For the .NET Framework only: Edit your app.config file and add the NewRelic.AgentEnabled app setting: <appSettings> ... <add key=\"NewRelic.AgentEnabled\" value=\"true\" /> ... </appSettings> Copy If your application is generating traffic, data should appear in your APM account in several minutes. If data does not appear, try these troubleshooting steps: Make sure that all files in the newrelic directory at the root of your app was published to Azure. Make sure the environment variables are set correctly. See the general troubleshooting documentation to check for common errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.2791,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "This document explains how to install APM&#x27;s .<em>NET</em> Framework <em>agent</em> and .<em>NET</em> Core <em>agent</em> on <em>Azure</em> Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft <em>Azure</em>. Install .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric Important In most cases, installing the .<em>NET</em> <em>agent</em>"
      },
      "id": "6043c8a6e7b9d24fa25799bc"
    }
  ],
  "/docs/agents/net-agent/azure-installation/install-net-agent-azure-service-fabric": [
    {
      "sections": [
        "Install the .NET agent on Azure Web Apps",
        "Installation options",
        "Disable Application Insights",
        "Install using the New Relic Azure Site Extension (Windows Only)",
        "Install using NuGet (.NET Framework)",
        "Install using NuGet (.NET Core)",
        "Log file configuration for Windows",
        "Log file configuration for Linux",
        "Environment variables for Windows",
        "Environment variables for Linux",
        "Add New Relic app settings to Azure App Services",
        "View your app's performance",
        "Troubleshooting"
      ],
      "title": "Install the .NET agent on Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "5cb6afb3ad05fdc243d2cf110f4df1e7e027740d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-web-apps/",
      "published_at": "2021-10-18T11:17:40Z",
      "updated_at": "2021-07-27T11:22:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install New Relic's .NET agent for application performance monitoring on your Azure Web App. (This is not the same as installing the infrastructure monitoring integrations for Microsoft Azure.) Recommendation: Before following these instructions, read the .NET agent installation overview. Installation options Use any of the following methods to add the New Relic .NET agent to your Azure-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, the easiest and most reliable option is to use the publicly maintained Azure site extension. Note: Azure Site Extensions are only currently available for Windows App Service Resources. Install using the Azure Site Extension For developer teams, or anyone needing to deploy the agent on a Linux App Service Resource, installing via nuget is the best option: Install using NuGet (.NET Framework) Install using NuGet (.NET Core) In order to monitor non-web apps (including WebJobs), or ASP.NET Core apps targeting .NET Framework, you must explicitly enable the agent for that application's .exe process via one of these two methods: Enable via placement of local newrelic.config file. Enable via application config file In addition, WebJobs may need custom instrumentation for transactions to appear in APM, and additional configuration if they run for less than one minute. Disable Application Insights Both New Relic's .NET agent and Microsoft Application Insights rely on the CLR Profiler, but only one may be active at a time. You must disable Application Insights in order for the .NET agent to function properly. For more information, see our Application Insights troubleshooting procedures. Install using the New Relic Azure Site Extension (Windows Only) To install the .NET agent for an Azure Web App using the New Relic Azure Site Extension: Shut down your web application before installing the New Relic Azure Site Extension. Add the site extension: Navigate to http://[yoursitename].scm.azurewebsites.net, then select Site extensions > Gallery. Select the plus icon next to the New Relic site extension. In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app to use the new version of the agent. Install using NuGet (.NET Framework) The NuGet installation method packages the New Relic Agent with your application so that it is available to the Azure Web App Host. The NuGet packages in this procedure support only the old packages.config. They do not support the current PackageReference format. For more information, see Microsoft's package reference documentation. For multi-project solutions, make sure you have selected the correct project (for example, a specific web app project) before installing the NuGet package. If you are upgrading the .NET Framework agent using NuGet, any changes you made in the newrelic.config will be overwritten. To preserve any changes, save your newrelic.config outside of your project, then restore it after upgrading. To install the .NET agent on an Azure Web App using NuGet: In the Azure portal, verify your Azure Platform (32-bit or 64-bit): From the Azure sidebar menu, select App Services > Your Application > Settings > Configuration > General settings. Open your application in Visual Studio, and install the New Relic NuGet package by running the appropriate command from the Package manager console: 32-bit: Install-Package NewRelic.Azure.WebSites 64-bit: Install-Package NewRelic.Azure.WebSites.x64 Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Key Value COR_ENABLE_PROFILING 1 COR_PROFILER {71DA0A04-7777-4EC6-9643-7D28B46A8A41} COR_PROFILER_PATH D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Install using NuGet (.NET Core) The NuGet installation method packages the New Relic Agent with your application so that it is available to the Azure Web App Host. New Relic .NET Core agent supports Linux and Windows applications on Azure App Services. The installation process for Azure App Services differs from the .NET Core agent installation procedures for Linux and Windows. To install the .NET agent on an Azure Web App using NuGet: Install the NewRelic.Agent NuGet package. Modify the log node by adding a directory attribute to your newrelic.config file (Note: If Visual Studio prevents you from editing the newrelic.config file that was added to your project by NuGet then you will need to make a local copy of this in your application): Log file configuration for Windows <log directory=\"D:\\Home\\LogFiles\\NewRelic\" level=\"info\"></log> Copy Log file configuration for Linux <log directory=\"/home/LogFiles/NewRelic\" level=\"info\"></log> Copy Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Environment variables for Windows Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH_32 D:\\Home\\site\\wwwroot\\newrelic\\x86\\NewRelic.Profiler.dll CORECLR_PROFILER_PATH_64 D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll CORECLR_NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic Environment variables for Linux Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH /home/site/wwwroot/newrelic/libNewRelicProfiler.so CORECLR_NEWRELIC_HOME /home/site/wwwroot/newrelic NEWRELIC_PROFILER_LOG_DIRECTORY /home/LogFiles/NewRelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Add New Relic app settings to Azure App Services To add your app settings: Make sure you have your license key before adding the New Relic .NET agent's app settings. In the Azure portal, open the web app you want to monitor, then select Configuration > Application settings. From Application settings, select + New application setting and add these key/value pairs: Key Value NEW_RELIC_LICENSE_KEY YOUR_LICENSE_KEY NEW_RELIC_APP_NAME YOUR_APP_NAME Save and restart your web app. Setting the license key and app name with Application settings will override the newrelic.config. To verify your app's environment variables in your app's Kudu diagnostic console, go to Environment > Environment variables. For example: https://myappname.scm.azurewebsites.net/Env.cshtml#envVariables Copy View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Web Apps. To view your app's performance in New Relic: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure portal by going to New Relic Accounts > (select your app). Troubleshooting If no data appears after installing the agent, generating traffic for your app, and waiting a few minutes, try these troubleshooting tips: Make sure that all files in the newrelic directory at the root of your app got published to Azure. Make sure the environment variables are set correctly. Make sure Microsoft Application Insights is not installed and configured on the application. For more information, see the Application Insights troubleshooting procedures. Refer to additional Azure troubleshooting procedures as applicable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.48631,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": " <em>installation</em> overview. <em>Installation</em> options Use any of the following methods to add the New Relic .<em>NET</em> <em>agent</em> to your <em>Azure</em>-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, the easiest and most"
      },
      "id": "603e8e7c28ccbc420ceba748"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Cloud Services",
        "Important",
        "Check Web or Worker role's location",
        "Install the NuGet package for Cloud Services",
        "Instrument Worker role",
        "Custom instrumentation example for Worker role",
        "Custom instrumentation file deployment",
        "Optional: Create custom config file",
        "View your app's performance"
      ],
      "title": "Install the .NET agent on Azure Cloud Services",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "afe3e181b9ec18fa0b2be3e76f7c9b20d247d21e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services/",
      "published_at": "2021-10-18T11:16:49Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET agent on Microsoft's Azure Cloud Services platform. This is not the same as installing the Infrastructure integrations for Microsoft Azure. To make sure you are using the most relevant instructions, first see the .NET agent install overview. Important Before installing the NuGet package into a multi-project Visual Studio solution, make sure you have selected the correct project for your New Relic .NET application (for example, a specific website project). Check Web or Worker role's location If Service files are nested within a Solution folder, the NuGet installer cannot locate or update the necessary files. This will cause issues with the .NET agent setup, which will in turn prevent the agent from reporting metrics on your Cloud Service. Recommendation: Place the Web or Worker role at the root of the solution before installing the NuGet package. Once the New Relic .NET agent is installed, you can move the Cloud role back into the Solution folder. Install the NuGet package for Cloud Services Important The NuGet packages in this procedure support only the old packages.config. They do not support the new PackageReference format. For more information see Microsoft's package reference documentation For multi-project solutions, make sure you have selected the correct project (for example, a specific website project) before installing the NuGet package. Open your Visual Studio solution, or create a new one by selecting File > New > Project. For multi-project solutions, make sure you have selected the correct project (for example, a specific website project). If you do not already have an Azure Cloud Service project in your solution, add one by right-clicking your app in the Solution Explorer and selecting Add Windows Azure Cloud Service Project. Open the Package Manager console by selecting Tools > Library Package Manager > Package Manager Console. Set your project as the default project. From the Package Manager command prompt, type Install-Package NewRelicWindowsAzure and press Enter. Follow the prompts to enter your New Relic license key and your application name as you want it to appear in the New Relic UI. Or, use your solution name as the default app name. From the Solution Explorer, right-click your Azure Cloud Service project, and select Publish. If this is your first time deploying this app to Azure, enter your Azure credentials. If applicable, instrument methods for Worker roles. Instrument Worker role A Worker role is a non-web process run as an Azure Cloud Service. To instrument a Worker role, you must create custom transactions. The .NET agent automatically instruments external calls and database calls, but it does not instrument default methods for transactions. Creating custom transactions solves this. After the Worker role starts up and the method executes, transaction data will appear in the APM Summary and Transactions pages under the Non-web category. The NuGet installer automatically adds the NewRelic.AppName parameter to the application config. This appears as <YOUR_WORKER_ROLE_NAME>.dll.config in E:\\approot. The .NET agent also automatically instruments WaWorkerHost.exe. This is the name of the actual Worker role process. Custom instrumentation example for Worker role This is a custom instrumentation example for a Worker role. It creates a custom transaction named ProcessMessage. The transaction begins when the ProcessMessage method is entered, and it ends when the method returns. The following example uses MyWorkerRole as the namespace. If you do not specify a name, it will default to the Solution name. namespace MyWorkerRole { public class NotificationQueue { public bool ProcessMessage(Message message) { // code to process message } } } Copy Here is the custom instrumentation file for the code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerfactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Custom/ProcessMessage\"> <match assemblyname=\"MyWorkerRole\" classname=\"MyWorkerRole.NotificationQueue\"> <exactmethodmatcher methodName=\"ProcessMessage\" /> </match> </tracerfactory> </instrumentation> </extension> Copy On a local installation, place this instrumentation file in C:\\ProgramData\\New Relic\\.NET Agent\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an Azure Cloud Service deployment: In your Azure Cloud project, add the instrumentation file to your Worker role inside the Roles folder. After installing the New Relic .NET agent NuGet package, locate newrelic.cmd in your Worker Role project. Find the statement IF %ERRORLEVEL% EQU 0 within the :INSTALL_NEWRELIC_AGENT block, and add the following statement to the conditional: IF %ERRORLEVEL% EQU 0 ( copy /Y \"%RoleRoot%\\approot\\MyInstrumentation.xml\" \"%NR_HOME%\\extensions\" >> %RoleRoot%\\nr.log ) ELSE ( Copy In this example, the newrelic.cmd batch file copies the custom instrumentation file to the Extensions folder in D:\\ProgramData\\New Relic\\.NET Agent\\, or %NR_HOME%. This example uses MyInstrumentation.xml, but any name will work as long as the file name and copy command match, and the file is valid XML. Optional: Create custom config file You can create a custom configuration file in Visual Studio. This allows you to make changes to newrelic.config inside Visual Studio, without having to remote into your Azure Role instance every time you make a change. Whenever you publish your app, the config file in Visual Studio is automatically uploaded to the remote host. The choices you make with the installation wizard do not matter. Installing locally does not affect your Azure development environment. In Visual Studio, select the Solution Explorer, then open NewRelicAgent_x64_XYZ.msi. Follow the steps to install the agent locally. Import newrelic.config into your project: In Solution Explorer > Cloud Project, right-click the Web Role, then select Add > Existing Item. Navigate to C: \\ ProgramData \\ New Relic \\ .NET Agent and select newrelic.config. From C: \\ ProgramData \\ New Relic \\ .NET Agent, edit newrelic.cmd. In the :INSTALL_NEWRELIC_AGENT section, find this statement: IF $ERRORLEVEL% EQU 0 ( Copy Add the following code as another statement inside the IF block, then save the file: copy /Y \"%RoleRoot%\\approot\\newrelic.config\" \"%NR_HOME%\" >> %RoleRoot%\\nr.log Copy You can now edit the newrelic.config hosted in Visual Studio. Whenever you publish your app, the copy command will upload the config file to the remote host. View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Cloud Services. To view your app's performance in APM: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure Portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure Portal by going to New Relic Accounts > choose your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.35572,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&gt; &lt;&#x2F;tracerfactory&gt; &lt;&#x2F;instrumentation&gt; &lt;&#x2F;extension&gt; Copy On a local <em>installation</em>, place this instrumentation file in C:\\ProgramData\\New Relic\\.<em>NET</em> <em>Agent</em>\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an <em>Azure</em> Cloud Service deployment: In your"
      },
      "id": "603e8e7ee7b9d2b4d42a07e3"
    },
    {
      "sections": [
        "Install Azure Marketplace app with New Relic",
        "End of life notice",
        "Install New Relic .NET agent"
      ],
      "title": "Install Azure Marketplace app with New Relic",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "aef2e193486dd4993ae483d01735a03537b138b2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic/",
      "published_at": "2021-10-18T10:43:45Z",
      "updated_at": "2021-03-13T02:42:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "End of life notice As of October 2017 you cannot create a New Relic account through Microsoft's Azure Marketplace Portal. Instead, if you have an Azure ID but do not already have a New Relic account, contact New Relic Sales. For more information, see the Azure transition information in New Relic's Online Technical Community. Install New Relic .NET agent Continue with the procedures to install the New Relic .NET agent with your Azure app as applicable for: Microsoft's Web App Services in the Azure Portal Microsoft's Cloud Services platform The .NET agent's support for Microsoft Azure is not the same as Infrastructure monitoring's integrations with Azure. Azure integrations have separate integration installation procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.27942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Azure</em> Marketplace app with New Relic",
        "sections": "<em>Install</em> New Relic .<em>NET</em> <em>agent</em>",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&#x27;s Online Technical Community. Install New Relic .<em>NET</em> <em>agent</em> Continue with the procedures to install the New Relic .<em>NET</em> <em>agent</em> with your <em>Azure</em> app as applicable for: Microsoft&#x27;s Web App Services in the <em>Azure</em> Portal Microsoft&#x27;s Cloud Services platform The .<em>NET</em> <em>agent</em>&#x27;s support for Microsoft <em>Azure</em> is not the same as Infrastructure monitoring&#x27;s integrations with <em>Azure</em>. <em>Azure</em> integrations have separate integration <em>installation</em> procedures."
      },
      "id": "6043c3ade7b9d24ead5799b2"
    }
  ]
}